void CFMessagePortSetDispatchQueue(CFMessagePortRef ms, dispatch_queue_t queue)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFStringRef v19;
  char v20;
  dispatch_source_s *v21;
  void *v22;
  unsigned int Port;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  dispatch_semaphore_t v31;
  dispatch_source_s *v32;
  uint64_t v33;
  uint64_t v34[6];
  unsigned int v35;
  void handler[7];
  unsigned int v37;
  uint64_t v38;
  v38 = *MEMORY[0x1895F89C0];
  v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  v12 = atomic_load((unint64_t *)ms + 1);
  if ((v12 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort is invalid";
LABEL_8:
    CFLog(4LL, (uint64_t)v19, v13, v14, v15, v16, v17, v18, v34[0]);
    return;
  }

  v20 = atomic_load((unint64_t *)ms + 1);
  if ((v20 & 4) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort is not a local port, queue cannot be set";
    goto LABEL_8;
  }

  if (*((void *)ms + 7))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = @"*** CFMessagePortSetDispatchQueue(): CFMessagePort already has a CFRunLoopSourceRef, queue cannot be set";
    goto LABEL_8;
  }

  v22 = (void *)((char *)ms + 64);
  v21 = (dispatch_source_s *)*((void *)ms + 8);
  if (v21)
  {
    dispatch_source_cancel(v21);
    *v22 = 0LL;
    *((void *)ms + 9) = 0LL;
  }

  if (queue)
  {
    Port = __CFMessagePortGetPort((uint64_t)ms, v5, v6, v7, v8, v9, v10, v11);
    if (Port)
    {
      v30 = Port;
      if (CFMessagePortSetDispatchQueue_once != -1) {
        dispatch_once(&CFMessagePortSetDispatchQueue_once, &__block_literal_global_6);
      }
      v31 = dispatch_semaphore_create(0LL);
      dispatch_retain(v31);
      *((void *)ms + 10) = v31;
      _cfmp_record_intent_to_invalidate(1, v30);
      v32 = dispatch_source_create( MEMORY[0x1895F8B40],  v30,  0LL,  (dispatch_queue_t)CFMessagePortSetDispatchQueue_mportQueue);
      v33 = MEMORY[0x1895F87A8];
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 0x40000000LL;
      handler[2] = __CFMessagePortSetDispatchQueue_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_16;
      handler[4] = queue;
      handler[5] = v32;
      v37 = v30;
      handler[6] = v31;
      dispatch_source_set_cancel_handler(v32, handler);
      v34[0] = v33;
      v34[1] = 0x40000000LL;
      v34[2] = (uint64_t)__CFMessagePortSetDispatchQueue_block_invoke_3;
      v34[3] = (uint64_t)&__block_descriptor_tmp_18;
      v35 = v30;
      v34[4] = (uint64_t)ms;
      v34[5] = (uint64_t)queue;
      dispatch_source_set_event_handler(v32, v34);
      *((void *)ms + 8) = v32;
      if (v32) {
        goto LABEL_16;
      }
    }

    else if (*v22)
    {
LABEL_16:
      dispatch_retain(queue);
      *((void *)ms + 9) = queue;
      dispatch_resume(*((dispatch_object_t *)ms + 8));
      goto LABEL_19;
    }

    CFLog( 4LL,  (uint64_t)@"*** CFMessagePortSetDispatchQueue(): dispatch source could not be created",  v24,  v25,  v26,  v27,  v28,  v29,  v34[0]);
  }

dispatch_queue_t __CFMessagePortSetDispatchQueue_block_invoke()
{
  qos_class_t v0 = qos_class_main();
  v1 = dispatch_queue_attr_make_with_qos_class(0LL, v0, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.CFMessagePort", v1);
  CFMessagePortSetDispatchQueue_mportQueue = (uint64_t)result;
  return result;
}

void __CFMessagePortSetDispatchQueue_block_invoke_2(uint64_t a1)
{
}

void __CFMessagePortSetDispatchQueue_block_invoke_3(uint64_t a1)
{
  mach_msg_return_t v5;
  dispatch_queue_s *v6;
  uint64_t v7;
  void block[7];
  block[6] = *MEMORY[0x1895F89C0];
  CFRetain(*(CFTypeRef *)(a1 + 32));
  mach_msg_size_t v2 = 2048;
  v3 = (mach_msg_header_t *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2048LL, 0LL);
  for (v3->msgh_size = 2048; ; v3->msgh_size = v2)
  {
    v3->msgh_bits = 0;
    mach_port_t v4 = *(_DWORD *)(a1 + 48);
    v3->msgh_remote_port = 0;
    v3->msgh_local_port = v4;
    v3->msgh_id = 0;
    v5 = mach_msg(v3, 117440518, 0, v2, *(_DWORD *)(a1 + 48), 0, 0);
    if (v5 != 268451844) {
      break;
    }
    mach_msg_size_t v2 = (v3->msgh_size + 71) & 0xFFFFFFFC;
    v3 = (mach_msg_header_t *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v3,  v2,  0LL,  0LL);
  }

  if (v5) {
    __break(1u);
  }
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __CFMessagePortSetDispatchQueue_block_invoke_4;
  block[3] = &__block_descriptor_tmp_17;
  v7 = *(void *)(a1 + 32);
  v6 = *(dispatch_queue_s **)(a1 + 40);
  block[4] = v3;
  block[5] = v7;
  dispatch_async(v6, block);
}

void __CFMessagePortSetDispatchQueue_block_invoke_4(uint64_t a1)
{
  mach_msg_return_t v4;
  mach_msg_size_t v2 = (mach_msg_header_t *)__CFMessagePortPerform( *(int **)(a1 + 32),  *(unsigned int *)(*(void *)(a1 + 32) + 4LL),  (const __CFAllocator *)&__kCFAllocatorSystemDefault,  *(void *)(a1 + 40));
  if (v2)
  {
    v3 = v2;
    mach_port_t v4 = mach_msg(v2, 1, v2->msgh_size, 0, 0, 0, 0);
    __CFMachMessageCheckForAndDestroyUnsentMessage(v4, v3);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3);
  }

  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(void **)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void OUTLINED_FUNCTION_0_7( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void __CFNotificationCenterDeallocate(uint64_t a1)
{
  *(void *)(a1 + 16) = 0LL;
  mach_msg_size_t v2 = *(_xpc_connection_s **)(a1 + 24);
  if (v2)
  {
    xpc_connection_cancel(v2);
    xpc_release(*(xpc_object_t *)(a1 + 24));
  }

CFTypeID CFNotificationCenterGetTypeID(void)
{
  return 52LL;
}

uint64_t _CFXNotificationCenterCreate( const __CFAllocator *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v43[5] = *MEMORY[0x1895F89C0];
  if (*a2 == 1)
  {
    if ((__CF_FORK_STATE & 2) == 0) {
      __CF_USED();
    }
    if ((__CF_FORK_STATE & 1) != 0) {
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
    if ((__CF_FORK_STATE & 1) != 0) {
      return 0LL;
    }
  }

  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x34uLL, 16LL, 0LL, a5, a6, a7, a8);
  uint64_t v17 = Instance;
  if (Instance)
  {
    int v18 = *a2;
    if (*a2 != 1) {
      goto LABEL_17;
    }
    v19 = (unint64_t *)(Instance + 8);
    unint64_t v20 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v21 = __ldaxr(v19);
      if (v21 != v20) {
        break;
      }
      if (__stlxr(v20 | 2, v19)) {
        goto LABEL_14;
      }
      int v22 = 1;
LABEL_15:
      unint64_t v20 = v21;
      if (v22)
      {
        int v18 = *a2;
LABEL_17:
        if (v18 == 2)
        {
          v23 = (unint64_t *)(Instance + 8);
          unint64_t v24 = atomic_load((unint64_t *)(Instance + 8));
          while (1)
          {
            unint64_t v25 = __ldaxr(v23);
            if (v25 != v24) {
              break;
            }
            if (__stlxr(v24 | 1, v23)) {
              goto LABEL_23;
            }
            int v26 = 1;
LABEL_24:
            unint64_t v24 = v25;
            if (v26) {
              goto LABEL_25;
            }
          }

          __clrex();
LABEL_23:
          int v26 = 0;
          goto LABEL_24;
        }

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  }
  return (CFNotificationCenterRef)__taskCenter;
}

uint64_t __CFNotificationCenterGetLocalCenter_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _CFXNotificationCenterCreate( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  _kCFXNotificationConfigurationStandardLocalConfiguration,  a3,  a4,  a5,  a6,  a7,  a8);
  __taskCenter = result;
  return result;
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  if (CFNotificationCenterGetDistributedCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetDistributedCenter_static_init, &__block_literal_global_10);
  }
  return (CFNotificationCenterRef)__hostCenter;
}

uint64_t __CFNotificationCenterGetDistributedCenter_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _CFXNotificationCenterCreate( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  _kCFXNotificationConfigurationStandardDistributedConfiguration,  a3,  a4,  a5,  a6,  a7,  a8);
  __hostCenter = result;
  return result;
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  if (CFNotificationCenterGetDarwinNotifyCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetDarwinNotifyCenter_static_init, &__block_literal_global_11);
  }
  return (CFNotificationCenterRef)__darwinCenter;
}

uint64_t __CFNotificationCenterGetDarwinNotifyCenter_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _CFXNotificationCenterCreate( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  _kCFXNotificationConfigurationStandardDarwinConfiguration,  a3,  a4,  a5,  a6,  a7,  a8);
  __darwinCenter = result;
  return result;
}

uint64_t _CFXNotificationGetTaskCenter()
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1) {
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  }
  return __taskCenter;
}

CFMutableStringRef _CFXNotificationCenterCopyDebugInfo(uint64_t a1)
{
  v5[6] = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  v3 = *(os_unfair_lock_s **)(a1 + 16);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___CFXNotificationCenterCopyDebugInfo_block_invoke;
  v5[3] = &__block_descriptor_48_e80_v16__0___CFXNotificationRegistration_____CFString__v_vQ_________v_____Q___i_Q__8l;
  v5[4] = Mutable;
  v5[5] = a1;
  CFXNotificationRegistrarEnumerate(v3, (uint64_t)v5);
  return Mutable;
}

void _CFNotificationCenterRegisterDependentNotificationList(__CFString ****a1)
{
  uint64_t v2 = 0LL;
  while ((&_unprocessedDependentNotificationLists)[v2])
  {
    if (++v2 == 8) {
      _CFNotificationCenterRegisterDependentNotificationList_cold_1();
    }
  }

  (&_unprocessedDependentNotificationLists)[v2] = a1;
  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
}

void _CFNotificationCenterInitializeDependentNotificationIfNecessary(uint64_t a1)
{
  v11[1] = *MEMORY[0x1895F89C0];
  v11[0] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_dependentNotificationLock);
  for (uint64_t i = 0LL; i != 8; ++i)
  {
    uint64_t v2 = (const void **)(&_unprocessedDependentNotificationLists)[i];
    if (!v2) {
      break;
    }
    v3 = *v2;
    if (*v2)
    {
      mach_port_t v4 = v2 + 1;
      do
      {
        v5 = (__CFSet *)_dependentNotifications;
        if (!_dependentNotifications)
        {
          memset(&callBacks, 0, 32);
          *(_OWORD *)&callBacks.equal = xmmword_18999B0A0;
          v5 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &callBacks);
          _dependentNotifications = (uint64_t)v5;
        }

        CFSetAddValue(v5, v3);
        v6 = *v4++;
        v3 = v6;
      }

      while (v6);
    }

    (&_unprocessedDependentNotificationLists)[i] = 0LL;
  }

  memset(&callBacks.retain, 0, sizeof(CFSetCallBacks));
  callBacks.version = (CFIndex)v11;
  Value = CFSetGetValue((CFSetRef)_dependentNotifications, &callBacks);
  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
  if (Value)
  {
    v8 = (dispatch_once_t *)*((void *)Value + 1);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___CFNotificationCenterInitializeDependentNotificationIfNecessary_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = Value;
    if (*v8 != -1) {
      dispatch_once(v8, block);
    }
  }

uint64_t _CFXNotificationRegisterObserver( CFIndex a1, const __CFString *a2, __CFString *a3, unint64_t a4, __CFString *a5, void *a6, const void *a7)
{
  unint64_t v10 = a4;
  uint64_t v42 = *MEMORY[0x1895F89C0];
  char v14 = atomic_load((unint64_t *)(a1 + 8));
  if ((v14 & 1) == 0)
  {
    __int16 v15 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v10 = ~(v15 << 11) & 0x1000 | a4;
  }

  if (!a2 || !a3 || !a5 || a5 == @"kCFNotificationAnyObserver") {
    __break(1u);
  }
  char v16 = atomic_load((unint64_t *)(a1 + 8));
  if ((v16 & 2) != 0 && (__CFIsDistNoteDaemon & 1) != 0) {
    return 0LL;
  }
  if ((v10 & 0x400) != 0)
  {
    Class = object_getClass(a5);
    if (class_isMetaClass(Class)) {
      v10 &= ~0x400uLL;
    }
    if ((v10 & 0x400) != 0) {
      objc_opt_self();
    }
  }

  _CFNotificationCenterInitializeDependentNotificationIfNecessary((uint64_t)a2);
  uint64_t v17 = CFXNotificationRegistrarAdd(*(void *)(a1 + 16), a2, a3, a5, v10, a6, a7);
  int out_token = 0;
  v19 = (void *)_CFAutoreleasePoolPush();
  char v20 = atomic_load((unint64_t *)(a1 + 8));
  if ((v20 & 1) != 0)
  {
    maxBufLen[0] = 0LL;
    v47.length = CFStringGetLength(a2);
    v47.location = 0LL;
    CFStringGetBytes(a2, v47, 0x8000100u, 0, 0, 0LL, 0LL, maxBufLen);
    v34 = (UInt8 *)malloc(maxBufLen[0] + 1);
    v48.length = CFStringGetLength(a2);
    v48.location = 0LL;
    CFStringGetBytes(a2, v48, 0x8000100u, 0, 0, v34, maxBufLen[0], 0LL);
    v34[maxBufLen[0]] = 0;
    if (__CFXNotificationCenterDarwinQueue_initOnce != -1) {
      dispatch_once(&__CFXNotificationCenterDarwinQueue_initOnce, &__block_literal_global_97);
    }
    maxBufLen[0] = MEMORY[0x1895F87A8];
    maxBufLen[1] = 3221225472LL;
    maxBufLen[2] = (CFIndex)____CFXNotificationRegisterObserver_block_invoke;
    maxBufLen[3] = (CFIndex)&__block_descriptor_48_e8_v12__0i8l;
    maxBufLen[4] = a1;
    maxBufLen[5] = v17;
    uint32_t v35 = notify_register_dispatch( (const char *)v34,  &out_token,  (dispatch_queue_t)__CFXNotificationCenterDarwinQueue_queue,  maxBufLen);
    CFXNotificationRegisteredObserverSetNotifyToken(*(void *)(a1 + 16), v17, out_token);
    free(v34);
    if (v35) {
      uint64_t v17 = 0LL;
    }
  }

  else
  {
    char v21 = atomic_load((unint64_t *)(a1 + 8));
    if ((v21 & 2) != 0)
    {
      maxBufLen[0] = 0LL;
      v43.length = CFStringGetLength(a2);
      v43.location = 0LL;
      CFStringGetBytes(a2, v43, 0x8000100u, 0, 0, 0LL, 0LL, maxBufLen);
      int v22 = (UInt8 *)malloc(maxBufLen[0] + 1);
      v44.length = CFStringGetLength(a2);
      v44.location = 0LL;
      CFStringGetBytes(a2, v44, 0x8000100u, 0, 0, v22, maxBufLen[0], 0LL);
      v22[maxBufLen[0]] = 0;
      maxBufLen[0] = 0LL;
      v45.length = CFStringGetLength(a3);
      v45.location = 0LL;
      CFStringGetBytes(a3, v45, 0x8000100u, 0, 0, 0LL, 0LL, maxBufLen);
      v23 = (UInt8 *)malloc(maxBufLen[0] + 1);
      v46.length = CFStringGetLength(a3);
      v46.location = 0LL;
      CFStringGetBytes(a3, v46, 0x8000100u, 0, 0, v23, maxBufLen[0], 0LL);
      v23[maxBufLen[0]] = 0;
      int v24 = strcmp("kCFNotificationAnyName", (const char *)v22);
      if (v24 | strcmp("kCFNotificationAnyObject", (const char *)v23) || (getpid(), !sandbox_check()))
      {
        int v33 = 1;
      }

      else
      {
        uint64_t v31 = __CFGenerateReport();
        uint64_t v32 = "\n\n";
        if (!v31) {
          uint64_t v32 = "";
        }
        CFLog( 4LL,  (uint64_t)@"*** attempt to register for all distributed notifications thwarted by sandboxing.%s%s",  v25,  v26,  v27,  v28,  v29,  v30,  (uint64_t)v32);
        free(v31);
        int v33 = 0;
      }

      xpc_object_t v36 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_string(v36, "method", "register");
      xpc_dictionary_set_uint64(v36, "version", 1uLL);
      xpc_dictionary_set_string(v36, "name", (const char *)v22);
      xpc_dictionary_set_string(v36, "object", (const char *)v23);
      xpc_dictionary_set_uint64(v36, "options", v10 & 0xFFFFFFFFFFFFDBFFLL);
      xpc_dictionary_set_uint64(v36, "token", v17);
      qos_class_t v37 = _CFGetProcessPath();
      xpc_dictionary_set_string(v36, "pn", (const char *)*v37);
      CFXNotificationRegisteredObserverSetDistributedConnection(*(void *)(a1 + 16), v17, *(void **)(a1 + 24));
      if (v33)
      {
        v38 = *(_xpc_connection_s **)(a1 + 24);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(v38, v36);
        xpc_connection_send_barrier(v38, &__block_literal_global_99);
      }

      xpc_release(v36);
      free(v23);
      free(v22);
    }
  }

  _CFAutoreleasePoolPop(v19);
  return v17;
}

void _CFXNotificationCancelToken(uint64_t a1, uint64_t a2)
{
}

unint64_t *_CFXNotificationRemoveObservers( unint64_t *result, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  if (a2 && a3 && a4)
  {
    v7 = result;
    v8 = result + 1;
    char v9 = atomic_load(result + 1);
    if ((v9 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
    {
      unint64_t v10 = (void *)_CFAutoreleasePoolPush();
      char v11 = atomic_load(v8);
      if ((v11 & 1) != 0) {
        uint64_t v12 = @"kCFNotificationAnyObject";
      }
      else {
        uint64_t v12 = a3;
      }
      CFXNotificationRegistrarRemove(v7[2], a2, v12, a4);
      return (unint64_t *)_CFAutoreleasePoolPop(v10);
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

void _CFXNotificationPost(unint64_t *a1, void *a2, uint64_t a3)
{
  v47[32] = *MEMORY[0x1895F89C0];
  char v6 = atomic_load(a1 + 1);
  if ((v6 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
  {
    v7 = (const __CFString *)[a2 name];
    uint64_t v8 = [a2 object];
    if (v8) {
      char v9 = (const __CFString *)v8;
    }
    else {
      char v9 = @"kCFNotificationAnyObject";
    }
    if (!a2 || !v7)
    {
      __break(1u);
      return;
    }

    unint64_t v10 = (void *)_CFAutoreleasePoolPush();
    char v11 = v10;
    char v12 = atomic_load(a1 + 1);
    if ((a3 & 0x100000) == 0 && (v12 & 1) != 0)
    {
      v47[0] = 0LL;
      v48.length = CFStringGetLength(v7);
      v48.location = 0LL;
      CFStringGetBytes(v7, v48, 0x8000100u, 0, 0, 0LL, 0LL, v47);
      uint64_t v13 = (UInt8 *)malloc(v47[0] + 1);
      v49.length = CFStringGetLength(v7);
      v49.location = 0LL;
      CFStringGetBytes(v7, v49, 0x8000100u, 0, 0, v13, v47[0], 0LL);
      v13[v47[0]] = 0;
      notify_post((const char *)v13);
      free(v13);
LABEL_11:
      _CFAutoreleasePoolPop(v11);
      return;
    }

    char v14 = atomic_load(a1 + 1);
    if ((a3 & 0x100000) != 0 || (v14 & 2) == 0)
    {
      uint64_t v17 = _CFAutoreleasePoolPop(v10);
      memset(v47, 0, 256);
      MEMORY[0x1895F8858](v17, v18);
      v44[0] = 0x2000000000LL;
      CFRange v45 = &v46;
      CFXNotificationRegistrarFind(a1[2], v7, v9, (unsigned int *)v44);
      if (LODWORD(v44[0]) < 0x21)
      {
        if (!LODWORD(v44[0]))
        {
          _CFXNotificationRegistrationBufferDestroy((unsigned int *)v44);
          return;
        }

        v19 = v47;
      }

      else
      {
        v19 = (CFIndex *)malloc(8LL * LODWORD(v44[0]));
      }

      uint64_t v20 = 0LL;
      unint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      do
      {
        if (CFXNotificationRegistrarValidateToken(a1[2], v45[v20 + 6]))
        {
          v23 = _CFXRegistrationPost(a1, (uint64_t)&v45[v20], 0, (uint64_t)a2, (void *)v45[v20 + 2]);
          if (v23) {
            v19[v22++] = (CFIndex)v23;
          }
        }

        ++v21;
        v20 += 8LL;
      }

      while (v21 < LODWORD(v44[0]));
      _CFXNotificationRegistrationBufferDestroy((unsigned int *)v44);
      if (v22 >= 1)
      {
        int v24 = (void **)v19;
        do
        {
          uint64_t v25 = *v24++;
          [v25 waitUntilFinished];

          --v22;
        }

        while (v22);
      }

      if (v19 != v47) {
        free(v19);
      }
    }

    else
    {
      __int16 v15 = (const void *)[a2 userInfo];
      if (v15)
      {
        CFDataRef Data = CFPropertyListCreateData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v15,  kCFPropertyListBinaryFormat_v1_0,  0LL,  0LL);
        if (!Data)
        {
          _CFAutoreleasePoolPop(v11);
          return;
        }
      }

      else
      {
        CFDataRef Data = 0LL;
      }

      if ((__CF_FORK_STATE & 2) == 0) {
        __CF_USED();
      }
      if ((__CF_FORK_STATE & 1) != 0) {
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
      }
      if ((__CF_FORK_STATE & 1) == 0)
      {
        if (Data)
        {
          DispatchCFDataRef Data = _CFDataCreateDispatchData(Data);
          xpc_object_t v27 = xpc_data_create_with_dispatch_data(DispatchData);
          dispatch_release(DispatchData);
        }

        else
        {
          xpc_object_t v27 = 0LL;
        }

        v47[0] = 0LL;
        v50.length = CFStringGetLength(v7);
        v50.location = 0LL;
        CFStringGetBytes(v7, v50, 0x8000100u, 0, 0, 0LL, 0LL, v47);
        uint64_t v28 = (UInt8 *)malloc(v47[0] + 1);
        v51.length = CFStringGetLength(v7);
        v51.location = 0LL;
        CFStringGetBytes(v7, v51, 0x8000100u, 0, 0, v28, v47[0], 0LL);
        v28[v47[0]] = 0;
        v47[0] = 0LL;
        v52.length = CFStringGetLength(v9);
        v52.location = 0LL;
        CFStringGetBytes(v9, v52, 0x8000100u, 0, 0, 0LL, 0LL, v47);
        uint64_t v29 = (UInt8 *)malloc(v47[0] + 1);
        v53.length = CFStringGetLength(v9);
        v53.location = 0LL;
        CFStringGetBytes(v9, v53, 0x8000100u, 0, 0, v29, v47[0], 0LL);
        v29[v47[0]] = 0;
        xpc_object_t v30 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_string(v30, "method", "post");
        xpc_dictionary_set_uint64(v30, "version", 1uLL);
        xpc_dictionary_set_string(v30, "name", (const char *)v28);
        xpc_dictionary_set_string(v30, "object", (const char *)v29);
        xpc_dictionary_set_value(v30, "userinfo", v27);
        xpc_dictionary_set_uint64(v30, "options", a3);
        double Current = CFAbsoluteTimeGetCurrent();
        os_unfair_lock_lock_with_options();
        double v32 = *(double *)&_CFXNotificationPost_lastPost;
        if (*(double *)&_CFXNotificationPost_lastPost == 0.0)
        {
          _CFXNotificationPost_lastPost = *(void *)&Current;
        }

        else
        {
          uint64_t v33 = 0LL;
          unint64_t v34 = (_CFXNotificationPost_sampleIndex + 1) % 0x64uLL;
          _CFXNotificationPost_lastPost = *(void *)&Current;
          _CFXNotificationPost_samples[v34] = Current - v32;
          _CFXNotificationPost_sampleIndex = v34;
          int64x2_t v35 = 0uLL;
          double v36 = 0.0;
          int8x16_t v37 = (int8x16_t)vdupq_n_s64(0x8000000000000000LL);
          do
          {
            float64x2_t v38 = *(float64x2_t *)&_CFXNotificationPost_samples[v33];
            int8x16_t v39 = (int8x16_t)vceqzq_f64(v38);
            int64x2_t v35 = vsubq_s64(v35, (int64x2_t)vmvnq_s8(v39));
            int8x16_t v40 = vbslq_s8(v39, v37, (int8x16_t)v38);
            double v36 = v36 + *(double *)v40.i64 + *(double *)&v40.i64[1];
            v33 += 2LL;
          }

          while (v33 != 100);
          uint64_t v41 = vaddvq_s64(v35);
          if ((unint64_t)v41 >= 0xB && Current - *(double *)&_CFXNotificationPost_lastWarning > 10.0)
          {
            double v42 = (double)v41 / v36;
            if (v42 > 60.0)
            {
              _CFXNotificationPost_lastWarning = *(void *)&Current;
              os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
              if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
                _CFXNotificationPost_cold_1(v42);
              }
              goto LABEL_54;
            }
          }
        }

        os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
LABEL_54:
        CFRange v43 = (_xpc_connection_s *)a1[3];
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(v43, v30);
        xpc_connection_send_barrier(v43, &__block_literal_global_99);
        xpc_release(v30);
        free(v29);
        free(v28);
        if (v27) {
          xpc_release(v27);
        }
        if (Data) {
          CFRelease(Data);
        }
        goto LABEL_11;
      }

      if (Data) {
        CFRelease(Data);
      }
    }
  }

void *_CFXRegistrationPost(const void *a1, uint64_t a2, int a3, uint64_t a4, void *a5)
{
  v5 = 0LL;
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (a2 && a4)
  {
    if (!_CFXRegistrationPost_operationQueueClass) {
      _CFXRegistrationPost_operationQueueClass = (uint64_t)objc_lookUpClass("NSOperationQueue");
    }
    if (!_CFXRegistrationPost_blockOperationClass) {
      _CFXRegistrationPost_blockOperationClass = (uint64_t)objc_lookUpClass("NSBlockOperation");
    }
    uint64_t v11 = *(void *)(a2 + 24);
    CFXNotificationHandlerCopy(&v29, *(void **)(a2 + 32), *(CFTypeRef *)(a2 + 40), v11);
    uint64_t v12 = *((void *)&v29 + 1) & (v11 << 46 >> 63);
    if ((v11 & 0x400) != 0) {
      id v13 = a5;
    }
    uint64_t v14 = *(void *)(a2 + 48);
    if (v11 & 0x10000 | v12) {
      char v15 = 1;
    }
    else {
      char v15 = a3;
    }
    CFRetain(a1);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    uint64_t v20 = ___CFXRegistrationPost_block_invoke;
    unint64_t v21 = &unk_18999B138;
    __int128 v23 = v29;
    char v28 = v15;
    int v24 = a1;
    uint64_t v25 = v14;
    uint64_t v22 = a4;
    uint64_t v26 = a5;
    uint64_t v27 = v11;
    if (v12)
    {
      if ([(id)_CFXRegistrationPost_operationQueueClass currentQueue] != v12
        && (pthread_main_np() != 1 || [(id)_CFXRegistrationPost_operationQueueClass mainQueue] != v12))
      {
        v5 = (void *)objc_opt_new();
        [v5 addExecutionBlock:block];
        [(id)v12 addOperation:v5];
        return v5;
      }

      goto LABEL_20;
    }

    if ((*(_BYTE *)(a2 + 26) & 1) != 0)
    {
      qos_class_t v17 = qos_class_main();
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(v17, 2uLL);
    }

    else
    {
      if (!a3)
      {
LABEL_20:
        v20((uint64_t)block);
        return 0LL;
      }

      dispatch_queue_global_t global_queue = (dispatch_queue_global_t)MEMORY[0x1895F8AE0];
    }

    dispatch_async(global_queue, block);
    return 0LL;
  }

  return v5;
}

BOOL _CFXNotificationCenterIsEmpty(uint64_t a1)
{
  return CFXNotificationRegistrarIsEmpty(*(os_unfair_lock_s **)(a1 + 16));
}

void _CFXNotificationGetSuspended(uint64_t a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 2) != 0) {
      atomic_load((unint64_t *)(a1 + 8));
    }
    else {
      __break(1u);
    }
  }

void _CFXNotificationSetSuspended(uint64_t a1, int a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    mach_port_t v4 = (unint64_t *)(a1 + 8);
    char v5 = atomic_load((unint64_t *)(a1 + 8));
    if ((v5 & 2) != 0)
    {
      char v6 = atomic_load(v4);
      if ((v6 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
      {
        unint64_t v7 = atomic_load(v4);
        if (((v7 >> 3) & 1) != a2)
        {
          unint64_t v8 = atomic_load(v4);
          if ((a2 & 1) != 0)
          {
            char v9 = "suspend";
            while (1)
            {
              unint64_t v10 = __ldaxr(v4);
              if (v10 != v8) {
                break;
              }
              if (__stlxr(v8 | 8, v4)) {
                goto LABEL_16;
              }
              char v11 = 1;
LABEL_17:
              unint64_t v8 = v10;
              if ((v11 & 1) != 0) {
                goto LABEL_27;
              }
            }

            __clrex();
LABEL_16:
            char v11 = 0;
            goto LABEL_17;
          }

          char v9 = "unsuspend";
          while (1)
          {
            unint64_t v12 = __ldaxr(v4);
            if (v12 != v8) {
              break;
            }
            if (__stlxr(v8 & 0xFFFFFFFFFFFFFFF7LL, v4)) {
              goto LABEL_25;
            }
            int v13 = 1;
LABEL_26:
            unint64_t v8 = v12;
            if (v13)
            {
LABEL_27:
              xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
              xpc_dictionary_set_string(v14, "method", v9);
              xpc_dictionary_set_uint64(v14, "version", 1uLL);
              char v15 = *(_xpc_connection_s **)(a1 + 24);
              _CFSuddenTerminationDisable();
              xpc_connection_send_message(v15, v14);
              xpc_connection_send_barrier(v15, &__block_literal_global_99);
              xpc_release(v14);
              return;
            }
          }

          __clrex();
LABEL_25:
          int v13 = 0;
          goto LABEL_26;
        }
      }
    }

    else
    {
      __break(1u);
    }
  }

void CFNotificationCenterSetSuspended(unint64_t *a1, int a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID(a1);
  if (v4 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0) {
    _CFXNotificationSetSuspended((uint64_t)a1, a2 != 0);
  }
}

void CFNotificationCenterIsSuspended(unint64_t *a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0) {
    _CFXNotificationGetSuspended((uint64_t)a1);
  }
}

void CFNotificationCenterAddObserver( CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  __int16 v6 = suspensionBehavior;
  unint64_t v12 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v12 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v12);
  }
  uint64_t v14 = 2LL;
  switch(v6 & 0xF)
  {
    case 1:
      goto LABEL_11;
    case 2:
      uint64_t v14 = 4LL;
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    case 3:
      uint64_t v14 = 8LL;
LABEL_11:
      if ((v6 & 0x400) != 0) {
        goto LABEL_12;
      }
      goto LABEL_13;
    case 4:
      uint64_t v14 = 1LL;
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    default:
      if ((v6 & 0xF) == 0xELL) {
        uint64_t v14 = 65537LL;
      }
      else {
        uint64_t v14 = 4LL;
      }
      if ((v6 & 0x400) == 0) {
        goto LABEL_13;
      }
LABEL_12:
      v14 |= 0x400uLL;
      objc_opt_self();
LABEL_13:
      if (name) {
        char v15 = name;
      }
      else {
        char v15 = @"kCFNotificationAnyName";
      }
      char v16 = atomic_load((unint64_t *)center + 1);
      if ((object == 0LL) | v16 & 1) {
        qos_class_t v17 = @"kCFNotificationAnyObject";
      }
      else {
        qos_class_t v17 = (__CFString *)object;
      }
      if (observer) {
        uint64_t v18 = (__CFString *)observer;
      }
      else {
        uint64_t v18 = (__CFString *)kCFXNotificationPlaceholderObserver;
      }
      _CFXNotificationRegisterObserver((CFIndex)center, v15, v17, v14 | 0x80000, v18, callBack, v13);
      return;
  }

void CFNotificationCenterRemoveObserver( CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v8 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v8);
  }
  char v9 = atomic_load((unint64_t *)center + 1);
  if ((v9 & 2) == 0)
  {
LABEL_3:
    char v10 = atomic_load((unint64_t *)center + 1);
    if (observer || (v10 & 1) == 0)
    {
      if (name) {
        char v11 = name;
      }
      else {
        char v11 = @"kCFNotificationAnyName";
      }
      char v12 = atomic_load((unint64_t *)center + 1);
      if ((object == 0LL) | v12 & 1) {
        int v13 = @"kCFNotificationAnyObject";
      }
      else {
        int v13 = (const __CFString *)object;
      }
      if (observer) {
        uint64_t v14 = observer;
      }
      else {
        uint64_t v14 = (const void *)kCFXNotificationPlaceholderObserver;
      }
      _CFXNotificationRemoveObservers((unint64_t *)center, v11, v13, (uint64_t)v14);
    }

    return;
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (name)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(name))
      {
        CFLog( 4LL,  (uint64_t)@"*** Attempt to unregister for a distributed notification with a non-string name ignored.",  v16,  v17,  v18,  v19,  v20,  v21,  v29);
        return;
      }
    }

    if (object)
    {
      CFTypeID v22 = CFStringGetTypeID();
      if (v22 != CFGetTypeID(object))
      {
        CFLog( 4LL,  (uint64_t)@"*** Attempt to unregister for a distributed notification (%@) with a non-string object ignored.",  v23,  v24,  v25,  v26,  v27,  v28,  (uint64_t)name);
        return;
      }
    }

    goto LABEL_3;
  }

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
}

void CFNotificationCenterPostNotificationWithOptions( CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, CFOptionFlags options)
{
  unint64_t v10 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v10 != 52) {
    _CFAssertMismatchedTypeID(0x34uLL, v10);
  }
  char v11 = objc_alloc(&OBJC_CLASS_____CFNotification);
  char v12 = atomic_load((unint64_t *)center + 1);
  if ((v12 & 1) != 0) {
    int v13 = 0LL;
  }
  else {
    int v13 = object;
  }
  char v14 = atomic_load((unint64_t *)center + 1);
  if ((v14 & 1) != 0) {
    CFDictionaryRef v15 = 0LL;
  }
  else {
    CFDictionaryRef v15 = userInfo;
  }
  uint64_t v16 = -[__CFNotification initWithName:object:userInfo:foundation:]( v11,  "initWithName:object:userInfo:foundation:",  name,  v13,  v15,  0LL);
  _CFXNotificationPost((unint64_t *)center, v16, options);
}

void CFNotificationCenterPostNotification( CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  CFNotificationCenterPostNotificationWithOptions(center, name, object, userInfo, deliverImmediately != 0);
}

void __CFXNotificationPostToken(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v13[8] = *MEMORY[0x1895F89C0];
  *(void *)char v11 = 0x100000000LL;
  char v12 = v13;
  if (CFXNotificationRegistrarFindToken(a1[2], a2, (uint64_t)v11))
  {
    if (!a3) {
      a3 = *v12;
    }
    char v9 = -[__CFNotification initWithName:object:userInfo:foundation:]( objc_alloc(&OBJC_CLASS_____CFNotification),  "initWithName:object:userInfo:foundation:",  a3,  a4,  a5,  1LL);
    unint64_t v10 = _CFXRegistrationPost(a1, (uint64_t)v12, 1, (uint64_t)v9, (void *)v12[2]);
  }

  _CFXNotificationRegistrationBufferDestroy(v11);
}

uint64_t _dependentNotificationsEqual(CFTypeRef **a1, CFTypeRef **a2)
{
  return CFEqual(**a1, **a2);
}

CFHashCode _dependentNotificationHash(CFTypeRef **a1)
{
  return CFHash(**a1);
}

uint64_t ___registerSubNotifications_block_invoke(uint64_t a1)
{
  unint64_t v4 = *(uint64_t (**)(CFNotificationCenterRef, void, void, void, void))(*(void *)(a1 + 32) + 24LL);
  CFNotificationCenterRef DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  return v4(DarwinNotifyCenter, 0LL, *(void *)(a1 + 40), 0LL, 0LL);
}

id __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__( id result, const char *a2, uint64_t a3, void *a4, void *a5, int a6)
{
  else {
    unint64_t v8 = a4;
  }
  if ((a6 & 0x20000) != 0) {
    return (id)(*((uint64_t (**)(const char *, void *))a2 + 2))(a2, a5);
  }
  if ((a6 & 0x40000) != 0) {
    return objc_msgSend(v8, a2, a5);
  }
  if ((a6 & 0x80000) != 0)
  {
    uint64_t v9 = (uint64_t)result;
    uint64_t v10 = [a5 name];
    char v11 = atomic_load((unint64_t *)(v9 + 8));
    if ((v11 & 1) != 0) {
      char v12 = @"kCFNotificationAnyObject";
    }
    else {
      char v12 = (const __CFString *)[a5 object];
    }
    char v13 = atomic_load((unint64_t *)(v9 + 8));
    if ((v13 & 1) != 0) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = [a5 userInfo];
    }
    return (id)((uint64_t (*)(uint64_t, void *, uint64_t, const __CFString *, uint64_t))a2)( v9,  v8,  v10,  v12,  v14);
  }

  return result;
}

CFTypeRef __CFBooleanCopyFormattingDescription(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1) {
    return CFRetain(@"true");
  }
  else {
    return CFRetain(@"false");
  }
}

uint64_t __CFBooleanHash(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1) {
    return 2654435761LL;
  }
  else {
    return 0LL;
  }
}

CFStringRef __CFBooleanCopyDescription(__objc2_class **a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  if (&__kCFBooleanTrue == a1) {
    v3 = "true";
  }
  else {
    v3 = "false";
  }
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFBoolean %p [%p]>{value = %s}",  a1,  v2,  v3);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return 21LL;
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  else {
    return &__kCFBooleanTrue == (__objc2_class **)BOOLean;
  }
}

CFStringRef __CFNumberCopyFormattingDescriptionAsFloat64(CFNumberRef number)
{
  return __CFNumberCreateFormattingDescriptionAsFloat64((const __CFAllocator *)&__kCFAllocatorSystemDefault, number);
}

CFStringRef __CFNumberCreateFormattingDescriptionAsFloat64(const __CFAllocator *a1, CFNumberRef number)
{
  valuePtr[1] = *(double *)MEMORY[0x1895F89C0];
  CFNumberGetValue(number, kCFNumberFloat64Type, valuePtr);
  if (fabs(valuePtr[0]) == INFINITY)
  {
    if (valuePtr[0] <= 0.0) {
      v3 = @"-infinity";
    }
    else {
      v3 = @"+infinity";
    }
    return (CFStringRef)CFRetain(v3);
  }

  if (valuePtr[0] == 0.0)
  {
    v3 = @"0.0";
    return (CFStringRef)CFRetain(v3);
  }

  return CFStringCreateWithFormat(a1, 0LL, @"%.*g", 17LL, *(void *)&valuePtr[0]);
}

CFStringRef __CFNumberCreateFormattingDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if ((a2 & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = *MEMORY[0x189616658];
  if ((~a2 & 0xC000000000000007LL) == 0) {
    uint64_t v4 = 0LL;
  }
  unint64_t v5 = v4 ^ a2;
  unint64_t v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x189616648] + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }

  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a2 + 8));
  }

  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]] & 0x20) != 0) {
    return __CFNumberCreateFormattingDescriptionAsFloat64(a1, (CFNumberRef)a2);
  }
  __CFNumberGetValue(a2, 17LL, (uint64_t)v10);
  emit128(v11, v10, 0);
  return CFStringCreateWithFormat(a1, 0LL, @"%s", v11);
}

uint64_t __CFNumberGetValue(uint64_t result, uint64_t a2, uint64_t a3)
{
  v75[1] = *MEMORY[0x1895F89C0];
  if ((result & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = *MEMORY[0x189616658];
  if ((~result & 0xC000000000000007LL) == 0) {
    uint64_t v4 = 0LL;
  }
  unint64_t v5 = v4 ^ result;
  uint64_t v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x189616648] + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }

  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(result + 8));
  }

  unsigned int v9 = __CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]];
  uint64_t v10 = __CFNumberTypeTable[a2] & 0x1FLL;
  unint64_t v11 = result + 16;
  int v12 = (v9 >> 5) & 1;
  int v13 = (v9 >> 6) & 1;
  if (result < 0)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = *MEMORY[0x189616658];
    if ((~result & 0xC000000000000007LL) == 0) {
      uint64_t v15 = 0LL;
    }
    uint64_t v16 = v15 ^ result;
    uint64_t v17 = v16 & 7;
    while (v17 != *(unsigned __int8 *)(MEMORY[0x189616648] + v14))
    {
      if (++v14 == 7) {
        goto LABEL_26;
      }
    }

    if (v14 == 3)
    {
      int v13 = 0;
      int v12 = 0;
      uint64_t v18 = v16 << 9 >> 12;
      if (v17 != 7) {
        uint64_t v18 = (2 * v16) >> 4;
      }
      char v19 = 6;
      if ((v16 & 0x40) == 0) {
        char v19 = 4;
      }
      v75[0] = v18 >> v19;
      unint64_t v11 = (unint64_t)v75;
    }
  }

LABEL_130:
        *(_DWORD *)a3 = v11;
        return result;
      }

      double v44 = *(double *)v11;
      if (v13)
      {
        unint64_t v45 = *(void *)(v11 + 8);
        uint64_t v46 = -*(void *)&v44;
        if (v45) {
          uint64_t v46 = ~*(void *)&v44;
        }
        if (v44 >= 0.0) {
          uint64_t v46 = *(void *)&v44;
        }
        else {
          unint64_t v45 = -(uint64_t)v45;
        }
        double v47 = -((double)v45 + (double)v46 * 1.84467441e19);
        if (v44 >= 0.0) {
          double v47 = (double)v45 + (double)v46 * 1.84467441e19;
        }
        float v38 = v47;
      }

      else
      {
        float v38 = (float)*(uint64_t *)&v44;
      }

      goto LABEL_158;
    case 6LL:
      if (v12)
      {
        if (v13)
        {
          uint64_t v33 = *(void *)v11;
LABEL_128:
          *(void *)a3 = v33;
          return result;
        }

        float v62 = *(float *)v11;
        if (fabsf(*(float *)v11) == INFINITY)
        {
          BOOL v34 = v62 < 0.0;
          uint64_t v33 = 0x7FF0000000000000LL;
          unint64_t v61 = 0xFFF0000000000000LL;
LABEL_126:
          if (v34) {
            uint64_t v33 = v61;
          }
          goto LABEL_128;
        }

        double v63 = v62;
        double v64 = 1.79769313e308;
        if (v63 <= 1.79769313e308) {
          double v64 = v63;
        }
        if (v63 >= -1.79769313e308) {
          double v51 = v64;
        }
        else {
          double v51 = -1.79769313e308;
        }
      }

      else
      {
        double v48 = *(double *)v11;
        if (v13)
        {
          unint64_t v49 = *(void *)(v11 + 8);
          uint64_t v50 = -*(void *)&v48;
          if (v49) {
            uint64_t v50 = ~*(void *)&v48;
          }
          if (v48 >= 0.0) {
            uint64_t v50 = *(void *)&v48;
          }
          else {
            unint64_t v49 = -(uint64_t)v49;
          }
          double v51 = -((double)v49 + (double)v50 * 1.84467441e19);
          if (v48 >= 0.0) {
            double v51 = (double)v49 + (double)v50 * 1.84467441e19;
          }
        }

        else
        {
          double v51 = (double)*(uint64_t *)&v48;
        }
      }

      *(double *)a3 = v51;
      return result;
    case 17LL:
      if (!v12)
      {
        if (v13)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
          return result;
        }

        uint64_t v66 = *(void *)v11;
        uint64_t v67 = v66 >> 63;
        goto LABEL_167;
      }

      if (v13)
      {
        double v39 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v39 >= 1.70141183e38) {
            goto LABEL_166;
          }
          goto LABEL_165;
        }

LABEL_138:
        uint64_t v66 = 0LL;
        uint64_t v67 = 0x8000000000000000LL;
        goto LABEL_167;
      }

      float v65 = *(float *)v11;
      if (v65 >= 1.7014e38)
      {
LABEL_166:
        uint64_t v66 = -1LL;
        uint64_t v67 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_167;
      }

      double v39 = v65;
LABEL_165:
      uint64_t v67 = vcvtmd_s64_f64(v39 * 5.42101086e-20);
      uint64_t v66 = (unint64_t)(v39 + floor(v39 * 5.42101086e-20) * -1.84467441e19);
LABEL_167:
      *(void *)a3 = v67;
      *(void *)(a3 + 8) = v66;
      return result;
    default:
      return result;
  }

            *a3 = Mutable;
LABEL_139:
            uint64_t result = 1LL;
            break;
          default:
            double v36 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v14, 0x8000100u, 0);
            float v37 = v36;
            *(void *)(a1 + 8) = v6;
            if (v36) {
              float v38 = v36;
            }
            else {
              float v38 = @"<unknown>";
            }
            double v39 = lineNumber((unint64_t *)a1);
            *(void *)(a1 + 24) = __CFPropertyListCreateError( 3840LL,  @"Encountered unknown tag %@ on line %u",  v38,  v39);
            if (!v37) {
              return 0LL;
            }
            uint64_t result = (uint64_t)v37;
LABEL_90:
            CFRelease((CFTypeRef)result);
            return 0LL;
        }

        break;
      default:
        uint64_t v17 = 1;
        uint64_t v18 = 1;
        char v19 = 1;
        double v20 = 1;
        double v21 = 1;
        goto LABEL_71;
    }
  }

  else
  {
    *(void *)(a1 + 8) = v6;
    unint64_t v45 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840LL, @"Malformed tag on line %u", v45);
LABEL_79:
    double v31 = Error;
    uint64_t result = 0LL;
    *(void *)(a1 + 24) = v31;
  }

  return result;
}

  *a6 = v10;
  return (uint64_t)((uint64_t)v15 - v7) >> 1;
}

                v86 = &v85[2 * v23];
                v87 = v103;
                v88 = v103;
                uint64_t v17 = v96;
                while (2)
                {
                  v90 = *v88++;
                  v89 = v90;
                  v91 = HIWORD(v90);
                  if (HIWORD(v90))
                  {
                    if (v91 > 0x10) {
                      goto LABEL_146;
                    }
                    *(_WORD *)v86 = ((v89 + 67043328) >> 10) - 10240;
                    v86 += 2;
                    LOWORD(v92) = v89 & 0x3FF | 0xDC00;
                  }

                  else if ((v89 & 0xFC00) == 0xD800)
                  {
                    if (v88 < v59)
                    {
                      v92 = *v88;
                      if (*v88 >> 10 == 55)
                      {
                        *(_WORD *)v86 = v89;
                        v86 += 2;
                        v88 = v87 + 2;
                        goto LABEL_150;
                      }
                    }

        unint64_t v22 = -193;
        goto LABEL_157;
      }
    }

    else
    {
      switch(v20)
      {
        case 0xCBu:
          if ((a1 & 0x200) == 0)
          {
            double v21 = -28575620;
            goto LABEL_92;
          }

          unint64_t v22 = -437;
          goto LABEL_157;
        case 0xF2u:
          unint64_t v22 = 8853;
          goto LABEL_157;
        case 0xFEu:
          if ((a1 & 0x200) == 0)
          {
            double v21 = -15730561;
            goto LABEL_92;
          }

          unint64_t v22 = -241;
LABEL_157:
          if (a5) {
            *a4++ = v22;
          }
          goto LABEL_159;
      }
    }

    a2 = v76;
    *a4 = v55;
    a4[1] = v54 & 0x7F;
    a4 += 2;
    unint64_t v11 = 1;
LABEL_147:
    ++v13;
LABEL_148:
    v12 += v18;
  }

  while (v13 < v8);
  if (v11) {
    goto LABEL_150;
  }
LABEL_167:
  uint64_t v67 = v12;
LABEL_171:
  a6 = v74;
LABEL_172:
  *a6 = v67;
  return v13;
}

char *emit128(char *result, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  if (*a2 < 0)
  {
    BOOL v6 = v4 == 0;
    unint64_t v4 = -(uint64_t)v4;
    if (v6) {
      uint64_t v3 = -v3;
    }
    else {
      uint64_t v3 = ~v3;
    }
    char v5 = 45;
    goto LABEL_8;
  }

  if (a3)
  {
    char v5 = 43;
LABEL_8:
    *result++ = v5;
  }

  uint64_t v7 = 0LL;
  int v8 = 0;
  do
  {
    while (1)
    {
      int v9 = 0;
      uint64_t v10 = (uint64_t *)((char *)&powersOf10 + 16 * v7);
      uint64_t v13 = *v10;
      unint64_t v11 = (unint64_t *)(v10 + 1);
      uint64_t v12 = v13;
      uint64_t v14 = (void *)((char *)&neg_powersOf10 + 16 * v7);
      uint64_t v15 = v14 + 1;
      while (v12 < v3 || v12 <= v3 && *v11 <= v4)
      {
        v3 += __CFADD__(v4, *v15) + *v14;
        v4 += *v15;
        ++v9;
      }

      v8 |= v9;
      if (!v8) {
        break;
      }
      *result++ = v9 + 48;
      ++v7;
      int v8 = 1;
      if (v7 == 39) {
        goto LABEL_19;
      }
    }

    ++v7;
  }

  while (v7 != 39);
  *result++ = 48;
LABEL_19:
  *uint64_t result = 0;
  return result;
}

CFStringRef __CFNumberCopyFormattingDescription(uint64_t number)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if ((number & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~number & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  unint64_t v3 = v2 ^ number;
  unint64_t v4 = v3 & 7;
  while (v4 != *(unsigned __int8 *)(MEMORY[0x189616648] + v1))
  {
    if (++v1 == 7) {
      goto LABEL_12;
    }
  }

  if (v1 == 3)
  {
    uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7) {
      uint64_t v5 = 0xFFFFFFFFFFFFFLL;
    }
    unint64_t v6 = v5 & (v3 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(number + 8));
  }

  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v6 & 7]] & 0x20) != 0) {
    return __CFNumberCreateFormattingDescriptionAsFloat64( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  (CFNumberRef)number);
  }
  __CFNumberGetValue(number, 17LL, (uint64_t)v8);
  emit128(v9, v8, 0);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%s", v9);
}

BOOL __CFNumberEqual(const __CFNumber *a1, const __CFNumber *a2, void *a3)
{
  return CFNumberCompare(a1, a2, a3) == kCFCompareEqualTo;
}

uint64_t __CFNumberHash(uint64_t a1)
{
  v16[1] = *(double *)MEMORY[0x1895F89C0];
  if ((a1 & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  unint64_t v3 = v2 ^ a1;
  unint64_t v4 = v3 & 7;
  while (v4 != *(unsigned __int8 *)(MEMORY[0x189616648] + v1))
  {
    if (++v1 == 7) {
      goto LABEL_12;
    }
  }

  if (v1 == 3)
  {
    uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7) {
      uint64_t v5 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v6 = v5 & (v3 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(a1 + 8));
  }

  if ((unint64_t)(__CFNumberCanonicalTypes[v6 & 7] - 1LL) > 2)
  {
    __CFNumberGetValue(a1, 6LL, (uint64_t)v16);
    double v9 = -v16[0];
    if (v16[0] >= 0.0) {
      double v9 = v16[0];
    }
    double v10 = floor(v9 + 0.5);
    double v11 = (v9 - v10) * 1.84467441e19;
    double v12 = fmod(v10, 1.84467441e19);
    unint64_t v13 = 2654435761u * (unint64_t)v12;
    unint64_t v14 = v13 + (unint64_t)v11;
    if (v11 <= 0.0) {
      unint64_t v14 = 2654435761u * (unint64_t)v12;
    }
    unint64_t v15 = v13 - (unint64_t)fabs(v11);
    if (v11 < 0.0) {
      return v15;
    }
    else {
      return v14;
    }
  }

  else
  {
    __CFNumberGetValue(a1, 3LL, (uint64_t)v16);
    unsigned int v7 = LODWORD(v16[0]);
    if (SLODWORD(v16[0]) < 0) {
      unsigned int v7 = -LODWORD(v16[0]);
    }
    return 2654435761LL * v7;
  }

__CFString *__CFNumberCopyDescription(unint64_t *a1)
{
  v20[16] = *(double *)MEMORY[0x1895F89C0];
  uint64_t v2 = 0LL;
  uint64_t v3 = *MEMORY[0x189616658];
  unint64_t v4 = v3 ^ (unint64_t)a1;
  unint64_t v5 = v4 & 7;
  while (v5 != *(unsigned __int8 *)(MEMORY[0x189616648] + v2))
  {
    if (++v2 == 7) {
      goto LABEL_12;
    }
  }

  if (v2 == 3)
  {
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5 == 7) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v7 = v6 & (v4 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v7) = atomic_load(a1 + 1);
  }

  uint64_t v8 = v7 & 7;
  uint64_t v9 = __CFNumberCanonicalTypes[v8];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFAllocatorRef v11 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0LL, @"<CFNumber %p [%p]>{value = ", a1, v11);
  unsigned __int16 v12 = __CFNumberTypeTable[v9];
  if ((v12 & 0x20) == 0)
  {
    __CFNumberGetValue((uint64_t)a1, 17LL, (uint64_t)v19);
    emit128((char *)v20, v19, 1);
    switch(v9)
    {
      case 1LL:
        unint64_t v13 = "kCFNumberSInt8Type";
        break;
      case 2LL:
        unint64_t v13 = "kCFNumberSInt16Type";
        break;
      case 3LL:
        unint64_t v13 = "kCFNumberSInt32Type";
        break;
      case 4LL:
        unint64_t v13 = "kCFNumberSInt64Type";
        break;
      default:
        unint64_t v13 = "unknown integer";
        if (v9 == 17) {
          unint64_t v13 = "kCFNumberSInt128Type";
        }
        break;
    }

    CFStringAppendFormat(Mutable, 0LL, @"%s, type = %s}", v20, v13);
    return Mutable;
  }

  __CFNumberGetValue((uint64_t)a1, 6LL, (uint64_t)v20);
  if (fabs(v20[0]) == INFINITY)
  {
    if (v20[0] <= 0.0) {
      unint64_t v14 = @"-infinity";
    }
    else {
      unint64_t v14 = @"+infinity";
    }
  }

  else
  {
    if (v20[0] != 0.0)
    {
      uint64_t v15 = 20LL;
      if ((v12 & 0x40) == 0) {
        uint64_t v15 = 10LL;
      }
      CFStringAppendFormat(Mutable, 0LL, @"%+.*f", v20[0], v15, *(void *)&v20[0]);
      goto LABEL_31;
    }

    if (v20[0] >= 0.0) {
      unint64_t v14 = @"+0.0";
    }
    else {
      unint64_t v14 = @"-0.0";
    }
  }

  CFStringAppend(Mutable, v14);
LABEL_31:
  uint64_t v16 = "unknown float";
  if (v8 == 5) {
    uint64_t v16 = "kCFNumberFloat64Type";
  }
  if (v8 == 4) {
    uint64_t v16 = "kCFNumberFloat32Type";
  }
  CFStringAppendFormat(Mutable, 0LL, @", type = %s}", v16, v18);
  return Mutable;
}

CFTypeID CFNumberGetTypeID(void)
{
  if (CFNumberGetTypeID_initOnce != -1) {
    dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
  }
  return 22LL;
}

const char *__CFNumberGetTypeID_block_invoke()
{
  else {
    __CFNumberTaggedPointersDisabled = 1;
  }
  uint64_t result = getenv("CFNumberDisableCache");
  if (result)
  {
    uint64_t result = (const char *)strcmp(result, "all");
    if ((_DWORD)result) {
      char v1 = 1;
    }
    else {
      char v1 = 2;
    }
    __CFNumberCaching = v1;
  }

  return result;
}

double _CFNumberInitBool(uint64_t a1, char a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7LL, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt8(uint64_t a1, char a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7LL, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt8(uint64_t a1, char a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  char v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 7LL, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt16(uint64_t a1, __int16 a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  __int16 v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 8LL, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt16(uint64_t a1, __int16 a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  __int16 v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 8LL, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt32(uint64_t a1, int a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 9LL, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt32(uint64_t a1, int a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  int v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 9LL, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt(uint64_t a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 10LL, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt(uint64_t a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 10LL, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt64(uint64_t a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 11LL, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt64(uint64_t a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  *(void *)&double result = __CFNumberInit(a1, 11LL, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitFloat(uint64_t a1, float a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  float v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 12LL, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitDouble(uint64_t a1, double a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  *(double *)float v3 = a2;
  *(void *)&double result = __CFNumberInit(a1, 13LL, (char *)v3).n128_u64[0];
  return result;
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  uint64_t v9 = (__objc2_class **)allocator;
  if (!allocator)
  {
    uint64_t v10 = _CFGetTSD(1u);
    if (v10) {
      uint64_t v9 = (__objc2_class **)v10;
    }
    else {
      uint64_t v9 = &__kCFAllocatorSystemDefault;
    }
  }

  if ((__CFNumberTaggedPointersDisabled & 1) == 0
    && (&__kCFAllocatorSystemDefault == v9
     || !v9 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
    && __CFNumberCaching != 2)
  {
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        uint64_t v11 = *MEMORY[0x189616658];
        unint64_t v12 = ((uint64_t)*(char *)valuePtr << 7) | 0x8000000000000003LL;
        goto LABEL_15;
      case 2:
        uint64_t v13 = *(__int16 *)valuePtr;
        uint64_t v11 = *MEMORY[0x189616658];
        unint64_t v14 = 0x800000000000000BLL;
        goto LABEL_14;
      case 3:
        uint64_t v13 = *(int *)valuePtr;
        uint64_t v11 = *MEMORY[0x189616658];
        unint64_t v14 = 0x8000000000000013LL;
LABEL_14:
        unint64_t v12 = v14 | (v13 << 7);
LABEL_15:
        unint64_t v15 = v12 ^ v11;
        goto LABEL_115;
      case 4:
        uint64_t v16 = *MEMORY[0x189616658];
        unint64_t v12 = (*(void *)valuePtr << 7) | 0x800000000000001BLL;
        goto LABEL_114;
      case 5:
        uint64_t v17 = (uint64_t)*(float *)valuePtr;
        BOOL v18 = *(int *)valuePtr < 0 && v17 == 0;
        uint64_t v16 = *MEMORY[0x189616658];
        unint64_t v12 = (v17 << 7) | 0x8000000000000023LL;
        goto LABEL_114;
      case 6:
        double v20 = *(double *)valuePtr;
        uint64_t v21 = (uint64_t)v20;
        BOOL v22 = v20 < 0.0 && v21 == 0;
        uint64_t v16 = *MEMORY[0x189616658];
        unint64_t v12 = (v21 << 7) | 0x800000000000002BLL;
LABEL_114:
        unint64_t v15 = v16 ^ v12;
LABEL_115:
        if ((~v15 & 0xC000000000000007LL) != 0) {
          unint64_t v12 = v15 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v15 & 7));
        }
        break;
      default:
        goto LABEL_36;
    }

    return (CFNumberRef)v12;
  }

LABEL_68:
  if ((v24 & 0x20) != 0) {
    uint64_t v33 = 8LL;
  }
  else {
    uint64_t v33 = ((v24 >> 3) & 8) + 8;
  }
  if (CFNumberGetTypeID_initOnce != -1) {
    dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance((const __CFAllocator *)v9, 0x16uLL, v33, 0LL, v3, v4, v5, v6);
  unint64_t v12 = Instance;
  if (Instance)
  {
    uint64_t v35 = __CFNumberCanonicalTypeIndex[v24 & 0x1F] & 7;
    double v36 = (unint64_t *)(Instance + 8);
    unint64_t v37 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v38 = __ldaxr(v36);
      if (v38 != v37) {
        break;
      }
      if (__stlxr(v37 & 0xFFFFFFFFFFFFFFC0LL | v35, v36)) {
        goto LABEL_79;
      }
      int v39 = 1;
LABEL_80:
      unint64_t v37 = v38;
      if (v39)
      {
        __CFNumberInit(Instance, theType, (char *)valuePtr);
        if (v29 == -2) {
          return (CFNumberRef)v12;
        }
        *(void *)(v12 + 16) = v29;
        if ((v12 & 0x8000000000000000LL) == 0) {
          goto LABEL_93;
        }
        uint64_t v40 = 0LL;
        uint64_t v41 = *MEMORY[0x189616658];
        if ((~v12 & 0xC000000000000007LL) == 0) {
          uint64_t v41 = 0LL;
        }
        unint64_t v42 = v41 ^ v12;
        unint64_t v43 = v42 & 7;
        while (v43 != *(unsigned __int8 *)(MEMORY[0x189616648] + v40))
        {
          if (++v40 == 7) {
            goto LABEL_93;
          }
        }

        if (v40 == 3)
        {
          uint64_t v44 = 0xFFFFFFFFFFFFFFFLL;
          if (v43 == 7) {
            uint64_t v44 = 0xFFFFFFFFFFFFFLL;
          }
          uint64_t v45 = v44 & (v42 >> 3);
        }

        else
        {
LABEL_93:
          LOBYTE(v45) = atomic_load(v36);
        }

        uint64_t v46 = __CFNumberCanonicalTypes[v45 & 7];
        unint64_t v47 = atomic_load(v36);
        while (2)
        {
          unint64_t v48 = __ldaxr(v36);
          if (v48 == v47)
          {
            if (!__stlxr(v47 & 0xFFFFFFFFFFFFFFC0LL | 2, v36))
            {
              int v49 = 1;
              goto LABEL_100;
            }
          }

          else
          {
            __clrex();
          }

          int v49 = 0;
LABEL_100:
          unint64_t v47 = v48;
          if (v49)
          {
            uint64_t v50 = &__CFNumberCache[v29 + 1];
            while (!__ldaxr(v50))
            {
              if (!__stlxr(v12, v50))
              {
                CFRetain((CFTypeRef)v12);
                return (CFNumberRef)v12;
              }
            }

            __clrex();
            uint64_t v52 = __CFNumberCanonicalTypeIndex[v46] & 7;
            unint64_t v53 = atomic_load(v36);
            while (2)
            {
              unint64_t v54 = __ldaxr(v36);
              if (v54 == v53)
              {
                if (!__stlxr(v53 & 0xFFFFFFFFFFFFFFC0LL | v52, v36))
                {
                  int v55 = 1;
                  goto LABEL_111;
                }
              }

              else
              {
                __clrex();
              }

              int v55 = 0;
LABEL_111:
              unint64_t v53 = v54;
              if (v55) {
                return (CFNumberRef)v12;
              }
              continue;
            }
          }

          continue;
        }
      }
    }

    __clrex();
LABEL_79:
    int v39 = 0;
    goto LABEL_80;
  }

  return (CFNumberRef)v12;
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  if (((unint64_t)number & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = *MEMORY[0x189616658];
    unint64_t v4 = v3 ^ (unint64_t)number;
    unint64_t v5 = (v3 ^ (unint64_t)number) & 7;
    uint64_t v6 = MEMORY[0x189616648];
    while (v5 != *(unsigned __int8 *)(MEMORY[0x189616648] + v2))
    {
      if (++v2 == 7) {
        goto LABEL_15;
      }
    }

    if (v2 == 3)
    {
      uint64_t v7 = 0LL;
      while (v5 != *(unsigned __int8 *)(MEMORY[0x189616648] + v7))
      {
        if (++v7 == 7) {
          goto LABEL_34;
        }
      }

      if (v7 != 3)
      {
LABEL_34:
        LOBYTE(v13) = atomic_load((unint64_t *)number + 1);
        return __CFNumberCanonicalTypes[v13 & 7];
      }

      uint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        uint64_t v12 = 0xFFFFFFFFFFFFFLL;
      }
      unint64_t v13 = v12 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v13 & 7];
    }

uint64_t _CFNumberGetType2(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = *MEMORY[0x189616658];
    unint64_t v4 = v3 ^ (unint64_t)a1;
    uint64_t v5 = (v3 ^ (unint64_t)a1) & 7;
    uint64_t v6 = MEMORY[0x189616648];
    while (v5 != *(unsigned __int8 *)(MEMORY[0x189616648] + v2))
    {
      if (++v2 == 7) {
        goto LABEL_15;
      }
    }

    if (v2 == 3)
    {
      uint64_t v7 = 0LL;
      while (v5 != *(unsigned __int8 *)(MEMORY[0x189616648] + v7))
      {
        if (++v7 == 7) {
          goto LABEL_25;
        }
      }

      goto LABEL_21;
    }

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return 1LL << (((unint64_t)__CFNumberTypeTable[CFNumberGetType(number)] >> 7) & 7);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return (__CFNumberTypeTable[CFNumberGetType(number)] >> 5) & 1;
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  uint64_t v3 = valuePtr;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v6 = 0LL;
  uint64_t v7 = *MEMORY[0x189616658];
  unint64_t v8 = v7 ^ (unint64_t)number;
  unint64_t v9 = v8 & 7;
  while (v9 != *(unsigned __int8 *)(MEMORY[0x189616648] + v6))
  {
    if (++v6 == 7) {
      goto LABEL_18;
    }
  }

  if (v6 == 3)
  {
    if (!valuePtr) {
      valuePtr = v15;
    }
    if (v9 == 7) {
      uint64_t v10 = (uint64_t)(v8 << 9) >> 12;
    }
    else {
      uint64_t v10 = (uint64_t)(2 * v8) >> 4;
    }
    BOOL v11 = (v8 & 0x40) == 0;
    char v12 = 6;
    if (v11) {
      char v12 = 4;
    }
    uint64_t v13 = v10 >> v12;
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        *(_BYTE *)valuePtr = v13;
        break;
      case 2:
        *(_WORD *)valuePtr = v13;
        break;
      case 3:
        *(_DWORD *)valuePtr = v13;
        break;
      case 4:
        *(void *)valuePtr = v13;
        break;
      case 5:
        *(float *)valuePtr = (float)v13;
        break;
      case 6:
        *(double *)valuePtr = (double)v13;
        break;
      default:
        return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }

    return 1;
  }

  else
  {
LABEL_18:
    if (CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
    {
      return -[__CFNumber _getValue:forType:](number, "_getValue:forType:", v3, __CFNumberTypeTable[theType] & 0x1FLL);
    }

    else
    {
      if (v3) {
        valuePtr = v3;
      }
      else {
        valuePtr = v15;
      }
      return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }
  }

uint64_t __CFNumberGetValueCompat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v70[1] = *MEMORY[0x1895F89C0];
  if ((a1 & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v4 = 0LL;
  }
  unint64_t v5 = v4 ^ a1;
  uint64_t v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x189616648] + v3))
  {
    if (++v3 == 7) {
      goto LABEL_12;
    }
  }

  if (v3 == 3)
  {
    uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7) {
      uint64_t v7 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v8 = v7 & (v5 >> 3);
  }

  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a1 + 8));
  }

  uint64_t v9 = __CFNumberTypeTable[a2] & 0x1FLL;
  uint64_t v10 = __CFNumberCanonicalTypes[v8 & 7];
  BOOL v11 = (unint64_t *)(a1 + 16);
  if (a1 < 0)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = *MEMORY[0x189616658];
    if ((~a1 & 0xC000000000000007LL) == 0) {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = v13 ^ a1;
    uint64_t v15 = v14 & 7;
    while (v15 != *(unsigned __int8 *)(MEMORY[0x189616648] + v12))
    {
      if (++v12 == 7) {
        goto LABEL_28;
      }
    }

    if (v12 == 3)
    {
      uint64_t v16 = v14 << 9 >> 12;
      if (v15 != 7) {
        uint64_t v16 = (2 * v14) >> 4;
      }
      char v17 = 6;
      if ((v14 & 0x40) == 0) {
        char v17 = 4;
      }
      v70[0] = v16 >> v17;
      BOOL v11 = v70;
    }
  }

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v6 = 0LL;
  uint64_t v7 = *MEMORY[0x189616658];
  unint64_t v8 = v7 ^ (unint64_t)number;
  unint64_t v9 = v8 & 7;
  while (v9 != *(unsigned __int8 *)(MEMORY[0x189616648] + v6))
  {
    if (++v6 == 7) {
      goto LABEL_16;
    }
  }

  if (v6 == 3)
  {
    uint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    if (v9 == 7) {
      uint64_t v10 = 0xFFFFFFFFFFFFFLL;
    }
    unint64_t v11 = v10 & (v8 >> 3);
  }

  else
  {
LABEL_16:
    LOBYTE(v11) = atomic_load((unint64_t *)number + 1);
  }

  uint64_t v12 = __CFNumberCanonicalTypes[v11 & 7];
  uint64_t v13 = 0LL;
  uint64_t v14 = *MEMORY[0x189616658];
  unint64_t v15 = v14 ^ (unint64_t)otherNumber;
  unint64_t v16 = v15 & 7;
  while (v16 != *(unsigned __int8 *)(MEMORY[0x189616648] + v13))
  {
    if (++v13 == 7) {
      goto LABEL_28;
    }
  }

  if (v13 == 3)
  {
    uint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    if (v16 == 7) {
      uint64_t v17 = 0xFFFFFFFFFFFFFLL;
    }
    unint64_t v18 = v17 & (v15 >> 3);
  }

  else
  {
LABEL_28:
    LOBYTE(v18) = atomic_load((unint64_t *)otherNumber + 1);
  }

  int v19 = __CFNumberTypeTable[__CFNumberCanonicalTypes[v18 & 7]] & 0x20;
  if ((__CFNumberTypeTable[v12] & 0x20) == 0)
  {
    if (!v19)
    {
      __CFNumberGetValue((uint64_t)number, 17LL, (uint64_t)&v36);
      __CFNumberGetValue((uint64_t)otherNumber, 17LL, (uint64_t)&v34);
      if (*(uint64_t *)&v36 >= *(uint64_t *)&v34)
      {
        if (*(uint64_t *)&v36 <= *(uint64_t *)&v34)
        {
          if (v37 >= v35) {
            return (unint64_t)(v37 > v35);
          }
          return -1LL;
        }

        return 1LL;
      }

      return -1LL;
    }

__n128 __CFNumberInit(uint64_t a1, uint64_t a2, char *a3)
{
  switch(__CFNumberTypeTable[a2] & 0x1F)
  {
    case 1:
      uint64_t v3 = *a3;
      goto LABEL_6;
    case 2:
      uint64_t v3 = *(__int16 *)a3;
      goto LABEL_6;
    case 3:
      uint64_t v3 = *(int *)a3;
      goto LABEL_6;
    case 4:
    case 6:
      uint64_t v3 = *(void *)a3;
LABEL_6:
      *(void *)(a1 + 16) = v3;
      break;
    case 5:
      *(_DWORD *)(a1 + 16) = *(_DWORD *)a3;
      break;
    case 0x11:
      __n128 result = *(__n128 *)a3;
      *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
      break;
    default:
      return result;
  }

  return result;
}

void __CFNumberFormatterDeallocate(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    __cficu_unum_close(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  unint64_t v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[8];
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (const void *)a1[9];
  if (v8) {
    CFRelease(v8);
  }
}

CFStringRef __CFNumberFormatterCopyDescription(const void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFNumberFormatter %p [%p]>", a1, v3);
}

CFTypeID CFNumberFormatterGetTypeID(void)
{
  return 57LL;
}

CFNumberFormatterRef CFNumberFormatterCreate( CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  unint64_t v9 = allocator;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v10 = _CFGetTSD(1u);
    if (v10) {
      unint64_t v9 = (const __CFAllocator *)v10;
    }
    else {
      unint64_t v9 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  uint64_t Instance = _CFRuntimeCreateInstance(v9, 0x39uLL, 72LL, 0LL, v3, v4, v5, v6);
  if (Instance)
  {
    if (!locale) {
      locale = CFLocaleGetSystem();
    }
    *(void *)(Instance + 32) = style;
    if ((unint64_t)style >= (kCFNumberFormatterCurrencyAccountingStyle|kCFNumberFormatterDecimalStyle))
    {
      unsigned int v12 = 1;
      *(void *)(Instance + 32) = 1LL;
      if (locale) {
        goto LABEL_10;
      }
    }

    else
    {
      unsigned int v12 = dword_180C36024[style];
      if (locale)
      {
LABEL_10:
        Identifier = CFLocaleGetIdentifier(locale);
        goto LABEL_13;
      }
    }

    Identifier = &stru_1899EF170;
LABEL_13:
    CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr && (CStringPtr = buffer, !CFStringGetCString(Identifier, buffer, 768LL, 0x600u))
      || (int v45 = 0,
          uint64_t v15 = __cficu_unum_open(v12, 0LL, 0LL, (uint64_t)CStringPtr, 0LL, &v45),
          (*(void *)(Instance + 16) = v15) == 0LL))
    {
      CFRelease((CFTypeRef)Instance);
      return 0LL;
    }

    if (style)
    {
      if (locale)
      {
LABEL_18:
        System = (void *)CFRetain(locale);
LABEL_22:
        *(void *)(Instance + 24) = System;
        unint64_t v18 = *(void *)(Instance + 32);
        if (v18 > 9 || ((1LL << v18) & 0x2E1) == 0)
        {
          AppleICUNumberFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberFormatStringsPref( System,  v17);
          if (AppleICUNumberFormatStringsPref)
          {
            double v28 = AppleICUNumberFormatStringsPref;
            CFTypeID v29 = CFGetTypeID(AppleICUNumberFormatStringsPref);
            if (v29 == CFDictionaryGetTypeID())
            {
              unint64_t v30 = v18 - 1;
              float64x2_t v31 = v30 > 9 ? @"0" : (__CFString *)*((void *)&off_18999B358 + v30);
              Value = (const __CFString *)CFDictionaryGetValue(v28, v31);
              if (Value)
              {
                double v33 = Value;
                CFTypeID v34 = CFGetTypeID(Value);
                if (v34 == CFStringGetTypeID())
                {
                  if (v30 > 9) {
                    unsigned int v35 = 0;
                  }
                  else {
                    unsigned int v35 = dword_180C36050[v30];
                  }
                  double v36 = CFLocaleGetIdentifier(*(CFLocaleRef *)(Instance + 24));
                  unint64_t v37 = (void *)CFStringGetCStringPtr(v36, 0x600u);
                  if (!v37)
                  {
                    if (CFStringGetCString(v36, v50, 768LL, 0x600u)) {
                      unint64_t v37 = v50;
                    }
                    else {
                      unint64_t v37 = 0LL;
                    }
                  }

                  int v47 = 0;
                  uint64_t v38 = __cficu_unum_open(v35, 0LL, 0LL, (uint64_t)v37, 0LL, &v47);
                  if (v38)
                  {
                    float v39 = (const void *)v38;
                    int v47 = 0;
                    int v40 = __cficu_unum_toPattern(v38, 0, chars, 768LL, &v47);
                    if (v47 <= 0 && v40 <= 768)
                    {
                      unint64_t v41 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v40);
                      int v47 = 0;
                      int v42 = __cficu_unum_toPattern(*(void *)(Instance + 16), 0, chars, 768LL, &v47);
                      if (v47 <= 0)
                      {
                        int v43 = v42;
                        if (v42 <= 768)
                        {
                          CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
                          CFStringAppendCharacters(Mutable, chars, v43);
                          v52.location = 0LL;
                          v52.length = v43;
                          if (CFStringFindWithOptions(Mutable, v41, v52, 0LL, &result))
                          {
                            CFStringReplace(Mutable, result, v33);
                            __CFNumberFormatterApplyPattern(Instance, Mutable);
                          }

                          CFRelease(Mutable);
                        }
                      }

                      CFRelease(v41);
                    }

                    __cficu_unum_close(v39);
                  }
                }
              }
            }
          }
        }

        AppleICUNumberSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberSymbolsPref( *(void **)(Instance + 24),  v17);
        if (AppleICUNumberSymbolsPref)
        {
          CFNumberRef v20 = AppleICUNumberSymbolsPref;
          CFTypeID v21 = CFGetTypeID(AppleICUNumberSymbolsPref);
          if (v21 == CFDictionaryGetTypeID()) {
            CFDictionaryApplyFunction( v20,  (CFDictionaryApplierFunction)__CFNumberFormatterApplySymbolPrefs,  (void *)Instance);
          }
        }

        unint64_t v22 = *(void *)(Instance + 32);
        if (v22 > 9 || ((1LL << v22) & 0x2E0) == 0)
        {
          int v45 = 0;
          int v26 = __cficu_unum_toPattern(*(void *)(Instance + 16), 0, chars, 768LL, &v45);
          if (v45 <= 0 && v26 <= 768) {
            *(void *)(Instance + 40) = CFStringCreateWithCharacters(v9, chars, v26);
          }
        }

        int8x16_t v23 = *(const void **)(Instance + 40);
        if (v23)
        {
          *(void *)(Instance + 48) = CFRetain(v23);
          *(void *)(Instance + 56) = __CFNumberFormatterCreateCompressedString( *(CFStringRef *)(Instance + 40),  1,  0LL);
        }

        unint64_t v24 = *(void *)(Instance + 32);
        if (v24 > 9 || ((1LL << v24) & 0x2E0) == 0)
        {
          *(_DWORD *)chars = __cficu_unum_getAttribute(*(void *)(Instance + 16), 9);
          if (*(_DWORD *)chars != 1)
          {
            *(void *)(Instance + 64) = CFNumberCreate(v9, kCFNumberSInt32Type, chars);
            __cficu_unum_setAttribute(*(void *)(Instance + 16), 9, 1LL);
          }
        }

        __cficu_unum_setAttribute(*(void *)(Instance + 16), 19, 0LL);
        __cficu_unum_setContext(*(void *)(Instance + 16), 256LL, &v45);
        return (CFNumberFormatterRef)Instance;
      }
    }

    else
    {
      int v45 = 0;
      __cficu_unum_applyPattern(v15, 0, word_180ED6678, 1LL, 0LL, &v45);
      __cficu_unum_setAttribute(*(void *)(Instance + 16), 3, 42LL);
      __cficu_unum_setAttribute(*(void *)(Instance + 16), 6, 0LL);
      if (locale) {
        goto LABEL_18;
      }
    }

    System = CFLocaleGetSystem();
    goto LABEL_22;
  }

  return (CFNumberFormatterRef)Instance;
}

__CFString *__CFNumberFormatterCreateCompressedString(CFStringRef theString, int a2, CFIndex *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!theString) {
    return 0LL;
  }
  if (a3)
  {
    CFIndex v5 = *a3;
    CFIndex Length = a3[1];
  }

  else
  {
    CFIndex Length = CFStringGetLength(theString);
    CFIndex v5 = 0LL;
  }

  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  CFCharacterSetRef v8 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  if (Length >= 1)
  {
    theSet = v8;
    BOOL v9 = 0;
    UniChar v10 = 0;
    CFIndex v11 = v5 + Length;
    do
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v5);
      uint64_t v13 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (CFCharacterSetIsCharacterMember(v13, CharacterAtIndex)) {
        int v14 = 32;
      }
      else {
        int v14 = CharacterAtIndex;
      }
      UniChar chars = v14;
      if (++v5 >= Length)
      {
        UniChar v15 = 0;
      }

      else
      {
        UniChar v15 = CFStringGetCharacterAtIndex(theString, v5);
        int v14 = chars;
      }

      if (v14 == 39 && a2 != 0) {
        BOOL v9 = !v9;
      }
      if (v9
        || v14 != 32
        || CFCharacterSetIsCharacterMember(Predefined, v10) && CFCharacterSetIsCharacterMember(Predefined, v15)
        || CFCharacterSetIsCharacterMember(theSet, v10) && CFCharacterSetIsCharacterMember(theSet, v15))
      {
        CFStringAppendCharacters(Mutable, &chars, 1LL);
        UniChar v10 = chars;
      }
    }

    while (v5 < v11);
  }

  return Mutable;
}

CFLocaleRef CFNumberFormatterGetLocale(CFNumberFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return (CFLocaleRef)*((void *)formatter + 3);
}

CFNumberFormatterStyle CFNumberFormatterGetStyle(CFNumberFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return *((void *)formatter + 4);
}

CFStringRef CFNumberFormatterGetFormat(CFNumberFormatterRef formatter)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  unint64_t v3 = *((void *)formatter + 4) - 5LL;
  if (v3 < 5 && ((0x17u >> v3) & 1) != 0) {
    return 0LL;
  }
  int v12 = 0;
  int v4 = __cficu_unum_toPattern(*((void *)formatter + 2), 0, chars, 768LL, &v12);
  if (v12 <= 0)
  {
    int v5 = v4;
    if (v4 <= 768)
    {
      uint64_t v6 = CFGetAllocator(formatter);
      CFStringRef v7 = CFStringCreateWithCharacters(v6, chars, v5);
      if (v7)
      {
        CFCharacterSetRef v8 = v7;
        BOOL v9 = (const void *)*((void *)formatter + 5);
        if (v9)
        {
          if (CFEqual(v7, v9))
          {
            CFRelease(v8);
            return (CFStringRef)*((void *)formatter + 5);
          }

          CFRelease(*((CFTypeRef *)formatter + 5));
        }

        *((void *)formatter + 5) = v8;
        CFIndex v11 = (const void *)*((void *)formatter + 7);
        if (v11)
        {
          CFRelease(v11);
          CFCharacterSetRef v8 = (const __CFString *)*((void *)formatter + 5);
        }

        *((void *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v8, 1, 0LL);
      }
    }
  }

  return (CFStringRef)*((void *)formatter + 5);
}

void CFNumberFormatterSetFormat(CFNumberFormatterRef formatter, CFStringRef formatString)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  }
  unint64_t v5 = *((void *)formatter + 4);
  BOOL v6 = v5 > 9;
  uint64_t v7 = (1LL << v5) & 0x2E0;
  if (v6 || v7 == 0)
  {
    CFIndex Length = CFStringGetLength(formatString);
    UniChar v10 = (const void *)*((void *)formatter + 5);
    if (v10)
    {
      if (CFEqual(v10, formatString) || Length >= 1025) {
        return;
      }
    }

    else if (Length > 1024)
    {
      return;
    }

    if ((int)__CFNumberFormatterApplyPattern((uint64_t)formatter, formatString) <= 0)
    {
      int v16 = 0;
      int v11 = __cficu_unum_toPattern(*((void *)formatter + 2), 0, chars, 768LL, &v16);
      if (v16 <= 0)
      {
        int v12 = v11;
        if (v11 <= 768)
        {
          uint64_t v13 = (const void *)*((void *)formatter + 5);
          if (v13) {
            CFRelease(v13);
          }
          uint64_t v14 = CFGetAllocator(formatter);
          UniChar v15 = CFStringCreateWithCharacters(v14, chars, v12);
          *((void *)formatter + 5) = v15;
          if (*((void *)formatter + 7))
          {
            CFRelease(*((CFTypeRef *)formatter + 7));
            UniChar v15 = (const __CFString *)*((void *)formatter + 5);
          }

          *((void *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v15, 1, 0LL);
        }
      }
    }
  }

uint64_t __CFNumberFormatterApplyPattern(uint64_t a1, CFStringRef theString)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(void *)(a1 + 32) - 5LL;
  if (v4 < 5 && ((0x17u >> v4) & 1) != 0) {
    return 16LL;
  }
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v7 = Length;
  unint64_t v8 = 2 * Length;
  if ((unint64_t)(2 * Length) < 0x101)
  {
    if (Length < 1)
    {
      BOOL v9 = 0LL;
    }

    else
    {
      MEMORY[0x1895F8858](Length, v6);
      BOOL v9 = (UniChar *)((char *)&valuePtr - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    }
  }

  else
  {
    BOOL v9 = (UniChar *)malloc(2 * Length);
  }

  CharactersPtr = (UChar *)CFStringGetCharactersPtr(theString);
  if (!CharactersPtr)
  {
    v17.location = 0LL;
    v17.length = v7;
    CFStringGetCharacters(theString, v17, v9);
    CharactersPtr = v9;
  }

  unsigned int v15 = 0;
  __cficu_unum_applyPattern(*(void *)(a1 + 16), 0, CharactersPtr, v7, 0LL, (int *)&v15);
  if (v8 >= 0x101) {
    free(v9);
  }
  if (!*(_BYTE *)(a1 + 81))
  {
    int v12 = *(const void **)(a1 + 64);
    if (v12) {
      CFRelease(v12);
    }
    *(void *)(a1 + 64) = 0LL;
    int valuePtr = __cficu_unum_getAttribute(*(void *)(a1 + 16), 9);
    if (valuePtr == 1) {
      return v15;
    }
    uint64_t v13 = CFGetAllocator((CFTypeRef)a1);
    *(void *)(a1 + 64) = CFNumberCreate(v13, kCFNumberSInt32Type, &valuePtr);
  }

  __cficu_unum_setAttribute(*(void *)(a1 + 16), 9, 1LL);
  return v15;
}

CFStringRef CFNumberFormatterCreateStringWithNumber( CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  unint64_t v5 = allocator;
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      unint64_t v5 = (const __CFAllocator *)v6;
    }
    else {
      unint64_t v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v7);
  }
  CFTypeID v8 = CFGetTypeID(number);
  if (CF_IS_OBJC(v8, (__objc2_class **)number))
  {
    -[__CFNumber doubleValue](number, "doubleValue");
    if (v9 == 0.0)
    {
      UniChar v10 = (const void *)*((void *)formatter + 9);
      if (v10) {
        return (CFStringRef)CFRetain(v10);
      }
    }

    double v26 = 0.0;
    double valuePtr = 1.0;
    int v12 = (const __CFNumber *)*((void *)formatter + 8);
    double v13 = 1.0;
    if (v12)
    {
      if (CFNumberGetValue(v12, kCFNumberFloat64Type, &valuePtr)) {
        double v13 = valuePtr;
      }
      else {
        double valuePtr = 1.0;
      }
    }

    if (modf(v13, &v26) < 0.00000011920929)
    {
      double v13 = floor(v13);
      double valuePtr = v13;
    }

    if (-[__CFNumber _getCString:length:multiplier:]( number,  "_getCString:length:multiplier:",  __s,  768LL,  v13))
    {
      int v25 = 0;
      size_t v16 = strlen(__s);
      int v17 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v16, (uint64_t)v29, 768LL, 0LL, &v25);
      CFIndex v18 = v17;
      int v19 = v25;
      if (v25 == 15 || v17 >= 769)
      {
        uint64_t v21 = v17 + 2LL;
        CFNumberRef v20 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * v21, 0LL);
        int v25 = 0;
        size_t v22 = strlen(__s);
        CFIndex v18 = (int)__cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v22, (uint64_t)(v20 + 1), v21, 0LL, &v25);
        int v19 = v25;
      }

      else
      {
        CFNumberRef v20 = 0LL;
      }

      if (v19 <= 0)
      {
        if (v20) {
          int8x16_t v23 = v20;
        }
        else {
          int8x16_t v23 = (UniChar *)v28;
        }
        if (*((_BYTE *)formatter + 82)
          && (Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
              CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
        {
          UniChar *v23 = 8207;
          ++v18;
        }

        else if (v20)
        {
          int8x16_t v23 = v20 + 1;
        }

        else
        {
          int8x16_t v23 = (UniChar *)v29;
        }

        unsigned int v15 = CFStringCreateWithCharacters(v5, v23, v18);
        if (!v20) {
          return v15;
        }
        goto LABEL_25;
      }

      unsigned int v15 = 0LL;
      if (v20) {
LABEL_25:
      }
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20);
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    CFNumberType Type2 = _CFNumberGetType2((unint64_t *)number);
    CFNumberGetValue(number, Type2, v28);
    return CFNumberFormatterCreateStringWithValue(v5, formatter, Type2, v28);
  }

  return v15;
}

CFStringRef CFNumberFormatterCreateStringWithValue( CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberType numberType, const void *valuePtr)
{
  unint64_t v7 = allocator;
  v51[192] = *MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      unint64_t v7 = (const __CFAllocator *)v8;
    }
    else {
      unint64_t v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v9);
  }
  double v46 = 0.0;
  double valuePtra = 1.0;
  UniChar v10 = (const __CFNumber *)*((void *)formatter + 8);
  double v11 = 1.0;
  if (v10)
  {
    if (CFNumberGetValue(v10, kCFNumberFloat64Type, &valuePtra)) {
      double v11 = valuePtra;
    }
    else {
      double valuePtra = 1.0;
    }
  }

  if (modf(v11, &v46) < 0.00000011920929)
  {
    double v11 = floor(v11);
    double valuePtra = v11;
  }

  int v45 = 0;
  if ((unint64_t)numberType > kCFNumberDoubleType)
  {
LABEL_28:
    if ((numberType & 0xFFFFFFFFFFFFFFFBLL) != 0xA)
    {
      double v28 = 0LL;
      switch(numberType)
      {
        case kCFNumberSInt8Type:
        case kCFNumberCharType:
          char v33 = *(_BYTE *)valuePtr;
          if (!*(_BYTE *)valuePtr)
          {
            int v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }

          if (v11 != 1.0) {
            char v33 = (int)(v11 * (double)v33);
          }
          _CFBigNumInitWithInt8((uint64_t)v49, v33);
          goto LABEL_34;
        case kCFNumberSInt16Type:
        case kCFNumberShortType:
          __int16 v34 = *(_WORD *)valuePtr;
          if (!*(_WORD *)valuePtr)
          {
            int v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }

          if (v11 != 1.0) {
            __int16 v34 = (int)(v11 * (double)v34);
          }
          _CFBigNumInitWithInt16((uint64_t)v49, v34);
          goto LABEL_34;
        case kCFNumberSInt32Type:
        case kCFNumberIntType:
          if (!*(_DWORD *)valuePtr)
          {
            int v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }

          if (v11 == 1.0) {
            unsigned int v35 = *(_DWORD *)valuePtr;
          }
          else {
            unsigned int v35 = (int)(v11 * (double)*(int *)valuePtr);
          }
          _CFBigNumInitWithInt32((uint64_t)v49, v35);
          goto LABEL_34;
        case kCFNumberMaxType|kCFNumberSInt8Type:
          uint64_t v38 = valuePtr;
          uint64_t v36 = *(void *)valuePtr;
          uint64_t v37 = v38[1];
          if (!(v37 | v36))
          {
            int v12 = (const void *)*((void *)formatter + 9);
            if (v12) {
              return (CFStringRef)CFRetain(v12);
            }
          }

          uint64_t v39 = v37;
          uint64_t v40 = v36;
          *(_OWORD *)&uint64_t v41 = (__int128)(v11 * (double)*(__int128 *)&v39);
          if (v11 == 1.0) {
            uint64_t v43 = v37;
          }
          else {
            uint64_t v43 = v41;
          }
          if (v11 == 1.0) {
            uint64_t v44 = v36;
          }
          else {
            uint64_t v44 = v42;
          }
          _CFBigNumInitWithInt128((uint64_t)v49, v43, v44);
          goto LABEL_34;
        default:
          return v28;
      }

      return v28;
    }

CFNumberRef CFNumberFormatterCreateNumberFromString( CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  char v5 = options;
  unint64_t v9 = allocator;
  double valuePtr[2] = *MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v10 = _CFGetTSD(1u);
    if (v10) {
      unint64_t v9 = (const __CFAllocator *)v10;
    }
    else {
      unint64_t v9 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v11 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v11 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v11);
  }
  if (rangep)
  {
    CFRange rangepa = *rangep;
  }

  else
  {
    rangepa.location = 0LL;
    rangepa.CFIndex length = CFStringGetLength(string);
  }

  int v12 = (const __CFNumber *)*((void *)formatter + 8);
  *((void *)formatter + 8) = 0LL;
  int ValueFromString = CFNumberFormatterGetValueFromString(formatter, string, &rangepa, kCFNumberSInt64Type, valuePtr);
  *((void *)formatter + 8) = v12;
  if (!ValueFromString) {
    goto LABEL_29;
  }
  if (v12)
  {
    uint64_t v14 = valuePtr[0];
    double v34 = 1.0;
    if (CFNumberGetValue(v12, kCFNumberFloat64Type, &v34)) {
      double v15 = v34;
    }
    else {
      double v15 = 1.0;
    }
    if (v14 >= 0) {
      uint64_t v16 = v14;
    }
    else {
      uint64_t v16 = -v14;
    }
    double v17 = fabs(v15);
    if (modf(v15, &v33) == 0.0)
    {
      uint64_t v19 = v14 / (uint64_t)v15;
    }

    else if (v15 == -1.0)
    {
      uint64_t v19 = -v14;
    }

    else
    {
      if (v15 == 1.0) {
        goto LABEL_27;
      }
      int v24 = -1;
      do
        double v25 = scalbn(v15, ++v24);
      while (modf(v25, &v32) != 0.0);
      for (uint64_t i = (uint64_t)v32; ; i *= 2LL)
      {
        unint64_t v27 = i >= 0 ? i : -i;
        if (v27 >> 50) {
          break;
        }
        LOBYTE(v24) = v24 + 1;
      }

      if ((unint64_t)v16 >> 53)
      {
        uint64_t v28 = 0LL;
        uint64_t v29 = v14;
        do
        {
          uint64_t v14 = v29 - i;
          uint64_t v30 = v29 - i;
          v28 += 1LL << v24;
          if (v30 < 0) {
            uint64_t v30 = -v30;
          }
          unint64_t v31 = (unint64_t)v30 >> 53;
          uint64_t v29 = v14;
        }

        while (v31);
      }

      else
      {
        uint64_t v28 = 0LL;
      }

      uint64_t v19 = v28 + (uint64_t)((double)v14 / v15);
    }

    valuePtr[0] = v19;
  }

Boolean CFNumberFormatterGetValueFromString( CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFNumberType numberType, void *valuePtr)
{
  int64_t v56 = valuePtr;
  CFStringRef theString = string;
  v62[128] = *MEMORY[0x1895F89C0];
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v8);
  }
  if (*((_BYTE *)formatter + 80)) {
    CompressedString = __CFNumberFormatterCreateCompressedString(theString, 0, &rangep->location);
  }
  else {
    CompressedString = (const __CFString *)CFRetain(theString);
  }
  uint64_t v10 = CompressedString;
  if (*((_BYTE *)formatter + 80))
  {
    CFIndex Length = CFStringGetLength(CompressedString);
    CFIndex location = 0LL;
  }

  else
  {
    if (rangep)
    {
      CFIndex location = rangep->location;
      CFIndex Length = rangep->length;
    }

    else
    {
      CFIndex Length = CFStringGetLength(CompressedString);
      CFIndex location = 0LL;
    }

    CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    if (Length >= 1)
    {
      uint64_t v36 = Predefined;
      while (1)
      {
        UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(v10, location);
        if (!CFCharacterSetIsCharacterMember(v36, CharacterAtIndex)) {
          break;
        }
        ++location;
        BOOL v33 = Length-- <= 1;
        if (v33)
        {
          CFIndex Length = 0LL;
          break;
        }
      }
    }
  }

  double v13 = (const __CFString *)*((void *)formatter + 9);
  float v58 = rangep;
  if (v13)
  {
    if (*((_BYTE *)formatter + 80)) {
      uint64_t v14 = __CFNumberFormatterCreateCompressedString(v13, 0, 0LL);
    }
    else {
      uint64_t v14 = (const __CFString *)CFRetain(v13);
    }
    uint64_t v16 = v14;
    BOOL v15 = CFStringCompare(v10, v14, 0LL) == kCFCompareEqualTo;
    CFRelease(v16);
  }

  else
  {
    BOOL v15 = 0;
  }

  if ((Length & ~(Length >> 63)) >= 1024) {
    CFIndex v17 = 1024LL;
  }
  else {
    CFIndex v17 = Length & ~(Length >> 63);
  }
  CharactersPtr = CFStringGetCharactersPtr(v10);
  uint64_t v20 = MEMORY[0x1895F8858](CharactersPtr, v19);
  CFNumberType v22 = (UChar *)((char *)&v52 - v21);
  if (v20)
  {
    if (!*((_BYTE *)formatter + 80))
    {
      CFNumberType v22 = (UChar *)(v20 + 2 * location);
      unint64_t v23 = (const __CFNumber **)((char *)formatter + 64);
      double v57 = (const __CFNumber *)*((void *)formatter + 8);
LABEL_26:
      UniChar *v23 = 0LL;
      goto LABEL_27;
    }

    unint64_t v23 = (const __CFNumber **)((char *)formatter + 64);
    double v57 = (const __CFNumber *)*((void *)formatter + 8);
    *((void *)formatter + 8) = 0LL;
    CFNumberType v22 = (UChar *)v20;
LABEL_23:
    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 7));
    double v25 = (const void *)*((void *)formatter + 8);
    if (v25) {
      CFRelease(v25);
    }
    goto LABEL_26;
  }

  if (!v17)
  {
    if (v10) {
      CFRelease(v10);
    }
    return 0;
  }

  v63.CFIndex location = location;
  v63.CFIndex length = v17;
  CFStringGetCharacters(v10, v63, (UniChar *)((char *)&v52 - v21));
  unint64_t v23 = (const __CFNumber **)((char *)formatter + 64);
  double v57 = (const __CFNumber *)*((void *)formatter + 8);
  int v24 = *((unsigned __int8 *)formatter + 80);
  *((void *)formatter + 8) = 0LL;
  if (v24) {
    goto LABEL_23;
  }
LABEL_27:
  BOOL v26 = (unint64_t)numberType <= kCFNumberCFIndexType && ((1LL << numberType) & 0x4F9E) != 0;
  __cficu_unum_setAttribute(*((void *)formatter + 2), 0, v26);
  uint64_t v61 = 0LL;
  if (v15)
  {
    uint64_t v27 = 0LL;
    HIDWORD(v61) = CFStringGetLength(v10);
    double v28 = 0.0;
    uint64_t v29 = v58;
  }

  else
  {
    unint64_t v55 = v23;
    bzero(v62, 0x400uLL);
    int v30 = __cficu_unum_parseDecimal( *((void *)formatter + 2),  v22,  v17,  (unsigned int *)&v61 + 1,  (const UInt8 *)v62,  1024LL,  (int *)&v61);
    int v31 = v30;
    int v32 = v61;
    BOOL v33 = (int)v61 >= 1 || v30 <= 0;
    if (!v33 && v26)
    {
      unint64_t v60 = 0LL;
      *__error() = 0;
      uint64_t v27 = strtoll_l((const char *)v62, &v60, 10, 0LL);
      if (*__error() || *v60)
      {
        int v32 = 3;
        LODWORD(v61) = 3;
      }

      else
      {
        int v32 = v61;
      }
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    uint64_t v29 = v58;
    double v28 = 0.0;
    if (v32 > 0)
    {
      unint64_t v23 = v55;
    }

    else
    {
      BOOL v33 = v31 < 1;
      unint64_t v23 = v55;
      if (!v33)
      {
        unint64_t v60 = 0LL;
        *__error() = 0;
        double v28 = strtod_l((const char *)v62, &v60, 0LL);
        if (*__error() || *v60) {
          LODWORD(v61) = 3;
        }
      }
    }
  }

  if (*((_BYTE *)formatter + 80))
  {
    if (v29)
    {
      CFIndex v38 = v29->location;
      if (SHIDWORD(v61) >= 1)
      {
        uint64_t v53 = v27;
        CFNumberType v54 = numberType;
        unint64_t v55 = v23;
        uint64_t v39 = 0LL;
        CFIndex v40 = v29->length + v38;
        while (v38 < v40)
        {
          CFIndex v41 = v38;
          while (1)
          {
            int v42 = v22[v39];
            int v43 = CFStringGetCharacterAtIndex(theString, v41);
            uint64_t v44 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
            int v45 = CFCharacterSetIsCharacterMember(v44, v43) ? 32 : v43;
            CFIndex v38 = v41 + 1;
            if (v42 == v45) {
              break;
            }
            ++v41;
            if (v40 == v38)
            {
              CFIndex v38 = v40;
              numberType = v54;
              goto LABEL_74;
            }
          }

          ++v39;
          numberType = v54;
          if (v39 >= SHIDWORD(v61))
          {
            CFIndex v38 = v41 + 1;
            break;
          }
        }

void CFNumberFormatterSetProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key, CFTypeRef value)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  int v41 = 0;
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v6);
  }
  if (CFEqual(@"kCFNumberFormatterFormattingContextKey", key))
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    __cficu_unum_setContext(*((void *)formatter + 2), valuePtr, &v41);
  }

  uint64_t v7 = *((void *)formatter + 4);
  if ((unint64_t)(v7 - 8) < 0xFFFFFFFFFFFFFFFDLL && v7 != 9 || @"kCFNumberFormatterIsLenientKey" == key)
  {
    if (@"kCFNumberFormatterCurrencyCodeKey" == key)
    {
      CFIndex Length = CFStringGetLength((CFStringRef)value);
      if (Length >= 768) {
        CFIndex v14 = 768LL;
      }
      else {
        CFIndex v14 = Length;
      }
      v45.CFIndex location = 0LL;
      v45.CFIndex length = v14;
      CFStringGetCharacters((CFStringRef)value, v45, buffer);
      uint64_t v15 = *((void *)formatter + 2);
      unsigned int v16 = 5;
      goto LABEL_59;
    }

    if (@"kCFNumberFormatterDecimalSeparatorKey" == key)
    {
      CFIndex v17 = CFStringGetLength((CFStringRef)value);
      if (v17 >= 768) {
        CFIndex v18 = 768LL;
      }
      else {
        CFIndex v18 = v17;
      }
      v46.CFIndex location = 0LL;
      v46.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v46, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 0;
      goto LABEL_109;
    }

    if (@"kCFNumberFormatterCurrencyDecimalSeparatorKey" == key)
    {
      CFIndex v21 = CFStringGetLength((CFStringRef)value);
      if (v21 >= 768) {
        CFIndex v18 = 768LL;
      }
      else {
        CFIndex v18 = v21;
      }
      v47.CFIndex location = 0LL;
      v47.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v47, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 10;
      goto LABEL_109;
    }

    if (@"kCFNumberFormatterAlwaysShowDecimalSeparatorKey" == key)
    {
      uint64_t v11 = *((void *)formatter + 2);
      uint64_t v10 = &__kCFBooleanTrue == value;
      int v12 = 2;
      goto LABEL_74;
    }

    if (@"kCFNumberFormatterGroupingSeparatorKey" == key)
    {
      CFIndex v22 = CFStringGetLength((CFStringRef)value);
      if (v22 >= 768) {
        CFIndex v18 = 768LL;
      }
      else {
        CFIndex v18 = v22;
      }
      v48.CFIndex location = 0LL;
      v48.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v48, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 1;
      goto LABEL_109;
    }

    if (@"kCFNumberFormatterUseGroupingSeparatorKey" == key)
    {
      uint64_t v11 = *((void *)formatter + 2);
      uint64_t v10 = &__kCFBooleanTrue == value;
      int v12 = 1;
      goto LABEL_74;
    }

    if (@"kCFNumberFormatterPercentSymbolKey" == key)
    {
      CFIndex v23 = CFStringGetLength((CFStringRef)value);
      if (v23 >= 768) {
        CFIndex v18 = 768LL;
      }
      else {
        CFIndex v18 = v23;
      }
      v49.CFIndex location = 0LL;
      v49.CFIndex length = v18;
      CFStringGetCharacters((CFStringRef)value, v49, buffer);
      uint64_t v19 = *((void *)formatter + 2);
      unsigned int v20 = 3;
      goto LABEL_109;
    }

    if (@"kCFNumberFormatterZeroSymbolKey" == key)
    {
      int v24 = (const void *)*((void *)formatter + 9);
      if (value) {
        CFTypeRef v25 = CFRetain(value);
      }
      else {
        CFTypeRef v25 = 0LL;
      }
      *((void *)formatter + 9) = v25;
      if (!v24) {
        goto LABEL_110;
      }
    }

    else
    {
      if (@"kCFNumberFormatterNaNSymbolKey" == key)
      {
        CFIndex v26 = CFStringGetLength((CFStringRef)value);
        if (v26 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v26;
        }
        v50.CFIndex location = 0LL;
        v50.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v50, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 15;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterInfinitySymbolKey" == key)
      {
        CFIndex v27 = CFStringGetLength((CFStringRef)value);
        if (v27 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v27;
        }
        v51.CFIndex location = 0LL;
        v51.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v51, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 14;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterMinusSignKey" == key)
      {
        CFIndex v28 = CFStringGetLength((CFStringRef)value);
        if (v28 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v28;
        }
        v52.CFIndex location = 0LL;
        v52.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v52, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 6;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterPlusSignKey" == key)
      {
        CFIndex v29 = CFStringGetLength((CFStringRef)value);
        if (v29 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v29;
        }
        v53.CFIndex location = 0LL;
        v53.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v53, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 7;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterCurrencySymbolKey" == key)
      {
        CFIndex v30 = CFStringGetLength((CFStringRef)value);
        if (v30 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v30;
        }
        v54.CFIndex location = 0LL;
        v54.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v54, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 8;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterExponentSymbolKey" == key)
      {
        CFIndex v31 = CFStringGetLength((CFStringRef)value);
        if (v31 >= 768) {
          CFIndex v18 = 768LL;
        }
        else {
          CFIndex v18 = v31;
        }
        v55.CFIndex location = 0LL;
        v55.CFIndex length = v18;
        CFStringGetCharacters((CFStringRef)value, v55, buffer);
        uint64_t v19 = *((void *)formatter + 2);
        unsigned int v20 = 11;
        goto LABEL_109;
      }

      if (@"kCFNumberFormatterMinIntegerDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 4;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterMaxIntegerDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 3;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterMinFractionDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 7;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterMaxFractionDigitsKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 6;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterGroupingSizeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 10;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterSecondaryGroupingSizeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 15;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterRoundingModeKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 11;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterRoundingIncrementKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberDoubleType, buffer);
        __cficu_unum_setDoubleAttribute(*((void *)formatter + 2), 12, *(double *)buffer);
        goto LABEL_110;
      }

      if (@"kCFNumberFormatterFormatWidthKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 13;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterPaddingPositionKey" == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        uint64_t v11 = *((void *)formatter + 2);
        uint64_t v10 = valuePtr;
        int v12 = 14;
        goto LABEL_74;
      }

      if (@"kCFNumberFormatterPaddingCharacterKey" == key)
      {
        CFIndex v32 = CFStringGetLength((CFStringRef)value);
        if (v32 >= 768) {
          CFIndex v14 = 768LL;
        }
        else {
          CFIndex v14 = v32;
        }
        v56.CFIndex location = 0LL;
        v56.CFIndex length = v14;
        CFStringGetCharacters((CFStringRef)value, v56, buffer);
        uint64_t v15 = *((void *)formatter + 2);
        unsigned int v16 = 4;
        goto LABEL_59;
      }

      if (@"kCFNumberFormatterDefaultFormatKey" == key) {
        goto LABEL_110;
      }
      if (@"kCFNumberFormatterMultiplierKey" != key)
      {
        if (@"kCFNumberFormatterPositivePrefixKey" == key)
        {
          CFIndex v34 = CFStringGetLength((CFStringRef)value);
          if (v34 >= 768) {
            CFIndex v14 = 768LL;
          }
          else {
            CFIndex v14 = v34;
          }
          v57.CFIndex location = 0LL;
          v57.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v57, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 0;
        }

        else if (@"kCFNumberFormatterPositiveSuffixKey" == key)
        {
          CFIndex v35 = CFStringGetLength((CFStringRef)value);
          if (v35 >= 768) {
            CFIndex v14 = 768LL;
          }
          else {
            CFIndex v14 = v35;
          }
          v58.CFIndex location = 0LL;
          v58.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v58, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 1;
        }

        else if (@"kCFNumberFormatterNegativePrefixKey" == key)
        {
          CFIndex v36 = CFStringGetLength((CFStringRef)value);
          if (v36 >= 768) {
            CFIndex v14 = 768LL;
          }
          else {
            CFIndex v14 = v36;
          }
          v59.CFIndex location = 0LL;
          v59.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v59, buffer);
          uint64_t v15 = *((void *)formatter + 2);
          unsigned int v16 = 2;
        }

        else
        {
          if (@"kCFNumberFormatterNegativeSuffixKey" != key)
          {
            if (@"kCFNumberFormatterPerMillSymbolKey" == key)
            {
              CFIndex v38 = CFStringGetLength((CFStringRef)value);
              if (v38 >= 768) {
                CFIndex v18 = 768LL;
              }
              else {
                CFIndex v18 = v38;
              }
              v61.CFIndex location = 0LL;
              v61.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v61, buffer);
              uint64_t v19 = *((void *)formatter + 2);
              unsigned int v20 = 12;
            }

            else if (@"kCFNumberFormatterInternationalCurrencySymbolKey" == key)
            {
              CFIndex v39 = CFStringGetLength((CFStringRef)value);
              if (v39 >= 768) {
                CFIndex v18 = 768LL;
              }
              else {
                CFIndex v18 = v39;
              }
              v62.CFIndex location = 0LL;
              v62.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v62, buffer);
              uint64_t v19 = *((void *)formatter + 2);
              unsigned int v20 = 9;
            }

            else
            {
              if (@"kCFNumberFormatterCurrencyGroupingSeparatorKey" != key)
              {
                if (@"kCFNumberFormatterIsLenientKey" == key)
                {
                  uint64_t v10 = &__kCFBooleanTrue == value;
                  *((_BYTE *)formatter + 80) = v10;
                  uint64_t v11 = *((void *)formatter + 2);
                  int v12 = 19;
                }

                else if (@"kCFNumberFormatterUseSignificantDigitsKey" == key)
                {
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = &__kCFBooleanTrue == value;
                  int v12 = 16;
                }

                else if (@"kCFNumberFormatterMinSignificantDigitsKey" == key)
                {
                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = valuePtr;
                  int v12 = 17;
                }

                else
                {
                  if (@"kCFNumberFormatterMaxSignificantDigitsKey" != key)
                  {
                    if (@"kCFNumberFormatterUsesCharacterDirectionKey" != key)
                    {
                      if (@"kCFNumberFormatterMinGroupingDigitsKey" != key) {
                        goto LABEL_110;
                      }
                      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                      uint64_t v10 = valuePtr;
                      if (valuePtr == -1)
                      {
                        uint64_t v10 = 4294967294LL;
                        unsigned int valuePtr = -2;
                      }

                      uint64_t v11 = *((void *)formatter + 2);
                      int v12 = 22;
                      goto LABEL_74;
                    }

                    *((_BYTE *)formatter + 82) = &__kCFBooleanTrue == value;
LABEL_110:
                    return;
                  }

                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  uint64_t v11 = *((void *)formatter + 2);
                  uint64_t v10 = valuePtr;
                  int v12 = 18;
                }

LABEL_59:
        __cficu_unum_setTextAttribute(v15, v16, buffer, v14, &v41);
        goto LABEL_110;
      }

      int v24 = (const void *)*((void *)formatter + 8);
      if (value) {
        CFTypeRef v33 = CFRetain(value);
      }
      else {
        CFTypeRef v33 = 0LL;
      }
      *((void *)formatter + 8) = v33;
      *((_BYTE *)formatter + 81) = value != 0LL;
      if (!v24) {
        goto LABEL_110;
      }
    }

    CFRelease(v24);
    goto LABEL_110;
  }

  v35.CFIndex location = location;
  v35.CFIndex length = length;
  return __CFStringEncodeByteStream(theString, v35, v10, v12, v11, (UniChar *)buffer, maxBufLen, usedBufLen);
}

      int v43 = __CFExceptionProem(v6, v7);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: both NSBinarySearchingFirstEqual and NSBinarySearchingLastEqual options cannot be specified",  v43);
      uint64_t v44 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
      objc_exception_throw(v44);
    }
  }

  if (v14)
  {
    CFRange v45 = v14;
    CFIndex v34 = _os_log_pack_size();
    CFIndex v35 = (char *)&v54 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFRange v46 = _os_log_pack_fill();
    CFRange v47 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v46,  (uint64_t)"-[NSArray indexOfObject:inSortedRange:options:usingComparator:]",  location,  length,  --v45);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v47,  "-[NSArray indexOfObject:inSortedRange:options:usingComparator:]",  location,  length,  v45);
  }

  else
  {
    CFIndex v34 = _os_log_pack_size();
    CFIndex v35 = (char *)&v54 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFIndex v36 = _os_log_pack_fill();
    CFIndex v37 = __os_log_helper_1_2_3_8_32_8_0_8_0( v36,  (uint64_t)"-[NSArray indexOfObject:inSortedRange:options:usingComparator:]",  location,  length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v37,  "-[NSArray indexOfObject:inSortedRange:options:usingComparator:]",  location,  length);
  }

  CFRange v48 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v35,  v34);
  objc_exception_throw(v48);
  return -[NSArray indexOfObjectAtIndexes:options:passingTest:](v49, v50, v51, v52, v53);
}

      int v43 = __CFExceptionProem(v6, v7);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: both NSBinarySearchingFirstEqual and NSBinarySearchingLastEqual options cannot be specified",  v43);
      uint64_t v44 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
      objc_exception_throw(v44);
    }
  }

  if (v14)
  {
    CFRange v45 = v14;
    CFIndex v34 = _os_log_pack_size();
    CFIndex v35 = (char *)&v54 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFRange v46 = _os_log_pack_fill();
    CFRange v47 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v46,  (uint64_t)"-[NSOrderedSet indexOfObject:inSortedRange:options:usingComparator:]",  location,  length,  --v45);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v47,  "-[NSOrderedSet indexOfObject:inSortedRange:options:usingComparator:]",  location,  length,  v45);
  }

  else
  {
    CFIndex v34 = _os_log_pack_size();
    CFIndex v35 = (char *)&v54 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFIndex v36 = _os_log_pack_fill();
    CFIndex v37 = __os_log_helper_1_2_3_8_32_8_0_8_0( v36,  (uint64_t)"-[NSOrderedSet indexOfObject:inSortedRange:options:usingComparator:]",  location,  length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v37,  "-[NSOrderedSet indexOfObject:inSortedRange:options:usingComparator:]",  location,  length);
  }

  CFRange v48 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v35,  v34);
  objc_exception_throw(v48);
  return -[NSOrderedSet indexOfObjectAtIndexes:options:passingTest:](v49, v50, v51, v52, v53);
}

CFTypeRef CFNumberFormatterCopyProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key)
{
  valuePtr[192] = *MEMORY[0x1895F89C0];
  int v36 = 0;
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  }
  if (CFEqual(@"kCFNumberFormatterFormattingContextKey", key))
  {
    int Context = __cficu_unum_getContext(*((void *)formatter + 2), 1LL, &v36);
LABEL_4:
    LODWORD(valuePtr[0]) = Context;
LABEL_5:
    unint64_t v6 = CFGetAllocator(formatter);
    CFNumberType v7 = kCFNumberSInt32Type;
    return CFNumberCreate(v6, v7, valuePtr);
  }

  uint64_t v9 = *((void *)formatter + 4);
  if (@"kCFNumberFormatterCurrencyCodeKey" == key)
  {
    Textint Attribute = __cficu_unum_getTextAttribute( *((void *)formatter + 2),  5u,  (const UniChar *)valuePtr,  768LL,  &v36);
    CFIndex v15 = TextAttribute;
    int v16 = v36;
    if (v36 <= 0 && !TextAttribute)
    {
      Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3));
      CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
      if (!CStringPtr)
      {
        CStringPtr = buffer;
        if (!CFStringGetCString(Identifier, buffer, 768LL, 0x600u)) {
          return 0LL;
        }
      }

      int v35 = 0;
      uint64_t v19 = __cficu_unum_open(2u, 0LL, 0LL, (uint64_t)CStringPtr, 0LL, &v35);
      if (v19)
      {
        unsigned int v20 = (const void *)v19;
        CFIndex v15 = (int)__cficu_unum_getTextAttribute(v19, 5u, (const UniChar *)valuePtr, 768LL, &v35);
        __cficu_unum_close(v20);
      }

      else
      {
        CFIndex v15 = 0LL;
      }

      int v16 = v36;
    }

    CFTypeRef result = 0LL;
    if (v16 <= 0 && v15 >= 1 && v15 <= 768) {
      goto LABEL_95;
    }
    return result;
  }

  if (@"kCFNumberFormatterDecimalSeparatorKey" == key)
  {
    uint64_t v21 = *((void *)formatter + 2);
    unsigned int v22 = 0;
  }

  else if (@"kCFNumberFormatterCurrencyDecimalSeparatorKey" == key)
  {
    uint64_t v21 = *((void *)formatter + 2);
    unsigned int v22 = 10;
  }

  else
  {
    if (@"kCFNumberFormatterAlwaysShowDecimalSeparatorKey" == key)
    {
      uint64_t v23 = *((void *)formatter + 2);
      int v24 = 2;
      goto LABEL_76;
    }

    if (@"kCFNumberFormatterGroupingSeparatorKey" == key)
    {
      uint64_t v21 = *((void *)formatter + 2);
      unsigned int v22 = 1;
    }

    else
    {
      if (@"kCFNumberFormatterUseGroupingSeparatorKey" == key)
      {
        uint64_t v23 = *((void *)formatter + 2);
        int v24 = 1;
        goto LABEL_76;
      }

      if (@"kCFNumberFormatterPercentSymbolKey" == key)
      {
        uint64_t v21 = *((void *)formatter + 2);
        unsigned int v22 = 3;
      }

      else
      {
        if (@"kCFNumberFormatterZeroSymbolKey" == key)
        {
          CFTypeRef result = (CFTypeRef)*((void *)formatter + 9);
          if (!result) {
            return result;
          }
          return CFRetain(result);
        }

        if (@"kCFNumberFormatterNaNSymbolKey" == key)
        {
          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 15;
        }

        else if (@"kCFNumberFormatterInfinitySymbolKey" == key)
        {
          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 14;
        }

        else if (@"kCFNumberFormatterMinusSignKey" == key)
        {
          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 6;
        }

        else if (@"kCFNumberFormatterPlusSignKey" == key)
        {
          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 7;
        }

        else if (@"kCFNumberFormatterCurrencySymbolKey" == key)
        {
          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 8;
        }

        else
        {
          if (@"kCFNumberFormatterExponentSymbolKey" != key)
          {
            if (@"kCFNumberFormatterMinIntegerDigitsKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 4;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterMaxIntegerDigitsKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 3;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterMinFractionDigitsKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 7;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterMaxFractionDigitsKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 6;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterGroupingSizeKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 10;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterSecondaryGroupingSizeKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 15;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterRoundingModeKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 11;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterRoundingIncrementKey" == key)
            {
              valuePtr[0] = __cficu_unum_getDoubleAttribute(*((void *)formatter + 2), 12);
              unint64_t v6 = CFGetAllocator(formatter);
              CFNumberType v7 = kCFNumberDoubleType;
              return CFNumberCreate(v6, v7, valuePtr);
            }

            if (@"kCFNumberFormatterFormatWidthKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 13;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterPaddingPositionKey" == key)
            {
              uint64_t v31 = *((void *)formatter + 2);
              int v32 = 14;
              goto LABEL_107;
            }

            if (@"kCFNumberFormatterPaddingCharacterKey" == key)
            {
              uint64_t v33 = *((void *)formatter + 2);
              unsigned int v34 = 4;
              goto LABEL_109;
            }

            if (@"kCFNumberFormatterDefaultFormatKey" == key)
            {
              CFTypeRef result = (CFTypeRef)*((void *)formatter + 6);
              if (!result) {
                return result;
              }
            }

            else
            {
              if (@"kCFNumberFormatterMultiplierKey" != key)
              {
                if (@"kCFNumberFormatterPositivePrefixKey" == key)
                {
                  uint64_t v33 = *((void *)formatter + 2);
                  unsigned int v34 = 0;
                }

                else if (@"kCFNumberFormatterPositiveSuffixKey" == key)
                {
                  uint64_t v33 = *((void *)formatter + 2);
                  unsigned int v34 = 1;
                }

                else if (@"kCFNumberFormatterNegativePrefixKey" == key)
                {
                  uint64_t v33 = *((void *)formatter + 2);
                  unsigned int v34 = 2;
                }

                else
                {
                  if (@"kCFNumberFormatterNegativeSuffixKey" != key)
                  {
                    if (@"kCFNumberFormatterPerMillSymbolKey" == key)
                    {
                      uint64_t v21 = *((void *)formatter + 2);
                      unsigned int v22 = 12;
                    }

                    else if (@"kCFNumberFormatterInternationalCurrencySymbolKey" == key)
                    {
                      uint64_t v21 = *((void *)formatter + 2);
                      unsigned int v22 = 9;
                    }

                    else
                    {
                      if (@"kCFNumberFormatterCurrencyGroupingSeparatorKey" != key)
                      {
                        if (@"kCFNumberFormatterIsLenientKey" == key)
                        {
                          CFIndex v26 = (CFTypeRef *)&kCFBooleanTrue;
                          BOOL v27 = *((_BYTE *)formatter + 80) == 0;
                          goto LABEL_77;
                        }

                        if (@"kCFNumberFormatterUseSignificantDigitsKey" != key)
                        {
                          if (@"kCFNumberFormatterMinSignificantDigitsKey" == key)
                          {
                            uint64_t v31 = *((void *)formatter + 2);
                            int v32 = 17;
                          }

                          else
                          {
                            if (@"kCFNumberFormatterMaxSignificantDigitsKey" != key)
                            {
                              if (@"kCFNumberFormatterMinGroupingDigitsKey" == key)
                              {
                                int Attribute = __cficu_unum_getAttribute(*((void *)formatter + 2), 22);
                                if (Attribute == -2) {
                                  int v13 = -1;
                                }
                                else {
                                  int v13 = Attribute;
                                }
                                LODWORD(valuePtr[0]) = v13;
                                goto LABEL_5;
                              }

                              return 0LL;
                            }

                            uint64_t v31 = *((void *)formatter + 2);
                            int v32 = 18;
                          }

LABEL_91:
  int Symbol = __cficu_unum_getSymbol(v21, v22, (const UniChar *)valuePtr, 768LL, &v36);
LABEL_92:
  int v29 = Symbol;
  CFTypeRef result = 0LL;
  if (v36 <= 0 && v29 <= 768)
  {
    CFIndex v15 = v29;
LABEL_95:
    CFIndex v30 = CFGetAllocator(formatter);
    return CFStringCreateWithCharacters(v30, (const UniChar *)valuePtr, v15);
  }

  return result;
}

    CFRelease(v57);
  }

        LODWORD(v14) = 4;
LABEL_93:
        unint64_t v6 = a6;
        if (a5 {
          && (_DWORD)v14
        }
          && v10 == 3
          && v8 == a5
          && *v13 == 27
          && v7 >= (unint64_t)(v13 + 3)
          && !strncmp("(B", v13 + 1, 2uLL))
        {
          v9 += 3LL;
        }

Boolean CFNumberFormatterGetDecimalInfoForCurrencyCode( CFStringRef currencyCode, int32_t *defaultFractionDigits, double *roundingIncrement)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  v9.CFIndex location = 0LL;
  v9.CFIndex length = 3LL;
  CFStringGetCharacters(currencyCode, v9, buffer);
  buffer[3] = 0;
  int v6 = 0;
  if (defaultFractionDigits) {
    *defaultFractionDigits = __cficu_ucurr_getDefaultFractionDigits(buffer, &v6);
  }
  if (roundingIncrement) {
    *roundingIncrement = __cficu_ucurr_getRoundingIncrement(buffer, &v6);
  }
  if (v6 > 0) {
    return 0;
  }
  if (!defaultFractionDigits)
  {
    if (!roundingIncrement) {
      return 1;
    }
    return *roundingIncrement >= 0.0;
  }

  Boolean result = *defaultFractionDigits >= 0;
  if (roundingIncrement && (*defaultFractionDigits & 0x80000000) == 0) {
    return *roundingIncrement >= 0.0;
  }
  return result;
}

unint64_t _CFNumberFormatterGetFormatter(unint64_t *a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 57) {
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  }
  return a1[2];
}

void __CFNumberFormatterApplySymbolPrefs(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      Intint Value = CFStringGetIntValue(a1);
      HIDWORD(v17) = 0;
      CFIndex Length = CFStringGetLength(a2);
      if (Length < 1)
      {
        __cficu_unum_setSymbol(*(void *)(a3 + 16), IntValue, &word_180ED667C, 0LL, (int *)&v17 + 1);
      }

      else
      {
        uint64_t v11 = Length;
        if (Length >= 768) {
          CFIndex v12 = 768LL;
        }
        else {
          CFIndex v12 = Length;
        }
        MEMORY[0x1895F8858](Length, v10);
        CFIndex v14 = (UniChar *)((char *)&v17 - v13);
        CharactersPtr = CFStringGetCharactersPtr(a2);
        if (CharactersPtr)
        {
          int v16 = (UChar *)CharactersPtr;
        }

        else
        {
          v19.CFIndex location = 0LL;
          v19.CFIndex length = v12;
          CFStringGetCharacters(a2, v19, v14);
          int v16 = v14;
          uint64_t v11 = v12;
        }

        __cficu_unum_setSymbol(*(void *)(a3 + 16), IntValue, v16, v11, (int *)&v17 + 1);
      }
    }
  }

void sub_180AB0F74(_Unwind_Exception *a1)
{
}

void mutateError(SEL sel, uint64_t a2, objc_class *a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = sel;
  char v5 = &NSInvalidArgumentException;
  if (a2 != 3)
  {
    if (a2 == 2)
    {
      uint64_t v14 = __CFExceptionProem(a3, sel);
      uint64_t v8 = (__NSCFString *)_CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"%@: nil argument",  v14);
      goto LABEL_8;
    }

    if (a2 != 1)
    {
      Name = sel_getName(sel);
      Class Class = object_getClass(v3);
      uint64_t v8 = (__NSCFString *)_CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"Can't call %s in %@",  Name,  Class);
      goto LABEL_8;
    }

    unint64_t v3 = (objc_class *)@"NSInvalidArgumentException";
    CFTypeID v6 = sel_getName(sel);
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"Attempt to mutate immutable object with %s",  v6);
  }

  uint64_t v7 = (uint64_t)*v5;
  uint64_t v13 = __CFExceptionProem(v3, v4);
  uint64_t v8 = (__NSCFString *)_CFThrowFormattedException(v7, @"%@: Range or index out of bounds", v13);
LABEL_8:
  -[__NSCFString insertString:atIndex:](v8, v9, v10, v11);
}

CFTypeRef _DescriptionWithLocaleFunc(void *a1, uint64_t a2)
{
  if (a1)
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      unint64_t v4 = (const __CFString *)[a1 descriptionWithLocale:a2];
    }
    else {
      unint64_t v4 = (const __CFString *)[a1 description];
    }
  }

  else
  {
    unint64_t v4 = @"*nil*";
  }

  if (!v4) {
    unint64_t v4 = @"*nil description*";
  }
  return CFRetain(v4);
}

CFTypeRef _DescriptionWithStringProxyFunc(void *a1, uint64_t a2, uint64_t a3, int a4, _BYTE *a5)
{
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    if (a5) {
      *a5 = 1;
    }
    if (a4)
    {
      uint64_t v10 = (const void *)[a1 _dynamicContextEvaluation:a2 patternString:a3];
      if (v10) {
        return CFRetain(v10);
      }
    }
  }

  else if (a5)
  {
    *a5 = 0;
  }

  return 0LL;
}

void mutateError2(SEL sel, uint64_t a2, objc_class *a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = sel;
  char v5 = &NSInvalidArgumentException;
  if (a2 != 3)
  {
    if (a2 == 2)
    {
      uint64_t v14 = __CFExceptionProem(a3, sel);
      uint64_t v8 = (__NSCFAttributedString *)_CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"%@: nil argument",  v14);
      goto LABEL_8;
    }

    if (a2 != 1)
    {
      Name = sel_getName(sel);
      Class Class = object_getClass(v3);
      uint64_t v8 = (__NSCFAttributedString *)_CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"Can't call %s in %@",  Name,  Class);
      goto LABEL_8;
    }

    unint64_t v3 = (objc_class *)@"NSInvalidArgumentException";
    CFTypeID v6 = sel_getName(sel);
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"Attempt to mutate immutable object with %s",  v6);
  }

  uint64_t v7 = (uint64_t)*v5;
  uint64_t v13 = __CFExceptionProem(v3, v4);
  uint64_t v8 = (__NSCFAttributedString *)_CFThrowFormattedException(v7, @"%@: Range or index out of bounds", v13);
LABEL_8:
  -[__NSCFAttributedString setAttributes:range:](v8, v9, v10, v11);
}

void *__CFFireTimer(void *a1, uint64_t a2)
{
  unint64_t v3 = *(void **)(a2 + 8);
  unint64_t v4 = *(const char **)(a2 + 16);
  char v5 = (void *)_CFAutoreleasePoolPush();
  id v6 = a1;
  id v7 = v3;
  objc_msgSend(v3, v4, a1);

  return _CFAutoreleasePoolPop(v5);
}

uint64_t __CFDescribeTimer(uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, uint64_t *a7)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  CFIndex v12 = *(void **)(a2 + 8);
  uint64_t v13 = *(const char **)(a2 + 16);
  ClassName = object_getClassName(v12);
  Name = sel_getName(v13);
  if (a7) {
    *a7 = object_getMethodImplementation();
  }
  int v16 = "<unknown name>";
  if (ClassName) {
    int v16 = ClassName;
  }
  uint64_t v17 = "<unknown selector>";
  if (Name) {
    uint64_t v17 = Name;
  }
  snprintf(a5, a6, "(CFTimer) %s %s", v16, v17);
  Class Class = object_getClass(v12);
  uint64_t result = dladdr(Class, &v21);
  if ((_DWORD)result)
  {
    dli_fname = v21.dli_fname;
    if (!v21.dli_fname) {
      dli_fname = "<unknown library>";
    }
    return snprintf(a3, a4, "%s", dli_fname);
  }

  return result;
}

unsigned int *_timerRetain(unsigned int *result)
{
  do
    unsigned int v1 = __ldaxr(result);
  while (__stlxr(v1 + 1, result));
  return result;
}

unsigned int *_timerRelease(unsigned int *result)
{
  unsigned int v1 = (id *)result;
  do
  {
    unsigned int v2 = __ldaxr(result);
    BOOL v3 = __OFSUB__(v2, 1);
    signed int v4 = v2 - 1;
  }

  while (__stlxr(v4, result));
  if ((v4 < 0) ^ v3 | (v4 == 0))
  {
    char v5 = (void *)_CFAutoreleasePoolPush();

    free(v1);
    return (unsigned int *)_CFAutoreleasePoolPop(v5);
  }

  return result;
}

void _inputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (id)[a3 retainedDelegate];
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    [v5 stream:a1 handleEvent:a2];
  }
}

void _outputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = (id)[a3 retainedDelegate];
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    [v5 stream:a1 handleEvent:a2];
  }
}

uint64_t OUTLINED_FUNCTION_0_8(uint64_t a1, const __CFString *a2)
{
  return _CFThrowFormattedException(v2, a2);
}

void mergeFunc(uint64_t a1, const __CFDictionary *cf, os_unfair_lock_s *a3)
{
  if (CFGetTypeID(cf) == 18)
  {
    int Value = CFDictionaryGetValue(cf, @"NSUserDefaultsDefaultValue");
    if (Value) {
      -[CFPrefsSource setValue:forKey:from:](a3, (uint64_t)Value, a1, 0LL);
    }
  }

uint64_t remoteStoreChanged(void *a1)
{
  v2[5] = *MEMORY[0x1895F89C0];
  v2[0] = MEMORY[0x1895F87A8];
  v2[1] = 3221225472LL;
  v2[2] = __remoteStoreChanged_block_invoke;
  v2[3] = &unk_18999B4C8;
  v2[4] = a1;
  return [a1 lockedAsync:v2];
}

void sub_180AB58D4( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int buf, __int128 a16, id a17)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  if (a2 == 2)
  {
    id v18 = objc_begin_catch(a1);
    CFRange v19 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(void *)(v17 + 48);
      buf = 138543874;
      WORD2(a16) = 2114;
      *(void *)((char *)&a16 + 6) = v20;
      HIWORD(a16) = 2114;
      a17 = v18;
      _os_log_error_impl( &dword_180A4C000,  v19,  OS_LOG_TYPE_ERROR,  "writing key %{public}@ in cloud domain %{public}@ failed with exception %{public}@",  (uint8_t *)&buf,  0x20u);
    }

    objc_end_catch();
  }

  else
  {
    objc_begin_catch(a1);
  }

  JUMPOUT(0x180AB5880LL);
}

uint64_t __remoteStoreChanged_block_invoke(uint64_t a1)
{
  unsigned int v1 = (id *)(a1 + 32);
  [*(id *)(*(void *)(a1 + 32) + 152) synchronizeForced:1];
  uint64_t v2 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    __remoteStoreChanged_block_invoke_cold_1(v1, v2);
  }
  [*v1 updateShmemEntry];
  return [*v1 asyncNotifyObserversOfWriteFromConnection:0 message:0];
}

void *initSYDRemotePreferencesSource()
{
  if (SyncedDefaultsLibrary_frameworkLibrary
    || (uint64_t result = dlopen("/System/Library/PrivateFrameworks/SyncedDefaults.framework/SyncedDefaults", 2),
        (SyncedDefaultsLibrary_frameworkLibrary = (uint64_t)result) != 0))
  {
    uint64_t result = objc_getClass("SYDRemotePreferencesSource");
    classSYDRemotePreferencesSource = (uint64_t)result;
    getSYDRemotePreferencesSourceClass Class = SYDRemotePreferencesSourceFunction;
  }

  return result;
}

uint64_t SYDRemotePreferencesSourceFunction()
{
  return classSYDRemotePreferencesSource;
}

uint64_t __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

objc_class *__NSDictionaryParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v3 = __CFExceptionProem(result, a2);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@: block is nil", v3);
    signed int v4 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
    objc_exception_throw(v4);
    return (objc_class *)__NSDictionaryEnumerate();
  }

  return result;
}

void __NSDictionaryEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  uint64_t v7 = [a1 count];
  if (v7)
  {
    unint64_t v8 = v7;
    if ((a2 & 1) == 0) {
      goto LABEL_20;
    }
    uint64_t v16 = __CFActiveProcessorCount();
    if (v16 < 2) {
      a2 = 0;
    }
    if ((a2 & 1) != 0)
    {
      uint64_t v9 = 32LL;
      uint64_t v10 = 16LL;
      uint64_t v11 = 4LL;
      if (v8 < 4 * v16) {
        uint64_t v11 = 1LL;
      }
      if (v8 < 16 * v16) {
        uint64_t v10 = v11;
      }
      if (v8 < 32 * v16) {
        uint64_t v9 = v10;
      }
      if (48 * v16 > v8) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 48LL;
      }
      if (v8 < v16 << 6) {
        unint64_t v13 = v12;
      }
      else {
        unint64_t v13 = 64LL;
      }
      uint64_t v14 = (void *)_CFAutoreleasePoolPush();
      uint64_t v15 = [a1 keyEnumerator];
      __int128 v38 = 0u;
      __int128 v37 = 0u;
      __int128 v36 = 0u;
      uint64_t v39 = 0LL;
      size_t v35 = 850045857LL;
      v33[0] = 0LL;
      v33[1] = v33;
      v33[2] = 0x2020000000LL;
      char v34 = 0;
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      void block[2] = ____NSDictionaryEnumerate_block_invoke;
      block[3] = &unk_18999B4F0;
      block[8] = v13;
      block[9] = &v35;
      block[6] = a3;
      block[7] = v33;
      block[4] = v15;
      void block[5] = a1;
      dispatch_apply((v8 + v13 - 1) / v13, 0LL, block);
      _CFAutoreleasePoolPop(v14);
      _Block_object_dispose(v33, 8);
    }

    else
    {
LABEL_20:
      uint64_t v17 = (void *)_CFAutoreleasePoolPush();
      objc_lookUpClass("__NSCFDictionary");
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v31[0] = MEMORY[0x1895F87A8];
        v31[1] = 3221225472LL;
        v31[2] = ____NSDictionaryEnumerate_block_invoke_2;
        v31[3] = &unk_1899965E8;
        v31[4] = a3;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v31);
      }

      else
      {
        if (((v8 >> 59) & 0xF) != 0)
        {
          CFStringRef v27 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  2 * v8);
          CFIndex v28 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v27,  0LL);
          CFRelease(v27);
          objc_exception_throw(v28);
          CFIndex v30 = v29;
          free(v3);
          _Unwind_Resume(v30);
        }

        if (2 * v8 <= 1) {
          uint64_t v19 = 1LL;
        }
        else {
          uint64_t v19 = 2 * v8;
        }
        unint64_t v20 = MEMORY[0x1895F8858](v19, v18);
        uint64_t v22 = (char *)v31 - v21;
        if (v23 >= 0x101)
        {
          uint64_t v22 = (char *)_CFCreateArrayStorage(v20, 0, &v35);
          int v24 = v22;
        }

        else
        {
          int v24 = 0LL;
        }

        [a1 getObjects:&v22[8 * v8] andKeys:v22 count:v8];
        LOBYTE(v33[0]) = 0;
        unint64_t v25 = v8 - 1;
        do
        {
          __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(a3);
          if (LOBYTE(v33[0])) {
            BOOL v26 = 1;
          }
          else {
            BOOL v26 = v25 == 0;
          }
          --v25;
          v22 += 8;
        }

        while (!v26);
        free(v24);
      }

      _CFAutoreleasePoolPop(v17);
    }
  }

void *visit(uint64_t a1, int a2, uint64_t a3)
{
  id v6 = 0LL;
  unint64_t v7 = 0LL;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unint64_t v8 = *(void *)(a1 + 24);
  unsigned __int8 v19 = 0;
  uint64_t v9 = a1 + 8;
  while (1)
  {
    uint64_t v10 = v9;
    id WeakRetained = objc_loadWeakRetained((id *)v9);
    uint64_t v12 = WeakRetained;
    if (v6) {
      unint64_t v13 = v6;
    }
    else {
      unint64_t v13 = (void *)v9;
    }
    if (WeakRetained) {
      ++v7;
    }
    else {
      id v6 = v13;
    }
    (*(void (**)(uint64_t, uint64_t, id, unsigned __int8 *))(a3 + 16))(a3, v9, WeakRetained, &v19);
    uint64_t v9 = *(void *)(v9 + 8);
    if (v12) {

    }
    int v14 = v19;
    if (v19 || v7 > v8) {
      break;
    }
    if (!v9)
    {
      uint64_t v16 = (void *)(v10 + 8);
      goto LABEL_17;
    }
  }

  uint64_t v16 = (void *)(v10 + 8);
  if (v9) {
    goto LABEL_18;
  }
LABEL_17:
  *(void *)(a1 + 24) = v7;
LABEL_18:
  if (!a2 && !v14 && !v6)
  {
    uint64_t v17 = calloc(1uLL, 0x10uLL);
    if (!v17) {
      visit_cold_1();
    }
    id v6 = v17;
    *uint64_t v16 = v17;
  }

  return v6;
}

void sub_180AB6874( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void sub_180AB69B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180AB6AF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  if (!CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
      || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
      && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
    {
      return (CFArrayRef)__CFArrayCreateCopy0(allocator, (unint64_t *)theArray);
    }

    if (__FoundationPresent_static_init != -1) {
      dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
    }
    if (!__FoundationPresent_present) {
      return (CFArrayRef)__CFArrayCreateCopy0(allocator, (unint64_t *)theArray);
    }
  }

  if (_CFArrayIsMutable((uint64_t)theArray)) {
    return (CFArrayRef)-[NSArray initWithArray:copyItems:]( objc_alloc(&OBJC_CLASS___NSArray),  "initWithArray:copyItems:",  theArray,  0LL);
  }
  return (CFArrayRef)-[__CFArray copyWithZone:](theArray, "copyWithZone:", 0LL);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray)) {
    return (CFMutableArrayRef)-[NSArray initWithArray:copyItems:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithArray:copyItems:",  theArray,  0LL);
  }
  if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return __CFArrayCreateMutableCopy0(allocator, capacity, (unint64_t *)theArray);
  }

  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present) {
    return (CFMutableArrayRef)-[NSArray initWithArray:copyItems:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithArray:copyItems:",  theArray,  0LL);
  }
  else {
    return __CFArrayCreateMutableCopy0(allocator, capacity, (unint64_t *)theArray);
  }
}

CFArrayRef CFArrayCreate( CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return (CFArrayRef)__CFArrayCreate0(allocator, (uint64_t *)values, numValues, callBacks, v4, v5, v6, v7);
  }

  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present) {
    return (CFArrayRef)-[NSArray initWithObjects:count:]( objc_alloc(&OBJC_CLASS___NSArray),  "initWithObjects:count:",  values,  numValues);
  }
  else {
    return (CFArrayRef)__CFArrayCreate0(allocator, (uint64_t *)values, numValues, callBacks, v4, v5, v6, v7);
  }
}

CFMutableArrayRef CFArrayCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  int v9 = capacity;
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return (CFMutableArrayRef)__CFArrayCreateMutable0(allocator, v9, callBacks, v3, v4, v5, v6, v7);
  }

  if (__FoundationPresent_static_init != -1) {
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  }
  if (__FoundationPresent_present) {
    return (CFMutableArrayRef)-[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  0LL);
  }
  else {
    return (CFMutableArrayRef)__CFArrayCreateMutable0(allocator, v9, callBacks, v3, v4, v5, v6, v7);
  }
}

const char *PROEM_CLS()
{
  qos_class_t v0 = (objc_class *)objc_opt_class();
  if (v0) {
    return class_getName(v0);
  }
  else {
    return "(null class)";
  }
}

const char *PROEM_SEL(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

double __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)&double result = 136316162LL;
  *(_DWORD *)a1 = 136316162;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2080;
  *(void *)(a1 + 34) = a5;
  *(_WORD *)(a1 + 42) = 2048;
  *(void *)(a1 + 44) = a6;
  return result;
}

uint64_t OUTLINED_FUNCTION_0_9(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return [a1 exceptionWithName:a3 reason:a4 userInfo:0 osLogPack:v5 size:v4];
}

uint64_t OUTLINED_FUNCTION_1_6()
{
  return _os_log_pack_fill();
}

uint64_t OUTLINED_FUNCTION_2_5()
{
  return _CFAutoreleasePoolAddObject();
}

uint64_t OUTLINED_FUNCTION_3_3(uint64_t a1, const __CFString *a2)
{
  return _CFThrowFormattedException(v2, a2);
}

uint64_t (**(*CFStringEncodingConverterFindBootstrap(int a1))( int a1, uint64_t (*a2)(uint64_t)))()
{
  double result = __CFStringEncodingGetArabicConverterDefinition;
  if (a1 > 1039)
  {
    if (a1 <= 2111)
    {
      switch(a1)
      {
        case 1040:
        case 1046:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 1041:
        case 1043:
        case 1045:
        case 1047:
        case 1048:
        case 1049:
        case 1050:
        case 1052:
        case 1054:
        case 1055:
        case 1057:
          return 0LL;
        case 1042:
          goto LABEL_18;
        case 1044:
          goto LABEL_25;
        case 1051:
          goto LABEL_39;
        case 1053:
          goto LABEL_31;
        case 1056:
          return __CFStringEncodingGetJapaneseConverterDefinition;
        case 1058:
          return __CFStringEncodingGetKoreanConverterDefinition;
        default:
          switch(a1)
          {
            case 1281:
              goto LABEL_18;
            case 1282:
              goto LABEL_39;
            case 1283:
              return __CFStringEncodingGetGreekConverterDefinition;
            case 1284:
              goto LABEL_25;
            case 1285:
              goto LABEL_9;
            case 1286:
              return result;
            case 1287:
              return __CFStringEncodingGetLatinSuppConverterDefinition;
            case 1288:
              double result = __CFStringEncodingGetVietnameseConverterDefinition;
              break;
            default:
              if (a1 == 2080) {
                return __CFStringEncodingGetJapaneseConverterDefinition;
              }
              return 0LL;
          }

          break;
      }

      return result;
    }

    if (a1 > 2367)
    {
      switch(a1)
      {
        case 2561:
          return __CFStringEncodingGetJapaneseConverterDefinition;
        case 2562:
          goto LABEL_39;
        case 2563:
          goto LABEL_33;
        case 2564:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 2565:
          return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
        default:
          if (a1 == 2368) {
            return __CFStringEncodingGetKoreanConverterDefinition;
          }
          return 0LL;
      }
    }

    switch(a1)
    {
      case 2112:
        return __CFStringEncodingGetKoreanConverterDefinition;
      case 2336:
        return __CFStringEncodingGetJapaneseConverterDefinition;
      case 2352:
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
    }

    return 0LL;
  }

  if (a1 <= 151)
  {
    switch(a1)
    {
      case 21:
LABEL_31:
        double result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetThaiConverterDefinition;
        break;
      case 22:
      case 23:
      case 24:
      case 26:
      case 27:
      case 28:
      case 30:
      case 31:
      case 32:
        return 0LL;
      case 25:
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
      case 29:
      case 36:
      case 38:
LABEL_18:
        double result = __CFStringEncodingGetLatin2ConverterDefinition;
        break;
      case 33:
      case 34:
        double result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetSymbolConverterDefinition;
        break;
      case 35:
LABEL_25:
        double result = __CFStringEncodingGetLatin5ConverterDefinition;
        break;
      case 37:
        return __CFStringEncodingGetLatinSuppConverterDefinition;
      default:
        switch(a1)
        {
          case 1:
            return __CFStringEncodingGetJapaneseConverterDefinition;
          case 2:
LABEL_33:
            double result = __CFStringEncodingGetTraditionalChineseConverterDefinition;
            break;
          case 3:
            return __CFStringEncodingGetKoreanConverterDefinition;
          case 6:
            return __CFStringEncodingGetGreekConverterDefinition;
          case 7:
LABEL_39:
            double result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
            break;
          default:
            return 0LL;
        }

        break;
    }
  }

  else
  {
    if (a1 > 1023)
    {
      switch(a1)
      {
        case 1024:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 1029:
          return __CFStringEncodingGetGreekConverterDefinition;
        case 1030:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
      }

      return 0LL;
    }

    switch(a1)
    {
      case 514:
        goto LABEL_18;
      case 515:
      case 516:
      case 524:
        return 0LL;
      case 517:
        goto LABEL_39;
      case 518:
        return result;
      case 519:
        return __CFStringEncodingGetGreekConverterDefinition;
      case 520:
LABEL_9:
        double result = __CFStringEncodingGetHebrewConverterDefinition;
        break;
      case 521:
        goto LABEL_25;
      case 522:
      case 525:
      case 526:
      case 527:
        return __CFStringEncodingGetLatinSuppConverterDefinition;
      case 523:
        goto LABEL_31;
      default:
        if (a1 == 152) {
          goto LABEL_39;
        }
        return 0LL;
    }
  }

  return result;
}

char **_CFArgv()
{
  return *_NSGetArgv();
}

uint64_t _CFArgc()
{
  return *_NSGetArgc();
}

BOOL _CFGetCurrentDirectory(char *a1, int a2)
{
  return getcwd(a1, a2) != 0LL;
}

uint64_t *_CFGetProgname()
{
  if (!__CFprogname) {
    _CFProcessPath();
  }
  return &__CFprogname;
}

const char *_CFProcessPath()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  double result = (const char *)__CFProcessPath;
  if (!__CFProcessPath)
  {
    getpid();
    bufsize[1] = 0;
    bufsize[0] = 1026;
    uint64_t v1 = csops();
    MEMORY[0x1895F8858](v1, v2);
    if (!_NSGetExecutablePath(v6, bufsize))
    {
      uint64_t v3 = strdup(v6);
      __CFProcessPath = (uint64_t)v3;
      uint64_t v4 = strrchr(v3, 47);
      if (v4) {
        uint64_t v5 = (uint64_t)(v4 + 1);
      }
      else {
        uint64_t v5 = (uint64_t)v3;
      }
      __CFprogname = v5;
    }

    double result = (const char *)__CFProcessPath;
    if (!__CFProcessPath)
    {
      double result = "";
      __CFProcessPath = (uint64_t)"";
      __CFprogname = (uint64_t)"";
    }
  }

  return result;
}

uint64_t *_CFGetProcessPath()
{
  if (!__CFProcessPath) {
    _CFProcessPath();
  }
  return &__CFProcessPath;
}

BOOL _CFIsMainThread()
{
  return pthread_main_np() == 1;
}

uint64_t _CFProcessNameString()
{
  if (!_CFProcessNameString___CFProcessNameString)
  {
    uint64_t v0 = __CFprogname;
    if (!__CFprogname)
    {
      _CFProcessPath();
      uint64_t v0 = __CFprogname;
    }

    if (v0) {
      uint64_t v1 = (const char *)v0;
    }
    else {
      uint64_t v1 = "";
    }
    CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x8000100u);
    while (!__ldaxr((unint64_t *)&_CFProcessNameString___CFProcessNameString))
    {
    }

    __clrex();
    CFRelease(v2);
  }

  return _CFProcessNameString___CFProcessNameString;
}

CFStringRef _CFStringCreateHostName()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  if (gethostname(cStr, 0x101uLL)) {
    cStr[0] = 0;
  }
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x8000100u);
}

CFStringRef CFCopyUserName()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  __CFGetUGIDs(&v4, 0LL);
  uid_t v0 = v4;
  if (!v4) {
    uid_t v0 = getuid();
  }
  uint64_t v1 = getpwuid(v0);
  if (!v1 || (pw_name = v1->pw_name) == 0LL)
  {
    pw_name = __CFgetenv("USER");
    if (!pw_name) {
      return (CFStringRef)CFRetain(&stru_1899EF170);
    }
  }

  CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_name, 0x8000100u);
  if (!result) {
    return (CFStringRef)CFRetain(&stru_1899EF170);
  }
  return result;
}

CFStringRef CFCopyFullUserName()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  __CFGetUGIDs(&v4, 0LL);
  uid_t v0 = v4;
  if (!v4) {
    uid_t v0 = getuid();
  }
  uint64_t v1 = getpwuid(v0);
  if (!v1) {
    return (CFStringRef)CFRetain(&stru_1899EF170);
  }
  pw_gecos = v1->pw_gecos;
  if (!pw_gecos) {
    return (CFStringRef)CFRetain(&stru_1899EF170);
  }
  CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_gecos, 0x8000100u);
  if (!result) {
    return (CFStringRef)CFRetain(&stru_1899EF170);
  }
  return result;
}

CFURLRef CFCopyHomeDirectoryURL(void)
{
  return (CFURLRef)_CFCopyHomeDirURLForUser(0LL, 1);
}

const UInt8 *_CFCopyHomeDirURLForUser(const char *a1, int a2)
{
  v30[3] = *MEMORY[0x1895F89C0];
  if (issetugid()) {
    uid_t v4 = 0LL;
  }
  else {
    uid_t v4 = __CFgetenv("CFFIXED_USER_HOME");
  }
  uint64_t v29 = 0LL;
  v30[0] = &v29;
  v30[1] = 0x2000000000LL;
  v30[2] = 0LL;
  v25[0] = MEMORY[0x1895F87A8];
  v25[1] = 0x40000000LL;
  BOOL v26 = ___CFCopyHomeDirURLForUser_block_invoke;
  CFStringRef v27 = &unk_18999B610;
  CFIndex v28 = &v29;
  if (!issetugid() && v4)
  {
    size_t v5 = strlen(v4);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)v4,  v5,  1u);
    if (pw_dir) {
      goto LABEL_35;
    }
    v26((uint64_t)v25);
    int has_internal_diagnostics = os_variant_has_internal_diagnostics();
    uint64_t v8 = *(__CFString **)(v30[0] + 24LL);
    if (has_internal_diagnostics) {
      CFStringAppendFormat( v8,  0LL,  @"CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value: %s",  v4);
    }
    else {
      CFStringAppend( v8,  @"CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value");
    }
  }

  if (a1)
  {
    *__error() = 0;
    int v9 = getpwnam(a1);
    if (!v9) {
      goto LABEL_26;
    }
  }

  else
  {
    __CFGetUGIDs(&v24, 0LL);
    *__error() = 0;
    uid_t v10 = v24;
    if (!v24) {
      uid_t v10 = getuid();
    }
    int v9 = getpwuid(v10);
    if (!v9)
    {
      uint64_t v14 = *__error();
      v26((uint64_t)v25);
      CFStringAppendFormat(*(CFMutableStringRef *)(v30[0] + 24LL), 0LL, @"getpwuid failed with code: %d", v14);
      pw_dir = 0LL;
      goto LABEL_27;
    }
  }

  pw_dir = (const UInt8 *)v9->pw_dir;
  if (pw_dir)
  {
    size_t v11 = strlen(v9->pw_dir);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  pw_dir,  v11,  1u);
  }

  if (!((unint64_t)a1 | (unint64_t)pw_dir))
  {
    v26((uint64_t)v25);
    if (v9->pw_dir)
    {
      int v12 = os_variant_has_internal_diagnostics();
      unint64_t v13 = *(__CFString **)(v30[0] + 24LL);
      if (v12)
      {
        CFStringAppendFormat( v13,  0LL,  @"CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value: %s",  v9->pw_dir);
        pw_dir = 0LL;
        goto LABEL_27;
      }

      uint64_t v15 = @"CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value";
    }

    else
    {
      unint64_t v13 = *(__CFString **)(v30[0] + 24LL);
      uint64_t v15 = @"upwd->pw_dir is NULL";
    }

    CFStringAppend(v13, v15);
LABEL_26:
    pw_dir = 0LL;
  }

void sub_180AB83E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

const UInt8 *CFCopyHomeDirectoryURLForUser(const __CFString *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return _CFCopyHomeDirURLForUser(0LL, 1);
  }
  CFIndex Length = (int)CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v4 = MaximumSizeForEncoding << 32;
  if ((int)MaximumSizeForEncoding > 126) {
    size_t v5 = (UInt8 *)CFAllocatorAllocate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  ((MaximumSizeForEncoding << 32) + 0x100000000LL) >> 32,  0LL);
  }
  else {
    size_t v5 = buffer;
  }
  v13.CFIndex location = 0LL;
  v13.CFIndex length = Length;
  CFIndex Bytes = CFStringGetBytes(a1, v13, 0x8000100u, 0, 1u, v5, v4 >> 32, &usedBufLen);
  uint64_t v8 = 0LL;
  if (Bytes == Length)
  {
    v5[usedBufLen] = 0;
    uint64_t v8 = (const char *)v5;
  }

  int v9 = _CFCopyHomeDirURLForUser(v8, 0);
  if (buffer != v5) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
  }
  return v9;
}

uint64_t _CFMZEnabled()
{
  return 0LL;
}

uint64_t _CFRSCompatible()
{
  return 0LL;
}

void __CFTSDInitialize()
{
  if (__CFTSDInitialize_once != -1) {
    dispatch_once(&__CFTSDInitialize_once, &__block_literal_global_11);
  }
}

void __CFTSDFinalize(unint64_t a1)
{
  if (pthread_main_np() == 1) {
    atomic_store(1u, __CFMainThreadHasExited);
  }
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(void *)(StatusReg + 440) = a1;
  if ((a1 | 0x1000) != 0x1000)
  {
    ++*(_DWORD *)a1;
    uint64_t v3 = (void *)_CFAutoreleasePoolPush();
    for (uint64_t i = 0LL; i != 560; i += 8LL)
    {
      size_t v5 = (_DWORD *)(a1 + i);
      if (*(void *)(a1 + i + 8))
      {
        uint64_t v6 = (void (*)(void))*((void *)v5 + 71);
        if (v6)
        {
          *((void *)v5 + 1) = 0LL;
          v6();
        }
      }
    }

    _CFAutoreleasePoolPop(v3);
    if (*(_DWORD *)a1 == 3)
    {
      free((void *)a1);
      *(void *)(StatusReg + 440) = 4096LL;
    }
  }

uint64_t _CFGetTSDCreateIfNeeded(unsigned int a1, int a2)
{
  if (a1 >= 0x46) {
    _CFGetTSDCreateIfNeeded_cold_1(a1);
  }
  uint64_t v4 = __CFTSDGetTable(a2);
  if (v4) {
    return v4[a1 + 1];
  }
  if (a2) {
    _CFLogSimple(4, "Warning: TSD slot %d retrieved but the thread data has already been torn down.", a1);
  }
  return 0LL;
}

void *__CFTSDGetTable(int a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v2 = *(void **)(StatusReg + 440);
  if (a1 && !v2)
  {
    uint64_t v2 = calloc(1uLL, 0x468uLL);
    pthread_key_init_np();
    *(void *)(StatusReg + 440) = v2;
  }

  return v2;
}

uint64_t _CFGetTSD(unsigned int a1)
{
  return _CFGetTSDCreateIfNeeded(a1, 1);
}

uint64_t _CFSetTSD(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if (a1 >= 0x46) {
    _CFSetTSD_cold_1(a1);
  }
  uint64_t v6 = (char *)__CFTSDGetTable(1);
  if (v6)
  {
    uint64_t v7 = &v6[8 * a1];
    uint64_t result = *((void *)v7 + 1);
    *((void *)v7 + 1) = a2;
    *((void *)v7 + 71) = a3;
  }

  else
  {
    _CFLogSimple(4, "Warning: TSD slot %d set but the thread data has already been torn down.", a1);
    return 0LL;
  }

  return result;
}

uint64_t (*CFStringEncodingGetAddressForSelector(unsigned int a1))()
{
  if (a1 > 4) {
    return 0LL;
  }
  else {
    return off_18999B630[a1];
  }
}

uint64_t CFStringEncodingIsDecomposableCharacter(unsigned int a1)
{
  if (a1 >= 0x80) {
    return CFUniCharIsMemberOf(a1, 0x65u);
  }
  else {
    return 0LL;
  }
}

uint64_t CFStringEncodingDecomposeCharacter(char a1, unsigned __int16 a2, unsigned int *a3)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  unsigned __int16 v5 = a2;
  CFUniCharDecompose(&v5, 1LL, 0LL, a3, 10LL, &v4, 0, 0, a1 < 0);
  return v4;
}

uint64_t (**__CFStringEncodingGetExternalConverter(uint64_t a1))()
{
  if (!WORD1(a1))
  {
    Bootstrap = CFStringEncodingConverterFindBootstrap(a1);
    if (Bootstrap) {
      return Bootstrap(a1, (uint64_t (*)(uint64_t))CFStringEncodingGetAddressForSelector);
    }
  }

  if (__CFStringEncodingGetICUName(a1)) {
    return (uint64_t (**)())&__CFICUBootstrap;
  }
  return 0LL;
}

_DWORD *__CFStringEncodingCreateListOfAvailablePlatformConverters(const __CFAllocator *a1, void *a2)
{
  uint64_t result = CFAllocatorAllocate(a1, 220LL, 0LL);
  for (uint64_t i = 0LL; i != 55; ++i)
    result[i] = __CFStringEncodingDylibConveters[i];
  *a2 = 55LL;
  return result;
}

uint64_t __CFStringEncodingPlatformUnicodeToBytes()
{
  return 3LL;
}

uint64_t __CFStringEncodingPlatformBytesToUnicode()
{
  return 3LL;
}

uint64_t __CFStringEncodingPlatformCharLengthForBytes()
{
  return 0LL;
}

uint64_t __CFStringEncodingPlatformByteLengthForCharacters()
{
  return 0LL;
}

uint64_t __CFCalendarEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

id __CFCalendarCopyDescription(void *a1)
{
  return (id)[a1 debugDescription];
}

CFTypeID CFCalendarGetTypeID(void)
{
  return 49LL;
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)(id)+[NSCalendar _current](&OBJC_CLASS___NSCalendar, "_current");
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)+[NSCalendar _newCalendarWithIdentifier:]( &OBJC_CLASS___NSCalendar,  "_newCalendarWithIdentifier:",  identifier);
}

uint64_t _CFCalendarCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

CFLocaleRef CFCalendarCopyLocale(CFCalendarRef calendar)
{
  return (CFLocaleRef)objc_msgSend((id)-[__CFCalendar locale](calendar, "locale"), "copy");
}

void CFCalendarSetLocale(CFCalendarRef calendar, CFLocaleRef locale)
{
}

CFTimeZoneRef CFCalendarCopyTimeZone(CFCalendarRef calendar)
{
  return (CFTimeZoneRef)objc_msgSend((id)-[__CFCalendar timeZone](calendar, "timeZone"), "copy");
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

void CFCalendarSetFirstWeekday(CFCalendarRef calendar, CFIndex wkdy)
{
}

void CFCalendarSetMinimumDaysInFirstWeek(CFCalendarRef calendar, CFIndex mwd)
{
}

id CFCalendarCopyGregorianStartDate(void *a1)
{
  return (id)[a1 gregorianStartDate];
}

uint64_t CFCalendarSetGregorianStartDate(void *a1, const char *a2)
{
  return [a1 setGregorianStartDate:a2];
}

CFRange CFCalendarGetMinimumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2 = -[__CFCalendar minimumRangeOfUnit:](calendar, "minimumRangeOfUnit:", unit);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v2 = -1LL;
    CFIndex v3 = -1LL;
  }

  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

CFRange CFCalendarGetMaximumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2 = -[__CFCalendar maximumRangeOfUnit:](calendar, "maximumRangeOfUnit:", unit);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v2 = -1LL;
    CFIndex v3 = -1LL;
  }

  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  uint64_t v6 = (void *)[objc_allocWithZone((Class)NSDateComponents) init];
  int v7 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    uint64_t v8 = componentDesc + 1;
    do
    {
      int v9 = va_arg(v14, void);
      if (v7 > 99)
      {
        if (v7 > 114)
        {
          switch(v7)
          {
            case 's':
              [v6 setSecond:v9];
              break;
            case 'w':
              [v6 setWeekOfYear:v9];
              [v6 setWeek:v9];
              break;
            case 'y':
              [v6 setYear:v9];
              break;
          }
        }

        else
        {
          switch(v7)
          {
            case 'd':
              [v6 setDay:v9];
              break;
            case 'l':
              [v6 setLeapMonth:v9 != 0];
              break;
            case 'm':
              [v6 setMinute:v9];
              break;
          }
        }
      }

      else
      {
        switch(v7)
        {
          case 'D':
            [v6 setDayOfYear:v9];
            break;
          case 'E':
            [v6 setWeekday:v9];
            break;
          case 'F':
            [v6 setWeekdayOrdinal:v9];
            break;
          case 'G':
            [v6 setEra:v9];
            break;
          case 'H':
            [v6 setHour:v9];
            break;
          case 'I':
          case 'J':
          case 'K':
          case 'L':
          case 'N':
          case 'O':
          case 'P':
          case 'R':
          case 'S':
          case 'T':
          case 'U':
          case 'V':
          case 'X':
            break;
          case 'M':
            [v6 setMonth:v9];
            break;
          case 'Q':
            [v6 setQuarter:v9];
            break;
          case 'W':
            [v6 setWeekOfMonth:v9];
            break;
          case 'Y':
            [v6 setYearForWeekOfYear:v9];
            break;
          default:
            if (v7 == 35) {
              [v6 setNanosecond:v9];
            }
            break;
        }
      }

      int v10 = *(unsigned __int8 *)v8++;
      int v7 = v10;
    }

    while (v10);
  }

  size_t v11 = (void *)-[__CFCalendar dateFromComponents:](calendar, "dateFromComponents:", v6, v14);

  if (!v11) {
    return 0;
  }
  [v11 timeIntervalSinceReferenceDate];
  *(void *)at = v12;
  return 1;
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  vars8 = va_arg(va, _BYTE *);
  uint64_t v3 = 0LL;
  va_copy(v13, va);
  for (uint64_t i = vars8; *i > 0x6Bu; ++i)
  {
    switch(*i)
    {
      case 'l':
LABEL_7:
        v3 |= 8uLL;
        break;
      case 'm':
        v3 |= 0x40uLL;
        break;
      case 'r':
      case 'y':
LABEL_6:
        v3 |= 4uLL;
        break;
      case 's':
        v3 |= 0x80uLL;
        break;
      case 'w':
LABEL_8:
        v3 |= 0x2100uLL;
        break;
      default:
        continue;
    }

Boolean CFCalendarAddComponents( CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  uint64_t v8 = (void *)[objc_allocWithZone((Class)NSDateComponents) init];
  int v9 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    int v10 = componentDesc + 1;
    do
    {
      int v11 = va_arg(v16, void);
      switch(v9)
      {
        case 'D':
          [v8 setDayOfYear:v11];
          break;
        case 'E':
        case 'c':
          [v8 setWeekday:v11];
          break;
        case 'F':
          [v8 setWeekdayOrdinal:v11];
          break;
        case 'G':
          [v8 setEra:v11];
          break;
        case 'H':
          [v8 setHour:v11];
          break;
        case 'I':
        case 'J':
        case 'K':
        case 'N':
        case 'O':
        case 'P':
        case 'R':
        case 'S':
        case 'T':
        case 'V':
        case 'X':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '_':
        case 'a':
        case 'b':
          break;
        case 'L':
        case 'M':
          [v8 setMonth:v11];
          break;
        case 'Q':
          [v8 setQuarter:v11];
          break;
        case 'U':
LABEL_6:
          objc_msgSend(v8, "setYear:", v11, v16);
          break;
        case 'W':
          [v8 setWeekOfMonth:v11];
          break;
        case 'Y':
          [v8 setYearForWeekOfYear:v11];
          break;
        case '^':
LABEL_8:
          objc_msgSend(v8, "setWeekOfYear:", v11, v16);
          [v8 setWeek:v11];
          break;
        case 'd':
          [v8 setDay:v11];
          break;
        default:
          switch(v9)
          {
            case 'l':
              [v8 setLeapMonth:v11 != 0];
              break;
            case 'm':
              [v8 setMinute:v11];
              break;
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 't':
            case 'u':
            case 'v':
            case 'x':
              goto LABEL_22;
            case 'r':
            case 'y':
              goto LABEL_6;
            case 's':
              [v8 setSecond:v11];
              break;
            case 'w':
              goto LABEL_8;
            default:
              if (v9 == 35) {
                [v8 setNanosecond:v11];
              }
              break;
          }

          break;
      }

Boolean CFCalendarGetComponentDifference( CFCalendarRef calendar, CFAbsoluteTime startingAT, CFAbsoluteTime resultAT, CFOptionFlags options, const char *componentDesc, ...)
{
  uint64_t vars0 = va_arg(va, void);
  uint64_t v5 = vars0;
  vars8 = va_arg(va, _BYTE *);
  uint64_t v6 = 0LL;
  va_copy(v23, va);
  for (uint64_t i = vars8; ; ++i)
  {
    unsigned int v8 = *i;
    if (v8 <= 0x63) {
      break;
    }
    uint64_t v9 = v6 | 0x80;
    uint64_t v10 = v6 | 0x2100;
    uint64_t v11 = v6 | 4;
    if (v8 != 121) {
      uint64_t v11 = v6;
    }
    if (v8 != 119) {
      uint64_t v10 = v11;
    }
    if (v8 != 115) {
      uint64_t v9 = v10;
    }
    uint64_t v12 = v6 | 0x10;
    uint64_t v13 = v6 | 8;
    uint64_t v14 = v6 | 0x40;
    if (v8 != 109) {
      uint64_t v14 = v6;
    }
    if (v8 != 108) {
      uint64_t v13 = v14;
    }
    if (v8 != 100) {
      uint64_t v12 = v13;
    }
    else {
      uint64_t v6 = v9;
    }
LABEL_20:
    ;
  }

  switch(*i)
  {
    case 'D':
      v6 |= 0x10000uLL;
      goto LABEL_20;
    case 'E':
      v6 |= 0x200uLL;
      goto LABEL_20;
    case 'F':
      v6 |= 0x400uLL;
      goto LABEL_20;
    case 'G':
      v6 |= 2uLL;
      goto LABEL_20;
    case 'H':
      v6 |= 0x20uLL;
      goto LABEL_20;
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'X':
      goto LABEL_20;
    case 'M':
      v6 |= 8uLL;
      goto LABEL_20;
    case 'Q':
      v6 |= 0x800uLL;
      goto LABEL_20;
    case 'W':
      v6 |= 0x1000uLL;
      goto LABEL_20;
    case 'Y':
      v6 |= 0x4000uLL;
      goto LABEL_20;
    default:
      if (v8 == 35)
      {
        v6 |= 0x8000uLL;
        goto LABEL_20;
      }

      if (*i) {
        goto LABEL_20;
      }
      uint64_t v15 = -[__CFCalendar components:fromDate:toDate:options:]( calendar,  "components:fromDate:toDate:options:",  v6,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  startingAT),  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  resultAT),  v5);
      if (!v15) {
        return v15;
      }
      int v16 = *vars8;
      if (*vars8)
      {
        uint64_t v17 = (void *)v15;
        size_t v18 = vars8 + 1;
        do
        {
          int v19 = va_arg(v23, _DWORD *);
          if (v16 <= 99)
          {
            switch(v16)
            {
              case 'D':
                int v20 = [v17 dayOfYear];
                goto LABEL_62;
              case 'E':
                int v20 = [v17 weekday];
                goto LABEL_62;
              case 'F':
                int v20 = [v17 weekdayOrdinal];
                goto LABEL_62;
              case 'G':
                int v20 = [v17 era];
                goto LABEL_62;
              case 'H':
                int v20 = [v17 hour];
                goto LABEL_62;
              case 'I':
              case 'J':
              case 'K':
              case 'L':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'U':
              case 'V':
              case 'X':
                goto LABEL_63;
              case 'M':
                int v20 = [v17 month];
                goto LABEL_62;
              case 'Q':
                int v20 = [v17 quarter];
                goto LABEL_62;
              case 'W':
                int v20 = [v17 weekOfMonth];
                goto LABEL_62;
              case 'Y':
                int v20 = [v17 yearForWeekOfYear];
                goto LABEL_62;
              default:
                if (v16 != 35) {
                  goto LABEL_63;
                }
                int v20 = [v17 nanosecond];
                break;
            }

            goto LABEL_62;
          }

          if (v16 > 114)
          {
            switch(v16)
            {
              case 's':
                int v20 = [v17 second];
                goto LABEL_62;
              case 'w':
                _DWORD *v19 = [v17 weekOfYear];
                if ([v17 weekOfYear] == 0x7FFFFFFFFFFFFFFFLL)
                {
                  int v20 = [v17 week];
                  goto LABEL_62;
                }

                break;
              case 'y':
                int v20 = [v17 year];
                goto LABEL_62;
            }
          }

          else
          {
            switch(v16)
            {
              case 'd':
                int v20 = [v17 day];
                goto LABEL_62;
              case 'l':
                int v20 = [v17 isLeapMonth];
                goto LABEL_62;
              case 'm':
                int v20 = [v17 minute];
LABEL_62:
                _DWORD *v19 = v20;
                break;
            }
          }

LABEL_63:
          int v21 = *v18++;
          int v16 = v21;
        }

        while (v21);
      }

      LOBYTE(v15) = 1;
      return v15;
  }

Boolean CFCalendarGetTimeRangeOfUnit( CFCalendarRef calendar, CFCalendarUnit unit, CFAbsoluteTime at, CFAbsoluteTime *startp, CFTimeInterval *tip)
{
  v11[1] = *(id *)MEMORY[0x1895F89C0];
  uint64_t v10 = 0LL;
  v11[0] = 0LL;
  int v7 = -[__CFCalendar rangeOfUnit:startDate:interval:forDate:]( calendar,  "rangeOfUnit:startDate:interval:forDate:",  unit,  v11,  &v10,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  if (v7)
  {
    if (startp)
    {
      [v11[0] timeIntervalSinceReferenceDate];
      *(void *)startp = v8;
    }

    if (tip) {
      *(void *)tip = v10;
    }
    LOBYTE(v7) = 1;
  }

  return v7;
}

id CFCalendarCreateDateFromComponents(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = -[NSDateComponents _initWithCFDateComponents:]( objc_alloc(&OBJC_CLASS___NSDateComponents),  "_initWithCFDateComponents:",  a3);
  id v5 = (id)[a2 dateFromComponents:v4];

  return v5;
}

uint64_t CFCalendarGetComponentFromDate(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = [a1 component:a2 fromDate:a3];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

CFTypeRef CFCalendarCreateDateComponentsFromDate(uint64_t a1, void *a2)
{
  return CFRetain((CFTypeRef)objc_msgSend((id)objc_msgSend(a2, "components:fromDate:"), "_dateComponents"));
}

CFRange CFCalendarGetRangeOfUnit( CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex v4 = -[__CFCalendar rangeOfUnit:inUnit:forDate:]( calendar,  "rangeOfUnit:inUnit:forDate:",  smallerUnit,  biggerUnit,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  if (v4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    CFIndex v4 = -1LL;
    CFIndex v5 = -1LL;
  }

  result.CFIndex length = v5;
  result.CFIndex location = v4;
  return result;
}

CFIndex CFCalendarGetOrdinalityOfUnit( CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex result = -[__CFCalendar ordinalityOfUnit:inUnit:forDate:]( calendar,  "ordinalityOfUnit:inUnit:forDate:",  smallerUnit,  biggerUnit,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

void _CFLocaleSetPreferredMeasurementSystem(const __CFString *cf1)
{
  uint64_t v1 = cf1;
  if (cf1)
  {
    if (CFEqual(cf1, @"Metric"))
    {
      CFIndex v2 = &kCFBooleanTrue;
      uint64_t v1 = @"Centimeters";
    }

    else
    {
      if (CFEqual(v1, @"U.S."))
      {
        CFIndex v2 = &kCFBooleanFalse;
      }

      else
      {
        if (!CFEqual(v1, @"U.K.")) {
          return;
        }
        CFIndex v2 = &kCFBooleanTrue;
      }

      uint64_t v1 = @"Inches";
    }

    CFBooleanRef v3 = *v2;
  }

  else
  {
    CFBooleanRef v3 = 0LL;
  }

  CFPreferencesSetValue( @"AppleMetricUnits",  v3,  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  CFPreferencesSetValue( @"AppleMeasurementUnits",  v1,  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  CFPreferencesSynchronize( @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  __CFLocaleResetCurrent(1);
  _CFLocalePostChangeNotification(@"AppleMeasurementSystemPreferencesChangedNotification");
}

void _CFLocalePostChangeNotification(const __CFString *a1)
{
  CFNotificationCenterRef DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, a1, 0LL, 0LL, 1u);
}

CFTypeRef _CFLocaleCopyPreferredMeasurementSystem()
{
  uid_t v0 = (__objc2_class **)CFPreferencesCopyValue( @"AppleMetricUnits",  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  unint64_t v1 = (unint64_t)CFPreferencesCopyValue( @"AppleMeasurementUnits",  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  CFIndex v2 = (const void *)v1;
  if (v1) {
    BOOL v3 = &__kCFBooleanTrue == v0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3 && CFEqual((CFTypeRef)v1, @"Inches"))
  {
    if ((dyld_program_sdk_at_least() & 1) != 0)
    {
      CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUK;
      goto LABEL_19;
    }

    goto LABEL_17;
  }

  if (v0) {
    BOOL v6 = &__kCFBooleanFalse == v0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUS;
LABEL_19:
    CFTypeRef v5 = CFRetain(*v4);
    if (!v0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (v2 && CFEqual(v2, @"Centimeters"))
  {
LABEL_17:
    CFIndex v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemMetric;
    goto LABEL_19;
  }

  CFTypeRef v5 = 0LL;
  if (v0) {
LABEL_20:
  }
    CFRelease(v0);
LABEL_21:
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

void _CFLocaleSetPreferredTemperatureUnit(CFPropertyListRef value)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  if (!value || _CFLocaleGetTemperatureUnitForPreferences((uint64_t)value, &v2))
  {
    CFPreferencesSetValue( @"AppleTemperatureUnit",  value,  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
    CFPreferencesSynchronize( @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
    __CFLocaleResetCurrent(1);
    _CFLocalePostChangeNotification(@"AppleTemperatureUnitPreferencesChangedNotification");
  }

uint64_t _CFLocaleGetTemperatureUnitForPreferences(uint64_t result, char *a2)
{
  if (result)
  {
    uint64_t v3 = (const void *)result;
    if (CFEqual((CFTypeRef)result, @"Celsius"))
    {
      char v4 = 1;
    }

    else
    {
      CFIndex result = CFEqual(v3, @"Fahrenheit");
      char v4 = 0;
      if (!(_DWORD)result) {
        return result;
      }
    }

    *a2 = v4;
    return 1LL;
  }

  return result;
}

CFTypeRef _CFLocaleCopyPreferredTemperatureUnit()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  CFPropertyListRef v0 = CFPreferencesCopyValue( @"AppleTemperatureUnit",  @"kCFPreferencesAnyApplication",  @"kCFPreferencesCurrentUser",  @"kCFPreferencesAnyHost");
  if (!_CFLocaleGetTemperatureUnitForPreferences((uint64_t)v0, &v4))
  {
    CFTypeRef v2 = 0LL;
    if (!v0) {
      return v2;
    }
LABEL_7:
    CFRelease(v0);
    return v2;
  }

  unint64_t v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitCelsius;
  if (!v4) {
    unint64_t v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitFahrenheit;
  }
  CFTypeRef v2 = CFRetain(*v1);
  if (v0) {
    goto LABEL_7;
  }
  return v2;
}

BOOL _CFLocaleGetCalendarDirection()
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  Boolean keyExistsAndHasValidFormat = 0;
  AppBooleanint Value = CFPreferencesGetAppBooleanValue( @"NSLocaleCalendarDirectionIsRightToLeft",  @"kCFPreferencesAnyApplication",  &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    return AppBooleanValue != 0;
  }
  MainBundle = CFBundleGetMainBundle();
  uint64_t v3 = CFBundleCopyBundleLocalizations(MainBundle);
  if (!v3) {
    return 0LL;
  }
  char v4 = v3;
  uint64_t v5 = CFBundleCopyPreferredLocalizationsFromArray(v3);
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0LL);
  ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0LL, ValueAtIndex);
  int Value = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, @"kCFLocaleLanguageCodeKey");
  if (Value) {
    BOOL v1 = CFLocaleGetLanguageCharacterDirection(Value) == kCFLocaleLanguageDirectionRightToLeft;
  }
  else {
    BOOL v1 = 0LL;
  }
  CFRelease(ComponentsFromLocaleIdentifier);
  CFRelease(v5);
  CFRelease(v4);
  return v1;
}

void *__cdecl CFPlugInInstanceCreate(CFAllocatorRef allocator, CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  os_unfair_recursive_lock_lock_with_options();
  if (!_factoriesByFactoryID
    || (int Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) == 0LL
    || (uint64_t v7 = (uint64_t)Value, !*((_BYTE *)Value + 24)))
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInInstanceCreate_cold_1();
    }
    goto LABEL_27;
  }

  uint64_t v8 = (const __CFArray *)*((void *)Value + 7);
  v34.CFIndex length = CFArrayGetCount(v8);
  v34.CFIndex location = 0LL;
  if ((CFArrayGetFirstIndexOfValue(v8, v34, typeUUID) & 0x80000000) != 0)
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInInstanceCreate_cold_4();
    }
    goto LABEL_27;
  }

  if (!*(_BYTE *)(v7 + 24))
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    uint64_t v17 = (os_log_s *)_CFBundlePluginLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInInstanceCreate_cold_2(v7, v17, v18, v19, v20, v21, v22, v23);
    }
    goto LABEL_27;
  }

  FunctionPointerForName = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
  if (!FunctionPointerForName)
  {
    FunctionPointerForName = (uint64_t (*)(uint64_t, uint64_t))CFBundleGetFunctionPointerForName( *(CFBundleRef *)(v7 + 40),  *(CFStringRef *)(v7 + 48));
    *(void *)(v7 + 32) = FunctionPointerForName;
    if (!FunctionPointerForName)
    {
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      uint64_t v10 = (os_log_s *)_CFBundlePluginLogger__log;
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(v7 + 16);
        uint64_t v26 = *(void *)(v7 + 40);
        uint64_t v25 = *(void *)(v7 + 48);
        int v27 = 138543874;
        uint64_t v28 = v25;
        __int16 v29 = 2114;
        uint64_t v30 = v24;
        __int16 v31 = 2114;
        uint64_t v32 = v26;
        _os_log_error_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_ERROR,  "Cannot find function pointer %{public}@ for factory %{public}@ in %{public}@",  (uint8_t *)&v27,  0x20u);
      }

      FunctionPointerForName = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
      if (!FunctionPointerForName)
      {
LABEL_27:
        uint64_t v13 = 0LL;
        goto LABEL_28;
      }
    }
  }

  uint64_t v11 = *(void *)(v7 + 40);
  if (v11 && *(_BYTE *)__CFBundleGetPlugInData(*(void *)(v7 + 40)))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData(v11);
    ++*(_DWORD *)(PlugInData + 12);
  }

  os_unfair_recursive_lock_unlock();
  uint64_t v13 = (void *)__CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__( FunctionPointerForName,  (uint64_t)allocator,  (uint64_t)typeUUID);
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    CFPlugInInstanceCreate_cold_3();
  }
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v14 = *(void *)(v7 + 40);
  if (v14 && *(_BYTE *)__CFBundleGetPlugInData(*(void *)(v7 + 40)))
  {
    uint64_t v15 = __CFBundleGetPlugInData(v14);
    --*(_DWORD *)(v15 + 12);
  }

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

Boolean CFPlugInRegisterFactoryFunction(CFUUIDRef factoryUUID, CFPlugInFactoryFunction func)
{
  Locked = (void *)_CFPFactoryCommonCreateLocked( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  factoryUUID,  v4,  v5,  v6,  v7,  v8,  v9);
  Locked[5] = 0LL;
  Locked[6] = 0LL;
  Locked[4] = func;
  os_unfair_recursive_lock_unlock();
  return 1;
}

uint64_t _CFPFactoryCommonCreateLocked( const __CFAllocator *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x20uLL, 48LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFRetain(a2);
    *(_BYTE *)(Instance + 24) = 1;
    *(void *)(Instance + 56) = CFArrayCreateMutable(a1, 0LL, &kCFTypeArrayCallBacks);
    uint64_t v11 = *(const void **)(Instance + 16);
    uint64_t v12 = (__CFDictionary *)_factoriesByFactoryID;
    if (!_factoriesByFactoryID)
    {
      memset(&v14, 0, sizeof(v14));
      uint64_t v12 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &v14);
      _factoriesByFactoryID = (uint64_t)v12;
    }

    CFDictionarySetValue(v12, v11, (const void *)Instance);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFPFactoryCommonCreateLocked_cold_1();
    }
  }

  return Instance;
}

Boolean CFPlugInRegisterFactoryFunctionByName( CFUUIDRef factoryUUID, CFPlugInRef plugIn, CFStringRef functionName)
{
  return 1;
}

CFStringRef _CFPlugInRegisterFactoryFunctionByNameLocked( const void *a1, const void *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Locked = (void *)_CFPFactoryCommonCreateLocked( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a1,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8);
  Locked[4] = 0LL;
  Locked[5] = CFRetain(a2);
  if (a2 && *(_BYTE *)__CFBundleGetPlugInData((uint64_t)a2))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)a2);
    CFArrayAppendValue(*(CFMutableArrayRef *)(PlugInData + 16), Locked);
  }

  if (a3) {
    CFStringRef result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
  }
  else {
    CFStringRef result = 0LL;
  }
  Locked[6] = result;
  return result;
}

Boolean CFPlugInUnregisterFactory(CFUUIDRef factoryUUID)
{
  if (_factoriesByFactoryID
    && (int Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0LL
    && Value[24])
  {
    _CFPFactoryDisableLocked(Value);
  }

  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInUnregisterFactory_cold_1();
    }
  }

  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryDisableLocked(_BYTE *a1)
{
  a1[24] = 0;
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  CFTypeRef v2 = (os_log_s *)_CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryDisableLocked_cold_1((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
  }
  CFRelease(a1);
}

Boolean CFPlugInRegisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  return 1;
}

void _CFPlugInRegisterPlugInTypeLocked(void *key, const void *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (_factoriesByFactoryID
    && (uint64_t v3 = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, key)) != 0LL
    && (uint64_t v4 = v3, *((_BYTE *)v3 + 24)))
  {
    CFArrayAppendValue(v3[7], a2);
    CFMutableStringRef Mutable = (const __CFDictionary *)_factoriesByTypeID;
    if (!_factoriesByTypeID)
    {
      CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      _factoriesByCFTypeID TypeID = (uint64_t)Mutable;
    }

    int Value = (void *)CFDictionaryGetValue(Mutable, a2);
    if (!Value)
    {
      memset(&v7, 0, sizeof(v7));
      int Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &v7);
      CFDictionarySetValue((CFMutableDictionaryRef)_factoriesByTypeID, a2, Value);
      CFRelease(Value);
    }

    CFArrayAppendValue((CFMutableArrayRef)Value, v4);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFPlugInRegisterPlugInTypeLocked_cold_2();
    }
  }

  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFPlugInRegisterPlugInTypeLocked_cold_1();
    }
  }

Boolean CFPlugInUnregisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  if (_factoriesByFactoryID
    && (int Value = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0LL
    && *((_BYTE *)Value + 24))
  {
    _CFPFactoryRemoveTypeLocked(Value, typeUUID);
  }

  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInUnregisterPlugInType_cold_1();
    }
  }

  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryRemoveTypeLocked(CFMutableArrayRef *a1, const void *a2)
{
  uint64_t v4 = a1[7];
  v9.CFIndex length = CFArrayGetCount(v4);
  v9.CFIndex location = 0LL;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v9, a2);
  if ((FirstIndexOfValue & 0x80000000) == 0) {
    CFArrayRemoveValueAtIndex(a1[7], FirstIndexOfValue);
  }
  if (_factoriesByTypeID)
  {
    int Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, a2);
    if (Value)
    {
      CFArrayCallBacks v7 = Value;
      v10.CFIndex length = CFArrayGetCount(Value);
      v10.CFIndex location = 0LL;
      unsigned int v8 = CFArrayGetFirstIndexOfValue(v7, v10, a1);
      if ((v8 & 0x80000000) == 0)
      {
        CFArrayRemoveValueAtIndex(v7, v8);
        if (!CFArrayGetCount(v7)) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByTypeID, a2);
        }
      }
    }
  }

  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryRemoveTypeLocked_cold_1();
  }
}

void CFPlugInAddInstanceForFactory(CFUUIDRef factoryID)
{
  if (_factoriesByFactoryID
    && (int Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0LL
    && Value[24])
  {
    _CFPFactoryAddInstanceLocked(Value);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInAddInstanceForFactory_cold_2();
    }
  }

  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInAddInstanceForFactory_cold_1();
    }
  }

  os_unfair_recursive_lock_unlock();
}

void *_CFPFactoryAddInstanceLocked(void *result)
{
  BOOL v1 = (const void *)result[5];
  if (v1)
  {
    CFStringRef result = (void *)__CFBundleGetPlugInData(result[5]);
    if (*(_BYTE *)result)
    {
      if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8))
      {
      }

      PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)v1);
      ++*(_DWORD *)(PlugInData + 8);
      return CFRetain(v1);
    }
  }

  return result;
}

void CFPlugInRemoveInstanceForFactory(CFUUIDRef factoryID)
{
  if (_factoriesByFactoryID
    && (int Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0LL
    && Value[24])
  {
    _CFPFactoryRemoveInstanceLocked((uint64_t)Value);
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      CFPlugInRemoveInstanceForFactory_cold_2();
    }
  }

  else
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR)) {
      CFPlugInRemoveInstanceForFactory_cold_1();
    }
  }

  os_unfair_recursive_lock_unlock();
}

void _CFPFactoryRemoveInstanceLocked(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  BOOL v1 = *(const void **)(a1 + 40);
  if (v1 && *(_BYTE *)__CFBundleGetPlugInData(*(void *)(a1 + 40)))
  {
    PlugInCFDataRef Data = __CFBundleGetPlugInData((uint64_t)v1);
    --*(_DWORD *)(PlugInData + 8);
    if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8) && *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)v1) + 1))
    {
      os_unfair_recursive_lock_lock_with_options();
      uint64_t v3 = (__CFSet *)_plugInsToUnload;
      if (!_plugInsToUnload)
      {
        memset(&v4, 0, 24);
        v4.copyDescription = kCFTypeSetCallBacks.copyDescription;
        *(_OWORD *)&v4.equal = *(_OWORD *)&kCFTypeSetCallBacks.equal;
        uint64_t v3 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &v4);
        _plugInsToUnload = (uint64_t)v3;
      }

      CFSetAddValue(v3, v1);
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFPFactoryRemoveInstanceLocked_cold_1();
      }
      os_unfair_recursive_lock_unlock();
    }

    CFRelease(v1);
  }

uint64_t _CFPlugInUnscheduleForUnloading(const void *a1)
{
  if (_plugInsToUnload) {
    CFSetRemoveValue((CFMutableSetRef)_plugInsToUnload, a1);
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPlugInUnscheduleForUnloading_cold_1();
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _CFPlugInUnloadScheduledPlugIns()
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  os_unfair_recursive_lock_lock_with_options();
  if (_plugInsToUnload)
  {
    CFIndex Count = CFSetGetCount((CFSetRef)_plugInsToUnload);
    if (Count >= 1)
    {
      CFIndex v1 = Count;
      CFTypeRef v2 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
      CFSetGetValues((CFSetRef)_plugInsToUnload, v2);
      for (uint64_t i = 0LL; i != v1; ++i)
      {
        uint64_t v4 = (uint64_t)v2[i];
        if (!*(_DWORD *)(__CFBundleGetPlugInData(v4) + 12))
        {
          if (_CFBundlePluginLogger_onceToken != -1) {
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          }
          uint64_t v5 = (os_log_s *)_CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543362;
            uint64_t v8 = v4;
            _os_log_debug_impl( &dword_180A4C000,  v5,  OS_LOG_TYPE_DEBUG,  "PlugIn %{public}@ is about to be unloaded",  buf,  0xCu);
          }

          _CFBundleUnloadExecutable(v4, 1LL);
        }
      }

      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
    }
  }

  return os_unfair_recursive_lock_unlock();
}

uint64_t _CFBundleInitPlugIn(void *a1, CFDictionaryRef theDict, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  memset(&callBacks, 0, sizeof(callBacks));
  if (!theDict) {
    return 1LL;
  }
  int Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CFPlugInFactories");
  CFArrayCallBacks v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFDictionaryGetTypeID()) {
      CFArrayCallBacks v7 = 0LL;
    }
  }

  uint64_t v9 = (const __CFString *)CFDictionaryGetValue(theDict, @"CFPlugInDynamicRegistration");
  CFRange v10 = v9;
  if (v9)
  {
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 != CFStringGetTypeID())
    {
      LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = 0;
      if (v7) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }

    LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = CFStringCompare(v10, @"YES", 1uLL) == kCFCompareEqualTo;
  }

  if (v7) {
    goto LABEL_12;
  }
LABEL_11:
  if (!(_DWORD)v10) {
    return 1LL;
  }
LABEL_12:
  char context = 0;
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForDummyUUID, &context);
    if (context)
    {
      if (_CFBundlePluginLogger_onceToken != -1) {
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      }
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFBundleInitPlugIn_cold_1();
      }
      return 1LL;
    }
  }

  os_unfair_recursive_lock_lock_with_options();
  if (!dyld_program_sdk_at_least()
    || (uint64_t v18 = 0LL, !v7)
    || (CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForExistingFactoryLocked, &v18), !v18))
  {
    *(_BYTE *)__CFBundleGetPlugInData((uint64_t)a1) = 1;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 1) = 1;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 2) = 0;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 3) = (_BYTE)v10;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + _Block_object_dispose(va, 8) = 0;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 12) = 0;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 4) = 1;
    uint64_t v13 = CFGetAllocator(a1);
    CFMutableArrayRef v14 = CFArrayCreateMutable(v13, 0LL, &callBacks);
    *(void *)(__CFBundleGetPlugInData((uint64_t)a1) + 16) = v14;
    if (v7) {
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_registerFactoryLocked, a1);
    }
    uint64_t v15 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CFPlugInTypes");
    if (v15)
    {
      int v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFDictionaryGetTypeID()) {
        CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)_registerTypeLocked, a1);
      }
    }

CFStringRef _searchForDummyUUID(const __CFString *result, const __CFString *a2, _BYTE *a3)
{
  if (!*a3)
  {
    uint64_t v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    CFStringRef result = (const __CFString *)CFStringGetTypeID();
    if ((const __CFString *)v6 == result)
    {
      CFStringRef result = (const __CFString *)CFStringCompare(v5, @"00000000-0000-0000-0000-000000000000", 0LL);
      if (a2)
      {
        if (!result)
        {
          CFTypeID v7 = CFGetTypeID(a2);
          CFStringRef result = (const __CFString *)CFStringGetTypeID();
          if ((const __CFString *)v7 == result)
          {
            CFStringRef result = (const __CFString *)CFStringCompare(a2, @"MyFactoryFunction", 0LL);
            if (!result) {
              *a3 = 1;
            }
          }
        }
      }
    }
  }

  return result;
}

void _searchForExistingFactoryLocked(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  if (!*a3)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 != CFStringGetTypeID()
      || (CFTypeID v6 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0LL)
    {
      CFTypeID v6 = CFRetain(a1);
    }

    if (_factoriesByFactoryID)
    {
      int Value = (CFTypeRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, v6);
      if (Value) {
        *a3 = CFRetain(Value[5]);
      }
    }

    if (v6) {
      CFRelease(v6);
    }
  }

void _registerFactoryLocked(const __CFString *a1, const __CFString *a2, const void *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()
    || (CFTypeID v7 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0LL)
  {
    CFTypeID v7 = CFRetain(a1);
  }

  CFTypeID v8 = CFGetTypeID(a2);
  if (v8 != CFStringGetTypeID() || CFStringGetLength(a2) <= 0) {
    a2 = 0LL;
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  uint64_t v9 = (os_log_s *)_CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = @"<no func>";
    int v16 = 138543874;
    if (a2) {
      uint64_t v15 = a2;
    }
    CFTypeID v17 = v7;
    __int16 v18 = 2114;
    uint64_t v19 = v15;
    __int16 v20 = 2050;
    uint64_t v21 = a3;
    _os_log_debug_impl( &dword_180A4C000,  v9,  OS_LOG_TYPE_DEBUG,  "Registering static factory %{public}@ %{public}@ bundle %{public}p",  (uint8_t *)&v16,  0x20u);
  }

  _CFPlugInRegisterFactoryFunctionByNameLocked(v7, a3, a2, v10, v11, v12, v13, v14);
  if (v7) {
    CFRelease(v7);
  }
}

void _registerTypeLocked(const __CFString *a1, const __CFString *cf, const void *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID()) {
    int Count = CFArrayGetCount((CFArrayRef)cf);
  }
  else {
    int Count = 0;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == CFStringGetTypeID()
    && (uint64_t v9 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) != 0LL)
  {
    if (Count) {
      goto LABEL_7;
    }
  }

  else
  {
    uint64_t v9 = CFRetain(a1);
    if (Count)
    {
LABEL_7:
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i != Count; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFStringGetTypeID()
            || (uint64_t v13 = CFGetAllocator(a3), (v14 = CFUUIDCreateFromString(v13, ValueAtIndex)) == 0LL))
          {
            uint64_t v14 = (void *)CFRetain(ValueAtIndex);
          }

          if (_CFBundlePluginLogger_onceToken != -1) {
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          }
          uint64_t v15 = (os_log_s *)_CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543618;
            uint64_t v21 = v14;
            __int16 v22 = 2114;
            uint64_t v23 = v9;
            _os_log_debug_impl( &dword_180A4C000,  v15,  OS_LOG_TYPE_DEBUG,  "Registering factory %{public}@ type %{public}@",  buf,  0x16u);
          }

          _CFPlugInRegisterPlugInTypeLocked(v14, v9);
          if (v14) {
            CFRelease(v14);
          }
        }
      }

      goto LABEL_31;
    }
  }

  CFTypeID v16 = CFGetTypeID(cf);
  if (v16 != CFArrayGetTypeID())
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 != CFStringGetTypeID() || (__int16 v18 = CFGetAllocator(a3), (v19 = CFUUIDCreateFromString(v18, cf)) == 0LL)) {
      uint64_t v19 = (void *)CFRetain(cf);
    }
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _registerTypeLocked_cold_1();
    }
    _CFPlugInRegisterPlugInTypeLocked(v19, v9);
    if (v19) {
      CFRelease(v19);
    }
  }

uint64_t _CFPlugInHandleDynamicRegistration(__CFBundle *a1)
{
  uint64_t result = __CFBundleGetPlugInData((uint64_t)a1);
  if (*(_BYTE *)result)
  {
    uint64_t v3 = result;
    uint64_t result = CFBundleIsExecutableLoaded(a1);
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(v3 + 3))
      {
        os_unfair_recursive_lock_lock_with_options();
        if (!*(_BYTE *)(v3 + 2))
        {
          *(_BYTE *)(v3 + 3) = 0;
          InfoDictionary = CFBundleGetInfoDictionary(a1);
          int Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFPlugInDynamicRegisterFunction");
          if (!Value || (CFTypeID v6 = Value, v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID()) || CFStringGetLength(v6) <= 0) {
            CFTypeID v6 = @"CFPlugInDynamicRegister";
          }
          *(_WORD *)(v3 + 1) = 256;
          FunctionPointerForName = (uint64_t (*)(uint64_t))CFBundleGetFunctionPointerForName(a1, v6);
          *(_BYTE *)(v3 + 2) = 0;
          if (*(_BYTE *)(v3 + 1))
          {
            if (!*(_DWORD *)(v3 + 8)) {
              CFBundleUnloadExecutable(a1);
            }
          }
        }

        return os_unfair_recursive_lock_unlock();
      }
    }
  }

  return result;
}

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_DYNAMIC_REGISTRATION_FUNCTION__( uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t _CFBundleDeallocatePlugIn(uint64_t a1)
{
  PlugInCFDataRef Data = __CFBundleGetPlugInData(a1);
  os_unfair_recursive_lock_lock_with_options();
  if (*(_BYTE *)PlugInData)
  {
    if (_CFBundlePluginLogger_onceToken != -1) {
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    }
    uint64_t v3 = (os_log_s *)_CFBundlePluginLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDeallocatePlugIn_cold_1(a1, v3);
    }
    int Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      unint64_t v5 = Count + 1LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(PlugInData + 16), (v5 - 2));
        _CFPFactoryDisableLocked(ValueAtIndex);
        --v5;
      }

      while (v5 > 1);
    }

    CFRelease(*(CFTypeRef *)(PlugInData + 16));
    *(_BYTE *)PlugInCFDataRef Data = 0;
  }

  return os_unfair_recursive_lock_unlock();
}

CFPlugInRef CFPlugInCreate(CFAllocatorRef allocator, CFURLRef plugInURL)
{
  CFTypeRef v2 = CFBundleCreate(allocator, plugInURL);
  if (!atomic_load(CFPlugInCreate_checkedLinkage))
  {
    int32_t v4 = NSVersionOfLinkTimeLibrary("System");
    int32_t v5 = NSVersionOfLinkTimeLibrary("CoreFoundation");
    if (v4 == -1 && v5 == -1 || v5 != -1 && v5 < 24576000 || v4 != -1 && v4 < 5832704) {
      atomic_store(1u, CFPlugInCreate_doDynamicRegistrationAtCreateTime);
    }
    atomic_store(1u, CFPlugInCreate_checkedLinkage);
  }

  if (v2)
  {
    if (atomic_load(CFPlugInCreate_doDynamicRegistrationAtCreateTime))
    {
      if (*(_BYTE *)__CFBundleGetPlugInData((uint64_t)v2)
        && *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)v2) + 3)
        && !CFBundleIsExecutableLoaded(v2))
      {
        CFBundleLoadExecutable(v2);
      }
    }
  }

  return v2;
}

void CFPlugInSetLoadOnDemand(CFPlugInRef plugIn, Boolean flag)
{
  int v2 = flag;
  PlugInCFDataRef Data = (_BYTE *)__CFBundleGetPlugInData((uint64_t)plugIn);
  if (*PlugInData)
  {
    int32_t v5 = PlugInData;
    os_unfair_recursive_lock_lock_with_options();
    v5[1] = v2;
    if (v2)
    {
      if (v5[2] || *((_DWORD *)v5 + 2))
      {
        os_unfair_recursive_lock_unlock();
      }

      else
      {
        os_unfair_recursive_lock_unlock();
        CFBundleUnloadExecutable(plugIn);
      }
    }

    else
    {
      os_unfair_recursive_lock_unlock();
      CFBundleLoadExecutable(plugIn);
    }
  }

Boolean CFPlugInIsLoadOnDemand(CFPlugInRef plugIn)
{
  else {
    return 0;
  }
}

_BYTE *_CFPlugInWillUnload(uint64_t a1)
{
  uint64_t result = (_BYTE *)__CFBundleGetPlugInData(a1);
  if (*result)
  {
    os_unfair_recursive_lock_lock_with_options();
    PlugInCFDataRef Data = __CFBundleGetPlugInData(a1);
    int Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      unint64_t v5 = Count + 1LL;
      do
      {
        uint64_t v6 = __CFBundleGetPlugInData(a1);
        *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 16), (v5-- - 2)) + 4) = 0LL;
      }

      while (v5 > 1);
    }

    return (_BYTE *)os_unfair_recursive_lock_unlock();
  }

  return result;
}

void _CFPFactoryDeallocate(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    BOOL v2 = _factoriesByTypeID == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2) {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByFactoryID, *(const void **)(a1 + 16));
  }
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    _CFPFactoryDeallocate_cold_1();
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (*(_BYTE *)__CFBundleGetPlugInData(*(void *)(a1 + 40)))
    {
      int32_t v4 = *(const __CFArray **)(__CFBundleGetPlugInData(v3) + 16);
      PlugInCFDataRef Data = __CFBundleGetPlugInData(v3);
      v13.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
      v13.CFIndex location = 0LL;
      FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v13, (const void *)a1);
      if ((FirstIndexOfValue & 0x80000000) == 0)
      {
        uint64_t v7 = __CFBundleGetPlugInData(v3);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v7 + 16), FirstIndexOfValue);
      }
    }

    CFRelease(*(CFTypeRef *)(a1 + 40));
  }

  int Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count >= 1)
  {
    unint64_t v9 = Count + 1LL;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (v9 - 2));
      _CFPFactoryRemoveTypeLocked((CFMutableArrayRef *)a1, ValueAtIndex);
      --v9;
    }

    while (v9 > 1);
  }

  CFRelease(*(CFTypeRef *)(a1 + 56));
  os_unfair_recursive_lock_unlock();
  uint64_t v11 = *(const void **)(a1 + 48);
  if (v11) {
    CFRelease(v11);
  }
  CFTypeID v12 = *(const void **)(a1 + 16);
  if (v12) {
    CFRelease(v12);
  }
}

CFArrayRef CFPlugInFindFactoriesForPlugInType(CFUUIDRef typeUUID)
{
  if (_factoriesByTypeID
    && (int Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0LL)
  {
    uint64_t v3 = Value;
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0LL; i != v6; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        unint64_t v9 = (const void *)*((void *)ValueAtIndex + 2);
        if (v9)
        {
          CFRetain(*((CFTypeRef *)ValueAtIndex + 2));
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v9);
        }
      }
    }
  }

  else
  {
    CFMutableStringRef Mutable = 0LL;
  }

  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  uint64_t v10 = (os_log_s *)_CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG)) {
    CFPlugInFindFactoriesForPlugInType_cold_1(Mutable, (uint64_t)typeUUID, v10);
  }
  return Mutable;
}

CFArrayRef CFPlugInFindFactoriesForPlugInTypeInPlugIn(CFUUIDRef typeUUID, CFPlugInRef plugIn)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByTypeID
    && (int Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0LL)
  {
    unint64_t v5 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    if (Count >= 1)
    {
      CFIndex v8 = 0LL;
      while (1)
      {
        ValueAtIndex = (__CFBundle **)CFArrayGetValueAtIndex(v5, v8);
        uint64_t v10 = ValueAtIndex;
        uint64_t v11 = ValueAtIndex[5];
        if (v11) {
          CFRetain(ValueAtIndex[5]);
        }
        if (v11 == plugIn) {
          break;
        }
        if (v11) {
          goto LABEL_9;
        }
LABEL_10:
        if (Count == ++v8) {
          goto LABEL_17;
        }
      }

      CFTypeID v12 = v10[2];
      if (v12) {
        CFRetain(v12);
      }
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      if (!v11) {
        goto LABEL_10;
      }
LABEL_9:
      CFRelease(v11);
      goto LABEL_10;
    }
  }

  else
  {
    CFMutableStringRef Mutable = 0LL;
  }

uint64_t __CFPlugInInstanceDeallocate(uint64_t a1)
{
  BOOL v2 = *(void (**)(uint64_t))(a1 + 32);
  if (v2) {
    v2(a1 + 40);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    _CFPFactoryRemoveInstanceLocked(v3);
  }
  return os_unfair_recursive_lock_unlock();
}

CFStringRef __CFPlugInInstanceCopyDescription()
{
  return @"Some CFPlugInInstance";
}

CFTypeID CFPlugInInstanceGetTypeID(void)
{
  return 33LL;
}

CFPlugInInstanceRef CFPlugInInstanceCreateWithInstanceDataSize( CFAllocatorRef allocator, CFIndex instanceDataSize, CFPlugInInstanceDeallocateInstanceDataFunction deallocateInstanceFunction, CFStringRef factoryName, CFPlugInInstanceGetInterfaceFunction getInterfaceFunction)
{
  uint64_t Instance = (__CFPlugInInstance *)_CFRuntimeCreateInstance( allocator,  0x21uLL,  (instanceDataSize + 24),  0LL,  (uint64_t)getInterfaceFunction,  v5,  v6,  v7);
  if (Instance)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (_factoriesByFactoryID
      && (int Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryName)) != 0LL
      && Value[24])
    {
      *((void *)Instance + 2) = Value;
      _CFPFactoryAddInstanceLocked(Value);
    }

    else
    {
      *((void *)Instance + 2) = 0LL;
    }

    *((void *)Instance + 3) = getInterfaceFunction;
    *((void *)Instance + 4) = deallocateInstanceFunction;
    os_unfair_recursive_lock_unlock();
  }

  return Instance;
}

Boolean CFPlugInInstanceGetInterfaceFunctionTable( CFPlugInInstanceRef instance, CFStringRef interfaceName, void **ftbl)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  int32_t v4 = (uint64_t (*)(void))*((void *)instance + 3);
  if (v4)
  {
    BOOL v5 = v4() != 0;
    if (!ftbl) {
      return v5;
    }
  }

  else
  {
    BOOL v5 = 0;
    if (!ftbl) {
      return v5;
    }
  }

  uint64_t v6 = v8;
  if (!v5) {
    uint64_t v6 = 0LL;
  }
  *ftbl = v6;
  return v5;
}

CFStringRef CFPlugInInstanceGetFactoryName(CFPlugInInstanceRef instance)
{
  uint64_t v2 = *((void *)instance + 2);
  uint64_t v3 = *(const __CFString **)(v2 + 16);
  if (v3) {
    CFRetain(*(CFTypeRef *)(v2 + 16));
  }
  os_unfair_recursive_lock_unlock();
  return v3;
}

void *__cdecl CFPlugInInstanceGetInstanceData(CFPlugInInstanceRef instance)
{
  return (char *)instance + 40;
}

void OUTLINED_FUNCTION_0_10(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_3_4(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void OUTLINED_FUNCTION_4_1( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_5_1( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void OUTLINED_FUNCTION_7_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

  ;
}

CFErrorRef __CFPropertyListCreateError(CFIndex code, CFStringRef format, ...)
{
  if (!format) {
    return CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", code, 0LL);
  }
  CFStringRef v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, format, va);
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(Mutable, @"NSDebugDescription", v3);
  CFErrorRef v5 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", code, Mutable);
  CFRelease(v3);
  CFRelease(Mutable);
  return v5;
}

__CFData *_CFPropertyListCreateXMLData(CFAllocatorRef allocator, const __CFString *a2, int a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!a3 || (v7[0] = 1LL, v8 = 0u, v9 = 0LL, v7[1] = 100LL, CFMutableStringRef Mutable = 0LL, __CFPropertyListIsValidAux(a2, v7)))
  {
    CFMutableStringRef Mutable = CFDataCreateMutable(allocator, 0LL);
    CFDataAppendBytes(Mutable, (const UInt8 *)"<?xml version=1.0 encoding=UTF-8?>\n<!DOCTYPE ", 49LL);
    _plistAppendCharacters(Mutable, L"plist", 5LL);
    CFDataAppendBytes( Mutable,  (const UInt8 *)" PUBLIC -//Apple//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd>\n<",  89LL);
    _plistAppendCharacters(Mutable, L"plist", 5LL);
    CFDataAppendBytes(Mutable, (const UInt8 *)" version=1.0>\n", 16LL);
    _CFAppendXML0(a2, 0, Mutable);
    CFDataAppendBytes(Mutable, (const UInt8 *)"</", 2LL);
    _plistAppendCharacters(Mutable, L"plist", 5LL);
    CFDataAppendBytes(Mutable, (const UInt8 *)">\n", 2LL);
  }

  return Mutable;
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  v3[0] = 1LL;
  __int128 v4 = 0u;
  uint64_t v5 = 0LL;
  v3[1] = format;
  return __CFPropertyListIsValidAux(plist, v3);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 1);
}

__CFData *_CFPropertyListCreateXMLDataWithExtras(const __CFAllocator *a1, const __CFString *a2)
{
  return _CFPropertyListCreateXMLData(a1, a2, 0);
}

BOOL __CFPropertyListIsValidAux(const void *a1, _BYTE *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    if (*((void *)a2 + 3))
    {
      __int128 v8 = @"property lists cannot contain NULL";
      goto LABEL_11;
    }

    return 0LL;
  }

  CFTypeID v4 = CFGetTypeID(a1);
  BOOL v5 = 1LL;
  if (v4 != 7)
  {
    CFTypeID v6 = v4;
    if (v4 != 20
      && (*((void *)a2 + 1) == 1LL
       || (v4 > 0x2A || ((1LL << v4) & 0x40000600000LL) == 0) && _CFKeyedArchiverUIDGetTypeID() != v4))
    {
      uint64_t v7 = *((void *)a2 + 2);
      if (v7)
      {
        if (CFSetContainsValue(*((CFSetRef *)a2 + 2), a1))
        {
          if (*((void *)a2 + 3))
          {
            __int128 v8 = @"property lists cannot contain recursive container references";
LABEL_11:
            BOOL v5 = 0LL;
            **((void **)a2 + 3) = CFRetain(v8);
            return v5;
          }

          return 0LL;
        }
      }

      else
      {
        *((void *)a2 + 2) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL);
      }

      uint64_t v9 = *((void *)a2 + 1);
      if (v9 != 200)
      {
        uint64_t v10 = (const __CFBag *)*((void *)a2 + 4);
        if (!v10)
        {
          *(_OWORD *)&callBacks.version = *(_OWORD *)&kCFTypeBagCallBacks.version;
          *(_OWORD *)&callBacks.release = *(_OWORD *)&kCFTypeBagCallBacks.release;
          callBacks.equal = 0LL;
          callBacks.hash = 0LL;
          *((void *)a2 + 4) = CFBagCreateMutable(0LL, 0LL, &callBacks);
          int v12 = 1;
LABEL_26:
          if (v6 == 18)
          {
            CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
            if (v9 != 200 && Count >= 1) {
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            }
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            CFDictionaryApplyFunction( (CFDictionaryRef)a1,  (CFDictionaryApplierFunction)__CFPropertyListIsDictPlistAux,  a2);
          }

          else
          {
            if (v6 != 19)
            {
              if (*((void *)a2 + 3))
              {
                CFStringRef v16 = CFCopyTypeIDDescription(v6);
                **((void **)a2 + 3) = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"property lists cannot contain objects of type '%@'",  v16);
                CFRelease(v16);
              }

              BOOL v5 = 0LL;
              if (v7) {
                goto LABEL_38;
              }
LABEL_37:
              CFRelease(*((CFTypeRef *)a2 + 2));
              *((void *)a2 + 2) = 0LL;
LABEL_38:
              if (v12)
              {
                CFRelease(*((CFTypeRef *)a2 + 4));
                *((void *)a2 + 4) = 0LL;
              }

              return v5;
            }

            CFIndex v13 = CFArrayGetCount((CFArrayRef)a1);
            CFIndex v14 = v13;
            if (v9 != 200 && v13 >= 1) {
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            }
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            v19.CFIndex location = 0LL;
            v19.CFIndex length = v14;
            CFArrayApplyFunction((CFArrayRef)a1, v19, (CFArrayApplierFunction)__CFPropertyListIsArrayPlistAux, a2);
          }

          CFSetRemoveValue(*((CFMutableSetRef *)a2 + 2), a1);
          BOOL v5 = *a2 != 0;
          if (v7) {
            goto LABEL_38;
          }
          goto LABEL_37;
        }

        if ((unint64_t)CFBagGetCountOfValue(v10, a1) >= 0x181)
        {
          if (*((void *)a2 + 3))
          {
            __int128 v8 = @"Too many nested arrays or dictionaries please use kCFPropertyListBinaryFormat_v1_0 instead which supports references";
            goto LABEL_11;
          }

          return 0LL;
        }
      }

      int v12 = 0;
      goto LABEL_26;
    }
  }

  return v5;
}

CFSetRef __CFPropertyListCreateTopLevelKeyPaths(const __CFAllocator *a1, CFSetRef theSet)
{
  CFMutableStringRef Mutable = theSet;
  v16[1] = *MEMORY[0x1895F89C0];
  if (theSet)
  {
    unint64_t Count = CFSetGetCount(theSet);
    if (Count >> 60) {
      __CFPropertyListCreateTopLevelKeyPaths_cold_1();
    }
    unint64_t v6 = Count;
    unint64_t v7 = MEMORY[0x1895F8858](Count, v5);
    uint64_t v10 = (const void **)((char *)v16 - v9);
    if (v7 > 0x100)
    {
      uint64_t v10 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v8, 0LL);
      if (!v10) {
        __CFPropertyListCreateTopLevelKeyPaths_cold_2();
      }
    }

    else
    {
      bzero((char *)v16 - v9, 8 * v8);
    }

    CFSetGetValues(Mutable, v10);
    CFMutableStringRef Mutable = CFSetCreateMutable(a1, v6, &kCFTypeSetCallBacks);
    if (v6)
    {
      for (uint64_t i = 0LL; i != v6; ++i)
      {
        CFTypeID v12 = CFGetTypeID(v10[i]);
        CFIndex v13 = (const __CFString *)v10[i];
        if (v12 == 19)
        {
          CFSetAddValue(Mutable, v13);
        }

        else
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v13, @":");
          CFSetAddValue(Mutable, ArrayBySeparatingStrings);
          if (ArrayBySeparatingStrings) {
            CFRelease(ArrayBySeparatingStrings);
          }
        }
      }

      if (v6 >= 0x101) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10);
      }
    }
  }

  return Mutable;
}

void __CFPropertyListCreateSplitKeypaths( const __CFAllocator *a1, CFSetRef theSet, __CFSet **a3, __CFSet **a4)
{
  CFTypeID v4 = a4;
  uint64_t v5 = a3;
  CFAllocatorRef v34 = a1;
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!theSet)
  {
    *a3 = 0LL;
    *a4 = 0LL;
    return;
  }

  unint64_t Count = CFSetGetCount(theSet);
  if (Count >> 60) {
    __CFPropertyListCreateSplitKeypaths_cold_1();
  }
  unint64_t v9 = Count;
  unint64_t v10 = MEMORY[0x1895F8858](Count, v8);
  CFIndex v13 = (const void **)((char *)&v30 - v12);
  if (v10 >= 0x101)
  {
    CFStringRef v16 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v11, 0LL);
    if (!v16) {
      __CFPropertyListCreateSplitKeypaths_cold_4();
    }
    CFIndex v13 = v16;
    CFSetGetValues(theSet, v16);
    goto LABEL_9;
  }

  bzero((char *)&v30 - v12, 8 * v11);
  CFSetGetValues(theSet, v13);
  if (v9)
  {
LABEL_9:
    uint64_t v30 = (uint64_t)&v30;
    __int16 v31 = v5;
    CFMutableStringRef Mutable = 0LL;
    CFIndex v15 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v32 = v4;
    CFAllocatorRef v33 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    do
    {
      uint64_t v18 = (const __CFArray *)v13[v17];
      CFIndex v19 = CFArrayGetCount(v18);
      unint64_t v20 = v19 - 1;
      if (v19 >= 1)
      {
        unint64_t v21 = v19;
        if (!Mutable) {
          CFMutableStringRef Mutable = CFSetCreateMutable(v34, 0LL, &kCFTypeSetCallBacks);
        }
        ValueAtIndex = CFArrayGetValueAtIndex(v18, 0LL);
        CFSetAddValue(Mutable, ValueAtIndex);
        if (v21 >= 2)
        {
          if (!v15)
          {
            CFMutableSetRef v23 = CFSetCreateMutable(v34, 0LL, &kCFTypeSetCallBacks);
            CFIndex v15 = v23;
          }

          if (v20 >> 60) {
            __CFPropertyListCreateSplitKeypaths_cold_2();
          }
          MEMORY[0x1895F8858](v23, v24);
          uint64_t v26 = (const void **)((char *)&v30 - v25);
          uint64_t v27 = 8 * v20;
          if (v21 > 0x101)
          {
            uint64_t v26 = (const void **)CFAllocatorAllocate(v33, v27, 0LL);
            if (!v26) {
              __CFPropertyListCreateSplitKeypaths_cold_3();
            }
          }

          else
          {
            bzero((char *)&v30 - v25, v27);
          }

          v36.CFIndex length = CFArrayGetCount(v18) - 1;
          v36.CFIndex location = 1LL;
          CFArrayGetValues(v18, v36, v26);
          CFIndex v28 = CFArrayGetCount(v18);
          CFArrayRef v29 = CFArrayCreate(v34, v26, v28 - 1, &kCFTypeArrayCallBacks);
          CFSetAddValue(v15, v29);
          if (v29) {
            CFRelease(v29);
          }
          if (v21 >= 0x102) {
            CFAllocatorDeallocate(v33, v26);
          }
        }
      }

      ++v17;
    }

    while (v9 != v17);
    uint64_t v5 = v31;
    CFTypeID v4 = v32;
    if (v9 >= 0x101) {
      CFAllocatorDeallocate(v33, v13);
    }
    goto LABEL_27;
  }

  CFMutableStringRef Mutable = 0LL;
  CFIndex v15 = 0LL;
LABEL_27:
  CFArrayRef v5 = Mutable;
  *CFTypeID v4 = v15;
}

uint64_t __CFPropertyListKeyPassesFilterSet(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = ____CFPropertyListKeyPassesFilterSet_block_invoke;
  v4[3] = &unk_18999B7E8;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_180ABD248( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

BOOL __CFPropertyListKeyBufferMatchesFilterBuffer(unsigned __int8 *a1, uint64_t a2, _BYTE *__s2, uint64_t __n)
{
  uint64_t v4 = __n - 1;
  if (__n != 1)
  {
    if (__n >= 2 && __s2[v4] == 42)
    {
      if (v4 <= a2)
      {
        uint64_t v7 = __s2;
        size_t v8 = __n - 1;
        return memcmp(a1, v7, v8) == 0;
      }
    }

    else if (a2 == __n)
    {
      uint64_t v7 = __s2;
      size_t v8 = __n;
      return memcmp(a1, v7, v8) == 0;
    }

    return 0LL;
  }

  int v5 = *__s2;
  if (v5 == 42) {
    return 1LL;
  }
  if (a2 != 1) {
    return 0LL;
  }
  return v5 == *a1;
}

BOOL __CFPropertyListFilterKeyHasWildcard(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  return Length >= 1 && CFStringGetCharacterAtIndex(a1, Length - 1) == 42;
}

uint64_t _CFPropertyListCreateFromXMLStringError( const __CFAllocator *a1, const __CFString *a2, int a3, void *a4, char a5, void *a6)
{
  v14[1] = *MEMORY[0x1895F89C0];
  UTF8DataFromString = _createUTF8DataFromString(a1, a2);
  v14[0] = 0LL;
  _CFPropertyListCreateFromUTF8Data(a1, UTF8DataFromString, 0LL, a2, 0, a3, a4, a5, a6, 0LL, v14, 1, 1);
  if (UTF8DataFromString) {
    CFRelease(UTF8DataFromString);
  }
  return v14[0];
}

CFDataRef _createUTF8DataFromString(const __CFAllocator *a1, CFStringRef theString)
{
  size[1] = *MEMORY[0x1895F89C0];
  size[0] = 0LL;
  v7.CFIndex length = CFStringGetLength(theString);
  v7.CFIndex location = 0LL;
  CFStringGetBytes(theString, v7, 0x8000100u, 0, 0, 0LL, 0LL, size);
  uint64_t v4 = (UInt8 *)CFAllocatorAllocate(a1, size[0], 0LL);
  v8.CFIndex length = CFStringGetLength(theString);
  v8.CFIndex location = 0LL;
  CFStringGetBytes(theString, v8, 0x8000100u, 0, 0, v4, size[0], 0LL);
  return CFDataCreateWithBytesNoCopy(a1, v4, size[0], a1);
}

uint64_t _CFPropertyListCreateFromUTF8Data( const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const void *a4, CFStringEncoding a5, int a6, void *a7, char a8, void *a9, const __CFSet *a10, void *a11, char a12, char a13)
{
  v81[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  CFIndex Length = CFDataGetLength(theData);
  if (!Length)
  {
    if (!a7) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Conversion of string failed. The string is empty.");
    goto LABEL_8;
  }

  CFIndex v22 = Length;
  v81[0] = 0LL;
  BytePtr = CFDataGetBytePtr(theData);
  int64_t v70 = &BytePtr[a3];
  if (__OFADD__(&BytePtr[a3], v22))
  {
    if (!a7) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to address entirety of CFPropertyList");
LABEL_8:
    uint64_t v25 = Error;
    goto LABEL_9;
  }

  uint64_t v27 = a9;
  v71 = (char *)&BytePtr[a3];
  unint64_t v72 = (unint64_t)&BytePtr[v22];
  CFTypeRef v73 = 0LL;
  v74 = a1;
  int v75 = a6;
  char v78 = a8;
  char v80 = 0;
  if (!a12) {
    goto LABEL_79;
  }
  CFRetain(theData);
  v76 = CFBurstTrieCreate();
  CFTypeRef cf = CFArrayCreateMutable(a1, 0LL, &kCFTypeArrayCallBacks);
  CFTypeRef TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths(a1, a10);
  while (1)
  {
    CFIndex v28 = v71;
    if ((unint64_t)v71 >= v72)
    {
      CFErrorRef v50 = __CFPropertyListCreateError(3840LL, @"Encountered unexpected EOF", v64, v66);
LABEL_69:
      CFTypeRef v51 = 0LL;
      int v52 = 0;
      CFTypeRef v73 = v50;
      goto LABEL_75;
    }

    unint64_t v29 = v72 - (void)v71;
    while (1)
    {
      unsigned int v30 = *v28;
      BOOL v31 = v30 > 0x20;
      uint64_t v32 = (1LL << v30) & 0x100002600LL;
      if (v31 || v32 == 0) {
        break;
      }
      ++v28;
      if (!--v29)
      {
        CFIndex v28 = (char *)v72;
        break;
      }
    }

    v71 = v28;
    if ((unint64_t)(v28 + 1) >= v72)
    {
      CFErrorRef v50 = __CFPropertyListCreateError(3840LL, @"No XML content found", v64, v66);
      goto LABEL_69;
    }

    uint64_t v34 = *v28;
    if ((_DWORD)v34 != 60)
    {
      uint64_t v68 = lineNumber((unint64_t *)&v70);
      CFErrorRef v50 = __CFPropertyListCreateError(3840LL, @"Unexpected character %c at line %u", v34, v68);
      goto LABEL_69;
    }

    v71 = v28 + 1;
    int v35 = v28[1];
    if (v35 == 63)
    {
      v71 = v28 + 2;
      skipXMLProcessingInstruction((unint64_t *)&v70);
      goto LABEL_29;
    }

    CFRange v36 = v28 + 2;
    v71 = v28 + 2;
    if ((unint64_t)(v28 + 3) < v72 && *(_BYTE *)v36 == 45 && v28[3] == 45)
    {
      v71 = v28 + 5;
      skipXMLComment((unint64_t *)&v70);
LABEL_29:
      if (v73) {
        goto LABEL_70;
      }
    }

    else
    {
      if ((uint64_t)(v72 - (void)v36) >= 7
        && (*v36 == 1413697348 ? (BOOL v37 = *(_DWORD *)(v28 + 5) == 1162893652) : (BOOL v37 = 0), v37))
      {
        uint64_t v39 = (unsigned __int8 *)(v28 + 9);
        v71 = v28 + 9;
        if ((unint64_t)(v28 + 9) < v72)
        {
          uint64_t v40 = v72 - (void)v28 - 9;
          while (1)
          {
            unsigned int v41 = (char)*v39;
            BOOL v31 = v41 > 0x20;
            uint64_t v42 = (1LL << v41) & 0x100002600LL;
            if (v31 || v42 == 0) {
              break;
            }
            v71 = (char *)++v39;
            if (!--v40)
            {
              uint64_t v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }

        if ((unint64_t)v39 < v72)
        {
          unint64_t v44 = v72 - (void)v39;
          while (1)
          {
            int v45 = *v39;
            if (v45 == 91) {
              break;
            }
            if (v45 == 62)
            {
              CFRange v47 = (char *)(v39 + 1);
              goto LABEL_63;
            }

            v71 = (char *)++v39;
            if (!--v44)
            {
              uint64_t v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }

        if (v39 == (unsigned __int8 *)v72 || (unint64_t)v39 >= v72)
        {
LABEL_61:
          CFErrorRef v38 = __CFPropertyListCreateError(3840LL, @"Encountered unexpected EOF while parsing DTD", v64, v66);
        }

        else
        {
          unint64_t v46 = v72 - (void)v39;
          CFRange v47 = (char *)(v39 + 1);
          while (1)
          {
            uint64_t v48 = *(v47 - 1);
            v71 = v47++;
            if (!--v46) {
              goto LABEL_61;
            }
          }

          if ((_DWORD)v48 == 62)
          {
LABEL_63:
            v71 = v47;
            goto LABEL_29;
          }

          uint64_t v67 = lineNumber((unint64_t *)&v70);
          CFErrorRef v38 = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected character %c on line %u while parsing DTD",  v48,  v67);
        }
      }

      else
      {
        uint64_t v65 = lineNumber((unint64_t *)&v70);
        CFErrorRef v38 = __CFPropertyListCreateError(3840LL, @"Malformed DTD on line %u", v65, v66);
      }

      CFTypeRef v73 = v38;
      if (v38)
      {
LABEL_70:
        CFTypeRef v51 = 0LL;
        int v52 = 0;
        goto LABEL_75;
      }
    }
  }

  int v53 = parseXMLElement((uint64_t)&v70, 0LL, v81, 0LL);
  int v52 = v53;
  CFTypeRef v51 = v81[0];
  if (a9 && v53 && v81[0])
  {
    *a9 = 100LL;
    int v52 = 1;
  }

uint64_t _CFPropertyListCreateFromXMLString( const __CFAllocator *a1, const __CFString *a2, int a3, CFStringRef *a4, char a5, void *a6)
{
  err[1] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  if (a4) {
    *a4 = 0LL;
  }
  err[0] = 0LL;
  uint64_t v7 = _CFPropertyListCreateFromXMLStringError(a1, a2, a3, err, a5, a6);
  CFErrorRef v8 = err[0];
  if (a4 && err[0])
  {
    uint64_t v9 = CFErrorCopyUserInfo(err[0]);
    value = 0LL;
    int ValueIfPresent = CFDictionaryGetValueIfPresent( v9,  @"kCFPropertyListOldStyleParsingError",  (const void **)&value);
    uint64_t v11 = (const __CFString *)CFDictionaryGetValue(v9, @"NSDebugDescription");
    CFStringRef v12 = v11;
    if (ValueIfPresent)
    {
      CFDictionaryRef v13 = CFErrorCopyUserInfo((CFErrorRef)value);
      CFIndex v14 = CFDictionaryGetValue(v9, @"NSDebugDescription");
      CFStringRef v12 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"XML parser error:\n\t%@\nOld-style plist parser error:\n\t%@\n",  v12,  v14);
      CFRelease(v13);
    }

    else if (v11)
    {
      CFRetain(v11);
    }

    CFRelease(v9);
    *a4 = v12;
    CFErrorRef v8 = err[0];
  }

  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

uint64_t _CFPropertyListCreateFiltered( const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const __CFSet *a4, CFTypeRef *a5, CFErrorRef *a6)
{
  uint64_t v6 = 0LL;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (theData && a4)
  {
    BytePtr = CFDataGetBytePtr(theData);
    unint64_t Length = CFDataGetLength(theData);
    CFTypeRef cf = 0LL;
    if (Length >= 8
      && (int v15 = Length, __CFDataGetBinaryPlistTopLevelInfo(theData, &v22, &v21, (uint64_t)v23)))
    {
      unint64_t v16 = v21;
      CFTypeRef TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths(a1, a4);
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(a1, 0LL, 0LL, &kCFTypeDictionaryValueCallBacks);
      uint64_t v6 = __CFBinaryPlistCreateObjectFiltered( BytePtr,  v15,  v16,  (uint64_t)v23,  (__objc2_class **)a1,  a3,  (unint64_t)theData & (a3 << 47 >> 63),  Mutable,  0LL,  0LL,  TopLevelKeyPaths,  &cf,  0LL);
      CFRelease(TopLevelKeyPaths);
      CFRelease(Mutable);
    }

    else
    {
      uint64_t v6 = _CFPropertyListCreateWithData((__objc2_class **)a1, theData, a3, a6, 1, 0LL, a4, &cf) != 0;
    }

    if (a5 && (_DWORD)v6)
    {
      *a5 = cf;
    }

    else if (cf)
    {
      CFRelease(cf);
    }
  }

  return v6;
}

uint64_t _CFPropertyListCreateWithData( __objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4, char a5, void *a6, const __CFSet *a7, void *a8)
{
  char v10 = BYTE1(a3) | (a3 >> 9) | (a3 >> 10);
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0)) {
    int v11 = (a3 >> 10) & 1;
  }
  else {
    int v11 = 1;
  }
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0)) {
    int v12 = (a3 >> 8) & 1;
  }
  else {
    int v12 = 1;
  }
  if (!theData || !CFDataGetLength(theData))
  {
    if (!a4) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Cannot parse a NULL or zero-length data");
LABEL_17:
    uint64_t v18 = 0LL;
    *a4 = Error;
    return v18;
  }

  if (((a3 & 0x200) != 0 || (v10 & 1) == 0)
    && __CFTryParseBinaryPlist(a1, theData, a3, a8, 0LL))
  {
    if (a6) {
      *a6 = 200LL;
    }
    return 1LL;
  }

  if (!(v11 | v12))
  {
    if (!a4) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unsupported property list");
    goto LABEL_17;
  }

  char v50 = a5;
  BytePtr = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  unsigned int v22 = Length;
  if (Length < 5)
  {
    if (Length != 4)
    {
      if (Length < 3)
      {
LABEL_51:
        uint64_t v26 = 0LL;
        goto LABEL_52;
      }

      int v23 = *BytePtr;
LABEL_36:
      switch(v23)
      {
        case 0:
          goto LABEL_54;
        case 254:
          int v25 = BytePtr[1];
          if (v25 == 255)
          {
            CFRange v49 = a6;
            int v24 = 268435712;
            goto LABEL_55;
          }

          break;
        case 255:
          int v25 = BytePtr[1];
          if (v25 == 254)
          {
            CFRange v49 = a6;
LABEL_44:
            int v24 = 335544576;
LABEL_55:
            uint64_t v28 = 2LL;
            goto LABEL_56;
          }

          break;
        default:
          int v25 = BytePtr[1];
          break;
      }

      goto LABEL_48;
    }

    int v23 = *BytePtr;
  }

  else
  {
    int v23 = *BytePtr;
    if (v23 == 255)
    {
      int v25 = BytePtr[1];
      if (v25 == 254)
      {
        CFRange v49 = a6;
        if (!BytePtr[2] && !BytePtr[3])
        {
          int v24 = 469762304;
          goto LABEL_90;
        }

        goto LABEL_44;
      }

const void *_CFPropertyListGetValueWithKeyPath(const void *a1, const __CFString *cf)
{
  uint64_t result = 0LL;
  if (a1 && cf)
  {
    if (CFGetTypeID(cf) == 19) {
      CFArrayRef ArrayBySeparatingStrings = (const __CFArray *)CFRetain(cf);
    }
    else {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  cf,  @":");
    }
    uint64_t v6 = ArrayBySeparatingStrings;
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      uint64_t v9 = 1LL;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9 - 1);
        CFTypeID v11 = CFGetTypeID(a1);
        if (v11 == 19)
        {
          Intint Value = CFStringGetIntValue(ValueAtIndex);
          int Value = CFArrayGetValueAtIndex((CFArrayRef)a1, IntValue);
        }

        else
        {
          if (v11 != 18)
          {
            a1 = 0LL;
            break;
          }

          int Value = CFDictionaryGetValue((CFDictionaryRef)a1, ValueAtIndex);
        }

        a1 = Value;
        if (v9 < v8)
        {
          ++v9;
          if (Value) {
            continue;
          }
        }

        break;
      }
    }

    CFRelease(v6);
    return a1;
  }

  return result;
}

BOOL _CFPropertyListCreateSingleValue( __objc2_class **a1, const __CFData *a2, uint64_t a3, CFStringRef theString, void *a5, CFErrorRef *a6)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (!theString || !CFStringGetLength(theString)) {
    return 0LL;
  }
  BytePtr = (char *)CFDataGetBytePtr(a2);
  unint64_t Length = CFDataGetLength(a2);
  if (Length < 8 || (uint64_t v14 = Length, !__CFDataGetBinaryPlistTopLevelInfo(a2, &v42, &v41, (uint64_t)v44)))
  {
    int v43 = 0LL;
    _CFPropertyListCreateWithData(a1, a2, a3, a6, 1, 0LL, 0LL, &v43);
    uint64_t v26 = v43;
    if (v43)
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  theString,  @":");
      uint64_t v28 = v26;
      if (CFArrayGetCount(ArrayBySeparatingStrings) < 1)
      {
LABEL_36:
        BOOL v34 = v28 != 0LL;
        int v35 = 1;
        if (a5 && v28)
        {
          *a5 = v28;
          CFRetain(v28);
          uint64_t v36 = 1LL;
        }

        else
        {
LABEL_45:
          uint64_t v36 = v35 & v34;
        }

        CFRelease(ArrayBySeparatingStrings);
        CFRelease(v26);
        return v36;
      }

      CFIndex v29 = 0LL;
      uint64_t v28 = v26;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v29);
        Intint Value = CFStringGetIntValue(ValueAtIndex);
        SInt32 v32 = IntValue;
        if (IntValue == 0x7FFFFFFF) {
          goto LABEL_26;
        }
        if (!IntValue) {
          break;
        }
        if (IntValue != 0x80000000 || !v28)
        {
LABEL_32:
          if (!v28)
          {
LABEL_43:
            int v35 = 0;
            BOOL v34 = 0;
            goto LABEL_45;
          }

          goto LABEL_33;
        }

LABEL_30:
        if (CFGetTypeID(v28) == 18)
        {
          int Value = CFDictionaryGetValue((CFDictionaryRef)v28, ValueAtIndex);
          goto LABEL_35;
        }

  CFIndex v18 = (os_log_s *)_CFBundleResourceLogger();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG) && a5 | (unint64_t)a6)
  {
    unsigned int v30 = values;
    CFIndex v31 = a5;
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    CFIndex v20 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    unint64_t v21 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    unsigned int v22 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    unsigned int v23 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    if (a6) {
      CFStringAppendFormat(Mutable, 0LL, @"%@", a6);
    }
    else {
      CFStringAppendFormat(Mutable, 0LL, @"%@", v31);
    }
    _onelineFormatArray(v20, a1);
    _onelineFormatArray(v21, theArray);
    _onelineFormatArray(v22, v11);
    _onelineFormatArray(v23, MutableArrayOfFallbackLanguages);
    if (CFBundleAllowMixedLocalizations_once != -1) {
      dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
    }
    int v24 = CFBundleAllowMixedLocalizations_allowMixed != 0;
    uint64_t v26 = a6
       && (InfoDictionary = CFBundleGetInfoDictionary(a6)) != 0LL
       && CFDictionaryGetValue(InfoDictionary, @"_CFBundleUseAppleLocalizations") == &__kCFBooleanTrue;
    char v27 = (os_log_s *)_CFBundleResourceLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      CFIndex v29 = "";
      *(_DWORD *)buf = 138479619;
      *(void *)&uint8_t buf[4] = Mutable;
      BOOL v34 = 2114;
      if (v26) {
        CFIndex v29 = "(use Apple Locs)";
      }
      int v35 = v20;
      uint64_t v36 = 2114;
      int v37 = v30;
      int v38 = 2114;
      CFTypeRef v39 = v21;
      int v40 = 2114;
      unint64_t v41 = v22;
      char v42 = 2050;
      int v43 = v24;
      CFErrorRef v44 = 2082;
      uint64_t v45 = v29;
      CFStringEncoding v46 = 2114;
      CFStringEncoding v47 = v23;
      _os_log_debug_impl( &dword_180A4C000,  v27,  OS_LOG_TYPE_DEBUG,  "Language lookup at %{private}@\n \tLocalizations : %{public}@\n \tDev language  : %{public}@\n \tUser prefs    : %{public}@\n \tMain bundle   : %{public}@\n \tAllow mixed   : %{public}lu %{public}s\n \tResult        : %{public}@\n",  buf,  0x52u);
    }

    CFRelease(Mutable);
    CFRelease(v20);
    CFRelease(v21);
    CFRelease(v23);
    CFRelease(v22);
  }

  if (v11) {
    CFRelease(v11);
  }
  return MutableArrayOfFallbackLanguages;
}

    LODWORD(v24) = 1;
    goto LABEL_33;
  }

  LOBYTE(v51[0]) = 0;
  char v19 = _CFGetTSD(1u);
  CFIndex v20 = &__kCFAllocatorSystemDefault;
  if (v19) {
    CFIndex v20 = (__objc2_class **)v19;
  }
  CFRange v55 = v20;
  int v52 = 0LL;
  unint64_t v21 = atomic_load(a1 + 1);
  if (__CFStringDecodeByteStream3((char *)a2, a3, a4, (v21 >> 4) & 1, (uint64_t)&v52, v51, 0LL))
  {
    uint64_t v9 = 0;
    a3 = v56;
    CFTypeID v11 = v53 == 0;
    a2 = v52;
    if (LOBYTE(v51[0])) {
      unsigned int v22 = 1;
    }
    else {
      unsigned int v22 = v54 == 0;
    }
    char v10 = !v22;
    goto LABEL_6;
  }

  if (!v9) {
    return 0;
  }
  if (!range)
  {
    v30[0] = 0LL;
    v30[1] = CFStringGetLength(string);
    range = (CFRange *)v30;
  }

  *(void *)buffer = string;
  SInt32 v32 = CFStringGetLength(string);
  CFAllocatorRef v33 = string;
  uint64_t v36 = 0LL;
  int v37 = v32;
  CharactersPtr = CFStringGetCharactersPtr(string);
  CStringPtr = 0LL;
  BOOL v34 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(string, 0x600u);
  }
  int v35 = CStringPtr;
  int v38 = 0LL;
  CFTypeRef v39 = 0LL;
  CFTypeRef cf = 0LL;
  CFIndex v29 = LODWORD(range->length) + LODWORD(range->location);
  utrans_trans();
  if (cf) {
    CFRelease(cf);
  }
  range->CFIndex length = v29 - range->location;
  char v27 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID)
  {
    CFRelease((CFTypeRef)__CFStringTransformCacheID);
    utrans_close();
  }

  __CFStringTransformCacheID = (uint64_t)CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, transform);
  __CFStringTransformCacheTL = v9;
  __CFStringTransformCacheRev = v4 != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  return v27;
}

        if (v17) {
          *a3 |= a10;
        }
        if (!*a2) {
          *a2 = CFStringCreateMutable(a1, 0LL);
        }
        uint64_t v26 = CFStringCreateWithBytes(a1, (const UInt8 *)(a4 + *a9), v18 - *a9, 0x201u, 0);
        CFStringAppend(*a2, v26);
        CFRelease(v26);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v18 + 1;
        }

        else if (a11 == 134217984)
        {
          unsigned int v22 = v18 + 1;
          if (v18 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            char v27 = *(char *)(a4 + v22);
            if (v27 >> 10 == 55)
            {
              char v50 = v49;
              CFTypeRef v51 = v27;
              else {
                unsigned int v22 = v18;
              }
              int v15 = 1;
              goto LABEL_44;
            }
          }
        }

        int v15 = 1;
LABEL_43:
        unsigned int v22 = v18;
        goto LABEL_44;
      }

      unsigned int v22 = a7;
LABEL_44:
      CFIndex v18 = v22 + 1;
      if (v22 + 1 >= a8) {
        return v15;
      }
    }
  }

  return 0;
}

  if (!v22) {
    return 0LL;
  }
  int v24 = objc_lookUpClass("NSArray");
  objc_lookUpClass("NSDictionary");
  block = MEMORY[0x1895F87A8];
  BOOL v34 = 3221225472LL;
  int v35 = __32__NSSharedKeySet_initWithCoder___block_invoke;
  uint64_t v36 = &unk_18999B4C8;
  int v37 = v24;
  if (initWithCoder__onceToken_0 != -1) {
    dispatch_once(&initWithCoder__onceToken_0, &block);
  }
  int v25 = (void *)[a3 allowedClasses];
  uint64_t v26 = (void *)objc_msgSend( (id)objc_msgSend(v25, "setByAddingObjectsFromSet:", initWithCoder__oPlistClasses_0),  "mutableCopy");
  [v26 removeObject:objc_opt_class()];
  char v27 = (void *)[a3 decodeObjectOfClasses:v26 forKey:@"NS.keys"];

  if (!v27 && [a3 error])
  {
    CFIndex v31 = __CFExceptionProem((objc_class *)self, a2);
    uint64_t v9 = @"%@: unable to unarchive - invalid class";
    goto LABEL_8;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    CFIndex v31 = objc_opt_class();
    uint64_t v9 = @"unexpected mutable keys (%@)";
    goto LABEL_8;
  }

  if ((_NSIsNSArray((uint64_t)v27) & 1) == 0)
  {
    CFIndex v31 = objc_opt_class();
    uint64_t v9 = @"unexpected keys (%@)";
    goto LABEL_8;
  }

  uint64_t v28 = [v27 count];
  if (v28 != v12)
  {
    CFIndex v31 = [v27 count];
    SInt32 v32 = v12;
    uint64_t v9 = @"key count mismatch %lu vs %u";
    goto LABEL_8;
  }

  CFIndex v29 = v28 - 1;
  while (v29 != -1)
  {
    [v27 objectAtIndexedSubscript:v29];
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      --v29;
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        continue;
      }
    }

    CFIndex v31 = objc_opt_class();
    uint64_t v9 = @"unexpected recursive keys (%@)";
    goto LABEL_8;
  }

  unsigned int v30 = +[NSArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v27);
  -[NSMutableArray addObjectsFromArray:]( v30,  "addObjectsFromArray:",  -[NSSharedKeySet allKeys](self->_subSharedKeySet, "allKeys"));

  return +[NSSharedKeySet keySetWithKeys:](&OBJC_CLASS___NSSharedKeySet, "keySetWithKeys:", v30);
}

              uint64_t v17 = 0;
              goto LABEL_36;
            }

            CFTypeID v11 = 0;
            if (buffer[1] == 46)
            {
              int v12 = -2LL;
              CFDictionaryRef v13 = 2LL;
              uint64_t v14 = buffer[0] - 48;
              goto LABEL_16;
            }

            unint64_t v16 = &buffer[1];
            --v9;
            CFIndex v18 = 0;
            uint64_t v14 = buffer[0] - 48;
          }

          else
          {
            CFTypeID v11 = 0;
            if (buffer[0] == 46)
            {
              int v12 = -1LL;
              CFDictionaryRef v13 = 1LL;
              uint64_t v14 = 0;
LABEL_16:
              int v15 = 0;
              goto LABEL_17;
            }

            unint64_t v16 = buffer;
            CFIndex v18 = 0;
            uint64_t v14 = 0;
          }

          uint64_t v17 = 0;
LABEL_42:
          unsigned int v22 = v10 - 97;
          unint64_t v21 = dword_180D81944[v22];
          if (v9 == 1)
          {
            char v19 = 0;
          }

          else
          {
            unsigned int v23 = v16[1];
            char v19 = v23 - 48;
            if (v9 != 2)
            {
              uint64_t v26 = v16[2];
              char v19 = v26 + 10 * v19 - 48;
              if (v9 != 3)
              {
                char v27 = v16[3];
                char v19 = v27 + 10 * v19 - 48;
                CFIndex v20 = v9 - 3 > 1;
                goto LABEL_49;
              }
            }
          }

          CFIndex v20 = 0;
LABEL_49:
          int v15 = v18;
          goto LABEL_50;
        }

        CFIndex v8 = CFGetTypeID(Value);
        if (v8 != CFNumberGetTypeID()) {
          CFDictionaryRemoveValue(v2, @"CFBundleNumericVersion");
        }
      }
    }
  }

LABEL_33:
        if (CFGetTypeID(v28) != 19)
        {
          int v35 = 0;
          BOOL v34 = 1;
          goto LABEL_45;
        }

        int Value = CFArrayGetValueAtIndex((CFArrayRef)v28, v32);
LABEL_35:
        uint64_t v28 = Value;
        if (++v29 >= CFArrayGetCount(ArrayBySeparatingStrings)) {
          goto LABEL_36;
        }
      }

      if (CFStringCompare(@"0", ValueAtIndex, 0LL) == kCFCompareEqualTo) {
        goto LABEL_32;
      }
LABEL_26:
      if (!v28) {
        goto LABEL_43;
      }
      goto LABEL_30;
    }

    return 0LL;
  }

  int v15 = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, @":");
  *(void *)int v40 = v41;
  CFMutableStringRef Mutable = (__objc2_class **)CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
  CFIndex Count = CFArrayGetCount(v15);
  _CFDictionarySetCapacity(Mutable, Count + 1);
  CFIndex v18 = Count - 1;
  if (Count < 1)
  {
    int v25 = 0;
    goto LABEL_42;
  }

  int v38 = a5;
  char v19 = 0;
  CFIndex v20 = 0LL;
  do
  {
    unint64_t v21 = (const __CFString *)CFArrayGetValueAtIndex(v15, v20);
    if (__CFBinaryPlistIsDictionary((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      char OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromDictionary3( BytePtr,  v14,  *(unint64_t *)v40,  (uint64_t)v44,  v21,  (unint64_t *)&v43,  (unint64_t *)v40);
LABEL_9:
      char v19 = OffsetForValueFromDictionary3;
      goto LABEL_13;
    }

    if (__CFBinaryPlistIsArray((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      unsigned int v23 = CFStringGetIntValue(v21);
      if (v23 <= 0x7FFFFFFE)
      {
        char OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromArray2( (uint64_t)BytePtr,  v14,  *(unint64_t *)v40,  (uint64_t)v44,  v23,  (unint64_t *)v40);
        goto LABEL_9;
      }
    }

    if (++v25 >= a4 - a3 + 1) {
      goto LABEL_46;
    }
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a2 & 0x4000000000000000LL) != 0)
    {
      if (v39)
      {
        pthread_mutex_lock(v39);
        [v40 addIndex:v27];
        pthread_mutex_unlock(v39);
      }

      else
      {
        [v40 addIndex:v27];
      }
    }

    goto LABEL_27;
  }

  SInt32 v32 = v41;
  while (1)
  {
    CFAllocatorRef v33 = atomic_load(v32);
    if (v33 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v34 = v33 < v27;
      if ((a2 & 2) == 0) {
        BOOL v34 = v27 < v33;
      }
      if (!v34) {
        break;
      }
    }

    while (1)
    {
      SInt32 v32 = v41;
      int v35 = __ldxr(v41);
      if (v35 != v33) {
        break;
      }
      if (!__stxr(v27, v41)) {
        goto LABEL_46;
      }
    }

    __clrex();
  }

  os_unfair_lock_unlock(v7);
  return v31;
}

  int v12 = CFRetain(v3);
  os_unfair_lock_unlock(v2);
  return v12;
}

    if (++v25 >= a4 - a3 + 1) {
      goto LABEL_46;
    }
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a2 & 0x4000000000000000LL) != 0)
    {
      if (v39)
      {
        pthread_mutex_lock(v39);
        [v40 addIndex:v27];
        pthread_mutex_unlock(v39);
      }

      else
      {
        [v40 addIndex:v27];
      }
    }

    goto LABEL_27;
  }

  SInt32 v32 = v41;
  while (1)
  {
    CFAllocatorRef v33 = atomic_load(v32);
    if (v33 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v34 = v33 < v27;
      if ((a2 & 2) == 0) {
        BOOL v34 = v27 < v33;
      }
      if (!v34) {
        break;
      }
    }

    while (1)
    {
      SInt32 v32 = v41;
      int v35 = __ldxr(v41);
      if (v35 != v33) {
        break;
      }
      if (!__stxr(v27, v41)) {
        goto LABEL_46;
      }
    }

    __clrex();
  }

      _CFAutoreleasePoolPop(context);
    }

    SInt32 v32 = (id)[v36 copy];

    return v32;
  }

  char v19 = *(void *)(a1 + 16);
  if ((v19 & 0x1E) != 6) {
    char v19 = v19 & 0xFFFFFFA0 | 6LL;
  }
  *(void *)(a1 + 16) = v19 & 0xFFFFFFFFFFFFFFBFLL;
}

    *(void *)(a1 + 16) &= ~0x40uLL;
    return v3;
  }

  return 0LL;
}

  unint64_t v21 = (unsigned __int16 *)&__CFToGB2312CharMap;
  int v25 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (2)
  {
    uint64_t v26 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v25 - v21)) >> 1;
    char v27 = &v21[17 * v26];
    uint64_t v28 = *v27;
    if (v28 > v14)
    {
      int v25 = v27 - 17;
      goto LABEL_39;
    }

    if (v28 + 16 <= v14)
    {
      unint64_t v21 = v27 + 17;
LABEL_39:
      if (v21 > v25) {
        goto LABEL_51;
      }
      continue;
    }

    break;
  }

  LOWORD(v21) = v21[17 * v26 + 1 + (int)(v14 - v28)];
  if ((_WORD)v21) {
    CFIndex v29 = (unsigned __int16)v21 == 65533;
  }
  else {
    CFIndex v29 = 1;
  }
  if (!v29)
  {
    char v19 = v11 + 2;
    if (a5)
    {
      if (v19 > a5) {
        goto LABEL_170;
      }
      *a4 = BYTE1(v21) | 0x80;
      LOBYTE(v21) = v21 | 0x80;
LABEL_127:
      a4[1] = (_BYTE)v21;
      a4 += 2;
    }

    goto LABEL_55;
  }

  CFStringRef theString = v17;
  v472 = v19;
  v495 = v47;
  if (v47 | v46)
  {
    if (v47)
    {
      if (v48.length >= 1)
      {
        CFRange v49 = 0;
        char v50 = v48.length;
        CFTypeRef v51 = (unsigned __int8 *)v47;
        while (1)
        {
          int v52 = *v51++;
          if (v52 == 37)
          {
            int v53 = __OFADD__(v49++, 1);
            if (v53) {
              break;
            }
          }

          if (!--v50)
          {
            uint64_t v45 = 0LL;
            CFErrorRef v44 = 0LL;
            goto LABEL_66;
          }
        }

        uint64_t v28 = a15;
        if (a15) {
          goto LABEL_26;
        }
        goto LABEL_884;
      }

      v494 = v46;
      theDict = v33;
      CFRange v49 = 0;
      uint64_t v45 = 0LL;
      goto LABEL_79;
    }

    uint64_t v45 = 0LL;
    CFErrorRef v44 = 0LL;
  }

  else
  {
    if (v48.length < 401)
    {
      CFErrorRef v44 = 0LL;
      CFRange v58 = v527;
    }

    else
    {
      CFRange v55 = v48.length;
      CFRange v56 = _CFGetTSD(1u);
      if (v56) {
        CFErrorRef v44 = (const __CFAllocator *)v56;
      }
      else {
        CFErrorRef v44 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      CFRange v57 = (UniChar *)CFAllocatorAllocate(v44, 2 * v55, 0LL);
      CFRange v58 = v57;
      CFRange v59 = v57 == v527 || __CFOASafe == 0;
      if (!v59)
      {
        CFRange v60 = v57;
        __CFSetLastAllocationEventName();
        CFRange v58 = v60;
      }

      v48.CFIndex length = range;
    }

    v48.CFIndex location = 0LL;
    uint64_t v66 = v58;
    CFStringGetCharacters(theString, v48, v58);
    CFStringEncoding v46 = (unint64_t)v66;
    v48.CFIndex length = range;
    uint64_t v45 = v66;
  }

  if (v48.length < 1)
  {
    v494 = v46;
    theDict = v33;
    CFRange v49 = 0;
  }

  else
  {
    uint64_t v67 = 0LL;
    CFRange v49 = 0;
    do
    {
      if (*(_WORD *)(v46 + 2 * v67) == 37)
      {
        int v53 = __OFADD__(v49++, 1);
        if (v53) {
          goto LABEL_67;
        }
      }

      ++v67;
    }

    while (v48.length != v67);
LABEL_66:
    if (v49 >= 0x100000)
    {
LABEL_67:
      uint64_t v28 = a15;
      if (!a15)
      {
        v500 = 0LL;
        int64_t v70 = 0LL;
        v71 = 0LL;
        unint64_t v72 = 0LL;
        goto LABEL_885;
      }

      uint64_t v68 = _CFGetTSD(1u);
      if (v68) {
        double v69 = (const __CFAllocator *)v68;
      }
      else {
        double v69 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      char v42 = CFDictionaryCreateMutable(v69, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, @"NSDebugDescription", @"Overflow occurred");
      int v43 = CFErrorCreate(v69, @"NSCocoaErrorDomain", 2048LL, v42);
LABEL_72:
      CFRelease(v42);
      v500 = 0LL;
      int64_t v70 = 0LL;
      v71 = 0LL;
      unint64_t v72 = 0LL;
      *uint64_t v28 = v43;
LABEL_885:
      CFAllocatorDeallocate(v44, v72);
      goto LABEL_886;
    }

    v494 = v46;
    theDict = v33;
  }

          v13 += v18;
          a2 += v18;
          uint64_t v28 = (uint64_t)v9 <= v18;
          v9 -= v18;
          if (v28) {
            return v13;
          }
          goto LABEL_3;
        }

        unint64_t v21 = v23 + 65;
      }

      else
      {
        CFIndex v20 = v23 - 65;
      }

      if (v21 > v20) {
        goto LABEL_24;
      }
    }
  }

  if ((unsigned __int16)(v19 + 351) <= 0x5Du)
  {
    if (a5)
    {
      char v27 = v19 - 3907;
LABEL_30:
      *a4++ = v27;
    }

    char v19 = 2LL;
    goto LABEL_34;
  }

  return v13;
}

  if (v21) {
    uint64_t v7 = _CFURLCreateWithURLString(allocator, v21, 0, *((const __CFURL **)v2 + 4));
  }
  else {
    uint64_t v7 = 0LL;
  }
  CFRelease(v21);
  if (v4) {
    goto LABEL_37;
  }
  return (CFURLRef)v7;
}

  if ((a2 - 57344) % 0xBC <= 0x3E) {
    CFDictionaryRef v13 = a2 + 68 * ((a2 - 57344) / 0xBC);
  }
  else {
    CFDictionaryRef v13 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  }
  int v5 = bswap32(v13 + 4160) >> 16;
LABEL_11:
  *(_WORD *)a3 = v5;
  return 2LL;
}

    int v24 = xpc_dictionary_get_string(a2, "Key") == 0LL;
LABEL_34:
    CFIndex length = 0LL;
    p_CFIndex length = &length;
    CFRange v56 = 0x3052000000LL;
    CFRange v57 = __Block_byref_object_copy__5;
    CFRange v58 = __Block_byref_object_dispose__5;
    CFRange v59 = 0LL;
    string = xpc_dictionary_get_string(a2, "CFPreferencesCloudConfig");
    uint64_t v26 = xpc_dictionary_get_value(a2, "CFPreferencesCloudStoreIdentifier");
    char v27 = v26;
    if (v26)
    {
      if (object_getClass(v26) != (Class)MEMORY[0x1895F92E8])
      {
        uint64_t v28 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          CFIndex v29 = _CFPrefsPIDForMessage(a2);
          -[CFPrefsDaemon handleSourceMessage:replyHandler:].cold.3(buf, v29, v28);
        }

        goto LABEL_62;
      }

      if (string)
      {
        xpc_retain(v27);
LABEL_42:
        unsigned int v30 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string, 0x8000100u);
        if (v24) {
          goto LABEL_47;
        }
        *(void *)buf = 0LL;
        uint64_t v68 = buf;
        double v69 = 0x2020000000LL;
        int64_t v70 = 0;
        CFIndex v31 = xpc_dictionary_get_remote_connection(a2);
        if (!v31)
        {
          SInt32 v32 = (_xpc_connection_s *)xpc_dictionary_get_value(a2, "connection");
          CFIndex v31 = v32;
          if (!v32 || object_getClass(v32) != (Class)MEMORY[0x1895F9238]) {
            __assert_rtn( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  393,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
          }
        }

        *(void *)&CFRange v62 = MEMORY[0x1895F87A8];
        *((void *)&v62 + 1) = 3221225472LL;
        *(void *)&CFErrorRef v63 = ___CFPrefsBooleanEntitlementValueForMessage_block_invoke;
        *((void *)&v63 + 1) = &unk_1899EE038;
        uint64_t v64 = (_xpc_connection_s *)a2;
        uint64_t v65 = buf;
        uint64_t v66 = "com.apple.private.trust-defaults-kvstore-identifier";
        withClientContext(v31, (uint64_t)&v62);
        CFAllocatorRef v33 = v68[24];
        _Block_object_dispose(buf, 8);
        if (v33)
        {
LABEL_47:
          p_length[5] = (size_t)v27;
        }

        else if (v13)
        {
          int v43 = (void *)_CFPrefsCopyEntitlementForMessage( a2,  (uint64_t)"com.apple.developer.ubiquity-kvstore-identifier");
          CFErrorRef v44 = v43;
          if (v43)
          {
            if (object_getClass(v43) == (Class)MEMORY[0x1895F92E8] && xpc_equal(v27, v44)) {
              p_length[5] = (size_t)v27;
            }
            xpc_release(v44);
          }
        }

        if (!p_length[5])
        {
          BOOL v34 = (void *)_CFPrefsCopyEntitlementForMessage(a2, (uint64_t)"com.apple.private.ubiquity-kvstore-access");
          int v35 = v34;
          if (v34)
          {
            if (object_getClass(v34) == (Class)MEMORY[0x1895F9220])
            {
              applier[0] = MEMORY[0x1895F87A8];
              applier[1] = 3221225472LL;
              applier[2] = __50__CFPrefsDaemon_handleSourceMessage_replyHandler___block_invoke_67;
              applier[3] = &unk_1899EDCF0;
              applier[4] = v27;
              applier[5] = &length;
              xpc_array_apply(v35, applier);
            }

            xpc_release(v35);
          }
        }

        if (!p_length[5])
        {
          uint64_t v36 = (void *)_CFPrefsCopyEntitlementForMessage( a2,  (uint64_t)"com.apple.private.ubiquity-additional-kvstore-identifiers");
          int v37 = v36;
          if (v36)
          {
            if (object_getClass(v36) == (Class)MEMORY[0x1895F9220])
            {
              v52[0] = MEMORY[0x1895F87A8];
              v52[1] = 3221225472LL;
              v52[2] = __50__CFPrefsDaemon_handleSourceMessage_replyHandler___block_invoke_2;
              v52[3] = &unk_1899EDCF0;
              v52[4] = v27;
              v52[5] = &length;
              xpc_array_apply(v37, v52);
            }

            xpc_release(v37);
          }
        }

        int v38 = (void *)p_length[5];
        if (v38) {
          xpc_retain(v38);
        }
        if (v27) {
          xpc_release(v27);
        }
LABEL_63:
        CFTypeRef v39 = v48 ^ 1;
        if (HIBYTE(v61)) {
          CFTypeRef v39 = 1;
        }
        if ((v39 & 1) != 0 || CFStringHasPrefix(theString, @"/private/var/containers/Shared/SystemGroup/"))
        {
          int v40 = p_length[5];
          if (!string || v40)
          {
            *(void *)&CFRange v62 = 0LL;
            *((void *)&v62 + 1) = &v62;
            *(void *)&CFErrorRef v63 = 0x2020000000LL;
            BYTE8(v63) = 0;
            v50[5] = &v62;
            v51[0] = MEMORY[0x1895F87A8];
            v51[1] = 3221225472LL;
            v51[2] = __50__CFPrefsDaemon_handleSourceMessage_replyHandler___block_invoke_3;
            v51[3] = &unk_1899EDD18;
            v51[6] = a3;
            v51[7] = &v62;
            v51[4] = a2;
            v51[5] = a1;
            v50[0] = MEMORY[0x1895F87A8];
            v50[1] = 3221225472LL;
            _BYTE v50[2] = __50__CFPrefsDaemon_handleSourceMessage_replyHandler___block_invoke_4;
            v50[3] = &unk_1899EDD40;
            v50[4] = a2;
            -[CFPrefsDaemon withSourceForDomain:inContainer:user:byHost:managed:managedUsesContainer:cloudStoreEntitlement:cloudConfigurationPath:performWithSourceLock:afterReleasingSourceLock:]( a1,  FixedUpDomainForMessage,  theString,  v6,  v46,  v47,  v45,  v40,  v30,  (uint64_t)v51,  (uint64_t)v50);
            _Block_object_dispose(&v62, 8);
LABEL_73:
            char v42 = (void *)p_length[5];
            if (v42) {
              xpc_release(v42);
            }
            if (v48) {
              CFRelease(theString);
            }
            if (v30) {
              CFRelease(v30);
            }
            if (v6) {
              CFRelease(v6);
            }
            _Block_object_dispose(&length, 8);
            return;
          }

          ErrorReply = createErrorReply( "'com.apple.developer.ubiquity-kvstore-identifier' entitlement needed to use cloud preferences",  a2);
          (*(void (**)(uint64_t, xpc_object_t))(a3 + 16))(a3, ErrorReply);
        }

        else
        {
          ErrorReply = createErrorReply( "Using kCFPreferencesAnyUser with a container is only allowed for System Containers",  a2);
          (*(void (**)(uint64_t, xpc_object_t))(a3 + 16))(a3, ErrorReply);
        }

        xpc_release(ErrorReply);
        xpc_release(a2);
        goto LABEL_73;
      }
    }

    else if (string)
    {
      char v27 = xpc_string_create(v60);
      goto LABEL_42;
    }

CFPropertyListRef CFPropertyListCreateWithData( CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  v6[1] = *MEMORY[0x1895F89C0];
  v6[0] = 0LL;
  _CFPropertyListCreateWithData((__objc2_class **)allocator, data, options, error, 1, format, 0LL, v6);
  return (CFPropertyListRef)v6[0];
}

CFSetRef _CFPropertyListCopyTopLevelKeys( __objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4)
{
  cf[4] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    unint64_t Length = CFDataGetLength(theData);
    if (Length >= 8)
    {
      int v10 = Length;
      if (__CFDataGetBinaryPlistTopLevelInfo(theData, &v19, &v18, (uint64_t)cf))
      {
        CFSetRef v11 = __CFBinaryPlistCopyTopLevelKeys(a1, BytePtr, v10, v18, (uint64_t)cf);
        if (!a4) {
          return v11;
        }
        goto LABEL_19;
      }
    }

    cf[0] = 0LL;
    _CFPropertyListCreateWithData(a1, theData, a3, a4, 1, 0LL, 0LL, cf);
    int v12 = (const __CFDictionary *)cf[0];
    if (cf[0])
    {
      if (CFGetTypeID(cf[0]) == 18)
      {
        CFIndex Count = CFDictionaryGetCount(v12);
        uint64_t v14 = (const void **)malloc(8 * Count);
        if (v14)
        {
          int v15 = v14;
          CFDictionaryGetKeysAndValues(v12, v14, 0LL);
          CFSetRef v11 = CFSetCreate((CFAllocatorRef)a1, v15, Count, &kCFTypeSetCallBacks);
          free(v15);
          goto LABEL_18;
        }

        if (a4)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to convert string to correct encoding");
          goto LABEL_16;
        }
      }

      else if (a4)
      {
        CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Cannot copy top-level keys for plist with non-dictionary root object");
LABEL_16:
        CFSetRef v11 = 0LL;
        *a4 = Error;
        goto LABEL_18;
      }

      CFSetRef v11 = 0LL;
LABEL_18:
      CFRelease(v12);
      if (!a4) {
        return v11;
      }
      goto LABEL_19;
    }
  }

  CFSetRef v11 = 0LL;
  if (!a4) {
    return v11;
  }
LABEL_19:
  if (!v11) {
    *a4 = __CFPropertyListCreateError(3840LL, @"Unable to extract top-level keys");
  }
  return v11;
}

uint64_t _CFPropertyListCreateFromXMLData( __objc2_class **a1, const __CFData *a2, unsigned int a3, CFStringRef *a4, char a5, void *a6)
{
  v11[1] = *MEMORY[0x1895F89C0];
  v11[0] = 0LL;
  if (a4) {
    *a4 = 0LL;
  }
  CFTypeRef cf = 0LL;
  int v7 = _CFPropertyListCreateWithData(a1, a2, a3, (CFErrorRef *)&cf, a5, a6, 0LL, v11);
  CFTypeRef v8 = cf;
  if (a4 && !v7 && cf)
  {
    *a4 = __copyErrorDebugDescription((__CFError *)cf);
    CFTypeRef v8 = cf;
  }

  if (v8) {
    CFRelease(v8);
  }
  return v11[0];
}

CFStringRef __copyErrorDebugDescription(__CFError *a1)
{
  CFIndex v1 = CFErrorCopyUserInfo(a1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  int Value = (const __CFString *)CFDictionaryGetValue(v1, @"NSDebugDescription");
  if (Value) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
  }
  else {
    CFStringRef Copy = 0LL;
  }
  CFRelease(v2);
  return Copy;
}

CFPropertyListRef CFPropertyListCreateFromXMLData( CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  v9[1] = *MEMORY[0x1895F89C0];
  if (errorString) {
    *errorString = 0LL;
  }
  CFTypeRef cf = 0LL;
  v9[0] = 0LL;
  _CFPropertyListCreateWithData( (__objc2_class **)allocator,  xmlData,  mutabilityOption,  (CFErrorRef *)&cf,  1,  0LL,  0LL,  v9);
  CFTypeRef v5 = cf;
  uint64_t v6 = (const void *)v9[0];
  if (errorString && cf)
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf);
    CFTypeRef v5 = cf;
  }

  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

CFDataRef CFPropertyListCreateData( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (format == kCFPropertyListBinaryFormat_v1_0)
  {
    CFDictionaryRef v13 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)&__kCFAllocatorSystemDefault, allocator);
    CFWriteStreamOpen(v13);
    if (CFPropertyListWrite(propertyList, v13, kCFPropertyListBinaryFormat_v1_0, options, error) < 1) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = (const __CFData *)CFWriteStreamCopyProperty(v13, @"kCFStreamPropertyDataWritten");
    }
    CFWriteStreamClose(v13);
    CFRelease(v13);
  }

  else
  {
    if (format != kCFPropertyListXMLFormat_v1_0)
    {
      if (format == kCFPropertyListOpenStepFormat) {
        CFSetRef v11 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
      }
      else {
        CFSetRef v11 = @"Unknown format option";
      }
      CFLog(3LL, (uint64_t)v11, format, options, (uint64_t)error, v5, v6, v7, v16);
      return 0LL;
    }

    CFTypeRef cf = 0LL;
    v18[0] = 1;
    uint64_t v19 = 100LL;
    uint64_t v20 = 0LL;
    p_CFTypeRef cf = &cf;
    uint64_t v22 = 0LL;
    if (!__CFPropertyListIsValidAux(propertyList, v18))
    {
      if (error) {
        *error = __CFPropertyListCreateError(3851LL, @"Property list invalid for format: %ld (%@)", 100LL, cf);
      }
      if (cf) {
        CFRelease(cf);
      }
      return 0LL;
    }

    return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 0);
  }

  return v14;
}

CFIndex CFPropertyListWrite( CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  v32[0] = 1;
  CFPropertyListFormat v33 = format;
  uint64_t v34 = 0LL;
  p_CFTypeRef cf = &cf;
  uint64_t v36 = 0LL;
  if (!__CFPropertyListIsValidAux(propertyList, v32))
  {
    if (error) {
      *error = __CFPropertyListCreateError(3851LL, @"Property list invalid for format: %ld (%@)", format, cf);
    }
    CFTypeRef v17 = cf;
    if (!cf) {
      return 0LL;
    }
    goto LABEL_9;
  }

  if (format == kCFPropertyListBinaryFormat_v1_0) {
    return __CFBinaryPlistWrite(propertyList, stream, 0LL, options, error);
  }
  if (format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat) {
      uint64_t v16 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
    }
    else {
      uint64_t v16 = @"Unknown format option";
    }
    goto LABEL_21;
  }

  XMLCFDataRef Data = _CFPropertyListCreateXMLData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const __CFString *)propertyList,  1);
  if (!XMLData)
  {
    uint64_t v16 = @"Property list format kCFPropertyListXMLFormat_v1_0 specified but was not a valid property list type";
LABEL_21:
    CFLog(3LL, (uint64_t)v16, v10, v11, v12, v13, v14, v15, v30);
    return 0LL;
  }

  uint64_t v20 = XMLData;
  uint64_t Length = CFDataGetLength(XMLData);
  BytePtr = CFDataGetBytePtr(v20);
  if (Length >= 1)
  {
    uint64_t v23 = BytePtr;
    while (1)
    {
      CFIndex v24 = CFWriteStreamWrite(stream, v23, Length);
      if (!v24) {
        break;
      }
      if (v24 < 0)
      {
        CFErrorRef v27 = CFWriteStreamCopyError(stream);
        if (v27)
        {
          CFErrorRef v28 = v27;
          if (error)
          {
            CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue( Mutable,  @"NSDebugDescription",  @"Property list writing could not be completed because the stream had an unknown error.");
            CFDictionarySetValue(Mutable, @"NSUnderlyingError", v28);
            *error = CFErrorCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"NSCocoaErrorDomain",  3851LL,  Mutable);
            CFRelease(Mutable);
          }

          CFRelease(v28);
        }

        goto LABEL_30;
      }

      v23 += v24;
      BOOL v25 = Length <= v24;
      Length -= v24;
      if (v25) {
        goto LABEL_18;
      }
    }

    if (error) {
      *error = __CFPropertyListCreateError( 3851LL,  @"Property list writing could not be completed because stream is full.");
    }
LABEL_30:
    CFTypeRef v17 = v20;
LABEL_9:
    CFRelease(v17);
    return 0LL;
  }

CFIndex CFPropertyListWriteToStream( CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFStringRef *errorString)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (errorString) {
    *errorString = 0LL;
  }
  cf[0] = 0LL;
  if (format != kCFPropertyListBinaryFormat_v1_0 && format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat)
    {
      if (errorString)
      {
        uint64_t v5 = @"Property list format kCFPropertyListOpenStepFormat not supported for writing";
LABEL_15:
        CFIndex v6 = 0LL;
        *errorString = (CFStringRef)CFRetain(v5);
        return v6;
      }
    }

    else if (errorString)
    {
      uint64_t v5 = @"Unknown format option";
      goto LABEL_15;
    }

    return 0LL;
  }

  CFIndex v6 = CFPropertyListWrite(propertyList, stream, format, 0LL, (CFErrorRef *)cf);
  CFTypeRef v7 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    CFTypeRef v7 = cf[0];
  }

  if (v7) {
    CFRelease(v7);
  }
  return v6;
}

CFPropertyListRef CFPropertyListCreateWithStream( CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  uint64_t v6 = MEMORY[0x1895F8858](allocator, stream);
  uint64_t v9 = v8;
  unsigned int v30 = v10;
  CFIndex v31 = v11;
  uint64_t v13 = v12;
  CFIndex v29 = (__objc2_class **)v6;
  int v14 = 0;
  int v15 = 0;
  uint64_t v16 = 0LL;
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (v7) {
    uint64_t v17 = v7;
  }
  else {
    uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  }
  do
  {
    if (v17 >= 0x2000) {
      CFIndex v18 = 0x2000LL;
    }
    else {
      CFIndex v18 = v17;
    }
    int v19 = CFReadStreamRead(v13, buffer, v18);
    unsigned int v20 = v19;
    if (v19 <= 0)
    {
      if (!v19)
      {
        int v21 = v14;
        if (!v16) {
          goto LABEL_38;
        }
        goto LABEL_36;
      }

      CFErrorRef v24 = CFReadStreamCopyError(v13);
      if (!v9) {
        goto LABEL_32;
      }
      goto LABEL_27;
    }

    int v21 = v14 + v19;
    if (__OFADD__(v14, v19)) {
      goto LABEL_23;
    }
    if (v15 < v21)
    {
      if (v15 < 0x40000)
      {
        int v22 = 4 * v15;
LABEL_15:
        if (v22 <= v21) {
          int v15 = v14 + v19;
        }
        else {
          int v15 = v22;
        }
        uint64_t v23 = (char *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v16,  v15,  0LL,  0LL);
        if (!v23) {
          __break(1u);
        }
        uint64_t v16 = v23;
        goto LABEL_20;
      }

      if (!HIBYTE(v15))
      {
        int v22 = 2 * v15;
        goto LABEL_15;
      }

      int v22 = v15 + 0x40000;
      if (!__OFADD__(v15, 0x40000)) {
        goto LABEL_15;
      }
LABEL_23:
      CFErrorRef v24 = __CFPropertyListCreateError(3840LL, @"Stream too large");
      uint64_t v16 = 0LL;
      if (!v9)
      {
LABEL_32:
        if (v24) {
          CFRelease(v24);
        }
        return 0LL;
      }

CFPropertyListRef CFPropertyListCreateFromStream( CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags mutabilityOption, CFPropertyListFormat *format, CFStringRef *errorString)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (errorString) {
    *errorString = 0LL;
  }
  cf[0] = 0LL;
  CFPropertyListRef v7 = CFPropertyListCreateWithStream(allocator, stream, streamLength, mutabilityOption, format, (CFErrorRef *)cf);
  CFTypeRef v8 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    CFTypeRef v8 = cf[0];
  }

  if (v8) {
    CFRelease(v8);
  }
  return v7;
}

uint64_t _CFPropertyListValidateData(const __CFData *a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t Length = CFDataGetLength(a1);
  if (Length >= 8
    && (int v6 = Length, __CFDataGetBinaryPlistTopLevelInfo(a1, &v10, (unint64_t *)v9, (uint64_t)v12)))
  {
    CFTypeRef cf = 0LL;
    uint64_t result = __CFBinaryPlistCreateObjectFiltered( BytePtr,  v6,  *(unint64_t *)v9,  (uint64_t)v12,  &__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  (CFTypeID *)&cf);
    if (a2) {
      *a2 = cf;
    }
  }

  else
  {
    CFTypeRef cf = 0LL;
    _CFPropertyListCreateWithData(&__kCFAllocatorSystemDefault, a1, 1u, 0LL, 1, 0LL, 0LL, &cf);
    CFTypeRef v8 = cf;
    if (cf)
    {
      if (a2) {
        *a2 = CFGetTypeID(cf);
      }
      CFRelease(v8);
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFPropertyListRef CFPropertyListCreateDeepCopy( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  valuePtr[0] = 1LL;
  __int128 v32 = 0u;
  uint64_t v33 = 0LL;
  valuePtr[1] = 200LL;
  CFMutableArrayRef Mutable = 0LL;
  if (__CFPropertyListIsValidAux(propertyList, valuePtr))
  {
    if (((unint64_t)propertyList & 0x8000000000000000LL) == 0 || mutabilityOption == 2)
    {
      CFTypeID v7 = CFGetTypeID(propertyList);
      switch(v7)
      {
        case 0x12uLL:
          unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)propertyList);
          if (!Count)
          {
            if (mutabilityOption) {
              return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            }
            else {
              return CFDictionaryCreate( allocator,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            }
          }

          CFIndex v10 = Count;
          if (((Count >> 59) & 0xF) != 0) {
            CFPropertyListCreateDeepCopy_cold_1();
          }
          unint64_t v11 = 2 * Count;
          MEMORY[0x1895F8858](Count, v9);
          uint64_t v13 = (const void **)((char *)valuePtr - v12);
          if (v11 > 0x100)
          {
            uint64_t v13 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 16 * v10, 0LL);
            if (!v13) {
              CFPropertyListCreateDeepCopy_cold_2();
            }
          }

          else
          {
            bzero((char *)valuePtr - v12, 16 * v10);
          }

          int v22 = &v13[v10];
          CFDictionaryGetKeysAndValues((CFDictionaryRef)propertyList, v13, v22);
          if (v10 < 1) {
            goto LABEL_52;
          }
          uint64_t v23 = 0LL;
          break;
        case 0x13uLL:
          if (!mutabilityOption) {
            return _arrayDeepImmutableCopy(allocator, (CFArrayRef)propertyList);
          }
          CFIndex v16 = CFArrayGetCount((CFArrayRef)propertyList);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0LL, &kCFTypeArrayCallBacks);
          if (!Mutable) {
            return Mutable;
          }
          if (v16 < 1)
          {
            CFIndex v17 = 0LL;
          }

          else
          {
            CFIndex v17 = 0LL;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)propertyList, v17);
              DeepCFStringRef Copy = CFPropertyListCreateDeepCopy(allocator, ValueAtIndex, mutabilityOption);
              if (!DeepCopy) {
                break;
              }
              unsigned int v20 = DeepCopy;
              CFArrayAppendValue(Mutable, DeepCopy);
              CFRelease(v20);
              if (v16 == ++v17) {
                return Mutable;
              }
            }
          }

          if (v17 == v16) {
            return Mutable;
          }
          CFRelease(Mutable);
          return 0LL;
        case 0x14uLL:
          if (mutabilityOption == 2) {
            return CFDataCreateMutableCopy(allocator, 0LL, (CFDataRef)propertyList);
          }
          else {
            return CFDataCreateCopy(allocator, (CFDataRef)propertyList);
          }
        case 0x15uLL:
          CFRetain(propertyList);
          return propertyList;
        case 0x16uLL:
          CFNumberType Type2 = _CFNumberGetType2((unint64_t *)propertyList);
          CFNumberGetValue((CFNumberRef)propertyList, Type2, valuePtr);
          return CFNumberCreate(allocator, Type2, valuePtr);
        default:
          if (v7 == 7)
          {
            if (mutabilityOption == 2) {
              return CFStringCreateMutableCopy(allocator, 0LL, (CFStringRef)propertyList);
            }
            else {
              return CFStringCreateCopy(allocator, (CFStringRef)propertyList);
            }
          }

          else
          {
            if (v7 != 42) {
              return 0LL;
            }
            CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)propertyList);
            return CFDateCreate(allocator, AbsoluteTime);
          }
      }

      while (1)
      {
        CFStringRef Copy = CFStringCreateCopy(allocator, (CFStringRef)v13[v23]);
        if (!Copy) {
          break;
        }
        v13[v23] = Copy;
        CFPropertyListRef v25 = CFPropertyListCreateDeepCopy(allocator, v22[v23], mutabilityOption);
        if (!v25)
        {
          CFRelease(v13[v23]);
          break;
        }

        v22[v23++] = v25;
        if (v10 == v23) {
          goto LABEL_47;
        }
      }

      if (v10 == v23)
      {
LABEL_47:
        if (mutabilityOption) {
          CFMutableDictionaryRef v27 = CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        else {
          CFMutableDictionaryRef v27 = CFDictionaryCreate( allocator,  v13,  &v13[v10],  v10,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        CFMutableArrayRef Mutable = v27;
        CFIndex v29 = v13;
        CFIndex v30 = v10;
        do
        {
          if (mutabilityOption) {
            CFDictionarySetValue(Mutable, *v29, v29[v10]);
          }
          CFRelease(*v29);
          CFRelease(v29[v10]);
          ++v29;
          --v30;
        }

        while (v30);
        goto LABEL_58;
      }

      if (v23)
      {
        for (uint64_t i = 0LL; i != v23; ++i)
        {
          CFRelease(v13[i]);
          CFRelease(v22[i]);
        }
      }

LABEL_52:
      CFMutableArrayRef Mutable = 0LL;
LABEL_58:
      if (v11 >= 0x101) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
      }
    }

    else
    {
      return propertyList;
    }
  }

  return Mutable;
}

      uint64_t v33 = 1;
      goto LABEL_53;
    }

    if (Length < 3)
    {
      if (Length != 2) {
        goto LABEL_52;
      }
    }

    else if (CFStringGetCharacterAtIndex(v12, 0LL) == 92 && CFStringGetCharacterAtIndex(v12, 1LL) == 92)
    {
      goto LABEL_58;
    }

    uint64_t v33 = 1;
    if (CFStringGetCharacterAtIndex(v12, 1LL) == 58) {
      goto LABEL_58;
    }
    goto LABEL_53;
  }

  return v8;
}

  CFErrorRef v44 = CFStringGetLength(v41);
  v145.CFIndex location = 0LL;
  v145.CFIndex length = v44;
  uint64_t v45 = 0LL;
  if (CFStringFindWithOptions(v41, @"charset=", v145, 1uLL, (CFRange *)&v129))
  {
    CFStringEncoding v46 = (const __CFAllocator *)v123;
    if (*((void *)&v129 + 1))
    {
      CFStringEncoding v47 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      uint64_t v48 = *((void *)&v129 + 1) + v129;
      if (*((void *)&v129 + 1) + (void)v129 >= v44)
      {
        uint64_t v45 = 0LL;
        unint64_t v41 = Copy;
      }

      else
      {
        CFRange v49 = v47;
        v125 = v40;
        char v50 = a3;
        CFTypeRef v51 = -1LL;
        int v52 = -1LL;
        do
        {
          UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(Copy, v48);
          if (CharacterAtIndex == 44 || CharacterAtIndex == 59) {
            break;
          }
          if (CFCharacterSetIsCharacterMember(v49, CharacterAtIndex))
          {
            CFRange v54 = -1LL;
          }

          else
          {
            int v52 = v48;
            CFRange v54 = v48;
          }

          if (v51 == -1) {
            CFTypeRef v51 = v54;
          }
          ++v48;
        }

        while (v48 < v44);
        if (v51 == -1)
        {
          uint64_t v45 = 0LL;
          a3 = v50;
          CFStringEncoding v46 = (const __CFAllocator *)v123;
          unint64_t v41 = Copy;
        }

        else
        {
          unint64_t v41 = Copy;
          CFRange v55 = CFGetAllocator(Copy);
          CFRange v56 = CFStringCreateMutableCopy(v55, v44, Copy);
          uint64_t v45 = v56;
          if (v52 != v44)
          {
            v142.CFIndex location = v52 + 1;
            v142.CFIndex length = v44 + ~v52;
            CFStringDelete(v56, v142);
          }

          v143.CFIndex location = 0LL;
          v143.CFIndex length = v51;
          CFStringDelete(v45, v143);
          CFStringLowercase(v45, 0LL);
          a3 = v50;
          CFStringEncoding v46 = (const __CFAllocator *)v123;
        }

        int v40 = v125;
      }
    }
  }

  else
  {
    CFStringEncoding v46 = (const __CFAllocator *)v123;
  }

  v124 = v45;
  CFRange v57 = CFStringFind(v41, @";base64", 1uLL).location;
  if (!v40) {
    int v40 = (__CFString *)CFRetain(@"text/plain");
  }
  v125 = v40;
  CFRange v58 = CFURLGetBytes((CFURLRef)cf, 0LL, 0LL);
  CFRange v59 = (UInt8 *)malloc(v58);
  CFURLGetBytes((CFURLRef)cf, v59, v58);
  CFRange v62 = CFURLGetByteRangeForComponent((CFURLRef)cf, kCFURLComponentResourceSpecifier, 0LL);
  CFRange v61 = v62.length;
  CFRange v60 = v62.location;
  if (v59[v62.location] == 44)
  {
    CFErrorRef v63 = v62.location;
    int v6 = v122;
  }

  else
  {
    int v6 = v122;
    do
    {
      CFErrorRef v63 = v60 + 1;
      --v61;
      uint64_t v64 = v59[++v60];
    }

    while (v64 != 44);
  }

  uint64_t v65 = v63 + 1;
  uint64_t v66 = v61 - 1;
  if (v57 == -1)
  {
    unint64_t v72 = percentEscapeDecodeBuffer(v46, (uint64_t)v59, v65, v66, 0);
    if (v72) {
      goto LABEL_181;
    }
    goto LABEL_84;
  }

  uint64_t v67 = 1;
  uint64_t v68 = percentEscapeDecodeBuffer(v46, (uint64_t)v59, v65, v66, 1);
  if (!v68)
  {
    unint64_t v72 = 0LL;
    CFStringRef Copy = 0LL;
    v123 = 0LL;
    goto LABEL_188;
  }

  double v69 = (const __CFString *)v68;
  BytePtr = CFDataGetBytePtr(v68);
  CFStringRef Copy = v69;
  v71 = CFDataGetLength((CFDataRef)v69);
  if ((v71 & 3) == 0)
  {
    if (v71 < 1025)
    {
      if (v71 <= 0)
      {
        unint64_t v72 = CFDataCreate(v46, (const UInt8 *)&v129, 0LL);
        goto LABEL_180;
      }

      CFTypeRef v73 = (CFRange *)&v129;
    }

    else
    {
      v74 = a4;
      int v75 = a5;
      v76 = v71;
      CFTypeRef v73 = (CFRange *)malloc(v71);
      v71 = v76;
      a5 = v75;
      a4 = v74;
      CFStringEncoding v46 = (const __CFAllocator *)v123;
    }

    v77 = 0LL;
    char v78 = 0LL;
    while (1)
    {
      v79 = BytePtr[v78];
      if (((v79 & 0xDF) - 65) >= 0x1Au
        && (v79 != 43 ? (char v80 = (v79 - 47) > 0xAu) : (char v80 = 0), v80)
        || (v81 = BytePtr[v78 + 1], ((v81 & 0xDF) - 65) >= 0x1Au)
        && (v81 != 43 ? (v82 = (v81 - 47) > 0xAu) : (v82 = 0), v82)
        || ((v83 = BytePtr[v78 + 2], (v83 - 47) >= 0xBu)
          ? (v84 = ((v83 & 0xDF) - 65) >= 0x1Au)
          : (v84 = 0),
            v84 && BytePtr[v78 + 2] != 61 && BytePtr[v78 + 2] != 43
         || (v85 = BytePtr[v78 + 3], (v85 - 47) >= 0xBu)
         && ((v85 & 0xDF) - 65) >= 0x1Au
         && BytePtr[v78 + 3] != 43
         && BytePtr[v78 + 3] != 61))
      {
        if (v73 != (CFRange *)&v129) {
          free(v73);
        }
        unint64_t v72 = 0LL;
        goto LABEL_180;
      }

      v86 = v79 - 65;
      if ((v79 - 65) >= 0x1A)
      {
        if ((v79 - 97) > 0x19)
        {
          if ((v79 - 48) > 9)
          {
            if (v79 == 47) {
              v86 = 63;
            }
            else {
              v86 = 0;
            }
            if (v79 == 43) {
              v86 = 62;
            }
          }

          else
          {
            v86 = v79 + 4;
          }
        }

        else
        {
          v86 = v79 - 71;
        }
      }

      v87 = 4 * v86;
      v88 = v81 - 65;
      if ((v81 - 48) <= 9)
      {
        v88 = v81 + 4;
LABEL_127:
        v89 = v87 | ((v88 & 0xF0) >> 4);
        v90 = v77 + 1;
        *((_BYTE *)&v73->location + v77) = v89;
        if (v83 != 61) {
          goto LABEL_128;
        }
        goto LABEL_150;
      }

      if ((v81 & 0xFFFFFFFB) == 0x2B) {
        v92 = 3;
      }
      else {
        v92 = 0;
      }
      v93 = v87 | v92;
      v90 = v77 + 1;
      *((_BYTE *)&v73->location + v77) = v93;
      if (v83 != 61)
      {
        if (v81 == 47) {
          v88 = 63;
        }
        else {
          v88 = 0;
        }
        if (v81 == 43) {
          v88 = 62;
        }
LABEL_128:
        v91 = v83 - 65;
        if ((v83 - 65) >= 0x1Au)
        {
          if ((v83 - 97) > 0x19u)
          {
            if ((v83 - 48) > 9u)
            {
              if (v83 == 47) {
                v94 = 63;
              }
              else {
                v94 = 0;
              }
              if (v83 == 43) {
                v91 = 62;
              }
              else {
                v91 = v94;
              }
            }

            else
            {
              v91 = v83 + 4;
            }
          }

          else
          {
            v91 = v83 - 71;
          }
        }

        *((_BYTE *)&v73->location + v90) = (16 * v88) | ((v91 & 0xFC) >> 2);
        v90 = v77 + 2;
      }

    CFRange v54 = sel_getName(v5);
    if (sel_getUid(v54) != v5) {
      CFLog( 4LL,  (uint64_t)@"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort",  v55,  v56,  v57,  v58,  v59,  v60,  (uint64_t)v5);
    }
    CFRange v61 = object_getClass((id)v4);
    if (class_respondsToSelector(v61, sel_doesNotRecognizeSelector_))
    {
      [(id)v4 doesNotRecognizeSelector:v5];
      __break(1u);
    }

    ___forwarding____cold_3((void *)v4);
  }

  int v15 = (void *)[(id)v4 methodSignatureForSelector:v5];
  if (!v15) {
    goto LABEL_52;
  }
  CFIndex v16 = v15;
  CFIndex v17 = [v15 _frameDescriptor];
  if ((((unint64_t)*(unsigned __int16 *)(*(void *)v17 + 34LL) >> 6) & 1) != a2)
  {
    CFIndex v18 = sel_getName(v5);
    CFLog( 4LL,  (uint64_t)@"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.",  v19,  v20,  v21,  v22,  v23,  v24,  (uint64_t)v18);
  }

  CFPropertyListRef v25 = object_getClass((id)v4);
  uint64_t v26 = class_respondsToSelector(v25, sel__forwardStackInvocation_);
  if (v26)
  {
    objc_opt_self();
    CFMutableDictionaryRef v27 = [v16 frameLength] + 320;
    InstanceSize = class_getInstanceSize((Class)&OBJC_CLASS___NSInvocation);
    CFIndex v29 = &v62[-((MEMORY[0x1895F8858](InstanceSize, InstanceSize) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    bzero(v29, v30);
    MEMORY[0x1895F8858](v31, v32);
    uint64_t v34 = &v62[-v33];
    objc_constructInstance((Class)&OBJC_CLASS___NSInvocation, v29);
    -[NSInvocation _initWithMethodSignature:frame:buffer:size:]((uint64_t)v29, v16, v3, v34, v27);
    [(id)v4 _forwardStackInvocation:v29];
  }

  else
  {
    int v35 = object_getClass((id)v4);
    if (!class_respondsToSelector(v35, sel_forwardInvocation_)) {
      ___forwarding____cold_4(v62, (id)v4);
    }
    CFIndex v29 = +[NSInvocation _invocationWithMethodSignature:frame:]( &OBJC_CLASS___NSInvocation,  "_invocationWithMethodSignature:frame:",  v16,  v3);
    [(id)v4 forwardInvocation:v29];
    CFMutableDictionaryRef v27 = 0LL;
  }

  if (v29[52] && (*(_WORD *)(*(void *)v17 + 34LL) & 0x80) != 0)
  {
    uint64_t v36 = *(void *)v17;
    memmove( *(void **)((char *)v3->n128_u64 + *(unsigned int *)(v36 + 28) + *(unsigned __int8 *)(v36 + 32)),  *(const void **)(*((void *)v29 + 1) + *(unsigned int *)(v36 + 28) + *(unsigned __int8 *)(v36 + 32)),  *(unsigned int *)(*(void *)v36 + 16LL));
  }

  uint64_t v37 = (unsigned __int8 *)[v16 methodReturnType];
  int v38 = *v37;
  if (v38 == 118 || v38 == 86 && v37[1] == 118)
  {
    if (v26) {

    }
    return (__n128 *)&___forwarding____placeholder;
  }

  else
  {
    CFStringRef v3 = (__n128 *)*((void *)v29 + 2);
    if (v26)
    {
      CFStringRef v3 = -[NSData bytes]( +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", *((void *)v29 + 2), v27),  "bytes");
    }
  }

  return v3;
}

CFArrayRef _arrayDeepImmutableCopy(const __CFAllocator *a1, CFArrayRef theArray)
{
  v15[1] = *MEMORY[0x1895F89C0];
  unint64_t Count = CFArrayGetCount(theArray);
  if (!Count) {
    return CFArrayCreate(a1, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  unint64_t v6 = Count;
  if (Count >> 60) {
    _arrayDeepImmutableCopy_cold_1();
  }
  MEMORY[0x1895F8858](Count, v5);
  CFTypeRef v8 = (const void **)((char *)v15 - v7);
  if (v6 > 0x100)
  {
    CFTypeRef v8 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v6, 0LL);
    if (!v8) {
      _arrayDeepImmutableCopy_cold_2();
    }
  }

  else
  {
    bzero((char *)v15 - v7, 8 * v6);
  }

  v16.CFIndex location = 0LL;
  v16.CFIndex length = v6;
  CFArrayGetValues(theArray, v16, v8);
  unint64_t v10 = 0LL;
  while (1)
  {
    DeepCFStringRef Copy = CFPropertyListCreateDeepCopy(a1, v8[v10], 0LL);
    if (!DeepCopy) {
      break;
    }
    v8[v10++] = DeepCopy;
    if (v6 == v10)
    {
      unint64_t v10 = v6;
      goto LABEL_12;
    }
  }

  if (v6 == v10)
  {
LABEL_12:
    CFArrayRef v12 = CFArrayCreate(a1, v8, v6, &kCFTypeArrayCallBacks);
    if (!v10) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }

  CFArrayRef v12 = 0LL;
  if (!v10) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v13 = v8;
  do
  {
    int v14 = *v13++;
    CFRelease(v14);
    --v10;
  }

  while (v10);
LABEL_17:
  if (v6 >= 0x101) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
  }
  return v12;
}

void _plistAppendCharacters(CFMutableDataRef theData, _WORD *a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unint64_t v7 = a3 - 1;
  CFTypeRef v8 = a2 + 1;
  while (1)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    if (a3 >= 1 && v6 >= -399)
    {
      unint64_t v11 = v6 + 399;
      if (v7 < v6 + 399) {
        unint64_t v11 = v7;
      }
      if ((unsigned __int16)*a2 > 0x7Fu)
      {
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
      }

      else
      {
        uint64_t v9 = 0LL;
        UInt8 v12 = *a2;
        while (1)
        {
          uint64_t v13 = v9;
          bytes[v9] = v12;
          if (v11 == v9) {
            break;
          }
          unsigned int v14 = (unsigned __int16)v8[v9];
          UInt8 v12 = v8[v9++];
          if (v14 > 0x7F) {
            goto LABEL_13;
          }
        }

        uint64_t v9 = v11 + 1;
LABEL_13:
        uint64_t v10 = v13 + 1;
      }
    }

    if (v9 > v6)
    {
      CFDataAppendBytes(theData, bytes, v10 - v6);
      uint64_t v6 = v9;
    }

    if (a3 <= v6) {
      break;
    }
    if ((unsigned __int16)a2[v6] >= 0x80u)
    {
      int v15 = CFStringCreateWithCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  &a2[v6],  a3 - v6,  (CFAllocatorRef)&__kCFAllocatorNull);
      if (v15)
      {
        CFRange v16 = v15;
        ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v15,  0x8000100u,  0);
        if (ExternalRepresentation)
        {
          CFIndex v18 = ExternalRepresentation;
          BytePtr = CFDataGetBytePtr(ExternalRepresentation);
          CFIndex Length = CFDataGetLength(v18);
          CFDataAppendBytes(theData, BytePtr, Length);
          CFRelease(v18);
        }

        CFRelease(v16);
      }

      return;
    }
  }

void _CFAppendXML0(const __CFString *a1, unsigned int a2, __CFData *a3)
{
  valuePtr[11] = *MEMORY[0x1895F89C0];
  int v6 = CFGetTypeID(a1);
  uint64_t v7 = a2;
  if (a2)
  {
    uint64_t v8 = a2;
    do
    {
      if (v8 >= 4) {
        uint64_t v9 = 4LL;
      }
      else {
        uint64_t v9 = v8;
      }
      _plistAppendCharacters(a3, _appendIndents_tabs, v9);
      BOOL v10 = (unint64_t)v8 > 4;
      v8 -= 4LL;
    }

    while (v10);
  }

  if (v6 == 7)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
    _plistAppendCharacters(a3, L"string", 6LL);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
    _appendEscapedString(a1, a3);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
    unint64_t v11 = a3;
    UInt8 v12 = L"string";
    uint64_t v13 = 6LL;
LABEL_9:
    _plistAppendCharacters(v11, v12, v13);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
    return;
  }

  if (_CFKeyedArchiverUIDGetTypeID() == v6)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
    _plistAppendCharacters(a3, L"dict", 4LL);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
    uint64_t v14 = a2 + 1;
    if (a2 == -1)
    {
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"key", 3LL);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
      _appendEscapedString(@"CF$UID", a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
      _plistAppendCharacters(a3, L"key", 3LL);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
    }

    else
    {
      uint64_t v20 = a2 + 1;
      do
      {
        if (v20 >= 4) {
          uint64_t v21 = 4LL;
        }
        else {
          uint64_t v21 = v20;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v21);
        BOOL v10 = (unint64_t)v20 > 4;
        v20 -= 4LL;
      }

      while (v10);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"key", 3LL);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
      _appendEscapedString(@"CF$UID", a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
      _plistAppendCharacters(a3, L"key", 3LL);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
      do
      {
        if (v14 >= 4) {
          uint64_t v22 = 4LL;
        }
        else {
          uint64_t v22 = v14;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v22);
        BOOL v10 = (unint64_t)v14 > 4;
        v14 -= 4LL;
      }

      while (v10);
    }

    CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
    _plistAppendCharacters(a3, L"integer", 7LL);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
    valuePtr[0] = _CFKeyedArchiverUIDGetValue((uint64_t)a1);
    CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, valuePtr);
    _plistAppendFormat(a3, @"%@", v23);
    CFRelease(v23);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
    _plistAppendCharacters(a3, L"integer", 7LL);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
    if (a2)
    {
      do
      {
        if (v7 >= 4) {
          uint64_t v24 = 4LL;
        }
        else {
          uint64_t v24 = v7;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v24);
        BOOL v10 = (unint64_t)v7 > 4;
        v7 -= 4LL;
      }

      while (v10);
    }

    CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
    CFPropertyListRef v25 = L"dict";
    goto LABEL_34;
  }

  switch(v6)
  {
    case 18:
      unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"dict", 4LL);
      if (!Count) {
        goto LABEL_79;
      }
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
      MEMORY[0x1895F8858](v16, v17);
      int v19 = (const void **)((char *)v71 - v18);
      v71[1] = (CFAllocatorRef)v71;
      if (Count > 0x100)
      {
        CFRange v59 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
        if (!v59) {
          _CFAppendXML0_cold_1();
        }
        int v19 = v59;
      }

      else
      {
        bzero((char *)v71 - v18, 8 * Count);
      }

      CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v19, 0LL);
      v71[0] = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
      v75.CFIndex location = 0LL;
      v75.CFIndex length = 0LL;
      CFArrayReplaceValues(Mutable, v75, v19, Count);
      v76.CFIndex location = 0LL;
      v76.CFIndex length = Count;
      CFArraySortValues(Mutable, v76, (CFComparatorFunction)CFStringCompare, 0LL);
      v77.CFIndex location = 0LL;
      v77.CFIndex length = Count;
      CFTypeRef v73 = v19;
      CFArrayGetValues(Mutable, v77, v19);
      CFRelease(Mutable);
      uint64_t v61 = 0LL;
      unsigned int v72 = a2;
      do
      {
        CFRange v62 = (const __CFString *)v73[v61];
        if (a2 != -1)
        {
          uint64_t v63 = a2 + 1;
          do
          {
            if (v63 >= 4) {
              uint64_t v64 = 4LL;
            }
            else {
              uint64_t v64 = v63;
            }
            _plistAppendCharacters(a3, _appendIndents_tabs, v64);
            BOOL v10 = (unint64_t)v63 > 4;
            v63 -= 4LL;
          }

          while (v10);
        }

        CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
        _plistAppendCharacters(a3, L"key", 3LL);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
        _appendEscapedString(v62, a3);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
        _plistAppendCharacters(a3, L"key", 3LL);
        CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
        int Value = CFDictionaryGetValue((CFDictionaryRef)a1, v62);
        _CFAppendXML0(Value, a2 + 1, a3);
        ++v61;
      }

      while (v61 != Count);
      if (Count >= 0x101) {
        CFAllocatorDeallocate(v71[0], v73);
      }
      if (v72)
      {
        do
        {
          if (v7 >= 4) {
            uint64_t v66 = 4LL;
          }
          else {
            uint64_t v66 = v7;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v66);
          BOOL v10 = (unint64_t)v7 > 4;
          v7 -= 4LL;
        }

        while (v10);
      }

      CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
      _plistAppendCharacters(a3, L"dict", 4LL);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
      return;
    case 19:
      uint64_t v28 = CFArrayGetCount((CFArrayRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"array", 5LL);
      if (!v28) {
        goto LABEL_79;
      }
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
      for (CFIndex i = 0LL; i != v28; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        _CFAppendXML0(ValueAtIndex, a2 + 1, a3);
      }

      if (a2)
      {
        do
        {
          if (v7 >= 4) {
            uint64_t v31 = 4LL;
          }
          else {
            uint64_t v31 = v7;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v31);
          BOOL v10 = (unint64_t)v7 > 4;
          v7 -= 4LL;
        }

        while (v10);
      }

      CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
      UInt8 v12 = L"array";
      unint64_t v11 = a3;
      uint64_t v13 = 5LL;
      goto LABEL_9;
    case 20:
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"data", 4LL);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      CFIndex Length = CFDataGetLength((CFDataRef)a1);
      if (a2 >= 8uLL) {
        uint64_t v34 = 8LL;
      }
      else {
        uint64_t v34 = a2;
      }
      if (Length < 1) {
        goto LABEL_108;
      }
      unint64_t v35 = Length;
      unsigned int v72 = a2;
      uint64_t v36 = 0LL;
      unint64_t v37 = 0LL;
      CFTypeRef v73 = (void *)v34;
      uint64_t v38 = 76 - 8 * v34;
      break;
    case 21:
      int v53 = CFBooleanGetValue((CFBooleanRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      if (v53)
      {
        CFRange v54 = L"true";
        CFRange v55 = a3;
        uint64_t v56 = 4LL;
      }

      else
      {
        CFRange v54 = L"false";
        CFRange v55 = a3;
        uint64_t v56 = 5LL;
      }

      _plistAppendCharacters(v55, v54, v56);
LABEL_79:
      CFDataAppendBytes(a3, (const UInt8 *)"/>\n", 3LL);
      return;
    case 22:
      int IsFloatType = CFNumberIsFloatType((CFNumberRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      if (IsFloatType)
      {
        _plistAppendCharacters(a3, L"real", 4LL);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
        CFRange v58 = __CFNumberCopyFormattingDescriptionAsFloat64((CFNumberRef)a1);
        _plistAppendString(a3, v58);
        CFRelease(v58);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
        unint64_t v11 = a3;
        UInt8 v12 = L"real";
LABEL_76:
        uint64_t v13 = 4LL;
      }

      else
      {
        _plistAppendCharacters(a3, L"integer", 7LL);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
        _plistAppendFormat(a3, @"%@", a1);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
        unint64_t v11 = a3;
        UInt8 v12 = L"integer";
        uint64_t v13 = 7LL;
      }

      goto LABEL_9;
    default:
      if (v6 != 42) {
        return;
      }
      CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
      CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(AbsoluteTime, 0LL);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1LL);
      _plistAppendCharacters(a3, L"date", 4LL);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1LL);
      _plistAppendFormat( a3,  @"%04d-%02d-%02dT%02d:%02d:%02dZ",  *(void *)&GregorianDate.year,  ((int)(*(void *)&GregorianDate.year >> 8) >> 24),  ((int)(*(void *)&GregorianDate.year >> 16) >> 24),  ((int)(*(void *)&GregorianDate.year >> 24) >> 24),  (*(int *)&GregorianDate.month >> 24),  (int)GregorianDate.second);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
      unint64_t v11 = a3;
      UInt8 v12 = L"date";
      goto LABEL_76;
  }

  do
  {
    CFTypeRef v39 = BytePtr;
    unint64_t v40 = v37 % 3;
    if (v37 % 3 == 2)
    {
      int v42 = *BytePtr;
      uint64_t v43 = v36 + 1;
      *((_BYTE *)valuePtr + v36) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[((unint64_t)(v42 | (*(BytePtr - 1) << 8)) >> 6) & 0x3F];
      unint64_t v41 = v42 & 0x3F;
      uint64_t v44 = 2LL;
    }

    else
    {
      if (v40 == 1)
      {
        unint64_t v41 = ((unint64_t)(*BytePtr | (*(BytePtr - 1) << 8)) >> 4) & 0x3F;
      }

      else
      {
        if (v40) {
          goto LABEL_60;
        }
        unint64_t v41 = (unint64_t)*BytePtr >> 2;
      }

      uint64_t v44 = 1LL;
      uint64_t v43 = v36;
    }

    v36 += v44;
    *((_BYTE *)valuePtr + v43) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[v41];
LABEL_60:
    if (v36 >= v38)
    {
      *(_WORD *)((char *)valuePtr + v36) = 10;
      if (v72)
      {
        uint64_t v45 = (uint64_t)v73;
        do
        {
          if (v45 >= 4) {
            uint64_t v46 = 4LL;
          }
          else {
            uint64_t v46 = v45;
          }
          _plistAppendCharacters(a3, _appendIndents_tabs, v46);
          BOOL v10 = (unint64_t)v45 > 4;
          v45 -= 4LL;
        }

        while (v10);
      }

      size_t v47 = strlen((const char *)valuePtr);
      CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v47);
      uint64_t v36 = 0LL;
    }

    ++v37;
    BytePtr = v39 + 1;
  }

  while (v37 != v35);
  if (v35 % 3 == 2)
  {
    char v50 = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[4 * (*v39 & 0xF)];
    uint64_t v51 = 2LL;
    uint64_t v52 = 1LL;
    uint64_t v49 = v36;
    a2 = v72;
    uint64_t v48 = (uint64_t)v73;
LABEL_100:
    uint64_t v67 = v52 + v36;
    *((_BYTE *)valuePtr + v49) = v50;
    v36 += v51;
    *((_BYTE *)valuePtr + v67) = 61;
  }

  else
  {
    a2 = v72;
    uint64_t v48 = (uint64_t)v73;
    if (v35 % 3 == 1)
    {
      uint64_t v49 = v36 + 1;
      *((_BYTE *)valuePtr + v36) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[16 * (*v39 & 3)];
      char v50 = 61;
      uint64_t v51 = 3LL;
      uint64_t v52 = 2LL;
      goto LABEL_100;
    }
  }

  if (v36 >= 1)
  {
    *(_WORD *)((char *)valuePtr + v36) = 10;
    if (a2)
    {
      do
      {
        if (v48 >= 4) {
          uint64_t v68 = 4LL;
        }
        else {
          uint64_t v68 = v48;
        }
        _plistAppendCharacters(a3, _appendIndents_tabs, v68);
        BOOL v10 = (unint64_t)v48 > 4;
        v48 -= 4LL;
      }

      while (v10);
    }

    size_t v69 = strlen((const char *)valuePtr);
    CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v69);
  }

LABEL_108:
  if (a2)
  {
    do
    {
      if (v7 >= 4) {
        uint64_t v70 = 4LL;
      }
      else {
        uint64_t v70 = v7;
      }
      _plistAppendCharacters(a3, _appendIndents_tabs, v70);
      BOOL v10 = (unint64_t)v7 > 4;
      v7 -= 4LL;
    }

    while (v10);
  }

  CFDataAppendBytes(a3, (const UInt8 *)"</", 2LL);
  CFPropertyListRef v25 = L"data";
LABEL_34:
  _plistAppendCharacters(a3, v25, 4LL);
  CFDataAppendBytes(a3, (const UInt8 *)">\n", 2LL);
}

      int v19 = 2LL;
LABEL_18:
      *a6 = v12;
      goto LABEL_19;
    }
  }

  return v13;
}

    *(a4 - 2) = HIBYTE(v62) & 0x7F;
    *(a4 - 1) = v62 & 0x7F;
    goto LABEL_109;
  }

  uint64_t v64 = v10 + 3;
  if (!a5) {
    goto LABEL_109;
  }
  if (v64 <= a5)
  {
    *(_WORD *)(a4 - 1) = 31614;
    a4 += 3;
    goto LABEL_108;
  }

        v109 = v52;
        if (v24 >= v12 || (v53 & 0xFC00) != 0xD800)
        {
          uint64_t v56 = v39;
          goto LABEL_117;
        }

        uint64_t v56 = v39;
        if (v6)
        {
          CFRange v57 = v6[v24];
        }

        else if (v15)
        {
          CFRange v57 = *((_WORD *)&p_info[96]->flags + *(unsigned __int8 *)(v15 + v24));
        }

        else
        {
          if (v24 - 1 < -1) {
            goto LABEL_117;
          }
          unsigned int v72 = v119;
          if (v119 <= v24) {
            goto LABEL_117;
          }
          if (v116)
          {
            CFRange v57 = v116[v118 + v24];
          }

          else if (v117)
          {
            CFRange v57 = *(char *)(v117 + v118 + v24);
          }

          else
          {
            if (v121 <= v24 || (CFRange v77 = v120, v120 > v24))
            {
              char v78 = v24 - 4;
              if (v78 + 64 < v119) {
                unsigned int v72 = v78 + 64;
              }
              v120 = v78;
              v121 = v72;
              v134.CFIndex location = v118 + v78;
              v134.CFIndex length = v72 - v78;
              CFStringGetCharacters(v115, v134, v114);
              uint64_t v52 = v109;
              CFRange v77 = v120;
            }

            CFRange v57 = v114[v24 - v77];
          }
        }

        if (v57 >> 10 == 55) {
          int v53 = (v53 << 10) - 56613888 + v57;
        }
LABEL_117:
        CFRange v58 = BitmapPtrForPlane;
        if (v52 >= 0x10000)
        {
          CFRange v58 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v52));
          uint64_t v52 = v109;
        }

        if (!v58 || ((*(unsigned __int8 *)(v58 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
        {
          CFRange v59 = BitmapPtrForPlane;
          if (v53 >= 0x10000)
          {
            CFRange v59 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v53));
            uint64_t v52 = v109;
          }

          if (!v59 || ((*(unsigned __int8 *)(v59 + ((unsigned __int16)v53 >> 3)) >> (v53 & 7)) & 1) == 0)
          {
            CFRange v60 = v101;
            if (v52 >= 0x10000)
            {
              CFRange v60 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v52));
              uint64_t v52 = v109;
            }

            uint64_t v61 = v101;
            if (v53 >= 0x10000)
            {
              uint64_t v61 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v53));
              uint64_t v52 = v109;
            }
          }
        }

        CFRange v62 = __CFStringFoldCharacterClusterAtIndex(v52, buffer, v56, 16, 0LL, __s1, &v111, 0LL);
        uint64_t v63 = v53;
        uint64_t v64 = v62;
        uint64_t v65 = v63;
        uint64_t v66 = __CFStringFoldCharacterClusterAtIndex(v63, v114, v24 - 1, 16, 0LL, __s2, &v110, 0LL);
        uint64_t v67 = v66;
        if (v64 && v64 == v66)
        {
          uint64_t v68 = memcmp(__s1, __s2, 4 * v64);
          uint64_t v52 = v109;
          if (v68) {
            goto LABEL_140;
          }
        }

        else
        {
          uint64_t v52 = v109;
          if (v64 || v66 != 1 || v109 != __s2[0])
          {
LABEL_140:
            if (v67 || v64 != 1 || v65 != __s1[0])
            {
              int v53 = v65;
LABEL_240:
              v93 = v52 >= v53;
LABEL_241:
              if (v93) {
                return 1LL;
              }
              else {
                return -1LL;
              }
            }
          }
        }

        if (v52 < 0x10000) {
          size_t v69 = 1LL;
        }
        else {
          size_t v69 = 2LL;
        }
        if (v64) {
          size_t v69 = v111;
        }
        CFNumberRef v23 = v69 + v23 - 1;
        if (v65 < 0x10000) {
          uint64_t v70 = 1LL;
        }
        else {
          uint64_t v70 = 2LL;
        }
        if (v67) {
          uint64_t v70 = v110;
        }
        uint64_t v24 = v70 + v24 - 1;
        uint64_t v22 = v105;
        int v15 = v106;
        int v19 = Length;
        p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
LABEL_154:
        uint64_t v21 = v24 < v12;
        uint64_t v20 = v23 < v19;
      }

      while (v23 < v19 && v24 < v12);
    }
  }

  if (v20 || v21)
  {
    if (v21) {
      return -1LL;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    if ((a3 & 0x200) != 0)
    {
      char v80 = 0LL;
      v81 = 0LL;
      if (v19 >= v12) {
        v82 = v12;
      }
      else {
        v82 = v19;
      }
      v83 = 64LL;
      v84 = &OBJC_METACLASS_____NSCFTimer.info;
      while (1)
      {
        v85 = (unint64_t)v81 >= 4 ? 4LL : v81;
        v86 = -v85;
        v87 = v85 + v80;
        v88 = v83 - v85;
        if (CharactersPtr)
        {
          v89 = CharactersPtr[v81];
        }

        else if (v22)
        {
          v89 = *((_WORD *)&v84[96]->flags + *(unsigned __int8 *)(v22 + v81));
        }

        else
        {
          v90 = v127;
          if (v127 <= v81)
          {
            v89 = 0;
          }

          else if (v124)
          {
            v89 = v124[v81 + v126];
          }

          else if (v125)
          {
            v89 = *(char *)(v125 + v126 + v81);
          }

          else
          {
            if (v129 <= v81 || (v94 = v128, v128 > v81))
            {
              v95 = v81 + v86 + 64;
              if (v95 >= v127) {
                v95 = v127;
              }
              v128 = v81 + v86;
              v129 = v95;
              if (v127 >= v88) {
                v90 = v88;
              }
              v135.CFIndex length = v90 + v87;
              v96 = v84;
              v135.CFIndex location = v81 + v86 + v126;
              CFStringGetCharacters(theString, v135, buffer);
              v84 = v96;
              uint64_t v22 = v105;
              int v15 = v106;
              v94 = v128;
            }

            v89 = buffer[v81 - v94];
          }
        }

        if (v6)
        {
          v91 = v6[v81];
        }

        else if (v15)
        {
          v91 = *((_WORD *)&v84[96]->flags + *(unsigned __int8 *)(v15 + v81));
        }

        else
        {
          v92 = v119;
          if (v119 <= v81)
          {
            v91 = 0;
          }

          else if (v116)
          {
            v91 = v116[v81 + v118];
          }

          else if (v117)
          {
            v91 = *(char *)(v117 + v118 + v81);
          }

          else
          {
            if (v121 <= v81 || (v97 = v120, v120 > v81))
            {
              v98 = v81 + v86 + 64;
              if (v98 >= v119) {
                v98 = v119;
              }
              v120 = v81 + v86;
              v121 = v98;
              if (v119 >= v88) {
                v92 = v88;
              }
              v136.CFIndex length = v92 + v87;
              v99 = v84;
              v136.CFIndex location = v81 + v86 + v118;
              CFStringGetCharacters(v115, v136, v114);
              v84 = v99;
              uint64_t v22 = v105;
              int v15 = v106;
              v97 = v120;
            }

            v91 = v114[v81 - v97];
          }
        }

        v93 = v89 >= v91;
        if (v89 != v91) {
          break;
        }
        ++v81;
        --v80;
        ++v83;
        if (v81 >= v82) {
          return 0LL;
        }
      }

      goto LABEL_241;
    }

    return 0LL;
  }

void _appendEscapedString(const __CFString *a1, __CFData *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v27 = 0LL;
  CFIndex v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  CFPropertyListRef v25 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v26 = CStringPtr;
  if (Length >= 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    for (uint64_t i = 64LL; ; ++i)
    {
      uint64_t v11 = (unint64_t)v8 >= 4 ? 4LL : v8;
      if (v25)
      {
        UniChar v12 = v25[v8 + v27];
      }

      else if (v26)
      {
        UniChar v12 = v26[v27 + v8];
      }

      else
      {
        uint64_t v13 = v29;
        if (v30 <= v8 || v29 > v8)
        {
          uint64_t v15 = -v11;
          uint64_t v16 = v11 + v7;
          uint64_t v17 = i - v11;
          uint64_t v18 = v8 + v15;
          CFIndex v19 = v18 + 64;
          if (v18 + 64 >= v28) {
            CFIndex v19 = v28;
          }
          uint64_t v29 = v18;
          uint64_t v30 = v19;
          if (v28 < v17) {
            uint64_t v17 = v28;
          }
          v33.CFIndex length = v17 + v16;
          v33.CFIndex location = v18 + v27;
          CFStringGetCharacters(theString, v33, buffer);
          uint64_t v13 = v29;
        }

        UniChar v12 = buffer[v8 - v13];
      }

      if (v9 >= 62 && (v12 & 0xFC00) == 0xD800)
      {
        _plistAppendCharacters(a2, v31, v9);
        uint64_t v9 = 0LL;
      }

      if (v12 == 38) {
        break;
      }
      if (v12 == 62)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        uint64_t v20 = a2;
        uint64_t v21 = "&gt;";
LABEL_34:
        CFIndex v22 = 4LL;
LABEL_38:
        CFDataAppendBytes(v20, (const UInt8 *)v21, v22);
        goto LABEL_39;
      }

      if (v12 == 60)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        uint64_t v20 = a2;
        uint64_t v21 = "&lt;";
        goto LABEL_34;
      }

      v31[v9++] = v12;
      if (v9 != 64) {
        goto LABEL_40;
      }
      _plistAppendCharacters(a2, v31, 64LL);
LABEL_39:
      uint64_t v9 = 0LL;
LABEL_40:
      ++v8;
      --v7;
      if (Length == v8)
      {
        if (v9) {
          _plistAppendCharacters(a2, v31, v9);
        }
        return;
      }
    }

    if (v9) {
      _plistAppendCharacters(a2, v31, v9);
    }
    uint64_t v20 = a2;
    uint64_t v21 = "&amp;";
    CFIndex v22 = 5LL;
    goto LABEL_38;
  }

void _plistAppendFormat(__CFData *a1, CFStringRef format, ...)
{
  CFStringRef v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, format, va);
  _plistAppendString(a1, v3);
  CFRelease(v3);
}

void _plistAppendString(__CFData *a1, CFStringRef theString)
{
  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr)
  {
    uint64_t v5 = (UniChar *)CharactersPtr;
    CFIndex Length = CFStringGetLength(theString);
    _plistAppendCharacters(a1, v5, Length);
  }

  else
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    if (CStringPtr || (CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u)) != 0LL)
    {
      size_t v8 = strlen(CStringPtr);
      CFDataAppendBytes(a1, (const UInt8 *)CStringPtr, v8);
    }

    else
    {
      ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  theString,  0x8000100u,  0);
      if (ExternalRepresentation)
      {
        BOOL v10 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        CFIndex v12 = CFDataGetLength(v10);
        CFDataAppendBytes(a1, BytePtr, v12);
        CFRelease(v10);
      }
    }
  }

uint64_t __CFPropertyListIsArrayPlistAux(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)a2)
  {
    if (result)
    {
      uint64_t result = __CFPropertyListIsValidAux(result, a2);
    }

    else
    {
      CFStringRef v3 = *(void **)(a2 + 24);
      if (v3 && !*v3)
      {
        CFTypeRef v4 = CFRetain(@"property list arrays cannot contain NULL");
        uint64_t result = 0LL;
        **(void **)(a2 + 24) = v4;
      }

      else
      {
        uint64_t result = 0LL;
      }
    }

    *(_BYTE *)a2 = result;
  }

  return result;
}

const void *__CFPropertyListIsDictPlistAux(const void *cf, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    uint64_t v5 = cf;
    if (!cf)
    {
      uint64_t v9 = *(void **)(a3 + 24);
      if (v9)
      {
        if (!*v9) {
          **(void **)(a3 + 24) = CFRetain(@"property list dictionaries cannot contain NULL keys");
        }
      }
    }

    if (!a2)
    {
      BOOL v10 = *(void **)(a3 + 24);
      if (v10)
      {
        if (!*v10) {
          **(void **)(a3 + 24) = CFRetain(@"property list dictionaries cannot contain NULL values");
        }
      }
    }

    if (CFGetTypeID(v5) != 7)
    {
      int v6 = *(void **)(a3 + 24);
      if (v6)
      {
        if (!*v6)
        {
          CFTypeID v7 = CFGetTypeID(v5);
          CFStringRef v8 = CFCopyTypeIDDescription(v7);
          **(void **)(a3 + 24) = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"property list dictionaries may only have keys which are CFStrings, not '%@'",  v8);
          CFRelease(v8);
        }
      }
    }

    CFTypeRef cf = 0LL;
    if (v5 && a2)
    {
      if (CFGetTypeID(v5) == 7) {
        CFTypeRef cf = (const void *)__CFPropertyListIsValidAux(a2, a3);
      }
      else {
        CFTypeRef cf = 0LL;
      }
    }

    *(_BYTE *)a3 = (_BYTE)cf;
  }

  return cf;
}

uint64_t lineNumber(unint64_t *a1)
{
  CFIndex v1 = (unsigned __int8 *)*a1;
  unint64_t v2 = a1[2];
  if (*a1 >= v2) {
    return 1LL;
  }
  unint64_t v3 = a1[1];
  uint64_t result = 1LL;
  do
  {
    int v5 = *v1;
    if (v5 == 10)
    {
      uint64_t result = (result + 1);
    }

    else if (v5 == 13)
    {
      uint64_t result = (result + 1);
    }

    ++v1;
  }

  while ((unint64_t)v1 < v2);
  return result;
}

unint64_t *skipXMLComment(unint64_t *result)
{
  CFIndex v1 = result;
  unint64_t v3 = result[1];
  unint64_t v2 = result[2];
  if (v3 >= v2 - 3)
  {
LABEL_7:
    uint64_t v6 = lineNumber(result);
    uint64_t result = (unint64_t *)__CFPropertyListCreateError( 3840LL,  @"Unterminated comment started on line %u",  v6);
    v1[3] = (unint64_t)result;
  }

  else
  {
    uint64_t v4 = v2 - v3 - 3;
    unint64_t v5 = v3 + 3;
    while (*(_BYTE *)(v5 - 3) != 45 || *(_BYTE *)(v5 - 2) != 45 || *(_BYTE *)(v5 - 1) != 62)
    {
      ++v5;
      if (!--v4) {
        goto LABEL_7;
      }
    }

    result[1] = v5;
  }

  return result;
}

unint64_t *skipXMLProcessingInstruction(unint64_t *result)
{
  CFIndex v1 = result;
  unint64_t v2 = result[1];
  unint64_t v3 = result[2];
  if (v2 >= v3 - 2)
  {
LABEL_6:
    result[1] = v2;
    uint64_t v6 = lineNumber(result);
    uint64_t result = (unint64_t *)__CFPropertyListCreateError( 3840LL,  @"Encountered unexpected EOF while parsing the processing instruction begun on line %u",  v6);
    v1[3] = (unint64_t)result;
  }

  else
  {
    uint64_t v4 = v3 - v2 - 2;
    unint64_t v5 = (_BYTE *)(v2 + 1);
    while (*(v5 - 1) != 63 || *v5 != 62)
    {
      result[1] = (unint64_t)v5++;
      if (!--v4) {
        goto LABEL_6;
      }
    }

    result[1] = (unint64_t)(v5 + 1);
  }

  return result;
}

uint64_t parseXMLElement(uint64_t a1, _BYTE *a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t v6 = *(unsigned __int8 **)(a1 + 8);
  CFTypeID v7 = v6;
  if (a2)
  {
    *a2 = 0;
    CFTypeID v7 = *(unsigned __int8 **)(a1 + 8);
  }

  CFStringRef v8 = *(unsigned __int8 **)(a1 + 16);
  if (v7 >= v8)
  {
    int v11 = -1;
  }

  else
  {
    uint64_t v9 = v8 - v7;
    int v10 = (_DWORD)v7 - (_DWORD)v6;
    int v11 = -1;
    do
    {
      uint64_t v12 = *v7;
      if (v12 <= 0x3E)
      {
        if (((1LL << v12) & 0x100002600LL) != 0)
        {
          if (v11 == -1) {
            int v11 = v10;
          }
        }

        else if (v12 == 62)
        {
          goto LABEL_14;
        }
      }

      *(void *)(a1 + _Block_object_dispose(va, 8) = ++v7;
      ++v10;
      --v9;
    }

    while (v9);
    CFTypeID v7 = v8;
  }

LABEL_71:
        if (v21 && v20 && v19 && v18 && v17 && v15 && !*(_BYTE *)(a1 + 64))
        {
          CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered new tag when expecting only old-style property list objects");
          goto LABEL_79;
        }

        switch(v14)
        {
          case 0:
            if (v13 == 47)
            {
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty plist tag");
              goto LABEL_79;
            }

            return parsePListTag((unint64_t *)a1, a3, a4 + 1);
          case 1:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80)) {
                goto LABEL_101;
              }
              int v40 = *(_DWORD *)(a1 + 40);
              unint64_t v41 = *(const __CFAllocator **)(a1 + 32);
              if (v40) {
                CFMutableArrayRef Mutable = CFArrayCreateMutable(v41, 0LL, &kCFTypeArrayCallBacks);
              }
              else {
                CFMutableArrayRef Mutable = CFArrayCreate(v41, 0LL, 0LL, &kCFTypeArrayCallBacks);
              }
              goto LABEL_138;
            }

            return parseArrayTag(a1, (CFArrayRef *)a3, a4 + 1);
          case 2:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80)) {
                goto LABEL_101;
              }
              int v43 = *(_DWORD *)(a1 + 40);
              uint64_t v44 = *(const __CFAllocator **)(a1 + 32);
              if (v43) {
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable( v44,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
              }
              else {
                CFMutableArrayRef Mutable = CFDictionaryCreate( v44,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
              }
              goto LABEL_138;
            }

            return parseDictTag(a1, a3, a4 + 1);
          case 3:
          case 4:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80))
              {
LABEL_101:
                *a3 = 0LL;
                goto LABEL_139;
              }

              int v33 = *(_DWORD *)(a1 + 40);
              uint64_t v34 = *(const __CFAllocator **)(a1 + 32);
              if (v33 == 2) {
                CFMutableArrayRef Mutable = CFStringCreateMutable(v34, 0LL);
              }
              else {
                CFMutableArrayRef Mutable = (void *)CFStringCreateWithCharacters(v34, 0LL, 0LL);
              }
              goto LABEL_138;
            }

            uint64_t result = parseStringTag(a1, (CFMutableStringRef *)a3);
            if ((_DWORD)result)
            {
              uint64_t result = (uint64_t)*a3;
              if (*a3) {
                goto LABEL_90;
              }
            }

            return result;
          case 5:
            if (v13 == 47)
            {
              uint64_t v46 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <data> on line %u", v46);
              goto LABEL_79;
            }

            return parseDataTag(a1, (__CFData **)a3);
          case 6:
            if (v13 == 47)
            {
              uint64_t v47 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <date> on line %u", v47);
              goto LABEL_79;
            }

            return parseDateTag(a1, (CFDateRef *)a3);
          case 7:
            if (v13 == 47)
            {
              uint64_t v48 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <real> on line %u", v48);
              goto LABEL_79;
            }

            return parseRealTag(a1, a3);
          case 8:
            if (v13 == 47)
            {
              uint64_t v49 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <integer> on line %u", v49);
              goto LABEL_79;
            }

            return parseIntegerTag(a1, (CFNumberRef *)a3);
          case 9:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"true", 4uLL))
            {
              uint64_t v50 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered non-empty <true> on line %u", v50);
              goto LABEL_79;
            }

            if (*(_BYTE *)(a1 + 80)) {
              goto LABEL_117;
            }
            int v42 = (CFTypeRef *)&kCFBooleanTrue;
            goto LABEL_130;
          case 10:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"false", 5uLL))
            {
              uint64_t v51 = lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered non-empty <false> on line %u", v51);
              goto LABEL_79;
            }

            if (*(_BYTE *)(a1 + 80))
            {
LABEL_117:
              CFMutableArrayRef Mutable = 0LL;
            }

            else
            {
              int v42 = (CFTypeRef *)&kCFBooleanFalse;
LABEL_130:
              CFMutableArrayRef Mutable = (void *)CFRetain(*v42);
            }

  CFStringRef v37 = (UniChar *)CFAllocatorAllocate(alloc, size[0], 0LL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  v68.CFIndex location = 0LL;
  v68.CFIndex length = data;
  uint64_t v38 = __CFStringEncodeByteStream(theString, v68, 1, v5, v4, v37, size[0], &length);
  if (data == v38 || v4 && v38) {
    return CFDataCreateWithBytesNoCopy(alloc, (const UInt8 *)v37, length, alloc);
  }
  CFAllocatorDeallocate(alloc, v37);
  return 0LL;
}

    int v30 = -3;
    goto LABEL_83;
  }

  if ((_DWORD)v15 != 12441)
  {
    if ((_DWORD)v15 == 12442)
    {
      int v30 = v29 + 2;
      goto LABEL_82;
    }

    goto LABEL_71;
  }

  if (v29 != 12454)
  {
    int v30 = v29 + 1;
LABEL_82:
    if (v30 < 0xA2u) {
      goto LABEL_159;
    }
    goto LABEL_83;
  }

  int v30 = 12532;
LABEL_83:
  uint64_t v34 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  unint64_t v35 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (1)
  {
    CFStringRef v36 = (uint64_t)(0x8E38E38E38E38E39LL * (v34 - v35)) >> 1;
    CFStringRef v37 = &v35[9 * v36];
    uint64_t v38 = *v37;
    if (v38 <= v30) {
      break;
    }
    uint64_t v34 = v37 - 9;
LABEL_88:
    if (v35 > v34) {
      goto LABEL_159;
    }
  }

  if (v38 + 8 <= v30)
  {
    unint64_t v35 = v37 + 9;
    goto LABEL_88;
  }

  uint64_t v39 = v35[9 * v36 + 1 + (int)(v30 - v38)];
  if ((_WORD)v39) {
    int v40 = (unsigned __int16)v39 == 65533;
  }
  else {
    int v40 = 1;
  }
  if (!v40)
  {
    if (a5) {
      *((_WORD *)a4 - 1) = bswap32(v39) >> 16;
    }
    goto LABEL_41;
  }

uint64_t parsePListTag(unint64_t *a1, CFTypeRef *a2, unint64_t a3)
{
  v13[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  v13[0] = 0LL;
  if (!getContentObject(a1, 0LL, (uint64_t)v13, a3))
  {
    if (!a1[3])
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty plist tag");
LABEL_10:
      CFErrorRef v8 = Error;
      uint64_t result = 0LL;
      a1[3] = (unint64_t)v8;
      return result;
    }

    return 0LL;
  }

  unint64_t v6 = a1[1];
  CFTypeRef cf = 0LL;
  if (getContentObject(a1, 0LL, (uint64_t)&cf, a3))
  {
    if (cf) {
      CFRelease(cf);
    }
    if (v13[0]) {
      CFRelease(v13[0]);
    }
    a1[1] = v6;
    uint64_t v11 = lineNumber(a1);
    CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected element at line %u (plist can only include one object)",  v11);
    goto LABEL_10;
  }

  if (a1[3])
  {
    uint64_t result = (uint64_t)v13[0];
  }

  else
  {
    int v10 = checkForCloseTag(a1, (const UInt8 *)"plist", 5uLL);
    uint64_t result = (uint64_t)v13[0];
    if (v10)
    {
      *a2 = v13[0];
      return 1LL;
    }
  }

  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0LL;
  }

  return result;
}

uint64_t parseArrayTag(uint64_t a1, CFArrayRef *a2, unint64_t a3)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  cf[0] = 0LL;
  if (!*(_BYTE *)(a1 + 80))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL, &kCFTypeArrayCallBacks);
    CFErrorRef v8 = *(const __CFSet **)(a1 + 72);
    __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v8, &v21, &v22);
    uint64_t v9 = v21;
    int v20 = a2;
    if (!v21)
    {
      int ContentObject = getContentObject((unint64_t *)a1, 0LL, (uint64_t)cf, a3);
      uint64_t v13 = 0LL;
      uint64_t v11 = v22;
      if (ContentObject) {
        goto LABEL_17;
      }
      goto LABEL_31;
    }

    CFStringRef v10 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0LL, @"%ld", 0LL);
    if (!CFSetContainsValue(v9, v10) && !CFSetContainsValue(v9, @"*")) {
      *(_BYTE *)(a1 + 80) = 1;
    }
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = v22;
    *(void *)(a1 + 72) = v22;
    int v12 = getContentObject((unint64_t *)a1, 0LL, (uint64_t)cf, a3);
    *(void *)(a1 + 72) = v8;
    *(_BYTE *)(a1 + 80) = 0;
    uint64_t v13 = 1LL;
    if (!v12)
    {
LABEL_31:
      if (v11) {
        CFRelease(v11);
      }
      if (v9) {
        CFRelease(v9);
      }
      if (!*(void *)(a1 + 24) && checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL))
      {
        int v17 = allowImmutableCollections;
        if (allowImmutableCollections == -1)
        {
          int v17 = getenv("CFPropertyListAllowImmutableCollections") != 0LL;
          allowImmutableCollections = v17;
        }

        if (v17 == 1)
        {
          int v18 = v20;
          if (*(_DWORD *)(a1 + 40))
          {
            CFArrayRef Copy = Mutable;
          }

          else
          {
            CFArrayRef Copy = CFArrayCreateCopy(*(CFAllocatorRef *)(a1 + 32), Mutable);
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
        }

        else
        {
          CFArrayRef Copy = Mutable;
          int v18 = v20;
        }

        *int v18 = Copy;
        return 1LL;
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
      return 0LL;
    }

    while (1)
    {
      while (1)
      {
LABEL_17:
        if (cf[0])
        {
          CFArrayAppendValue(Mutable, cf[0]);
          if (cf[0]) {
            CFRelease(cf[0]);
          }
        }

        if (v9) {
          break;
        }
      }

      CFStringRef v15 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0LL, @"%ld", v13);
      if (!CFSetContainsValue(v9, v15) && !CFSetContainsValue(v9, @"*")) {
        break;
      }
      if (v15) {
        goto LABEL_24;
      }
LABEL_25:
      ++v13;
      *(void *)(a1 + 72) = v11;
      int v16 = getContentObject((unint64_t *)a1, 0LL, (uint64_t)cf, a3);
      *(void *)(a1 + 72) = v8;
      *(_BYTE *)(a1 + 80) = 0;
      if (!v16) {
        goto LABEL_31;
      }
    }

    *(_BYTE *)(a1 + 80) = 1;
    if (!v15) {
      goto LABEL_25;
    }
LABEL_24:
    CFRelease(v15);
    goto LABEL_25;
  }

  while (getContentObject((unint64_t *)a1, 0LL, (uint64_t)cf, a3))
  {
    if (cf[0]) {
      CFRelease(cf[0]);
    }
  }

  if (*(void *)(a1 + 24)) {
    return 0LL;
  }
  uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL);
  if (!(_DWORD)result) {
    return result;
  }
  *a2 = 0LL;
  return 1LL;
}

uint64_t parseDictTag(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  CFTypeRef v37 = 0LL;
  CFTypeRef cf = 0LL;
  if (*(_BYTE *)(a1 + 80))
  {
    while (getContentObject((unint64_t *)a1, &v39, (uint64_t)&cf, a3))
    {
      if (!v39)
      {
        if (*(void *)(a1 + 24)) {
          return 0LL;
        }
        uint64_t v32 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Found non-key inside <dict> at line %u", v32);
LABEL_49:
        CFErrorRef v24 = Error;
        uint64_t result = 0LL;
        *(void *)(a1 + 24) = v24;
        return result;
      }

      if (!getContentObject((unint64_t *)a1, 0LL, (uint64_t)&v37, a3))
      {
        if (*(void *)(a1 + 24)) {
          return 0LL;
        }
        uint64_t v33 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Value missing for key inside <dict> at line %u", v33);
        goto LABEL_49;
      }

      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0LL;
      if (v37) {
        CFRelease(v37);
      }
      CFTypeRef v37 = 0LL;
    }

    uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"dict", 4uLL);
    if (!(_DWORD)result) {
      return result;
    }
    *a2 = 0LL;
    return 1LL;
  }

  unint64_t v6 = *(const __CFSet **)(a1 + 72);
  __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v6, (__CFSet **)&v35, (__CFSet **)&v36);
  CFTypeID v7 = 0LL;
  if (!getContentObject((unint64_t *)a1, &v39, (uint64_t)&cf, a3) || (CFTypeRef v8 = cf) == 0LL)
  {
LABEL_31:
    if (v36) {
      CFRelease(v36);
    }
    if (v35) {
      CFRelease(v35);
    }
    if (v7)
    {
      if (CFDictionaryGetCount(v7) == 1)
      {
        int Value = (const __CFNumber *)CFDictionaryGetValue(v7, @"CF$UID");
        if (Value)
        {
          int v14 = Value;
          if (CFGetTypeID(Value) == 22)
          {
            CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr);
            uint64_t v21 = _CFKeyedArchiverUIDCreate(*(const __CFAllocator **)(a1 + 32), valuePtr, v15, v16, v17, v18, v19, v20);
            CFRelease(v7);
            *a2 = v21;
            return 1LL;
          }
        }
      }

      int v28 = allowImmutableCollections;
      if (allowImmutableCollections == -1)
      {
        int v28 = getenv("CFPropertyListAllowImmutableCollections") != 0LL;
        allowImmutableCollections = v28;
      }

      if (v28 == 1 && !*(_DWORD *)(a1 + 40))
      {
        CFDictionaryRef Copy = CFDictionaryCreateCopy(*(CFAllocatorRef *)(a1 + 32), v7);
        CFRelease(v7);
        CFTypeID v7 = Copy;
      }
    }

    else
    {
      int v30 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40)) {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v30, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      else {
        CFMutableDictionaryRef Mutable = CFDictionaryCreate( v30,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      CFTypeID v7 = Mutable;
    }

    *a2 = v7;
    return 1LL;
  }

  CFTypeID v7 = 0LL;
  while (1)
  {
    if (!v39)
    {
      if (*(void *)(a1 + 24)
        || (uint64_t v25 = lineNumber((unint64_t *)a1),
            *(void *)(a1 + 24) = __CFPropertyListCreateError( 3840LL,  @"Found non-key inside <dict> at line %u",  v25),  (CFTypeRef v8 = cf) != 0LL))
      {
        CFRelease(v8);
      }

      if (v36) {
        CFRelease(v36);
      }
      CFTypeRef v26 = v35;
      if (v35) {
        goto LABEL_65;
      }
      goto LABEL_66;
    }

    CFTypeRef v9 = v35;
    if (v35) {
      break;
    }
LABEL_20:
    CFTypeRef v11 = cf;
    if (cf)
    {
      CFTypeRef v12 = v37;
      if (v37)
      {
        if (!v7)
        {
          CFTypeID v7 = CFDictionaryCreateMutable( *(CFAllocatorRef *)(a1 + 32),  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          _CFDictionarySetCapacity((__objc2_class **)v7, 10LL);
          CFTypeRef v12 = v37;
          CFTypeRef v11 = cf;
        }

        CFDictionarySetValue(v7, v11, v12);
        CFTypeRef v11 = cf;
      }
    }

    if (v11) {
      CFRelease(v11);
    }
    CFTypeRef cf = 0LL;
    if (v37) {
      CFRelease(v37);
    }
    CFTypeRef v37 = 0LL;
    if (getContentObject((unint64_t *)a1, &v39, (uint64_t)&cf, a3))
    {
      CFTypeRef v8 = cf;
      if (cf) {
        continue;
      }
    }

    goto LABEL_31;
  }

  *(void *)(a1 + 72) = v36;
  int ContentObject = getContentObject((unint64_t *)a1, 0LL, (uint64_t)&v37, a3);
  *(void *)(a1 + 72) = v6;
  *(_BYTE *)(a1 + 80) = 0;
  if (ContentObject) {
    goto LABEL_20;
  }
LABEL_57:
  if (!*(void *)(a1 + 24))
  {
    uint64_t v27 = lineNumber((unint64_t *)a1);
    *(void *)(a1 + 24) = __CFPropertyListCreateError( 3840LL,  @"Value missing for key inside <dict> at line %u",  v27);
  }

  if (cf) {
    CFRelease(cf);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v9)
  {
    CFTypeRef v26 = v9;
LABEL_65:
    CFRelease(v26);
  }

uint64_t parseStringTag(uint64_t a1, CFMutableStringRef *a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 24)) {
    return 0LL;
  }
  CFMutableDictionaryRef Mutable = 0LL;
  unint64_t v6 = *(const UInt8 **)(a1 + 8);
  CFTypeID v7 = v6;
  while (1)
  {
    unint64_t v8 = *(void *)(a1 + 16);
    int v9 = *v6;
    if (v9 == 38)
    {
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
        unint64_t v6 = *(const UInt8 **)(a1 + 8);
      }

      CFDataAppendBytes(Mutable, v7, v6 - v7);
      int v14 = *(_BYTE **)(a1 + 8);
      unint64_t v15 = *(void *)(a1 + 16);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v14 + 1;
      unsigned int v16 = v15 - ((_DWORD)v14 + 1);
      int v17 = (char)v14[1];
      if (v17 <= 102)
      {
        if (v17 == 35)
        {
          if (v16 > 3)
          {
            CFTypeRef v26 = v14 + 2;
            *(void *)(a1 + _Block_object_dispose(va, 8) = v14 + 2;
            int v27 = v14[2];
            if (v27 == 120)
            {
              CFTypeRef v26 = v14 + 3;
              *(void *)(a1 + _Block_object_dispose(va, 8) = v14 + 3;
            }

            if ((unint64_t)v26 < v15)
            {
              uint64_t v28 = 0LL;
              unsigned int v29 = 0;
              unint64_t v30 = v15 - (void)v26;
              while (1)
              {
                uint64_t v31 = (char)v26[v28];
                *(void *)(a1 + _Block_object_dispose(va, 8) = &v26[v28 + 1];
                if ((_DWORD)v31 == 59) {
                  break;
                }
                if ((_DWORD)v28 == 8)
                {
                  usedBufLend = (CFIndex *)lineNumber((unint64_t *)a1);
                  CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unparseable unicode sequence at line %u while parsing data (too large of a value for a Unicode sequence)",  usedBufLend,  v53,  *(void *)bytes);
                  goto LABEL_81;
                }

                int v32 = 16 * v29;
                if ((v31 - 48) > 9)
                {
                  if (v27 != 120) {
                    goto LABEL_89;
                  }
                  if ((v31 - 97) > 5)
                  {
                    if ((v31 - 65) > 5)
                    {
LABEL_89:
                      uint64_t v54 = lineNumber((unint64_t *)a1);
                      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected character %c at line %u while parsing data",  v31,  v54,  *(void *)bytes);
                      goto LABEL_81;
                    }

                    unsigned int v29 = v32 + v31 - 55;
                  }

                  else
                  {
                    unsigned int v29 = v32 + v31 - 87;
                  }
                }

                else
                {
                  int v33 = 10 * v29;
                  if (v27 == 120) {
                    int v33 = v32;
                  }
                  unsigned int v29 = v31 + v33 - 48;
                }

                *(_DWORD *)uint64_t v56 = v29;
                if (v30 == ++v28) {
                  goto LABEL_72;
                }
              }

              *(_DWORD *)uint64_t v56 = bswap32(v29);
              uint64_t v34 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v56, 4LL, 0x18000100u, 0);
              if (v34)
              {
                CFTypeRef v35 = v34;
                *(void *)bytes = 0LL;
                v59.CFIndex length = CFStringGetLength(v34);
                v59.CFIndex location = 0LL;
                CFStringGetBytes(v35, v59, 0x8000100u, 0, 0, buffer, 6LL, (CFIndex *)bytes);
                CFDataAppendBytes(Mutable, buffer, *(CFIndex *)bytes);
                CFRelease(v35);
                goto LABEL_82;
              }

              usedBufLene = (CFIndex *)lineNumber((unint64_t *)a1);
              CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unparseable Unicode sequence at line %u while parsing data (input did not result in a real string)",  usedBufLene,  v53,  *(void *)bytes);
              goto LABEL_81;
            }
          }

          goto LABEL_72;
        }

        if (v17 != 97) {
          goto LABEL_80;
        }
        if (v16 <= 3) {
          goto LABEL_72;
        }
        int v19 = v14[2];
        if (v19 != 109)
        {
          if (v16 < 5 || v19 != 112 || v14[3] != 111 || v14[4] != 115 || v14[5] != 59) {
            goto LABEL_80;
          }
          UInt8 v25 = 39;
          goto LABEL_79;
        }

        if (v14[3] != 112 || v14[4] != 59) {
          goto LABEL_80;
        }
        bytes[0] = 38;
        uint64_t v20 = 5LL;
      }

      else if (v17 == 103)
      {
        if (v16 < 3 || v14[2] != 116 || v14[3] != 59) {
          goto LABEL_80;
        }
        UInt8 v18 = 62;
LABEL_47:
        bytes[0] = v18;
        uint64_t v20 = 4LL;
      }

      else
      {
        if (v17 != 113)
        {
          if (v17 == 108 && v16 >= 3 && v14[2] == 116 && v14[3] == 59)
          {
            UInt8 v18 = 60;
            goto LABEL_47;
          }

LABEL_80:
          usedBufLenc = (CFIndex *)lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unknown ampersand-escape sequence at line %u",  usedBufLenc,  v53,  *(void *)bytes);
          goto LABEL_81;
        }

        if (v16 < 5 || v14[2] != 117 || v14[3] != 111 || v14[4] != 116 || v14[5] != 59) {
          goto LABEL_80;
        }
        UInt8 v25 = 34;
LABEL_79:
        bytes[0] = v25;
        uint64_t v20 = 6LL;
      }

      *(void *)(a1 + _Block_object_dispose(va, 8) = &v14[v20];
      CFDataAppendBytes(Mutable, bytes, 1LL);
      goto LABEL_82;
    }

    if (v9 == 60)
    {
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
        unint64_t v6 = *(const UInt8 **)(a1 + 8);
      }

      CFDataAppendBytes(Mutable, v7, v6 - v7);
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(void *)(a1 + 16);
      if (v11 - v10 > 8)
      {
        if (*(void *)v10 != 0x41544144435B213CLL || *(_BYTE *)(v10 + 8) != 91)
        {
          usedBufLena = (CFIndex *)lineNumber((unint64_t *)a1);
          CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered improper CDATA opening at line %u",  usedBufLena,  v53,  *(void *)bytes);
          goto LABEL_81;
        }

        uint64_t v21 = (const UInt8 *)(v10 + 9);
        *(void *)(a1 + _Block_object_dispose(va, 8) = v10 + 9;
        if (v10 + 9 < (unint64_t)(v11 - 2))
        {
          CFIndex v22 = 0LL;
          uint64_t v23 = v11 - v10 - 11;
          while (1)
          {
            CFIndex v24 = v10 + v22;
            if (*(_BYTE *)(v10 + v22 + 9) == 93 && *(_BYTE *)(v24 + 10) == 93 && *(_BYTE *)(v10 + v22 + 11) == 62) {
              break;
            }
            *(void *)(a1 + _Block_object_dispose(va, 8) = v24 + 10;
            if (v23 == ++v22) {
              goto LABEL_42;
            }
          }

          CFDataAppendBytes(Mutable, v21, v22);
          *(void *)(a1 + 8) += 3LL;
          goto LABEL_82;
        }

  *a6 = v12;
  return (_BYTE *)(v22 - a2);
}

        if ((theForm & 1) != 0)
        {
          if (v52)
          {
            if (v52 >= 1) {
              goto LABEL_86;
            }
          }

          else if (CFUniCharIsMemberOf(v49, 0x64u))
          {
            *int v43 = v49;
            uint64_t v52 = 1LL;
LABEL_86:
            uint64_t v61 = i;
            do
            {
              CFRange v62 = CFUniCharCompatibilityDecompose((int *)v43, v52, v44);
              if (!v62)
              {
                v44 += 64LL;
                if (v43 == (unsigned int *)__src)
                {
                  int v43 = (unsigned int *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 4 * v44, 0LL);
                  memmove(v43, __src, 0x100uLL);
                }

                else
                {
                  int v43 = (unsigned int *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v43,  4 * v44,  0LL,  0LL);
                }
              }
            }

            while (v62 < v52);
            uint64_t v52 = v62;
            uint64_t i = v61;
            goto LABEL_94;
          }

          uint64_t v52 = 0LL;
        }

                                    ++v12;
LABEL_81:
                                    int v19 = 2LL;
                                    goto LABEL_17;
                                  }

                                  if ((unsigned __int16)(v25 + 23703) > 0x1Cu)
                                  {
                                    if (v25 != 42566) {
                                      return v13;
                                    }
                                    v12 += v17;
                                    if (a5)
                                    {
                                      if (v12 > a5) {
                                        return v13;
                                      }
                                      if ((a1 & 0x200) == 0) {
                                        *a4++ = -1951;
                                      }
                                      *(_DWORD *)a4 = 538976288;
                                      a4[2] = 8224;
                                      a4 += 3;
                                      goto LABEL_81;
                                    }
                                  }

                                  else
                                  {
                                    v12 += v17;
                                    if (a5)
                                    {
                                      if (v12 > a5) {
                                        return v13;
                                      }
                                      if ((a1 & 0x200) == 0) {
                                        *a4++ = -1951;
                                      }
                                      *a4 = 40;
                                      if (v25 >= 0xA381) {
                                        v79 = 62;
                                      }
                                      else {
                                        v79 = 65;
                                      }
                                      a4[1] = v79 + v25 + 23703;
                                      a4[2] = 41;
                                      a4 += 3;
LABEL_160:
                                      int v19 = 2LL;
                                      goto LABEL_17;
                                    }
                                  }

                                  int v19 = 2LL;
                                  goto LABEL_17;
                                }

                                if (v111)
                                {
                                  uint64_t v49 = __CFStringEncodingIsDecomposableCharacter_0(v46, (a1 >> 7) & 1);
                                  int v17 = v22;
                                  unsigned int v16 = v111;
                                  unint64_t v15 = v114;
                                  int v14 = v107;
                                  if (v49)
                                  {
                                    uint64_t v51 = __CFStringEncodingDecomposeCharacter_0( a1,  v47,  v117,  v50,  63615LL,  v107,  v22,  8230LL);
                                    uint64_t v52 = *a6;
                                    CFTypeRef v12 = *a6 + v51;
                                    *a6 = v12;
                                    if (!a5) {
                                      goto LABEL_142;
                                    }
                                    if (v12 <= a5)
                                    {
                                      if (v51 >= 1)
                                      {
                                        uint64_t v53 = v51 + 1;
                                        uint64_t v54 = (__int16 *)v117;
                                        int v14 = v107;
                                        unint64_t v15 = v114;
                                        unsigned int v16 = v111;
                                        int v17 = v22;
                                        do
                                        {
                                          CFRange v55 = *v54++;
                                          *a4++ = v55;
                                          --v53;
                                        }

                                        while (v53 > 1);
                                        int v19 = 2LL;
                                        goto LABEL_18;
                                      }

uint64_t checkForCloseTag(unint64_t *a1, const UInt8 *a2, size_t a3)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  unint64_t v5 = (unsigned __int8 *)a1[2];
  int v7 = *v4;
  if (v7 != 60 || (a1[1] = (unint64_t)(v4 + 1), int v7 = v4[1], v7 != 47))
  {
    if (!a1[3])
    {
      uint64_t v21 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected character %c on line %u while looking for close tag",  (char)v7,  v21);
      goto LABEL_13;
    }

    return 0LL;
  }

  uint64_t v10 = v4 + 2;
  a1[1] = (unint64_t)(v4 + 2);
  if (memcmp(v4 + 2, a2, a3))
  {
    CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, 0x8000100u, 0);
    if (!a1[3])
    {
      uint64_t v12 = lineNumber(a1);
      a1[3] = (unint64_t)__CFPropertyListCreateError( 3840LL,  @"Close tag on line %u does not match open tag %@",  v12,  v11);
    }

    CFRelease(v11);
    return 0LL;
  }

  unint64_t v15 = &v10[a3];
  for (a1[1] = (unint64_t)&v10[a3]; v15 < v5; a1[1] = (unint64_t)v15)
  {
    unsigned int v16 = (char)*v15;
    BOOL v17 = v16 > 0x20;
    uint64_t v18 = (1LL << v16) & 0x100002600LL;
    if (v17 || v18 == 0) {
      break;
    }
    ++v15;
  }

  if (v15 == v5)
  {
LABEL_27:
    if (!a1[3])
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered unexpected EOF");
LABEL_13:
      CFErrorRef v14 = Error;
      uint64_t result = 0LL;
      a1[3] = (unint64_t)v14;
      return result;
    }

    return 0LL;
  }

  if (*v15 != 62)
  {
    if (!a1[3])
    {
      uint64_t v20 = (char)*v15;
      uint64_t v22 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected character %c on line %u while looking for close tag",  v20,  v22);
      goto LABEL_13;
    }

    return 0LL;
  }

  a1[1] = (unint64_t)(v15 + 1);
  return 1LL;
}

uint64_t parseDataTag(uint64_t a1, __CFData **a2)
{
  uint64_t v20 = *(void *)(a1 + 8);
  if (*(_BYTE *)(a1 + 80))
  {
    unint64_t v3 = 0LL;
    uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  }

  else
  {
    unint64_t v3 = (UInt8 *)CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 256LL, 0LL);
    uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
  }

  if ((unint64_t)v4 >= *(void *)(a1 + 16))
  {
    int v8 = 0;
LABEL_29:
    if (*(_BYTE *)(a1 + 80))
    {
      uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL);
      if (!(_DWORD)result) {
        return result;
      }
      CFMutableDictionaryRef Mutable = 0LL;
    }

    else
    {
      unsigned int v16 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40) == 2)
      {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(v16, 0LL);
        CFDataAppendBytes(Mutable, v3, v8);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), v3);
      }

      else
      {
        CFMutableDictionaryRef Mutable = CFDataCreateWithBytesNoCopy(v16, v3, v8, *(CFAllocatorRef *)(a1 + 32));
      }

      if (!Mutable)
      {
        *(void *)(a1 + _Block_object_dispose(va, 8) = v20;
        uint64_t v18 = lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Could not interpret <data> at line %u (should be base64-encoded)",  v18);
        uint64_t result = 0LL;
        *(void *)(a1 + 24) = Error;
        return result;
      }

      if (!checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL))
      {
        CFRelease(Mutable);
        return 0LL;
      }
    }

    *a2 = Mutable;
    return 1LL;
  }

  char v5 = 0;
  int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  int v9 = 256;
  uint64_t v10 = MEMORY[0x1895F8770];
  while (1)
  {
    uint64_t v11 = *v4;
    if ((_DWORD)v11 != 61) {
      break;
    }
    ++v7;
LABEL_11:
    if ((parseDataTag_dataDecodeTable[v11] & 0x80000000) == 0)
    {
      ++v5;
      int v6 = parseDataTag_dataDecodeTable[v11] + (v6 << 6);
      if (!*(_BYTE *)(a1 + 80) && (v5 & 3) == 0)
      {
        uint64_t v12 = v8 + 2LL;
        if (v9 <= (int)v12)
        {
          if (v9 >= 0x40000)
          {
            if (HIBYTE(v9)) {
              v9 += 0x40000;
            }
            else {
              v9 *= 2;
            }
          }

          else
          {
            v9 *= 4;
          }

          unint64_t v3 = (UInt8 *)__CFSafelyReallocateWithAllocator(*(malloc_zone_t **)(a1 + 32), v3, v9, 0LL, 0LL);
          uint64_t v10 = MEMORY[0x1895F8770];
        }

        v3[v8] = BYTE2(v6);
        if (v7 > 1)
        {
          ++v8;
        }

        else
        {
          v3[v8 + 1] = BYTE1(v6);
          if (v7 == 1)
          {
            v8 += 2;
          }

          else
          {
            v8 += 3;
            v3[v12] = v6;
          }
        }
      }
    }

    unint64_t v13 = *(void *)(a1 + 16);
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a1 + 8) + 1LL);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v4;
  }

  if ((_DWORD)v11 == 60) {
    goto LABEL_29;
  }
  if ((v11 & 0x80) == 0)
  {
    v7 &= (int)(*(_DWORD *)(v10 + 4 * v11 + 60) << 17) >> 31;
    goto LABEL_11;
  }

  __maskrune(*v4, 0x4000uLL);
  uint64_t v17 = lineNumber((unint64_t *)a1);
  *(void *)(a1 + 24) = __CFPropertyListCreateError( 3840LL,  @"Could not interpret <data> on line %u (invalid character 0x%hhX)",  v17,  v11);
  if (v3) {
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), v3);
  }
  return 0LL;
}

uint64_t parseDateTag(uint64_t a1, CFDateRef *a2)
{
  unint64_t v3 = *(_BYTE **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v3 < v4 && *v3 == 45)
  {
    int v5 = 0;
    *(void *)(a1 + _Block_object_dispose(va, 8) = ++v3;
  }

  else
  {
    int v5 = 1;
  }

  uint64_t v6 = 0LL;
  int v7 = 0;
  while (1)
  {
    int v8 = (char)v3[v6];
    int v7 = v8 + 10 * v7 - 48;
    *(void *)(a1 + _Block_object_dispose(va, 8) = &v3[++v6];
    if (v4 - (void)v3 == v6) {
      goto LABEL_38;
    }
  }

  if (v8 != 45) {
    goto LABEL_38;
  }
  int v9 = &v3[v6 + 1];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v9;
  uint64_t v10 = &v3[v6 + 3];
  int v11 = *v9;
  int v12 = (char)v3[v6 + 2];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v10;
  if (*v10 != 45) {
    goto LABEL_38;
  }
  unint64_t v13 = &v3[v6 + 4];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v13;
  CFErrorRef v14 = &v3[v6 + 6];
  int v15 = *v13;
  int v16 = (char)v3[v6 + 5];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v14;
  if (*v14 != 84) {
    goto LABEL_38;
  }
  uint64_t v17 = &v3[v6 + 7];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v17;
  uint64_t v18 = &v3[v6 + 9];
  int v19 = *v17;
  int v20 = (char)v3[v6 + 8];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v18;
  if (*v18 != 58) {
    goto LABEL_38;
  }
  uint64_t v21 = &v3[v6 + 10];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v21;
  uint64_t v22 = &v3[v6 + 12];
  int v23 = *v21;
  int v24 = (char)v3[v6 + 11];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v22;
  if (*v22 != 58) {
    goto LABEL_38;
  }
  UInt8 v25 = &v3[v6 + 13];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v25;
  CFTypeRef v26 = &v3[v6 + 15];
  int v27 = *v25;
  int v28 = (char)v3[v6 + 14];
  *(void *)(a1 + _Block_object_dispose(va, 8) = v26;
  if (*v26 != 90) {
    goto LABEL_38;
  }
  *(void *)(a1 + _Block_object_dispose(va, 8) = &v3[v6 + 16];
  unsigned int v42 = v7;
  int v43 = v5;
  int v37 = v15;
  int v38 = v11;
  int v40 = v16;
  int v41 = v12;
  int v36 = v19;
  int v39 = v20;
  if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"date", 4uLL))
  {
    if (v43) {
      uint64_t v29 = v42;
    }
    else {
      uint64_t v29 = -v42;
    }
    *(void *)&v44.year = v29 | ((unint64_t)(v41 + 10 * v38 - 528) << 32) | ((unint64_t)(v40 + 10 * v37 - 528) << 40) | ((unint64_t)(v39 + 10 * v36 - 528) << 48) | ((unint64_t)(v24 + 10 * v23 - 528) << 56);
    v44.second = (double)(v28 + 10 * v27 - 528);
    double AbsoluteTime = CFGregorianDateGetAbsoluteTime(v44, 0LL);
    CFDateRef v31 = 0LL;
    if (!*(_BYTE *)(a1 + 80)) {
      CFDateRef v31 = CFDateCreate(*(CFAllocatorRef *)(a1 + 32), AbsoluteTime);
    }
    *a2 = v31;
    return 1LL;
  }

  else
  {
LABEL_38:
    uint64_t v33 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Could not interpret <date> at line %u", v33);
    uint64_t result = 0LL;
    *(void *)(a1 + 24) = Error;
  }

  return result;
}

uint64_t parseRealTag(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  CFStringRef theString1 = 0LL;
  if (!parseStringTag(a1, (CFMutableStringRef *)&theString1))
  {
    if (*(void *)(a1 + 24)) {
      return 0LL;
    }
    uint64_t v13 = lineNumber((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <real> on line %u", v13);
    goto LABEL_34;
  }

  unint64_t v4 = theString1;
  if (*(_BYTE *)(a1 + 80))
  {
    int v5 = 0LL;
    if (!theString1) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  if (CFStringCompare(theString1, @"nan", 1uLL) == kCFCompareEqualTo)
  {
    int v7 = (CFTypeRef *)&kCFNumberNaN;
    goto LABEL_17;
  }

  if (CFStringCompare(v4, @"+infinity", 1uLL) == kCFCompareEqualTo) {
    goto LABEL_14;
  }
  if (CFStringCompare(v4, @"-infinity", 1uLL) == kCFCompareEqualTo)
  {
LABEL_16:
    int v7 = (CFTypeRef *)&kCFNumberNegativeInfinity;
LABEL_17:
    int v5 = *v7;
    if (*v7)
    {
      CFRetain(*v7);
      if (!v4)
      {
LABEL_20:
        if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"real", 4uLL))
        {
          *a2 = v5;
          return 1LL;
        }

        if (v5) {
          CFRelease(v5);
        }
        return 0LL;
      }

uint64_t parseIntegerTag(uint64_t a1, CFNumberRef *a2)
{
  void valuePtr[2] = *MEMORY[0x1895F89C0];
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    uint64_t v6 = *(unsigned __int8 **)(a1 + 8);
    goto LABEL_23;
  }

  uint64_t v6 = *(unsigned __int8 **)(a1 + 16);
  int v7 = (unsigned __int8 *)(v5 + 1);
  uint64_t v8 = -(uint64_t)v5;
  while (1)
  {
    unsigned int v9 = *(v7 - 1);
    if (v9 < 0x21 || v9 - 127 < 0x22) {
      goto LABEL_19;
    }
    int v10 = *v7;
    int v11 = v7[1];
    if (v9 == 226 && v10 == 128)
    {
    }

    else if (v9 == 226 && v10 == 129)
    {
      if (v11 != 159) {
        break;
      }
    }

    else if (v9 != 227 || v10 != 128 || v11 != 128)
    {
      break;
    }

uint64_t getContentObject(unint64_t *a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  if (a4 >= 0x81)
  {
    uint64_t v16 = lineNumber(a1);
    CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Too many nested arrays or dictionaries, failing on line %u",  v16);
LABEL_26:
    a1[3] = (unint64_t)Error;
    return 0LL;
  }

  if (a2) {
    *a2 = 0;
  }
  if (a1[3]) {
    return 0LL;
  }
  while (2)
  {
    unsigned int v9 = (char *)a1[1];
    unint64_t v10 = a1[2];
    unint64_t v11 = v10 - (void)v9;
    while (1)
    {
      uint64_t v12 = *v9;
      a1[1] = (unint64_t)++v9;
      if (!--v11) {
        goto LABEL_25;
      }
    }

    if ((_DWORD)v12 != 60)
    {
      uint64_t v17 = lineNumber(a1);
      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected character %c on line %u while looking for open tag",  v12,  v17);
      goto LABEL_26;
    }

    a1[1] = (unint64_t)(v9 + 1);
    int v14 = v9[1];
    switch(v14)
    {
      case '!':
        if ((unint64_t)(v9 + 3) < v10 && v9[2] == 45 && v9[3] == 45)
        {
          a1[1] = (unint64_t)(v9 + 4);
          skipXMLComment(a1);
LABEL_23:
          if (!a1[3]) {
            continue;
          }
          return 0LL;
        }

CFTypeRef _createUniqueStringWithUTF8Bytes(uint64_t a1, const UInt8 *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!a3) {
    return CFRetain(&stru_1899EF170);
  }
  unsigned int v9 = 0;
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    ValueAtIndex = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), a2, a3, 0x8000100u, 0);
    if (ValueAtIndex)
    {
      unsigned int v9 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) + 1;
    }
  }

  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v9 - 1LL);
    CFRetain(ValueAtIndex);
  }

  return ValueAtIndex;
}

void __CFRunArrayDeallocate(void *a1)
{
  unint64_t v2 = (const void **)a1[2];
  os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
  if ((uint64_t)*v2 > 1)
  {
    *unint64_t v2 = (char *)*v2 - 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if ((uint64_t)v2[2] >= 1)
    {
      uint64_t v3 = 0LL;
      unint64_t v4 = v2 + 7;
      do
      {
        unint64_t v5 = *v4;
        v4 += 2;
        CFRelease(v5);
        ++v3;
      }

      while (v3 < (uint64_t)v2[2]);
    }

    BOOL v6 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v6, v2);
  }

uint64_t __CFRunArrayEqual()
{
  return 0LL;
}

uint64_t __CFRunArrayHash(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8LL);
}

__CFString *__CFRunArrayCopyDescription(uint64_t a1)
{
  CFIndex v1 = *(void **)(a1 + 16);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFStringAppendFormat( Mutable,  0LL,  @"%ld blocks used, total length %ld (%ld blocks, block %ld is at %ld)\n",  v1[2],  v1[1],  v1[3],  v1[4],  v1[5]);
  if ((uint64_t)v1[2] >= 1)
  {
    uint64_t v3 = 0LL;
    unint64_t v4 = v1 + 7;
    do
    {
      CFStringAppendFormat(Mutable, 0LL, @" %ld %p %@\n", *(v4 - 1), *v4, *v4);
      ++v3;
      v4 += 2;
    }

    while (v3 < v1[2]);
  }

  return Mutable;
}

uint64_t CFRunArrayGetTypeID()
{
  return 63LL;
}

void *_CFRunArrayCreateWithGuts( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance(a1, 0x3FuLL, 8LL, 0LL, a5, a6, a7, a8);
  uint64_t v10 = Instance;
  if (Instance)
  {
    if (a2)
    {
      Instance[2] = a2;
      os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
      ++*(void *)v10[2];
      os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    }

    else
    {
      unint64_t v11 = CFGetAllocator(Instance);
      uint64_t v12 = CFAllocatorAllocate(v11, 80LL, 0LL);
      v12[2] = 0LL;
      v12[3] = 2LL;
      v12[4] = 0LL;
      v12[5] = 0LL;
      *uint64_t v12 = 1LL;
      v12[1] = 0LL;
      uint64_t v10[2] = v12;
    }
  }

  return v10;
}

void *__CFRunArrayMakeNewList(CFTypeRef cf, uint64_t *a2)
{
  if (a2) {
    uint64_t v4 = a2[2];
  }
  else {
    uint64_t v4 = 2LL;
  }
  unint64_t v5 = CFGetAllocator(cf);
  uint64_t result = CFAllocatorAllocate(v5, 16 * v4 + 48, 0LL);
  uint64_t v7 = (uint64_t)result;
  result[3] = v4;
  if (a2)
  {
    uint64_t v8 = a2[2];
    if (v8 >= 1)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = (const void **)(a2 + 7);
      unint64_t v11 = result + 7;
      do
      {
        *(v11 - 1) = *(v10 - 1);
        uint64_t v12 = *v10;
        v10 += 2;
        uint64_t result = CFRetain(v12);
        *unint64_t v11 = result;
        v11 += 2;
        ++v9;
        uint64_t v8 = a2[2];
      }

      while (v9 < v8);
    }

    *(void *)(v7 + 16) = v8;
    *(_OWORD *)(v7 + 32) = *((_OWORD *)a2 + 2);
    uint64_t v13 = *a2;
    *(void *)(v7 + _Block_object_dispose(va, 8) = a2[1];
    *a2 = v13 - 1;
  }

  else
  {
    result[1] = 0LL;
    result[2] = 0LL;
    result[4] = 0LL;
    result[5] = 0LL;
  }

  *(void *)uint64_t v7 = 1LL;
  *((void *)cf + 2) = v7;
  return result;
}

void *CFRunArrayCreate( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _CFRunArrayCreateWithGuts(a1, 0LL, a3, a4, a5, a6, a7, a8);
}

uint64_t CFRunArrayGetCount(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8LL);
}

uint64_t CFRunArrayGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = blockForLocation(*(void *)(a1 + 16), a2, a3);
  if (a4) {
    *a4 = v6;
  }
  return *(void *)(*(void *)(a1 + 16) + 16 * v6 + 56);
}

uint64_t blockForLocation(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 >= 0) {
    uint64_t v4 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v4 = v3 + 1;
  }
  if (a2 <= v4 >> 1)
  {
    uint64_t v3 = 0LL;
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
  }

  uint64_t v6 = a1 + 16 * v5;
  if (v3 <= a2)
  {
    --v5;
    unint64_t v11 = (uint64_t *)(v6 + 48);
    do
    {
      uint64_t v12 = v3;
      uint64_t v13 = *v11;
      v11 += 2;
      uint64_t v9 = v13;
      v3 += v13;
      ++v5;
    }

    while (v3 <= a2);
    uint64_t v3 = v12;
  }

  else
  {
    uint64_t v7 = (uint64_t *)(v6 + 32);
    do
    {
      uint64_t v8 = v5--;
      uint64_t v10 = *v7;
      v7 -= 2;
      uint64_t v9 = v10;
      v3 -= v10;
    }

    while (v8 >= 2 && v3 > a2);
  }

  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v3;
  if (a3)
  {
    *a3 = v3;
    a3[1] = v9;
  }

  return v5;
}

uint64_t CFRunArrayGetValueAtRunArrayIndex(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (*(void *)(v3 + 16) <= a2) {
    return 0LL;
  }
  if (a3) {
    *a3 = *(void *)(v3 + 16 * a2 + 48);
  }
  return *(void *)(v3 + 16 * a2 + 56);
}

CFTypeRef CFRunArrayInsert(CFTypeRef result, uint64_t a2, uint64_t a3, const void *a4)
{
  v29[2] = *MEMORY[0x1895F89C0];
  if (a3)
  {
    uint64_t v7 = result;
    uint64_t v8 = (uint64_t *)*((void *)result + 2);
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v8 >= 2)
    {
      __CFRunArrayMakeNewList(v7, v8);
      uint64_t v8 = (uint64_t *)v7[2];
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if (a2 == v8[1])
    {
      if (a2 < 1)
      {
        __CFRunArraySetBlockCapacity(v7, 1LL);
        uint64_t v8 = (uint64_t *)v7[2];
        uint64_t result = CFRetain(a4);
        v8[6] = a3;
        v8[7] = (uint64_t)result;
        uint64_t v14 = v8[2];
      }

      else
      {
        uint64_t result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v8[2 * v8[2] + 5]);
        uint64_t v9 = v8[2];
        if ((_DWORD)result)
        {
          v8[2 * v9 + 4] += a3;
          if (v8[4] >= v9) {
            v8[5] += a3;
          }
          goto LABEL_21;
        }

        __CFRunArraySetBlockCapacity(v7, v9 + 1);
        uint64_t v8 = (uint64_t *)v7[2];
        uint64_t result = CFRetain(a4);
        uint64_t v14 = v8[2];
        uint64_t v17 = &v8[2 * v14];
        v17[6] = a3;
        v17[7] = (uint64_t)result;
      }

      uint64_t v8[2] = v14 + 1;
LABEL_21:
      v8[1] += a3;
      return result;
    }

    uint64_t v10 = blockForLocation((uint64_t)v8, a2, v29);
    unint64_t v11 = &v8[2 * v10];
    uint64_t result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v11[7]);
    if ((_DWORD)result)
    {
      uint64_t v12 = v11 + 6;
LABEL_11:
      uint64_t v13 = a3;
LABEL_12:
      *v12 += v13;
      goto LABEL_21;
    }

    uint64_t v15 = v29[0];
    if (v10 >= 1 && v29[0] == a2)
    {
      uint64_t v16 = &v8[2 * v10 - 2];
      uint64_t result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v16[7]);
      if ((_DWORD)result)
      {
        v16[6] += a3;
        if (v8[4] < v10) {
          goto LABEL_21;
        }
        uint64_t v12 = v8 + 5;
        goto LABEL_11;
      }

      uint64_t v15 = v29[0];
    }

    uint64_t v18 = v8[2];
    if (v15 == a2)
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 1);
      uint64_t v8 = (uint64_t *)v7[2];
      uint64_t v12 = v8 + 2;
      uint64_t v19 = v8[2];
      if (v19 > v10)
      {
        int v20 = &v8[2 * v19 + 6];
        do
        {
          --v19;
          *(_OWORD *)int v20 = *((_OWORD *)v20 - 1);
          v20 -= 2;
        }

        while (v19 > v10);
      }

      uint64_t result = CFRetain(a4);
      int v21 = &v8[2 * v10];
      v21[6] = a3;
      v21[7] = (uint64_t)result;
      uint64_t v13 = 1LL;
    }

    else
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 2);
      uint64_t v8 = (uint64_t *)v7[2];
      uint64_t v12 = v8 + 2;
      uint64_t v22 = v8[2];
      uint64_t v23 = v10 + 2;
      if (v22 + 1 >= v10 + 2)
      {
        uint64_t v24 = v22 + 2;
        int v25 = &v8[2 * v22 + 8];
        do
        {
          *(_OWORD *)int v25 = *((_OWORD *)v25 - 2);
          v25 -= 2;
          --v24;
        }

        while (v24 > v23);
      }

      CFTypeRef v26 = CFRetain(a4);
      uint64_t v27 = (uint64_t)&v8[2 * v10 + 6];
      *(void *)(v27 + 16) = a3;
      *(void *)(v27 + 24) = v26;
      *(void *)uint64_t v27 = a2 - v29[0];
      uint64_t result = CFRetain(*(CFTypeRef *)(v27 + 8));
      int v28 = &v8[2 * v23 + 6];
      v28[1] = (uint64_t)result;
      *int v28 = v29[1] - a2 + v29[0];
      uint64_t v13 = 2LL;
    }

    goto LABEL_12;
  }

  return result;
}

void *__CFRunArraySetBlockCapacity(void *result, uint64_t a2)
{
  if (a2 <= 1) {
    uint64_t v2 = 1LL;
  }
  else {
    uint64_t v2 = a2;
  }
  uint64_t v3 = *(void *)(result[2] + 24LL);
  if (v3 >= 0) {
    uint64_t v4 = *(void *)(result[2] + 24LL);
  }
  else {
    uint64_t v4 = v3 + 1;
  }
  uint64_t v5 = v4 >> 1;
  if (v3 < v2 || v5 > v2)
  {
    uint64_t v7 = result;
    unint64_t v8 = v2 + 3;
    uint64_t v9 = (malloc_zone_t *)CFGetAllocator(result);
    uint64_t result = __CFSafelyReallocateWithAllocator(v9, (void *)v7[2], ((v8 / 3) << 6) | 0x30, 0LL, 0LL);
    void v7[2] = result;
    result[3] = 4 * (v8 / 3);
  }

  return result;
}

void CFRunArrayDelete(void *a1, uint64_t a2, uint64_t a3)
{
}

void CFRunArrayReplace(void *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    uint64_t v6 = a4;
    uint64_t v10 = (uint64_t *)a1[2];
    if (a5) {
      unint64_t v11 = a4;
    }
    else {
      unint64_t v11 = 0LL;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v10 >= 2)
    {
      __CFRunArrayMakeNewList(a1, v10);
      uint64_t v10 = (uint64_t *)a1[2];
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    uint64_t v12 = blockForLocation((uint64_t)v10, a2, &v42);
    uint64_t v13 = v12;
    v10[1] -= a3;
    uint64_t v41 = a2;
    if (v43 - a2 + v42 >= a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = v43 - a2 + v42;
    }
    uint64_t v15 = &v10[2 * v12];
    uint64_t v17 = v15[6];
    uint64_t v16 = v15 + 6;
    uint64_t v18 = v17 - v14;
    *uint64_t v16 = v17 - v14;
    if (v17 == v14)
    {
      CFRelease((CFTypeRef)v10[2 * v12 + 7]);
      uint64_t v18 = *v16;
    }

    if (v18) {
      uint64_t v19 = v13 + 1;
    }
    else {
      uint64_t v19 = v13;
    }
    uint64_t v20 = a3 - v14;
    if (v20)
    {
      uint64_t v21 = (uint64_t)&v10[2 * v13 + 8];
      do
      {
        uint64_t v22 = *(void *)v21;
        if (v20 >= *(void *)v21) {
          uint64_t v23 = *(void *)v21;
        }
        else {
          uint64_t v23 = v20;
        }
        *(void *)uint64_t v21 = v22 - v23;
        if (v22 <= v20) {
          CFRelease(*(CFTypeRef *)(v21 + 8));
        }
        v21 += 16LL;
        ++v13;
        v20 -= v23;
      }

      while (v20);
    }

    if (v13) {
      v13 -= v10[2 * v13 + 6] != 0;
    }
    if (v19 > v13)
    {
      uint64_t v6 = v11;
LABEL_47:
      if (v6) {
        CFRunArrayInsert(a1, v41, a5, v6);
      }
      return;
    }

    uint64_t v24 = v19 - 1;
    if (v19 < 1)
    {
      if (!v11) {
        goto LABEL_40;
      }
    }

    else
    {
      if (v19 == v10[4])
      {
        uint64_t v25 = v10[5] - v10[2 * v24 + 6];
        v10[4] = v24;
        v10[5] = v25;
      }

      if (!v11)
      {
LABEL_37:
        uint64_t v29 = v13 + 1;
        if (v13 + 1 < v10[2])
        {
          uint64_t v30 = (uint64_t)&v10[2 * v29 + 6];
          uint64_t v32 = *(const void **)(v30 + 8);
          unint64_t v31 = (CFTypeRef *)(v30 + 8);
          if (CFEqual((CFTypeRef)v10[2 * v24 + 7], v32))
          {
            v10[2 * v24 + 6] += v10[2 * v29 + 6];
            CFRelease(*v31);
            uint64_t v6 = 0LL;
            ++v13;
            goto LABEL_41;
          }
        }

uint64_t __CFLocaleEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

uint64_t __CFLocaleCopyDescription(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "description"), "copy");
}

CFTypeID CFLocaleGetTypeID(void)
{
  return 55LL;
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)+[NSLocale _system](&OBJC_CLASS___NSLocale, "_system");
}

id _CFLocaleCopyNumberingSystemForLocaleIdentifier(uint64_t a1)
{
  return (id)+[NSLocale _numberingSystemForLocaleIdentifier:]( &OBJC_CLASS___NSLocale,  "_numberingSystemForLocaleIdentifier:",  a1);
}

id _CFLocaleCopyValidNumberingSystemsForLocaleIdentifier(uint64_t a1)
{
  return (id)+[NSLocale _validNumberingSystemsForLocaleIdentifier:]( &OBJC_CLASS___NSLocale,  "_validNumberingSystemsForLocaleIdentifier:",  a1);
}

id _CFLocaleCreateLocaleIdentiferByReplacingLanguageCodeAndScriptCode(uint64_t a1, uint64_t a2)
{
  return (id)+[NSLocale _localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:desiredComponents:]( &OBJC_CLASS___NSLocale,  "_localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:desiredComponents:",  a1,  a2);
}

id _CFLocaleCreateLikeCurrentWithBundleLocalizations(uint64_t a1, int a2)
{
  return (id)+[NSLocale _currentLocaleWithBundleLocalizations:disableBundleMatching:]( &OBJC_CLASS___NSLocale,  "_currentLocaleWithBundleLocalizations:disableBundleMatching:",  a1,  a2 != 0);
}

uint64_t _CFLocaleCopyAsIfCurrent(uint64_t a1)
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:]( &OBJC_CLASS___NSLocale,  "_newLocaleAsIfCurrent:overrides:disableBundleMatching:",  a1,  0LL,  0LL);
}

uint64_t _CFLocaleCopyAsIfCurrentWithOverrides(uint64_t a1, uint64_t a2)
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:]( &OBJC_CLASS___NSLocale,  "_newLocaleAsIfCurrent:overrides:disableBundleMatching:",  a1,  a2,  0LL);
}

uint64_t _CFLocaleCopyPreferred()
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:]( &OBJC_CLASS___NSLocale,  "_newLocaleAsIfCurrent:overrides:disableBundleMatching:",  0LL,  0LL,  1LL);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)(id)+[NSLocale _current](&OBJC_CLASS___NSLocale, "_current");
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  if (localeIdentifier) {
    return (CFLocaleRef)+[NSLocale _newLocaleWithIdentifier:]( &OBJC_CLASS___NSLocale,  "_newLocaleWithIdentifier:",  localeIdentifier);
  }
  else {
    return 0LL;
  }
}

id _CFLocaleCreateCopyWithNewCalendarIdentifier(uint64_t a1, void *a2)
{
  return (id)objc_msgSend(a2, "_localeWithNewCalendarIdentifier:");
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)-[__CFLocale objectForKey:](locale, "objectForKey:", key);
}

CFStringRef CFLocaleCopyDisplayNameForPropertyValue( CFLocaleRef displayLocale, CFLocaleKey key, CFStringRef value)
{
  return (CFStringRef)(id)-[__CFLocale displayNameForKey:value:]( displayLocale,  "displayNameForKey:value:",  key,  value);
}

CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers(void)
{
  return (CFArrayRef)+[NSLocale availableLocaleIdentifiers](&OBJC_CLASS___NSLocale, "availableLocaleIdentifiers");
}

CFArrayRef CFLocaleCopyISOLanguageCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOLanguageCodes](&OBJC_CLASS___NSLocale, "ISOLanguageCodes");
}

CFArrayRef CFLocaleCopyISOCountryCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOCountryCodes](&OBJC_CLASS___NSLocale, "ISOCountryCodes");
}

CFArrayRef CFLocaleCopyISOCurrencyCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOCurrencyCodes](&OBJC_CLASS___NSLocale, "ISOCurrencyCodes");
}

CFArrayRef CFLocaleCopyCommonISOCurrencyCodes(void)
{
  return (CFArrayRef)+[NSLocale commonISOCurrencyCodes](&OBJC_CLASS___NSLocale, "commonISOCurrencyCodes");
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(CFAllocatorRef allocator, uint32_t lcid)
{
  return (CFLocaleIdentifier) +[NSLocale localeIdentifierFromWindowsLocaleCode:]( &OBJC_CLASS___NSLocale,  "localeIdentifierFromWindowsLocaleCode:",  *(void *)&lcid);
}

uint32_t CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(CFLocaleIdentifier localeIdentifier)
{
  return +[NSLocale windowsLocaleCodeFromLocaleIdentifier:]( &OBJC_CLASS___NSLocale,  "windowsLocaleCodeFromLocaleIdentifier:",  localeIdentifier);
}

CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(CFStringRef isoLangCode)
{
  return +[NSLocale characterDirectionForLanguage:]( &OBJC_CLASS___NSLocale,  "characterDirectionForLanguage:",  isoLangCode);
}

CFLocaleLanguageDirection CFLocaleGetLanguageLineDirection(CFStringRef isoLangCode)
{
  return +[NSLocale lineDirectionForLanguage:](&OBJC_CLASS___NSLocale, "lineDirectionForLanguage:", isoLangCode);
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)(id)+[NSLocale _preferredLanguagesForCurrentUser:]( &OBJC_CLASS___NSLocale,  "_preferredLanguagesForCurrentUser:",  0LL);
}

id _CFLocaleCopyPreferredLanguagesForCurrentUser()
{
  return (id)+[NSLocale _preferredLanguagesForCurrentUser:]( &OBJC_CLASS___NSLocale,  "_preferredLanguagesForCurrentUser:",  1LL);
}

uint64_t _CFLocaleGetAppleICUNumberFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUNumberFormatStrings"];
}

uint64_t _CFLocaleGetAppleICUNumberSymbolsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUNumberSymbols"];
}

uint64_t _CFLocaleGetAppleFirstWeekdayPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleFirstWeekday"];
}

uint64_t _CFLocaleGetAppleICUDateTimeSymbolsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUDateTimeSymbols"];
}

uint64_t _CFLocaleGetAppleMinDaysInFirstWeekPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleMinDaysInFirstWeek"];
}

uint64_t _CFLocaleGetAppleICUForce24HourTimePref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUForce24HourTime"];
}

uint64_t _CFLocaleGetAppleICUForce12HourTimePref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUForce12HourTime"];
}

uint64_t _CFLocaleGetAppleICUDateFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUDateFormatStrings"];
}

uint64_t _CFLocaleGetAppleICUTimeFormatStringsPref(void *a1, const char *a2)
{
  return [a1 _prefForKey:@"AppleICUTimeFormatStrings"];
}

uint64_t __CFLocaleGetDoesNotRequireSpecialCaseHandling(void *a1)
{
  return [a1 _doesNotRequireSpecialCaseHandling];
}

id _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags(uint64_t a1)
{
  return (id)+[NSLocale _localeIdentifierByAddingLikelySubtags:]( &OBJC_CLASS___NSLocale,  "_localeIdentifierByAddingLikelySubtags:",  a1);
}

void __CFLocaleResetCurrent(int a1)
{
  if (a1) {
    +[NSLocale _resetCurrent](&OBJC_CLASS___NSLocale, "_resetCurrent");
  }
  dispatch_async(MEMORY[0x1895F8AE0], &__block_literal_global_13);
}

void _CFLocaleResetCurrent()
{
}

void __CFLocalePrefsChanged()
{
  v4[5] = *MEMORY[0x1895F89C0];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  __lastNote = *(void *)&Current;
  dispatch_time_t v1 = dispatch_time(0LL, 10000000LL);
  qos_class_t v2 = qos_class_main();
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(v2, 2uLL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = ____CFLocalePrefsChanged_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  *(CFAbsoluteTime *)&v4[4] = Current;
  dispatch_after(v1, global_queue, v4);
}

uint64_t _CFLocaleGetNoteCount()
{
  return __noteCount;
}

uint64_t (**__CFStringEncodingGetLatin5ConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_2) {
    __CFStringEncodingPrecomposeLatinCharacter_2 = (_UNKNOWN *)a2(4LL);
  }
  if (a1 > 1043)
  {
    if (a1 != 1044)
    {
      if (a1 == 1284) {
        return __CFConverterWindowsLatin5;
      }
      return 0LL;
    }

    return __CFConverterDOSTurkish;
  }

  else
  {
    if (a1 != 35)
    {
      if (a1 == 521) {
        return __CFConverterISOLatin5;
      }
      return 0LL;
    }

    return __CFConverterMacTurkish;
  }

uint64_t __CFToISOLatin5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xCF) {
    goto LABEL_2;
  }
  if (a2 < 0x11E)
  {
LABEL_11:
    if (a2 <= 0xFF && (a2 - 208 >= 0x2F || ((0x600100006001uLL >> (a2 + 48)) & 1) == 0))
    {
LABEL_2:
      *a3 = a2;
      return 1LL;
    }
  }

  else if (a2 <= 0x15F)
  {
    uint64_t v4 = (unsigned __int16 *)&ISOLatin5_from_uni;
    uint64_t v5 = (unsigned __int16 *)&unk_180C3651C;
    while (1)
    {
      uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
      uint64_t v7 = &v4[2 * v6];
      unsigned int v8 = *v7;
      if (v8 <= a2)
      {
        if (v8 >= a2)
        {
          LOBYTE(a2) = v4[2 * v6 + 1];
          goto LABEL_2;
        }

        uint64_t v4 = v7 + 2;
      }

      else
      {
        uint64_t v5 = v7 - 2;
      }

      if (v4 > v5) {
        goto LABEL_11;
      }
    }
  }

  return 0LL;
}

uint64_t __CFFromISOLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if (a2 > 239)
  {
    switch(a2)
    {
      case 240:
        LOWORD(a2) = 287;
        break;
      case 253:
        LOWORD(a2) = 305;
        break;
      case 254:
        LOWORD(a2) = 351;
        break;
    }
  }

  else
  {
    switch(a2)
    {
      case 208:
        LOWORD(a2) = 286;
        break;
      case 221:
        LOWORD(a2) = 304;
        break;
      case 222:
        LOWORD(a2) = 350;
        break;
    }
  }

  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0LL);
  int v10 = __CFToISOLatin5(v9, v9, &v13);
  uint64_t result = 0LL;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFIsValidCombiningCharacterForLatin5(int a1)
{
  else {
    return (__CFLatin5CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToMacTurkish(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      uint64_t v4 = (unsigned __int16 *)&MacTurkish_from_uni;
      uint64_t v5 = (unsigned __int16 *)&unk_180C36728;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          uint64_t v4 = v7 + 2;
        }

        else
        {
          uint64_t v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

BOOL __CFFromMacTurkish(__int16 a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 == 245 && (a1 & 0x200) != 0) {
      a2 = 65533;
    }
    else {
      a2 = MacTurkish_to_uni[a2 - 128];
    }
  }

  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0LL);
  if (v9 <= 0x7F)
  {
    LOBYTE(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v9;
    if (!(_BYTE)v9) {
      return 0LL;
    }
    goto LABEL_3;
  }

  BOOL v12 = (unsigned __int16 *)&MacTurkish_from_uni;
  char v13 = (unsigned __int16 *)&unk_180C36728;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    uint64_t v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0LL;
    }
  }

  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }

  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0LL;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFToDOSTurkish(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&DOSTurkish_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C36A1C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSTurkish(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSTurkish_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      unint64_t v11 = (unsigned __int16 *)&DOSTurkish_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C36A1C;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          unint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToWindowsLatin5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&WindowsLatin5_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C36D00;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromWindowsLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsLatin5_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      unint64_t v11 = (unsigned __int16 *)&WindowsLatin5_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C36D00;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          unint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

void __CFRunLoopDump()
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFStringRef v1 = CFCopyDescription(Current);
  CFShow(v1);
  CFRelease(v1);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRunLoopRef result = (CFRunLoopRef)_CFGetTSD(0xAu);
  if (!result)
  {
    CFStringRef v1 = pthread_self();
    return (CFRunLoopRef)_CFRunLoopGet0(v1);
  }

  return result;
}

__n128 __CFRunLoopModeDeallocate(uint64_t a1)
{
  qos_class_t v2 = *(const void **)(a1 + 96);
  if (v2) {
    CFRelease(v2);
  }
  char v3 = *(const void **)(a1 + 104);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 112);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 120);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 128);
  if (v6) {
    CFRelease(v6);
  }
  CFRelease(*(CFTypeRef *)(a1 + 80));
  uint64_t v7 = mach_port_mod_refs(*MEMORY[0x1895FBBE0], *(_DWORD *)(a1 + 136), 3u, -1);
  if ((_DWORD)v7)
  {
    uint64_t v8 = v7;
    mach_error_string(v7);
    CFLog(3LL, (uint64_t)@"error (%d - %s) while trying to free port set: %d", v9, v10, v11, v12, v13, v14, v8);
  }

  unsigned int v15 = *(dispatch_source_s **)(a1 + 152);
  if (v15)
  {
    dispatch_source_cancel(v15);
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  }

  unsigned int v16 = *(dispatch_object_s **)(a1 + 160);
  if (v16) {
    dispatch_release(v16);
  }
  if (*(_DWORD *)(a1 + 172)) {
    mk_timer_destroy();
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  result.n128_u64[0] = 0x7C7C7C7C7C7C7C7CLL;
  result.n128_u64[1] = 0x7C7C7C7C7C7C7C7CLL;
  *(__n128 *)(a1 + 16) = result;
  *(__n128 *)(a1 + 32) = result;
  *(__n128 *)(a1 + 4_Block_object_dispose(va, 8) = result;
  *(__n128 *)(a1 + 64) = result;
  *(__n128 *)(a1 + 80) = result;
  *(__n128 *)(a1 + 96) = result;
  *(__n128 *)(a1 + 112) = result;
  *(__n128 *)(a1 + 12_Block_object_dispose(va, 8) = result;
  *(__n128 *)(a1 + 144) = result;
  *(__n128 *)(a1 + 160) = result;
  *(__n128 *)(a1 + 176) = result;
  *(void *)(a1 + 192) = 0x7C7C7C7C7C7C7C7CLL;
  return result;
}

uint64_t __CFRunLoopModeEqual(uint64_t a1, uint64_t a2)
{
  return CFEqual(*(CFTypeRef *)(a1 + 80), *(CFTypeRef *)(a2 + 80));
}

CFHashCode __CFRunLoopModeHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 80));
}

__CFString *__CFRunLoopModeCopyDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0LL, @"<CFRunLoopMode %p [%p]>{name = %@, ", a1, v3, *(void *)(a1 + 80));
  CFStringAppendFormat(Mutable, 0LL, @"port set = 0x%x, ", *(unsigned int *)(a1 + 136));
  CFStringAppendFormat(Mutable, 0LL, @"queue = %p, ", *(void *)(a1 + 160));
  if (*(_BYTE *)(a1 + 168)) {
    uint64_t v4 = "fired";
  }
  else {
    uint64_t v4 = "not fired";
  }
  CFStringAppendFormat(Mutable, 0LL, @"source = %p (%s), ", *(void *)(a1 + 152), v4);
  CFStringAppendFormat(Mutable, 0LL, @"timer port = 0x%x, ", *(unsigned int *)(a1 + 172));
  __int128 v17 = *(_OWORD *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v6 = *(void *)(a1 + 120);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = mach_absolute_time();
  uint64_t v9 = *(void *)(a1 + 184);
  uint64_t v10 = mach_absolute_time();
  double v11 = __CFTSRToTimeInterval(v9 - v10);
  uint64_t v12 = *(void *)(a1 + 184);
  uint64_t v13 = *(void *)(a1 + 192);
  uint64_t v14 = mach_absolute_time();
  double v15 = __CFTSRToTimeInterval(v13 - v14);
  CFStringAppendFormat( Mutable,  0LL,  @"\n\tsources0 = %@,\n\tsources1 = %@,\n\tobservers = %@,\n\ttimers = %@,\n\tcurrently %0.09g (%lld) / soft deadline in: %0.09g sec (@ %lld) / hard deadline in: %0.09g sec (@ %lld)\n},\n",  v17,  v5,  v6,  *(void *)&Current,  v8,  *(void *)&v11,  v12,  *(void *)&v15,  *(void *)(a1 + 192));
  return Mutable;
}

void *__CFRunLoopDeallocate(mach_port_context_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  qos_class_t v2 = (unsigned __int8 *)(a1 + 680);
  kdebug_trace();
  atomic_store(0, v2);
  uint64_t v5 = (_opaque_pthread_t *)pthread_main_thread_np();
  uint64_t v6 = _CFRunLoopGet0b(v5);
  if (v6 == (const void *)a1)
  {
    __break(1u);
    goto LABEL_24;
  }

  uint64_t v7 = (unint64_t *)(a1 + 8);
  unint64_t v8 = atomic_load((unint64_t *)(a1 + 8));
  do
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 4, v7))
      {
        int v10 = 1;
        goto LABEL_9;
      }
    }

    else
    {
      __clrex();
    }

    int v10 = 0;
LABEL_9:
    unint64_t v8 = v9;
  }

  while (!v10);
  double v11 = *(const __CFSet **)(a1 + 632);
  if (v11)
  {
    CFSetApplyFunction(v11, (CFSetApplierFunction)__CFRunLoopCleanseSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateObservers, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateTimers, (void *)a1);
  }

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v12 = *(CFTypeRef **)(a1 + 640);
  if (v12)
  {
    do
    {
      uint64_t v13 = (CFTypeRef *)*v12;
      CFRelease(v12[1]);
      _Block_release(v12[2]);
      free(v12);
      uint64_t v12 = v13;
    }

    while (v13);
  }

  uint64_t v14 = *(const void **)(a1 + 616);
  if (v14) {
    CFRelease(v14);
  }
  double v15 = *(const void **)(a1 + 608);
  if (v15) {
    CFRelease(v15);
  }
  unsigned int v16 = *(const void **)(a1 + 632);
  if (v16) {
    CFRelease(v16);
  }
  mach_port_name_t v1 = *(_DWORD *)(a1 + 80);
  LODWORD(v6) = mach_port_destruct(*MEMORY[0x1895FBBE0], v1, -1, a1);
  if ((_DWORD)v6)
  {
LABEL_24:
    snprintf(__str, 0x100uLL, "*** Unable to destruct port. (0x%x, %d, %p) ***", v1, (_DWORD)v6, (const void *)a1);
    qword_18C539A70 = (uint64_t)__str;
    __break(1u);
  }

  *(_DWORD *)(a1 + 80) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  return memset((void *)(a1 + 16), 140, 0x2A0uLL);
}

__CFString *__CFRunLoopCopyDescription(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v4 = a1 + *(unsigned __int8 *)(a1 + 84);
  int v5 = *(unsigned __int8 *)(v4 + 85);
  int v6 = *(unsigned __int8 *)(v4 + 339);
  uint64_t v7 = *(void *)(a1 + 624);
  if (v7) {
    unint64_t v8 = *(const __CFString **)(v7 + 80);
  }
  else {
    unint64_t v8 = @"(none)";
  }
  if (v6) {
    unint64_t v9 = "true";
  }
  else {
    unint64_t v9 = "false";
  }
  if (v5) {
    int v10 = "true";
  }
  else {
    int v10 = "false";
  }
  CFStringAppendFormat( Mutable,  0LL,  @"<CFRunLoop %p [%p]>{wakeup port = 0x%x, stopped = %s, ignoreWakeUps = %s, \ncurrent mode = %@,\n",  a1,  v3,  *(unsigned int *)(a1 + 80),  v10,  v9,  v8);
  CFStringAppendFormat( Mutable,  0LL,  @"common modes = %@,\ncommon mode items = %@,\nmodes = %@}\n",  *(void *)(a1 + 608),  *(void *)(a1 + 616),  *(void *)(a1 + 632));
  return Mutable;
}

CFTypeID CFRunLoopGetTypeID(void)
{
  return 43LL;
}

const void *_CFRunLoopCacheLookup(_opaque_pthread_t *a1, int a2)
{
  CFAllocatorRef v3 = a1;
  if (pthread_equal(a1, 0LL)) {
    CFAllocatorRef v3 = (const void *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  uint64_t v4 = (const __CFDictionary *)__CFRunLoops;
  if (a2 && !__CFRunLoops)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v6 = pthread_main_thread_np();
    uint64_t v14 = (const void *)__CFRunLoopCreate(v6, v7, v8, v9, v10, v11, v12, v13);
    double v15 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v15, v14);
    while (!__ldaxr((unint64_t *)&__CFRunLoops))
    {
    }

    __clrex();
    CFRelease(Mutable);
LABEL_10:
    CFRelease(v14);
    os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
    uint64_t v4 = (const __CFDictionary *)__CFRunLoops;
  }

  if (v4) {
    int Value = CFDictionaryGetValue(v4, v3);
  }
  else {
    int Value = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

uint64_t __CFRunLoopCreate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t Instance = _CFRuntimeCreateInstance( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  0x2BuLL,  672LL,  0LL,  a5,  a6,  a7,  a8);
  if (!Instance) {
    return Instance;
  }
  pthread_mutexattr_init(&v16);
  pthread_mutexattr_settype(&v16, 2);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v16);
  pthread_mutexattr_destroy(&v16);
  mach_port_name_t name = 0;
  *(_OWORD *)&options.flags = xmmword_180C36E40;
  options.reserved[1] = 0LL;
  uint64_t result = mach_port_construct(*MEMORY[0x1895FBBE0], &options, Instance, &name);
  if ((_DWORD)result)
  {
    uint64_t v14 = snprintf( (char *)&v16,  0x100uLL,  "*** The system has no mach ports available. You may be able to diagnose which application(s) are using ports by using 'top' or Activity Monitor. (%d) ***",  result);
    qword_18C539A70 = (uint64_t)&v16;
    __THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__(v14);
  }

  mach_port_name_t v11 = name;
  *(_DWORD *)(Instance + 80) = name;
  if (v11)
  {
    *(_WORD *)(Instance + 84) = 0;
    *(_BYTE *)(Instance + 339) = 1;
    CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeSetCallBacks);
    *(void *)(Instance + 60_Block_object_dispose(va, 8) = Mutable;
    CFSetAddValue(Mutable, @"kCFRunLoopDefaultMode");
    *(void *)(Instance + 632) = CFSetCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeSetCallBacks);
    *(void *)(Instance + 600) = a1;
    *(_DWORD *)(Instance + 684) = 0;
    *(_BYTE *)(Instance + 681) = 1;
    uint64_t v13 = (const void *)__CFRunLoopCopyMode(Instance, @"kCFRunLoopDefaultMode", 1);
    if (v13) {
      CFRelease(v13);
    }
    return Instance;
  }

  __break(1u);
  return result;
}

const void *_CFRunLoopGetButDontCreateCurrent()
{
  uint64_t result = (const void *)_CFGetTSDCreateIfNeeded(0xAu, 0);
  if (!result)
  {
    mach_port_name_t v1 = pthread_self();
    return _CFRunLoopCacheLookup(v1, 0);
  }

  return result;
}

const void *_CFRunLoopIsCurrent(const void *result)
{
  if (result) {
    return (const void *)(_CFRunLoopGetButDontCreateCurrent() == result);
  }
  return result;
}

const void *_CFRunLoopGet0(_opaque_pthread_t *a1)
{
  mach_port_name_t v1 = a1;
  if (pthread_equal(a1, 0LL)) {
    mach_port_name_t v1 = (_opaque_pthread_t *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  qos_class_t v2 = (const __CFDictionary *)__CFRunLoops;
  if (!__CFRunLoops)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v4 = pthread_main_thread_np();
    uint64_t v12 = (const void *)__CFRunLoopCreate(v4, v5, v6, v7, v8, v9, v10, v11);
    uint64_t v13 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v13, v12);
    while (!__ldaxr((unint64_t *)&__CFRunLoops))
    {
    }

    __clrex();
    CFRelease(Mutable);
LABEL_9:
    CFRelease(v12);
    qos_class_t v2 = (const __CFDictionary *)__CFRunLoops;
  }

  int Value = CFDictionaryGetValue(v2, v1);
  if (Value)
  {
    uint64_t v23 = Value;
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }

  else
  {
    uint64_t v23 = (const void *)__CFRunLoopCreate((uint64_t)v1, v16, v17, v18, v19, v20, v21, v22);
    kdebug_trace();
    CFDictionarySetValue((CFMutableDictionaryRef)__CFRunLoops, v1, v23);
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (v23) {
      CFRelease(v23);
    }
  }

  uint64_t v24 = pthread_self();
  if (pthread_equal(v1, v24))
  {
    _CFSetTSD(0xAu, (uint64_t)v23, 0LL);
    if (!_CFGetTSD(0xBu)) {
      _CFSetTSD(0xBu, 3LL, (uint64_t)__CFFinalizeRunLoop);
    }
  }

  return v23;
}

void __CFFinalizeRunLoop(unint64_t a1)
{
  if (a1 > 1)
  {
    _CFSetTSD(0xBu, a1 - 1, (uint64_t)__CFFinalizeRunLoop);
    return;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  mach_port_name_t v1 = (const __CFDictionary *)__CFRunLoops;
  if (!__CFRunLoops) {
    goto LABEL_14;
  }
  pthread_t v2 = pthread_self();
  int Value = CFDictionaryGetValue(v1, v2);
  if (!Value)
  {
    uint64_t v13 = (__CFDictionary *)__CFRunLoops;
    pthread_t v14 = pthread_self();
    CFDictionaryRemoveValue(v13, v14);
LABEL_14:
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    return;
  }

  uint64_t v4 = (uint64_t)Value;
  CFRetain(Value);
  uint64_t v5 = (__CFDictionary *)__CFRunLoops;
  pthread_t v6 = pthread_self();
  CFDictionaryRemoveValue(v5, v6);
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  uint64_t v7 = (_opaque_pthread_t *)pthread_main_thread_np();
  if (_CFRunLoopGet0b(v7) != (const void *)v4)
  {
    uint64_t v8 = *(const void **)(v4 + 672);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(v4 + 672) = 0LL;
    }

    uint64_t v9 = CFRunLoopCopyAllModes((CFRunLoopRef)v4);
    CFIndex Count = CFArrayGetCount(v9);
    if (Count)
    {
      CFIndex v11 = Count - 1;
      do
      {
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v9, v11);
        __CFRunLoopRemoveAllSources(v4, ValueAtIndex);
        --v11;
      }

      while (v11 != -1);
    }

    __CFRunLoopRemoveAllSources(v4, @"kCFRunLoopCommonModes");
    CFRelease(v9);
  }

  atomic_store(1u, (unsigned __int8 *)(v4 + 680));
  CFRelease((CFTypeRef)v4);
}

const void *_CFRunLoopGet0b(_opaque_pthread_t *a1)
{
  mach_port_name_t v1 = a1;
  if (pthread_equal(a1, 0LL)) {
    mach_port_name_t v1 = (const void *)pthread_main_thread_np();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  if (__CFRunLoops) {
    int Value = CFDictionaryGetValue((CFDictionaryRef)__CFRunLoops, v1);
  }
  else {
    int Value = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  CFIndex Count = CFSetGetCount(*((CFSetRef *)rl + 79));
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  CFSetApplyFunction(*((CFSetRef *)rl + 79), (CFSetApplierFunction)__CFRunLoopGetModeName, Mutable);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  return Mutable;
}

uint64_t __CFRunLoopRemoveAllSources(uint64_t a1, __CFString *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (a2 == @"kCFRunLoopCommonModes")
  {
    if (*(void *)(a1 + 616))
    {
      uint64_t v12 = *(const __CFSet **)(a1 + 608);
      if (v12)
      {
        CFDictionaryRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
        if (Copy)
        {
          pthread_t v14 = Copy;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveSourcesFromCommonMode, (void *)a1);
          CFIndex v11 = v14;
LABEL_12:
          CFRelease(v11);
        }
      }
    }
  }

  else
  {
    uint64_t v4 = __CFRunLoopCopyMode(a1, a2, 0);
    if (v4)
    {
      uint64_t v5 = (const __CFSet **)v4;
      pthread_t v6 = (pthread_mutex_t *)(v4 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
      uint64_t v7 = v5[12];
      if (v7)
      {
        uint64_t v8 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        uint64_t context = a1;
        uint64_t v17 = a2;
        CFSetApplyFunction(v8, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v8);
      }

      uint64_t v9 = v5[13];
      if (v9)
      {
        uint64_t v10 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9);
        uint64_t context = a1;
        uint64_t v17 = a2;
        CFSetApplyFunction(v10, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v10);
      }

      pthread_mutex_unlock(v6);
      CFIndex v11 = v5;
      goto LABEL_12;
    }
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

uint64_t _CFRunLoopGet1(uint64_t a1)
{
  return *(void *)(a1 + 600);
}

CFTypeRef _CFRunLoopGet2(uint64_t a1)
{
  CFTypeRef v2 = *(CFTypeRef *)(a1 + 672);
  if (v2)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }

  else
  {
    Class v3 = objc_lookUpClass("NSRunLoop");
    if (v3 && (Class v4 = v3, (objc_opt_respondsToSelector() & 1) != 0))
    {
      uint64_t v5 = (const void *)-[objc_class _new:](v4, "_new:", a1);
      if (v5) {
        CFTypeRef v2 = CFRetain(v5);
      }
      else {
        CFTypeRef v2 = 0LL;
      }
      *(void *)(a1 + 672) = v2;
    }

    else
    {
      CFTypeRef v2 = *(CFTypeRef *)(a1 + 672);
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (!v2) {
      _CFRunLoopGet2_cold_1();
    }
  }

  return v2;
}

uint64_t _CFRunLoopGet2b(uint64_t a1)
{
  return *(void *)(a1 + 672);
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CFRunLoopGetMain_onceToken != -1) {
    dispatch_once(&CFRunLoopGetMain_onceToken, &__block_literal_global_14);
  }
  return (CFRunLoopRef)__CFRunLoopMain;
}

void __CFRunLoopGetMain_block_invoke()
{
  CFPropertyListRef v0 = (_opaque_pthread_t *)pthread_main_thread_np();
  __CFRunLoopMain = (uint64_t)_CFRunLoopGet0(v0);
  __CFRuntimeSetImmortal(__CFRunLoopMain);
}

BOOL _CFRunLoopCurrentIsMain()
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_t v0 = (pthread_t)pthread_main_thread_np();
  return v0 == pthread_self();
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  Class v3 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  uint64_t v4 = *((void *)rl + 78);
  if (v4) {
    uint64_t v5 = (const __CFString *)CFRetain(*(CFTypeRef *)(v4 + 80));
  }
  else {
    uint64_t v5 = 0LL;
  }
  pthread_mutex_unlock(v3);
  return v5;
}

void __CFRunLoopGetModeName(uint64_t a1, CFMutableArrayRef theArray)
{
}

uint64_t _CFRunLoop01(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = CFSetContainsValue(*(CFSetRef *)(a1 + 608), a2);
  pthread_mutex_unlock(v4);
  return v5;
}

void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFRunLoopMode mode)
{
  context[2] = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  }
  unsigned __int8 v5 = atomic_load(__CFMainThreadHasExited);
  if ((v5 & 1) != 0)
  {
    BOOL v9 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v9 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v6 = atomic_load((unint64_t *)rl + 1);
  if ((v6 & 4) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (!CFSetContainsValue(*((CFSetRef *)rl + 76), mode))
    {
      uint64_t v7 = (const __CFSet *)*((void *)rl + 77);
      if (v7)
      {
        CFDictionaryRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
        if (Copy)
        {
          context[0] = rl;
          context[1] = mode;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemsToCommonMode, context);
          CFRelease(Copy);
        }
      }

      else
      {
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
      }
    }

    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

void __CFRunLoopAddItemsToCommonMode(void *a1, uint64_t a2)
{
  unint64_t v4 = *(__CFRunLoop **)a2;
  Class v3 = *(const __CFString **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(a1);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)a1, v3);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)a1, v3);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)a1, v3);
      break;
  }

BOOL _CFRunLoopFinished(uint64_t a1, const __CFString *a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = __CFRunLoopCopyMode(a1, a2, 0);
  if (v5)
  {
    char v6 = (const void *)v5;
    uint64_t v7 = (pthread_mutex_t *)(v5 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
    BOOL v8 = __CFRunLoopModeIsEmpty(a1, (uint64_t)v6) != 0;
    pthread_mutex_unlock(v7);
    CFRelease(v6);
  }

  else
  {
    BOOL v8 = 1LL;
  }

  pthread_mutex_unlock(v4);
  return v8;
}

uint64_t __CFRunLoopCopyMode(uint64_t a1, const __CFString *a2, int a3)
{
  kern_return_t v14;
  int sig;
  mach_port_name_t port_4CF;
  mach_port_name_t v17;
  dispatch_source_s *v18;
  mach_port_name_t v19;
  mach_port_name_t v20;
  void handler[5];
  pthread_mutexattr_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD value[5];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v33 = 0LL;
  unint64_t v31 = 0u;
  uint64_t v32 = 0u;
  uint64_t v29 = 0u;
  uint64_t v30 = 0u;
  uint64_t v27 = 0u;
  int v28 = 0u;
  CFTypeRef v26 = 0u;
  memset(value, 0, sizeof(value));
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)value, 0x2CuLL);
  *(void *)&CFTypeRef v26 = a2;
  char v6 = CFSetGetValue(*(CFSetRef *)(a1 + 632), value);
  uint64_t Instance = (uint64_t)v6;
  if (v6)
  {
    CFRetain(v6);
  }

  else if (a3)
  {
    uint64_t Instance = _CFRuntimeCreateInstance( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  0x2CuLL,  184LL,  0LL,  v7,  v8,  v9,  v10);
    if (Instance)
    {
      pthread_mutexattr_init(&v22);
      pthread_mutexattr_settype(&v22, 2);
      pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v22);
      pthread_mutexattr_destroy(&v22);
      *(void *)(Instance + 80) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
      uint64_t v13 = (ipc_space_t *)MEMORY[0x1895FBBE0];
      pthread_t v14 = mach_port_allocate(*MEMORY[0x1895FBBE0], 3u, (mach_port_name_t *)&v22);
      if (v14) {
        __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(v14);
      }
      sig = v22.__sig;
      *(_BYTE *)(Instance + 16_Block_object_dispose(va, 8) = 0;
      *(_DWORD *)(Instance + 136) = sig;
      *(void *)(Instance + 184) = -1LL;
      *(void *)(Instance + 192) = -1LL;
      *(void *)(Instance + 160) = _dispatch_runloop_root_queue_create_4CF();
      port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
      if (!port_4CF) {
        __CFRunLoopCopyMode_cold_1();
      }
      uint64_t v17 = port_4CF;
      uint64_t v18 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *(dispatch_queue_t *)(Instance + 160));
      *(void *)(Instance + 152) = v18;
      v22.__sig = 0LL;
      *(void *)v22.__opaque = &v22;
      uint64_t v23 = 0x2020000000LL;
      uint64_t v24 = Instance + 168;
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3221225472LL;
      handler[2] = ____CFRunLoopCopyMode_block_invoke;
      handler[3] = &unk_18999BD28;
      handler[4] = &v22;
      dispatch_source_set_event_handler(v18, handler);
      dispatch_source_set_timer( *(dispatch_source_t *)(Instance + 152),  0xFFFFFFFFFFFFFFFFLL,  0xFFFFFFFFFFFFFFFFLL,  0x141uLL);
      dispatch_resume(*(dispatch_object_t *)(Instance + 152));
      if (mach_port_insert_member(*v13, v17, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_5();
      }
      uint64_t v19 = mk_timer_create();
      *(_DWORD *)(Instance + 172) = v19;
      if (!v19) {
        __CFRunLoopCopyMode_cold_2();
      }
      if (mach_port_insert_member(*v13, v19, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_4();
      }
      uint64_t v20 = *(_DWORD *)(a1 + 80);
      if (!v20 || mach_port_insert_member(*v13, v20, *(_DWORD *)(Instance + 136))) {
        __CFRunLoopCopyMode_cold_3();
      }
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 632), (const void *)Instance);
      _Block_object_dispose(&v22, 8);
    }
  }

  else
  {
    return 0LL;
  }

  return Instance;
}

void sub_180AC695C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __CFRunLoopModeIsEmpty(uint64_t a1, uint64_t a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    return 0LL;
  }

  unint64_t v4 = *(const __CFSet **)(a2 + 96);
  if (v4)
  {
    if (CFSetGetCount(v4) > 0) {
      return 0LL;
    }
  }

  uint64_t v5 = *(const __CFSet **)(a2 + 104);
  if (v5)
  {
    if (CFSetGetCount(v5) > 0) {
      return 0LL;
    }
  }

  char v6 = *(const __CFArray **)(a2 + 120);
  if (v6)
  {
    if (CFArrayGetCount(v6) > 0) {
      return 0LL;
    }
  }

  uint64_t v8 = *(void **)(a1 + 640);
  while (v8)
  {
    uint64_t v9 = v8;
    uint64_t v8 = (void *)*v8;
    CFTypeID v10 = CFGetTypeID((CFTypeRef)v9[1]);
    CFIndex v11 = (const void *)v9[1];
    uint64_t v12 = *(const void **)(a2 + 80);
    if (v10 == 7)
    {
      if (CFEqual(v11, v12)) {
        return 0LL;
      }
      if (CFEqual((CFTypeRef)v9[1], @"kCFRunLoopCommonModes")) {
        goto LABEL_23;
      }
    }

    else
    {
      if (CFSetContainsValue((CFSetRef)v11, v12)) {
        return 0LL;
      }
      if (CFSetContainsValue((CFSetRef)v9[1], @"kCFRunLoopCommonModes"))
      {
LABEL_23:
      }
    }
  }

  return 1LL;
}

uint64_t CFRunLoopRunSpecific(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  v22[5] = *MEMORY[0x1895F89C0];
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v8 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v8);
  }
  unsigned __int8 v9 = atomic_load(__CFMainThreadHasExited);
  if ((v9 & 1) != 0)
  {
    BOOL v21 = __CFRunLoopMain && __CFRunLoopMain == a1;
    if (v21 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!a2 || a2 == @"kCFRunLoopCommonModes" || CFEqual(a2, @"kCFRunLoopCommonModes"))
  {
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __CFRunLoopRunSpecific_block_invoke;
    v22[3] = &__block_descriptor_40_e5_v8__0l;
    v22[4] = a2;
    if (CFRunLoopRunSpecific_onceToken != -1) {
      dispatch_once(&CFRunLoopRunSpecific_onceToken, v22);
    }
    return 1LL;
  }

  char v12 = atomic_load((unint64_t *)(a1 + 8));
  if ((v12 & 4) != 0) {
    return 1LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v13 = __CFRunLoopCopyMode(a1, a2, 0);
  if (!v13)
  {
LABEL_18:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return 1LL;
  }

  uint64_t v14 = v13;
  if (__CFRunLoopModeIsEmpty(a1, v13))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 16));
    CFRelease((CFTypeRef)v14);
    goto LABEL_18;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v14 + 16));
  uint64_t v15 = *(unsigned __int8 *)(a1 + 84);
  uint64_t v16 = v15 + 1;
  *(_BYTE *)(a1 + 84) = v16;
  uint64_t v17 = a1 + v16;
  *(_BYTE *)(v17 + 85) = 0;
  *(_BYTE *)(v17 + 339) = 0;
  uint64_t v18 = *(void *)(a1 + 624);
  *(void *)(a1 + 624) = v14;
  if ((*(_BYTE *)(v14 + 144) & 1) != 0) {
    __CFRunLoopDoObservers(a1, v14, 1LL);
  }
  uint64_t v19 = (_DWORD *)CFRunLoopRunSpecific_runloopNestingLevel();
  ++*v19;
  kdebug_trace();
  uint64_t v20 = __CFRunLoopRun(a1, v14, a3, *v19, a4);
  kdebug_trace();
  --*v19;
  if ((*(_BYTE *)(v14 + 144) & 0x80) != 0) {
    __CFRunLoopDoObservers(a1, v14, 128LL);
  }
  uint64_t v10 = v20;
  if (!*(_BYTE *)(a1 + 84)) {
    CFRunLoopRunSpecific_cold_2();
  }
  --*(_BYTE *)(a1 + 84);
  pthread_mutex_unlock((pthread_mutex_t *)(v14 + 16));
  CFRelease((CFTypeRef)v14);
  *(void *)(a1 + 624) = v18;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v10;
}

void sub_180AC6DF4(_Unwind_Exception *a1)
{
}

uint64_t __CFRunLoopRunSpecific_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = CFLog( 3LL,  (uint64_t)@"invalid mode '%@' provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution.",  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 32));
  return _CFRunLoopError_RunCalledWithInvalidMode(v8);
}

uint64_t __CFRunLoopDoObservers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t result = *(void *)(a2 + 112);
  if (result)
  {
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t v8 = result;
      __int128 v37 = &v32;
      unint64_t v9 = MEMORY[0x1895F8858](result, v7);
      CFIndex v11 = (char *)&v32 - v10;
      int v36 = (char *)&v32 - v10;
      if (v9 >= 0x401) {
        CFIndex v11 = (char *)malloc(8 * v8);
      }
      uint64_t v12 = 0LL;
      for (CFIndex i = 0LL; i != v8; ++i)
      {
        ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 112), i);
        if ((ValueAtIndex[12] & a3) != 0)
        {
          char v15 = atomic_load(ValueAtIndex + 1);
          if ((v15 & 8) != 0)
          {
            char v16 = atomic_load(ValueAtIndex + 1);
            if ((v16 & 1) == 0) {
              *(void *)&v11[8 * v12++] = CFRetain(ValueAtIndex);
            }
          }
        }
      }

      uint64_t v34 = (pthread_mutex_t *)(a2 + 16);
      uint64_t v35 = a2;
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
      uint64_t v33 = (pthread_mutex_t *)(a1 + 16);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      if (v12 >= 1)
      {
        uint64_t v17 = 0LL;
        uint64_t v38 = a1;
        while (1)
        {
          uint64_t v18 = *(void *)&v11[8 * v17];
          pthread_mutex_lock((pthread_mutex_t *)(v18 + 16));
          uint64_t v19 = (unint64_t *)(v18 + 8);
          char v20 = atomic_load((unint64_t *)(v18 + 8));
          if ((v20 & 8) != 0) {
            break;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v18 + 16));
LABEL_39:
          CFRelease((CFTypeRef)v18);
          if (++v17 == v12) {
            goto LABEL_40;
          }
        }

        BOOL v21 = v11;
        char v22 = atomic_load(v19);
        unint64_t v23 = atomic_load(v19);
        while (1)
        {
          unint64_t v24 = __ldaxr(v19);
          if (v24 != v23) {
            break;
          }
          if (__stlxr(v23 | 1, v19)) {
            goto LABEL_24;
          }
          int v25 = 1;
LABEL_25:
          unint64_t v23 = v24;
          if (v25)
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v18 + 16));
            CFTypeRef v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v18 + 112);
            uint64_t v27 = *(void *)(v18 + 128);
            if (a1 && !*(_BYTE *)(a1 + 681)) {
              int v28 = 0LL;
            }
            else {
              int v28 = (void *)_CFAutoreleasePoolPush();
            }
            kdebug_trace();
            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(v26, v18, a3, v27);
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v28);
            if ((v22 & 2) == 0) {
              CFRunLoopObserverInvalidate((CFRunLoopObserverRef)v18);
            }
            unint64_t v29 = atomic_load(v19);
            a1 = v38;
            CFIndex v11 = v21;
            while (1)
            {
              unint64_t v30 = __ldaxr(v19);
              if (v30 != v29) {
                break;
              }
              if (__stlxr(v29 & 0xFFFFFFFFFFFFFFFELL, v19)) {
                goto LABEL_37;
              }
              char v31 = 1;
LABEL_38:
              unint64_t v29 = v30;
              if ((v31 & 1) != 0) {
                goto LABEL_39;
              }
            }

            __clrex();
LABEL_37:
            char v31 = 0;
            goto LABEL_38;
          }
        }

        __clrex();
LABEL_24:
        int v25 = 0;
        goto LABEL_25;
      }

uint64_t __CFRunLoopRun(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  uint64_t v10 = mach_absolute_time();
  uint64_t v11 = a1 + *(unsigned __int8 *)(a1 + 84);
  int v13 = *(unsigned __int8 *)(v11 + 85);
  uint64_t v12 = (_BYTE *)(v11 + 85);
  if (v13)
  {
    *uint64_t v12 = 0;
    return 2LL;
  }

  if (*(_BYTE *)(a2 + 88))
  {
    *(_BYTE *)(a2 + 8_Block_object_dispose(va, 8) = 0;
    return 2LL;
  }

  uint64_t v16 = v10;
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    mach_port_name_t main_queue_port_4CF = _dispatch_get_main_queue_port_4CF();
  }

  else
  {
    mach_port_name_t main_queue_port_4CF = 0;
  }

  if (!*(void *)(a2 + 160)) {
    goto LABEL_14;
  }
  int port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
  if (!port_4CF)
  {
    qword_18C539A70 = (uint64_t)"Unable to get port for run loop mode queue";
    __break(1u);
LABEL_14:
    int port_4CF = 0;
  }

  int v67 = a3;
  if (a5 <= 0.0)
  {
    source = 0LL;
    uint64_t v19 = 0LL;
  }

  else if (a5 <= 504911232.0)
  {
    uint64_t v19 = __CFTimeIntervalToTSR(a5) + v16;
    if (pthread_main_np() == 1) {
      uint64_t v20 = qos_class_main();
    }
    else {
      uint64_t v20 = 17LL;
    }
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(v20, 2uLL);
    char v22 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, global_queue);
    CFRetain((CFTypeRef)a1);
    uint64_t v23 = MEMORY[0x1895F87A8];
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = ____CFRunLoopRun_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = a1;
    dispatch_source_set_event_handler(v22, handler);
    v73[0] = v23;
    v73[1] = 3221225472LL;
    v73[2] = ____CFRunLoopRun_block_invoke_2;
    v73[3] = &__block_descriptor_40_e5_v8__0l;
    v73[4] = a1;
    dispatch_source_set_cancel_handler(v22, v73);
    double v24 = __CFTSRToTimeInterval(v16);
    dispatch_time_t v25 = dispatch_time(1uLL, (unint64_t)((v24 + a5) * 1000000000.0));
    dispatch_source_set_timer(v22, v25, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
    source = v22;
    dispatch_resume(v22);
  }

  else
  {
    source = 0LL;
    uint64_t v19 = -1LL;
  }

  uint64_t v60 = v19;
  BOOL v62 = v19 != 0;
  CFTypeRef v26 = (unint64_t *)(a1 + 8);
  uint64_t v63 = (pthread_mutex_t *)(a1 + 16);
  uint64_t v64 = (pthread_mutex_t *)(a2 + 16);
  mach_port_name_t name = main_queue_port_4CF;
  int v27 = 1;
  uint64_t v61 = a4;
  do
  {
    __cftrace_runloop_trace_iteration_start(a4, (__CFRunLoop *)a1);
    id v71 = 0LL;
    voucher_mach_msg_state_t state = (voucher_mach_msg_state_t)-1LL;
    uint64_t v70 = 0LL;
    mach_port_t v69 = 0;
    mach_port_name_t v28 = *(_DWORD *)(a2 + 136);
    *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 0;
    uint64_t v29 = *(void *)(a2 + 144);
    if ((v29 & 2) != 0)
    {
      __CFRunLoopDoObservers(a1, a2, 2LL);
      uint64_t v29 = *(void *)(a2 + 144);
    }

    if ((v29 & 4) != 0) {
      __CFRunLoopDoObservers(a1, a2, 4LL);
    }
    __CFRunLoopDoBlocks(a1, a2);
    int v30 = v62;
    int v65 = __CFRunLoopDoSources0(a1, a2, v67);
    if (v65)
    {
      __CFRunLoopDoBlocks(a1, a2);
      int v30 = 0;
    }

    if (!name
      || v27
      || (uint64_t v70 = v78, !__CFRunLoopServiceMachPort(name, (mach_msg_header_t **)&v70, &v69, 0, &state, 0LL)))
    {
      if (v30)
      {
        if ((*(_BYTE *)(a2 + 144) & 0x20) != 0) {
          __CFRunLoopDoObservers(a1, a2, 32LL);
        }
        unint64_t v31 = atomic_load(v26);
        while (1)
        {
          unint64_t v32 = __ldaxr(v26);
          if (v32 != v31) {
            break;
          }
          if (__stlxr(v31 | 2, v26)) {
            goto LABEL_41;
          }
          int v33 = 1;
LABEL_42:
          unint64_t v31 = v32;
          if (v33)
          {
            if (name) {
              mach_port_insert_member(*MEMORY[0x1895FBBE0], name, v28);
            }
            pthread_mutex_unlock(v64);
            pthread_mutex_unlock(v63);
            double Current = CFAbsoluteTimeGetCurrent();
            goto LABEL_56;
          }
        }

        __clrex();
LABEL_41:
        int v33 = 0;
        goto LABEL_42;
      }

      unint64_t v35 = atomic_load(v26);
      while (1)
      {
        unint64_t v36 = __ldaxr(v26);
        if (v36 != v35) {
          break;
        }
        if (__stlxr(v35 | 2, v26)) {
          goto LABEL_51;
        }
        int v37 = 1;
LABEL_52:
        unint64_t v35 = v36;
        if (v37)
        {
          if (name) {
            mach_port_insert_member(*MEMORY[0x1895FBBE0], name, v28);
          }
          pthread_mutex_unlock(v64);
          pthread_mutex_unlock(v63);
          double Current = 0.0;
LABEL_56:
          kdebug_trace();
          kdebug_trace();
          uint64_t v70 = v78;
          __CFRunLoopServiceMachPort(v28, (mach_msg_header_t **)&v70, &v69, v30 << 31 >> 31, &state, &v71);
          if (port_4CF && v69 == port_4CF)
          {
            while (1)
            {
              while ((_dispatch_runloop_root_queue_perform_4CF() & 1) != 0)
                ;
              if (*(_BYTE *)(a2 + 168)) {
                break;
              }
              if (v70 && v70 != v78) {
                free(v70);
              }
              uint64_t v70 = v78;
              __CFRunLoopServiceMachPort(v28, (mach_msg_header_t **)&v70, &v69, v30 << 31 >> 31, &state, &v71);
              if (v69 != port_4CF) {
                goto LABEL_66;
              }
            }

            *(_BYTE *)(a2 + 16_Block_object_dispose(va, 8) = 0;
          }

LABEL_87:
    *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
    uint64_t v44 = (const void *)v69;
    if (!v69)
    {
      int v27 = 0;
      goto LABEL_115;
    }

    if (v69 != *(_DWORD *)(a1 + 80))
    {
      if (port_4CF && v69 == port_4CF)
      {
        uint64_t v45 = mach_absolute_time();
        if (!__CFRunLoopDoTimers(a1, a2, v45)) {
          goto LABEL_99;
        }
      }

      else
      {
        int v46 = *(_DWORD *)(a2 + 172);
        if (v46 && v69 == v46)
        {
          uint64_t v47 = mach_absolute_time();
          if (!__CFRunLoopDoTimers(a1, a2, v47))
          {
            *(void *)(a2 + 184) = -1LL;
            *(void *)(a2 + 192) = -1LL;
LABEL_99:
            __CFArmNextTimerInMode(a2);
          }
        }

        else
        {
          if (v69 == name)
          {
            pthread_mutex_unlock(v64);
            pthread_mutex_unlock(v63);
            _CFSetTSD(4u, 6LL, 0LL);
            uint64_t v66 = (void *)_CFAutoreleasePoolPush();
            kdebug_trace();
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v66);
            _CFSetTSD(4u, 0LL, 0LL);
            pthread_mutex_lock(v63);
            pthread_mutex_lock(v64);
            int v65 = 1;
            int v27 = 1;
            goto LABEL_115;
          }

          kdebug_trace();
          uint64_t v48 = _CFSetTSD(0xDu, (uint64_t)v71, MEMORY[0x1895FC5F0]);
          if ((__CF_FORK_STATE & 2) == 0) {
            __CF_USED();
          }
          if ((__CF_FORK_STATE & 1) != 0) {
            __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
          }
          uint64_t v49 = *(const __CFDictionary **)(a2 + 128);
          if (v49 && CFDictionaryGetValue(v49, v44))
          {
            *(void *)msg = 0LL;
            int v50 = __CFRunLoopDoSource1(a1, a2);
            uint64_t v51 = *(void **)msg;
            if (*(void *)msg)
            {
              mach_msg(*(mach_msg_header_t **)msg, 1, *(_DWORD *)(*(void *)msg + 4LL), 0, 0, 0, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v51);
            }

            v65 |= v50;
          }

          else
          {
            uint64_t v52 = (os_log_s *)_CFOSLog();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              uint64_t v58 = *(void *)(a2 + 80);
              *(_DWORD *)msg = 138412546;
              *(void *)&msg[4] = v58;
              __int16 v76 = 1024;
              int v77 = (int)v44;
              _os_log_error_impl( &dword_180A4C000,  v52,  OS_LOG_TYPE_ERROR,  "__CFRunLoopModeFindSourceForMachPort returned NULL for mode '%@' livePort: %u",  msg,  0x12u);
            }
          }

          _CFSetTSD(0xDu, v48, MEMORY[0x1895FC5F0]);
          kdebug_trace();
        }
      }

      int v27 = 0;
      goto LABEL_115;
    }

    int v27 = 0;
LABEL_115:
    if (v70 && v70 != v78) {
      free(v70);
    }
    __CFRunLoopDoBlocks(a1, a2);
    if (v67 && v65)
    {
      BOOL v53 = 0;
      uint64_t v14 = 4LL;
      goto LABEL_128;
    }

    if (v60 < mach_absolute_time())
    {
      BOOL v53 = 0;
      uint64_t v14 = 3LL;
      goto LABEL_128;
    }

    uint64_t v54 = a1 + *(unsigned __int8 *)(a1 + 84);
    int v56 = *(unsigned __int8 *)(v54 + 85);
    CFRange v55 = (_BYTE *)(v54 + 85);
    if (v56)
    {
      BOOL v53 = 0;
      *CFRange v55 = 0;
LABEL_127:
      uint64_t v14 = 2LL;
      goto LABEL_128;
    }

    if (*(_BYTE *)(a2 + 88))
    {
      BOOL v53 = 0;
      *(_BYTE *)(a2 + 8_Block_object_dispose(va, 8) = 0;
      goto LABEL_127;
    }

    int IsEmpty = __CFRunLoopModeIsEmpty(a1, a2);
    BOOL v53 = IsEmpty == 0;
    uint64_t v14 = IsEmpty != 0;
LABEL_128:
    voucher_mach_msg_revert(state);

    kdebug_trace();
  }

  while (v53);
  if (source)
  {
    dispatch_source_cancel(source);
    dispatch_release(source);
  }

  return v14;
}

void CFRunLoopRun(void)
{
  do
  {
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    int v1 = CFRunLoopRunSpecific((uint64_t)Current, @"kCFRunLoopDefaultMode", 0, 1.0e10);
    if ((__CF_FORK_STATE & 2) == 0) {
      __CF_USED();
    }
    if ((__CF_FORK_STATE & 1) != 0) {
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
  }

  while ((v1 - 3) < 0xFFFFFFFE);
}

CFRunLoopRunResult CFRunLoopRunInMode( CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  int v3 = returnAfterSourceHandled;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  return CFRunLoopRunSpecific((uint64_t)Current, mode, v3, seconds);
}

CFAbsoluteTime CFRunLoopGetNextTimerFireDate(CFRunLoopRef rl, CFRunLoopMode mode)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  }
  unsigned __int8 v5 = atomic_load(__CFMainThreadHasExited);
  if ((v5 & 1) != 0)
  {
    BOOL v14 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v14 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v6 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  uint64_t v7 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (v7)
  {
    uint64_t v8 = (CFArrayRef *)v7;
    unint64_t v9 = (pthread_mutex_t *)(v7 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
    uint64_t v10 = v8[15];
    double NextFireDate = 0.0;
    if (v10)
    {
      if (CFArrayGetCount(v10) >= 1)
      {
        ValueAtIndex = (__CFRunLoopTimer *)CFArrayGetValueAtIndex(v8[15], 0LL);
        if (ValueAtIndex) {
          double NextFireDate = CFRunLoopTimerGetNextFireDate(ValueAtIndex);
        }
      }
    }

    pthread_mutex_unlock(v9);
    CFRelease(v8);
  }

  else
  {
    double NextFireDate = 0.0;
  }

  pthread_mutex_unlock(v6);
  return NextFireDate;
}

CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer _cffireTime](timer, "_cffireTime");
  }

  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
    char v3 = atomic_load((unint64_t *)timer + 1);
    double v4 = 0.0;
    if ((v3 & 8) != 0) {
      double v4 = *((double *)timer + 13);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
    return v4;
  }

  return result;
}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if ((v3 & 1) != 0)
  {
    BOOL v6 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v6 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v4 = atomic_load((unint64_t *)rl + 1);
  return (v4 >> 1) & 1;
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  mach_msg_return_t v5;
  mach_msg_header_t v6;
  uint64_t v7;
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if ((v3 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (*((_BYTE *)rl + *((unsigned __int8 *)rl + 84) + 339))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

  else
  {
    kdebug_trace();
    mach_port_t v4 = *((_DWORD *)rl + 20);
    *(void *)&v6.msgh_bits = 0x1800000013LL;
    v6.msgh_remote_port = v4;
    v6.msgh_local_port = 0;
    v6.msgh_id = 0;
    unsigned __int8 v5 = mach_msg(&v6, 17, 0x18u, 0, 0, 0, 0);
    __CFMachMessageCheckForAndDestroyUnsentMessage(v5, &v6);
    if (v5)
    {
      if (v5 != 268435460) {
        CFRunLoopWakeUp_cold_1();
      }
    }

    kdebug_trace();
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

void CFRunLoopStop(CFRunLoopRef rl)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  }
  unsigned __int8 v3 = atomic_load(__CFMainThreadHasExited);
  if ((v3 & 1) != 0)
  {
    BOOL v4 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v4 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (*((void *)rl + 78))
  {
    *((_BYTE *)rl + *((unsigned __int8 *)rl + 84) + 85) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    CFRunLoopWakeUp(rl);
  }

  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

void _CFRunLoopStopMode(uint64_t a1, const __CFString *a2)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v4 = __CFRunLoopCopyMode(a1, a2, 1);
  if (v4)
  {
    unsigned __int8 v5 = (_BYTE *)v4;
    BOOL v6 = (pthread_mutex_t *)(v4 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
    v5[88] = 1;
    pthread_mutex_unlock(v6);
    CFRelease(v5);
  }

  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  CFRunLoopWakeUp((CFRunLoopRef)a1);
}

uint64_t _CFRunLoopModeContainsMode()
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return 0LL;
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
  }
  if (CFGetTypeID(mode) == 7)
  {
    CFDictionaryRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFStringRef)mode);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    unint64_t v9 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, Copy, 1);
    if (v9) {
      CFRelease(v9);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

  else
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(mode))
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)mode);
      uint64_t v12 = (const void **)malloc(8 * Count);
      v24.CFIndex location = 0LL;
      v24.CFIndex length = Count;
      CFArrayGetValues((CFArrayRef)mode, v24, v12);
      CFDictionaryRef Copy = (const __CFString *)CFSetCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v12,  Count,  &kCFTypeSetCallBacks);
      int v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (Count >= 1)
      {
        BOOL v14 = (const __CFString **)v12;
        do
        {
          char v15 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v14, 1);
          if (v15) {
            CFRelease(v15);
          }
          ++v14;
          --Count;
        }

        while (Count);
      }
    }

    else
    {
      CFTypeID v16 = CFSetGetTypeID();
      if (v16 != CFGetTypeID(mode))
      {
        CFDictionaryRef Copy = 0LL;
        goto LABEL_26;
      }

      uint64_t v17 = CFSetGetCount((CFSetRef)mode);
      uint64_t v12 = (const void **)malloc(8 * v17);
      CFSetGetValues((CFSetRef)mode, v12);
      CFDictionaryRef Copy = (const __CFString *)CFSetCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v12,  v17,  &kCFTypeSetCallBacks);
      int v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (v17 >= 1)
      {
        uint64_t v18 = (const __CFString **)v12;
        do
        {
          uint64_t v19 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v18, 1);
          if (v19) {
            CFRelease(v19);
          }
          ++v18;
          --v17;
        }

        while (v17);
      }
    }

    pthread_mutex_unlock(v13);
    free(v12);
  }

uint64_t _CFRunLoopPerCalloutAutoreleasepoolEnabled()
{
  return *((unsigned __int8 *)CFRunLoopGetCurrent() + 681);
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled(uint64_t a1)
{
  *((_BYTE *)CFRunLoopGetCurrent() + 681) = a1;
  return a1;
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v17 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v17 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    BOOL v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14)
    {
      Boolean v13 = CFSetContainsValue(v14, source);
      goto LABEL_19;
    }

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    if (*((void *)source + 13) == 1LL)
    {
      mach_port_name_t v9 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
      ptype[0] = 0;
      uint64_t v10 = mach_port_type(*MEMORY[0x1895FBBE0], v9, ptype);
      if (!(_DWORD)v10 && (ptype[0] & 0x20000) == 0)
      {
        v31[0] = MEMORY[0x1895F87A8];
        v31[1] = 3221225472LL;
        v31[2] = __CFRunLoopAddSource_block_invoke;
        v31[3] = &__block_descriptor_56_e5_v8__0l;
        v31[4] = source;
        void v31[5] = rl;
        v31[6] = mode;
        if (CFRunLoopAddSource_onceToken != -1) {
          dispatch_once(&CFRunLoopAddSource_onceToken, v31);
        }
        __CFRunLoopError_AddingSourceLackingReceiveRight(v10, v11, v12, v13, v14, v15, v16);
      }
    }

    char v17 = atomic_load((unint64_t *)source + 1);
    if ((v17 & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (mode == @"kCFRunLoopCommonModes")
      {
        uint64_t v23 = (const __CFSet *)*((void *)rl + 76);
        if (v23) {
          CFDictionaryRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v23);
        }
        else {
          CFDictionaryRef Copy = 0LL;
        }
        CFMutableArrayRef Mutable = (__CFSet *)*((void *)rl + 77);
        if (!Mutable)
        {
          CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeSetCallBacks);
          *((void *)rl + 77) = Mutable;
        }

        CFSetAddValue(Mutable, source);
        if (!Copy) {
          goto LABEL_38;
        }
        *(void *)ptype = rl;
        CFRunLoopSourceRef v33 = source;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, ptype);
        CFTypeRef v26 = Copy;
        goto LABEL_37;
      }

      uint64_t v18 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
      if (!v18)
      {
LABEL_38:
        pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
        return;
      }

      uint64_t v19 = v18;
      uint64_t v20 = (pthread_mutex_t *)(v18 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v18 + 16));
      BOOL v21 = *(const __CFSet **)(v19 + 96);
      if (!v21)
      {
        *(void *)(v19 + 96) = CFSetCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeSetCallBacks);
        *(void *)(v19 + 104) = CFSetCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeSetCallBacks);
        *(void *)(v19 + 12_Block_object_dispose(va, 8) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, 0LL);
        BOOL v21 = *(const __CFSet **)(v19 + 96);
      }

      if (CFSetContainsValue(v21, source) || CFSetContainsValue(*(CFSetRef *)(v19 + 104), source)) {
        goto LABEL_36;
      }
      uint64_t v22 = *((void *)source + 13);
      if (v22 == 1)
      {
        CFSetAddValue(*(CFMutableSetRef *)(v19 + 104), source);
        mach_port_name_t v27 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
        if (v27)
        {
          mach_port_name_t v28 = v27;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 128), (const void *)v27, source);
          mach_port_insert_member(*MEMORY[0x1895FBBE0], v28, *(_DWORD *)(v19 + 136));
        }
      }

      else if (!v22)
      {
        CFSetAddValue(*(CFMutableSetRef *)(v19 + 96), source);
      }

      pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
      uint64_t v29 = (__CFBag *)*((void *)source + 12);
      if (!v29)
      {
        uint64_t v29 = CFBagCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeBagCallBacks);
        *((void *)source + 12) = v29;
      }

      CFBagAddValue(v29, rl);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
      if (*((void *)source + 13))
      {
LABEL_36:
        pthread_mutex_unlock(v20);
        CFTypeRef v26 = (const __CFSet *)v19;
LABEL_37:
        CFRelease(v26);
        goto LABEL_38;
      }

      uint64_t v30 = *((void *)source + 20);
      pthread_mutex_unlock(v20);
      CFRelease((CFTypeRef)v19);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
      if (v30) {
        (*((void (**)(void, CFRunLoopRef, CFRunLoopMode))source + 20))(*((void *)source + 14), rl, mode);
      }
    }
  }

unint64_t __CFRunLoopAddSource_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog( 3LL,  (uint64_t)@"Attempting to add a runloop source %p to runloop %p in mode '%@', but the port associated with this source does not have a receive right. This means your source will never be signalled and is likely an error. Break on __CFRunLoopError_AddingSourceLackingReceiveRight to debug. This message will only appear once per execution.",  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 32));
}

void __CFRunLoopAddItemToCommonModes(const __CFString *a1, uint64_t a2)
{
  uint64_t v4 = *(__CFRunLoop **)a2;
  unsigned __int8 v3 = *(void **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  context[2] = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v21 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v21 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    char v17 = (const __CFSet *)*((void *)rl + 77);
    if (v17 && CFSetContainsValue(v17, source))
    {
      uint64_t v18 = (const __CFSet *)*((void *)rl + 76);
      if (v18)
      {
        CFDictionaryRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
        if (Copy)
        {
          context[0] = rl;
          context[1] = source;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
          CFRelease(Copy);
        }
      }

      else
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
      }
    }

    goto LABEL_33;
  }

  uint64_t v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v8)
  {
LABEL_33:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    return;
  }

  uint64_t v9 = v8;
  uint64_t v10 = (pthread_mutex_t *)(v8 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  uint64_t v11 = *(const __CFSet **)(v9 + 96);
  if (v11 && CFSetContainsValue(v11, source)
    || (uint64_t v12 = *(const __CFSet **)(v9 + 104)) != 0LL && CFSetContainsValue(v12, source))
  {
    CFRetain(source);
    if (*((void *)source + 13) == 1LL)
    {
      mach_port_name_t v13 = (*((uint64_t (**)(void))source + 20))(*((void *)source + 14));
      if (v13)
      {
        mach_port_name_t v14 = v13;
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 128), (const void *)v13);
        mach_port_extract_member(*MEMORY[0x1895FBBE0], v14, *(_DWORD *)(v9 + 136));
      }
    }

    CFSetRemoveValue(*(CFMutableSetRef *)(v9 + 96), source);
    CFSetRemoveValue(*(CFMutableSetRef *)(v9 + 104), source);
    pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
    uint64_t v15 = (__CFBag *)*((void *)source + 12);
    if (v15) {
      CFBagRemoveValue(v15, rl);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
    if (!*((void *)source + 13))
    {
      char v16 = 0;
      BOOL v20 = *((void *)source + 21) == 0LL;
      goto LABEL_28;
    }

    char v16 = 0;
  }

  else
  {
    char v16 = 1;
  }

  BOOL v20 = 1;
LABEL_28:
  pthread_mutex_unlock(v10);
  CFRelease((CFTypeRef)v9);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  if (!v20) {
    (*((void (**)(void, CFRunLoopRef, CFRunLoopMode))source + 21))(*((void *)source + 14), rl, mode);
  }
  if ((v16 & 1) == 0) {
    CFRelease(source);
  }
}

void __CFRunLoopRemoveItemFromCommonModes(const __CFString *a1, uint64_t a2)
{
  uint64_t v4 = *(__CFRunLoop **)a2;
  unsigned __int8 v3 = *(void **)(a2 + 8);
  CFTypeID v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopRemoveObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopRemoveTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopRemoveSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }

Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    mach_port_name_t v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14)
    {
      Boolean v13 = CFSetContainsValue(v14, observer);
      goto LABEL_16;
    }

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  context[2] = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    char v9 = atomic_load((unint64_t *)observer + 1);
    if ((v9 & 8) != 0)
    {
      uint64_t v10 = (__CFRunLoop *)*((void *)observer + 10);
      if (!v10 || v10 == rl)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
        if (mode == @"kCFRunLoopCommonModes")
        {
          uint64_t v18 = (const __CFSet *)*((void *)rl + 76);
          if (v18) {
            CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
          }
          else {
            CFSetRef Copy = 0LL;
          }
          CFMutableArrayRef Mutable = (__CFSet *)*((void *)rl + 77);
          if (!Mutable)
          {
            CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeSetCallBacks);
            *((void *)rl + 77) = Mutable;
          }

          CFSetAddValue(Mutable, observer);
          if (!Copy) {
            goto LABEL_29;
          }
          context[0] = rl;
          context[1] = observer;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, context);
        }

        else
        {
          uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
          if (!v11)
          {
LABEL_29:
            pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
            return;
          }

          CFSetRef Copy = (CFSetRef)v11;
          Boolean v13 = (pthread_mutex_t *)(v11 + 16);
          pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
          mach_port_name_t v14 = (const __CFArray *)*((void *)Copy + 14);
          if (!v14)
          {
            mach_port_name_t v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
            *((void *)Copy + 14) = v14;
          }

          v21.CFIndex length = CFArrayGetCount(v14);
          v21.CFIndex location = 0LL;
          if (!CFArrayContainsValue(v14, v21, observer))
          {
            CFIndex v15 = CFArrayGetCount(*((CFArrayRef *)Copy + 14)) + 1;
            do
            {
              CFIndex v16 = v15 - 1;
              if (v15 == 1) {
                break;
              }
              ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)Copy + 14), v15 - 2);
              CFIndex v15 = v16;
            }

            while (ValueAtIndex[13] > *((void *)observer + 13));
            CFArrayInsertValueAtIndex(*((CFMutableArrayRef *)Copy + 14), v16, observer);
            *((void *)Copy + 18) |= *((void *)observer + 12);
            __CFRunLoopObserverSchedule((uint64_t)observer, (uint64_t)rl);
          }

          pthread_mutex_unlock(v13);
        }

        CFRelease(Copy);
        goto LABEL_29;
      }
    }
  }

uint64_t __CFRunLoopObserverSchedule(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    *(void *)(a1 + 80) = a2;
  }
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v5 + 1;
  return pthread_mutex_unlock(v4);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  context[2] = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v18 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v18 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v8 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    CFIndex v15 = (const __CFSet *)*((void *)rl + 77);
    if (v15 && CFSetContainsValue(v15, observer))
    {
      CFIndex v16 = (const __CFSet *)*((void *)rl + 76);
      if (!v16)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
        goto LABEL_21;
      }

      CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = observer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
        mach_port_name_t v14 = Copy;
LABEL_14:
        CFRelease(v14);
      }
    }
  }

  else
  {
    uint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v9)
    {
      uint64_t v10 = (const __CFArray **)v9;
      uint64_t v11 = (pthread_mutex_t *)(v9 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
      if (v10[14])
      {
        CFRetain(observer);
        uint64_t v12 = v10[14];
        v20.CFIndex length = CFArrayGetCount(v12);
        v20.CFIndex location = 0LL;
        FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v12, v20, observer);
        if (FirstIndexOfValue != -1)
        {
          CFArrayRemoveValueAtIndex(v10[14], FirstIndexOfValue);
          __CFRunLoopObserverCancel((uint64_t)observer);
        }

        CFRelease(observer);
      }

      pthread_mutex_unlock(v11);
      mach_port_name_t v14 = (const __CFSet *)v10;
      goto LABEL_14;
    }
  }

uint64_t __CFRunLoopObserverCancel(uint64_t a1)
{
  unint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  uint64_t v3 = *(void *)(a1 + 88) - 1LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v3;
  if (!v3) {
    *(void *)(a1 + 80) = 0LL;
  }
  return pthread_mutex_unlock(v2);
}

Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  LOBYTE(v_Block_object_dispose(va, 8) = 0;
  uint64_t v9 = (__CFRunLoop *)*((void *)timer + 11);
  if (v9 && v9 == rl)
  {
    uint64_t v10 = (pthread_mutex_t *)((char *)rl + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (mode == @"kCFRunLoopCommonModes")
    {
      mach_port_name_t v14 = (const __CFSet *)*((void *)rl + 77);
      if (v14)
      {
        LOBYTE(v_Block_object_dispose(va, 8) = CFSetContainsValue(v14, timer);
LABEL_17:
        pthread_mutex_unlock(v10);
        return v8;
      }
    }

    else
    {
      uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
      if (v11)
      {
        uint64_t v12 = (CFArrayRef *)v11;
        Boolean v13 = (pthread_mutex_t *)(v11 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
        char v8 = v12[15];
        if (v8)
        {
          v17.CFIndex length = CFArrayGetCount(v12[15]);
          v17.CFIndex location = 0LL;
          LOBYTE(v_Block_object_dispose(va, 8) = CFArrayGetFirstIndexOfValue(v8, v17, timer) != -1;
        }

        pthread_mutex_unlock(v13);
        CFRelease(v12);
        goto LABEL_17;
      }
    }

    LOBYTE(v_Block_object_dispose(va, 8) = 0;
    goto LABEL_17;
  }

  return v8;
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0 && __CFRunLoopMain && (CFRunLoopRef)__CFRunLoopMain == rl && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
    dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
  }
  char v8 = atomic_load((unint64_t *)rl + 1);
  if ((v8 & 4) == 0)
  {
    char v9 = atomic_load((unint64_t *)timer + 1);
    if ((v9 & 8) != 0)
    {
      uint64_t v10 = (__CFRunLoop *)*((void *)timer + 11);
      if (!v10 || v10 == rl)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
        if (mode == @"kCFRunLoopCommonModes")
        {
          mach_port_name_t v14 = (const __CFSet *)*((void *)rl + 76);
          if (v14) {
            CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
          }
          else {
            CFSetRef Copy = 0LL;
          }
          CFMutableArrayRef Mutable = (__CFSet *)*((void *)rl + 77);
          if (!Mutable)
          {
            CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeSetCallBacks);
            *((void *)rl + 77) = Mutable;
          }

          CFSetAddValue(Mutable, timer);
          if (!Copy) {
            goto LABEL_28;
          }
          v17.version = (CFIndex)rl;
          v17.retain = (CFArrayRetainCallBack)timer;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, &v17);
          goto LABEL_27;
        }

        uint64_t v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
        if (!v11)
        {
LABEL_28:
          pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
          return;
        }

        CFSetRef Copy = (CFSetRef)v11;
        Boolean v13 = (pthread_mutex_t *)(v11 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
        if (!*((void *)Copy + 15))
        {
          *(_OWORD *)&v17.version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
          *(_OWORD *)&v17.release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
          v17.equal = 0LL;
          *((void *)Copy + 15) = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &v17);
        }

        if (CFSetContainsValue(*((CFSetRef *)timer + 12), *((const void **)Copy + 10)))
        {
LABEL_16:
          pthread_mutex_unlock(v13);
LABEL_27:
          CFRelease(Copy);
          goto LABEL_28;
        }

        pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
        CFIndex v15 = (__CFRunLoop *)*((void *)timer + 11);
        if (v15)
        {
          if (v15 != rl)
          {
            pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
            goto LABEL_16;
          }
        }

        else
        {
          *((void *)timer + 11) = rl;
        }

        CFSetAddValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
        os_unfair_lock_lock((os_unfair_lock_t)rl + 171);
        __CFRepositionTimerInMode((uint64_t)Copy, timer, 0);
        os_unfair_lock_unlock((os_unfair_lock_t)rl + 171);
        goto LABEL_16;
      }
    }
  }

void __CFRepositionTimerInMode(uint64_t a1, const void *a2, int a3)
{
  if (a2)
  {
    uint64_t v4 = *(const __CFArray **)(a1 + 120);
    if (v4)
    {
      unint64_t v6 = *(const __CFArray **)(a1 + 120);
      if (a3)
      {
        v11.CFIndex length = CFArrayGetCount(v6);
        v11.CFIndex location = 0LL;
        FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v11, a2);
        if (FirstIndexOfValue != -1)
        {
          CFIndex v8 = FirstIndexOfValue;
          CFRetain(a2);
          CFArrayRemoveValueAtIndex(v4, v8);
          CFIndex v9 = __CFRunLoopInsertionIndexInTimerArray(v4, (uint64_t)a2);
          CFArrayInsertValueAtIndex(v4, v9, a2);
          __CFArmNextTimerInMode(a1);
          CFRelease(a2);
        }
      }

      else
      {
        CFIndex v10 = __CFRunLoopInsertionIndexInTimerArray(v6, (uint64_t)a2);
        CFArrayInsertValueAtIndex(v4, v10, a2);
        __CFArmNextTimerInMode(a1);
      }
    }
  }

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  context[2] = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43) {
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  }
  unsigned __int8 v7 = atomic_load(__CFMainThreadHasExited);
  if ((v7 & 1) != 0)
  {
    BOOL v16 = __CFRunLoopMain && __CFRunLoopMain == (void)rl;
    if (v16 && CF_RUNLOOP_ASSERTIONS_onceToken != -1) {
      dispatch_once(&CF_RUNLOOP_ASSERTIONS_onceToken, &__block_literal_global_46);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == @"kCFRunLoopCommonModes")
  {
    mach_port_name_t v14 = (const __CFSet *)*((void *)rl + 77);
    if (v14 && CFSetContainsValue(v14, timer))
    {
      CFIndex v15 = (const __CFSet *)*((void *)rl + 76);
      if (!v15)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
        goto LABEL_22;
      }

      CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = timer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
LABEL_15:
        CFRelease(Copy);
      }
    }
  }

  else
  {
    uint64_t v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v8)
    {
      CFSetRef Copy = (CFSetRef)v8;
      CFIndex v10 = (pthread_mutex_t *)(v8 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
      CFRange v11 = (const __CFArray *)*((void *)Copy + 15);
      if (v11)
      {
        v18.CFIndex length = CFArrayGetCount(*((CFArrayRef *)Copy + 15));
        v18.CFIndex location = 0LL;
        FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v11, v18, timer);
        if (FirstIndexOfValue != -1)
        {
          CFIndex v13 = FirstIndexOfValue;
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
          CFSetRemoveValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
          if (!CFSetGetCount(*((CFSetRef *)timer + 12))) {
            *((void *)timer + 11) = 0LL;
          }
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          CFArrayRemoveValueAtIndex(v11, v13);
          __CFArmNextTimerInMode((uint64_t)Copy);
        }
      }

      pthread_mutex_unlock(v10);
      goto LABEL_15;
    }
  }

void __CFArmNextTimerInMode(uint64_t a1)
{
  unint64_t v2 = *(const __CFArray **)(a1 + 120);
  if (!v2)
  {
    unint64_t v7 = -1LL;
    unint64_t v6 = -1LL;
    goto LABEL_34;
  }

  CFIndex Count = CFArrayGetCount(v2);
  if (Count < 1)
  {
    unint64_t v6 = -1LL;
  }

  else
  {
    CFIndex v4 = Count;
    CFIndex v5 = 0LL;
    unint64_t v6 = -1LL;
    unint64_t v7 = -1LL;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), v5);
      if ((*((_WORD *)ValueAtIndex + 8) & 1) == 0)
      {
        unint64_t v9 = *((void *)ValueAtIndex + 16);
        unint64_t v10 = __CFTimeIntervalToTSR(*((double *)ValueAtIndex + 15));
        if (v9 > v6) {
          break;
        }
        unint64_t v11 = v9 + v10;
        if (__CFADD__(v9, v10)) {
          unint64_t v11 = -1LL;
        }
        if (v9 < v7) {
          unint64_t v7 = v9;
        }
        if (v11 < v6) {
          unint64_t v6 = v11;
        }
      }

      ++v5;
    }

    while (v4 != v5);
    if (v7 != -1LL)
    {
      if (v6 != *(void *)(a1 + 192) || v7 != *(void *)(a1 + 184))
      {
        mach_absolute_time();
        kdebug_trace();
        uint64_t v12 = __CFTSRToNanoseconds(v6 - v7);
        dispatch_time_t v13 = __CFTSRToDispatchTime(v7);
        if (v12)
        {
          dispatch_time_t v14 = v13;
          if (*(_BYTE *)(a1 + 176) && *(_DWORD *)(a1 + 172))
          {
            mk_timer_cancel();
            *(_BYTE *)(a1 + 176) = 0;
          }

          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), v14, 0xFFFFFFFFFFFFFFFFLL, v12);
          *(_BYTE *)(a1 + 169) = 1;
        }

        else
        {
          if (*(_BYTE *)(a1 + 169))
          {
            dispatch_source_set_timer( *(dispatch_source_t *)(a1 + 152),  0xFFFFFFFFFFFFFFFFLL,  0xFFFFFFFFFFFFFFFFLL,  0x378uLL);
            *(_BYTE *)(a1 + 169) = 0;
          }

          if (*(_DWORD *)(a1 + 172))
          {
            mk_timer_arm();
            *(_BYTE *)(a1 + 176) = 1;
          }
        }
      }

      goto LABEL_34;
    }
  }

  if (*(_BYTE *)(a1 + 176) && *(_DWORD *)(a1 + 172))
  {
    mk_timer_cancel();
    *(_BYTE *)(a1 + 176) = 0;
  }

  unint64_t v7 = -1LL;
  if (*(_BYTE *)(a1 + 169))
  {
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x14DuLL);
    *(_BYTE *)(a1 + 169) = 0;
  }

double __CFRunLoopSourceDeallocate(uint64_t a1)
{
  unint64_t v2 = *(void (**)(void))(a1 + 128);
  if (v2) {
    v2(*(void *)(a1 + 112));
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0LL;
  return result;
}

uint64_t __CFRunLoopSourceEqual(unint64_t *a1, unint64_t *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  int v2 = atomic_load(a1 + 1);
  int v3 = atomic_load(a2 + 1);
  if (((v3 ^ v2) & 8) != 0) {
    return 0LL;
  }
  if (a1[10] != a2[10]) {
    return 0LL;
  }
  unint64_t v4 = a1[13];
  if (v4 != a2[13]) {
    return 0LL;
  }
  if (a1[19] != a2[19]) {
    return 0LL;
  }
  CFIndex v5 = (uint64_t (*)(unint64_t, unint64_t))a1[18];
  if (v4 == 1)
  {
    unint64_t v7 = a1[21];
    unint64_t v8 = a2[21];
LABEL_13:
    if (v7 != v8) {
      return 0LL;
    }
    goto LABEL_14;
  }

  if (!v4)
  {
    unint64_t v7 = a1[22];
    unint64_t v8 = a2[22];
    goto LABEL_13;
  }

uint64_t __CFRunLoopSourceHash(uint64_t a1)
{
  int v1 = *(uint64_t (**)(uint64_t))(a1 + 152);
  uint64_t result = *(void *)(a1 + 112);
  if (v1) {
    return v1(result);
  }
  return result;
}

CFStringRef __CFRunLoopSourceCopyDescription(unint64_t *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  int v2 = (uint64_t (*)(unint64_t))a1[17];
  if (v2)
  {
    uint64_t v3 = v2(a1[14]);
    if (v3)
    {
      CFStringRef v4 = (CFStringRef)v3;
      goto LABEL_17;
    }
  }

  unint64_t v5 = a1[13];
  if (v5 == 1)
  {
    unint64_t v6 = (const void **)(a1 + 21);
    goto LABEL_8;
  }

  if (!v5)
  {
    unint64_t v6 = (const void **)(a1 + 22);
LABEL_8:
    unint64_t v7 = (void *)*v6;
    goto LABEL_10;
  }

  unint64_t v7 = 0LL;
LABEL_10:
  int v8 = dladdr(v7, &v18);
  dli_smach_port_name_t name = "???";
  if (v8)
  {
    if (v18.dli_sname && v18.dli_saddr == v7) {
      dli_smach_port_name_t name = v18.dli_sname;
    }
  }

  CFStringRef v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopSource context>{version = %ld, info = %p, callout = %s (%p)}",  a1[13],  a1[14],  dli_sname,  v7);
LABEL_17:
  CFAllocatorRef v11 = CFGetAllocator(a1);
  unint64_t v12 = atomic_load(a1 + 11);
  dispatch_time_t v13 = "Yes";
  if (v12) {
    dispatch_time_t v14 = "Yes";
  }
  else {
    dispatch_time_t v14 = "No";
  }
  char v15 = atomic_load(a1 + 1);
  if ((v15 & 8) == 0) {
    dispatch_time_t v13 = "No";
  }
  CFStringRef v16 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopSource %p [%p]>{signalled = %s, valid = %s, order = %ld, context = %@}",  a1,  v11,  v14,  v13,  a1[10],  v4);
  CFRelease(v4);
  return v16;
}

CFTypeID CFRunLoopSourceGetTypeID(void)
{
  return 46LL;
}

CFRunLoopSourceRef CFRunLoopSourceCreate( CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!context) {
    CFRunLoopSourceCreate_cold_1();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(allocator, 0x2EuLL, 168LL, 0LL, v3, v4, v5, v6);
  uint64_t v11 = Instance;
  if (Instance)
  {
    unint64_t v12 = (unint64_t *)(Instance + 8);
    unint64_t v13 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v14 = __ldaxr(v12);
      if (v14 != v13) {
        break;
      }
      if (__stlxr(v13 | 8, v12)) {
        goto LABEL_12;
      }
      int v15 = 1;
LABEL_13:
      unint64_t v13 = v14;
      if (v15)
      {
        atomic_store(0LL, (unint64_t *)(Instance + 88));
        pthread_mutexattr_init(&v20);
        pthread_mutexattr_settype(&v20, 2);
        pthread_mutex_init((pthread_mutex_t *)(v11 + 16), &v20);
        pthread_mutexattr_destroy(&v20);
        *(void *)(v11 + 80) = order;
        uint64_t v16 = 72LL;
        if (context->version != 1) {
          uint64_t v16 = 0LL;
        }
        if (context->version) {
          size_t v17 = v16;
        }
        else {
          size_t v17 = 80LL;
        }
        memmove((void *)(v11 + 104), context, v17);
        retain = context->retain;
        if (retain) {
          *(void *)(v11 + 112) = ((uint64_t (*)(void *))retain)(context->info);
        }
        return (CFRunLoopSourceRef)v11;
      }
    }

    __clrex();
LABEL_12:
    int v15 = 0;
    goto LABEL_13;
  }

  return (CFRunLoopSourceRef)v11;
}

CFIndex CFRunLoopSourceGetOrder(CFRunLoopSourceRef source)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)source + 10);
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  context[2] = *MEMORY[0x1895F89C0];
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  CFRetain(source);
  uint64_t v3 = (unint64_t *)((char *)source + 8);
  char v4 = atomic_load((unint64_t *)source + 1);
  if ((v4 & 8) != 0)
  {
    uint64_t v5 = (const __CFBag *)*((void *)source + 12);
    unint64_t v6 = atomic_load(v3);
    while (1)
    {
      unint64_t v7 = __ldaxr(v3);
      if (v7 != v6) {
        break;
      }
      if (__stlxr(v6 & 0xFFFFFFFFFFFFFFF7LL, v3)) {
        goto LABEL_12;
      }
      int v8 = 1;
LABEL_13:
      unint64_t v6 = v7;
      if (v8)
      {
        atomic_store(0LL, (unint64_t *)source + 11);
        if (v5)
        {
          *((void *)source + 12) = 0LL;
          pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
          context[0] = source;
          context[1] = 0LL;
          CFBagApplyFunction(v5, (CFBagApplierFunction)__CFRunLoopSourceRemoveFromRunLoop, context);
          CFRelease(v5);
          pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
        }

        goto LABEL_16;
      }
    }

    __clrex();
LABEL_12:
    int v8 = 0;
    goto LABEL_13;
  }

void __CFRunLoopSourceRemoveFromRunLoop(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) != a1)
  {
    char v4 = *(__CFRunLoopSource **)a2;
    uint64_t v5 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    unint64_t v6 = CFRunLoopCopyAllModes((CFRunLoopRef)a1);
    CFIndex Count = CFArrayGetCount(v6);
    if (Count)
    {
      CFIndex v8 = Count - 1;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v8);
        CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, ValueAtIndex);
        --v8;
      }

      while (v8 != -1);
    }

    CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, @"kCFRunLoopCommonModes");
    pthread_mutex_unlock(v5);
    CFRelease(v6);
    *(void *)(a2 + _Block_object_dispose(va, 8) = a1;
  }

Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)source + 1);
  return (v3 >> 3) & 1;
}

void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v4 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v5 = 72LL;
  if (context->version != 1) {
    uint64_t v5 = 0LL;
  }
  if (context->version) {
    size_t v6 = v5;
  }
  else {
    size_t v6 = 80LL;
  }
  memmove(context, (char *)source + 104, v6);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  char v3 = atomic_load((unint64_t *)source + 1);
  if ((v3 & 8) != 0)
  {
    kdebug_trace();
    unint64_t v4 = (unint64_t *)((char *)source + 88);
    uint64_t v5 = mach_absolute_time();
    while (!__ldaxr(v4))
    {
      if (!__stlxr(v5, v4)) {
        goto LABEL_12;
      }
    }

    __clrex();
LABEL_12:
    kdebug_trace();
  }

  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
}

BOOL CFRunLoopSourceIsSignalled(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  unint64_t v4 = atomic_load((unint64_t *)(a1 + 88));
  BOOL v5 = v4 != 0;
  pthread_mutex_unlock(v3);
  return v5;
}

void _CFRunLoopSourceWakeUpRunLoops(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46) {
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  }
  char v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 8) != 0 && (BOOL v5 = *(const __CFBag **)(a1 + 96)) != 0LL)
  {
    CFSetRef Copy = CFBagCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    pthread_mutex_unlock(v3);
    if (Copy)
    {
      CFBagApplyFunction(Copy, (CFBagApplierFunction)__CFRunLoopSourceWakeUpLoop, 0LL);
      CFRelease(Copy);
    }
  }

  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }

uint64_t __CFRunLoopObserverDeallocate(uint64_t a1)
{
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
}

CFStringRef __CFRunLoopObserverCopyDescription(unint64_t *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  unint64_t v2 = (uint64_t (*)(unint64_t))a1[19];
  if (!v2 || (CFStringRef v3 = (CFStringRef)v2(a1[16])) == 0LL) {
    CFStringRef v3 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopObserver context %p>",  a1[16]);
  }
  char v4 = (void *)a1[14];
  dli_smach_port_name_t name = "???";
  if (dladdr(v4, &v14))
  {
    if (v14.dli_sname && v14.dli_saddr == v4) {
      dli_smach_port_name_t name = v14.dli_sname;
    }
  }

  CFAllocatorRef v7 = CFGetAllocator(a1);
  char v8 = atomic_load(a1 + 1);
  if ((v8 & 8) != 0) {
    unint64_t v9 = "Yes";
  }
  else {
    unint64_t v9 = "No";
  }
  char v10 = atomic_load(a1 + 1);
  if ((v10 & 2) != 0) {
    uint64_t v11 = "Yes";
  }
  else {
    uint64_t v11 = "No";
  }
  CFStringRef v12 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopObserver %p [%p]>{valid = %s, activities = 0x%lx, repeats = %s, order = %ld, callout = %s (%p), context = %@}",  a1,  v7,  v9,  a1[12],  v11,  a1[13],  dli_sname,  v4,  v3);
  CFRelease(v3);
  return v12;
}

CFTypeID CFRunLoopObserverGetTypeID(void)
{
  return 45LL;
}

CFRunLoopObserverRef CFRunLoopObserverCreate( CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  int v11 = repeats;
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(allocator, 0x2DuLL, 144LL, 0LL, (uint64_t)callout, (uint64_t)context, v6, v7);
  uint64_t v15 = Instance;
  if (Instance)
  {
    uint64_t v16 = (unint64_t *)(Instance + 8);
    unint64_t v17 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v18 = __ldaxr(v16);
      if (v18 != v17) {
        break;
      }
      if (__stlxr(v17 | 8, v16)) {
        goto LABEL_11;
      }
      int v19 = 1;
LABEL_12:
      unint64_t v17 = v18;
      if (v19)
      {
        unint64_t v20 = atomic_load(v16);
        while (1)
        {
          unint64_t v21 = __ldaxr(v16);
          if (v21 != v20) {
            break;
          }
          if (__stlxr(v20 & 0xFFFFFFFFFFFFFFFELL, v16)) {
            goto LABEL_18;
          }
          int v22 = 1;
LABEL_19:
          unint64_t v20 = v21;
          if (v22)
          {
            unint64_t v23 = atomic_load(v16);
            if (v11)
            {
              while (1)
              {
                unint64_t v24 = __ldaxr(v16);
                if (v24 != v23) {
                  break;
                }
                if (__stlxr(v23 | 2, v16)) {
                  goto LABEL_25;
                }
                char v25 = 1;
LABEL_26:
                unint64_t v23 = v24;
                if ((v25 & 1) != 0) {
                  goto LABEL_34;
                }
              }

              __clrex();
LABEL_25:
              char v25 = 0;
              goto LABEL_26;
            }

            while (2)
            {
              unint64_t v26 = __ldaxr(v16);
              if (v26 == v23)
              {
                if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFFDLL, v16))
                {
                  int v27 = 1;
                  goto LABEL_33;
                }
              }

              else
              {
                __clrex();
              }

              int v27 = 0;
LABEL_33:
              unint64_t v23 = v26;
              if (v27)
              {
LABEL_34:
                pthread_mutexattr_init(&v31);
                pthread_mutexattr_settype(&v31, 2);
                pthread_mutex_init((pthread_mutex_t *)(v15 + 16), &v31);
                pthread_mutexattr_destroy(&v31);
                *(void *)(v15 + 80) = 0LL;
                *(void *)(v15 + 8_Block_object_dispose(va, 8) = 0LL;
                *(void *)(v15 + 96) = activities;
                *(void *)(v15 + 104) = order;
                *(void *)(v15 + 112) = callout;
                if (context)
                {
                  info = context->info;
                  retain = context->retain;
                  if (retain) {
                    info = (void *)((uint64_t (*)(void *))retain)(info);
                  }
                  *(void *)(v15 + 12_Block_object_dispose(va, 8) = info;
                  *(_OWORD *)(v15 + 136) = *(_OWORD *)&context->retain;
                  *(void *)(v15 + 152) = context->copyDescription;
                }

                return (CFRunLoopObserverRef)v15;
              }

              continue;
            }
          }
        }

        __clrex();
LABEL_18:
        int v22 = 0;
        goto LABEL_19;
      }
    }

    __clrex();
LABEL_11:
    int v19 = 0;
    goto LABEL_12;
  }

  return (CFRunLoopObserverRef)v15;
}

CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler( CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void *block)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  v6.version = 0LL;
  v6.info = block;
  v6.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1895F8720];
  v6.release = (void (__cdecl *)(const void *))MEMORY[0x1895F8748];
  v6.copyDescription = 0LL;
  return CFRunLoopObserverCreate( allocator,  activities,  repeats,  order,  (CFRunLoopObserverCallBack)_runLoopObserverWithBlockContext,  &v6);
}

uint64_t _runLoopObserverWithBlockContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFOptionFlags CFRunLoopObserverGetActivities(CFRunLoopObserverRef observer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)observer + 12);
}

CFIndex CFRunLoopObserverGetOrder(CFRunLoopObserverRef observer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)observer + 13);
}

Boolean CFRunLoopObserverDoesRepeat(CFRunLoopObserverRef observer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 1) & 1;
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
  CFRetain(observer);
  unsigned int v3 = (unint64_t *)((char *)observer + 8);
  char v4 = atomic_load((unint64_t *)observer + 1);
  if ((v4 & 8) != 0)
  {
    uint64_t v5 = *((void *)observer + 10);
    uint64_t v6 = *((void *)observer + 16);
    *((void *)observer + 16) = 0LL;
    unint64_t v7 = atomic_load(v3);
    while (1)
    {
      unint64_t v8 = __ldaxr(v3);
      if (v8 != v7) {
        break;
      }
      if (__stlxr(v7 & 0xFFFFFFFFFFFFFFF7LL, v3)) {
        goto LABEL_12;
      }
      int v9 = 1;
LABEL_13:
      unint64_t v7 = v8;
      if (v9)
      {
        if (v5)
        {
          CFRetain((CFTypeRef)v5);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));
          pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
          char v10 = CFRunLoopCopyAllModes((CFRunLoopRef)v5);
          CFIndex Count = CFArrayGetCount(v10);
          if (Count)
          {
            CFIndex v12 = Count - 1;
            do
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v12);
              CFRunLoopRemoveObserver((CFRunLoopRef)v5, observer, ValueAtIndex);
              --v12;
            }

            while (v12 != -1);
          }

          CFRunLoopRemoveObserver((CFRunLoopRef)v5, observer, @"kCFRunLoopCommonModes");
          pthread_mutex_unlock((pthread_mutex_t *)(v5 + 16));
          CFRelease(v10);
          CFRelease((CFTypeRef)v5);
          pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
        }

        Dl_info v14 = (void (*)(uint64_t))*((void *)observer + 18);
        if (v14) {
          v14(v6);
        }
        goto LABEL_21;
      }
    }

    __clrex();
LABEL_12:
    int v9 = 0;
    goto LABEL_13;
  }

Boolean CFRunLoopObserverIsValid(CFRunLoopObserverRef observer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 3) & 1;
}

void CFRunLoopObserverGetContext(CFRunLoopObserverRef observer, CFRunLoopObserverContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v4 != 45) {
    _CFAssertMismatchedTypeID(0x2DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __int128 v5 = *(_OWORD *)((char *)observer + 120);
  __int128 v6 = *(_OWORD *)((char *)observer + 136);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((void *)observer + 19);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

uint64_t __CFRunLoopTimerDeallocate(uint64_t a1)
{
  *(_WORD *)(a1 + 16) |= 4u;
  CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
  CFRelease(*(CFTypeRef *)(a1 + 96));
  *(void *)(a1 + 96) = 0LL;
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 24));
}

CFStringRef __CFRunLoopTimerCopyDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v3 = v2;
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(uint64_t (**)(void))(v2 + 184);
  if (!v4 || (CFStringRef v5 = (CFStringRef)v4(*(void *)(v2 + 160))) == 0LL) {
    CFStringRef v5 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopTimer context %p>",  *(void *)(v3 + 160));
  }
  uint64_t v6 = *(void *)(v3 + 144);
  uint64_t v7 = *(void *)(v3 + 160);
  strcpy(__str, "<unknown>");
  strcpy(v24, "<unknown>");
  int v22 = 0LL;
  if (__CFRunLoopDebugInfoForRunLoopTimer_onceToken != -1) {
    dispatch_once(&__CFRunLoopDebugInfoForRunLoopTimer_onceToken, &__block_literal_global_89);
  }
  unint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 144);
  if (v8 == _runLoopTimerWithBlockContext) {
    unint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 16);
  }
  if ((char *)v8 == (char *)__CFFireTimer)
  {
    __CFDescribeTimer(v3, v7, __str, 0x800uLL, v24, 0x800uLL, (uint64_t *)&v22);
  }

  else if (v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc {
         && __CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc
  }
         && (int v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeTimerCalloutFunc) != 0LL
         || v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
         && __CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
         && (int v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeDelayedPerformFunc) != 0LL)
  {
    v9(v3, v7, __str, 2048LL, v24, 2048LL, &v22);
  }

  else
  {
    if (dladdr(v8, &v23))
    {
      dli_fmach_port_name_t name = v23.dli_fname;
      if (!v23.dli_fname) {
        dli_fmach_port_name_t name = "<unknown library>";
      }
      snprintf(__str, 0x800uLL, "%s", dli_fname);
      dli_smach_port_name_t name = v23.dli_sname;
      if (!v23.dli_sname) {
        dli_smach_port_name_t name = "<unknown function>";
      }
      snprintf(v24, 0x800uLL, "%s", dli_sname);
    }

    else
    {
      strcpy(__str, "<unknown library>");
      strcpy(v24, "<unknown function>");
    }

    int v22 = v8;
  }

  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)v3);
  char v13 = atomic_load((unint64_t *)(v3 + 8));
  if ((v13 & 8) != 0) {
    Dl_info v14 = "Yes";
  }
  else {
    Dl_info v14 = "No";
  }
  if ((*(_WORD *)(v3 + 16) & 1) != 0) {
    uint64_t v15 = "Yes";
  }
  else {
    uint64_t v15 = "No";
  }
  uint64_t v17 = *(void *)(v3 + 112);
  uint64_t v16 = *(void *)(v3 + 120);
  double v18 = *(double *)(v3 + 104);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFStringRef v20 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFRunLoopTimer %p [%p]>{valid = %s, firing = %s, interval = %0.09g, tolerance = %0.09g, next fire date = %0.09g (%0.09g @ %lld), callout = %s (%p / %p) (%s), context = %@}",  v3,  v12,  v14,  v15,  v17,  v16,  *(void *)&v18,  v18 - Current,  *(void *)(v3 + 128),  v24,  v6,  v22,  __str,  v5);
  CFRelease(v5);
  return v20;
}

CFTypeID CFRunLoopTimerGetTypeID(void)
{
  return 47LL;
}

CFRunLoopTimerRef CFRunLoopTimerCreate( CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  uint64_t v7 = MEMORY[0x1895F8858](allocator, flags);
  CFAllocatorRef v12 = (void *)v8;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  double v18 = v17;
  double v20 = v19;
  unint64_t v21 = (const __CFAllocator *)v7;
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v21, 0x2FuLL, 176LL, 0LL, v8, v9, v10, v11);
  uint64_t v23 = Instance;
  if (Instance)
  {
    unint64_t v24 = (unint64_t *)(Instance + 8);
    unint64_t v25 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v26 = __ldaxr(v24);
      if (v26 != v25) {
        break;
      }
      if (__stlxr(v25 | 8, v24)) {
        goto LABEL_11;
      }
      int v27 = 1;
LABEL_12:
      unint64_t v25 = v26;
      if (v27)
      {
        *(_WORD *)(Instance + 16) &= ~1u;
        pthread_mutexattr_init(&v36);
        pthread_mutexattr_settype(&v36, 2);
        pthread_mutex_init((pthread_mutex_t *)(v23 + 24), &v36);
        pthread_mutexattr_destroy(&v36);
        *(void *)(v23 + 8_Block_object_dispose(va, 8) = 0LL;
        *(void *)(v23 + 96) = CFSetCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeSetCallBacks);
        *(void *)(v23 + 136) = v16;
        if (v18 < 0.0) {
          double v18 = 0.0;
        }
        *(void *)(v23 + 120) = 0LL;
        if (v20 <= 4039289860.0) {
          double v28 = v20;
        }
        else {
          double v28 = 4039289860.0;
        }
        *(double *)(v23 + 104) = v28;
        *(double *)(v23 + 112) = v18;
        uint64_t v29 = mach_absolute_time();
        double Current = CFAbsoluteTimeGetCurrent();
        double v31 = Current;
        if (v28 >= Current)
        {
          double v32 = v28 - Current;
          if (v28 - v31 > 504911232.0) {
            double v32 = 504911232.0;
          }
          *(void *)(v23 + 12_Block_object_dispose(va, 8) = __CFTimeIntervalToTSR(v32) + v29;
        }

        else
        {
          *(void *)(v23 + 12_Block_object_dispose(va, 8) = v29;
        }

        *(void *)(v23 + 144) = v14;
        if (v12)
        {
          uint64_t v33 = v12[1];
          uint64_t v34 = (uint64_t (*)(uint64_t))v12[2];
          if (v34) {
            uint64_t v33 = v34(v33);
          }
          *(void *)(v23 + 160) = v33;
          *(_OWORD *)(v23 + 16_Block_object_dispose(va, 8) = *((_OWORD *)v12 + 1);
          *(void *)(v23 + 184) = v12[4];
        }

        kdebug_trace();
        return (CFRunLoopTimerRef)v23;
      }
    }

    __clrex();
LABEL_11:
    int v27 = 0;
    goto LABEL_12;
  }

  return (CFRunLoopTimerRef)v23;
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler( CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  v7.version = 0LL;
  v7.info = block;
  v7.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1895F8720];
  v7.release = (void (__cdecl *)(const void *))MEMORY[0x1895F8748];
  v7.copyDescription = 0LL;
  return CFRunLoopTimerCreate( allocator,  fireDate,  interval,  flags,  order,  (CFRunLoopTimerCallBack)_runLoopTimerWithBlockContext,  &v7);
}

uint64_t _runLoopTimerWithBlockContext(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  uint64_t v2 = (unint64_t *)((uint64_t (*)(CFRunLoopTimerRef))MEMORY[0x1895F8858])(timer);
  double v4 = v3;
  CFStringRef v5 = v2;
  v27[518] = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID(v2);
  if (v6 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  char v7 = atomic_load(v5 + 1);
  if ((v7 & 8) != 0)
  {
    if (v4 <= 4039289860.0) {
      double v8 = v4;
    }
    else {
      double v8 = 4039289860.0;
    }
    uint64_t v9 = mach_absolute_time();
    double Current = CFAbsoluteTimeGetCurrent();
    double v11 = Current;
    if (v8 >= Current)
    {
      double v12 = v8 - Current;
      if (v8 - v11 > 504911232.0) {
        double v12 = 504911232.0;
      }
      v9 += __CFTimeIntervalToTSR(v12);
    }

    pthread_mutex_lock((pthread_mutex_t *)(v5 + 3));
    if (v5[11])
    {
      CFIndex Count = CFSetGetCount((CFSetRef)v5[12]);
      MEMORY[0x1895F8858](Count, v14);
      uint64_t v16 = (const void **)((char *)v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
      CFSetGetValues((CFSetRef)v5[12], v16);
      if (Count >= 1)
      {
        double v17 = v16;
        CFIndex v18 = Count;
        do
        {
          double v19 = *v17++;
          CFRetain(v19);
          --v18;
        }

        while (v18);
      }

      double v20 = (char *)CFRetain((CFTypeRef)v5[11]);
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 3));
      pthread_mutex_lock((pthread_mutex_t *)(v20 + 16));
      if (Count < 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v20 + 171);
        v5[16] = v9;
        *((double *)v5 + 13) = v8;
        os_unfair_lock_unlock((os_unfair_lock_t)v20 + 171);
      }

      else
      {
        v27[0] = v27;
        unint64_t v21 = (const __CFString **)v16;
        CFIndex v22 = Count;
        do
        {
          uint64_t v23 = *v21;
          *unint64_t v21 = (const __CFString *)__CFRunLoopCopyMode((uint64_t)v20, *v21, 0);
          ++v21;
          CFRelease(v23);
          --v22;
        }

        while (v22);
        os_unfair_lock_lock((os_unfair_lock_t)v20 + 171);
        v5[16] = v9;
        *((double *)v5 + 13) = v8;
        unint64_t v24 = (uint64_t *)v16;
        CFIndex v25 = Count;
        do
        {
          if (*v24) {
            __CFRepositionTimerInMode(*v24, v5, 1);
          }
          ++v24;
          --v25;
        }

        while (v25);
        os_unfair_lock_unlock((os_unfair_lock_t)v20 + 171);
        do
        {
          unint64_t v26 = (char *)*v16;
          if (*v16)
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v26 + 16));
            CFRelease(v26);
          }

          ++v16;
          --Count;
        }

        while (Count);
      }

      pthread_mutex_unlock((pthread_mutex_t *)(v20 + 16));
      if (!v20 || _CFRunLoopGetButDontCreateCurrent() != v20) {
        CFRunLoopWakeUp((CFRunLoopRef)v20);
      }
      CFRelease(v20);
    }

    else
    {
      v5[16] = v9;
      *((double *)v5 + 13) = v8;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 3));
    }

    kdebug_trace();
  }

CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  -[__CFRunLoopTimer timeInterval](timer, "timeInterval");
  return result;
}

Boolean CFRunLoopTimerDoesRepeat(CFRunLoopTimerRef timer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((double *)timer + 14) > 0.0;
}

CFIndex CFRunLoopTimerGetOrder(CFRunLoopTimerRef timer)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((void *)timer + 17);
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  v21[1] = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer invalidate](timer, "invalidate");
    return;
  }

  pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
  if ((*((_WORD *)timer + 8) & 4) == 0) {
    CFRetain(timer);
  }
  unint64_t v2 = (unint64_t *)((char *)timer + 8);
  char v3 = atomic_load((unint64_t *)timer + 1);
  if ((v3 & 8) != 0)
  {
    uint64_t v4 = *((void *)timer + 11);
    uint64_t v5 = *((void *)timer + 20);
    *((void *)timer + 20) = 0LL;
    unint64_t v6 = atomic_load(v2);
    while (1)
    {
      unint64_t v7 = __ldaxr(v2);
      if (v7 != v6) {
        break;
      }
      if (__stlxr(v6 & 0xFFFFFFFFFFFFFFF7LL, v2)) {
        goto LABEL_15;
      }
      int v8 = 1;
LABEL_16:
      unint64_t v6 = v7;
      if (v8)
      {
        if (v4)
        {
          CFIndex Count = CFSetGetCount(*((CFSetRef *)timer + 12));
          MEMORY[0x1895F8858](Count, v10);
          double v12 = (const void **)((char *)v21 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
          CFSetGetValues(*((CFSetRef *)timer + 12), v12);
          if (Count >= 1)
          {
            uint64_t v13 = v12;
            CFIndex v14 = Count;
            do
            {
              uint64_t v15 = *v13++;
              CFRetain(v15);
              --v14;
            }

            while (v14);
          }

          CFRetain((CFTypeRef)v4);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
          if (Count < 1)
          {
            CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, @"kCFRunLoopCommonModes");
            pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
          }

          else
          {
            uint64_t v16 = (const __CFString **)v12;
            CFIndex v17 = Count;
            do
            {
              CFIndex v18 = *v16++;
              CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, v18);
              --v17;
            }

            while (v17);
            CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, @"kCFRunLoopCommonModes");
            pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
            do
            {
              double v19 = *v12++;
              CFRelease(v19);
              --Count;
            }

            while (Count);
          }

          CFRelease((CFTypeRef)v4);
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
        }

        double v20 = (void (*)(uint64_t))*((void *)timer + 22);
        if (v20) {
          v20(v5);
        }
        goto LABEL_31;
      }
    }

    __clrex();
LABEL_15:
    int v8 = 0;
    goto LABEL_16;
  }

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    LOBYTE(v2) = -[__CFRunLoopTimer isValid](timer, "isValid");
  }

  else
  {
    unint64_t v3 = atomic_load((unint64_t *)timer + 1);
    return (v3 >> 3) & 1;
  }

  return v2;
}

void CFRunLoopTimerGetContext(CFRunLoopTimerRef timer, CFRunLoopTimerContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v4 != 47) {
    _CFAssertMismatchedTypeID(0x2FuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __int128 v5 = *(_OWORD *)((char *)timer + 152);
  __int128 v6 = *(_OWORD *)((char *)timer + 168);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((void *)timer + 23);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

CFTimeInterval CFRunLoopTimerGetTolerance(CFRunLoopTimerRef timer)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  -[__CFRunLoopTimer tolerance](timer, "tolerance");
  return result;
}

void CFRunLoopTimerSetTolerance(CFRunLoopTimerRef timer, CFTimeInterval tolerance)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer setTolerance:](timer, "setTolerance:", tolerance);
  }

  else
  {
    double v4 = *((double *)timer + 14);
    if (v4 <= 0.0)
    {
      double v5 = 0.0;
      if (tolerance >= 0.0) {
        double v5 = tolerance;
      }
    }

    else
    {
      double v5 = v4 * 0.5;
      if (v5 > tolerance) {
        double v5 = tolerance;
      }
    }

    *((double *)timer + 15) = v5;
  }

void __CFRunLoopCleanseSources(uint64_t a1, const void *a2)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  double v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    CFIndex Count = CFSetGetCount(v4);
    unint64_t v7 = (const __CFSet **)(a1 + 104);
    __int128 v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      goto LABEL_7;
    }
  }

  else
  {
    unint64_t v7 = (const __CFSet **)(a1 + 104);
    __int128 v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      return;
    }
    CFIndex Count = 0LL;
  }

  __int128 v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  uint64_t v8 = (uint64_t)v6 + Count;
  else {
    uint64_t v9 = (const void **)values;
  }
  uint64_t v10 = *(const __CFSet **)(a1 + 96);
  if (v10) {
    CFSetGetValues(v10, v9);
  }
  uint64_t v11 = *v7;
  if (v11)
  {
    CFIndex v12 = *(void *)(a1 + 96);
    if (v12) {
      CFIndex v12 = CFSetGetCount((CFSetRef)v12);
    }
    CFSetGetValues(v11, &v9[v12]);
  }

  if (v8 >= 1)
  {
    uint64_t v13 = v9;
    do
    {
      CFIndex v14 = *v13;
      uint64_t v15 = (pthread_mutex_t *)((char *)*v13 + 16);
      pthread_mutex_lock(v15);
      uint64_t v16 = (__CFBag *)*((void *)v14 + 12);
      if (v16) {
        CFBagRemoveValue(v16, a2);
      }
      pthread_mutex_unlock(v15);
      ++v13;
      --v8;
    }

    while (v8);
  }

void __CFRunLoopDeallocateSources(uint64_t a1, const void *a2)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  double v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    CFIndex Count = CFSetGetCount(v4);
    unint64_t v7 = (CFMutableSetRef *)(a1 + 104);
    __int128 v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      goto LABEL_7;
    }
  }

  else
  {
    unint64_t v7 = (CFMutableSetRef *)(a1 + 104);
    __int128 v6 = *(const __CFSet **)(a1 + 104);
    if (!v6) {
      return;
    }
    CFIndex Count = 0LL;
  }

  __int128 v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  uint64_t v8 = (uint64_t)v6 + Count;
  else {
    uint64_t v9 = (const void **)values;
  }
  uint64_t v10 = *(const __CFSet **)(a1 + 96);
  if (v10) {
    CFSetGetValues(v10, v9);
  }
  uint64_t v11 = *v7;
  if (*v7)
  {
    CFIndex v12 = *(void *)(a1 + 96);
    if (v12) {
      CFIndex v12 = CFSetGetCount((CFSetRef)v12);
    }
    CFSetGetValues(v11, &v9[v12]);
  }

  if (v8 >= 1)
  {
    uint64_t v13 = v9;
    uint64_t v14 = v8;
    do
    {
      uint64_t v15 = *v13++;
      CFRetain(v15);
      --v14;
    }

    while (v14);
  }

  uint64_t v16 = *(__CFSet **)(a1 + 96);
  if (v16) {
    CFSetRemoveAllValues(v16);
  }
  if (*v7) {
    CFSetRemoveAllValues(*v7);
  }
  if (v8 >= 1)
  {
    CFIndex v17 = (ipc_space_t *)MEMORY[0x1895FBBE0];
    CFIndex v18 = v9;
    do
    {
      double v19 = *v18;
      double v20 = (pthread_mutex_t *)((char *)*v18 + 16);
      pthread_mutex_lock(v20);
      unint64_t v21 = (__CFBag *)*((void *)v19 + 12);
      if (v21) {
        CFBagRemoveValue(v21, a2);
      }
      pthread_mutex_unlock(v20);
      uint64_t v22 = *((void *)v19 + 13);
      if (v22 == 1)
      {
        mach_port_name_t v24 = (*((uint64_t (**)(void))v19 + 20))(*((void *)v19 + 14));
        if (v24) {
          mach_port_extract_member(*v17, v24, *(_DWORD *)(a1 + 136));
        }
      }

      else if (!v22)
      {
        uint64_t v23 = (void (*)(void, const void *, void))*((void *)v19 + 21);
        if (v23) {
          v23(*((void *)v19 + 14), a2, *(void *)(a1 + 80));
        }
      }

      CFRelease(v19);
      ++v18;
      --v8;
    }

    while (v8);
  }

void __CFRunLoopDeallocateObservers(uint64_t a1)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v2 = *(const __CFArray **)(a1 + 112);
  if (v2)
  {
    uint64_t Count = CFArrayGetCount(v2);
    if (Count >= 257) {
      double v4 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    }
    else {
      double v4 = (const void **)values;
    }
    v11.CFIndex location = 0LL;
    v11.CFIndex length = Count;
    CFArrayGetValues(*(CFArrayRef *)(a1 + 112), v11, v4);
    if (Count < 1)
    {
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
    }

    else
    {
      double v5 = v4;
      uint64_t v6 = Count;
      do
      {
        unint64_t v7 = *v5++;
        CFRetain(v7);
        --v6;
      }

      while (v6);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
      uint64_t v8 = (uint64_t *)v4;
      do
      {
        __CFRunLoopObserverCancel(*v8);
        uint64_t v9 = (const void *)*v8++;
        CFRelease(v9);
        --Count;
      }

      while (Count);
    }
  }

void __CFRunLoopDeallocateTimers(uint64_t a1, void *a2)
{
  unint64_t v3 = *(const __CFArray **)(a1 + 120);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count)
    {
      v6.CFIndex length = Count;
      v6.CFIndex location = 0LL;
      CFArrayApplyFunction(*(CFArrayRef *)(a1 + 120), v6, (CFArrayApplierFunction)__CFRunLoopKillOneTimer, a2);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 120));
    }
  }

uint64_t __CFRunLoopKillOneTimer(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 96));
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  return pthread_mutex_unlock(v2);
}

void __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(int a1)
{
  if (a1 == 6) {
    __RESOURCE_SHORTAGE__();
  }
  if (a1 == 3) {
    __NO_SPACE__();
  }
  __break(1u);
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__( uint64_t (*result)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))result(a2, a3, a4);
  }
  return result;
}

void *__CFRunLoopPerCalloutARPEnd(void *result)
{
  if (result) {
    return _CFAutoreleasePoolPop(result);
  }
  return result;
}

void sub_180ACC874( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, int a10, __int16 a11, __int16 a12, uint64_t a13)
{
  if (a2)
  {
    id v14 = objc_begin_catch(exception_object);
    if (a2 == 2)
    {
      uint64_t v15 = v14;
      uint64_t v16 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = [v15 name];
        uint64_t v18 = [v15 reason];
        uint64_t v19 = [v15 userInfo];
        LODWORD(a9) = 138543875;
        *(void *)((char *)&a9 + 4) = v17;
        WORD6(a9) = 2113;
        *(void *)((char *)&a9 + 14) = v18;
        a12 = 2113;
        a13 = v19;
        _os_log_error_impl( &dword_180A4C000,  v16,  OS_LOG_TYPE_ERROR,  "Caught exception during runloop's autorelease pool drain of client objects %{public}@: %{private}@ userInfo: %{private}@",  (uint8_t *)&a9,  0x20u);
      }
    }

    objc_terminate();
    __break(1u);
    JUMPOUT(0x180ACC920LL);
  }

  _Unwind_Resume(exception_object);
}

uint64_t __cftrace_runloop_trace_iteration_start(uint64_t a1, __CFRunLoop *a2)
{
  v15[1] = *MEMORY[0x1895F89C0];
  uint64_t result = kdebug_is_enabled();
  if ((_DWORD)result)
  {
    double v4 = CFRunLoopCopyCurrentMode(a2);
    if (CFEqual(v4, @"kCFRunLoopDefaultMode"))
    {
      BOOL v5 = 0;
    }

    else if (CFEqual(v4, @"kCFRunLoopCommonModes"))
    {
      BOOL v5 = 0;
    }

    else if (CFEqual(v4, @"NSModalPanelRunLoopMode"))
    {
      BOOL v5 = 0;
    }

    else if (CFEqual(v4, @"NSEventTrackingRunLoopMode"))
    {
      BOOL v5 = 0;
    }

    else if (CFEqual(v4, @"UITrackingRunLoopMode"))
    {
      BOOL v5 = 0;
    }

    else if (CFEqual(v4, @"com.apple.run-loop-mode.view-bridge.blocks"))
    {
      BOOL v5 = 0;
    }

    else
    {
      if (CFStringGetCStringPtr(v4, 0x8000100u))
      {
        unint64_t v6 = kdebug_trace_string();
        BOOL v5 = 1;
      }

      else
      {
        CFIndex Length = CFStringGetLength(v4);
        if (Length < 177)
        {
          CFIndex v8 = Length;
        }

        else
        {
          CFIndex v8 = 176LL;
          v16.CFIndex location = 0LL;
          v16.CFIndex length = 176LL;
          CFStringRef v9 = CFStringCreateWithSubstring(0LL, v4, v16);
          CFRelease(v4);
          double v4 = v9;
        }

        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u);
        MEMORY[0x1895F8858](MaximumSizeForEncoding, v11);
        int CString = CFStringGetCString(v4, (char *)v15 - v12, v13, 0x8000100u);
        BOOL v5 = CString != 0;
        if (CString) {
          unint64_t v6 = kdebug_trace_string();
        }
        else {
          unint64_t v6 = -1LL;
        }
      }

      if (v6 >= 0xFFFFFFFFFFFFFFF9LL)
      {
        kdebug_trace_string();
        BOOL v5 = 0;
      }
    }

    CFRelease(v4);
    _CFRunLoopCurrentIsMain();
    uint64_t result = kdebug_trace();
    if (v5) {
      return kdebug_trace_string();
    }
  }

  return result;
}

uint64_t __CFRunLoopDoBlocks(uint64_t a1, uint64_t a2)
{
  uint64_t result = kdebug_trace();
  BOOL v5 = *(void **)(a1 + 640);
  if (!v5) {
    return result;
  }
  unint64_t v6 = *(const void **)(a2 + 80);
  if (!v6) {
    return result;
  }
  unint64_t v7 = *(void **)(a1 + 648);
  *(void *)(a1 + 640) = 0LL;
  *(void *)(a1 + 64_Block_object_dispose(va, 8) = 0LL;
  theSet = *(const __CFSet **)(a1 + 608);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  CFIndex v8 = 0LL;
  CFStringRef v9 = v5;
  do
  {
    while (1)
    {
      uint64_t v10 = v9;
      CFStringRef v9 = (void *)*v9;
      CFTypeID v11 = CFGetTypeID((CFTypeRef)v10[1]);
      uint64_t v12 = (const void *)v10[1];
      if (v11 == 7)
      {
        if (CFEqual(v12, v6)) {
          goto LABEL_11;
        }
        if (!CFEqual((CFTypeRef)v10[1], @"kCFRunLoopCommonModes")) {
          goto LABEL_22;
        }
        break;
      }

      if (CFSetContainsValue((CFSetRef)v12, v6)) {
        goto LABEL_11;
      }
      if (CFSetContainsValue((CFSetRef)v10[1], @"kCFRunLoopCommonModes")) {
        break;
      }
LABEL_22:
      CFIndex v8 = v10;
      if (!v9) {
        goto LABEL_23;
      }
    }

    if (!CFSetContainsValue(theSet, v6)) {
      goto LABEL_22;
    }
LABEL_11:
    if (v8) {
      void *v8 = v9;
    }
    if (v10 == v5) {
      BOOL v5 = v9;
    }
    if (v10 == v7) {
      unint64_t v7 = v8;
    }
    CFIndex v13 = (const void *)v10[2];
    CFRelease((CFTypeRef)v10[1]);
    free(v10);
    if (*(_BYTE *)(a1 + 681)) {
      id v14 = (void *)_CFAutoreleasePoolPush();
    }
    else {
      id v14 = 0LL;
    }
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__((uint64_t)v13);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v14);
    _Block_release(v13);
  }

  while (v9);
LABEL_23:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (v5 && v7)
  {
    void *v7 = *(void *)(a1 + 640);
    *(void *)(a1 + 640) = v5;
    if (!*(void *)(a1 + 648)) {
      *(void *)(a1 + 64_Block_object_dispose(va, 8) = v7;
    }
  }

  return kdebug_trace();
}

uint64_t __CFRunLoopDoSources0(uint64_t a1, uint64_t a2, int a3)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  cf[0] = 0LL;
  unint64_t v6 = *(const __CFSet **)(a2 + 96);
  if (v6
    && CFSetGetCount(v6) >= 1
    && (CFSetApplyFunction(*(CFSetRef *)(a2 + 96), (CFSetApplierFunction)__CFRunLoopCollectSources0, cf), cf[0]))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    if (CFGetTypeID(cf[0]) == 46)
    {
      uint64_t v7 = __CFRunLoopDoSource0(a1, (uint64_t)cf[0]);
    }

    else
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)cf[0]);
      v14.CFIndex location = 0LL;
      v14.CFIndex length = Count;
      CFArraySortValues((CFMutableArrayRef)cf[0], v14, (CFComparatorFunction)__CFRunLoopSourceComparator, 0LL);
      if (Count < 1)
      {
        uint64_t v7 = 0LL;
      }

      else
      {
        CFIndex v9 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf[0], v9);
          uint64_t v11 = __CFRunLoopDoSource0(a1, (uint64_t)ValueAtIndex);
          uint64_t v7 = v11;
          if (a3)
          {
            if ((_DWORD)v11) {
              break;
            }
          }

          if (Count == ++v9) {
            goto LABEL_19;
          }
        }

        uint64_t v7 = 1LL;
      }
    }

uint64_t __CFRunLoopServiceMachPort( mach_port_name_t rcv_name, mach_msg_header_t **a2, mach_port_t *a3, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *a5, id *a6)
{
  char v11 = 0;
  unsigned int v12 = 3072;
  while (1)
  {
    CFIndex v13 = *a2;
    v13->msgh_remote_port = 0;
    v13->mach_port_t msgh_local_port = rcv_name;
    v13->msgh_bits = 0;
    v13->mach_msg_size_t msgh_size = v12;
    v13->msgh_id = 0;
    if (timeout == -1) {
      mach_msg_option_t v14 = 117442566;
    }
    else {
      mach_msg_option_t v14 = 117442822;
    }
    uint64_t v15 = (char *)mach_msg(v13, v14, 0, v13->msgh_size, rcv_name, timeout, 0);
    voucher_mach_msg_revert(*a5);
    voucher_mach_msg_state_t v16 = voucher_mach_msg_adopt(v13);
    *a5 = v16;
    if (a6)
    {
      if (v16 == (voucher_mach_msg_state_t)-1LL) {
        uint64_t v17 = 0LL;
      }
      else {
        uint64_t v17 = voucher_copy();
      }
      *a6 = (id)v17;
    }

    if ((_DWORD)v15 != 268451844) {
      break;
    }
    mach_msg_size_t msgh_size = v13->msgh_size;
    if ((v11 & 1) != 0)
    {
      uint64_t v19 = *a2;
    }

    else
    {
      uint64_t v19 = 0LL;
      *a2 = 0LL;
    }

    unsigned int v12 = (msgh_size + 71) & 0xFFFFFFFC;
    *a2 = (mach_msg_header_t *)__CFSafelyReallocate(v19, (msgh_size + 68 + 3LL) & 0x1FFFFFFFCLL, 0LL);
    char v11 = 1;
    if (a6)
    {
      if (*a6) {
    }
      }
  }

  if ((_DWORD)v15 == 268451843)
  {
    if ((v11 & 1) != 0) {
      free(v13);
    }
    mach_port_t msgh_local_port = 0;
    uint64_t result = 0LL;
    *a2 = 0LL;
  }

  else
  {
    if ((_DWORD)v15) {
      __CFRunLoopServiceMachPort_cold_1(v15);
    }
    mach_port_t msgh_local_port = v13->msgh_local_port;
    uint64_t result = 1LL;
  }

  *a3 = msgh_local_port;
  return result;
}

BOOL __CFRunLoopDoTimers(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = *(const __CFArray **)(a2 + 120);
  if (!v6) {
    goto LABEL_16;
  }
  CFIndex Count = CFArrayGetCount(v6);
  if (Count < 1) {
    goto LABEL_16;
  }
  CFIndex v8 = Count;
  CFMutableArrayRef Mutable = 0LL;
  for (CFIndex i = 0LL; i != v8; ++i)
  {
    ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), i);
    char v12 = atomic_load(ValueAtIndex + 1);
    if ((v12 & 8) != 0)
    {
      CFIndex v13 = ValueAtIndex;
      if ((ValueAtIndex[2] & 1) == 0 && ValueAtIndex[16] <= a3)
      {
        if (!Mutable) {
          CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
        }
        CFArrayAppendValue(Mutable, v13);
      }
    }
  }

  if (Mutable)
  {
    CFIndex v14 = CFArrayGetCount(Mutable);
    if (v14 < 1)
    {
      BOOL v15 = 0;
    }

    else
    {
      BOOL v15 = 0;
      for (CFIndex j = 0LL; j != v14; ++j)
      {
        uint64_t v17 = (char *)CFArrayGetValueAtIndex(Mutable, j);
        BOOL v15 = (v15 | __CFRunLoopDoTimer(a1, a2, v17)) != 0;
      }
    }

    CFRelease(Mutable);
  }

  else
  {
LABEL_16:
    BOOL v15 = 0;
  }

  kdebug_trace();
  return v15;
}

void sub_180ACD360(_Unwind_Exception *a1)
{
}

void sub_180ACD37C()
{
}

uint64_t __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
{
  return _dispatch_main_queue_callback_4CF();
}

uint64_t __CFRunLoopDoSource1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  double v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  uint64_t v13 = v2;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRetain((CFTypeRef)v10);
  CFIndex v14 = (pthread_mutex_t *)(v12 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  BOOL v15 = (pthread_mutex_t *)(v13 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 16));
  char v16 = atomic_load((unint64_t *)(v10 + 8));
  if ((v16 & 8) != 0)
  {
    atomic_store(0LL, (unint64_t *)(v10 + 88));
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    uint64_t v18 = v8;
    uint64_t v19 = v6;
    double v20 = *(uint64_t (**)(uint64_t, uint64_t, __objc2_class **, uint64_t))(v10 + 168);
    uint64_t v21 = *(void *)(v10 + 112);
    if (v13 && !*(_BYTE *)(v13 + 681)) {
      uint64_t v22 = 0LL;
    }
    else {
      uint64_t v22 = (void *)_CFAutoreleasePoolPush();
    }
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(v20, v18, v19, v4, v21);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v22);
    if ((__CF_FORK_STATE & 2) == 0) {
      __CF_USED();
    }
    BOOL v15 = (pthread_mutex_t *)(v13 + 16);
    CFIndex v14 = (pthread_mutex_t *)(v12 + 16);
    if ((__CF_FORK_STATE & 1) != 0) {
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
    uint64_t v17 = 1LL;
  }

  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    uint64_t v17 = 0LL;
  }

  CFRelease((CFTypeRef)v10);
  pthread_mutex_lock(v15);
  pthread_mutex_lock(v14);
  return v17;
}

uint64_t __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void __CFRunLoopCollectSources0(unint64_t *cf, CFTypeRef *a2)
{
  if (!cf[13])
  {
    char v3 = atomic_load(cf + 1);
    if ((v3 & 8) != 0)
    {
      if (atomic_load(cf + 11))
      {
        if (*a2)
        {
          CFTypeID v6 = CFGetTypeID(*a2);
          CFTypeRef v7 = *a2;
          if (v6 == 46)
          {
            CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
            *a2 = Mutable;
            CFArrayAppendValue(Mutable, v7);
            CFArrayAppendValue((CFMutableArrayRef)*a2, cf);
            CFRelease(v7);
          }

          else
          {
            CFArrayAppendValue((CFMutableArrayRef)*a2, cf);
          }
        }

        else
        {
          *a2 = CFRetain(cf);
        }
      }
    }
  }

uint64_t __CFRunLoopDoSource0(uint64_t a1, uint64_t a2)
{
  double v4 = (pthread_mutex_t *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (!atomic_load((unint64_t *)(a2 + 88)))
  {
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  atomic_store(0LL, (unint64_t *)(a2 + 88));
  char v6 = atomic_load((unint64_t *)(a2 + 8));
  pthread_mutex_unlock(v4);
  if ((v6 & 8) == 0) {
    return 0LL;
  }
  CFTypeRef v7 = *(uint64_t (**)(uint64_t))(a2 + 176);
  uint64_t v8 = *(void *)(a2 + 112);
  if (a1 && !*(_BYTE *)(a1 + 681)) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = (void *)_CFAutoreleasePoolPush();
  }
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(v7, v8);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v9);
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return 1LL;
}

uint64_t __CFRunLoopSourceComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  if (v2 < v3) {
    return -1LL;
  }
  if (v3 < v2) {
    return 1LL;
  }
  unint64_t v5 = atomic_load((unint64_t *)(a1 + 88));
  double v6 = (double)v5;
  unint64_t v7 = atomic_load((unint64_t *)(a2 + 88));
  BOOL v8 = v6 < (double)v7;
  BOOL v9 = v6 > (double)v7;
  if (v8) {
    return -1LL;
  }
  else {
    return v9;
  }
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__( uint64_t (*result)(uint64_t), uint64_t a2))(uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t))result(a2);
  }
  return result;
}

uint64_t __CFRunLoopDoTimer(uint64_t a1, uint64_t a2, char *cf)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  CFRetain(cf);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  char v6 = atomic_load((unint64_t *)cf + 1);
  if ((v6 & 8) == 0
    || (uint64_t v7 = *((void *)cf + 16), v7 > mach_absolute_time())
    || (__int16 v8 = *((_WORD *)cf + 8), (v8 & 1) != 0)
    || *((void *)cf + 11) != a1)
  {
    uint64_t v9 = 0LL;
    atomic_load((unint64_t *)cf + 1);
LABEL_6:
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    goto LABEL_7;
  }

  uint64_t v12 = *((void *)cf + 20);
  uint64_t v11 = (uint64_t (*)(void))*((void *)cf + 21);
  if (v11)
  {
    uint64_t v12 = v11(*((void *)cf + 20));
    int v46 = (void (*)(uint64_t))*((void *)cf + 22);
    __int16 v8 = *((_WORD *)cf + 8);
  }

  else
  {
    int v46 = 0LL;
  }

  double v13 = *((double *)cf + 14);
  *((_WORD *)cf + _Block_object_dispose(va, 8) = v8 | 1;
  *(void *)(a2 + 184) = -1LL;
  *(void *)(a2 + 192) = -1LL;
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  os_unfair_lock_lock_with_options();
  unint64_t v14 = *((void *)cf + 16);
  os_unfair_lock_t v44 = (os_unfair_lock_t)(a1 + 684);
  unint64_t v45 = v14;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 684));
  __CFArmNextTimerInMode(a2);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  BOOL v15 = (uint64_t (*)(uint64_t, uint64_t))*((void *)cf + 18);
  char v16 = (void *)_CFAutoreleasePoolPush();
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(v15, (uint64_t)cf, v12);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v16);
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (v13 == 0.0) {
    CFRunLoopTimerInvalidate((CFRunLoopTimerRef)cf);
  }
  if (v46) {
    v46(v12);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  *((_WORD *)cf + 8) &= ~1u;
  char v17 = atomic_load((unint64_t *)cf + 1);
  if ((v17 & 8) == 0)
  {
    uint64_t v9 = 1LL;
    goto LABEL_6;
  }

  if (v45 < *((void *)cf + 16))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    __CFArmNextTimerInMode(a2);
LABEL_44:
    uint64_t v9 = 1LL;
    goto LABEL_7;
  }

  double v18 = *((double *)cf + 14);
  if (v18 <= 0.0)
  {
    unint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    if (v45 >= 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }

  if (v18 > 504911232.0) {
    double v18 = 504911232.0;
  }
  unint64_t v19 = __CFTimeIntervalToTSR(v18);
  if ((v19 ^ 0x7FFFFFFFFFFFFFFFLL) <= v45)
  {
    unint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_34;
  }

  unint64_t v20 = v19;
  if (!v19) {
LABEL_32:
  }
    __CFRunLoopDoTimer_cold_1();
  uint64_t v21 = mach_absolute_time();
  unint64_t v22 = v45 - v20;
  do
    v22 += v20;
  while (v22 <= v21);
LABEL_34:
  uint64_t v23 = (const void *)*((void *)cf + 11);
  if (!v23)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    unint64_t v35 = v44;
    os_unfair_lock_lock(v44);
    *((void *)cf + 16) = v22;
    double Current = CFAbsoluteTimeGetCurrent();
    *((double *)cf + 13) = Current + __CFTimeIntervalUntilTSR(v22);
    os_unfair_lock_unlock(v35);
    goto LABEL_44;
  }

  CFRetain(*((CFTypeRef *)cf + 11));
  CFIndex Count = CFSetGetCount(*((CFSetRef *)cf + 12));
  MEMORY[0x1895F8858](Count, v25);
  int v27 = (const void **)((char *)&v43 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  CFSetGetValues(*((CFSetRef *)cf + 12), v27);
  if (Count < 1)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  }

  else
  {
    double v28 = v27;
    CFIndex v29 = Count;
    do
    {
      uint64_t v30 = *v28++;
      CFRetain(v30);
      --v29;
    }

    while (v29);
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    double v31 = (const __CFString **)v27;
    CFIndex v32 = Count;
    do
    {
      uint64_t v33 = *v31;
      uint64_t v34 = __CFRunLoopCopyMode((uint64_t)v23, *v31, 0);
      *double v31 = (const __CFString *)v34;
      if (v34) {
        pthread_mutex_lock((pthread_mutex_t *)(v34 + 16));
      }
      CFRelease(v33);
      ++v31;
      --v32;
    }

    while (v32);
  }

  uint64_t v37 = v44;
  os_unfair_lock_lock(v44);
  *((void *)cf + 16) = v22;
  double v38 = CFAbsoluteTimeGetCurrent();
  *((double *)cf + 13) = v38 + __CFTimeIntervalUntilTSR(v22);
  if (Count < 1)
  {
    os_unfair_lock_unlock(v37);
  }

  else
  {
    unint64_t v39 = (uint64_t *)v27;
    CFIndex v40 = Count;
    do
    {
      if (*v39) {
        __CFRepositionTimerInMode(*v39, cf, 1);
      }
      ++v39;
      --v40;
    }

    while (v40);
    os_unfair_lock_unlock(v44);
    unint64_t v41 = v27 - 1;
    do
    {
      unint64_t v42 = (char *)v41[Count];
      if (v42)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v42 + 16));
        CFRelease(v41[Count]);
      }

      --Count;
    }

    while ((unint64_t)(Count + 1) > 1);
  }

  CFRelease(v23);
  uint64_t v9 = 1LL;
LABEL_7:
  CFRelease(cf);
  return v9;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__( uint64_t (*result)(uint64_t, uint64_t), uint64_t a2, uint64_t a3))(uint64_t, uint64_t)
{
  if (result) {
    return (uint64_t (*)(uint64_t, uint64_t))result(a2, a3);
  }
  return result;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__( uint64_t (*result)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a2, uint64_t a3, uint64_t (**a4)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a5))(uint64_t, uint64_t, __objc2_class **, uint64_t)
{
  if (result)
  {
    uint64_t result = (uint64_t (*)(uint64_t, uint64_t, __objc2_class **, uint64_t))result( a2,  a3,  &__kCFAllocatorSystemDefault,  a5);
    *a4 = result;
  }

  return result;
}

uint64_t __CFRunLoopRemoveSourcesFromCommonMode(uint64_t a1, uint64_t a2)
{
  return __CFRunLoopRemoveAllSources(a2, a1);
}

void __CFRunLoopRemoveSourceFromMode(CFRunLoopSourceRef source, uint64_t a2)
{
}

uint64_t __CFRunLoopInsertionIndexInTimerArray(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0LL;
  }
  uint64_t v5 = Count;
  if ((unint64_t)Count >= 0x101)
  {
    if (*((void *)CFArrayGetValueAtIndex(a1, Count - 1) + 16) <= *(void *)(a2 + 128)) {
      return v5;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(a1, 0LL);
    uint64_t result = 0LL;
    if (*(void *)(a2 + 128) < ValueAtIndex[16]) {
      return result;
    }
  }

  uint64_t v8 = 0LL;
  uint64_t v9 = 2 << flsl(v5);
  do
  {
    if (v9 >= 0) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 + 1;
    }
    if (v8 + (v10 >> 1) >= v5)
    {
      BOOL v14 = 0LL;
    }

    else
    {
      unint64_t v11 = *((void *)CFArrayGetValueAtIndex(a1, v8 + (v10 >> 1)) + 16);
      unint64_t v12 = *(void *)(a2 + 128);
      BOOL v13 = v11 > v12;
      BOOL v14 = v11 <= v12;
      if (!v13) {
        v8 += v10 >> 1;
      }
    }

    BOOL v13 = v9 <= 1;
    uint64_t v9 = v10 >> 1;
  }

  while (!v13);
  return v14 + v8;
}

void __CFOAInitialize()
{
  if (__CFgetenv("OAKeepAllocationStatistics"))
  {
    pthread_t v0 = (void (*)(void))__CFOAInitialize_dyfunc;
    if (__CFOAInitialize_dyfunc == -1)
    {
      pthread_t v0 = (void (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OAInitialize");
      __CFOAInitialize_dyfunc = (uint64_t)v0;
      if (!v0) {
        return;
      }
    }

    else if (!__CFOAInitialize_dyfunc)
    {
      return;
    }

    v0();
    __CFObjectAllocRecordAllocationFunction = (uint64_t (*)(void, void, void, void, void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OARecordAllocationEvent");
    __CFObjectAllocSetLastAllocEventNameFunction = (uint64_t (*)(void))dlsym( (void *)0xFFFFFFFFFFFFFFFELL,  "_OASetLastAllocationEventName");
    __CFOAInitializeNSObject();
    __CFOASafe = 1;
  }

char *__CFgetenv(char *__s1)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    uint64_t v3 = (&__CFEnv)[v2];
    if (v3)
    {
      if (!strcmp(__s1, v3)) {
        break;
      }
    }

    v2 += 2LL;
    if (v2 == 22) {
      return getenv(__s1);
    }
  }

  return (&__CFEnv)[v2 + 1];
}

uint64_t __CFRecordAllocationEvent()
{
  if (__CFOASafe) {
    BOOL v0 = __CFObjectAllocRecordAllocationFunction == 0LL;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0) {
    return __CFObjectAllocRecordAllocationFunction();
  }
  return result;
}

uint64_t __CFSetLastAllocationEventName()
{
  if (__CFOASafe) {
    BOOL v0 = __CFObjectAllocSetLastAllocEventNameFunction == 0LL;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0) {
    return __CFObjectAllocSetLastAllocEventNameFunction();
  }
  return result;
}

void *__CFRuntimeEnumerateClassTable( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void *, uint64_t, void **), uint64_t a4)
{
  __dst[33] = *MEMORY[0x1895F89C0];
  uint64_t v8 = (*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeBuiltinClassTable");
  if (v8 && !a3(a1, (void *)v8, 576LL, (void **)__dst))
  {
    for (uint64_t i = 0LL; i != 576; i += 8LL)
      (*(void (**)(uint64_t, void))(a4 + 16))(a4, *(void *)(__dst[0] + i));
  }

  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeClassTables");
  if (result)
  {
    uint64_t result = (void *)a3(a1, result, 264LL, &__src);
    if (!(_DWORD)result)
    {
      uint64_t result = memcpy(__dst, __src, 0x108uLL);
      int v11 = atomic_load((unsigned int *)&__dst[32]);
      if (v11 >= 1)
      {
        unsigned int v12 = 0;
        int v13 = -1;
        do
        {
          if (v12 >> 6 != v13)
          {
            uint64_t result = (void *)a3(a1, (void *)__dst[v12 >> 6], 512LL, (void **)&v15);
            int v13 = v12 >> 6;
            if ((_DWORD)result) {
              break;
            }
          }

          uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void))(a4 + 16))( a4,  *(void *)(v15 + 8LL * (v12++ & 0x3F)));
          signed int v14 = atomic_load((unsigned int *)&__dst[32]);
        }

        while ((int)v12 < v14);
      }
    }
  }

  return result;
}

unint64_t CF_IS_OBJC(unint64_t result, __objc2_class **a2)
{
  uint64_t v2 = *a2;
  if (!*a2)
  {
    if (result) {
      CF_IS_OBJC_cold_1();
    }
    return result;
  }

  if (result == 7 && v2 == __CFConstantStringClassReferencePtr) {
    return 0LL;
  }
  if (result <= 0x47)
  {
    uint64_t v3 = &__CFRuntimeBuiltinObjCClassTable[result];
    goto LABEL_13;
  }

  int v4 = result - 72;
  if ((int)result - 72 < dword_18C45D280)
  {
    uint64_t v5 = __CFRuntimeClassTables[(v4 >> 6) + 16];
    if (v5)
    {
      uint64_t v3 = (uint64_t *)(v5 + 8LL * (v4 & 0x3F));
LABEL_13:
      char v6 = (__objc2_class *)*v3;
      if (v2 == v6) {
        return 0LL;
      }
      goto LABEL_16;
    }
  }

  char v6 = 0LL;
LABEL_16:
  return (*MEMORY[0x189616640] & (unint64_t)v2) != (void)v6;
}

uint64_t _CFRuntimeRegisterClass( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)a1 & 8) != 0 && !*(void *)(a1 + 80))
  {
    CFLog( 4LL,  (uint64_t)@"*** _CFRuntimeRegisterClass() given inconsistent class '%s'.  Program will crash soon.",  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a1 + 8));
    return 0LL;
  }

  os_unfair_lock_lock_with_options();
  if (dword_18C45D280 >= 1024)
  {
    CFLog( 4LL,  (uint64_t)@"*** CoreFoundation class table full; registration failing for class '%s'.  Program will crash soon.",
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      *(void *)(a1 + 8));
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    return 0LL;
  }

  int v15 = dword_18C45D280;
  uint64_t v16 = (uint64_t)dword_18C45D280 >> 6;
  char v17 = (void *)__CFRuntimeClassTables[dword_18C45D280 >> 6];
  if (!v17)
  {
    char v17 = calloc(0x40uLL, 8uLL);
    double v18 = calloc(0x40uLL, 8uLL);
    __dmb(0xBu);
    unint64_t v19 = &__CFRuntimeClassTables[v16];
    void *v19 = v17;
    v19[16] = v18;
    if (!v17) {
      _CFRuntimeRegisterClass_cold_1();
    }
  }

  uint64_t v20 = v15 + 72LL;
  v17[v15 & 0x3F] = a1;
  *(void *)(__CFRuntimeClassTables[v16 + 16] + 8LL * (v15 & 0x3F)) = qword_18C45D2B8;
  do
    unsigned int v21 = __ldxr((unsigned int *)&dword_18C45D280);
  while (__stxr(v21 + 1, (unsigned int *)&dword_18C45D280));
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  return v20;
}

void _CFRuntimeBridgeClasses(unint64_t a1, const char *a2)
{
  if (a1 > 0x47)
  {
    uint64_t v6 = __CFRuntimeClassTables[(((int)a1 - 72) >> 6) + 16];
    FutureClass Class = objc_getFutureClass(a2);
    uint64_t v5 = (uint64_t *)(v6 + 8LL * (((_DWORD)a1 - 72) & 0x3F));
  }

  else
  {
    FutureClass Class = objc_getFutureClass(a2);
    uint64_t v5 = &__CFRuntimeBuiltinObjCClassTable[a1];
  }

  uint64_t *v5 = (uint64_t)FutureClass;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

uint64_t _CFRuntimeGetClassWithTypeID(unint64_t a1)
{
  if (a1 <= 0x47)
  {
    int v1 = &__CFRuntimeBuiltinClassTable + a1;
    return (uint64_t)*v1;
  }

  int v2 = a1 - 72;
  if ((int)a1 - 72 < dword_18C45D280)
  {
    uint64_t v3 = __CFRuntimeClassTables[v2 >> 6];
    if (v3)
    {
      int v1 = (_UNKNOWN **)(v3 + 8LL * (v2 & 0x3F));
      return (uint64_t)*v1;
    }
  }

  return 0LL;
}

void _CFRuntimeUnregisterClassWithTypeID(unint64_t a1)
{
  if (a1 <= 0x47) {
    _CFRuntimeUnregisterClassWithTypeID_cold_1();
  }
  int v1 = a1;
  os_unfair_lock_lock_with_options();
  *(void *)(__CFRuntimeClassTables[(v1 - 72) >> 6] + 8LL * ((v1 - 72) & 0x3F)) = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

void _CFEnableZombies()
{
  if (!__CFZombieEnabled)
  {
    __CFZombieEnabled = -1;
    __CFZombifyNSObject();
  }

uint64_t _CFRuntimeCreateInstance( const __CFAllocator *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0x47)
  {
    uint64_t v12 = (uint64_t *)*(&__CFRuntimeBuiltinClassTable + a2);
    if (!v12) {
      return 0LL;
    }
LABEL_10:
    uint64_t v16 = *v12;
    if ((*v12 & 0x10) != 0) {
      char v17 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
    else {
      char v17 = a1;
    }
    if ((v16 & 8) != 0 && !v12[10])
    {
      CFLog( 4LL,  (uint64_t)@"*** _CFRuntimeCreateInstance() found inconsistent class '%s'.",  a3,  a4,  a5,  a6,  a7,  a8,  v12[1]);
      return 0LL;
    }

    double v18 = (__objc2_class **)v17;
    if (!v17)
    {
      uint64_t v19 = _CFGetTSD(1u);
      if (v19) {
        double v18 = (__objc2_class **)v19;
      }
      else {
        double v18 = &__kCFAllocatorSystemDefault;
      }
    }

    if (&__kCFAllocatorNull == v18) {
      return 0LL;
    }
    if (&__kCFAllocatorSystemDefault == v18)
    {
      BOOL v21 = 1;
    }

    else if (v18)
    {
      BOOL v21 = 0;
    }

    else
    {
      BOOL v21 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }

    if ((*(_BYTE *)v12 & 0x10) != 0)
    {
      size_t v25 = v12[11];
      BOOL v22 = !v21;
      size_t v26 = (a3 + 16LL * !v21 + 31) & 0xFFFFFFFFFFFFFFF0LL;
      int v27 = malloc_default_zone();
      uint64_t v24 = (unint64_t *)malloc_zone_memalign(v27, v25, v26);
    }

    else
    {
      BOOL v22 = !v21;
      unint64_t v23 = (a3 + 16LL * !v21 + 31) & 0xFFFFFFFFFFFFFFF0LL;
      if (!__CFAllocatorRespectsHintZeroWhenAllocating((__objc2_class **)v17))
      {
        CFIndex v40 = (unint64_t *)CFAllocatorAllocate(v17, v23, 0LL);
        uint64_t v20 = v40;
        if (!v40) {
          return (uint64_t)v20;
        }
        bzero(v40, v23);
        goto LABEL_33;
      }

      uint64_t v24 = (unint64_t *)CFAllocatorAllocate(v17, v23, 1uLL);
    }

    uint64_t v20 = v24;
    if (!v24) {
      return (uint64_t)v20;
    }
LABEL_33:
    if (a4 && __CFOASafe)
    {
      double v28 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction) {
        goto LABEL_41;
      }
      CFIndex v29 = v20;
      uint64_t v30 = a4;
    }

    else
    {
      if (!__CFOASafe) {
        goto LABEL_41;
      }
      double v28 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction) {
        goto LABEL_41;
      }
      uint64_t v30 = v12[1];
      CFIndex v29 = v20;
    }

    ((void (*)(unint64_t *, uint64_t))v28)(v29, v30);
LABEL_41:
    if (v22)
    {
      CFTypeRef v31 = CFRetain(v18);
      uint64_t v32 = 0LL;
      *uint64_t v20 = (unint64_t)v31;
      v20 += 2;
    }

    else
    {
      uint64_t v32 = 128LL;
    }

    uint64_t v33 = v32 | ((_DWORD)a2 << 8);
    uint64_t v34 = -8388608LL;
    if ((v16 & 8) == 0) {
      uint64_t v34 = 0x1000000000000LL;
    }
    atomic_store(v33 | v34, v20 + 1);
    *uint64_t v20 = 0LL;
    if (a2 > 0x47)
    {
      int v36 = a2 - 72;
      if ((int)a2 - 72 >= dword_18C45D280 || (uint64_t v37 = __CFRuntimeClassTables[(v36 >> 6) + 16]) == 0)
      {
        double v38 = 0LL;
LABEL_53:
        object_setClass(v20, v38);
        unint64_t v39 = (void (*)(unint64_t *))v12[2];
        if (v39) {
          v39(v20);
        }
        return (uint64_t)v20;
      }

      unint64_t v35 = (objc_class **)(v37 + 8LL * (v36 & 0x3F));
    }

    else
    {
      unint64_t v35 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
    }

    double v38 = *v35;
    goto LABEL_53;
  }

  uint64_t result = os_unfair_lock_lock_with_options();
  if (dword_18C45D280 + 72LL > a2)
  {
    int v14 = a2 - 72;
    else {
      uint64_t v12 = 0LL;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    if (!v12) {
      return 0LL;
    }
    goto LABEL_10;
  }

  __break(1u);
  return result;
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  if (!cf) {
    CFRetain_cold_1();
  }
  int v1 = (void *)cf;
  if (((unint64_t)cf & 0x8000000000000000LL) == 0)
  {
    unint64_t v2 = atomic_load((unint64_t *)cf + 1);
    else {
      return _CFRetain((unint64_t *)v1, 0);
    }
  }

  return cf;
}

Class _CFRuntimeInitStaticInstance( Class result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Class v8 = result;
  if (a2 > 0x47)
  {
    int v10 = a2 - 72;
    uint64_t v11 = __CFRuntimeClassTables[v10 >> 6];
    if (!v11) {
      goto LABEL_19;
    }
    uint64_t v9 = (uint64_t *)(v11 + 8LL * (v10 & 0x3F));
  }

  else
  {
    uint64_t v9 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a2);
  }

  uint64_t v12 = *v9;
  if (!*v9)
  {
LABEL_19:
    __break(1u);
    return result;
  }

  if ((*(_BYTE *)v12 & 8) != 0) {
    return (Class)CFLog( 3LL,  (uint64_t)@"*** Cannot initialize a static instance to a class (%s) with custom ref counting",  a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(v12 + 8));
  }
  atomic_store(((_DWORD)a2 << 8) | 0x80LL, (unint64_t *)&result[1]);
  result->isa = 0LL;
  if (a2 <= 0x47)
  {
    uint64_t v13 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
LABEL_14:
    uint64_t v16 = *v13;
    goto LABEL_16;
  }

  int v14 = a2 - 72;
  if ((int)a2 - 72 < dword_18C45D280)
  {
    uint64_t v15 = __CFRuntimeClassTables[(v14 >> 6) + 16];
    if (v15)
    {
      uint64_t v13 = (objc_class **)(v15 + 8LL * (v14 & 0x3F));
      goto LABEL_14;
    }
  }

  uint64_t v16 = 0LL;
LABEL_16:
  uint64_t result = object_setClass(result, v16);
  char v17 = *(uint64_t (**)(Class))(v12 + 16);
  if (v17) {
    return (Class)v17(v8);
  }
  return result;
}

uint64_t _CFRuntimeSetInstanceTypeID(uint64_t result, unint64_t a2)
{
  if (a2 > 0x47)
  {
    int v3 = a2 - 72;
    uint64_t v4 = __CFRuntimeClassTables[v3 >> 6];
    if (!v4) {
      goto LABEL_26;
    }
    unint64_t v2 = (void **)(v4 + 8LL * (v3 & 0x3F));
  }

  else
  {
    unint64_t v2 = (void **)(&__CFRuntimeBuiltinClassTable + a2);
  }

  uint64_t v5 = *v2;
  if (*v2)
  {
    uint64_t v6 = (unint64_t *)(result + 8);
    unint64_t v7 = atomic_load((unint64_t *)(result + 8));
    unint64_t v8 = (v7 >> 8) & 0x3FF;
    if (v8 > 0x47)
    {
      unsigned int v10 = v8 - 72;
      if ((int)v8 - 72 >= dword_18C45D280 || (uint64_t v11 = __CFRuntimeClassTables[v10 >> 6]) == 0)
      {
        uint64_t v12 = 0LL;
LABEL_14:
        if ((*v12 & 8) != 0 || v8 && (*v5 & 8) != 0) {
          return CFLog(3LL, @"*** Cannot change the CFTypeID of a %s to a %s due to custom ref counting");
        }
        unint64_t v13 = atomic_load(v6);
        while (1)
        {
          unint64_t v14 = __ldaxr(v6);
          if (v14 != v13) {
            break;
          }
          int v15 = 1;
LABEL_24:
          unint64_t v13 = v14;
          if (v15) {
            return result;
          }
        }

        __clrex();
LABEL_23:
        int v15 = 0;
        goto LABEL_24;
      }

      uint64_t v9 = (_BYTE **)(v11 + 8LL * (v10 & 0x3F));
    }

    else
    {
      uint64_t v9 = (_BYTE **)(&__CFRuntimeBuiltinClassTable + v8);
    }

    uint64_t v12 = *v9;
    goto LABEL_14;
  }

Class _CFRuntimeSetInstanceTypeIDAndIsa(objc_class **a1, unint64_t a2)
{
  Class result = (Class)_CFRuntimeSetInstanceTypeID((uint64_t)a1, a2);
  uint64_t v5 = *a1;
  if (a2 >= 0x48)
  {
    int v7 = a2 - 72;
    if ((int)a2 - 72 >= dword_18C45D280)
    {
      isa = 0LL;
    }

    else
    {
      isa = (objc_class *)__CFRuntimeClassTables[(v7 >> 6) + 16];
      if (isa) {
        isa = isa[v7 & 0x3F].isa;
      }
    }

    if (v5 != isa)
    {
      if (v7 >= dword_18C45D280 || (uint64_t v9 = __CFRuntimeClassTables[(v7 >> 6) + 16]) == 0)
      {
        unsigned int v10 = 0LL;
        return object_setClass(a1, v10);
      }

      uint64_t v6 = (objc_class **)(v9 + 8LL * (v7 & 0x3F));
LABEL_13:
      unsigned int v10 = *v6;
      return object_setClass(a1, v10);
    }
  }

  else
  {
    uint64_t v6 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
    if (v5 != *v6) {
      goto LABEL_13;
    }
  }

  return result;
}

uint64_t __CFRuntimeIsFreedObject(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    if (!__CFRuntimeIsFreedObject_freedClass) {
      __CFRuntimeIsFreedObject_freedClass Class = _objc_getFreedObjectClass();
    }
    Class Class = object_getClass(v1);
    if (Class == (Class)__CFRuntimeIsFreedObject_freedClass) {
      return 1LL;
    }
    int v3 = Class;
    Class result = (uint64_t)object_getClass(Class);
    if (!result) {
      return result;
    }
    Name = class_getName(v3);
    return Name && !strncmp(Name, "_NSZombie_", 0xAuLL);
  }

  return result;
}

uint64_t __CFGenericTypeID(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v1 = 0LL;
    uint64_t v2 = *MEMORY[0x189616658];
    unint64_t v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v1)) {
        break;
      }
      ++v1;
    }

    while (v1 != 7);
    unint64_t v4 = v1 | v3;
    uint64_t v5 = v1 & 7;
    int v6 = (v4 >> 55) + 8;
    if (v5 != 7) {
      int v6 = v5;
    }
    uint64_t v7 = 22LL;
    switch(v6)
    {
      case 0:
        return 1LL;
      case 1:
        goto LABEL_17;
      case 2:
        return 7LL;
      case 3:
        return v7;
      case 4:
      case 5:
        return 1LL;
      case 6:
        return 42LL;
      default:
        if (v6 == 20) {
          return 1LL;
        }
        if (v6 == 22) {
          return 7LL;
        }
LABEL_17:
        uint64_t result = [a1 _cfTypeID];
        break;
    }
  }

  else
  {
    unint64_t v8 = atomic_load(a1 + 1);
    return (v8 >> 8) & 0x3FF;
  }

  return result;
}

uint64_t CFTypeGetTypeID()
{
  return 1LL;
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  if (((unint64_t)cf & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = *MEMORY[0x189616658];
    unint64_t v4 = v3 ^ (unint64_t)cf;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v2)) {
        break;
      }
      ++v2;
    }

    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      LODWORD(v6) = v7;
    }
    CFTypeID result = 22LL;
    switch((int)v6)
    {
      case 0:
        goto LABEL_18;
      case 1:
        return [(id)cf _cfTypeID];
      case 2:
        goto LABEL_17;
      case 3:
        return result;
      case 4:
      case 5:
        goto LABEL_18;
      case 6:
        return 42LL;
      default:
        if ((_DWORD)v6 == 20)
        {
LABEL_18:
          CFTypeID result = 1LL;
        }

        else
        {
          if ((_DWORD)v6 != 22) {
            return [(id)cf _cfTypeID];
          }
LABEL_17:
          CFTypeID result = 7LL;
        }

        break;
    }
  }

  else
  {
    unint64_t v9 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v9 >> 8) & 0x3FF, (__objc2_class **)cf))
    {
      return [(id)cf _cfTypeID];
    }

    else
    {
      unint64_t v10 = atomic_load((unint64_t *)cf + 1);
      return (v10 >> 8) & 0x3FF;
    }
  }

  return result;
}

uint64_t _CFGetNonObjCTypeID(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v1 = 0LL;
    uint64_t v2 = *MEMORY[0x189616658];
    unint64_t v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v1)) {
        break;
      }
      ++v1;
    }

    while (v1 != 7);
    unint64_t v4 = v1 | v3;
    uint64_t v5 = v1 & 7;
    int v6 = (v4 >> 55) + 8;
    if (v5 != 7) {
      int v6 = v5;
    }
    uint64_t v7 = 22LL;
    switch(v6)
    {
      case 0:
        return 1LL;
      case 1:
        goto LABEL_17;
      case 2:
        return 7LL;
      case 3:
        return v7;
      case 4:
      case 5:
        return 1LL;
      case 6:
        return 42LL;
      default:
        if (v6 == 20) {
          return 1LL;
        }
        if (v6 == 22) {
          return 7LL;
        }
LABEL_17:
        uint64_t result = [a1 _cfTypeID];
        break;
    }
  }

  else
  {
    unint64_t v8 = atomic_load(a1 + 1);
    return (v8 >> 8) & 0x3FF;
  }

  return result;
}

uint64_t _CFGetTypeIDDescription(unint64_t a1)
{
  if (a1 > 0x47)
  {
    int v2 = a1 - 72;
    uint64_t v3 = __CFRuntimeClassTables[v2 >> 6];
    if (!v3) {
      return 0LL;
    }
    uint64_t v1 = (uint64_t *)(v3 + 8LL * (v2 & 0x3F));
  }

  else
  {
    uint64_t v1 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a1);
  }

  uint64_t v4 = 0LL;
  if (a1 != 1)
  {
    uint64_t v5 = *v1;
    if (v5) {
      return *(void *)(v5 + 8);
    }
  }

  return v4;
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  if (type_id > 0x47) {
    uint64_t v1 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)type_id - 72) >> 6] + 8LL * (((_DWORD)type_id - 72) & 0x3F));
  }
  else {
    uint64_t v1 = &__CFRuntimeBuiltinClassTable + type_id;
  }
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *((const char **)*v1 + 1), 0x600u);
}

unint64_t *_CFNonObjCRetain(unint64_t *a1)
{
  return _CFRetain(a1, 0);
}

unint64_t *_CFRetain(unint64_t *cf, int a2)
{
  int v2 = cf;
  uint64_t v3 = cf + 1;
  unint64_t v4 = atomic_load(cf + 1);
  if ((v4 & 0x800000) == 0)
  {
    unint64_t v5 = v4;
    while (!a2 || (v5 & 0x600000) == 0)
    {
      if (!HIWORD(v5)) {
        return v2;
      }
      v4 &= 0xFFFFFFFFFFFFuLL;
      if (HIWORD(v5) != 0xFFFF) {
        unint64_t v4 = v5 + 0x1000000000000LL;
      }
      while (1)
      {
        unint64_t v6 = __ldaxr(v3);
        if (v6 != v5) {
          break;
        }
        if (!__stlxr(v4, v3))
        {
          int v7 = 1;
          goto LABEL_12;
        }
      }

      int v7 = 0;
      __clrex();
LABEL_12:
      unint64_t v5 = v6;
      if (v7) {
        goto LABEL_23;
      }
    }

    return 0LL;
  }

  if (a2) {
    return 0LL;
  }
  unint64_t v8 = (v4 >> 8) & 0x3FF;
  if (v8 > 0x47) {
    unint64_t v9 = (_UNKNOWN **)(__CFRuntimeClassTables[(v8 - 72) >> 6] + 8LL * (((_DWORD)v8 - 72) & 0x3F));
  }
  else {
    unint64_t v9 = &__CFRuntimeBuiltinClassTable + v8;
  }
  unint64_t v10 = *v9;
  uint64_t v11 = (void (*)(uint64_t, unint64_t *))*((void *)*v9 + 10);
  if (!v11 || (*v10 & 8) == 0) {
    _CFRetain_cold_1();
  }
  if (v4 <= 0xFFFEFFFFFFFFFFFFLL) {
    _CFRetain_cold_2();
  }
  v11(1LL, cf);
LABEL_23:
  if (__CFOASafe)
  {
    CFIndex v13 = CFGetRetainCount(v2);
    if (__CFOASafe)
    {
      if (__CFObjectAllocRecordAllocationFunction) {
        __CFObjectAllocRecordAllocationFunction(28LL, v2, 0LL, v13, 0LL);
      }
    }
  }

  return v2;
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  if (!arg) {
    CFAutorelease_cold_1();
  }
  CFTypeRef v2 = (id)arg;
  return arg;
}

void _CFRelease(void *ptr)
{
  name[32] = *(char **)MEMORY[0x1895F89C0];
  CFTypeRef v2 = (unint64_t *)((char *)ptr + 8);
  unint64_t v3 = atomic_load((unint64_t *)ptr + 1);
  unint64_t v4 = (v3 >> 8) & 0x3FF;
  if (v4 > 0x47)
  {
    unsigned int v6 = v4 - 72;
    if ((int)v4 - 72 >= dword_18C45D280 || (uint64_t v7 = __CFRuntimeClassTables[v6 >> 6]) == 0)
    {
      uint64_t v8 = 0LL;
      if ((v3 & 0x200000) == 0) {
        goto LABEL_7;
      }
LABEL_49:
      _CFRelease_cold_3((char *)name, v8);
    }

    unint64_t v5 = (uint64_t *)(v7 + 8LL * (v6 & 0x3F));
  }

  else
  {
    unint64_t v5 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + v4);
  }

  uint64_t v8 = *v5;
  if ((v3 & 0x200000) != 0) {
    goto LABEL_49;
  }
LABEL_7:
  if (!__CFOASafe)
  {
    CFIndex v9 = 0LL;
    if ((v3 & 0x800000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_104;
  }

  CFIndex v9 = CFGetRetainCount(ptr);
  if ((v3 & 0x800000) != 0)
  {
LABEL_104:
    uint64_t v47 = *(void (**)(uint64_t, void *))(v8 + 80);
    if (!v47 || (*(_BYTE *)v8 & 8) == 0) {
      _CFRelease_cold_1();
    }
    if (v3 <= 0xFFFEFFFFFFFFFFFFLL) {
      _CFRelease_cold_2();
    }
    v47(-1LL, ptr);
LABEL_108:
    if (__CFOASafe)
    {
      if (__CFObjectAllocRecordAllocationFunction) {
        __CFObjectAllocRecordAllocationFunction(29LL, ptr, 0LL, v9 - 1, 0LL);
      }
    }

    return;
  }

  while (1)
  {
LABEL_9:
    while (HIWORD(v3) != 1)
    {
      if (!HIWORD(v3)) {
        return;
      }
      while (1)
      {
        unint64_t v10 = __ldaxr(v2);
        if (v10 != v3) {
          break;
        }
        if (!__stlxr(v3 - 0x1000000000000LL, v2))
        {
          int v11 = 1;
          goto LABEL_21;
        }
      }

      int v11 = 0;
      __clrex();
LABEL_21:
      unint64_t v3 = v10;
      if (v11) {
        goto LABEL_108;
      }
    }

    if ((*(_BYTE *)v8 & 4) != 0)
    {
      uint64_t v12 = *(void (**)(void *))(v8 + 72);
      if (v12) {
        v12(ptr);
      }
    }

    while (1)
    {
      unint64_t v13 = __ldaxr(v2);
      if (v13 != v3) {
        break;
      }
      if (!__stlxr(v3 | 0x400000, v2))
      {
        int v14 = 1;
        goto LABEL_24;
      }
    }

    int v14 = 0;
    __clrex();
LABEL_24:
    unint64_t v3 = v13;
    if (v14)
    {
      int v15 = *(void (**)(void *))(v8 + 32);
      if (v15) {
        v15(ptr);
      }
      unint64_t v16 = atomic_load(v2);
      BOOL v17 = v4 == 2 || HIWORD(v16) == 1;
      char v18 = v17;
      if (!v17)
      {
        while (1)
        {
          unint64_t v3 = atomic_load(v2);
          while (1)
          {
            unint64_t v21 = __ldaxr(v2);
            if (v21 != v3) {
              break;
            }
            if (!__stlxr(v3 & 0xFFFFFFFFFFBFFFFFLL, v2)) {
              goto LABEL_41;
            }
          }

          __clrex();
        }
      }

      do
      {
        unint64_t v3 = v16;
        unint64_t v19 = (v16 | 0x200000) - 0x1000000000000LL;
        while (1)
        {
          unint64_t v16 = __ldaxr(v2);
          if (v16 != v3) {
            break;
          }
          if (!__stlxr(v19, v2))
          {
            char v20 = 1;
            goto LABEL_40;
          }
        }

        char v20 = 0;
        __clrex();
LABEL_40:
        ;
      }

      while ((v20 & 1) == 0);
LABEL_41:
      if ((v18 & 1) != 0) {
        break;
      }
    }
  }

  if (__CFOASafe && __CFObjectAllocRecordAllocationFunction) {
    __CFObjectAllocRecordAllocationFunction(29LL, ptr, 0LL, 0LL, 0LL);
  }
  if (v4 == 2)
  {
    __CFAllocatorDeallocate(ptr);
    return;
  }

  char v22 = atomic_load(v2);
  if (v22 < 0)
  {
    CFAllocatorRef v26 = 0LL;
    BOOL v25 = 1;
    uint64_t v24 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }

  else
  {
    unint64_t v23 = (__objc2_class **)CFGetAllocator(ptr);
    uint64_t v24 = (const __CFAllocator *)v23;
    if (&__kCFAllocatorSystemDefault == v23)
    {
      BOOL v25 = 1;
    }

    else if (v23)
    {
      BOOL v25 = 0;
    }

    else
    {
      BOOL v25 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }

    if (((unint64_t)ptr & 0x8000000000000000LL) != 0
      || (unint64_t v27 = atomic_load((unint64_t *)ptr + 1),
          CF_IS_OBJC((v27 >> 8) & 0x3FF, (__objc2_class **)ptr))
      || (unint64_t v28 = atomic_load(v2), (v28 & 0x3FF00) == 0x200))
    {
      CFAllocatorRef v26 = 0LL;
    }

    else
    {
      char v45 = atomic_load(v2);
      if (v45 < 0) {
        int v46 = &kCFAllocatorSystemDefault;
      }
      else {
        int v46 = (const CFAllocatorRef *)((char *)ptr - 16);
      }
      CFAllocatorRef v26 = *v46;
    }
  }

  int v29 = __CFZombieEnabled;
  Class Class = object_getClass(ptr);
  CFTypeRef v31 = Class;
  if (!v29)
  {
    if (object_getClass(Class)) {
      objc_destructInstance(ptr);
    }
    goto LABEL_95;
  }

  os_unfair_lock_lock_with_options();
  unint64_t v32 = 0LL;
  uint64_t v33 = (uint64_t *)&__CFRuntimeBuiltinClassTable;
  while (v32 < dword_18C45D280 + 72LL)
  {
    int v34 = v32 - 72;
    if (v32 >= 0x48)
    {
      if (v34 >= dword_18C45D280)
      {
        isa = 0LL;
      }

      else
      {
        isa = (objc_class *)__CFRuntimeClassTables[(v34 >> 6) + 16];
        if (isa) {
          isa = isa[v34 & 0x3F].isa;
        }
      }

      if (isa != v31 || v34 >= dword_18C45D280 || (uint64_t v37 = __CFRuntimeClassTables[v34 >> 6]) == 0)
      {
LABEL_80:
        unint64_t v39 = 0LL;
        goto LABEL_81;
      }

      unint64_t v35 = (uint64_t *)(v37 + 8LL * (v34 & 0x3F));
    }

    else
    {
      unint64_t v35 = v33;
      if ((objc_class *)__CFRuntimeBuiltinObjCClassTable[v32] != v31) {
        goto LABEL_80;
      }
    }

    uint64_t v38 = *v35;
    if (!v38) {
      goto LABEL_80;
    }
    unint64_t v39 = *(const char **)(v38 + 8);
LABEL_81:
    ++v32;
    ++v33;
    if (v39)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
      goto LABEL_88;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  if (object_getClass(v31)) {
    unint64_t v39 = class_getName(v31);
  }
  else {
    unint64_t v39 = 0LL;
  }
LABEL_88:
  CFIndex v40 = "$class-unknown$";
  if (v39) {
    CFIndex v40 = v39;
  }
  name[0] = 0LL;
  asprintf(name, "_NSZombie_%s", v40);
  unint64_t v41 = objc_lookUpClass(name[0]);
  if (!v41)
  {
    unint64_t v42 = objc_lookUpClass("_NSZombie_");
    unint64_t v41 = objc_duplicateClass(v42, name[0], 0LL);
  }

  free(name[0]);
  if (object_getClass(v31)) {
    objc_destructInstance(ptr);
  }
  int v43 = __CFDeallocateZombies;
  object_setClass(ptr, v41);
  if (v43)
  {
LABEL_95:
    uint64_t v44 = -16LL;
    if (v25) {
      uint64_t v44 = 0LL;
    }
    CFAllocatorDeallocate(v24, (char *)ptr + v44);
  }

  if (v26) {
    CFRelease(v26);
  }
}

void CFRelease(CFTypeRef cf)
{
  if (!cf) {
    CFRelease_cold_1();
  }
  if (((unint64_t)cf & 0x8000000000000000LL) == 0)
  {
    unint64_t v2 = atomic_load((unint64_t *)cf + 1);
    else {
      _CFRelease((void *)cf);
    }
  }

CFStringRef __CFStringCollectionCopy(const __CFAllocator *a1, const __CFString *a2)
{
  if (!a2) {
    __CFStringCollectionCopy_cold_1();
  }
  return CFStringCreateCopy(a1, a2);
}

CFTypeRef __CFTypeCollectionRetain(int a1, CFTypeRef cf)
{
  if (!cf) {
    __CFTypeCollectionRetain_cold_1();
  }
  return CFRetain(cf);
}

void __CFTypeCollectionRelease(int a1, CFTypeRef cf)
{
  if (!cf) {
    __CFTypeCollectionRelease_cold_1();
  }
  CFRelease(cf);
}

BOOL __CFRuntimeIsImmortal(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  return HIWORD(v1) == 0;
}

void __CFRuntimeSetImmortal(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  atomic_store(v1 & 0xFFFFFFFFFFFFLL, (unint64_t *)(a1 + 8));
}

void __CFRuntimeSetRC(uint64_t a1, unsigned __int16 a2)
{
  unint64_t v2 = atomic_load((unint64_t *)(a1 + 8));
  atomic_store(v2 & 0xFFFFFFFFFFFFLL | ((unint64_t)a2 << 48), (unint64_t *)(a1 + 8));
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  if (!cf) {
    CFGetRetainCount_cold_1();
  }
  unint64_t v3 = atomic_load((unint64_t *)cf + 1);
  unint64_t v4 = atomic_load((unint64_t *)cf + 1);
  if ((v4 & 0x800000) != 0)
  {
    unint64_t v7 = (v4 >> 8) & 0x3FF;
    if (v7 > 0x47) {
      uint64_t v8 = (_UNKNOWN **)(__CFRuntimeClassTables[(v7 - 72) >> 6] + 8LL * (((_DWORD)v7 - 72) & 0x3F));
    }
    else {
      uint64_t v8 = &__CFRuntimeBuiltinClassTable + v7;
    }
    CFIndex v9 = *v8;
    unint64_t v10 = (unsigned int (*)(void, CFTypeRef))*((void *)*v8 + 10);
    if (v10 && (*v9 & 8) != 0)
    {
      if (v4 > 0xFFFEFFFFFFFFFFFFLL) {
        return v10(0LL, cf);
      }
    }

    else
    {
      __break(1u);
    }

    CFGetRetainCount_cold_2();
  }

  unint64_t v5 = atomic_load((unint64_t *)cf + 1);
  CFIndex v6 = HIWORD(v5);
  if (v6) {
    return v6;
  }
  else {
    return 0xFFFFFFFFFFFFFFFLL;
  }
}

uint64_t _CFNonObjCEqual(unint64_t *a1, unint64_t *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a2) {
    _CFNonObjCEqual_cold_1();
  }
  if (((unint64_t)a2 & 0x8000000000000000LL) != 0)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = *MEMORY[0x189616658];
    unint64_t v6 = v5 ^ (unint64_t)a2;
    do
    {
      if ((v6 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v4)) {
        break;
      }
      ++v4;
    }

    while (v4 != 7);
    unint64_t v7 = v4 | v6;
    uint64_t v8 = v4 & 7;
    int v9 = (v7 >> 55) + 8;
    if (v8 == 7) {
      LODWORD(v_Block_object_dispose(va, 8) = v9;
    }
    unint64_t v10 = 22LL;
    switch((int)v8)
    {
      case 0:
        goto LABEL_19;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_18;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_19;
      case 6:
        unint64_t v10 = 42LL;
        break;
      default:
        if ((_DWORD)v8 == 20)
        {
LABEL_19:
          unint64_t v10 = 1LL;
        }

        else if ((_DWORD)v8 == 22)
        {
LABEL_18:
          unint64_t v10 = 7LL;
        }

        else
        {
LABEL_20:
          unint64_t v10 = [a2 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v12 = atomic_load(a2 + 1);
    unint64_t v10 = (v12 >> 8) & 0x3FF;
  }

  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = *MEMORY[0x189616658];
    unint64_t v15 = v14 ^ (unint64_t)a1;
    do
    {
      if ((v15 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v13)) {
        break;
      }
      ++v13;
    }

    while (v13 != 7);
    unint64_t v16 = v13 | v15;
    uint64_t v17 = v13 & 7;
    int v18 = (v16 >> 55) + 8;
    if (v17 == 7) {
      LODWORD(v17) = v18;
    }
    uint64_t v19 = 22LL;
    switch((int)v17)
    {
      case 0:
        goto LABEL_39;
      case 1:
        goto LABEL_40;
      case 2:
        goto LABEL_38;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_39;
      case 6:
        uint64_t v19 = 42LL;
        break;
      default:
        if ((_DWORD)v17 == 20)
        {
LABEL_39:
          uint64_t v19 = 1LL;
        }

        else if ((_DWORD)v17 == 22)
        {
LABEL_38:
          uint64_t v19 = 7LL;
        }

        else
        {
LABEL_40:
          uint64_t v19 = [a1 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v20 = atomic_load(a1 + 1);
    uint64_t v19 = (v20 >> 8) & 0x3FF;
  }

  if (((unint64_t)a2 & 0x8000000000000000LL) != 0)
  {
    uint64_t v21 = 0LL;
    uint64_t v22 = *MEMORY[0x189616658];
    unint64_t v23 = v22 ^ (unint64_t)a2;
    do
    {
      if ((v23 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v21)) {
        break;
      }
      ++v21;
    }

    while (v21 != 7);
    unint64_t v24 = v21 | v23;
    uint64_t v25 = v21 & 7;
    int v26 = (v24 >> 55) + 8;
    if (v25 == 7) {
      LODWORD(v25) = v26;
    }
    uint64_t v27 = 22LL;
    switch((int)v25)
    {
      case 0:
        goto LABEL_57;
      case 1:
        goto LABEL_58;
      case 2:
        goto LABEL_56;
      case 3:
        goto LABEL_60;
      case 4:
      case 5:
        goto LABEL_57;
      case 6:
        uint64_t v27 = 42LL;
        goto LABEL_60;
      default:
        if ((_DWORD)v25 == 20)
        {
LABEL_57:
          uint64_t v27 = 1LL;
        }

        else if ((_DWORD)v25 == 22)
        {
LABEL_56:
          uint64_t v27 = 7LL;
        }

        else
        {
LABEL_58:
          uint64_t v27 = [a2 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v28 = atomic_load(a2 + 1);
    uint64_t v27 = (v28 >> 8) & 0x3FF;
  }

  if (v19 != v27) {
    return 0LL;
  }
LABEL_60:
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v29 = 0LL;
    uint64_t v30 = *MEMORY[0x189616658];
    unint64_t v31 = v30 ^ (unint64_t)a1;
    do
    {
      if ((v31 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v29)) {
        break;
      }
      ++v29;
    }

    while (v29 != 7);
    unint64_t v32 = v29 | v31;
    uint64_t v33 = v29 & 7;
    int v34 = (v32 >> 55) + 8;
    if (v33 == 7) {
      LODWORD(v33) = v34;
    }
    unint64_t v35 = 22LL;
    switch((int)v33)
    {
      case 0:
        goto LABEL_78;
      case 1:
        goto LABEL_79;
      case 2:
        goto LABEL_77;
      case 3:
        goto LABEL_81;
      case 4:
      case 5:
        goto LABEL_78;
      case 6:
        unint64_t v35 = 42LL;
        goto LABEL_81;
      default:
        if ((_DWORD)v33 == 20)
        {
LABEL_78:
          unint64_t v35 = 1LL;
          goto LABEL_81;
        }

        if ((_DWORD)v33 == 22)
        {
LABEL_77:
          unint64_t v35 = 7LL;
          goto LABEL_81;
        }

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  if (!cf1) {
    CFEqual_cold_1();
  }
  if (cf1 == cf2) {
    return 1;
  }
  if (!cf2) {
    CFEqual_cold_2();
  }
  if (((unint64_t)cf1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v4 = *MEMORY[0x189616658];
    unint64_t v5 = (unint64_t)cf1 & 0xC000000000000007LL;
    if (((unint64_t)cf2 & 0x8000000000000000LL) != 0)
    {
      uint64_t v6 = 0LL;
      if (v5 == 0xC000000000000007LL) {
        uint64_t v7 = 0LL;
      }
      else {
        uint64_t v7 = *MEMORY[0x189616658];
      }
      do
      {
        ++v6;
      }

      while (v6 != 7);
      uint64_t v8 = 0LL;
      unint64_t v9 = v6 | v7 ^ (unint64_t)cf1;
      uint64_t v10 = v6 & 7;
      int v11 = (v9 >> 55) + 8;
      if (v10 == 7) {
        LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v11;
      }
      else {
        uint64_t v12 = 0LL;
      }
      unint64_t v13 = v12 ^ (unint64_t)cf2;
      do
      {
        if ((v13 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v8)) {
          break;
        }
        ++v8;
      }

      while (v8 != 7);
      unint64_t v14 = v8 | v13;
      uint64_t v15 = v8 & 7;
      int v16 = (v14 >> 55) + 8;
      if (v15 != 7) {
        int v16 = v15;
      }
    }

    uint64_t v17 = 0LL;
    if (v5 == 0xC000000000000007LL) {
      uint64_t v4 = 0LL;
    }
    unint64_t v18 = v4 ^ (unint64_t)cf1;
    do
    {
      if ((v18 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v17)) {
        break;
      }
      ++v17;
    }

    while (v17 != 7);
    int v19 = ((v17 | v18) >> 55) + 8;
    if ((v17 & 7) != 7) {
      int v19 = v17 & 7;
    }
    unint64_t v20 = 22LL;
    switch(v19)
    {
      case 0:
        goto LABEL_53;
      case 1:
        goto LABEL_58;
      case 2:
        goto LABEL_52;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_53;
      case 6:
        unint64_t v20 = 42LL;
        break;
      default:
        if (v19 == 20)
        {
LABEL_53:
          unint64_t v20 = 1LL;
        }

        else if (v19 == 22)
        {
LABEL_52:
          unint64_t v20 = 7LL;
        }

        else
        {
LABEL_58:
          unint64_t v20 = [(id)cf1 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v22 = atomic_load((unint64_t *)cf1 + 1);
    unint64_t v20 = (v22 >> 8) & 0x3FF;
  }

  if (CF_IS_OBJC(v20, (__objc2_class **)cf1))
  {
    unint64_t v23 = (void *)cf1;
    CFTypeRef v24 = cf2;
    return [v23 isEqual:v24];
  }

  if (((unint64_t)cf2 & 0x8000000000000000LL) != 0)
  {
    uint64_t v25 = 0LL;
    uint64_t v26 = *MEMORY[0x189616658];
    unint64_t v27 = v26 ^ (unint64_t)cf2;
    do
    {
      if ((v27 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v25)) {
        break;
      }
      ++v25;
    }

    while (v25 != 7);
    unint64_t v28 = v25 | v27;
    uint64_t v29 = v25 & 7;
    int v30 = (v28 >> 55) + 8;
    if (v29 == 7) {
      LODWORD(v29) = v30;
    }
    unint64_t v31 = 22LL;
    switch((int)v29)
    {
      case 0:
        goto LABEL_57;
      case 1:
        goto LABEL_60;
      case 2:
        goto LABEL_56;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_57;
      case 6:
        unint64_t v31 = 42LL;
        break;
      default:
        if ((_DWORD)v29 == 20)
        {
LABEL_57:
          unint64_t v31 = 1LL;
        }

        else if ((_DWORD)v29 == 22)
        {
LABEL_56:
          unint64_t v31 = 7LL;
        }

        else
        {
LABEL_60:
          unint64_t v31 = [(id)cf2 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v32 = atomic_load((unint64_t *)cf2 + 1);
    unint64_t v31 = (v32 >> 8) & 0x3FF;
  }

  if (CF_IS_OBJC(v31, (__objc2_class **)cf2))
  {
    unint64_t v23 = (void *)cf2;
    CFTypeRef v24 = cf1;
    return [v23 isEqual:v24];
  }

  if (((unint64_t)cf1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v33 = 0LL;
    uint64_t v34 = *MEMORY[0x189616658];
    unint64_t v35 = v34 ^ (unint64_t)cf1;
    do
    {
      if ((v35 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v33)) {
        break;
      }
      ++v33;
    }

    while (v33 != 7);
    unint64_t v36 = v33 | v35;
    uint64_t v37 = v33 & 7;
    int v38 = (v36 >> 55) + 8;
    if (v37 == 7) {
      LODWORD(v37) = v38;
    }
    uint64_t v39 = 22LL;
    switch((int)v37)
    {
      case 0:
        goto LABEL_80;
      case 1:
        goto LABEL_81;
      case 2:
        goto LABEL_79;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_80;
      case 6:
        uint64_t v39 = 42LL;
        break;
      default:
        if ((_DWORD)v37 == 20)
        {
LABEL_80:
          uint64_t v39 = 1LL;
        }

        else if ((_DWORD)v37 == 22)
        {
LABEL_79:
          uint64_t v39 = 7LL;
        }

        else
        {
LABEL_81:
          uint64_t v39 = [(id)cf1 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v40 = atomic_load((unint64_t *)cf1 + 1);
    uint64_t v39 = (v40 >> 8) & 0x3FF;
  }

  if (((unint64_t)cf2 & 0x8000000000000000LL) != 0)
  {
    uint64_t v41 = 0LL;
    uint64_t v42 = *MEMORY[0x189616658];
    unint64_t v43 = v42 ^ (unint64_t)cf2;
    do
    {
      if ((v43 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v41)) {
        break;
      }
      ++v41;
    }

    while (v41 != 7);
    unint64_t v44 = v41 | v43;
    uint64_t v45 = v41 & 7;
    int v46 = (v44 >> 55) + 8;
    if (v45 == 7) {
      LODWORD(v45) = v46;
    }
    uint64_t v47 = 22LL;
    switch((int)v45)
    {
      case 0:
        goto LABEL_98;
      case 1:
        goto LABEL_99;
      case 2:
        goto LABEL_97;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_98;
      case 6:
        uint64_t v47 = 42LL;
        break;
      default:
        if ((_DWORD)v45 == 20)
        {
LABEL_98:
          uint64_t v47 = 1LL;
        }

        else if ((_DWORD)v45 == 22)
        {
LABEL_97:
          uint64_t v47 = 7LL;
        }

        else
        {
LABEL_99:
          uint64_t v47 = [(id)cf2 _cfTypeID];
        }

        break;
    }
  }

  else
  {
    unint64_t v48 = atomic_load((unint64_t *)cf2 + 1);
    uint64_t v47 = (v48 >> 8) & 0x3FF;
  }

  if (v39 == v47)
  {
    if (((unint64_t)cf1 & 0x8000000000000000LL) != 0)
    {
      int TaggedPointerTag = _objc_getTaggedPointerTag((uint64_t)cf1);
      unint64_t v50 = 22LL;
      switch(TaggedPointerTag)
      {
        case 0:
          goto LABEL_112;
        case 1:
          goto LABEL_113;
        case 2:
          goto LABEL_111;
        case 3:
          goto LABEL_115;
        case 4:
        case 5:
          goto LABEL_112;
        case 6:
          unint64_t v50 = 42LL;
          goto LABEL_115;
        default:
          if (TaggedPointerTag == 20)
          {
LABEL_112:
            unint64_t v50 = 1LL;
            goto LABEL_115;
          }

          if (TaggedPointerTag == 22)
          {
LABEL_111:
            unint64_t v50 = 7LL;
            goto LABEL_115;
          }

LABEL_113:
          unint64_t v50 = [(id)cf1 _cfTypeID];
          break;
      }
    }

    else
    {
      unint64_t v51 = atomic_load((unint64_t *)cf1 + 1);
      unint64_t v50 = (v51 >> 8) & 0x3FF;
    }

    if (v50 <= 0x47) {
LABEL_115:
    }
      uint64_t v52 = &__CFRuntimeBuiltinClassTable + v50;
    else {
      uint64_t v52 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v50 - 72) >> 6] + 8LL * (((_DWORD)v50 - 72) & 0x3F));
    }
    BOOL v53 = (uint64_t (*)(CFTypeRef, CFTypeRef))*((void *)*v52 + 5);
    if (v53) {
      return v53(cf1, cf2);
    }
  }

  return 0;
}

                        v157 = (unint64_t)v13;
                        if (*v66 != 61)
                        {
                          malloc_zone_t *v27 = 125;
                          v154 = v27 + 1;
                          v157 = (unint64_t)v30;
                          v86 = calloc(1uLL, 0x29uLL);
                          v86[37] = 0;
                          *((_DWORD *)v86 + 5) = a2;
                          void *v8 = (uint64_t)v86;
                          unint64_t v5 = v149;
                          if (!*((_DWORD *)v8 + 4)) {
                            goto LABEL_168;
                          }
                          goto LABEL_75;
                        }

                        malloc_zone_t *v27 = 61;
                        int v67 = v27 + 1;
                        uint64_t v68 = v66 + 1;
                        v157 = (unint64_t)(v66 + 1);
                        if ((unint64_t)(v66 + 1) >= v63)
                        {
                          id v71 = 0LL;
                          uint64_t v70 = 0LL;
LABEL_162:
                          v154 = v67 + 1;
                          *int v67 = 125;
                          v157 = (unint64_t)v30;
                          if (v71 <= 1) {
                            v98 = 1LL;
                          }
                          else {
                            v98 = v71;
                          }
                          int v65 = (v70 + v98 - 1) / v98 * v98;
                          goto LABEL_167;
                        }

                        mach_port_t v69 = 0LL;
                        uint64_t v70 = 0LL;
                        id v71 = 0LL;
                        while (2)
                        {
                          __NSGetSizeAndAlignment(v68, v161, &v160, (uint64_t)v68, 1LL, 0LL, 1uLL);
                          unsigned int v72 = v160;
                          if (v71 <= v160) {
                            id v71 = v160;
                          }
                          if (!v160)
                          {
                            v160 = 1LL;
                            unsigned int v72 = 1LL;
                          }

                          CFTypeRef v73 = (v72 + v70 - 1) / v72 * v72;
                          v74 = parseFrameArgumentInfo(&v157, v73 + a2, 1LL, v152);
                          v81 = v74;
                          if (!v74) {
                            goto LABEL_228;
                          }
                          v82 = v161[0];
                          if (v161[0] != *(_DWORD *)(v74 + 16))
                          {
                            v142 = v74 + 37;
                            v143 = *(unsigned int *)(v74 + 16);
                            CFLog( 4LL,  (uint64_t)@"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)",  v75,  v76,  v77,  v78,  v79,  v80,  v161[0]);
                            v82 = *(unsigned int *)(v81 + 16);
                          }

                          v83 = *(_BYTE *)(v81 + 37);
                          if (v83)
                          {
                            v84 = (unsigned __int8 *)(v81 + 38);
                            do
                            {
                              *v67++ = v83;
                              v85 = *v84++;
                              v83 = v85;
                            }

                            while (v85);
                          }

                          if (*v8)
                          {
                            if (v69) {
                              goto LABEL_130;
                            }
                          }

                          else
                          {
                            void *v8 = v81;
                            if (v69) {
LABEL_130:
                            }
                              *(void *)(v69 + _Block_object_dispose(va, 8) = v81;
                          }

                          uint64_t v70 = v82 + v73;
                          uint64_t v68 = (_BYTE *)v157;
                          mach_port_t v69 = v81;
                          if (v157 >= v63) {
                            goto LABEL_162;
                          }
                          continue;
                        }
                      }

                      if (v28 == 125) {
                        goto LABEL_112;
                      }
                    }

                    else if (!v28 || v28 == 41)
                    {
LABEL_112:
                      uint64_t v66 = v10 + 1;
                      goto LABEL_113;
                    }

                    if (v28) {
                      ++i;
                    }
                  }
                }

                unint64_t v32 = -1LL;
              }

              else
              {
                unint64_t v32 = v31 == 123;
              }

              v29 += v32;
              uint64_t v33 = *v30++;
              unint64_t v31 = v33;
            }

            while (v33);
          }

          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'",  v10,  v142,  v143);
        }

        goto LABEL_251;
      default:
        __NSMethodFrameArgInfoDestroy(v8);
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%c' in '%s'",  v14,  *v148);
        v140 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
        objc_exception_throw(v140);
        goto LABEL_263;
    }
  }

uint64_t _objc_getTaggedPointerTag(uint64_t a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  uint64_t v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v1)) {
      break;
    }
    ++v1;
  }

  while (v1 != 7);
  unint64_t v4 = v1 | v3;
  uint64_t v5 = v1 & 7;
  unsigned int v6 = (v4 >> 55) + 8;
  if (v5 == 7) {
    return v6;
  }
  else {
    return v5;
  }
}

uint64_t _CFNonObjCHash(unint64_t *a1)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = *MEMORY[0x189616658];
    unint64_t v4 = v3 ^ (unint64_t)a1;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v2)) {
        break;
      }
      ++v2;
    }

    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      LODWORD(v6) = v7;
    }
    unint64_t v8 = 22LL;
    switch((int)v6)
    {
      case 0:
        goto LABEL_18;
      case 1:
        goto LABEL_19;
      case 2:
        goto LABEL_17;
      case 3:
        goto LABEL_21;
      case 4:
      case 5:
        goto LABEL_18;
      case 6:
        unint64_t v8 = 42LL;
        goto LABEL_21;
      default:
        if ((_DWORD)v6 == 20)
        {
LABEL_18:
          unint64_t v8 = 1LL;
          goto LABEL_21;
        }

        if ((_DWORD)v6 == 22)
        {
LABEL_17:
          unint64_t v8 = 7LL;
          goto LABEL_21;
        }

CFHashCode CFHash(CFTypeRef cf)
{
  if (!cf) {
    CFHash_cold_1();
  }
  if (((unint64_t)cf & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = (uint64_t *)MEMORY[0x189616658];
    uint64_t v4 = *MEMORY[0x189616658];
    unint64_t v5 = (unint64_t)cf & 0xC000000000000007LL;
    unint64_t v6 = v4 ^ (unint64_t)cf;
    unint64_t v7 = v6 & 7;
    uint64_t v8 = MEMORY[0x189616648];
    do
    {
      ++v2;
    }

    while (v2 != 7);
    unint64_t v9 = v2 | v6;
    uint64_t v10 = v2 & 7;
    int v11 = (v9 >> 55) + 8;
    if (v10 == 7) {
      LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v11;
    }
    if ((_DWORD)v10)
    {
      if ((_DWORD)v10 == 3)
      {
        uint64_t v12 = __CFNumberHash;
        return v12((uint64_t)cf);
      }
    }

    else
    {
      if ((dyld_program_sdk_at_least() & 1) != 0) {
        CFHash_cold_4();
      }
      uint64_t v18 = *v3;
      if (v5 == 0xC000000000000007LL) {
        uint64_t v18 = 0LL;
      }
      unint64_t v6 = v18 ^ (unint64_t)cf;
      unint64_t v7 = v6 & 7;
    }

    for (uint64_t i = 0LL; i != 7; ++i)
    {
    }

    int v20 = ((i | v6) >> 55) + 8;
    if ((i & 7) != 7) {
      int v20 = i & 7;
    }
    unint64_t v21 = 22LL;
    switch(v20)
    {
      case 0:
        goto LABEL_37;
      case 1:
        goto LABEL_38;
      case 2:
        goto LABEL_36;
      case 3:
        goto LABEL_40;
      case 4:
      case 5:
        goto LABEL_37;
      case 6:
        unint64_t v21 = 42LL;
        goto LABEL_40;
      default:
        if (v20 == 20)
        {
LABEL_37:
          unint64_t v21 = 1LL;
        }

        else if (v20 == 22)
        {
LABEL_36:
          unint64_t v21 = 7LL;
        }

        else
        {
LABEL_38:
          unint64_t v21 = [(id)cf _cfTypeID];
        }

LABEL_56:
            unint64_t v15 = [(id)cf _cfTypeID];
            break;
        }

        break;
    }
  }

  else
  {
    unint64_t v13 = atomic_load((unint64_t *)cf + 1);
    unint64_t v14 = atomic_load((unint64_t *)cf + 1);
    unint64_t v15 = (v14 >> 8) & 0x3FF;
  }

  if (v15 > 0x47) {
    int v16 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v15 - 72) >> 6] + 8LL * (((_DWORD)v15 - 72) & 0x3F));
  }
  else {
LABEL_16:
  }
    int v16 = &__CFRuntimeBuiltinClassTable + v15;
  uint64_t v12 = (uint64_t (*)(uint64_t))*((void *)*v16 + 6);
  if (v12) {
    return v12((uint64_t)cf);
  }
  return (CFHashCode)cf;
}

    CFRetain(v13);
LABEL_57:
    CFArrayAppendValue(v13, cf);
    CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, cf, v10);
    CFRelease(v10);
    CFRelease(v13);
    *((void *)cf + 2) |= 0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    goto LABEL_58;
  }

  if ((cf[17] & 1) != 0)
  {
    unint64_t v21 = CFGetAllocator(cf);
    v46.version = 0LL;
    v46.info = cf;
    *(_OWORD *)&v46.retain = 0uLL;
    v46.copyDescription = CFCopyDescription;
    memset(&v46.equal, 0, 32);
    v46.perform = (void (__cdecl *)(void *))_cfstream_solo_signalEventSync;
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    uint64_t v22 = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, cf);
    uint64_t v23 = CFRetain(v22);
    unint64_t v24 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, v23);
    CFIndex Count = CFArrayGetCount(v24);
    v48.CFIndex location = 0LL;
    v48.CFIndex length = Count;
    FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v24, v48, cf);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v24, FirstIndexOfValue);
      --Count;
    }

    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      int v27 = *((void *)cf + 4);
      if (v27 && (unint64_t v28 = *(__CFRunLoopSource **)(v27 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v27 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        uint64_t v29 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0LL);
        int v30 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1LL);
        CFRunLoopRemoveSource(v29, v28, v30);
        CFRelease(v28);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }

      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, v23);
    }

    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, cf);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v34 = *((void *)cf + 4);
    if (v34)
    {
      unint64_t v35 = *(void **)(v34 + 56);
      if (v35)
      {
        CFRetain(*(CFTypeRef *)(v34 + 56));
        *(void *)(*((void *)cf + 4) + 56LL) = 0LL;
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        CFRelease(v35);
        if (!Count) {
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v35);
        }
        CFRelease(v35);
        goto LABEL_41;
      }

      *(void *)(v34 + 56) = 0LL;
    }

    pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_41:
    *((void *)cf + 2) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    unint64_t v9 = CFRunLoopSourceCreate(v21, 0LL, &v46);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    unint64_t v36 = *((void *)cf + 4);
    if (v36)
    {
      uint64_t v37 = *(const void **)(v36 + 56);
      if (v37)
      {
        CFRetain(*(CFTypeRef *)(v36 + 56));
        unint64_t v36 = *((void *)cf + 4);
      }

      *(void *)(v36 + 56) = v9;
      if (v9) {
        CFRetain(v9);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      if (v37)
      {
        CFRelease(v37);
        CFRelease(v37);
      }
    }

    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }

    int v38 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0LL);
    uint64_t v39 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1LL);
    CFRunLoopAddSource(v38, v9, v39);
    CFRelease(v23);
    goto LABEL_50;
  }

  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  uint64_t v8 = *((void *)cf + 4);
  if (v8)
  {
    unint64_t v9 = *(CFRunLoopSourceRef *)(v8 + 56);
    if (v9)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_50:
      CFRunLoopAddSource((CFRunLoopRef)a2, v9, a3);
      CFRelease(v9);
      goto LABEL_58;
    }
  }

  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_58:
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  unint64_t v40 = *(__CFArray **)(*((void *)cf + 4) + 64LL);
  if (!v40)
  {
    uint64_t v41 = CFGetAllocator(cf);
    unint64_t v40 = CFArrayCreateMutable(v41, 0LL, &kCFTypeArrayCallBacks);
    *(void *)(*((void *)cf + 4) + 64LL) = v40;
  }

  CFArrayAppendValue(v40, a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*((void *)cf + 4) + 64LL), a3);
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
  if (v6)
  {
    uint64_t v42 = *(void (**)(char *, void *, const __CFString *, void))(v6 + 120);
    if (v42)
    {
      *((void *)cf + 2) |= 0x40uLL;
      v42(cf, a2, a3, *((void *)cf + 5));
      *((void *)cf + 2) &= ~0x40uLL;
    }
  }

  unint64_t v43 = *((void *)cf + 4);
  if (v43 && *(void *)(v43 + 72))
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    unint64_t v44 = *((void *)cf + 4);
    if (v44 && (uint64_t v45 = *(__CFRunLoopSource **)(v44 + 56)) != 0LL)
    {
      CFRetain(*(CFTypeRef *)(v44 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      CFRunLoopSourceSignal(v45);
      CFRelease(v45);
      _wakeUpRunLoop((uint64_t)cf);
    }

    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }

          if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
          {
            uint64_t v10 = v12 != 0;
            if (v12) {
              unint64_t v31 = v13 + 1;
            }
            else {
              unint64_t v31 = v13;
            }
            unint64_t v13 = v31 + 2;
            if (!a5) {
              goto LABEL_71;
            }
            if (v13 <= a5)
            {
              if (v12) {
                *a4++ = 14;
              }
              if (v14 >= 0xE05E) {
                unint64_t v32 = 126;
              }
              else {
                unint64_t v32 = 73;
              }
              *a4 = v32;
              if (v14 >= 0xE05E) {
                uint64_t v33 = 67;
              }
              else {
                uint64_t v33 = 33;
              }
              a4[1] = (v33 + v14) & 0x7F;
              a4 += 2;
              goto LABEL_71;
            }

            goto LABEL_165;
          }

                  unint64_t v36 = (unsigned __int16 *)&MacKorean_to_uni_three_char;
                  uint64_t v37 = (unsigned __int16 *)&unk_180CA35CE;
                  while (1)
                  {
                    int v38 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v37 - v36)) >> 1;
                    uint64_t v39 = &v36[17 * v38];
                    unint64_t v40 = *v39;
                    if (v40 <= v25)
                    {
                      if (v40 + 16 > v25)
                      {
                        char v80 = v36[17 * v38 + 1 + (int)(v25 - v40)];
                        if (!v80)
                        {
LABEL_63:
                          uint64_t v41 = (unsigned __int16 *)&MacKorean_to_uni_five_char;
                          uint64_t v42 = (unsigned __int16 *)&unk_180CA37AA;
                          while (1)
                          {
                            unint64_t v43 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v42 - v41)) >> 1;
                            unint64_t v44 = &v41[17 * v43];
                            uint64_t v45 = *v44;
                            if (v45 <= v25)
                            {
                              if (v45 + 16 > v25)
                              {
                                v93 = v41[17 * v43 + 1 + (int)(v25 - v45)];
                                if (v93)
                                {
                                  v94 = ((v93 & 0x8000u) != 0) & (a1 >> 9);
                                  v95 = 4LL;
                                  if (!v94) {
                                    v95 = 5LL;
                                  }
                                  v12 += v95;
                                  if (!a5)
                                  {
                                    int v19 = 2LL;
                                    int v16 = v23;
                                    goto LABEL_185;
                                  }

                                  if (v12 <= a5)
                                  {
                                    if ((v94 & 1) == 0) {
                                      *a4++ = __CFFiveCharDecompSeqTable[5 * (v93 & 0x7FFF)];
                                    }
                                    v101 = (char *)&__CFFiveCharDecompSeqTable[5 * (v93 & 0x7FFF)];
                                    *(_DWORD *)a4 = *(_DWORD *)(v101 + 2);
                                    a4[2] = *((_WORD *)v101 + 3);
                                    v102 = v14 ^ 1;
                                    if ((v93 & 0x8000u) != 0) {
                                      v102 = 0;
                                    }
                                    if ((v102 & 1) != 0)
                                    {
                                      a4 += 3;
                                    }

                                    else
                                    {
                                      a4[3] = *((_WORD *)v101 + 4);
                                      a4 += 4;
                                    }

                                    int v19 = 2LL;
                                    int v16 = v23;
LABEL_185:
                                    uint64_t v17 = v22;
LABEL_17:
                                    *a6 = v12;
LABEL_18:
                                    v13 += v19;
                                    a2 += v19;
                                    int v20 = (uint64_t)v9 <= v19;
                                    v9 -= v19;
                                    if (!v20) {
                                      goto LABEL_8;
                                    }
                                  }

                                  return v13;
                                }

      *(void *)(a1 + _Block_object_dispose(va, 8) = ++v14;
    }

    unint64_t v25 = v24 - 48;
    goto LABEL_37;
  }

  if ((_DWORD)v12 == 34 || (_DWORD)v12 == 39) {
    return parseQuotedPlistString(a1, v12);
  }
LABEL_66:
  if ((v12 - 48) >= 0xA
    && (unsigned __int16)((v12 & 0xFFDF) - 65) >= 0x1Au
    && ((v12 - 36) > 0x3B || ((1LL << (v12 - 36)) & 0x800000000400E01LL) == 0))
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    if (a2)
    {
      uint64_t v42 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unexpected character '0x%x' at line %d", v12, v42);
      goto LABEL_3;
    }

    return 0LL;
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
  return parseUnquotedPlistString(a1);
}

CFStringRef CFCopyDescription(CFStringRef cf)
{
  if (!cf) {
    return cf;
  }
  uint64_t v1 = (__CFString *)cf;
  if (((unint64_t)cf & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = (uint64_t *)MEMORY[0x189616658];
    uint64_t v4 = *MEMORY[0x189616658];
    unint64_t v5 = (unint64_t)cf & 0xC000000000000007LL;
    unint64_t v6 = v4 ^ (unint64_t)cf;
    unint64_t v7 = v6 & 7;
    uint64_t v8 = MEMORY[0x189616648];
    do
    {
      ++v2;
    }

    while (v2 != 7);
    unint64_t v9 = v2 | v6;
    uint64_t v10 = v2 & 7;
    int v11 = (v9 >> 55) + 8;
    if (v10 == 7) {
      LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v11;
    }
    if ((_DWORD)v10)
    {
      if ((_DWORD)v10 == 6)
      {
        uint64_t v12 = (__CFString *(*)(unint64_t *))__CFDateCopyDescription;
        return v12((unint64_t *)cf);
      }

      if ((_DWORD)v10 == 3)
      {
        uint64_t v12 = __CFNumberCopyDescription;
        return v12((unint64_t *)cf);
      }
    }

    else
    {
      if ((dyld_program_sdk_at_least() & 1) != 0) {
        CFCopyDescription_cold_3();
      }
      uint64_t v23 = *v3;
      if (v5 == 0xC000000000000007LL) {
        uint64_t v23 = 0LL;
      }
      unint64_t v6 = v23 ^ (unint64_t)v1;
      unint64_t v7 = v6 & 7;
    }

    for (uint64_t i = 0LL; i != 7; ++i)
    {
    }

    int v25 = ((i | v6) >> 55) + 8;
    if ((i & 7) != 7) {
      int v25 = i & 7;
    }
    unint64_t v26 = 22LL;
    switch(v25)
    {
      case 0:
        goto LABEL_46;
      case 1:
        goto LABEL_47;
      case 2:
        goto LABEL_45;
      case 3:
        goto LABEL_49;
      case 4:
      case 5:
        goto LABEL_46;
      case 6:
        unint64_t v26 = 42LL;
        goto LABEL_49;
      default:
        if (v25 == 20)
        {
LABEL_46:
          unint64_t v26 = 1LL;
        }

        else if (v25 == 22)
        {
LABEL_45:
          unint64_t v26 = 7LL;
        }

        else
        {
LABEL_47:
          unint64_t v26 = -[__CFString _cfTypeID](v1, "_cfTypeID");
        }

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  if (!cf
    || ((unint64_t)cf & 0x8000000000000000LL) != 0
    || (unint64_t v2 = atomic_load((unint64_t *)cf + 1), CF_IS_OBJC((v2 >> 8) & 0x3FF, (__objc2_class **)cf)))
  {
    uint64_t v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    return *v3;
  }

  unint64_t v5 = atomic_load((unint64_t *)cf + 1);
  if ((v5 & 0x3FF00) != 0x200)
  {
    char v6 = atomic_load((unint64_t *)cf + 1);
    if (v6 < 0) {
      uint64_t v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }
    else {
      uint64_t v3 = (CFAllocatorRef *)((char *)cf - 16);
    }
    return *v3;
  }

  return (CFAllocatorRef)__CFAllocatorGetAllocator((uint64_t)cf);
}

uint64_t __CFCopyFormattingDescription(unint64_t *a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = (uint64_t *)MEMORY[0x189616658];
    uint64_t v6 = *MEMORY[0x189616658];
    unint64_t v7 = (unint64_t)a1 & 0xC000000000000007LL;
    unint64_t v8 = v6 ^ (unint64_t)a1;
    unint64_t v9 = v8 & 7;
    uint64_t v10 = MEMORY[0x189616648];
    do
    {
      ++v4;
    }

    while (v4 != 7);
    unint64_t v11 = v4 | v8;
    uint64_t v12 = v4 & 7;
    int v13 = (v11 >> 55) + 8;
    if (v12 == 7) {
      LODWORD(v12) = v13;
    }
    if ((_DWORD)v12)
    {
      if ((_DWORD)v12 == 6) {
        return 0LL;
      }
      if ((_DWORD)v12 == 3)
      {
        unint64_t v14 = __CFNumberCopyFormattingDescription;
        return ((uint64_t (*)(unint64_t *, uint64_t))v14)(a1, a2);
      }
    }

    else
    {
      if ((dyld_program_sdk_at_least() & 1) != 0) {
        __CFCopyFormattingDescription_cold_3();
      }
      uint64_t v20 = *v5;
      if (v7 == 0xC000000000000007LL) {
        uint64_t v20 = 0LL;
      }
      unint64_t v8 = v20 ^ (unint64_t)a1;
      unint64_t v9 = v8 & 7;
    }

    for (uint64_t i = 0LL; i != 7; ++i)
    {
    }

    int v22 = ((i | v8) >> 55) + 8;
    if ((i & 7) != 7) {
      int v22 = i & 7;
    }
    unint64_t v23 = 22LL;
    switch(v22)
    {
      case 0:
        goto LABEL_40;
      case 1:
        goto LABEL_41;
      case 2:
        goto LABEL_39;
      case 3:
        goto LABEL_43;
      case 4:
      case 5:
        goto LABEL_40;
      case 6:
        unint64_t v23 = 42LL;
        goto LABEL_43;
      default:
        if (v22 == 20)
        {
LABEL_40:
          unint64_t v23 = 1LL;
        }

        else if (v22 == 22)
        {
LABEL_39:
          unint64_t v23 = 7LL;
        }

        else
        {
LABEL_41:
          unint64_t v23 = [a1 _cfTypeID];
        }

void __CF_USED()
{
  do
    unsigned __int8 v0 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
  while (__stlxr(v0 | 2, (unsigned __int8 *)&__CF_FORK_STATE));
}

ssize_t __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__()
{
  return write( 2,  "Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.\n",  0x75uLL);
}

char *__CFgetenvIfNotRestricted(char *a1)
{
  else {
    return __CFgetenv(a1);
  }
}

uint64_t __CFProcessIsRestricted()
{
  return issetugid();
}

uint64_t os_log_callback()
{
  return 0LL;
}

void __CFInitialize()
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!__CFInitialized && (__CFInitializing & 1) == 0)
  {
    uint64_t v0 = 0LL;
    __CFInitializing = 1;
    __CFProphylacticAutofsAccess = 1;
    do
    {
      uint64_t v1 = (&__CFEnv)[v0];
      if (v1)
      {
        unint64_t v2 = getenv(v1);
        if (v2) {
          (&__CFEnv)[v0 + 1] = v2;
        }
      }

      v0 += 2LL;
    }

    while (v0 != 22);
    __exceptionInit();
    objc_setForwardHandler(_CF_forwarding_prep_0, 0LL);
    objc_setEnumerationMutationHandler((void (__cdecl *)(id))__NSFastEnumerationMutationHandler);
    _CFStringGetUserDefaultEncoding(&v22, &v21);
    pthread_atfork((void (*)(void))__cf_atfork_prepare, 0LL, __cf_atfork_child);
    uint64_t v3 = getenv("NSObjCMessageLoggingEnabled");
    _CFRuntimeBridgeClasses(0LL, "__NSCFType");
    uint64_t v4 = __CFRuntimeBuiltinObjCClassTable[0];
    uint64_t v5 = 1u;
    do
      __CFRuntimeBuiltinObjCClassTable[v5++] = v4;
    while (v5 != 72);
    _CFRuntimeBridgeClasses(7uLL, "__NSCFString");
    _CFRuntimeBridgeClasses(0x10uLL, "NSNull");
    _CFRuntimeBridgeClasses(0x11uLL, "__NSCFSet");
    _CFRuntimeBridgeClasses(0x12uLL, "__NSCFDictionary");
    _CFRuntimeBridgeClasses(0x13uLL, "__NSCFArray");
    _CFRuntimeBridgeClasses(0x14uLL, "__NSCFData");
    _CFRuntimeBridgeClasses(0x15uLL, "__NSCFBoolean");
    _CFRuntimeBridgeClasses(0x16uLL, "__NSCFNumber");
    CFNumberGetTypeID();
    __CFCharacterSetInitialize();
    CFTypeID TypeID = CFMachPortGetTypeID();
    _CFRuntimeBridgeClasses(TypeID, "NSMachPort");
    CFTypeID v7 = CFURLGetTypeID();
    _CFRuntimeBridgeClasses(v7, "NSURL");
    CFTypeID v8 = CFRunLoopTimerGetTypeID();
    _CFRuntimeBridgeClasses(v8, "__NSCFTimer");
    CFTypeID v9 = CFAttributedStringGetTypeID();
    _CFRuntimeBridgeClasses(v9, "__NSCFAttributedString");
    CFTypeID v10 = CFLocaleGetTypeID();
    _CFRuntimeBridgeClasses(v10, "__NSCFLocale");
    CFTypeID v11 = CFErrorGetTypeID();
    _CFRuntimeBridgeClasses(v11, "__NSCFError");
    CFTypeID v12 = CFCharacterSetGetTypeID();
    _CFRuntimeBridgeClasses(v12, "__NSCFCharacterSet");
    CFTypeID v13 = CFReadStreamGetTypeID();
    _CFRuntimeBridgeClasses(v13, "__NSCFInputStream");
    CFTypeID v14 = CFWriteStreamGetTypeID();
    _CFRuntimeBridgeClasses(v14, "__NSCFOutputStream");
    _CFProcessPath();
    *MEMORY[0x1895F8A80] = _CFAutoreleasePoolPush;
    *MEMORY[0x1895F8AC0] = _CFAutoreleasePoolPop;
    __CFOAInitialize();
    __CFStringInitializeSystemEncoding();
    __CFMakeNSBlockClasses();
    unint64_t v15 = getenv("NSZombieEnabled");
    if (v15 && (*v15 | 0x20) == 0x79 && !__CFZombieEnabled)
    {
      __CFZombieEnabled = -1;
      __CFZombifyNSObject();
    }

    int v16 = getenv("NSDeallocateZombies");
    __CFProphylacticAutofsAccess = 0;
    _os_log_set_nscf_formatter();
    unint64_t v17 = _CFGetHandleForInsertedOrInterposingLibrary("libclang_rt.tsan");
    if (v17)
    {
      unint64_t v18 = v17;
      __cf_tsanRegisterTagFunction = (uint64_t (*)(void))dlsym(v17, "__tsan_external_register_tag");
      __cf_tsanAssignTagFunction = (uint64_t (*)(void))dlsym(v18, "__tsan_external_assign_tag");
      __cf_tsanReadFunction = (uint64_t (*)(void, void, void))dlsym(v18, "__tsan_external_read");
      uint64_t v19 = dlsym(v18, "__tsan_external_write");
      __cf_tsanWriteFunction = (uint64_t (*)(void, void, void))v19;
      if (!__cf_tsanRegisterTagFunction
        || !__cf_tsanAssignTagFunction
        || !__cf_tsanReadFunction
        || !v19
        || (__CFTSANTagMutableArray = __cf_tsanRegisterTagFunction("NSMutableArray"),
            __CFTSANTagMutableDictionary = __cf_tsanRegisterTagFunction("NSMutableDictionary"),
            __CFTSANTagMutableSet = __cf_tsanRegisterTagFunction("NSMutableSet"),
            __CFTSANTagMutableOrderedSet = __cf_tsanRegisterTagFunction("NSMutableOrderedSet"),
            uint64_t v20 = __cf_tsanRegisterTagFunction("NSMutableData"),
            __CFTSANTagMutableCFDataRef Data = v20,
            !__CFTSANTagMutableArray)
        || !__CFTSANTagMutableDictionary
        || !__CFTSANTagMutableSet
        || !__CFTSANTagMutableOrderedSet
        || !v20)
      {
        __cf_tsanRegisterTagFunction = 0LL;
        __cf_tsanAssignTagFunction = 0LL;
        __cf_tsanReadFunction = 0LL;
        __cf_tsanWriteFunction = 0LL;
        __CFTSANTagMutableArray = 0LL;
        __CFTSANTagMutableDictionary = 0LL;
        __CFTSANTagMutableSet = 0LL;
        __CFTSANTagMutableOrderedSet = 0LL;
        __CFTSANTagMutableCFDataRef Data = 0LL;
      }
    }

    __CFInitializing = 0;
    __CFInitialized = 1;
  }

uint64_t __cf_atfork_prepare()
{
  uint64_t result = pthread_is_threaded_np();
  if ((_DWORD)result)
  {
    do
      unsigned __int8 v1 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v1 | 4, (unsigned __int8 *)&__CF_FORK_STATE));
  }

  else
  {
    do
      unsigned __int8 v2 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v2 & 0xFB, (unsigned __int8 *)&__CF_FORK_STATE));
  }

  return result;
}

void __cf_atfork_child()
{
  if ((__CF_FORK_STATE & 2) != 0)
  {
    do
      unsigned __int8 v0 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v0 | 1, (unsigned __int8 *)&__CF_FORK_STATE));
  }

unint64_t *_CFTryRetain(unint64_t *result)
{
  if (result)
  {
  }

  return result;
}

uint64_t _CFIsDeallocating(uint64_t a1)
{
  if (a1 < 1) {
    return 0LL;
  }
  unsigned int v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((*(void *)&v1 & 0x800000LL) != 0) {
    return 1LL;
  }
  else {
    return (v1 >> 22) & 1;
  }
}

uint64_t _CFRegisterThreadSanitizerTag(uint64_t a1)
{
  if (__cf_tsanRegisterTagFunction) {
    BOOL v1 = a1 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0LL;
  }
  else {
    return __cf_tsanRegisterTagFunction();
  }
}

uint64_t _CFAssignThreadSanitizerTag(uint64_t result, uint64_t a2)
{
  if (__cf_tsanAssignTagFunction) {
    BOOL v2 = result == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && a2 != 0) {
    return __cf_tsanAssignTagFunction();
  }
  return result;
}

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

objc_class *__NSArrayParameterCheckIterate( objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  v23[1] = *MEMORY[0x1895F89C0];
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v6 = result;
    if (a5)
    {
      unint64_t v7 = [a5 lastIndex];
      uint64_t result = (objc_class *)-[objc_class count](v6, "count");
      if (!result)
      {
        uint64_t v8 = _os_log_pack_size();
        CFTypeID v10 = (char *)v23 - ((MEMORY[0x1895F8858](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = _os_log_pack_fill();
        CFTypeID v12 = PROEM_SEL_0(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSArray", (uint64_t)v12, v7);
        int v21 = PROEM_SEL_0(a2);
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** -[%s %s]: index %lu beyond bounds for empty array",  "NSArray",  v21,  v7);
LABEL_11:
        uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v10,  v8);
        objc_exception_throw(v19);
        return (objc_class *)PROEM_SEL_0(v20);
      }
    }

    else
    {
      unint64_t v7 = (unint64_t)&__kCFAllocatorSystemDefault;
      uint64_t v13 = __CFExceptionProem(result, a2);
      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@: index set is nil", v13);
      CFTypeID v14 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
      objc_exception_throw(v14);
    }

    unint64_t v15 = result;
    uint64_t v8 = _os_log_pack_size();
    CFTypeID v10 = (char *)v23 - ((MEMORY[0x1895F8858](v8, v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = _os_log_pack_fill();
    unint64_t v18 = PROEM_SEL_0(a2);
    unint64_t v15 = (objc_class *)((char *)v15 - 1);
    __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v17, (uint64_t)"NSArray", (uint64_t)v18, v7, (uint64_t)v15);
    int v22 = PROEM_SEL_0(a2);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** -[%s %s]: index %lu beyond bounds [0 .. %lu]",  "NSArray",  v22,  v7,  v15);
    goto LABEL_11;
  }

  return result;
}

const char *PROEM_SEL_0(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

double __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&double result = 136315906LL;
  *(_DWORD *)a1 = 136315906;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(void *)(a1 + 34) = a5;
  return result;
}

double __os_log_helper_1_2_3_8_32_8_32_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&double result = 136315650LL;
  *(_DWORD *)a1 = 136315650;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  return result;
}

BOOL __NSArrayChunkIterate( void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  id v40 = a8;
  uint64_t v42 = a6;
  uint64_t v45 = *MEMORY[0x1895F89C0];
  char v44 = 0;
  uint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
  if (a7) {
    CFTypeID v14 = a7;
  }
  else {
    CFTypeID v14 = (unint64_t *)&v43;
  }
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    unint64_t v15 = atomic_load(v14);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v16 = v15 >= a3;
      BOOL v17 = v15 <= a4;
      if ((a2 & 2) != 0) {
        BOOL v16 = v17;
      }
      if (!v16) {
        return 0LL;
      }
    }
  }

  uint64_t v41 = v14;
  uint64_t v37 = (void *)_CFAutoreleasePoolPush();
  int v38 = &v36;
  uint64_t v19 = MEMORY[0x1895F8858](v37, v18);
  int v21 = (char *)&v36 - v20;
  MEMORY[0x1895F8858](v19, v22);
  uint64_t v24 = (char *)&v36 - v23;
  if ((a2 & 0x1000000000000000LL) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v36 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_46;
  }

  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1LL) {
    goto LABEL_46;
  }
  uint64_t v25 = 0LL;
  uint64_t v39 = a9;
  while (1)
  {
    uint64_t v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0) {
      uint64_t v26 = v25;
    }
    if ((a2 & 0x1000000000000000LL) != 0 && !v24[v26]) {
      goto LABEL_33;
    }
    if ((a2 & 2) != 0) {
      unint64_t v27 = a4 - v25;
    }
    else {
      unint64_t v27 = v25 + a3;
    }
    if ((a2 & 0x6000000000000000LL) == 0)
    {
      __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(v42);
      goto LABEL_27;
    }

    if ((__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v42) & 1) != 0) {
      break;
    }
LABEL_27:
    if (v44) {
      goto LABEL_46;
    }
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      unint64_t v28 = atomic_load(v41);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        BOOL v29 = v28 >= a3;
        BOOL v30 = v28 <= a4;
        if ((a2 & 2) == 0) {
          BOOL v30 = v29;
        }
        if (!v30) {
          goto LABEL_46;
        }
      }
    }

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void __NSArrayEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if ([a1 count])
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      uint64_t v6 = [a4 firstIndex];
      unint64_t v30 = [a4 lastIndex];
    }

    else
    {
      uint64_t v6 = 0LL;
      unint64_t v30 = [a1 count] - 1;
    }

    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((a3 & 1) != 0)
      {
        uint64_t v7 = __CFActiveProcessorCount();
        if (v7 < 2) {
          a3 &= ~1uLL;
        }
      }

      else
      {
        uint64_t v7 = 1LL;
      }

      if ((a3 & 3) != 0)
      {
        unint64_t v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000) {
            unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0LL;
          }
          else {
            unint64_t v9 = 4096LL;
          }
        }

        else
        {
          unint64_t v9 = 16LL;
        }

        unint64_t v17 = v9 + v30 - v6;
        uint64_t v36 = 0LL;
        uint64_t v37 = &v36;
        uint64_t v38 = 0x2020000000LL;
        uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
        if ((a3 & 1) != 0)
        {
          v34[0] = 0LL;
          v34[1] = v34;
          v34[2] = 0x2020000000LL;
          char v35 = 0;
          block[0] = MEMORY[0x1895F87A8];
          block[1] = 3221225472LL;
          void block[2] = ____NSArrayEnumerate_block_invoke;
          block[3] = &unk_18999C070;
          void block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          block[4] = a1;
          void block[5] = a4;
          block[7] = v34;
          block[8] = &v36;
          block[6] = a2;
          block[9] = v6;
          dispatch_apply(v17 / v9, 0LL, block);
          _Block_object_dispose(v34, 8);
        }

        else
        {
          BOOL v29 = a1;
          if (v9 <= v17)
          {
            uint64_t v18 = 0LL;
            unint64_t v19 = v9 - 1;
            unint64_t v20 = 1LL;
            unint64_t v21 = v6;
            unint64_t v22 = v30;
            unint64_t v23 = v17 / v9;
            do
            {
              if ((a3 & 2) != 0)
              {
                if (v19 >= v22 - v6) {
                  unint64_t v25 = v6;
                }
                else {
                  unint64_t v25 = 1 - v9 + v22;
                }
                unint64_t v24 = v22;
              }

              else
              {
                if (v19 >= v22 - v6) {
                  unint64_t v24 = v30;
                }
                else {
                  unint64_t v24 = v19 + v18 * v9 + v6;
                }
                unint64_t v25 = v21;
              }

              BOOL v26 = __NSArrayChunkIterate(v29, a3, v25, v24, a4, a2, (unint64_t *)v37 + 3, 0LL, 0LL);
              ++v18;
              char v27 = v20 >= v23 || v26;
              v22 -= v9;
              v21 += v9;
              ++v20;
            }

            while ((v27 & 1) == 0);
          }
        }

        _Block_object_dispose(&v36, 8);
      }

      else
      {
        unint64_t v28 = v6;
        CFTypeID v10 = (void *)_CFAutoreleasePoolPush();
        LOBYTE(v34[0]) = 0;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
        if (v11)
        {
          uint64_t v12 = 0LL;
          unint64_t v13 = 0LL;
          uint64_t v14 = *(void *)v42;
          do
          {
            for (uint64_t i = 0LL; i != v11; ++i)
            {
              if (*(void *)v42 != v14) {
                objc_enumerationMutation(a1);
              }
              unint64_t v16 = v12 + i;
              if ((a3 & 0x1000000000000000LL) == 0
                || v28 <= v16 && v16 <= v30 && [a4 containsIndex:v12 + i])
              {
                __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v13 < 0x3FF)
                {
                  ++v13;
                }

                else
                {
                  _CFAutoreleasePoolPop(v10);
                  CFTypeID v10 = (void *)_CFAutoreleasePoolPush();
                  unint64_t v13 = 0LL;
                }
              }
            }

            uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
            v12 += i;
          }

          while (v11);
        }

        _CFAutoreleasePoolPop(v10);
      }
    }
  }

void sub_180AD20A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

unint64_t __NSArrayGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (![a1 count]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    uint64_t v7 = [a4 firstIndex];
    unint64_t v35 = [a4 lastIndex];
  }

  else
  {
    uint64_t v7 = 0LL;
    unint64_t v35 = [a1 count] - 1;
  }

  unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v35 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if ((a3 & 1) != 0)
    {
      uint64_t v9 = __CFActiveProcessorCount();
      if (v9 < 2) {
        a3 &= ~1uLL;
      }
    }

    else
    {
      uint64_t v9 = 1LL;
    }

    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v35 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
        }
        else {
          unint64_t v11 = 4096LL;
        }
      }

      else
      {
        unint64_t v11 = 16LL;
      }

      unint64_t v20 = v11 + v35 - v7;
      if ((a3 & 1) != 0)
      {
        unint64_t v40 = 0LL;
        __int128 v41 = &v40;
        uint64_t v42 = 0x2020000000LL;
        uint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
        v38[0] = 0LL;
        v38[1] = v38;
        v38[2] = 0x2020000000LL;
        char v39 = 0;
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        void block[2] = ____NSArrayGetIndexPassingTest_block_invoke;
        block[3] = &unk_18999C070;
        void block[10] = v11;
        block[11] = v35;
        block[12] = a3;
        block[4] = a1;
        void block[5] = a4;
        block[6] = a2;
        block[7] = v38;
        block[8] = &v40;
        block[9] = v7;
        dispatch_apply(v20 / v11, 0LL, block);
        unint64_t v8 = atomic_load(v41 + 3);
        _Block_object_dispose(v38, 8);
        _Block_object_dispose(&v40, 8);
      }

      else
      {
        contexta = a4;
        uint64_t v34 = a2;
        unint64_t v40 = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v20)
        {
          uint64_t v21 = 0LL;
          unint64_t v22 = v11 - 1;
          unint64_t v23 = 1LL;
          unint64_t v24 = v7;
          unint64_t v25 = v35;
          unint64_t v26 = v20 / v11;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v22 >= v25 - v7) {
                unint64_t v28 = v7;
              }
              else {
                unint64_t v28 = 1 - v11 + v25;
              }
              unint64_t v27 = v25;
            }

            else
            {
              if (v22 >= v25 - v7) {
                unint64_t v27 = v35;
              }
              else {
                unint64_t v27 = v22 + v21 * v11 + v7;
              }
              unint64_t v28 = v24;
            }

            BOOL v29 = __NSArrayChunkIterate(a1, a3, v28, v27, contexta, v34, &v40, 0LL, 0LL);
            if (v23 >= v26) {
              break;
            }
            ++v21;
            v25 -= v11;
            v24 += v11;
            ++v23;
          }

          while (!v29);
        }

        return atomic_load(&v40);
      }
    }

    else
    {
      uint64_t v12 = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v40) = 0;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      uint64_t v13 = [a1 countByEnumeratingWithState:&v45 objects:v44 count:16];
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t context = v12;
        unint64_t v33 = v7;
        unint64_t v15 = 0LL;
        uint64_t v16 = 0LL;
        uint64_t v17 = *(void *)v46;
        while (2)
        {
          for (uint64_t i = 0LL; i != v14; ++i)
          {
            if (*(void *)v46 != v17) {
              objc_enumerationMutation(a1);
            }
            unint64_t v19 = v16 + i;
            if ((a3 & 0x1000000000000000LL) == 0
              || v33 <= v19 && v19 <= v35 && [a4 containsIndex:v16 + i])
            {
              if ((__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(a2) & 1) != 0)
              {
                unint64_t v8 = v16 + i;
                goto LABEL_51;
              }

              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                uint64_t context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0LL;
              }

              else
              {
                ++v15;
              }
            }
          }

          uint64_t v14 = [a1 countByEnumeratingWithState:&v45 objects:v44 count:16];
          v16 += i;
          if (v14) {
            continue;
          }
          break;
        }

        unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_51:
        uint64_t v12 = context;
      }

      _CFAutoreleasePoolPop(v12);
    }
  }

  return v8;
}

id __NSArrayGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (![a1 count]
    || ((a3 & 0x1000000000000000LL) != 0
      ? (v7 = [a4 firstIndex], unint64_t v36 = objc_msgSend(a4, "lastIndex"))
      : (v7 = 0, unint64_t v36 = [a1 count] - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v36 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    return (id)objc_opt_new();
  }

  else
  {
    if ((a3 & 1) != 0)
    {
      uint64_t v8 = __CFActiveProcessorCount();
      if (v8 < 2) {
        a3 &= ~1uLL;
      }
    }

    else
    {
      uint64_t v8 = 1LL;
    }

    __CFLookUpClass("NSMutableIndexSet");
    unint64_t v35 = (void *)objc_opt_new();
    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v36 - v7 + 1) / v8 / v8;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
        }
        else {
          unint64_t v11 = 4096LL;
        }
      }

      else
      {
        unint64_t v11 = 16LL;
      }

      unint64_t v19 = v11 + v36 - v7;
      if ((a3 & 1) != 0)
      {
        __int128 v44 = 0u;
        __int128 v43 = 0u;
        __int128 v42 = 0u;
        uint64_t v45 = 0LL;
        uint64_t v41 = 850045857LL;
        v39[0] = 0LL;
        v39[1] = v39;
        v39[2] = 0x2020000000LL;
        char v40 = 0;
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        void block[2] = ____NSArrayGetIndexesPassingTest_block_invoke;
        block[3] = &unk_18999C098;
        block[8] = v39;
        block[9] = v7;
        void block[10] = v11;
        block[11] = v36;
        block[4] = a1;
        void block[5] = a4;
        block[6] = v35;
        block[7] = a2;
        block[12] = a3;
        void block[13] = &v41;
        dispatch_apply(v19 / v11, 0LL, block);
        _Block_object_dispose(v39, 8);
      }

      else
      {
        contexta = a1;
        uint64_t v34 = a4;
        if (v11 <= v19)
        {
          unint64_t v20 = v7;
          uint64_t v21 = 0LL;
          unint64_t v22 = v11 - 1;
          unint64_t v23 = 1LL;
          uint64_t v24 = -(uint64_t)v7;
          unint64_t v25 = v36;
          unint64_t v26 = v19 / v11;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v22 >= v24 + v25) {
                unint64_t v28 = v20;
              }
              else {
                unint64_t v28 = 1 - v11 + v25;
              }
              unint64_t v27 = v25;
            }

            else
            {
              if (v22 >= v24 + v25) {
                unint64_t v27 = v36;
              }
              else {
                unint64_t v27 = v22 + v21 * v11 + v20;
              }
              unint64_t v28 = v7;
            }

            BOOL v29 = __NSArrayChunkIterate(contexta, a3, v28, v27, v34, a2, 0LL, v35, 0LL);
            if (v23 >= v26) {
              break;
            }
            ++v21;
            v25 -= v11;
            v7 += v11;
            ++v23;
          }

          while (!v29);
        }
      }
    }

    else
    {
      uint64_t context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v41) = 0;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      uint64_t v12 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
      if (v12)
      {
        uint64_t v13 = v12;
        unint64_t v33 = a4;
        uint64_t v14 = 0LL;
        unint64_t v15 = 0LL;
        uint64_t v16 = *(void *)v48;
        do
        {
          for (uint64_t i = 0LL; i != v13; ++i)
          {
            if (*(void *)v48 != v16) {
              objc_enumerationMutation(a1);
            }
            unint64_t v18 = v14 + i;
            if ((a3 & 0x1000000000000000LL) == 0
              || v7 <= v18 && v18 <= v36 && [v33 containsIndex:v14 + i])
            {
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                uint64_t context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0LL;
              }

              else
              {
                ++v15;
              }
            }
          }

          uint64_t v13 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
          v14 += i;
        }

        while (v13);
      }

      _CFAutoreleasePoolPop(context);
    }

    id v30 = (id)[v35 copy];

    return v30;
  }

void sub_180AD2C48(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_180AD2EB0(_Unwind_Exception *exception_object)
{
}

void sub_180AD32AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_180AD3404(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t __NSSetI_new(uint64_t *a1, uint64_t *a2, unint64_t a3, char a4)
{
  unint64_t v5 = a3;
  uint64_t v8 = 0LL;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v24 = a2;
  while (__NSSetCapacities[v8] < a3)
  {
    if (++v8 == 64)
    {
      __break(1u);
      break;
    }
  }

  uint64_t v9 = __NSSetSizes[v8];
  unint64_t v10 = (objc_class *)objc_opt_self();
  uint64_t v11 = __CFAllocateObject(v10, 8 * v9);
  uint64_t v12 = v11;
  *(_BYTE *)(v11 + 15) = *(_BYTE *)(v11 + 15) & 3 | (4 * v8);
  if (v5)
  {
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    unint64_t v18 = ____NSSetI_new_block_invoke;
    unint64_t v19 = &unk_18999C0F0;
    uint64_t v21 = v11 + 16;
    uint64_t v22 = v9;
    char v23 = a4;
    uint64_t v20 = v11;
    if (a2)
    {
      ____NSSetI_new_block_invoke((uint64_t)v17, *a1);
      if (v5 >= 2)
      {
        unint64_t v13 = v5 - 1;
        do
        {
          uint64_t v14 = v24++;
          v18((uint64_t)v17, *v14);
          --v13;
        }

        while (v13);
      }
    }

    else
    {
      do
      {
        uint64_t v15 = *a1++;
        v18((uint64_t)v17, v15);
        --v5;
      }

      while (v5);
    }
  }

  return v12;
}

uint64_t _NSSetI_mutableCopyWithZone(void *a1, uint64_t a2)
{
  v12[1] = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1[1];
  unint64_t v4 = v3 & 0x3FFFFFFFFFFFFFFLL;
  if ((v3 & 0x3FFFFFFFFFFFFFELL) != 0) {
    uint64_t v5 = v3 & 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  unint64_t v6 = MEMORY[0x1895F8858](v5, a2);
  uint64_t v8 = (char *)v12 - v7;
  if (v4 >= 0x101)
  {
    uint64_t v8 = (char *)_CFCreateArrayStorage(v6, 0, v12);
    uint64_t v9 = v8;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  [a1 getObjects:v8 count:v4];
  uint64_t v10 = __NSSetM_new((uint64_t)v8, v4, 0);
  free(v9);
  return v10;
}

void sub_180AD3C80(_Unwind_Exception *exception_object)
{
}

uint64_t _compare_clumpiness_0(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void sub_180AD4B2C(_Unwind_Exception *exception_object)
{
}

NSUInteger OUTLINED_FUNCTION_0_11(objc_class *a1, uint64_t a2)
{
  return __CFRequireConcreteImplementation(a1, a2);
}

double __CFSetGetCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  __CFBasicHashGetCallbacks(a1, v7);
  uint64_t v3 = v7[1];
  uint64_t v4 = v7[3];
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v3;
  uint64_t v5 = v9;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  double result = v8[0];
  *(_OWORD *)(a2 + 32) = *(_OWORD *)v8;
  return result;
}

CFTypeID CFSetGetTypeID(void)
{
  return 17LL;
}

uint64_t __CFSetCreateTransfer(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  v12[10] = *MEMORY[0x1895F89C0];
  v12[6] = (uint64_t)CFHash;
  v12[7] = 0LL;
  v12[0] = (uint64_t)__CFTypeCollectionRetain;
  v12[1] = (uint64_t)__CFTypeCollectionRetain;
  size_t v12[2] = (uint64_t)__CFTypeCollectionRelease;
  v12[3] = (uint64_t)__CFTypeCollectionRelease;
  v12[4] = (uint64_t)CFEqual;
  v12[5] = (uint64_t)CFEqual;
  v12[8] = (uint64_t)CFCopyDescription;
  v12[9] = (uint64_t)CFCopyDescription;
  uint64_t v5 = CFBasicHashCreate(a1, 0x2000u, v12);
  CFBasicHashSuppressRC(v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity(v5, a3);
    do
    {
      unint64_t v6 = *a2++;
      CFBasicHashAddValue(v5, v6, v6);
      --a3;
    }

    while (a3);
  }

  CFBasicHashUnsuppressRC(v5);
  uint64_t v7 = (unint64_t *)(v5 + 8);
  unint64_t v8 = atomic_load((unint64_t *)(v5 + 8));
  do
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        int v10 = 1;
        goto LABEL_10;
      }
    }

    else
    {
      __clrex();
    }

    int v10 = 0;
LABEL_10:
    unint64_t v8 = v9;
  }

  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v5, 0x11uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v5;
}

CFSetRef CFSetCreate( CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  uint64_t Generic = __CFSetCreateGeneric((uint64_t)allocator, (uint64_t)callBacks);
  uint64_t v7 = (unint64_t *)Generic;
  if (!Generic) {
    return (CFSetRef)v7;
  }
  if (numValues >= 1)
  {
    CFBasicHashSetCapacity(Generic, numValues);
    do
    {
      unint64_t v8 = (unint64_t)*values++;
      CFBasicHashAddValue((uint64_t)v7, v8, v8);
      --numValues;
    }

    while (numValues);
  }

  unint64_t v9 = v7 + 1;
  unint64_t v10 = atomic_load(v7 + 1);
  do
  {
    unint64_t v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 | 0x40, v9))
      {
        int v12 = 1;
        goto LABEL_11;
      }
    }

    else
    {
      __clrex();
    }

    int v12 = 0;
LABEL_11:
    unint64_t v10 = v11;
  }

  while (!v12);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v7, 0x11uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return (CFSetRef)v7;
}

uint64_t __CFSetCreateGeneric(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    __int128 v4 = *(_OWORD *)(a2 + 32);
    uint64_t v5 = *(void *)(a2 + 24);
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 0LL;
    uint64_t v5 = 0LL;
    __int128 v4 = 0uLL;
  }

  __int128 v8 = v4;
  uint64_t v10 = v5;
  uint64_t v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  void v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  uint64_t v9 = 0LL;
  return CFBasicHashCreate(a1, 0x2000u, v7);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  uint64_t Generic = (objc_class **)__CFSetCreateGeneric((uint64_t)allocator, (uint64_t)callBacks);
  __int128 v4 = (__CFSet *)Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 0x11uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return v4;
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  uint64_t Copy = CFBasicHashCreateCopy(allocator, (uint64_t)theSet, v4, v5, v6, v7, v8, v9);
  uint64_t v12 = (const __CFSet *)Copy;
  if (!Copy) {
    return v12;
  }
  unint64_t v13 = (unint64_t *)(Copy + 8);
  unint64_t v14 = atomic_load((unint64_t *)(Copy + 8));
  do
  {
    unint64_t v15 = __ldaxr(v13);
    if (v15 == v14)
    {
      if (!__stlxr(v14 | 0x40, v13))
      {
        int v16 = 1;
        goto LABEL_10;
      }
    }

    else
    {
      __clrex();
    }

    int v16 = 0;
LABEL_10:
    unint64_t v14 = v15;
  }

  while (!v16);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 0x11uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v12;
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    CFIndex Count = CFSetGetCount(theSet);
    if (Count >= 257) {
      uint64_t v12 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    }
    else {
      uint64_t v12 = (const void **)values;
    }
    CFSetGetValues(theSet, v12);
    uint64_t Generic = __CFSetCreateGeneric((uint64_t)allocator, (uint64_t)&kCFTypeSetCallBacks);
    uint64_t Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (CFIndex i = 0LL; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)v12[i], (uint64_t)v12[i]);
    }
  }

  else
  {
    uint64_t Copy = (objc_class **)CFBasicHashCreateCopy(allocator, (uint64_t)theSet, v5, v6, v7, v8, v9, v10);
  }

  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x11uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return (CFMutableSetRef)Copy;
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  else {
    return CFBasicHashGetCount((uint64_t)theSet);
  }
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet getObjects:](theSet, "getObjects:", values);
  }

  else
  {
    CFIndex Count = CFSetGetCount(theSet);
    CFBasicHashGetElements((uint64_t)theSet, Count, 0LL, (uint64_t)values);
  }

CFIndex CFSetGetCountOfValue(CFSetRef theSet, const void *value)
{
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value);
  }
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value) > 0;
  }
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  v5[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)value, v5);
  if (v5[3]) {
    return (const void *)v5[2];
  }
  else {
    return 0LL;
  }
}

Boolean CFSetGetValueIfPresent(CFSetRef theSet, const void *candidate, const void **value)
{
  v7[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)candidate, v7);
  if (!v7[3]) {
    return 0;
  }
  if (value) {
    void *value = (const void *)v7[2];
  }
  return 1;
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  v6[6] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet __applyValues:context:](theSet, "__applyValues:context:", applier, context);
  }

  else
  {
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    void v6[2] = __CFSetApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    v6[5] = context;
    CFBasicHashApply((uint64_t)theSet, (uint64_t)v6);
  }

uint64_t __CFSetApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t CFSetApply(void *a1, uint64_t a2)
{
  uint64_t v5[5] = *MEMORY[0x1895F89C0];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __CFSetApply_block_invoke;
  v5[3] = &unk_1899965E8;
  v5[4] = a2;
  return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
}

BOOL __CFSetApply_block_invoke(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  char v2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  return v2 == 0;
}

uint64_t _CFSetFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  else {
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
  }
}

BOOL _CFSetIsMutable(uint64_t a1)
{
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

void _CFSetSetCapacity(__objc2_class **a1, uint64_t a2)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet addObject:](theSet, "addObject:", value);
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFSetAddValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashAddValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }

void CFSetReplaceValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet replaceObject:](theSet, "replaceObject:", value);
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFSetReplaceValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashReplaceValue((unint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet setObject:](theSet, "setObject:", value);
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFSetSetValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashSetValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet removeObject:](theSet, "removeObject:", value);
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFSetRemoveValue(CFMutableSetRef, const void *)");
    }
    CFBasicHashRemoveValue((uint64_t)theSet, (unint64_t)value);
  }

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet removeAllObjects](theSet, "removeAllObjects");
  }

  else
  {
    char v8 = atomic_load((unint64_t *)theSet + 1);
    if ((v8 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFSetRemoveAllValues(CFMutableSetRef)");
    }
    CFBasicHashRemoveAllValues((uint64_t)theSet);
  }

uint64_t __CFSocketSetSocketReadBufferAttrs(uint64_t a1, CFIndex a2, double a3)
{
  if (a3 == 0.0)
  {
    int v5 = 0;
    uint64_t v6 = 0LL;
  }

  else
  {
    BOOL v7 = a3 < 2147483650.0 && a3 > 0.0;
    double v8 = floor(a3);
    if (v7)
    {
      float v9 = v8;
      uint64_t v6 = (int)v9;
    }

    else
    {
      uint64_t v6 = 0x7FFFFFFFLL;
    }

    int v5 = (int)((a3 - v8) * 1000000.0);
  }

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  CFIndex v10 = *(void *)(a1 + 296);
  if (v10 != a2)
  {
    uint64_t v11 = *(void *)(a1 + 304);
    uint64_t v12 = *(void *)(a1 + 312);
    CFIndex v13 = v11 - v12;
    if (v11 != v12)
    {
      CFMutableArrayRef Mutable = *(__CFData **)(a1 + 328);
      if (!Mutable)
      {
        unint64_t v15 = CFGetAllocator((CFTypeRef)a1);
        CFMutableArrayRef Mutable = CFDataCreateMutable(v15, 0LL);
        *(void *)(a1 + 32_Block_object_dispose(va, 8) = Mutable;
      }

      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
      CFDataAppendBytes(Mutable, &BytePtr[*(void *)(a1 + 312)], v13);
      CFRelease(*(CFTypeRef *)(a1 + 288));
      CFIndex v10 = 0LL;
      *(_OWORD *)(a1 + 28_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a1 + 304) = 0u;
    }

    uint64_t v17 = (CFIndex *)(a1 + 296);
    if (a2)
    {
      unint64_t v18 = (void *)(a1 + 304);
      unint64_t v19 = *(const void **)(a1 + 288);
      if (v10 < a2)
      {
        if (v19)
        {
          CFRelease(v19);
          *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
        }

        *uint64_t v17 = a2;
        *unint64_t v18 = 0LL;
        *(void *)(a1 + 312) = 0LL;
        goto LABEL_23;
      }

      *uint64_t v17 = a2;
      *unint64_t v18 = 0LL;
      *(void *)(a1 + 312) = 0LL;
      if (!v19)
      {
LABEL_23:
        uint64_t v21 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
        *(void *)(a1 + 28_Block_object_dispose(va, 8) = v21;
        CFDataSetLength(v21, a2);
      }
    }

    else
    {
      *uint64_t v17 = 0LL;
      *(void *)(a1 + 304) = 0LL;
      *(void *)(a1 + 312) = 0LL;
      uint64_t v20 = *(const void **)(a1 + 288);
      if (v20)
      {
        CFRelease(v20);
        int v5 = 0;
        uint64_t v6 = 0LL;
        *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
      }

      else
      {
        int v5 = 0;
        uint64_t v6 = 0LL;
      }
    }
  }

  if (*(void *)(a1 + 272) != v6 || *(_DWORD *)(a1 + 280) != v5)
  {
    *(void *)(a1 + 272) = v6;
    *(_DWORD *)(a1 + 280) = v5;
    __CFReadSocketsTimeoutInvalid = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

int64_t __CFSocketRead(uint64_t a1, void *a2, int64_t a3, int *a4)
{
  double v8 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  *a4 = 0;
  float v9 = *(const __CFData **)(a1 + 328);
  if (v9)
  {
    CFIndex Length = CFDataGetLength(v9);
    if (Length < a3) {
      a3 = Length;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 328));
    memcpy(a2, BytePtr, a3);
    CFIndex v12 = CFDataGetLength(*(CFDataRef *)(a1 + 328));
    CFIndex v13 = *(void **)(a1 + 328);
    if (a3 >= v12)
    {
      CFRelease(v13);
      *(void *)(a1 + 32_Block_object_dispose(va, 8) = 0LL;
    }

    else
    {
      v25.CFIndex location = 0LL;
      v25.CFIndex length = a3;
      CFDataReplaceBytes((CFMutableDataRef)v13, v25, 0LL, 0LL);
    }
  }

  else if (*(void *)(a1 + 296) && (uint64_t v14 = *(void *)(a1 + 312), v15 = *(void *)(a1 + 304) - v14, v15 >= 1))
  {
    if (v15 < a3) {
      a3 = *(void *)(a1 + 304) - v14;
    }
    int v16 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
    memcpy(a2, &v16[*(void *)(a1 + 312)], a3);
    uint64_t v17 = *(void *)(a1 + 304);
    int64_t v18 = *(void *)(a1 + 312) + a3;
    *(void *)(a1 + 312) = v18;
    if (v18 == v17)
    {
      *(void *)(a1 + 304) = 0LL;
      *(void *)(a1 + 312) = 0LL;
    }
  }

  else
  {
    int v19 = *(_DWORD *)(a1 + 324);
    if (v19)
    {
      *a4 = v19;
      a3 = -1LL;
    }

    else if (*(_BYTE *)(a1 + 320))
    {
      a3 = 0LL;
    }

    else
    {
      CFSocketNativeHandle Native = CFSocketGetNative((CFSocketRef)a1);
      ssize_t v22 = read(Native, a2, a3);
      a3 = v22;
      if (v22)
      {
        if (v22 < 0)
        {
          char v23 = __error();
          int v24 = *v23;
          *a4 = *v23;
          if (v24 != 35) {
            *(_DWORD *)(a1 + 324) = v24;
          }
        }
      }

      else
      {
        *(_BYTE *)(a1 + 320) = 1;
      }
    }
  }

  pthread_mutex_unlock(v8);
  return a3;
}

CFSocketNativeHandle CFSocketGetNative(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce == -1)
  {
    if (!s) {
      goto LABEL_4;
    }
  }

  else
  {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
    if (!s) {
      goto LABEL_4;
    }
  }

  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
LABEL_4:
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (s) {
    return *((_DWORD *)s + 38);
  }
  else {
    return -1;
  }
}

uint64_t __CFSocketGetBytesAvailable(__CFSocket *a1, void *a2)
{
  v6[1] = *MEMORY[0x1895F89C0];
  uint64_t v3 = *((void *)a1 + 38) - *((void *)a1 + 39);
  if (!v3)
  {
    CFSocketNativeHandle Native = CFSocketGetNative(a1);
    if (ioctl(Native, 0x4004667FuLL, v6) < 0) {
      return 0LL;
    }
    uint64_t v3 = v6[0];
  }

  *a2 = v3;
  return 1LL;
}

void __CFSocketDeallocate(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 168);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t v3 = *(const void **)(a1 + 288);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t v4 = *(const void **)(a1 + 328);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 32_Block_object_dispose(va, 8) = 0LL;
  }

  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 272) = 0LL;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(_BYTE *)(a1 + 320) = 1;
  *(_DWORD *)(a1 + 324) = 0;
}

__CFString *__CFSocketCopyDescription(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0LL);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v4 = *(void **)(a1 + 208);
  dli_smach_port_name_t name = "???";
  if (dladdr(v4, &v19))
  {
    if (v19.dli_sname && v19.dli_saddr == v4) {
      dli_smach_port_name_t name = v19.dli_sname;
    }
  }

  CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)a1);
  double v8 = "Yes";
  char v9 = atomic_load((unint64_t *)(a1 + 8));
  if ((v9 & 0x10) == 0) {
    double v8 = "No";
  }
  uint64_t v10 = *(int *)(a1 + 184);
  uint64_t v12 = *(unsigned int *)(a1 + 152);
  uint64_t v11 = *(unsigned int *)(a1 + 156);
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  CFStringAppendFormat( Mutable,  0LL,  @"<CFSocket %p [%p]>{valid = %s, type = %d, socket = %d, socket set count = %ld,\n    callback types = 0x%x, callout = %s (%p), source = %p,\n    run loops = %@,\n    uint64_t context = ",  a1,  v7,  v8,  v11,  v12,  v10,  v13 & 0xF,  dli_sname,  v4,  *(void *)(a1 + 192),  *(void *)(a1 + 200));
  uint64_t v14 = *(void *)(a1 + 224);
  uint64_t v15 = *(uint64_t (**)(uint64_t))(a1 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  if (!v14 || !v15 || (int v16 = (const __CFString *)v15(v14)) == 0LL)
  {
    uint64_t v17 = CFGetAllocator((CFTypeRef)a1);
    int v16 = CFStringCreateWithFormat(v17, 0LL, @"<CFSocket context %p>", v14);
  }

  CFStringAppend(Mutable, v16);
  CFStringAppend(Mutable, @"}");
  CFRelease(v16);
  return Mutable;
}

CFTypeID CFSocketGetTypeID(void)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  return 61LL;
}

uint64_t __CFSocketGetTypeID_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v0 = getrlimit(8, &v6);
  *(void *)CFAllocatorRef v7 = 0x1D00000001LL;
  int rlim_max = 0;
  size_t v4 = 4LL;
  uint64_t result = sysctl(v7, 2u, &rlim_max, &v4, 0LL, 0LL);
  if (result | v0)
  {
    if (v0) {
      return result;
    }
    LODWORD(v2) = rlim_max;
  }

  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      int rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }

  if (v6.rlim_cur < (int)v2)
  {
    rlim_t v2 = (int)v2;
    rlimit v3 = v6;
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }

  return result;
}

CFSocketRef CFSocketCreateWithNative( CFAllocatorRef allocator, CFSocketNativeHandle sock, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  char v7 = callBackTypes;
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  socklen_t v54 = 4;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  if (!__CFReadSockets)
  {
    __CFWriteSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL);
    __CFReadSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL);
    __CFWriteSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    __CFReadSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
    if (socketpair(1, 2, 0, (int *)&__CFWakeupSocketPair) < 0
      || (uint64_t v52 = 1LL, fcntl(__CFWakeupSocketPair, 2) < 0)
      || (uint64_t v52 = 1LL, fcntl(SHIDWORD(__CFWakeupSocketPair), 2) < 0))
    {
      close(__CFWakeupSocketPair);
      close(SHIDWORD(__CFWakeupSocketPair));
      __CFWakeupSocketPair = -1LL;
      CFLog( 4LL,  (uint64_t)@"*** Could not create wakeup socket pair for CFSocket!!!",  v14,  v15,  v16,  v17,  v18,  v19,  v52);
    }

    else
    {
      LODWORD(callBacks.__sig) = 1;
      ioctl(__CFWakeupSocketPair, 0x8004667EuLL, &callBacks);
      ioctl(SHIDWORD(__CFWakeupSocketPair), 0x8004667EuLL, &callBacks);
      int64_t v10 = HIDWORD(__CFWakeupSocketPair);
      if ((__CFWakeupSocketPair & 0x8000000000000000LL) == 0)
      {
        uint64_t v11 = (__CFData *)__CFReadSocketsFds;
        unint64_t v12 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
        if ((uint64_t)v12 <= v10)
        {
          unint64_t v50 = v12 >> 5;
          unint64_t v51 = 4 * (((unint64_t)(v10 + 32) >> 5) - (v12 >> 5));
          CFDataIncreaseLength(v11, v51);
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          bzero(&MutableBytePtr[4 * v50], v51);
        }

        else
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
        }

        if ((!__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1)
           || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v10 >> 3) & 0x1FFFFFFC] >> v10) & 1) == 0)
          && __darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
        {
          *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] |= 1 << v10;
        }
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  CFMutableArrayRef Mutable = (const __CFDictionary *)__CFAllSockets;
  if (!__CFAllSockets)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
    __CFAllSockets = (uint64_t)Mutable;
  }

  if (sock != -1 && CFDictionaryGetValueIfPresent(Mutable, (const void *)sock, (const void **)&value))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    CFRetain(value);
    return (CFSocketRef)value;
  }

  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(allocator, 0x3DuLL, 344LL, 0LL, v20, v21, v22, v23);
  value = Instance;
  if (!Instance)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    return 0LL;
  }

  unint64_t v26 = Instance + 1;
  unint64_t v27 = atomic_load(Instance + 1);
  do
  {
    unint64_t v28 = __ldaxr(v26);
    if (v28 == v27)
    {
      if (!__stlxr(v27 & 0xFFFFFFFFFFFFFFF0LL | v7 & 0xF, v26))
      {
        int v29 = 1;
        goto LABEL_27;
      }
    }

    else
    {
      __clrex();
    }

    int v29 = 0;
LABEL_27:
    unint64_t v27 = v28;
  }

  while (!v29);
  if (sock != -1)
  {
    id v30 = (unint64_t *)((char *)value + 8);
    unint64_t v31 = atomic_load((unint64_t *)value + 1);
    while (1)
    {
      unint64_t v32 = __ldaxr(v30);
      if (v32 != v31) {
        break;
      }
      if (__stlxr(v31 | 0x10, v30)) {
        goto LABEL_34;
      }
      int v33 = 1;
LABEL_35:
      unint64_t v31 = v32;
      if (v33) {
        goto LABEL_36;
      }
    }

    __clrex();
LABEL_34:
    int v33 = 0;
    goto LABEL_35;
  }

void CFSocketInvalidate(CFSocketRef s)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  rlimit v3 = (unint64_t *)((char *)s + 8);
  char v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) == 0)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
    goto LABEL_64;
  }

  unint64_t v5 = atomic_load(v3);
  do
  {
    unint64_t v6 = __ldaxr(v3);
    if (v6 == v5)
    {
      if (!__stlxr(v5 & 0xFFFFFFFFFFFFFFEFLL, v3))
      {
        int v7 = 1;
        goto LABEL_16;
      }
    }

    else
    {
      __clrex();
    }

    int v7 = 0;
LABEL_16:
    unint64_t v5 = v6;
  }

  while (!v7);
  unint64_t v8 = atomic_load(v3);
  do
  {
    unint64_t v9 = __ldaxr(v3);
    if (v9 == v8)
    {
      if (!__stlxr(v8 & 0xFFFFFFFFFFFFFFBFLL, v3))
      {
        int v10 = 1;
        goto LABEL_23;
      }
    }

    else
    {
      __clrex();
    }

    int v10 = 0;
LABEL_23:
    unint64_t v8 = v9;
  }

  while (!v10);
  unint64_t v11 = atomic_load(v3);
  do
  {
    unint64_t v12 = __ldaxr(v3);
    if (v12 == v11)
    {
      if (!__stlxr(v11 & 0xFFFFFFFFFFFFFFDFLL, v3))
      {
        int v13 = 1;
        goto LABEL_30;
      }
    }

    else
    {
      __clrex();
    }

    int v13 = 0;
LABEL_30:
    unint64_t v11 = v12;
  }

  while (!v13);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  uint64_t v14 = (const __CFArray *)__CFWriteSockets;
  v38.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
  v38.CFIndex location = 0LL;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v14, v38, s);
  if ((FirstIndexOfValue & 0x80000000) == 0)
  {
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
    CFIndex v16 = *((unsigned int *)s + 38);
    if ((v16 & 0x80000000) == 0)
    {
      uint64_t v17 = (__CFData *)__CFWriteSocketsFds;
      if (v16 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
      {
        MutableBytePtr = CFDataGetMutableBytePtr(v17);
        if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1))
        {
          if ((*(_DWORD *)&MutableBytePtr[4 * (v16 >> 5)] & (1 << v16)) != 0)
          {
            if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1)) {
              *(_DWORD *)&MutableBytePtr[4 * (v16 >> 5)] &= ~(1 << v16);
            }
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              char v35 = 120;
              send(__CFWakeupSocketPair, &v35, 1uLL, 0);
            }
          }
        }
      }
    }
  }

  uint64_t v19 = (const __CFArray *)__CFReadSockets;
  v39.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
  v39.CFIndex location = 0LL;
  unsigned int v20 = CFArrayGetFirstIndexOfValue(v19, v39, s);
  if ((v20 & 0x80000000) == 0)
  {
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v20);
    __CFReadSocketsTimeoutInvalid = 0;
    CFIndex v21 = *((unsigned int *)s + 38);
    if ((v21 & 0x80000000) == 0)
    {
      uint64_t v22 = (__CFData *)__CFReadSocketsFds;
      if (v21 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
      {
        uint64_t v23 = CFDataGetMutableBytePtr(v22);
        if (__darwin_check_fd_set_overflow(v21, v23, 1))
        {
          if ((*(_DWORD *)&v23[4 * (v21 >> 5)] & (1 << v21)) != 0)
          {
            if (__darwin_check_fd_set_overflow(v21, v23, 1)) {
              *(_DWORD *)&v23[4 * (v21 >> 5)] &= ~(1 << v21);
            }
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              char v36 = 115;
              send(__CFWakeupSocketPair, &v36, 1uLL, 0);
            }
          }
        }
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)*((int *)s + 38));
  if ((*((_BYTE *)s + 16) & 0x80) != 0) {
    close(*((_DWORD *)s + 38));
  }
  *((_DWORD *)s + 3_Block_object_dispose(va, 8) = -1;
  int v24 = (const void *)*((void *)s + 22);
  if (v24)
  {
    CFRelease(v24);
    *((void *)s + 22) = 0LL;
  }

  CFRange v25 = (const void *)*((void *)s + 32);
  if (v25)
  {
    CFRelease(v25);
    *((void *)s + 32) = 0LL;
  }

  unint64_t v26 = (const void *)*((void *)s + 33);
  if (v26)
  {
    CFRelease(v26);
    *((void *)s + 33) = 0LL;
  }

  *((_DWORD *)s + 46) = 0;
  unint64_t v27 = (const __CFArray *)CFRetain(*((CFTypeRef *)s + 25));
  CFRelease(*((CFTypeRef *)s + 25));
  unint64_t v28 = (__CFRunLoopSource *)*((void *)s + 24);
  *((void *)s + 24) = 0LL;
  *((void *)s + 25) = 0LL;
  uint64_t v29 = *((void *)s + 28);
  id v30 = (void (*)(uint64_t))*((void *)s + 30);
  *((_OWORD *)s + 14) = 0u;
  *((_OWORD *)s + 15) = 0u;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
  int Count = CFArrayGetCount(v27);
  if (Count)
  {
    CFIndex v32 = Count - 1LL;
    do
    {
      ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v27, v32);
      CFRunLoopWakeUp(ValueAtIndex);
    }

    while ((_DWORD)v32--);
  }

  CFRelease(v27);
  if (v30) {
    v30(v29);
  }
  if (v28)
  {
    CFRunLoopSourceInvalidate(v28);
    CFRelease(v28);
  }

Boolean CFSocketIsValid(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = atomic_load((unint64_t *)s + 1);
  return (v3 >> 4) & 1;
}

CFDataRef CFSocketCopyAddress(CFSocketRef s)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  socklen_t v10 = 256;
  char v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((void *)s + 21))
  {
    int v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getsockname(v8, &v11, &v10) && (int)v10 >= 1)
    {
      unint64_t v9 = CFGetAllocator(s);
      *((void *)s + 21) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }

  unint64_t v5 = (const void *)*((void *)s + 21);
  if (v5) {
    unint64_t v6 = (const __CFData *)CFRetain(v5);
  }
  else {
    unint64_t v6 = 0LL;
  }
  pthread_mutex_unlock(v3);
  return v6;
}

CFDataRef CFSocketCopyPeerAddress(CFSocketRef s)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned int v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  socklen_t v10 = 256;
  char v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((void *)s + 22))
  {
    int v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getpeername(v8, &v11, &v10) && (int)v10 >= 1)
    {
      unint64_t v9 = CFGetAllocator(s);
      *((void *)s + 22) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }

  unint64_t v5 = (const void *)*((void *)s + 22);
  if (v5) {
    unint64_t v6 = (const __CFData *)CFRetain(v5);
  }
  else {
    unint64_t v6 = 0LL;
  }
  pthread_mutex_unlock(v3);
  return v6;
}

void CFSocketGetContext(CFSocketRef s, CFSocketContext *context)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __int128 v5 = *(_OWORD *)((char *)s + 216);
  __int128 v6 = *(_OWORD *)((char *)s + 232);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((void *)s + 31);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

CFOptionFlags CFSocketGetSocketFlags(CFSocketRef s)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  return *((unsigned __int8 *)s + 16);
}

void CFSocketSetSocketFlags(CFSocketRef s, CFOptionFlags flags)
{
  char v2 = flags;
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  *((_BYTE *)s + 16) = v2;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
}

void CFSocketDisableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  unsigned __int8 v2 = callBackTypes;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  __int128 v5 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  char v6 = atomic_load((unint64_t *)s + 1);
  if ((v6 & 0x10) != 0 && *((int *)s + 46) >= 1)
  {
    unsigned __int8 v7 = atomic_load((unint64_t *)s + 1);
    unint64_t v8 = v2 & v7 & 0xF;
    unsigned __int8 v9 = atomic_load((unint64_t *)s + 1);
    *((_DWORD *)s + 4) |= (_DWORD)v8 << 8;
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    if ((v9 & 3) == 2 || *((_DWORD *)s + 39) != 1) {
      *((_DWORD *)s + 4) |= 0x10000u;
    }
    if (v8 > 7 || (v8 & 4) != 0 && (*((_BYTE *)s + 18) & 1) == 0)
    {
      CFIndex v10 = *((unsigned int *)s + 38);
      if ((v10 & 0x80000000) == 0)
      {
        sockaddr v11 = (__CFData *)__CFWriteSocketsFds;
        if (v10 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] & (1 << v10)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] &= ~(1 << v10);
              }
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                char v16 = 120;
                send(__CFWakeupSocketPair, &v16, 1uLL, 0);
              }

              atomic_load((unint64_t *)s + 1);
            }
          }
        }
      }
    }

    if ((v9 & 3) != 0 && (v9 & v8 & 3) != 0)
    {
      __CFReadSocketsTimeoutInvalid = 0;
      CFIndex v13 = *((unsigned int *)s + 38);
      if ((v13 & 0x80000000) == 0)
      {
        uint64_t v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          uint64_t v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1)) {
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              }
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                char v17 = 115;
                send(__CFWakeupSocketPair, &v17, 1uLL, 0);
              }
            }
          }
        }
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }

  pthread_mutex_unlock(v5);
}

uint64_t __CFSocketEnableCallBacks(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!a2) {
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  }
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  if ((v6 & 0x10) != 0 && *(int *)(a1 + 184) >= 1)
  {
    unsigned __int8 v7 = atomic_load((unint64_t *)(a1 + 8));
    int v8 = v7 & 3;
    unsigned __int8 v9 = atomic_load((unint64_t *)(a1 + 8));
    unint64_t v10 = a2 & v9 & 0xF;
    if (a3) {
      *(_DWORD *)(a1 + 16) &= (~(_DWORD)v10 << 8) | 0xFFFF00FF;
    }
    if (v8 == 2 || *(_DWORD *)(a1 + 156) != 1)
    {
      int v11 = *(_DWORD *)(a1 + 16) | 0x10000;
      *(_DWORD *)(a1 + 16) = v11;
      if ((v11 & 0x10000) != 0) {
        goto LABEL_18;
      }
    }

    else
    {
      int v11 = *(_DWORD *)(a1 + 16);
      if ((v11 & 0x10000) != 0) {
        goto LABEL_18;
      }
    }

    if ((v10 & 4) != 0)
    {
      BOOL v13 = 0;
      BOOL v14 = (v11 & 0x400) == 0;
      goto LABEL_21;
    }

void CFSocketEnableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  __CFSocketEnableCallBacks((uint64_t)s, callBackTypes, 1);
}

CFRunLoopSourceRef CFSocketCreateRunLoopSource(CFAllocatorRef allocator, CFSocketRef s, CFIndex order)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  unsigned __int8 v7 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  char v8 = atomic_load((unint64_t *)s + 1);
  if ((v8 & 0x10) != 0)
  {
    unint64_t v10 = (__CFRunLoopSource *)*((void *)s + 24);
    if (v10)
    {
      int IsValid = CFRunLoopSourceIsValid(v10);
      CFRunLoopSourceRef v12 = (CFRunLoopSourceRef)*((void *)s + 24);
      if (IsValid)
      {
        if (v12)
        {
LABEL_16:
          CFRetain(v12);
          unsigned __int8 v9 = (__CFRunLoopSource *)*((void *)s + 24);
          goto LABEL_17;
        }
      }

      else
      {
        CFRelease(v12);
        *((void *)s + 24) = 0LL;
      }
    }

    context.version = 0LL;
    context.info = s;
    context.retain = CFRetain;
    context.release = CFRelease;
    context.copyDescription = CFCopyDescription;
    context.equal = CFEqual;
    context.hash = CFHash;
    context.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketSchedule;
    context.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketCancel;
    context.perform = (void (__cdecl *)(void *))__CFSocketPerformV0;
    CFRunLoopSourceRef v12 = CFRunLoopSourceCreate(allocator, order, &context);
    *((void *)s + 24) = v12;
    goto LABEL_16;
  }

  unsigned __int8 v9 = 0LL;
LABEL_17:
  pthread_mutex_unlock(v7);
  return v9;
}

uint64_t __CFSocketSchedule(uint64_t a1, const void *a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 0x10) == 0) {
    return pthread_mutex_unlock(v4);
  }
  unint64_t v6 = *(const __CFArray **)(a1 + 200);
  Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v6);
  CFArrayAppendValue(MutableCopy, a2);
  *(void *)(a1 + 200) = MutableCopy;
  CFRelease(v6);
  int v8 = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 184) = v8 + 1;
  if (v8) {
    return pthread_mutex_unlock(v4);
  }
  char v10 = atomic_load((unint64_t *)(a1 + 8));
  return __CFSocketEnableCallBacks(a1, v10 & 0xF, 1);
}

uint64_t __CFSocketCancel(uint64_t a1, const void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  int v5 = *(_DWORD *)(a1 + 184) - 1;
  *(_DWORD *)(a1 + 184) = v5;
  if (!v5)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    unint64_t v6 = (const __CFArray *)__CFWriteSockets;
    v23.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
    v23.CFIndex location = 0LL;
    FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v6, v23, (const void *)a1);
    if ((FirstIndexOfValue & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
      CFIndex v8 = *(unsigned int *)(a1 + 152);
      if ((v8 & 0x80000000) == 0)
      {
        unsigned __int8 v9 = (__CFData *)__CFWriteSocketsFds;
        if (v8 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v9);
          if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] & (1 << v8)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] &= ~(1 << v8);
              }
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                char v20 = 120;
                send(__CFWakeupSocketPair, &v20, 1uLL, 0);
              }
            }
          }
        }
      }
    }

    int v11 = (const __CFArray *)__CFReadSockets;
    v24.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
    v24.CFIndex location = 0LL;
    unsigned int v12 = CFArrayGetFirstIndexOfValue(v11, v24, (const void *)a1);
    if ((v12 & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v12);
      __CFReadSocketsTimeoutInvalid = 0;
      CFIndex v13 = *(unsigned int *)(a1 + 152);
      if ((v13 & 0x80000000) == 0)
      {
        BOOL v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          uint64_t v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1)) {
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              }
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                char v21 = 115;
                send(__CFWakeupSocketPair, &v21, 1uLL, 0);
              }
            }
          }
        }
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }

  unsigned int v16 = *(const void **)(a1 + 200);
  if (v16)
  {
    Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, *(CFArrayRef *)(a1 + 200));
    v25.CFIndex length = CFArrayGetCount(MutableCopy);
    v25.CFIndex location = 0LL;
    unsigned int v18 = CFArrayGetFirstIndexOfValue(MutableCopy, v25, a2);
    if ((v18 & 0x80000000) == 0) {
      CFArrayRemoveValueAtIndex(MutableCopy, v18);
    }
    *(void *)(a1 + 200) = MutableCopy;
    CFRelease(v16);
  }

  return pthread_mutex_unlock(v4);
}

void __CFSocketPerformV0(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  unsigned __int8 v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  unsigned int v3 = (unint64_t *)(a1 + 8);
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x10) == 0)
  {
    pthread_mutex_unlock(v2);
    return;
  }

  atomic_load(v3);
  int v5 = atomic_load(v3);
  int v6 = atomic_load(v3);
  int v7 = v5 & (v6 << 26 >> 31);
  unint64_t v8 = atomic_load(v3);
  if ((v5 & 3) == 2)
  {
    unsigned int v12 = *(const __CFArray **)(a1 + 256);
    if (v12 && CFArrayGetCount(v12) >= 1)
    {
      unsigned int ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0LL);
      char v10 = 0LL;
      goto LABEL_11;
    }

CFSocketError CFSocketSendData(CFSocketRef s, CFDataRef address, CFDataRef data, CFTimeInterval timeout)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v8 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v8);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (address)
  {
    BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
    LODWORD(address) = CFDataGetLength(address);
  }

  else
  {
    BytePtr = 0LL;
  }

  char v10 = CFDataGetBytePtr(data);
  int Length = CFDataGetLength(data);
  if (!CFSocketIsValid(s)) {
    return -1LL;
  }
  CFSocketNativeHandle Native = CFSocketGetNative(s);
  if (Native == -1) {
    return -1LL;
  }
  int v13 = Native;
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFSocketWriteLock_);
  BOOL v14 = timeout < 2147483650.0 && timeout > 0.0;
  double v15 = floor(timeout);
  uint64_t v16 = (int)vcvtmd_s64_f64(timeout);
  if (!v14) {
    uint64_t v16 = 0x7FFFFFFFLL;
  }
  uint64_t v20 = v16;
  unsigned int v21 = vcvtmd_s64_f64((timeout - v15) * 1000000.0);
  setsockopt(v13, 0xFFFF, 4101, &v20, 0x10u);
  else {
    int v17 = send(v13, v10, Length, 0);
  }
  int v19 = v17;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFSocketWriteLock_);
  CFRelease(s);
  if (v19 >= 1) {
    return 0LL;
  }
  else {
    return -1LL;
  }
}

CFSocketError CFSocketSetAddress(CFSocketRef s, CFDataRef address)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!address || !CFSocketIsValid(s)) {
    return -1LL;
  }
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  socklen_t Length = CFDataGetLength(address);
  CFSocketError result = kCFSocketError;
  if (BytePtr && Length)
  {
    CFSocketNativeHandle Native = CFSocketGetNative(s);
    if (Length < 3 || BytePtr->sa_family != 1)
    {
LABEL_18:
      int v15 = bind(Native, BytePtr, Length);
      if (v15)
      {
        uint64_t v16 = @"CFSocketSetAddress bind failure: %d";
      }

      else
      {
        if (!listen(Native, 256)) {
          return (uint64_t)v15;
        }
        uint64_t v16 = @"CFSocketSetAddress listen failure: %d";
      }

      int v17 = __error();
      CFLog(7LL, (uint64_t)v16, v18, v19, v20, v21, v22, v23, *v17);
      return (uint64_t)v15;
    }

    socklen_t Length = strnlen(BytePtr->sa_data, Length - 2) + 2;
    if (Length <= 0xFF)
    {
      if (Length != BytePtr->sa_len)
      {
        CFLog( 4LL,  (uint64_t)@"WARNING: The sun_len field of a sockaddr_un structure passed to CFSocketSetAddress was not set correctly using the SUN_LEN macro.",  v9,  v10,  v11,  v12,  v13,  v14,  v24);
        __memcpy_chk();
        char v25 = Length;
        BytePtr = (const sockaddr *)&v25;
      }

      goto LABEL_18;
    }

    return -1LL;
  }

  return result;
}

CFSocketError CFSocketConnectToAddress(CFSocketRef s, CFDataRef address, CFTimeInterval timeout)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (CFSocketGetTypeID_initOnce != -1) {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61) {
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v29 = 1;
  int v30 = 0;
  HIDWORD(v2_Block_object_dispose(va, 8) = 0;
  if (!CFSocketIsValid(s)) {
    return -1LL;
  }
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  signed int Length = CFDataGetLength(address);
  CFSocketError result = kCFSocketError;
  if (BytePtr && Length >= 1)
  {
    unsigned int Native = CFSocketGetNative(s);
    BOOL v11 = (fcntl(Native, 3, 0LL) & 0x80000004) == 4 || timeout == 0.0;
    if (!v11) {
      ioctl(Native, 0x8004667EuLL, &v29);
    }
    int v12 = connect(Native, BytePtr, Length);
    if (v12)
    {
      int v13 = *__error();
      BOOL v14 = v13 == 36;
      if (timeout >= 0.0 && v13 == 36)
      {
        LODWORD(v2_Block_object_dispose(va, 8) = 4;
        CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
        uint64_t v16 = Mutable;
        if ((Native & 0x80000000) == 0)
        {
          unint64_t v17 = 8 * CFDataGetLength(Mutable);
          if ((uint64_t)v17 <= Native)
          {
            unint64_t v19 = v17 >> 5;
            unint64_t v20 = 4 * ((((unint64_t)Native + 32) >> 5) - (v17 >> 5));
            CFDataIncreaseLength(v16, v20);
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
            bzero(&MutableBytePtr[4 * v19], v20);
          }

          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
          }

          unsigned int v21 = Native >> 5;
          if (!__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[4 * v21] >> Native) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1)) {
              *(_DWORD *)&MutableBytePtr[4 * v21] |= 1 << Native;
            }
          }
        }

        BOOL v22 = timeout < 2147483650.0 && timeout > 0.0;
        double v23 = floor(timeout);
        uint64_t v24 = (int)vcvtmd_s64_f64(timeout);
        if (!v22) {
          uint64_t v24 = 0x7FFFFFFFLL;
        }
        uint64_t v26 = v24;
        unsigned int v27 = vcvtmd_s64_f64((timeout - v23) * 1000000.0);
        CFDataGetLength(v16);
        CFDataGetMutableBytePtr(v16);
        int v25 = select_DARWIN_EXTSN();
        if (v25 < 0)
        {
          int v30 = *__error();
          int v12 = -1;
        }

        else if (v25)
        {
          if (getsockopt(Native, 0xFFFF, 4103, &v30, (socklen_t *)&v28))
          {
            int v12 = 0;
            int v30 = 0;
          }

          else if (v30)
          {
            int v12 = -1;
          }

          else
          {
            int v12 = 0;
          }
        }

        else
        {
          int v12 = -2;
        }

        CFRelease(v16);
        BOOL v14 = 1;
        if (v11) {
          goto LABEL_26;
        }
LABEL_25:
        ioctl(Native, 0x8004667EuLL, (char *)&v28 + 4, v26, v27, v28);
LABEL_26:
        if (timeout < 0.0 && v14) {
          return 0LL;
        }
        else {
          return (uint64_t)v12;
        }
      }
    }

    else
    {
      BOOL v14 = 0;
    }

    if (v11) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }

  return result;
}

CFSocketRef CFSocketCreate( CFAllocatorRef allocator, SInt32 protocolFamily, SInt32 socketType, SInt32 protocol, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (protocolFamily >= 1) {
    SInt32 v14 = protocolFamily;
  }
  else {
    SInt32 v14 = 2;
  }
  if (socketType <= 1) {
    SInt32 v15 = 1;
  }
  else {
    SInt32 v15 = socketType;
  }
  if (protocol < 1 && socketType < 2) {
    SInt32 v17 = 6;
  }
  else {
    SInt32 v17 = protocol;
  }
  if (v17 < 1 && v15 == 2) {
    SInt32 v17 = 17;
  }
  if (v14 == 2) {
    SInt32 v19 = v17;
  }
  else {
    SInt32 v19 = protocol;
  }
  if (v14 != 2) {
    SInt32 v15 = socketType;
  }
  if (v15 < 1 && v14 == 1) {
    int v21 = 1;
  }
  else {
    int v21 = v15;
  }
  CFSocketNativeHandle v22 = socket(v14, v21, v19);
  if (v22 == -1) {
    return 0LL;
  }
  else {
    return CFSocketCreateWithNative(allocator, v22, callBackTypes, callout, context);
  }
}

CFSocketRef CFSocketCreateWithSocketSignature( CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  uint64_t v10 = CFSocketCreate( allocator,  signature->protocolFamily,  signature->socketType,  signature->protocol,  callBackTypes,  callout,  context);
  BOOL v11 = v10;
  if (v10 && (!CFSocketIsValid(v10) || CFSocketSetAddress(v11, signature->address)))
  {
    CFSocketInvalidate(v11);
    CFRelease(v11);
    return 0LL;
  }

  return v11;
}

CFSocketRef CFSocketCreateConnectedToSocketSignature( CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context, CFTimeInterval timeout)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  int v12 = CFSocketCreate( allocator,  signature->protocolFamily,  signature->socketType,  signature->protocol,  callBackTypes,  callout,  context);
  int v13 = v12;
  if (v12 && (!CFSocketIsValid(v12) || CFSocketConnectToAddress(v13, signature->address, timeout)))
  {
    CFSocketInvalidate(v13);
    CFRelease(v13);
    return 0LL;
  }

  return v13;
}

CFSocketError CFSocketRegisterValue( const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef value)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  uint64_t v10[2] = 0LL;
  CFSocketError v11 = kCFSocketError;
  v10[0] = &v11;
  v10[1] = 0LL;
  CFDictionaryAddValue(Mutable, @"Command", @"Register");
  CFDictionaryAddValue(Mutable, @"Name", name);
  if (value) {
    CFDictionaryAddValue(Mutable, @"Value", value);
  }
  __CFSocketValidateSignature( (uint64_t)nameServerSignature,  (uint64_t)&v12,  (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v12, Mutable, v10, timeout);
  CFRelease(Mutable);
  CFRelease(v12.address);
  return v11;
}

void *__CFSocketValidateSignature(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v19 = 0LL;
  *(_WORD *)bytes = 528;
  __int16 v17 = bswap32((unsigned __int16)__CFSocketDefaultNameRegistryPortNumber) >> 16;
  int v18 = 16777343;
  if (!a1)
  {
    *(void *)a2 = 0x100000002LL;
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 6;
    goto LABEL_23;
  }

  int v6 = *(_DWORD *)a1;
  *(_DWORD *)a2 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 4) = v7;
  int v8 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v8;
  if (v6 <= 0)
  {
    *(_DWORD *)a2 = 2;
LABEL_7:
    if (v7 < 1)
    {
      *(_DWORD *)(a2 + 4) = 1;
      if (v8 >= 1) {
        goto LABEL_15;
      }
    }

    else
    {
      if (v8 >= 1) {
        goto LABEL_15;
      }
      if (v7 != 1)
      {
        if (v7 != 2) {
          goto LABEL_15;
        }
        int v9 = 17;
        goto LABEL_14;
      }
    }

    int v9 = 6;
LABEL_14:
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v9;
    goto LABEL_15;
  }

  if (v6 == 2) {
    goto LABEL_7;
  }
LABEL_15:
  uint64_t v10 = *(const __CFData **)(a1 + 16);
  if (v10)
  {
    BytePtr = CFDataGetBytePtr(v10);
    if (CFDataGetLength(*(CFDataRef *)(a1 + 16)) < 16 || (BytePtr[1] | 2) != 2)
    {
      CFSocketError result = (void *)CFRetain(*(CFTypeRef *)(a1 + 16));
      goto LABEL_25;
    }

    *(_WORD *)bytes = 528;
    __int16 v12 = *((_WORD *)BytePtr + 1);
    __int16 v13 = __rev16(a3);
    if (!v12) {
      __int16 v12 = v13;
    }
    __int16 v17 = v12;
    int v14 = *((_DWORD *)BytePtr + 1);
    if (!v14) {
      int v14 = 16777343;
    }
    int v18 = v14;
  }

void __CFSocketSendNameRegistryRequest( const CFSocketSignature *a1, const void *a2, void **a3, CFTimeInterval a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  v13.version = 0LL;
  memset(&v13.retain, 0, 24);
  v13.info = a3;
  if (*a3) {
    **a3 = -1LL;
  }
  CFDataRef Data = CFPropertyListCreateData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a2,  kCFPropertyListXMLFormat_v1_0,  0LL,  0LL);
  if (Data)
  {
    int v8 = Data;
    if (*a3) {
      **a3 = -2LL;
    }
    int v9 = CFSocketCreateConnectedToSocketSignature( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a1,  3uLL,  (CFSocketCallBack)__CFSocketHandleNameRegistryReply,  &v13,  a4);
    if (v9)
    {
      uint64_t v10 = v9;
      if (CFSocketSendData(v9, 0LL, v8, a4) == kCFSocketSuccess)
      {
        RunLoopSource = CFSocketCreateRunLoopSource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, 0LL);
        double Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, RunLoopSource, @"CFSocketRegistryRequest");
        CFRunLoopRunInMode(@"CFSocketRegistryRequest", a4, 0);
        CFRelease(RunLoopSource);
      }

      CFSocketInvalidate(v10);
      CFRelease(v10);
    }

    CFRelease(v8);
  }

CFSocketError CFSocketCopyRegisteredValue( const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef *value, CFDataRef *nameServerAddress)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  size_t v12[2] = nameServerAddress;
  CFSocketError v13 = kCFSocketError;
  v12[0] = &v13;
  v12[1] = value;
  CFDictionaryAddValue(Mutable, @"Command", @"Retrieve");
  CFDictionaryAddValue(Mutable, @"Name", name);
  __CFSocketValidateSignature( (uint64_t)nameServerSignature,  (uint64_t)&v14,  (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v14, Mutable, v12, timeout);
  CFRelease(Mutable);
  CFRelease(v14.address);
  return v13;
}

CFSocketError CFSocketRegisterSocketSignature( const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, const CFSocketSignature *signature)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!signature) {
    return CFSocketRegisterValue(nameServerSignature, timeout, name, 0LL);
  }
  __CFSocketValidateSignature((uint64_t)signature, (uint64_t)&v20, 0);
  int v7 = theData;
  UInt8 v8 = v20;
  UInt8 v9 = v21;
  UInt8 v10 = BYTE4(v21);
  v11.i64[0] = __PAIR64__(v20, HIDWORD(v21));
  v11.i64[1] = v21;
  __int16 v12 = vmovn_s32(vcgtq_s32(v11, (int32x4_t)xmmword_180C37180)).u16[0];
  *(int16x4_t *)v11.i8 = vmovn_s32(vcgtq_s32((int32x4_t)xmmword_180C37180, v11));
  v11.i16[0] = v12;
  if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v11.i8, 0xFuLL))) & 1) != 0
    || (v20 <= 255 ? (BOOL v13 = theData == 0LL) : (BOOL v13 = 1), v13 || (int)v21 > 255))
  {
    CFSocketError v15 = kCFSocketError;
    if (!theData) {
      return v15;
    }
  }

  else
  {
    CFIndex Length = CFDataGetLength(theData);
    if ((unint64_t)(Length - 256) >= 0xFFFFFFFFFFFFFF01LL)
    {
      CFIndex v17 = Length;
      CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length + 4);
      bytes[0] = v8;
      bytes[1] = v9;
      UInt8 bytes[2] = v10;
      bytes[3] = v17;
      CFDataAppendBytes(Mutable, bytes, 4LL);
      BytePtr = CFDataGetBytePtr(v7);
      CFDataAppendBytes(Mutable, BytePtr, v17);
      CFSocketError v15 = CFSocketRegisterValue(nameServerSignature, timeout, name, Mutable);
      CFRelease(Mutable);
    }

    else
    {
      CFSocketError v15 = kCFSocketError;
    }
  }

  CFRelease(v7);
  return v15;
}

CFSocketError CFSocketUnregister( const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name)
{
  return CFSocketRegisterValue(nameServerSignature, timeout, name, 0LL);
}

CFSocketError CFSocketCopyRegisteredSocketSignature( const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFSocketSignature *signature, CFDataRef *nameServerAddress)
{
  value[1] = *(CFPropertyListRef *)MEMORY[0x1895F89C0];
  value[0] = 0LL;
  CFTypeRef cf = 0LL;
  CFSocketError v7 = CFSocketCopyRegisteredValue(nameServerSignature, timeout, name, value, (CFDataRef *)&cf);
  if (value[0])
  {
    CFTypeID v8 = CFGetTypeID(value[0]);
    if (v8 == CFDataGetTypeID()
      && (UInt8 v9 = CFDataGetBytePtr((CFDataRef)value[0])) != 0LL
      && (v10 = v9, CFIndex v11 = CFDataGetLength((CFDataRef)value[0]), v11 >= 4))
    {
      if (signature && v7 == kCFSocketSuccess)
      {
        v20[0] = *v10;
        v20[1] = v10[1];
        v20[2] = v10[2];
        CFTypeRef v21 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10 + 4, v11 - 4);
        __CFSocketValidateSignature((uint64_t)v20, (uint64_t)signature, 0);
        CFRelease(v21);
        BytePtr = CFDataGetBytePtr(signature->address);
        if (CFDataGetLength(signature->address) >= 16 && BytePtr[1] == 2)
        {
          if (cf)
          {
            if (CFDataGetLength((CFDataRef)cf) >= 16)
            {
              CFSocketSignature v14 = CFDataGetBytePtr((CFDataRef)cf);
              if (v14)
              {
                CFSocketError v15 = v14;
                if (v14[1] == 2)
                {
                  CFIndex Length = CFDataGetLength(signature->address);
                  Mutableuint64_t Copy = CFDataCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Length,  signature->address);
                  *((_DWORD *)CFDataGetMutableBytePtr(MutableCopy) + 1) = *((_DWORD *)v15 + 1);
                  CFRelease(signature->address);
                  signature->address = MutableCopy;
                }
              }
            }
          }
        }

        if (nameServerAddress)
        {
          int v18 = (const __CFData *)cf;
          if (cf) {
            int v18 = (const __CFData *)CFRetain(cf);
          }
          CFSocketError v7 = kCFSocketSuccess;
          *nameServerAddress = v18;
        }

        else
        {
          CFSocketError v7 = kCFSocketSuccess;
        }
      }
    }

    else
    {
      CFSocketError v7 = kCFSocketError;
    }

    if (value[0]) {
      CFRelease(value[0]);
    }
  }

  else
  {
    CFSocketError v7 = kCFSocketError;
  }

  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

void CFSocketSetDefaultNameRegistryPortNumber(UInt16 port)
{
  __CFSocketDefaultNameRegistryPortNumber = port;
}

UInt16 CFSocketGetDefaultNameRegistryPortNumber(void)
{
  return __CFSocketDefaultNameRegistryPortNumber;
}

uint64_t _CFSocketGetThread()
{
  return __CFSocketManagerThread;
}

void __CFSocketManager(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 4LL, 0LL);
  unsigned int v3 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 4LL, 0LL);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  v165 = 0LL;
  CFIndex v4 = 0LL;
  v170.tv_sec = 0LL;
  *(void *)&v170.tv_usec = 0LL;
  uint64_t v161 = 1LL;
  while (1)
  {
LABEL_2:
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    ++__CFSocketManagerIteration;
    int v5 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
    int v6 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
    if (v5 <= v6) {
      int v5 = v6;
    }
    unint64_t v7 = v161;
    if (v5 > 32 * (int)v161)
    {
      unint64_t v7 = (unint64_t)(v5 + 31LL) >> 5;
      unsigned __int8 v2 = __CFSafelyReallocateWithAllocator((malloc_zone_t *)&__kCFAllocatorSystemDefault, v2, 4LL * (int)v7, 0LL, 0LL);
      unsigned int v3 = (char *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v3,  4LL * (int)v7,  0LL,  0LL);
    }

    uint64_t v161 = v7;
    bzero(v2, 4LL * (int)v7);
    bzero(v3, 4LL * (int)v7);
    CFTypeID v8 = (const __CFData *)__CFWriteSocketsFds;
    v178.CFIndex length = CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
    v178.CFIndex location = 0LL;
    CFDataGetBytes(v8, v178, (UInt8 *)v2);
    UInt8 v9 = (const __CFData *)__CFReadSocketsFds;
    v179.CFIndex length = CFDataGetLength((CFDataRef)__CFReadSocketsFds);
    v179.CFIndex location = 0LL;
    CFDataGetBytes(v9, v179, (UInt8 *)v3);
    if ((__CFReadSocketsTimeoutInvalid & 1) == 0)
    {
      *(void *)&context[0].sa_len = 0LL;
      __CFReadSocketsTimeoutInvalid = 1;
      UInt8 v10 = (const __CFArray *)__CFReadSockets;
      v180.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      v180.CFIndex location = 0LL;
      CFArrayApplyFunction(v10, v180, (CFArrayApplierFunction)_calcMinTimeout_locked, context);
      if (*(void *)&context[0].sa_len)
      {
        __int128 v171 = *(_OWORD *)*(void *)&context[0].sa_len;
        v165 = &v171;
      }

      else
      {
        v165 = 0LL;
      }
    }

    if (v165) {
      gettimeofday(&v170, 0LL);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    int v166 = select_DARWIN_EXTSN();
    if (!v166)
    {
      gettimeofday((timeval *)context, 0LL);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      int Count = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      if (Count >= 1)
      {
        CFIndex v12 = 0LL;
        MutableBytePtr = 0LL;
        uint64_t v14 = Count;
        do
        {
          unsigned int ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v12);
          if (*((void *)ValueAtIndex + 34) || ValueAtIndex[70] || *((void *)ValueAtIndex + 41))
          {
            unint64_t v16 = ValueAtIndex[38];
            if ((v16 & 0x80000000) == 0 && (int)v16 < v5)
            {
              CFArraySetValueAtIndex(theArray, v4, ValueAtIndex);
              if (!MutableBytePtr) {
                MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)__CFReadSocketsFds);
              }
              ++v4;
              if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1)) {
                *(_DWORD *)&MutableBytePtr[(v16 >> 3) & 0x1FFFFFFC] &= ~(1 << v16);
              }
            }
          }

          ++v12;
        }

        while (v14 != v12);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    }

    if ((v166 & 0x80000000) == 0) {
      break;
    }
    if (*__error() == 9)
    {
      uint64_t v26 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      CFIndex v27 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
      if (v27 >= 1)
      {
        CFIndex v28 = v27;
        for (CFIndex i = 0LL; i != v28; ++i)
        {
          int v30 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFWriteSockets, i);
          if (!__CFNativeSocketIsValid(v30[38])) {
            CFArrayAppendValue(v26, v30);
          }
        }
      }

      CFIndex v31 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      if (v31 >= 1)
      {
        CFIndex v32 = v31;
        for (CFIndex j = 0LL; j != v32; ++j)
        {
          unint64_t v34 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, j);
          if (!__CFNativeSocketIsValid(v34[38])) {
            CFArrayAppendValue(v26, v34);
          }
        }
      }

      CFIndex v35 = CFArrayGetCount(v26);
      if (v35)
      {
        uint64_t v36 = v35;
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
        if (v36 >= 1)
        {
          for (CFIndex k = 0LL; k != v36; ++k)
          {
            char v38 = (__CFSocket *)CFArrayGetValueAtIndex(v26, k);
            CFSocketInvalidate(v38);
          }
        }
      }

      else
      {
        clearInvalidFileDescriptors((UInt8 *)__CFReadSocketsFds);
        clearInvalidFileDescriptors((UInt8 *)__CFWriteSocketsFds);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
      }

      CFRelease(v26);
    }
  }

  int v17 = HIDWORD(__CFWakeupSocketPair);
  if (__darwin_check_fd_set_overflow(SHIDWORD(__CFWakeupSocketPair), v3, 1)
    && ((*(_DWORD *)&v3[((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v17) & 1) != 0)
  {
    recv(SHIDWORD(__CFWakeupSocketPair), v172, 0x100uLL, 0);
  }

  uint64_t idx = v4;
  v162 = v2;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  int v18 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
  v163 = v3;
  if (v18 < 1)
  {
    CFIndex v21 = 0LL;
  }

  else
  {
    CFIndex v19 = 0LL;
    int v20 = 0LL;
    CFIndex v21 = 0LL;
    uint64_t v22 = v18;
    do
    {
      double v23 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFWriteSockets, v19);
      unint64_t v24 = v23[38];
      if ((v24 & 0x80000000) == 0 && (int)v24 < v5)
      {
        int v25 = v23;
        if (__darwin_check_fd_set_overflow(v23[38], v162, 1) && (*((_DWORD *)v162 + (v24 >> 5)) & (1 << v24)) != 0)
        {
          CFArraySetValueAtIndex(Mutable, v21, v25);
          if (!v20) {
            int v20 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFWriteSocketsFds);
          }
          ++v21;
          if (__darwin_check_fd_set_overflow(v24, v20, 1)) {
            *(_DWORD *)&v20[4 * (v24 >> 5)] &= ~(1 << v24);
          }
        }

        unsigned int v3 = v163;
      }

      ++v19;
    }

    while (v22 != v19);
  }

  int v39 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
  v169.tv_sec = 0LL;
  *(void *)&v169.tv_usec = 0LL;
  if (v165) {
    gettimeofday(&v169, 0LL);
  }
  if (v39 >= 1)
  {
    CFIndex v40 = 0LL;
    CFTypeRef v41 = 0LL;
    do
    {
      CFRange v42 = CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v40);
      CFMutableArrayRef v43 = v42;
      unint64_t v44 = *((unsigned int *)v42 + 38);
      BOOL v46 = (v44 & 0x80000000) == 0LL && (int)v44 < v5;
      v42[352] = 0;
      if (v166
        && v165
        && v46
        && (!__darwin_check_fd_set_overflow(v44, v3, 1) || ((*(_DWORD *)&v3[(v44 >> 3) & 0x1FFFFFFC] >> v44) & 1) == 0))
      {
        __darwin_time_t v47 = *((void *)v43 + 42);
        if (v47 || *((_DWORD *)v43 + 86))
        {
          BOOL v48 = v169.tv_sec <= v47;
          if (v169.tv_sec == v47) {
            BOOL v48 = v169.tv_usec <= *((_DWORD *)v43 + 86);
          }
          if (!v48) {
            v43[352] = 1;
          }
        }
      }

      if (v46
        && (__darwin_check_fd_set_overflow(v44, v3, 1) && ((*(_DWORD *)&v3[(v44 >> 3) & 0x1FFFFFFC] >> v44) & 1) != 0
         || v43[352]))
      {
        CFArraySetValueAtIndex(theArray, idx, v43);
        if (!v41) {
          CFTypeRef v41 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFReadSocketsFds);
        }
        ++idx;
        if (__darwin_check_fd_set_overflow(v44, v41, 1)) {
          *(_DWORD *)&v41[4 * (v44 >> 5)] &= ~(1 << v44);
        }
      }

      ++v40;
    }

    while (v39 != v40);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  __int128 v49 = theArray;
  if (v21 < 1) {
    goto LABEL_125;
  }
  CFIndex v50 = 0LL;
  while (1)
  {
    unsigned int v51 = (__objc2_class **)CFArrayGetValueAtIndex(Mutable, v50);
    if (&__kCFNull == v51) {
      goto LABEL_103;
    }
    char v52 = v51;
    *(_DWORD *)&context[0].sa_len = 0;
    *(_DWORD *)&v177[0].sa_len = 4;
    if (!CFSocketIsValid((CFSocketRef)v51)) {
      goto LABEL_102;
    }
    if (((_BYTE)v52[2] & 0x40) != 0
      || getsockopt(*((_DWORD *)v52 + 38), 0xFFFF, 4103, context, (socklen_t *)&v177[0].sa_len))
    {
      *(_DWORD *)&context[0].sa_len = 0;
    }

    pthread_mutex_lock((pthread_mutex_t *)(v52 + 3));
    int v53 = (unint64_t *)(v52 + 1);
    unint64_t v54 = atomic_load((unint64_t *)v52 + 1);
    char v55 = atomic_load((unint64_t *)v52 + 1);
    if ((v55 & 0x10) == 0) {
      goto LABEL_101;
    }
    uint64_t v56 = 8LL;
    if (((_DWORD)v52[2] & 4) == 0) {
      uint64_t v56 = 12LL;
    }
    if ((~(*((_DWORD *)v52 + 4) >> 8) & v56 & v54) == 0)
    {
LABEL_101:
      pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
      goto LABEL_102;
    }

    *((_DWORD *)v52 + 40) = *(_DWORD *)&context[0].sa_len;
    unint64_t v57 = atomic_load((unint64_t *)v52 + 1);
    do
    {
      unint64_t v58 = __ldaxr(v53);
      if (v58 == v57)
      {
        if (!__stlxr(v57 | 0x40, v53))
        {
          int v59 = 1;
          goto LABEL_111;
        }
      }

      else
      {
        __clrex();
      }

      int v59 = 0;
LABEL_111:
      unint64_t v57 = v58;
    }

    while (!v59);
    CFRunLoopSourceSignal((CFRunLoopSourceRef)v52[24]);
    uint64_t v60 = (__objc2_class *)CFRetain(v52[25]);
    Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (CFArrayRef)v52[25]);
    BOOL v62 = v52[24];
    if (v62)
    {
      if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v52[24]))
      {
        CFRetain(v62);
        char v63 = 0;
        goto LABEL_117;
      }

      BOOL v62 = 0LL;
    }

    char v63 = 1;
LABEL_117:
    pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
    uint64_t v64 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v62, MutableCopy);
    if ((v63 & 1) == 0) {
      CFRelease(v62);
    }
    if (v64)
    {
      CFRunLoopWakeUp((CFRunLoopRef)v64);
      CFRelease(v64);
    }

    pthread_mutex_lock((pthread_mutex_t *)(v52 + 3));
    unsigned int v3 = v163;
    if (v60 == v52[25])
    {
      v52[25] = (__objc2_class *)MutableCopy;
      CFRelease(v60);
      Mutableuint64_t Copy = 0LL;
    }

    __int128 v49 = theArray;
    pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
    CFRelease(v60);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
LABEL_102:
    CFArraySetValueAtIndex(Mutable, v50, &__kCFNull);
LABEL_103:
    if (++v50 == v21)
    {
LABEL_125:
      if (idx < 1) {
        goto LABEL_286;
      }
      CFIndex v65 = 0LL;
      while (1)
      {
        uint64_t v66 = (__objc2_class **)CFArrayGetValueAtIndex(v49, v65);
        if (&__kCFNull == v66) {
          goto LABEL_269;
        }
        int v67 = v66;
        if (v166) {
          BOOL v68 = *((_BYTE *)v66 + 352) != 0;
        }
        else {
          BOOL v68 = 1;
        }
        if (!CFSocketIsValid((CFSocketRef)v66)) {
          goto LABEL_268;
        }
        mach_port_t v69 = (unint64_t *)(v67 + 1);
        char v70 = atomic_load((unint64_t *)v67 + 1);
        if ((~v70 & 3) == 0)
        {
          socklen_t v173 = 256;
          if (*((_DWORD *)v67 + 39) == 1)
          {
            int v71 = *((_DWORD *)v67 + 38);
            unsigned int v72 = context;
            CFTypeRef v73 = context;
            size_t v74 = 0x8000LL;
            goto LABEL_141;
          }

          unsigned int v72 = (sockaddr *)malloc(0xFFFFuLL);
          if (v72)
          {
            int v71 = *((_DWORD *)v67 + 38);
            CFTypeRef v73 = v72;
            size_t v74 = 0xFFFFLL;
LABEL_141:
            int v82 = recvfrom(v71, v73, v74, 0, &v174, &v173);
            if (v82 > 0)
            {
              v83 = CFGetAllocator(v67);
              CFIndex v84 = v82;
              p_sa_len = &v72->sa_len;
LABEL_154:
              CFDataRef v92 = CFDataCreate(v83, p_sa_len, v84);
              if (v72 && v72 != context) {
                free(v72);
              }
              v93 = (pthread_mutex_t *)(v67 + 3);
              pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
              char v94 = atomic_load((unint64_t *)v67 + 1);
              if ((v94 & 0x10) == 0)
              {
                CFDataRef v95 = v92;
                goto LABEL_187;
              }

              unint64_t v96 = atomic_load(v69);
              while (2)
              {
                unint64_t v97 = __ldaxr(v69);
                if (v97 == v96)
                {
                  if (!__stlxr(v96 | 0x20, v69))
                  {
                    int v98 = 1;
                    goto LABEL_165;
                  }
                }

                else
                {
                  __clrex();
                }

                int v98 = 0;
LABEL_165:
                unint64_t v96 = v97;
                if (v98)
                {
                  if ((int)v173 >= 1)
                  {
                    v99 = CFGetAllocator(v67);
                    v100 = CFDataCreate(v99, &v174.sa_len, (int)v173);
                    goto LABEL_171;
                  }

                  if (*((_DWORD *)v67 + 39) == 1)
                  {
                    CFDataRef v101 = (CFDataRef)v67[22];
                    if (v101)
                    {
LABEL_170:
                      v100 = (const __CFData *)CFRetain(v101);
LABEL_171:
                      CFDataRef v102 = v100;
                      if (!v100) {
                        goto LABEL_172;
                      }
LABEL_173:
                      v104 = (__CFArray *)v67[32];
                      if (!v104)
                      {
                        v105 = CFGetAllocator(v67);
                        v104 = CFArrayCreateMutable(v105, 0LL, &kCFTypeArrayCallBacks);
                        v67[32] = (__objc2_class *)v104;
                      }

                      if (!v67[33])
                      {
                        v106 = CFGetAllocator(v67);
                        v67[33] = (__objc2_class *)CFArrayCreateMutable(v106, 0LL, &kCFTypeArrayCallBacks);
                        v104 = (__CFArray *)v67[32];
                      }

                      CFArrayAppendValue(v104, v92);
                      CFRelease(v92);
                      CFArrayAppendValue((CFMutableArrayRef)v67[33], v102);
                      CFRelease(v102);
                      if (v82 >= 1)
                      {
                        int v107 = *((_DWORD *)v67 + 4);
                        if ((v107 & 3) != 0 && (v107 & 0x300) == 0 && *((int *)v67 + 46) >= 1)
                        {
                          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
                          __CFReadSocketsTimeoutInvalid = 0;
                          int64_t v108 = *((unsigned int *)v67 + 38);
                          if ((v108 & 0x80000000) == 0)
                          {
                            v109 = (__CFData *)__CFReadSocketsFds;
                            unint64_t v110 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                            if ((uint64_t)v110 <= v108)
                            {
                              unint64_t v130 = v110 >> 5;
                              unint64_t v131 = 4 * (((unint64_t)(v108 + 32) >> 5) - (v110 >> 5));
                              CFDataIncreaseLength(v109, v131);
                              v111 = CFDataGetMutableBytePtr(v109);
                              bzero(&v111[4 * v130], v131);
                            }

                            else
                            {
                              v111 = CFDataGetMutableBytePtr(v109);
                            }

                            if (!__darwin_check_fd_set_overflow(v108, v111, 1)
                              || ((*(_DWORD *)&v111[((unint64_t)v108 >> 3) & 0x1FFFFFFC] >> v108) & 1) == 0)
                            {
                              if (__darwin_check_fd_set_overflow(v108, v111, 1)) {
                                *(_DWORD *)&v111[4 * (v108 >> 5)] |= 1 << v108;
                              }
                              int v132 = __CFWakeupSocketPair;
                              if ((_DWORD)__CFWakeupSocketPair != -1)
                              {
                                v177[0].sa_len = 114;
                                v133 = v177;
                                goto LABEL_236;
                              }
                            }
                          }

                          goto LABEL_237;
                        }
                      }

                      goto LABEL_238;
                    }

                    int v176 = 256;
                    char v129 = atomic_load((unint64_t *)v67 + 1);
                    CFDataRef v101 = (CFDataRef)v67[22];
                    if ((v129 & 0x10) != 0)
                    {
                      if (v101) {
                        goto LABEL_170;
                      }
                      int v134 = *((_DWORD *)v67 + 38);
                      if (v134 != -1)
                      {
                        if (getpeername(v134, v177, (socklen_t *)&v176) || v176 <= 0)
                        {
                          CFDataRef v101 = (CFDataRef)v67[22];
                        }

                        else
                        {
                          v135 = CFGetAllocator(v67);
                          CFDataRef v101 = CFDataCreate(v135, &v177[0].sa_len, v176);
                          v67[22] = (__objc2_class *)v101;
                        }

                        goto LABEL_215;
                      }
                    }

                    else
                    {
LABEL_215:
                      if (v101) {
                        goto LABEL_170;
                      }
                    }
                  }

LABEL_172:
                  v103 = CFGetAllocator(v67);
                  CFDataRef v102 = CFDataCreate(v103, 0LL, 0LL);
                  goto LABEL_173;
                }

                continue;
              }
            }
          }

          else
          {
            int v82 = 0;
          }

          v83 = CFGetAllocator(v67);
          p_sa_len = 0LL;
          CFIndex v84 = 0LL;
          goto LABEL_154;
        }

        char v75 = atomic_load(v69);
        if ((v75 & 3) != 2LL)
        {
          v86 = (pthread_mutex_t *)(v67 + 3);
          pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
          char v87 = atomic_load((unint64_t *)v67 + 1);
          if ((v87 & 0x10) != 0 && (*((_BYTE *)v67 + 17) & 1) == 0)
          {
            if (v68)
            {
              if (!v67[38] && !v67[41])
              {
                *((_DWORD *)v67 + 86) = 0;
                v67[42] = 0LL;
                goto LABEL_149;
              }

LABEL_149:
              os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
              __CFReadSocketsTimeoutInvalid = 0;
              int64_t v88 = *((unsigned int *)v67 + 38);
              if ((v88 & 0x80000000) == 0)
              {
                v89 = (__CFData *)__CFReadSocketsFds;
                unint64_t v90 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                if ((uint64_t)v90 <= v88)
                {
                  unint64_t v147 = v90 >> 5;
                  unint64_t v148 = 4 * (((unint64_t)(v88 + 32) >> 5) - (v90 >> 5));
                  CFDataIncreaseLength(v89, v148);
                  v91 = CFDataGetMutableBytePtr(v89);
                  bzero(&v91[4 * v147], v148);
                }

                else
                {
                  v91 = CFDataGetMutableBytePtr(v89);
                }

                if (!__darwin_check_fd_set_overflow(v88, v91, 1)
                  || ((*(_DWORD *)&v91[((unint64_t)v88 >> 3) & 0x1FFFFFFC] >> v88) & 1) == 0)
                {
                  if (__darwin_check_fd_set_overflow(v88, v91, 1)) {
                    *(_DWORD *)&v91[4 * (v88 >> 5)] |= 1 << v88;
                  }
                  int v149 = __CFWakeupSocketPair;
                  if ((_DWORD)__CFWakeupSocketPair != -1)
                  {
                    context[0].sa_len = 114;
                    v150 = context;
                    goto LABEL_264;
                  }
                }
              }
            }

            else
            {
              v151 = v67[37];
              ssize_t v152 = (ssize_t)v67[38] + v146;
              v67[38] = (__objc2_class *)v152;
              if (v151 == (__objc2_class *)v152)
              {
                *((_DWORD *)v67 + 86) = 0;
                v67[42] = 0LL;
                goto LABEL_206;
              }

              *(void *)&context[0].sa_data[6] = 0LL;
              *(void *)&context[0].sa_len = 0LL;
              gettimeofday((timeval *)context, 0LL);
              v153 = (char *)v67[34] + *(void *)&context[0].sa_len;
              v67[42] = (__objc2_class *)v153;
              int v154 = *((_DWORD *)v67 + 70) + *(_DWORD *)&context[0].sa_data[6];
              *((_DWORD *)v67 + 86) = v154;
              if (v154 >= 1000000)
              {
                v67[42] = (__objc2_class *)(v153 + 1);
                *((_DWORD *)v67 + 86) = v154 - 1000000;
              }

              os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
              __CFReadSocketsTimeoutInvalid = 0;
              int64_t v155 = *((unsigned int *)v67 + 38);
              if ((v155 & 0x80000000) == 0)
              {
                v156 = (__CFData *)__CFReadSocketsFds;
                unint64_t v157 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                if ((uint64_t)v157 <= v155)
                {
                  unint64_t v159 = v157 >> 5;
                  unint64_t v160 = 4 * (((unint64_t)(v155 + 32) >> 5) - (v157 >> 5));
                  CFDataIncreaseLength(v156, v160);
                  v158 = CFDataGetMutableBytePtr(v156);
                  bzero(&v158[4 * v159], v160);
                }

                else
                {
                  v158 = CFDataGetMutableBytePtr(v156);
                }

                if (!__darwin_check_fd_set_overflow(v155, v158, 1)
                  || ((*(_DWORD *)&v158[((unint64_t)v155 >> 3) & 0x1FFFFFFC] >> v155) & 1) == 0)
                {
                  if (__darwin_check_fd_set_overflow(v155, v158, 1)) {
                    *(_DWORD *)&v158[4 * (v155 >> 5)] |= 1 << v155;
                  }
                  int v149 = __CFWakeupSocketPair;
                  if ((_DWORD)__CFWakeupSocketPair != -1)
                  {
                    v177[0].sa_len = 114;
                    v150 = v177;
LABEL_264:
                    send(v149, v150, 1uLL, 0);
                  }
                }
              }
            }

            os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
          }

          v114 = v86;
          goto LABEL_267;
        }

        *(_DWORD *)&v177[0].sa_len = 256;
        int v76 = accept(*((_DWORD *)v67 + 38), context, (socklen_t *)&v177[0].sa_len);
        if (v76 == -1) {
          goto LABEL_268;
        }
        int v77 = v76;
        int v78 = *(_DWORD *)&v177[0].sa_len;
        uint64_t v79 = CFGetAllocator(v67);
        if (v78 < 1)
        {
          v81 = 0LL;
          CFIndex v80 = 0LL;
        }

        else
        {
          CFIndex v80 = *(int *)&v177[0].sa_len;
          v81 = context;
        }

        CFDataRef v112 = CFDataCreate(v79, &v81->sa_len, v80);
        v93 = (pthread_mutex_t *)(v67 + 3);
        pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
        char v113 = atomic_load((unint64_t *)v67 + 1);
        if ((v113 & 0x10) == 0)
        {
          close(v77);
          CFDataRef v95 = v112;
LABEL_187:
          CFRelease(v95);
          v114 = v93;
LABEL_267:
          pthread_mutex_unlock(v114);
          goto LABEL_268;
        }

        unint64_t v115 = atomic_load(v69);
        do
        {
          unint64_t v116 = __ldaxr(v69);
          if (v116 == v115)
          {
            if (!__stlxr(v115 | 0x20, v69))
            {
              int v117 = 1;
              goto LABEL_194;
            }
          }

          else
          {
            __clrex();
          }

          int v117 = 0;
LABEL_194:
          unint64_t v115 = v116;
        }

        while (!v117);
        v118 = (__CFArray *)v67[32];
        if (!v118)
        {
          v119 = CFGetAllocator(v67);
          v118 = CFArrayCreateMutable(v119, 0LL, 0LL);
          v67[32] = (__objc2_class *)v118;
        }

        if (!v67[33])
        {
          v120 = CFGetAllocator(v67);
          v67[33] = (__objc2_class *)CFArrayCreateMutable(v120, 0LL, &kCFTypeArrayCallBacks);
          v118 = (__CFArray *)v67[32];
        }

        CFArrayAppendValue(v118, (const void *)v77);
        CFArrayAppendValue((CFMutableArrayRef)v67[33], v112);
        CFRelease(v112);
        if (((_DWORD)v67[2] & 0x202) == 2 && *((int *)v67 + 46) >= 1)
        {
          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
          __CFReadSocketsTimeoutInvalid = 0;
          int64_t v121 = *((unsigned int *)v67 + 38);
          if ((v121 & 0x80000000) == 0)
          {
            v122 = (__CFData *)__CFReadSocketsFds;
            unint64_t v123 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
            if ((uint64_t)v123 <= v121)
            {
              unint64_t v136 = v123 >> 5;
              unint64_t v137 = 4 * (((unint64_t)(v121 + 32) >> 5) - (v123 >> 5));
              CFDataIncreaseLength(v122, v137);
              v124 = CFDataGetMutableBytePtr(v122);
              bzero(&v124[4 * v136], v137);
            }

            else
            {
              v124 = CFDataGetMutableBytePtr(v122);
            }

            if (!__darwin_check_fd_set_overflow(v121, v124, 1)
              || ((*(_DWORD *)&v124[((unint64_t)v121 >> 3) & 0x1FFFFFFC] >> v121) & 1) == 0)
            {
              if (__darwin_check_fd_set_overflow(v121, v124, 1)) {
                *(_DWORD *)&v124[4 * (v121 >> 5)] |= 1 << v121;
              }
              int v132 = __CFWakeupSocketPair;
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v174.sa_len = 114;
                v133 = &v174;
LABEL_236:
                send(v132, v133, 1uLL, 0);
              }
            }
          }

LABEL_237:
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
        }

              v135 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec",  0LL);
LABEL_238:
              objc_exception_throw(v135);
              goto LABEL_263;
            }

LABEL_238:
        CFRunLoopSourceSignal((CFRunLoopSourceRef)v67[24]);
        v138 = (__objc2_class *)CFRetain(v67[25]);
        v139 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (CFArrayRef)v67[25]);
        v140 = v67[24];
        if (v140)
        {
          if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v67[24]))
          {
            CFRetain(v140);
            char v141 = 0;
            goto LABEL_243;
          }

          v140 = 0LL;
        }

        char v141 = 1;
LABEL_243:
        pthread_mutex_unlock((pthread_mutex_t *)(v67 + 3));
        v142 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v140, v139);
        if ((v141 & 1) == 0) {
          CFRelease(v140);
        }
        if (v142)
        {
          CFRunLoopWakeUp((CFRunLoopRef)v142);
          CFRelease(v142);
        }

        pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
        __int128 v49 = theArray;
        if (v138 == v67[25])
        {
          v67[25] = (__objc2_class *)v139;
          CFRelease(v138);
          v139 = 0LL;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(v67 + 3));
        CFRelease(v138);
        if (v139) {
          CFRelease(v139);
        }
LABEL_268:
        CFArraySetValueAtIndex(v49, v65, &__kCFNull);
LABEL_269:
        if (++v65 == idx)
        {
LABEL_286:
          CFIndex v4 = 0LL;
          unsigned __int8 v2 = v162;
          goto LABEL_2;
        }
      }
    }
  }

  *a6 = v12;
  return v13;
}

uint64_t _calcMinTimeout_locked(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(void *)(result + 272);
  if (!v2 && !*(_DWORD *)(result + 280)) {
    goto LABEL_7;
  }
  unsigned int v3 = (void *)(result + 272);
  uint64_t v4 = *a2;
  if (*a2)
  {
    BOOL v5 = v2 < *(void *)v4;
    if (v2 == *(void *)v4) {
      BOOL v5 = *(_DWORD *)(result + 280) < *(_DWORD *)(v4 + 8);
    }
    if (!v5)
    {
LABEL_7:
      if (!*(void *)(result + 328)) {
        return result;
      }
      unsigned int v3 = &_calcMinTimeout_locked_sKickerTime;
    }
  }

  *a2 = (uint64_t)v3;
  return result;
}

BOOL __CFNativeSocketIsValid(int a1)
{
  return (fcntl(a1, 3, 0LL) & 0x80000000) == 0 || *__error() != 9;
}

UInt8 *clearInvalidFileDescriptors(UInt8 *result)
{
  if (result)
  {
    BOOL v1 = (__CFData *)result;
    int v2 = 8 * CFDataGetLength((CFDataRef)result);
    CFSocketError result = CFDataGetMutableBytePtr(v1);
    if (v2 >= 1)
    {
      unsigned int v3 = result;
      for (unsigned int i = 0; i != v2; ++i)
      {
        CFSocketError result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
        if ((_DWORD)result)
        {
          uint64_t v5 = i >> 5;
          if ((*((_DWORD *)v3 + v5) & (1 << i)) != 0)
          {
            CFSocketError result = (UInt8 *)__CFNativeSocketIsValid(i);
            if (!(_DWORD)result)
            {
              CFSocketError result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
              if ((_DWORD)result) {
                *((_DWORD *)v3 + v5) &= ~(1 << i);
              }
            }
          }
        }
      }
    }
  }

  return result;
}

char *__CFSocketCopyRunLoopToWakeUp(__CFRunLoopSource *a1, CFArrayRef theArray)
{
  if (!a1) {
    return 0LL;
  }
  int Count = CFArrayGetCount(theArray);
  if (Count < 1) {
    return 0LL;
  }
  unsigned int ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, 0LL);
  if (ValueAtIndex && Count != 1)
  {
    for (CFIndex i = 1LL; i < Count; ++i)
    {
      unint64_t v7 = (char *)CFArrayGetValueAtIndex(theArray, i);
      if (v7 != ValueAtIndex) {
        break;
      }
    }

    if (v7 != ValueAtIndex) {
      unsigned int ValueAtIndex = 0LL;
    }
  }

  if (ValueAtIndex)
  {
    CFRetain(ValueAtIndex);
  }

  else
  {
    int v8 = 0;
    int v9 = 0;
    uint64_t v10 = Count;
    do
    {
      CFIndex v11 = (__CFRunLoop *)CFArrayGetValueAtIndex(theArray, (CFIndex)ValueAtIndex);
      CFIndex v12 = CFRunLoopCopyCurrentMode(v11);
      if (v12)
      {
        BOOL v13 = v12;
        if (CFRunLoopContainsSource(v11, a1, v12))
        {
          int IsWaiting = CFRunLoopIsWaiting(v11);
          int v15 = v9 ? v8 : (int)ValueAtIndex;
          BOOL v16 = IsWaiting != 0;
          if (IsWaiting)
          {
            int v8 = (int)ValueAtIndex;
          }

          else
          {
            int v9 = 1;
            int v8 = v15;
          }
        }

        else
        {
          BOOL v16 = 0;
        }

        CFRelease(v13);
        if (v16) {
          break;
        }
      }

      ++ValueAtIndex;
    }

    while ((uint64_t)ValueAtIndex < v10);
    unsigned int ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, v8);
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(theArray, v8);
    CFArrayAppendValue(theArray, ValueAtIndex);
  }

  return ValueAtIndex;
}

void __CFSocketHandleNameRegistryReply( __CFSocket *a1, int a2, const __CFData *a3, CFDataRef data, uint64_t a5)
{
  int v8 = (const __CFDictionary *)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  data,  0LL,  0LL,  0LL);
  int v9 = v8;
  if (*(void *)a5) {
    **(void **)a5 = -1LL;
  }
  if (v8)
  {
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFDictionaryGetTypeID())
    {
      int Value = CFDictionaryGetValue(v9, @"Result");
      if (Value)
      {
        if (*(void *)a5) {
          **(void **)a5 = 0LL;
        }
        if (*(void *)(a5 + 8)) {
          **(void **)(a5 + _Block_object_dispose(va, 8) = CFRetain(Value);
        }
        CFIndex v12 = *(CFDataRef **)(a5 + 16);
        if (v12)
        {
          if (a3)
          {
            CFDataRef Copy = CFDataCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
            CFIndex v12 = *(CFDataRef **)(a5 + 16);
          }

          else
          {
            CFDataRef Copy = 0LL;
          }

          *CFIndex v12 = Copy;
        }
      }
    }

    CFRelease(v9);
  }

  CFSocketInvalidate(a1);
}

uint64_t __CFDateIntervalFormatterDeallocate(void *a1)
{
  int v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  unsigned int v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[4];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[5];
  if (v5) {
    CFRelease(v5);
  }
  int v6 = (const void *)a1[6];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t result = a1[7];
  if (result) {
    return udtitvfmt_close();
  }
  return result;
}

uint64_t CFDateIntervalFormatterCreate( const __CFAllocator *a1, const void *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    a1 = (const __CFAllocator *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x45uLL, 80LL, 0LL, a5, a6, a7, a8);
  uint64_t v12 = Instance;
  if (Instance)
  {
    uint64_t v13 = 2LL;
    if (a3 >= 5) {
      uint64_t v14 = 2LL;
    }
    else {
      uint64_t v14 = a3;
    }
    if (a4 < 5) {
      uint64_t v13 = a4;
    }
    *(void *)(Instance + 64) = v14;
    *(void *)(Instance + 72) = v13;
    if (a2) {
      CFTypeRef v15 = CFRetain(a2);
    }
    else {
      CFTypeRef v15 = 0LL;
    }
    *(void *)(v12 + 16) = v15;
    *(void *)(v12 + 24) = 0LL;
    *(void *)(v12 + 32) = 0LL;
    *(void *)(v12 + 40) = 0LL;
    *(void *)(v12 + 4_Block_object_dispose(va, 8) = CFRetain(&stru_1899EF170);
    *(void *)(v12 + 56) = 0LL;
    *(void *)(v12 + 80) = 0LL;
    *(_DWORD *)(v12 + 8_Block_object_dispose(va, 8) = 0;
    *(_BYTE *)(v12 + 92) &= 0xFCu;
  }

  return v12;
}

void _CFDateIntervalFormatterInitializeFromCoderValues( uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, int a6, int a7, const void *a8, const void *a9, const void *a10)
{
  locCFIndex k = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 72) = a3;
  int v18 = *(const void **)(a1 + 48);
  if (v18 != a4)
  {
    if (v18) {
      CFRelease(v18);
    }
    if (a4) {
      CFRetain(a4);
    }
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = a4;
  }

  CFIndex v19 = *(const void **)(a1 + 40);
  if (v19 != a5)
  {
    if (v19) {
      CFRelease(v19);
    }
    if (a5) {
      CFRetain(a5);
    }
    *(void *)(a1 + 40) = a5;
  }

  *(_BYTE *)(a1 + 92) = (a6 != 0) | (2 * (a7 != 0)) | *(_BYTE *)(a1 + 92) & 0xFC;
  int v20 = *(const void **)(a1 + 16);
  if (v20 != a8)
  {
    if (v20) {
      CFRelease(v20);
    }
    if (a8) {
      CFRetain(a8);
    }
    *(void *)(a1 + 16) = a8;
  }

  CFIndex v21 = *(const void **)(a1 + 24);
  if (v21 != a9)
  {
    if (v21) {
      CFRelease(v21);
    }
    if (a9) {
      CFRetain(a9);
    }
    *(void *)(a1 + 24) = a9;
  }

  uint64_t v22 = *(const void **)(a1 + 32);
  if (v22 != a10)
  {
    if (v22) {
      CFRelease(v22);
    }
    if (a10) {
      CFRetain(a10);
    }
    *(void *)(a1 + 32) = a10;
  }

  os_unfair_lock_unlock(lock);
}

void _CFDateIntervalFormatterCopyCoderValues( uint64_t a1, void *a2, void *a3, void *a4, void *a5, _BYTE *a6, BOOL *a7, void *a8, void *a9, void *a10)
{
  int v18 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v19 = *(void *)(a1 + 72);
  *a2 = *(void *)(a1 + 64);
  *a3 = v19;
  uint64_t v20 = *(void *)(a1 + 48);
  if (v20) {
    CFRetain(*(CFTypeRef *)(a1 + 48));
  }
  *a4 = v20;
  uint64_t v21 = *(void *)(a1 + 40);
  if (v21) {
    CFRetain(*(CFTypeRef *)(a1 + 40));
  }
  *a5 = v21;
  *a6 = *(_BYTE *)(a1 + 92) & 1;
  *a7 = (*(_BYTE *)(a1 + 92) & 2) != 0;
  uint64_t v22 = *(void *)(a1 + 16);
  if (v22) {
    CFRetain(*(CFTypeRef *)(a1 + 16));
  }
  *a8 = v22;
  uint64_t v23 = *(void *)(a1 + 24);
  if (v23) {
    CFRetain(*(CFTypeRef *)(a1 + 24));
  }
  *a9 = v23;
  unint64_t v24 = *(const void **)(a1 + 32);
  if (v24) {
    CFRetain(v24);
  }
  *a10 = v24;
  os_unfair_lock_unlock(v18);
}

uint64_t CFDateIntervalFormatterCreateCopy(const __CFAllocator *a1, uint64_t a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 88));
  uint64_t v9 = CFDateIntervalFormatterCreate( a1,  *(const void **)(a2 + 16),  *(void *)(a2 + 64),  *(void *)(a2 + 72),  v5,  v6,  v7,  v8);
  CFTypeID v10 = *(void **)(a2 + 24);
  if (v10) {
    *(void *)(v9 + 24) = _CFCalendarCreateCopy((uint64_t)a1, v10);
  }
  CFIndex v11 = *(const void **)(a2 + 32);
  if (v11) {
    *(void *)(v9 + 32) = CFRetain(v11);
  }
  uint64_t v12 = *(const __CFString **)(a2 + 40);
  if (v12) {
    *(void *)(v9 + 40) = CFStringCreateCopy(a1, v12);
  }
  uint64_t v13 = *(const __CFString **)(a2 + 48);
  if (v13) {
    *(void *)(v9 + 4_Block_object_dispose(va, 8) = CFStringCreateCopy(a1, v13);
  }
  *(_OWORD *)(v9 + 64) = *(_OWORD *)(a2 + 64);
  char v14 = *(_BYTE *)(v9 + 92) & 0xFE | *(_BYTE *)(a2 + 92) & 1;
  *(_BYTE *)(v9 + 92) = v14;
  *(_BYTE *)(v9 + 92) = v14 & 0xFD | *(_BYTE *)(a2 + 92) & 2;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 88));
  return v9;
}

CFLocaleRef CFDateIntervalFormatterCopyLocale(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  unsigned int v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  unint64_t v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFLocaleRef)v4;
  }

  else
  {
    os_unfair_lock_unlock(v3);
    return CFLocaleCopyCurrent();
  }

void CFDateIntervalFormatterSetLocale(uint64_t a1, const __CFLocale *a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v5 = *(const __CFLocale **)(a1 + 16);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      CFLocaleRef Copy = CFLocaleCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
    }
    else {
      CFLocaleRef Copy = 0LL;
    }
    *(void *)(a1 + 16) = Copy;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

void updateDateTemplateFromCurrentSettings(void *a1)
{
  CFDateFormatterStyle v2 = a1[8];
  CFDateFormatterStyle v3 = a1[9];
  unint64_t v4 = (const void *)a1[2];
  if (v4) {
    uint64_t v5 = (const __CFLocale *)CFRetain(v4);
  }
  else {
    uint64_t v5 = CFLocaleCopyCurrent();
  }
  uint64_t v6 = v5;
  CFTypeRef Value = (CFTypeRef)a1[3];
  if (!Value) {
    CFTypeRef Value = CFLocaleGetValue(v5, @"kCFLocaleCalendarKey");
  }
  uint64_t v8 = CFDateFormatterCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v2, v3);
  CFDateFormatterSetProperty(v8, @"kCFDateFormatterCalendarKey", Value);
  CFRelease(v6);
  Format = CFDateFormatterGetFormat(v8);
  CFTypeID v10 = (const void *)a1[5];
  if (v10) {
    CFRelease(v10);
  }
  a1[5] = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Format);
  CFRelease(v8);
}

CFCalendarRef CFDateIntervalFormatterCopyCalendar(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFCalendarRef v3 = *(CFCalendarRef *)(a1 + 24);
  if (v3)
  {
    CFTypeRef Value = *(__CFCalendar **)(a1 + 24);
  }

  else
  {
    uint64_t v5 = *(const __CFLocale **)(a1 + 16);
    if (!v5)
    {
      CFCalendarRef v3 = CFCalendarCopyCurrent();
      goto LABEL_7;
    }

    CFTypeRef Value = (__CFCalendar *)CFLocaleGetValue(v5, @"kCFLocaleCalendarKey");
    CFCalendarRef v3 = Value;
  }

  CFRetain(Value);
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetCalendar(uint64_t a1, void *a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      uint64_t Copy = _CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    }
    else {
      uint64_t Copy = 0LL;
    }
    *(void *)(a1 + 24) = Copy;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFTimeZoneRef CFDateIntervalFormatterCopyTimeZone(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  unint64_t v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFTimeZoneRef)v4;
  }

  else
  {
    os_unfair_lock_unlock(v3);
    return CFTimeZoneCopyDefault();
  }

void CFDateIntervalFormatterSetTimeZone(uint64_t a1, const void *a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5 != a2)
  {
    if (v5) {
      CFRelease(v5);
    }
    if (a2) {
      CFTypeRef v6 = CFRetain(a2);
    }
    else {
      CFTypeRef v6 = 0LL;
    }
    *(void *)(a1 + 32) = v6;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((void *)a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

const void *CFDateIntervalFormatterCopyDateTemplate(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  CFCalendarRef v3 = *(const void **)(a1 + 48);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetDateTemplate(uint64_t a1, const __CFString *a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  if (a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = &stru_1899EF170;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!CFEqual(v5, *(CFTypeRef *)(a1 + 48)))
  {
    CFTypeRef v6 = *(const void **)(a1 + 48);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    *(_BYTE *)(a1 + 92) |= 3u;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetDateStyle(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 64);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetDateStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((void *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetTimeStyle(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 72);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetTimeStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 72) = a2;
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((void *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t _CFDateIntervalFormatterGetBoundaryStyle(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  }
  CFCalendarRef v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v4 = *(void *)(a1 + 80);
  os_unfair_lock_unlock(v3);
  return v4;
}

void _CFDateIntervalFormatterSetBoundaryStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(void *)(a1 + 80) = a2;
  *(_BYTE *)(a1 + 92) |= 1u;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFStringRef CFDateIntervalFormatterCreateStringFromDateToDate( uint64_t a1, const __CFDate *a2, const __CFDate *a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 69) {
    _CFAssertMismatchedTypeID(0x45uLL, v6);
  }
  uint64_t v7 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v8 = *(void *)(a1 + 56);
  if ((*(_BYTE *)(a1 + 92) & 1) != 0)
  {
    if (v8)
    {
      udtitvfmt_close();
      *(void *)(a1 + 56) = 0LL;
      *(_BYTE *)(a1 + 92) &= ~1u;
    }
  }

  else if (v8)
  {
    goto LABEL_29;
  }

  uint64_t v9 = *(const __CFLocale **)(a1 + 16);
  if (v9) {
    CFRetain(*(CFTypeRef *)(a1 + 16));
  }
  else {
    uint64_t v9 = CFLocaleCopyCurrent();
  }
  CFTypeRef Value = *(CFTypeRef *)(a1 + 24);
  if (!Value) {
    CFTypeRef Value = CFLocaleGetValue(v9, @"kCFLocaleCalendarKey");
  }
  Identifier = CFLocaleGetIdentifier(v9);
  ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Identifier);
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  ComponentsFromLocaleIdentifier);
  CFRelease(ComponentsFromLocaleIdentifier);
  if (Value) {
    CFDictionarySetValue(MutableCopy, @"kCFLocaleCalendarKey", Value);
  }
  LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  MutableCopy);
  CFRelease(MutableCopy);
  int v49 = 0;
  memset(buffer, 0, sizeof(buffer));
  CFStringGetCString(LocaleIdentifierFromComponents, (char *)buffer, 100LL, 0x8000100u);
  CFRelease(LocaleIdentifierFromComponents);
  uint64_t v45 = 0LL;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  *(_OWORD *)UniChar chars = 0u;
  __int128 v34 = 0u;
  CFTypeRef v15 = *(const __CFTimeZone **)(a1 + 32);
  if (v15) {
    CFRetain(*(CFTypeRef *)(a1 + 32));
  }
  else {
    CFTypeRef v15 = CFTimeZoneCopyDefault();
  }
  Name = CFTimeZoneGetName(v15);
  if (CFStringGetLength(Name) > 99) {
    v17.CFIndex length = 100LL;
  }
  else {
    v17.CFIndex length = CFStringGetLength(Name);
  }
  v17.CFIndex location = 0LL;
  CFStringGetCharacters(Name, v17, chars);
  uint64_t v18 = 48LL;
  if ((*(_BYTE *)(a1 + 92) & 2) == 0) {
    uint64_t v18 = 40LL;
  }
  uint64_t v19 = *(const __CFString **)(a1 + v18);
  uint64_t v47 = 0LL;
  memset(v46, 0, sizeof(v46));
  if (CFStringGetLength(v19) > 99) {
    v20.CFIndex length = 100LL;
  }
  else {
    v20.CFIndex length = CFStringGetLength(v19);
  }
  v20.CFIndex location = 0LL;
  CFStringGetCharacters(v19, v20, (UniChar *)v46);
  CFStringGetLength(v19);
  CFStringGetLength(Name);
  uint64_t v21 = udtitvfmt_open();
  *(void *)(a1 + 56) = v21;
  if (v21
    || (u_errorName(U_ZERO_ERROR),
        CFLog( 3LL,  (uint64_t)@"udtitvfmt_open failed!  Formatter is NULL! -- locale: %s, template: %@, timezone: %@, status: %s",  v22,  v23,  v24,  v25,  v26,  v27,  (uint64_t)buffer),  *(void *)(a1 + 56)))
  {
    udtitvfmt_setAttribute();
  }

  CFRelease(v9);
  CFRelease(v15);
  if (!*(void *)(a1 + 56))
  {
    CFStringRef v31 = &stru_1899EF170;
    goto LABEL_33;
  }

CFStringRef CFDateIntervalFormatterCreateStringFromDateInterval(uint64_t a1, uint64_t a2)
{
  started = (const __CFDate *)CFDateIntervalCopyStartDate(a2);
  uint64_t v5 = CFDateIntervalCopyEndDate(a2);
  CFStringRef StringFromDateToDate = CFDateIntervalFormatterCreateStringFromDateToDate(a1, started, v5);
  CFRelease(started);
  CFRelease(v5);
  return StringFromDateToDate;
}

uint64_t CFBundleAllowMixedLocalizations()
{
  if (CFBundleAllowMixedLocalizations_once != -1) {
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  }
  return CFBundleAllowMixedLocalizations_allowMixed;
}

uint64_t __CFBundleAllowMixedLocalizations_block_invoke()
{
  uint64_t result = _CFBundleGetInfoDictionaryBoolean(@"CFBundleAllowMixedLocalizations");
  CFBundleAllowMixedLocalizations_allowMixed = result;
  return result;
}

uint64_t _CFBundleGetInfoDictionaryBoolean(const void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    if (InfoDictionary)
    {
      CFTypeRef Value = (const __CFBoolean *)CFDictionaryGetValue(InfoDictionary, a1);
      if (Value)
      {
        uint64_t v5 = Value;
        CFTypeID v6 = CFGetTypeID(Value);
        if (v6 == CFBooleanGetTypeID()) {
          return CFBooleanGetValue(v5);
        }
        if (v6 == CFStringGetTypeID())
        {
          uint64_t v8 = 1LL;
          if (CFStringCompare((CFStringRef)v5, @"true", 1uLL)) {
            return CFStringCompare((CFStringRef)v5, @"YES", 1uLL) == kCFCompareEqualTo;
          }
          return v8;
        }

        if (v6 == CFNumberGetTypeID())
        {
          int valuePtr = 0;
          if (CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr)) {
            BOOL v9 = valuePtr == 0;
          }
          else {
            BOOL v9 = 1;
          }
          return !v9;
        }
      }
    }
  }

  return 0LL;
}

CFStringRef _CFBundleCopyLocaleAbbreviationForRegionCode(unsigned int a1)
{
  if (a1 <= 0x6C
    && __CFBundleLocaleAbbreviationsArray
    && (BOOL v1 = (const char *)(__CFBundleLocaleAbbreviationsArray + 6 * a1), *v1))
  {
    return CFStringCreateWithCStringNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v1,  0x600u,  (CFAllocatorRef)&__kCFAllocatorNull);
  }

  else
  {
    return 0LL;
  }

uint64_t CFBundleGetLocalizationInfoForLocalization( CFStringRef localeIdentifier, unsigned int *a2, unsigned int *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int ValueAtIndex = localeIdentifier;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unsigned int v22 = -1;
  unsigned int v23 = -1;
  if (localeIdentifier) {
    goto LABEL_2;
  }
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (!MainBundle || (CFTypeRef v16 = _CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) == 0LL)
  {
    CFTypeRef v16 = _CFBundleCopyUserLanguages();
    if (!v16)
    {
LABEL_13:
      _CFBundleGetLanguageAndRegionCodes(&v23, &v22);
      unsigned int RegionCodeForLocalization = v22;
      unsigned int LanguageCodeForLocalization = v23;
      goto LABEL_14;
    }
  }

  if (CFArrayGetCount((CFArrayRef)v16) <= 0)
  {
    CFRelease(v16);
    goto LABEL_13;
  }

  unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v16, 0LL);
  CFRelease(v16);
  if (!ValueAtIndex) {
    goto LABEL_13;
  }
LABEL_2:
  __int16 v21 = -1;
  __int16 v20 = -1;
  __int16 v19 = 0;
  int v18 = 0;
  uint64_t result = CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v21, &v20, &v19, &v18);
  if ((_DWORD)result)
  {
    unsigned int LanguageCodeForLocalization = v21;
    unsigned int RegionCodeForLocalization = v20;
    int v13 = v19;
    int v14 = v18;
    if (!a2) {
      goto LABEL_28;
    }
LABEL_27:
    *a2 = LanguageCodeForLocalization;
    goto LABEL_28;
  }

  unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
  unsigned int v23 = LanguageCodeForLocalization;
  unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
  unsigned int v22 = RegionCodeForLocalization;
LABEL_14:
  if (LanguageCodeForLocalization < 0x99 || RegionCodeForLocalization == -1)
  {
    BOOL v17 = LanguageCodeForLocalization != -1;
    if (RegionCodeForLocalization == -1 && LanguageCodeForLocalization != -1)
    {
      unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
      BOOL v17 = 1;
    }
  }

  else
  {
    unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
    BOOL v17 = LanguageCodeForLocalization != -1;
  }

  if (LanguageCodeForLocalization > 0x97)
  {
    int v13 = 0;
    int v14 = 0;
  }

  else
  {
    int v13 = __CFBundleScriptCodesArray[LanguageCodeForLocalization];
    int v14 = __CFBundleStringEncodingsArray[LanguageCodeForLocalization];
  }

  uint64_t result = RegionCodeForLocalization != -1 || v17;
  if (a2) {
    goto LABEL_27;
  }
LABEL_28:
  if (a3) {
    *a3 = RegionCodeForLocalization;
  }
  if (a4) {
    *a4 = v13;
  }
  if (a5) {
    *a5 = v14;
  }
  return result;
}

CFTypeRef _CFBundleCopyLanguageSearchListInBundle(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  CFCalendarRef v3 = *(__CFArray **)(a1 + 40);
  if (v3) {
    goto LABEL_33;
  }
  os_unfair_lock_unlock(v2);
  unint64_t v4 = (const __CFArray *)_CFBundleCopyBundleLocalizations(a1, 0LL);
  uint64_t v5 = (const __CFArray *)_CFBundleCopyUserLanguages();
  DevelopmentRegion = (__CFString *)CFBundleGetDevelopmentRegion((CFBundleRef)a1);
  CFCalendarRef v3 = _CFBundleCopyPreferredLanguagesInList(v4, DevelopmentRegion, v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  if (!CFArrayGetCount(v3))
  {
    CFRelease(v3);
    CFCalendarRef v3 = _CFBundleCopyPreferredLanguagesInList(v4, @"en_US", v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  }

  if (!CFArrayGetCount(v3) && v4 && CFArrayGetCount(v4) >= 1)
  {
    unsigned int ValueAtIndex = (void *)CFArrayGetValueAtIndex(v4, 0LL);
    CFRelease(v3);
    CFCalendarRef v3 = _CFBundleCopyPreferredLanguagesInList(v4, ValueAtIndex, v5, 1, *(void *)(a1 + 16), (__CFBundle *)a1);
  }

  if (v5) {
    CFRelease(v5);
  }
  if (DevelopmentRegion)
  {
    v14.CFIndex length = CFArrayGetCount(v3);
    v14.CFIndex location = 0LL;
    if (!CFArrayContainsValue(v3, v14, DevelopmentRegion)) {
      CFArrayAppendValue(v3, DevelopmentRegion);
    }
    if (!v4) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    v15.CFIndex location = 0LL;
    v15.CFIndex length = Count;
    if (CFArrayContainsValue(v4, v15, @"en"))
    {
      v9.CFIndex length = CFArrayGetCount(v3);
      CFTypeID v10 = @"en";
    }

    else
    {
      v16.CFIndex location = 0LL;
      v16.CFIndex length = Count;
      if (CFArrayContainsValue(v4, v16, @"English"))
      {
        v9.CFIndex length = CFArrayGetCount(v3);
        CFTypeID v10 = @"English";
      }

      else
      {
        v17.CFIndex location = 0LL;
        v17.CFIndex length = Count;
        if (!CFArrayContainsValue(v4, v17, @"en_US"))
        {
LABEL_24:
          CFRelease(v4);
          goto LABEL_25;
        }

        v9.CFIndex length = CFArrayGetCount(v3);
        CFTypeID v10 = @"en_US";
      }
    }

    v9.CFIndex location = 0LL;
    if (!CFArrayContainsValue(v3, v9, v10)) {
      CFArrayAppendValue(v3, v10);
    }
    goto LABEL_24;
  }

CFTypeRef _CFBundleCopyUserLanguages()
{
  int v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
    goto LABEL_15;
  }
  CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"AppleLanguages", @"kCFPreferencesCurrentApplication");
  if (!v1) {
    CFPropertyListRef v1 = CFPreferencesCopyAppValue(@"NSLanguages", @"kCFPreferencesCurrentApplication");
  }
  CFTypeRef v2 = (CFTypeRef)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = v1 == 0LL;
  }
  if (!v3)
  {
    CFTypeRef v2 = CFRetain(v1);
    _CFBundleUserLanguages = (uint64_t)v2;
  }

  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
      CFRelease((CFTypeRef)_CFBundleUserLanguages);
      _CFBundleUserLanguages = 0LL;
    }
  }

  if (v1) {
    CFRelease(v1);
  }
  int v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages) {
LABEL_15:
  }
    CFTypeRef v5 = CFRetain(v0);
  else {
    CFTypeRef v5 = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  return v5;
}

uint64_t _CFBundleGetLanguageCodeForLocalization(const __CFString *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length;
  if (!CFStringGetCString(a1, buffer, 255LL, 0x600u)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = 0LL;
  char v14 = 0;
  do
  {
    unint64_t v5 = v4;
    int v6 = strcmp(buffer, __CFBundleLanguageNamesArray[v4]);
    if (!v6) {
      break;
    }
    unint64_t v4 = v5 + 1;
  }

  while (v5 < 0x97);
  BOOL v7 = *(_DWORD *)buffer == 1415538810 && *(unsigned __int16 *)&buffer[4] == 87;
  if (v7 || *(void *)buffer == 0x746E61482D687ALL) {
    return 19LL;
  }
  BOOL v8 = *(_DWORD *)buffer == 1130326138 && *(unsigned __int16 *)&buffer[4] == 78;
  uint64_t result = 33LL;
  if (!v8)
  {
    uint64_t result = *(void *)buffer == 0x736E61482D687ALL ? 33LL : v5;
    if (*(void *)buffer != 0x736E61482D687ALL && v6)
    {
      if (v3 != 2)
      {
        if (buffer[2] < 0
           ? __maskrune(buffer[2], 0x100uLL)
           : *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * buffer[2] + 60) & 0x100)
        {
          return 0xFFFFFFFFLL;
        }
      }

      if (buffer[0] == 110 && buffer[1] == 111)
      {
        return 9LL;
      }

      else
      {
        unint64_t v11 = 0LL;
        uint64_t result = 0xFFFFFFFFLL;
        while (buffer[0] != byte_180C37437[v11] || buffer[1] != byte_180C37437[v11 + 1])
        {
          BOOL v12 = v11 >= 0x1C5;
          v11 += 3LL;
          if (v12) {
            return result;
          }
        }

        return (unsigned __int16)v11 / 3u;
      }
    }
  }

  return result;
}

uint64_t _CFBundleGetRegionCodeForLocalization(const __CFString *a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  unint64_t v2 = 0LL;
  buffer[5] = 0;
  uint64_t v3 = __CFBundleLocaleAbbreviationsArray;
  do
  {
    else {
      uint64_t result = 0xFFFFFFFFLL;
    }
    if ((_DWORD)result != -1) {
      break;
    }
    BOOL v5 = v2 >= 0x288;
    v2 += 6LL;
  }

  while (!v5);
  if ((int)result <= 27)
  {
    if ((_DWORD)result != -1)
    {
      if ((_DWORD)result == 25) {
        return 68LL;
      }
      return result;
    }

void _CFBundleGetLanguageAndRegionCodes(unsigned int *a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (BOOL v5 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) != 0LL
    || (BOOL v5 = (const __CFArray *)_CFBundleCopyUserLanguages()) != 0LL)
  {
    if (CFArrayGetCount(v5) < 1)
    {
      unsigned int RegionCodeForLocalization = 0;
      unsigned int LanguageCodeForLocalization = 0;
    }

    else
    {
      unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0LL);
      __int16 v10 = -1;
      __int16 v9 = -1;
      if (CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v10, &v9, 0LL, 0LL))
      {
        unsigned int LanguageCodeForLocalization = v10;
        unsigned int RegionCodeForLocalization = v9;
      }

      else
      {
        unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
        unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
      }

      if (LanguageCodeForLocalization != -1 || RegionCodeForLocalization == -1)
      {
        if (RegionCodeForLocalization == -1 && LanguageCodeForLocalization != -1) {
          unsigned int RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
        }
      }

      else
      {
        unsigned int LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
      }
    }

    CFRelease(v5);
    if (a1) {
      goto LABEL_18;
    }
  }

  else
  {
    unsigned int RegionCodeForLocalization = 0;
    unsigned int LanguageCodeForLocalization = 0;
    if (a1) {
LABEL_18:
    }
      *a1 = LanguageCodeForLocalization;
  }

  if (a2) {
    *a2 = RegionCodeForLocalization;
  }
}

uint64_t _CFBundleGetLanguageCodeForRegionCode(unsigned int a1)
{
  if (a1 == 52) {
    return 33LL;
  }
  if (a1 > 0x6C) {
    return 0xFFFFFFFFLL;
  }
  if (!__CFBundleLocaleAbbreviationsArray) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v2 = (unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + 6 * a1);
  if (!*v2) {
    return 0xFFFFFFFFLL;
  }
  for (unint64_t i = 0LL; *v2 != byte_180C37437[i] || v2[1] != byte_180C37437[i + 1]; i += 3LL)
  {
    if (i >= 0x1C5) {
      return 0xFFFFFFFFLL;
    }
  }

  return (unsigned __int16)i / 3u;
}

uint64_t _CFBundleGetRegionCodeForLanguageCode(unsigned int a1)
{
  if (a1 == 19) {
    return 53LL;
  }
  if (a1 > 0x97) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v2 = &byte_180C37437[3 * a1];
  if (!*v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = 0LL;
  while (*(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3) != *v2
       || *(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3 + 1) != v2[1])
  {
    BOOL v4 = v3 >= 0x288;
    v3 += 6LL;
    if (v4)
    {
      unsigned int v5 = -1;
      goto LABEL_11;
    }
  }

  unsigned int v5 = (unsigned __int16)v3 / 6;
LABEL_11:
  if (v5 == 28) {
    return 82LL;
  }
  else {
    return v5;
  }
}

CFStringRef CFBundleCopyLocalizationForLocalizationInfo(unsigned int a1, unsigned int a2, int a3, int a4)
{
  CFStringRef result = _CFBundleCopyLocaleAbbreviationForRegionCode(a2);
  if (!result)
  {
    CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(a1);
    if (!result)
    {
      unint64_t v8 = 0LL;
      do
      {
        if (__CFBundleScriptCodesArray[v8] == a3)
        {
          if (__CFBundleStringEncodingsArray[v8] == a4) {
            unsigned int v9 = v8;
          }
          else {
            unsigned int v9 = -1;
          }
        }

        else
        {
          unsigned int v9 = -1;
        }

        if (v9 != -1) {
          break;
        }
        BOOL v10 = v8++ >= 0x97;
      }

      while (!v10);
      unint64_t v11 = 0LL;
      do
      {
        int v12 = __CFBundleScriptCodesArray[v11];
        int v13 = v11 + 1;
        if (v12 == a3) {
          break;
        }
        BOOL v10 = v11++ >= 0x97;
      }

      while (!v10);
      unint64_t v14 = 0LL;
      if (v12 == a3) {
        unsigned int v15 = v13 - 1;
      }
      else {
        unsigned int v15 = -1;
      }
      do
      {
        int v16 = __CFBundleStringEncodingsArray[v14];
        int v17 = v14 + 1;
        if (v16 == a4) {
          break;
        }
        BOOL v10 = v14++ >= 0x97;
      }

      while (!v10);
      CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v9);
      if (!result)
      {
        if (v16 == a4) {
          unsigned int v18 = v17 - 1;
        }
        else {
          unsigned int v18 = -1;
        }
        CFStringRef result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v18);
        if (!result) {
          return _CFBundleCopyLanguageAbbreviationForLanguageCode(v15);
        }
      }
    }
  }

  return result;
}

CFStringRef _CFBundleCopyLanguageAbbreviationForLanguageCode(unsigned int a1)
{
  if (a1 <= 0x97 && (CFPropertyListRef v1 = &byte_180C37437[3 * a1], *v1)) {
    return CFStringCreateWithCStringNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v1,  0x600u,  (CFAllocatorRef)&__kCFAllocatorNull);
  }
  else {
    return 0LL;
  }
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)_CFBundleCopyBundleLocalizations((uint64_t)bundle, 0LL);
}

const void *_CFBundleCopyBundleLocalizations(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  os_unfair_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 128))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    if (CFBundleGetMainBundle() != (CFBundleRef)a1) {
      goto LABEL_8;
    }
    if (CFBundleFollowParentLocalization_once != -1) {
      dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_135);
    }
    if (CFBundleFollowParentLocalization_followParent != 1
      || (unsigned int v5 = _CFBundleCopyXPCBootstrapMainBundleLanguages()) == 0LL)
    {
LABEL_8:
      unsigned int v5 = _copyBundleLocalizationsFromResources((__CFBundle *)a1, a2);
    }

    os_unfair_lock_lock_with_options();
    if (!*(_BYTE *)(a1 + 128))
    {
      *(void *)(a1 + 120) = CFRetain(v5);
      *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
      goto LABEL_12;
    }

    CFRelease(v5);
  }

  unsigned int v5 = CFRetain(*(CFTypeRef *)(a1 + 120));
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  return v5;
}

CFArrayRef CFBundleCopyLocalizationsForURL(CFURLRef url)
{
  v15[1] = *(const void **)MEMORY[0x1895F89C0];
  CFBundleRef v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  v15[0] = 0LL;
  if (v2)
  {
    CFBundleRef v4 = v2;
    unsigned int v5 = (const __CFArray *)_CFBundleCopyBundleLocalizations((uint64_t)v2, 0LL);
    CFRelease(v4);
    return v5;
  }

  else
  {
    BOOL v7 = _CFBundleCopyInfoDictionaryInExecutable(url, v3);
    if (!v7) {
      return 0LL;
    }
    unint64_t v8 = v7;
    CFTypeRef Value = CFDictionaryGetValue(v7, @"CFBundleLocalizations");
    if (!Value
      || (v10 = Value, CFTypeID v11 = CFGetTypeID(Value), v11 != CFArrayGetTypeID())
      || (int v12 = (const __CFString *)CFRetain(v10)) == 0LL)
    {
      int v12 = (const __CFString *)_copyAppleLocalizations(v8);
      if (!v12)
      {
        int v13 = (const __CFString *)CFDictionaryGetValue(v8, @"CFBundleDevelopmentRegion");
        int v12 = v13;
        v15[0] = v13;
        if (v13)
        {
          CFTypeID v14 = CFGetTypeID(v13);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(v12) >= 1) {
            int v12 = (const __CFString *)CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v15,  1LL,  &kCFTypeArrayCallBacks);
          }
          else {
            int v12 = 0LL;
          }
        }
      }
    }

    CFRelease(v8);
    return (CFArrayRef)v12;
  }

uint64_t _copyAppleLocalizations(const __CFDictionary *a1)
{
  if (CFDictionaryGetValue(a1, @"_CFBundleUseAppleLocalizations") != &__kCFBooleanTrue) {
    return 0LL;
  }
  CFBundleRef v2 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"/System/Library/Frameworks/CoreFoundation.framework",  kCFURLPOSIXPathStyle,  1u);
  CFBundleRef v3 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
  uint64_t v4 = _copyBundleLocalizationsFromResources(v3, 0LL);
  CFRelease(v2);
  CFRelease(v3);
  return v4;
}

void _CFBundleSetupXPCBootstrapWithLanguages(void *a1, const __CFArray *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  if (CFArrayGetCount(a2) >= 1)
  {
    CFIndex v5 = 0LL;
    do
    {
      unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v5);
      if (CFStringGetCString(ValueAtIndex, buffer, 128LL, 0x8000100u))
      {
        xpc_object_t v7 = xpc_string_create(buffer);
        if (v7)
        {
          unint64_t v8 = v7;
          xpc_array_append_value(v4, v7);
          xpc_release(v8);
        }
      }

      ++v5;
    }

    while (v5 < CFArrayGetCount(a2));
  }

  if (xpc_array_get_count(v4))
  {
    xpc_object_t v9 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_value(v9, "MainBundleLanguages", v4);
    xpc_dictionary_set_value(a1, "_NSBundleEntry", v9);
    xpc_release(v9);
  }

  xpc_release(v4);
}

void _CFBundleSetupXPCBootstrap(void *a1)
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFBundleRef v3 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle);
    if (v3)
    {
      xpc_object_t v4 = v3;
      _CFBundleSetupXPCBootstrapWithLanguages(a1, v3);
      CFRelease(v4);
    }
  }

void _CFBundleFlushLanguageCachesAfterEUIDChange()
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  _CFBundleFlushBundleCaches((uint64_t)MainBundle);
  _CFLocaleResetCurrent();
  os_unfair_lock_lock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  if (_CFBundleUserLanguages)
  {
    CFRelease((CFTypeRef)_CFBundleUserLanguages);
    _CFBundleUserLanguages = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  if (prefArray) {
    return _CFBundleCopyLocalizationsForPreferences(locArray, prefArray, 0);
  }
  xpc_object_t v4 = (const __CFArray *)_CFBundleCopyUserLanguages();
  if (!v4) {
    xpc_object_t v4 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  CFIndex v5 = _CFBundleCopyLocalizationsForPreferences(locArray, v4, 0);
  CFRelease(v4);
  return v5;
}

__CFArray *_CFBundleCopyLocalizationsForPreferences(const __CFArray *a1, const __CFArray *a2, int a3)
{
  if (!a1 || CFArrayGetCount(a1) < 1) {
    goto LABEL_10;
  }
  CFMutableArrayRef Mutable = _CFBundleCopyPreferredLanguagesInList(a1, 0LL, a2, a3, 0LL, 0LL);
  if (CFArrayGetCount(Mutable) || CFArrayGetCount(a1) < 1)
  {
    if (CFArrayGetCount(Mutable)) {
      goto LABEL_9;
    }
    unsigned int ValueAtIndex = @"en";
  }

  else
  {
    unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, 0LL);
  }

  CFArrayAppendValue(Mutable, ValueAtIndex);
LABEL_9:
  if (!Mutable)
  {
LABEL_10:
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(Mutable, @"en");
  }

  return Mutable;
}

CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(CFArrayRef locArray)
{
  CFBundleRef v2 = (const __CFArray *)_CFBundleCopyUserLanguages();
  if (!v2) {
    CFBundleRef v2 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  CFBundleRef v3 = _CFBundleCopyLocalizationsForPreferences(locArray, v2, 1);
  CFRelease(v2);
  return v3;
}

void _CFBundleSetDefaultLocalization(CFStringRef theString)
{
  if (theString) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
  }
  else {
    CFStringRef Copy = 0LL;
  }
  if (_defaultLocalization) {
    CFRelease((CFTypeRef)_defaultLocalization);
  }
  _defaultLocalization = (uint64_t)Copy;
}

__CFArray *_CFBundleCopyPreferredLanguagesInList( const __CFArray *a1, void *a2, CFArrayRef theArray, int a4, unint64_t a5, __CFBundle *a6)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  values = a2;
  if (!a4) {
    goto LABEL_5;
  }
  if (CFBundleAllowMixedLocalizations_once != -1) {
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  }
  if (CFBundleAllowMixedLocalizations_allowMixed)
  {
LABEL_5:
    uint64_t v11 = 0LL;
    goto LABEL_6;
  }

  if (CFBundleFollowParentLocalization_once != -1) {
    dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_135);
  }
  if (CFBundleFollowParentLocalization_followParent == 1)
  {
    uint64_t v11 = (const __CFArray *)_CFBundleCopyXPCBootstrapMainBundleLanguages();
    if (!v11) {
      goto LABEL_6;
    }
LABEL_28:
    if (CFArrayGetCount(v11) >= 1)
    {
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v11);
      if (MutableArrayOfFallbackLanguages) {
        goto LABEL_30;
      }
    }

    goto LABEL_6;
  }

  CFBundleRef MainBundle = CFBundleGetMainBundle();
  uint64_t v11 = MainBundle;
  if (!MainBundle) {
    goto LABEL_6;
  }
  CFURLRef v16 = CFBundleCopyBundleURL(MainBundle);
  if (!v16) {
    goto LABEL_5;
  }
  CFURLRef v17 = v16;
  if (a5 && CFEqual((CFTypeRef)a5, v16)) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(v11);
  }
  CFRelease(v17);
  if (v11) {
    goto LABEL_28;
  }
LABEL_6:
  if (!theArray || CFArrayGetCount(theArray) < 1)
  {
    MutableArrayOfFallbackLanguages = 0LL;
LABEL_11:
    if (a2)
    {
      CFArrayRef v13 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&values,  1LL,  &kCFTypeArrayCallBacks);
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v13);
      CFRelease(v13);
    }

    goto LABEL_13;
  }

  MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)theArray);
  if (!MutableArrayOfFallbackLanguages) {
    goto LABEL_11;
  }
LABEL_13:
  if (!MutableArrayOfFallbackLanguages)
  {
    *(void *)buf = @"en_US";
    CFArrayRef v14 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)buf, 1LL, &kCFTypeArrayCallBacks);
    MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v14);
    CFRelease(v14);
    if (!MutableArrayOfFallbackLanguages) {
      MutableArrayOfFallbackLanguages = CFArrayCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeArrayCallBacks);
    }
  }

__CFArray *_CFBundleCopyLanguageSearchListInDirectory(const __CFURL *a1, unsigned __int8 *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unsigned __int8 v18 = 0;
  xpc_object_t v4 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, &v18);
  CFIndex v5 = v4;
  if (!v4)
  {
    xpc_object_t v7 = 0LL;
    BOOL v10 = 0LL;
    goto LABEL_11;
  }

  CFTypeRef Value = (__CFString *)CFDictionaryGetValue(v4, @"CFBundleDevelopmentRegion");
  xpc_object_t v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFStringGetTypeID() || !CFStringGetLength(v7)) {
      xpc_object_t v7 = 0LL;
    }
  }

  xpc_object_t v9 = CFDictionaryGetValue(v5, @"CFBundleLocalizations");
  if (!v9) {
    goto LABEL_9;
  }
  BOOL v10 = v9;
  CFRetain(v9);
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFArrayGetTypeID())
  {
    CFRelease(v10);
LABEL_9:
    BOOL v10 = (const void *)_copyAppleLocalizations(v5);
  }

uint64_t _CFBundleCopyLProjDirectoriesForURL(uint64_t a1, CFURLRef relativeURL)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  BOOL v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  CFBundleRef v3 = CFURLCopyAbsoluteURL(relativeURL);
  xpc_object_t v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  CFIndex Length = CFStringGetLength(@".lproj");
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  uint64_t v8[2] = ___CFBundleCopyLProjDirectoriesForURL_block_invoke;
  v8[3] = &unk_18999C978;
  double v8[4] = &v9;
  v8[5] = Length;
  v8[6] = @".lproj";
  v8[7] = a1;
  _CFIterateDirectory(v4, 0, 0LL, (uint64_t)v8);
  CFRelease(v4);
  uint64_t v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_180AE0074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

CFTypeRef _CFBundleCopyXPCBootstrapMainBundleLanguages()
{
  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken != -1) {
    dispatch_once(&_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken, &__block_literal_global_141);
  }
  CFTypeRef result = (CFTypeRef)_CFBundleCopyXPCBootstrapMainBundleLanguages_result;
  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_result) {
    return CFRetain((CFTypeRef)_CFBundleCopyXPCBootstrapMainBundleLanguages_result);
  }
  return result;
}

CFArrayRef _copyBundleLocalizationsFromResources(__CFBundle *a1, uint64_t a2)
{
  v50[1] = *(const void **)MEMORY[0x1895F89C0];
  InfoDictionary = CFBundleGetInfoDictionary(a1);
  if (InfoDictionary)
  {
    CFIndex v5 = InfoDictionary;
    CFTypeRef Value = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, @"CFBundleLocalizations");
    if (Value && (v7 = Value, CFTypeID v8 = CFGetTypeID(Value), v8 == CFArrayGetTypeID()))
    {
      uint64_t v9 = CFGetAllocator(a1);
      CFIndex Count = CFArrayGetCount(v7);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v9, Count, &kCFTypeArrayCallBacks);
      if (CFArrayGetCount(v7) >= 1)
      {
        CFIndex v12 = 0LL;
        do
        {
          unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v12);
          CFTypeID v14 = CFGetTypeID(ValueAtIndex);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(ValueAtIndex) >= 1) {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          ++v12;
        }

        while (v12 < CFArrayGetCount(v7));
      }

      unsigned int v15 = CFGetAllocator(a1);
      CFStringRef Copy = CFArrayCreateCopy(v15, Mutable);
      CFRelease(Mutable);
    }

    else
    {
      CFStringRef Copy = (const __CFArray *)_copyAppleLocalizations(v5);
    }
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFURLRef v17 = CFBundleCopyResourcesDirectoryURL(a1);
  if (v17)
  {
    unsigned __int8 v18 = v17;
    CFAllocatorRef v19 = CFGetAllocator(a1);
    uint64_t v20 = _CFBundleCopyLProjDirectoriesForURL((uint64_t)v19, v18);
    if (v20)
    {
      CFRange v21 = (const __CFArray *)v20;
      if (Copy)
      {
        MutableCFStringRef Copy = CFArrayCreateMutableCopy(0LL, 0LL, Copy);
        CFRelease(Copy);
        v58.CFIndex length = CFArrayGetCount(v21);
        v58.CFIndex location = 0LL;
        CFArrayAppendArray(MutableCopy, v21, v58);
        CFRelease(v21);
        CFStringRef Copy = MutableCopy;
      }

      else
      {
        CFStringRef Copy = (const __CFArray *)v20;
      }
    }

    CFRelease(v18);
  }

  CFStringRef DevelopmentRegion = CFBundleGetDevelopmentRegion(a1);
  BOOL v24 = DevelopmentRegion;
  v50[0] = DevelopmentRegion;
  if (Copy)
  {
    if (!DevelopmentRegion) {
      return Copy;
    }
    CFIndex v25 = CFArrayGetCount(Copy);
    if (a2 == 1 || !a2 && (dyld_program_sdk_at_least() & 1) == 0)
    {
      v51.CFIndex location = 0LL;
      v51.CFIndex length = v25;
      if (!CFArrayContainsValue(Copy, v51, @"Base")) {
        return Copy;
      }
    }

    uint64_t v26 = CFArrayGetCount(Copy);
    v52.CFIndex location = 0LL;
    v52.CFIndex length = v26;
    if (CFArrayContainsValue(Copy, v52, v24))
    {
      uint64_t v27 = v24;
    }

    else
    {
      AlternateNameForLanguage = _CFBundleGetAlternateNameForLanguage(v24);
      if (AlternateNameForLanguage
        && (CFIndex v32 = AlternateNameForLanguage,
            v53.CFIndex location = 0LL,
            v53.CFIndex length = v26,
            CFArrayContainsValue(Copy, v53, AlternateNameForLanguage)))
      {
        uint64_t v27 = v32;
      }

      else
      {
        CFIndex Length = CFStringGetLength(v24);
        if (Length >= 4)
        {
          CFIndex v34 = Length;
          int CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 2LL);
          int v36 = CharacterAtIndex;
          if (CharacterAtIndex == 95 || CharacterAtIndex == 45)
          {
            __int128 v37 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v24);
            CFTypeRef v28 = v37;
            __int16 v38 = v36 == 45 ? @"_" : @"-";
            v54.CFIndex location = 2LL;
            v54.CFIndex length = 1LL;
            CFStringReplace(v37, v54, v38);
            if (v28)
            {
              v55.CFIndex location = 0LL;
              v55.CFIndex length = v26;
              if (CFArrayContainsValue(Copy, v55, v28)) {
                goto LABEL_28;
              }
              CFRelease(v28);
            }
          }
        }

        if (CFArrayGetCount(Copy) < 1) {
          goto LABEL_54;
        }
        CFIndex v39 = 0LL;
        while (1)
        {
          __int16 v40 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v39);
          __int128 v41 = _CFBundleGetAlternateNameForLanguage(v24);
          __int16 v42 = _CFBundleGetAlternateNameForLanguage(v40);
          if (_CFBundleIsLanguageDefaultLanguageOfOther(v24, v40)
            || _CFBundleIsLanguageDefaultLanguageOfOther(v41, v40)
            || _CFBundleIsLanguageDefaultLanguageOfOther(v24, v42))
          {
            break;
          }

          if (++v39 >= CFArrayGetCount(Copy)) {
            goto LABEL_54;
          }
        }

        if (v40 && (v56.location = 0LL, v56.CFIndex length = v26, CFArrayContainsValue(Copy, v56, v40)))
        {
          uint64_t v27 = v40;
        }

        else
        {
LABEL_54:
          CFLocaleIdentifier CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v24);
          if (!CanonicalLanguageIdentifierFromString) {
            goto LABEL_62;
          }
          CFTypeRef v28 = CanonicalLanguageIdentifierFromString;
          v57.CFIndex location = 0LL;
          v57.CFIndex length = v26;
          if (CFArrayContainsValue(Copy, v57, CanonicalLanguageIdentifierFromString)) {
            goto LABEL_28;
          }
          if (v26 < 1)
          {
LABEL_61:
            CFRelease(v28);
            goto LABEL_62;
          }

          CFIndex v44 = 0LL;
          while (1)
          {
            uint64_t v45 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v44);
            CFLocaleIdentifier v46 = CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45);
            if (v46)
            {
              CFLocaleIdentifier v47 = v46;
              int v48 = CFEqual(v46, v28);
              CFRelease(v47);
              if (v48) {
                break;
              }
            }

            if (v26 == ++v44) {
              goto LABEL_61;
            }
          }

          CFRelease(v28);
          uint64_t v27 = v45;
        }
      }
    }

    CFTypeRef v28 = CFRetain(v27);
    if (v28)
    {
LABEL_28:
      CFRelease(v28);
      return Copy;
    }

__CFString *_CFBundleGetAlternateNameForLanguage(CFTypeRef cf1)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    CFBundleRef v3 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageAbbreviationsArray[v2];
    int v4 = CFEqual(cf1, v3);
    CFIndex v5 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageNamesArray[v2];
    if (v4) {
      break;
    }
    if (CFEqual(cf1, v5)) {
      return v3;
    }
    if (++v2 == 7) {
      return 0LL;
    }
  }

  return v5;
}

BOOL _CFBundleIsLanguageDefaultLanguageOfOther(const void *a1, const void *a2)
{
  BOOL v2 = 0LL;
  if (a1 && a2)
  {
    int v4 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a1);
    if (v4)
    {
      CFIndex v5 = v4;
      uint64_t v6 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a2);
      if (v6)
      {
        xpc_object_t v7 = v6;
        BOOL v2 = CFStringCompare(v5, v6, 1uLL) == kCFCompareEqualTo;
        CFRelease(v5);
        CFIndex v5 = v7;
      }

      else
      {
        BOOL v2 = 0LL;
      }

      CFRelease(v5);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

const void *_CFBundleCopyDefaultLanguageForLanguage(const void *a1)
{
  CFMutableArrayRef Mutable = (const __CFDictionary *)_CFBundleCopyDefaultLanguageForLanguage_cache;
  if (!_CFBundleCopyDefaultLanguageForLanguage_cache)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    _CFBundleCopyDefaultLanguageForLanguage_cache = (uint64_t)Mutable;
  }

  CFTypeRef Value = (const __CFString *)CFDictionaryGetValue(Mutable, a1);
  if (Value)
  {
    CFStringRef Copy = CFStringCreateCopy(0LL, Value);
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
    return Copy;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
  CFStringRef Copy = _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags((uint64_t)a1);
  if (Copy)
  {
    os_unfair_lock_lock_with_options();
    CFDictionarySetValue((CFMutableDictionaryRef)_CFBundleCopyDefaultLanguageForLanguage_cache, a1, Copy);
    goto LABEL_7;
  }

  return Copy;
}

__CFArray *_CFBundleCreateMutableArrayOfFallbackLanguages(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (const __CFArray *)MEMORY[0x1895F8858](a1, a2);
  int v4 = v3;
  CFIndex v5 = v2;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  CFIndex Count = CFArrayGetCount(v2);
  xpc_object_t v7 = malloc(8 * Count);
  CFTypeID v8 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v7, v5, (uint64_t)v7);
  CFIndex v9 = CFArrayGetCount(v4);
  BOOL v10 = malloc(8 * v9);
  uint64_t v11 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v10, v4, (uint64_t)v10);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  if (v8)
  {
    if (v11)
    {
      int v13 = ualoc_localizationsToUse();
      if (v13 >= 1)
      {
        uint64_t v14 = v13;
        unsigned int v15 = (const char **)&v19;
        do
        {
          CFStringRef v16 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *v15, 0x8000100u);
          if (v16)
          {
            CFStringRef v17 = v16;
            CFArrayAppendValue(Mutable, v16);
            CFRelease(v17);
          }

          ++v15;
          --v14;
        }

        while (v14);
      }
    }
  }

  if (v7) {
    free(v7);
  }
  if (v8) {
    free(v8);
  }
  if (v10) {
    free(v10);
  }
  if (v11) {
    free(v11);
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

void _onelineFormatArray(__CFString *a1, const __CFArray *a2)
{
  if (a2)
  {
    v4.CFIndex length = CFArrayGetCount(a2);
    v4.CFIndex location = 0LL;
    CFArrayApplyFunction(a2, v4, (CFArrayApplierFunction)_onelineFormatArrayApply, a1);
    if (CFArrayGetCount(a2) >= 1)
    {
      v5.CFIndex location = CFStringGetLength(a1) - 2;
      v5.CFIndex length = 2LL;
      CFStringDelete(a1, v5);
    }
  }

  else
  {
    CFStringAppend(a1, @"<null>");
  }

  CFStringAppend(a1, @"]");
}

void _onelineFormatArrayApply(uint64_t a1, CFMutableStringRef theString)
{
}

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

objc_class *__NSOrderedSetParameterCheckIterate( objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  v23[1] = *MEMORY[0x1895F89C0];
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v6 = result;
    if (a5)
    {
      unint64_t v7 = [a5 lastIndex];
      CFTypeRef result = (objc_class *)-[objc_class count](v6, "count");
      if (!result)
      {
        uint64_t v8 = _os_log_pack_size();
        BOOL v10 = (char *)v23 - ((MEMORY[0x1895F8858](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = _os_log_pack_fill();
        CFIndex v12 = PROEM_SEL_1(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSOrderedSet", (uint64_t)v12, v7);
        CFRange v21 = PROEM_SEL_1(a2);
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** -[%s %s]: index %lu beyond bounds for empty array",  "NSOrderedSet",  v21,  v7);
LABEL_11:
        char v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v10,  v8);
        objc_exception_throw(v19);
        return (objc_class *)PROEM_SEL_1(v20);
      }
    }

    else
    {
      unint64_t v7 = (unint64_t)&__kCFAllocatorSystemDefault;
      uint64_t v13 = __CFExceptionProem(result, a2);
      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@: index set is nil", v13);
      uint64_t v14 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
      objc_exception_throw(v14);
    }

    unsigned int v15 = result;
    uint64_t v8 = _os_log_pack_size();
    BOOL v10 = (char *)v23 - ((MEMORY[0x1895F8858](v8, v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = _os_log_pack_fill();
    unsigned __int8 v18 = PROEM_SEL_1(a2);
    unsigned int v15 = (objc_class *)((char *)v15 - 1);
    __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v17, (uint64_t)"NSOrderedSet", (uint64_t)v18, v7, (uint64_t)v15);
    unsigned int v22 = PROEM_SEL_1(a2);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** -[%s %s]: index %lu beyond bounds [0 .. %lu]",  "NSOrderedSet",  v22,  v7,  v15);
    goto LABEL_11;
  }

  return result;
}

const char *PROEM_SEL_1(const char *a1)
{
  if (a1) {
    return sel_getName(a1);
  }
  else {
    return "(null selector)";
  }
}

BOOL __NSOrderedSetChunkIterate( void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  id v40 = a8;
  uint64_t v42 = a6;
  uint64_t v45 = *MEMORY[0x1895F89C0];
  char v44 = 0;
  uint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
  if (a7) {
    uint64_t v14 = a7;
  }
  else {
    uint64_t v14 = (unint64_t *)&v43;
  }
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    unint64_t v15 = atomic_load(v14);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      BOOL v16 = v15 >= a3;
      BOOL v17 = v15 <= a4;
      if ((a2 & 2) != 0) {
        BOOL v16 = v17;
      }
      if (!v16) {
        return 0LL;
      }
    }
  }

  __int128 v41 = v14;
  __int128 v37 = (void *)_CFAutoreleasePoolPush();
  __int16 v38 = &v36;
  uint64_t v19 = MEMORY[0x1895F8858](v37, v18);
  CFRange v21 = (char *)&v36 - v20;
  MEMORY[0x1895F8858](v19, v22);
  BOOL v24 = (char *)&v36 - v23;
  if ((a2 & 0x1000000000000000LL) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v36 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_46;
  }

  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1LL) {
    goto LABEL_46;
  }
  uint64_t v25 = 0LL;
  CFIndex v39 = a9;
  while (1)
  {
    uint64_t v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0) {
      uint64_t v26 = v25;
    }
    if ((a2 & 0x1000000000000000LL) != 0 && !v24[v26]) {
      goto LABEL_33;
    }
    if ((a2 & 2) != 0) {
      unint64_t v27 = a4 - v25;
    }
    else {
      unint64_t v27 = v25 + a3;
    }
    if ((a2 & 0x6000000000000000LL) == 0)
    {
      __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(v42);
      goto LABEL_27;
    }

    if ((__NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v42) & 1) != 0) {
      break;
    }
LABEL_27:
    if (v44) {
      goto LABEL_46;
    }
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      unint64_t v28 = atomic_load(v41);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        BOOL v29 = v28 >= a3;
        BOOL v30 = v28 <= a4;
        if ((a2 & 2) == 0) {
          BOOL v30 = v29;
        }
        if (!v30) {
          goto LABEL_46;
        }
      }
    }

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void __NSOrderedSetEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if ([a1 count])
  {
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      uint64_t v6 = [a4 firstIndex];
      unint64_t v30 = [a4 lastIndex];
    }

    else
    {
      uint64_t v6 = 0LL;
      unint64_t v30 = [a1 count] - 1;
    }

    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((a3 & 1) != 0)
      {
        uint64_t v7 = __CFActiveProcessorCount();
        if (v7 < 2) {
          a3 &= ~1uLL;
        }
      }

      else
      {
        uint64_t v7 = 1LL;
      }

      if ((a3 & 3) != 0)
      {
        unint64_t v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000) {
            unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0LL;
          }
          else {
            unint64_t v9 = 4096LL;
          }
        }

        else
        {
          unint64_t v9 = 16LL;
        }

        unint64_t v17 = v9 + v30 - v6;
        uint64_t v36 = 0LL;
        __int128 v37 = &v36;
        uint64_t v38 = 0x2020000000LL;
        uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
        size_t v18 = v17 / v9;
        if ((a3 & 1) != 0)
        {
          v34[0] = 0LL;
          v34[1] = v34;
          v34[2] = 0x2020000000LL;
          char v35 = 0;
          block[0] = MEMORY[0x1895F87A8];
          block[1] = 3221225472LL;
          void block[2] = ____NSOrderedSetEnumerate_block_invoke;
          block[3] = &unk_18999C070;
          void block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          block[4] = a1;
          void block[5] = a4;
          block[7] = v34;
          block[8] = &v36;
          block[6] = a2;
          block[9] = v6;
          dispatch_apply(v18, 0LL, block);
          _Block_object_dispose(v34, 8);
        }

        else if (v9 <= v17)
        {
          uint64_t v19 = 0LL;
          unint64_t v20 = v9 - 1;
          if (v18 <= 1) {
            uint64_t v21 = 1LL;
          }
          else {
            uint64_t v21 = v17 / v9;
          }
          uint64_t v22 = v21 - 1;
          unint64_t v23 = v6;
          unint64_t v24 = v30;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v20 >= v24 - v6) {
                unint64_t v26 = v6;
              }
              else {
                unint64_t v26 = 1 - v9 + v24;
              }
              unint64_t v25 = v24;
            }

            else
            {
              if (v20 >= v24 - v6) {
                unint64_t v25 = v30;
              }
              else {
                unint64_t v25 = v20 + v19 * v9 + v6;
              }
              unint64_t v26 = v23;
            }

            BOOL v27 = __NSOrderedSetChunkIterate(a1, a3, v26, v25, a4, a2, (unint64_t *)v37 + 3, 0LL, 0LL);
            ++v19;
            if (v22) {
              int v28 = v27;
            }
            else {
              int v28 = 1;
            }
            --v22;
            v24 -= v9;
            v23 += v9;
          }

          while (v28 != 1);
        }

        _Block_object_dispose(&v36, 8);
      }

      else
      {
        unint64_t v29 = v6;
        LOBYTE(v34[0]) = 0;
        BOOL v10 = (void *)_CFAutoreleasePoolPush();
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
        if (v11)
        {
          uint64_t v12 = 0LL;
          unint64_t v13 = 0LL;
          uint64_t v14 = *(void *)v42;
          do
          {
            for (uint64_t i = 0LL; i != v11; ++i)
            {
              if (*(void *)v42 != v14) {
                objc_enumerationMutation(a1);
              }
              unint64_t v16 = v12 + i;
              if ((a3 & 0x1000000000000000LL) == 0
                || v29 <= v16 && v16 <= v30 && [a4 containsIndex:v12 + i])
              {
                __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v13 < 0x3FF)
                {
                  ++v13;
                }

                else
                {
                  _CFAutoreleasePoolPop(v10);
                  BOOL v10 = (void *)_CFAutoreleasePoolPush();
                  unint64_t v13 = 0LL;
                }
              }
            }

            uint64_t v11 = [a1 countByEnumeratingWithState:&v41 objects:v40 count:16];
            v12 += i;
          }

          while (v11);
        }

        _CFAutoreleasePoolPop(v10);
      }
    }
  }

void sub_180AE1798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

unint64_t __NSOrderedSetGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (![a1 count]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    uint64_t v7 = [a4 firstIndex];
    unint64_t v37 = [a4 lastIndex];
  }

  else
  {
    uint64_t v7 = 0LL;
    unint64_t v37 = [a1 count] - 1;
  }

  unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v37 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if ((a3 & 1) != 0)
    {
      uint64_t v9 = __CFActiveProcessorCount();
      if (v9 < 2) {
        a3 &= ~1uLL;
      }
    }

    else
    {
      uint64_t v9 = 1LL;
    }

    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v37 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
        }
        else {
          unint64_t v11 = 4096LL;
        }
      }

      else
      {
        unint64_t v11 = 16LL;
      }

      unint64_t v21 = v11 + v37 - v7;
      size_t v22 = v21 / v11;
      if ((a3 & 1) != 0)
      {
        v44[0] = 0LL;
        v44[1] = (unint64_t)v44;
        void v44[2] = 0x2020000000LL;
        char v45 = 0;
        uint64_t v40 = 0LL;
        __int128 v41 = &v40;
        uint64_t v42 = 0x2020000000LL;
        uint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        void block[2] = ____NSOrderedSetGetIndexPassingTest_block_invoke;
        block[3] = &unk_18999C070;
        void block[10] = v11;
        block[11] = v37;
        block[12] = a3;
        block[4] = a1;
        void block[5] = a4;
        block[6] = a2;
        block[7] = v44;
        block[8] = &v40;
        block[9] = v7;
        dispatch_apply(v22, 0LL, block);
        unint64_t v8 = atomic_load((unint64_t *)v41 + 3);
        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(v44, 8);
      }

      else
      {
        uint64_t v36 = a2;
        v44[0] = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v21)
        {
          unint64_t v23 = v7;
          uint64_t v24 = 0LL;
          unint64_t v25 = v11 - 1;
          if (v22 <= 1) {
            uint64_t v26 = 1LL;
          }
          else {
            uint64_t v26 = v21 / v11;
          }
          uint64_t v27 = v26 - 1;
          unint64_t v28 = v23;
          unint64_t v29 = v37;
          do
          {
            uint64_t v30 = v27;
            if ((a3 & 2) != 0)
            {
              if (v25 >= v29 - v23) {
                unint64_t v32 = v23;
              }
              else {
                unint64_t v32 = 1 - v11 + v29;
              }
              unint64_t v31 = v29;
            }

            else
            {
              if (v25 >= v29 - v23) {
                unint64_t v31 = v37;
              }
              else {
                unint64_t v31 = v25 + v24 * v11 + v23;
              }
              unint64_t v32 = v28;
            }

            if (__NSOrderedSetChunkIterate(a1, a3, v32, v31, a4, v36, v44, 0LL, 0LL)) {
              break;
            }
            ++v24;
            uint64_t v27 = v30 - 1;
            v29 -= v11;
            v28 += v11;
          }

          while (v30);
        }

        return atomic_load(v44);
      }

      return v8;
    }

    uint64_t v12 = (void *)_CFAutoreleasePoolPush();
    LOBYTE(v44[0]) = 0;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    uint64_t v13 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
    if (!v13) {
      goto LABEL_56;
    }
    uint64_t v14 = v13;
    CFRunLoopSourceContext context = v12;
    unint64_t v35 = v7;
    unint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    uint64_t v17 = *(void *)v48;
LABEL_17:
    uint64_t v18 = 0LL;
    while (1)
    {
      if (*(void *)v48 != v17) {
        objc_enumerationMutation(a1);
      }
      unint64_t v19 = v16 + v18;
      uint64_t v20 = *(void *)(*((void *)&v47 + 1) + 8 * v18);
      if ((a3 & 0x1000000000000000LL) == 0
        || v35 <= v19 && v19 <= v37 && [a4 containsIndex:v16 + v18])
      {
        if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(a2 + 16))( a2,  v20,  v16 + v18,  v44) & 1) != 0)
        {
          unint64_t v8 = v16 + v18;
LABEL_55:
          uint64_t v12 = context;
LABEL_56:
          _CFAutoreleasePoolPop(v12);
          return v8;
        }

        if (LOBYTE(v44[0])) {
          goto LABEL_31;
        }
        if (v15 >= 0x3FF)
        {
          _CFAutoreleasePoolPop(context);
          CFRunLoopSourceContext context = (void *)_CFAutoreleasePoolPush();
          unint64_t v15 = 0LL;
        }

        else
        {
          ++v15;
        }
      }

      if (v14 == ++v18)
      {
        uint64_t v14 = [a1 countByEnumeratingWithState:&v47 objects:v46 count:16];
        v16 += v18;
        if (v14) {
          goto LABEL_17;
        }
LABEL_31:
        unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_55;
      }
    }
  }

  return v8;
}

id __NSOrderedSetGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (![a1 count]
    || ((a3 & 0x1000000000000000LL) != 0
      ? (v7 = [a4 firstIndex], unint64_t v37 = objc_msgSend(a4, "lastIndex"))
      : (v7 = 0, unint64_t v37 = [a1 count] - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v37 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    return (id)objc_opt_new();
  }

  else
  {
    if ((a3 & 1) != 0)
    {
      uint64_t v8 = __CFActiveProcessorCount();
      if (v8 < 2) {
        a3 &= ~1uLL;
      }
    }

    else
    {
      uint64_t v8 = 1LL;
    }

    __CFLookUpClass("NSMutableIndexSet");
    uint64_t v36 = (void *)objc_opt_new();
    if ((a3 & 3) != 0)
    {
      unint64_t v10 = (v37 - v7 + 1) / v8 / v8;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000) {
          unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
        }
        else {
          unint64_t v11 = 4096LL;
        }
      }

      else
      {
        unint64_t v11 = 16LL;
      }

      unint64_t v20 = v11 + v37 - v7;
      size_t v21 = v20 / v11;
      if ((a3 & 1) != 0)
      {
        v40[0] = 0LL;
        v40[1] = v40;
        int v40[2] = 0x2020000000LL;
        char v41 = 0;
        __int128 v45 = 0u;
        __int128 v44 = 0u;
        __int128 v43 = 0u;
        uint64_t v46 = 0LL;
        uint64_t v42 = 850045857LL;
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        void block[2] = ____NSOrderedSetGetIndexesPassingTest_block_invoke;
        block[3] = &unk_18999C098;
        block[8] = v40;
        block[9] = v7;
        void block[10] = v11;
        block[11] = v37;
        block[4] = a1;
        void block[5] = a4;
        block[6] = v36;
        block[7] = a2;
        block[12] = a3;
        void block[13] = &v42;
        dispatch_apply(v21, 0LL, block);
        _Block_object_dispose(v40, 8);
      }

      else
      {
        unint64_t v35 = a1;
        if (v11 <= v20)
        {
          unint64_t v22 = v7;
          uint64_t v23 = 0LL;
          unint64_t v24 = v11 - 1;
          if (v21 <= 1) {
            uint64_t v25 = 1LL;
          }
          else {
            uint64_t v25 = v20 / v11;
          }
          uint64_t v26 = v25 - 1;
          unint64_t v27 = v22;
          unint64_t v28 = v37;
          do
          {
            uint64_t v29 = v26;
            if ((a3 & 2) != 0)
            {
              if (v24 >= v28 - v22) {
                unint64_t v31 = v22;
              }
              else {
                unint64_t v31 = 1 - v11 + v28;
              }
              unint64_t v30 = v28;
            }

            else
            {
              if (v24 >= v28 - v22) {
                unint64_t v30 = v37;
              }
              else {
                unint64_t v30 = v24 + v23 * v11 + v22;
              }
              unint64_t v31 = v27;
            }

            if (__NSOrderedSetChunkIterate(v35, a3, v31, v30, a4, a2, 0LL, v36, 0LL)) {
              break;
            }
            ++v23;
            uint64_t v26 = v29 - 1;
            v28 -= v11;
            v27 += v11;
          }

          while (v29);
        }
      }
    }

    else
    {
      CFRunLoopSourceContext context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v42) = 0;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      uint64_t v12 = [a1 countByEnumeratingWithState:&v48 objects:v47 count:16];
      if (v12)
      {
        uint64_t v13 = v12;
        unint64_t v34 = v7;
        uint64_t v14 = 0LL;
        unint64_t v15 = 0LL;
        uint64_t v16 = *(void *)v49;
        do
        {
          for (uint64_t i = 0LL; i != v13; ++i)
          {
            if (*(void *)v49 != v16) {
              objc_enumerationMutation(a1);
            }
            unint64_t v18 = v14 + i;
            uint64_t v19 = *(void *)(*((void *)&v48 + 1) + 8 * i);
            if ((a3 & 0x1000000000000000LL) == 0
              || v34 <= v18 && v18 <= v37 && [a4 containsIndex:v14 + i])
            {
              if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(a2 + 16))( a2,  v19,  v14 + i,  &v42))
              {
                [v36 addIndex:v14 + i];
              }

              if ((_BYTE)v42) {
                goto LABEL_33;
              }
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                CFRunLoopSourceContext context = (void *)_CFAutoreleasePoolPush();
                unint64_t v15 = 0LL;
              }

              else
              {
                ++v15;
              }
            }
          }

          uint64_t v13 = [a1 countByEnumeratingWithState:&v48 objects:v47 count:16];
          v14 += i;
        }

        while (v13);
      }

uint64_t comparisonUsingOrderingForStringKeys(id *a1, void *a2)
{
  if (*a1 == (id)*a2) {
    return 0LL;
  }
  else {
    return objc_msgSend(*a1, "compare:options:range:locale:", *a2, 2, 0, objc_msgSend(*a1, "length"), 0);
  }
}

uint64_t comparisonUsingOrderingForNumericKeys(void **a1, void **a2)
{
  BOOL v2 = *a1;
  if (v2 == *a2) {
    return 0LL;
  }
  else {
    return objc_msgSend(v2, "compare:");
  }
}

uint64_t __CFURLComponentsEqual(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

id __CFURLComponentsCopyDescription(void *a1)
{
  return (id)[a1 debugDescription];
}

uint64_t _CFURLComponentsGetTypeID()
{
  return 30LL;
}

id _CFURLComponentsCreate()
{
  return (id)unk_18C5463EC(&off_18C546D08, "_components");
}

id _CFURLComponentsCreateWithURL(uint64_t a1, uint64_t a2, int a3)
{
  return (id)unk_18C5463F8(&off_18C546D08, "_componentsWithUrl:resolvingAgainstBaseURL:", a2, a3 != 0);
}

id _CFURLComponentsCreateWithString(uint64_t a1, uint64_t a2)
{
  return (id)unk_18C5463D4(&off_18C546D08, "_componentsWithString:encodingInvalidCharacters:", a2, 1LL);
}

uint64_t _CFURLComponentsCreateWithStringInternal()
{
  return 0LL;
}

uint64_t _CFURLComponentsCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

id _CFURLComponentsCopyURL(void *a1)
{
  return (id)[a1 URL];
}

id _CFURLComponentsCopyURLRelativeToURL(void *a1, uint64_t a2)
{
  return (id)[a1 URLRelativeToURL:a2];
}

id _CFURLComponentsCopyString(void *a1)
{
  return (id)[a1 string];
}

id _CFURLComponentsCopyScheme(void *a1)
{
  return (id)[a1 scheme];
}

id _CFURLComponentsCopyUser(void *a1)
{
  return (id)[a1 user];
}

id _CFURLComponentsCopyPassword(void *a1)
{
  return (id)[a1 password];
}

id _CFURLComponentsCopyHost(void *a1)
{
  return (id)[a1 host];
}

id _CFURLComponentsCopyPort(void *a1)
{
  return (id)[a1 port];
}

id _CFURLComponentsCopyPath(void *a1)
{
  return (id)[a1 path];
}

id _CFURLComponentsCopyQuery(void *a1)
{
  return (id)[a1 query];
}

id _CFURLComponentsCopyFragment(void *a1)
{
  return (id)[a1 fragment];
}

uint64_t _CFURLComponentsSetScheme(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE3328(void *a1)
{
}

uint64_t _CFURLComponentsSetUser(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t _CFURLComponentsSetPassword(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t _CFURLComponentsSetHost(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t _CFURLComponentsSetPort(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE33A8(void *a1)
{
}

uint64_t _CFURLComponentsSetPath(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t _CFURLComponentsSetQuery(void *a1, uint64_t a2)
{
  return 1LL;
}

uint64_t _CFURLComponentsSetFragment(void *a1, uint64_t a2)
{
  return 1LL;
}

id _CFURLComponentsCopyPercentEncodedUser(void *a1)
{
  return (id)[a1 percentEncodedUser];
}

id _CFURLComponentsCopyPercentEncodedPassword(void *a1)
{
  return (id)[a1 percentEncodedPassword];
}

id _CFURLComponentsCopyPercentEncodedHost(void *a1)
{
  return (id)[a1 percentEncodedHost];
}

id _CFURLComponentsCopyPercentEncodedPath(void *a1)
{
  return (id)[a1 percentEncodedPath];
}

id _CFURLComponentsCopyPercentEncodedQuery(void *a1)
{
  return (id)[a1 percentEncodedQuery];
}

id _CFURLComponentsCopyPercentEncodedFragment(void *a1)
{
  return (id)[a1 percentEncodedFragment];
}

uint64_t _CFURLComponentsSchemeIsValid(const __CFString *a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length - 1;
  if (Length < 1) {
    return 0LL;
  }
  uint64_t v4 = Length;
  CFStringRef theString = a1;
  uint64_t v33 = 0LL;
  CFIndex v34 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  unint64_t v31 = CharactersPtr;
  if (CharactersPtr)
  {
    uint64_t v35 = 0LL;
    CFIndex v36 = 0LL;
    id v32 = 0LL;
    __int16 v6 = *CharactersPtr;
  }

  else
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
    uint64_t v35 = 0LL;
    CFIndex v36 = 0LL;
    id v32 = CStringPtr;
    if (CStringPtr)
    {
      __int16 v6 = *CStringPtr;
    }

    else
    {
      v9.CFIndex length = v4 >= 64 ? 64LL : v4;
      CFIndex v36 = v9.length;
      v9.CFIndex location = 0LL;
      CFStringGetCharacters(a1, v9, &buffer);
      __int16 v6 = *(_WORD *)&v29[-2 * v35 - 2];
    }
  }

  if ((unint64_t)v4 >= 2)
  {
    uint64_t v11 = 0LL;
    BOOL v10 = 0;
    uint64_t v12 = -1LL;
    uint64_t v13 = 65LL;
    unint64_t v14 = 1LL;
    do
    {
      if (v14 >= 4) {
        uint64_t v15 = 4LL;
      }
      else {
        uint64_t v15 = v14;
      }
      if (v31)
      {
        UniChar v16 = v31[v11 + 1 + v33];
      }

      else if (v32)
      {
        UniChar v16 = v32[v33 + 1 + v11];
      }

      else
      {
        if (v36 <= v11 + 1 || (uint64_t v17 = v35, v35 > v11 + 1))
        {
          uint64_t v18 = -v15;
          uint64_t v19 = v15 + v12;
          uint64_t v20 = v13 - v15;
          uint64_t v21 = v11 + v18;
          uint64_t v22 = v21 + 1;
          CFIndex v23 = v21 + 65;
          if (v23 >= v34) {
            CFIndex v23 = v34;
          }
          uint64_t v35 = v22;
          CFIndex v36 = v23;
          if (v34 < v20) {
            uint64_t v20 = v34;
          }
          v38.CFIndex length = v20 + v19;
          v38.CFIndex location = v22 + v33;
          CFStringGetCharacters(theString, v38, &buffer);
          uint64_t v17 = v35;
        }

        UniChar v16 = *(_WORD *)&v29[2 * v11 + -2 * v17];
      }

      if (v16 > 0x7Fu) {
        break;
      }
      if ((unsigned __int16)(v16 - 48) >= 0xAu && (unsigned __int16)((v16 & 0xFFDF) - 65) >= 0x1Au)
      {
        unsigned int v25 = v16;
        uint64_t v26 = (1LL << v16) & 0x680000000000LL;
        if (v25 > 0x2E || v26 == 0) {
          break;
        }
      }

      ++v14;
      BOOL v10 = v11 + 2 >= v4;
      ++v11;
      --v12;
      ++v13;
    }

    while (v3 != v11);
  }

  else
  {
    return 1;
  }

  return v10;
}

id _CFURLComponentsCopyEncodedHost(void *a1)
{
  return (id)[a1 encodedHost];
}

uint64_t _CFURLComponentsSetPercentEncodedUser(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE3734(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedPassword(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE3760(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedHost(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE378C(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedPath(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE37B8(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedQuery(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE37E4(void *a1)
{
}

uint64_t _CFURLComponentsSetPercentEncodedFragment(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE3810(void *a1)
{
}

uint64_t _CFURLComponentsSetEncodedHost(void *a1, uint64_t a2)
{
  return 1LL;
}

void sub_180AE383C(void *a1)
{
}

uint64_t _CFURLComponentsGetRangeOfScheme(void *a1)
{
  uint64_t result = [a1 rangeOfScheme];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfUser(void *a1)
{
  uint64_t result = [a1 rangeOfUser];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPassword(void *a1)
{
  uint64_t result = [a1 rangeOfPassword];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfHost(void *a1)
{
  uint64_t result = [a1 rangeOfHost];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPort(void *a1)
{
  uint64_t result = [a1 rangeOfPort];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPath(void *a1)
{
  uint64_t result = [a1 rangeOfPath];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfQuery(void *a1)
{
  uint64_t result = [a1 rangeOfQuery];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

uint64_t _CFURLComponentsGetRangeOfFragment(void *a1)
{
  uint64_t result = [a1 rangeOfFragment];
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

CFArrayRef _CFURLComponentsCopyQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 0);
}

CFArrayRef __CFURLComponentsCopyQueryItems(void *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a2) {
    BOOL v2 = (void *)[a1 percentEncodedQueryItems];
  }
  else {
    BOOL v2 = (void *)[a1 queryItems];
  }
  CFIndex v3 = v2;
  if (!v2) {
    return 0LL;
  }
  if ([v2 count] == 1) {
    return CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  uint64_t v6 = [v3 countByEnumeratingWithState:&v17 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v18;
    __int128 v13 = xmmword_18999CA08;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(v3);
        }
        BOOL v10 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        *(_OWORD *)keys = v13;
        values[0] = (void *)objc_msgSend(v10, "name", v13);
        values[1] = (void *)[v10 value];
        if ([v10 value]) {
          CFIndex v11 = 2LL;
        }
        else {
          CFIndex v11 = 1LL;
        }
        CFDictionaryRef v12 = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)keys,  (const void **)values,  v11,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        CFArrayAppendValue(Mutable, v12);
      }

      uint64_t v7 = [v3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    }

    while (v7);
  }

  return Mutable;
}

CFArrayRef _CFURLComponentsCopyPercentEncodedQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 1);
}

CFIndex __CFURLComponentsSetQueryItems(void *a1, CFArrayRef theArray, const __CFArray *a3)
{
  CFIndex v3 = a1;
  if (!theArray)
  {
    uint64_t v15 = 0LL;
    return [a1 setQuery:v15];
  }

  if (!CFArrayGetCount(theArray))
  {
    uint64_t v15 = &stru_1899EF170;
    a1 = v3;
    return [a1 setQuery:v15];
  }

  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex result = CFArrayGetCount(a3);
  if (Count == result)
  {
    uint64_t v8 = +[NSArray array](&OBJC_CLASS___NSMutableArray, "array");
    if (CFArrayGetCount(theArray) >= 1)
    {
      CFIndex v9 = 0LL;
      do
      {
        unsigned int ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
        CFIndex v11 = (__objc2_class **)CFArrayGetValueAtIndex(a3, v9);
        if (ValueAtIndex == (const __CFString *)&__kCFNull)
        {
          unsigned int ValueAtIndex = &stru_1899EF170;
        }

        else
        {
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFStringGetTypeID()) {
            unsigned int ValueAtIndex = &stru_1899EF170;
          }
        }

        if (v11 == &__kCFNull)
        {
          unint64_t v14 = 0LL;
        }

        else
        {
          CFTypeID v13 = CFGetTypeID(v11);
          if (v13 == CFStringGetTypeID()) {
            unint64_t v14 = v11;
          }
          else {
            unint64_t v14 = 0LL;
          }
        }

        -[NSArray addObject:]( v8,  "addObject:",  unk_18C546E04(&off_18C547088, "queryItemWithName:value:", ValueAtIndex, v14));
        ++v9;
      }

      while (CFArrayGetCount(theArray) > v9);
    }

    return [v3 setQueryItems:v8];
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t _CFURLComponentsSetPercentEncodedQueryItems(void *a1, const __CFArray *a2, const __CFArray *a3)
{
  return 1LL;
}

uint64_t _CFURLComponentsMatchURLInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = unk_18C5463E0(&off_18C546D08, "_matchWithString:requiredComponents:defaultValues:urlPtr:", a1, a2, a3, a4);
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    return -1LL;
  }
  return result;
}

unint64_t _CFSocketStreamSetAuthenticatesServerCertificateDefault( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog( 3LL,  (uint64_t)@"_CFSocketStreamSetAuthenticatesServerCertificateDefault(): This call has been deprecated.  Use SetProperty(_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate, kCFBooleanTrue/False)\n",  a3,  a4,  a5,  a6,  a7,  a8,  vars0);
}

uint64_t _CFSocketStreamGetAuthenticatesServerCertificateDefault( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0LL;
}

uint64_t _CFSocketStreamPairSetAuthenticatesServerCertificate( __CFReadStream *a1, CFWriteStreamRef stream, int a3)
{
  CFIndex v3 = &kCFBooleanFalse;
  if (a3) {
    CFIndex v3 = &kCFBooleanTrue;
  }
  CFBooleanRef v4 = *v3;
  if (a1) {
    return CFReadStreamSetProperty(a1, @"_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate", v4);
  }
  else {
    return CFWriteStreamSetProperty(stream, @"_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate", v4);
  }
}

void CFStreamCreatePairWithSocket( CFAllocatorRef alloc, CFSocketNativeHandle sock, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

uint64_t createPair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  if (a6) {
    *a6 = 0LL;
  }
  if (a7) {
    *a7 = 0LL;
  }
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_18C536ED0 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  pthread_mutex_unlock(&CFNetworkSupport);
  return off_18C536ED8(a1, a2, a3, a4, a5, a6, a7);
}

void CFStreamCreatePairWithSocketToHost( CFAllocatorRef alloc, CFStringRef host, UInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

void CFStreamCreatePairWithPeerSocketSignature( CFAllocatorRef alloc, const CFSocketSignature *signature, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

uint64_t _CFStreamErrorFromError(__CFError *a1)
{
  if ((dword_18C536ED0 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  BOOL v2 = off_18C536EE8;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v2) {
    return off_18C536EE8(a1);
  }
  CFErrorDomain Domain = CFErrorGetDomain(a1);
  if (CFEqual(Domain, @"NSPOSIXErrorDomain"))
  {
    uint64_t v3 = 1LL;
  }

  else if (CFEqual(Domain, @"NSOSStatusErrorDomain"))
  {
    uint64_t v3 = 2LL;
  }

  else if (CFEqual(Domain, @"NSMachErrorDomain"))
  {
    uint64_t v3 = 11LL;
  }

  else
  {
    uint64_t v3 = -1LL;
  }

  CFErrorGetCode(a1);
  return v3;
}

void *initializeCFNetworkSupport()
{
  dword_18C536ED0 |= 1u;
  off_18C536ED8 = __CFLookupCFNetworkFunction("_CFSocketStreamCreatePair");
  off_18C536EE0 = __CFLookupCFNetworkFunction("_CFErrorCreateWithStreamError");
  uint64_t result = __CFLookupCFNetworkFunction("_CFStreamErrorFromCFError");
  off_18C536EE8 = result;
  if (!off_18C536ED8) {
    uint64_t result = (void *)CFLog( 3LL,  (uint64_t)@"CoreFoundation: failed to dynamically link symbol _CFSocketStreamCreatePair",  v1,  v2,  v3,  v4,  v5,  v6,  v7);
  }
  if (!off_18C536EE0) {
    uint64_t result = (void *)CFLog( 3LL,  (uint64_t)@"CoreFoundation: failed to dynamically link symbol _CFErrorCreateWithStreamError",  v1,  v2,  v3,  v4,  v5,  v6,  v7);
  }
  if (!off_18C536EE8) {
    uint64_t result = (void *)CFLog( 3LL,  (uint64_t)@"CoreFoundation: failed to dynamically link symbol _CFStreamErrorFromCFError",  v1,  v2,  v3,  v4,  v5,  v6,  v7);
  }
  dword_18C536ED0 |= 2u;
  return result;
}

CFErrorRef _CFStreamCreateErrorFromStreamError(const __CFAllocator *a1, int *a2)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_18C536ED0 & 1) == 0) {
    initializeCFNetworkSupport();
  }
  uint64_t v4 = off_18C536EE0;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v4) {
    return (CFErrorRef)off_18C536EE0(a1, a2);
  }
  if (*(void *)a2 == 2LL)
  {
    CFIndex v6 = a2[2];
    uint64_t v7 = (CFErrorDomain *)&kCFErrorDomainOSStatus;
    return CFErrorCreate(a1, *v7, v6, 0LL);
  }

  if (*(void *)a2 == 1LL)
  {
    CFIndex v6 = a2[2];
    uint64_t v7 = (CFErrorDomain *)&kCFErrorDomainPOSIX;
    return CFErrorCreate(a1, *v7, v6, 0LL);
  }

  keys[0] = @"CFStreamErrorDomainKey";
  values = CFNumberCreate(a1, kCFNumberCFIndexType, a2);
  uint64_t v8 = CFDictionaryCreate( a1,  (const void **)keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFErrorRef v9 = CFErrorCreate(a1, @"BogusCFStreamErrorCompatibilityDomain", a2[2], v8);
  CFRelease(values);
  CFRelease(v8);
  return v9;
}

void CFSortIndexes(uint64_t a1, unint64_t a2, char a3, uint64_t a4)
{
  block[7] = *MEMORY[0x1895F89C0];
  if ((uint64_t)a2 >= 1)
  {
    if (a2 >> 60) {
      CFSortIndexes_cold_1();
    }
    char v6 = a3;
    uint64_t v7 = (char *)a1;
    if ((a3 & 1) != 0)
    {
      a1 = __CFActiveProcessorCount();
      if (a2 < 0xA0 || (int)a1 < 2)
      {
        char v6 = 0;
      }

      else if (a2 > 0x27F || a1 <= 2)
      {
        if (a2 > 0xC7F || a1 <= 4)
        {
          else {
            a1 = 8LL;
          }
        }

        else
        {
          a1 = 4LL;
        }
      }

      else
      {
        a1 = 2LL;
      }

      else {
        int v8 = a1;
      }
    }

    else
    {
      int v8 = 0;
    }

    if (a2 > 0x10000)
    {
      dispatch_queue_t v12 = dispatch_queue_create("com.apple.NSSortIndexes", MEMORY[0x1895F8AF8]);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      void block[2] = __CFSortIndexes_block_invoke;
      block[3] = &__block_descriptor_tmp_9;
      block[4] = ((a2 + 15) >> 3) & 0x1FFFFFFFFFFFFFFELL;
      void block[5] = a2;
      block[6] = v7;
      dispatch_apply(8uLL, 0LL, block);
      dispatch_release(v12);
      if ((v6 & 1) == 0)
      {
LABEL_18:
        MEMORY[0x1895F8858](a1, a2);
        CFIndex v11 = (char *)block - v10;
        if ((uint64_t)a2 > 4096)
        {
          CFTypeID v13 = (char *)malloc(8 * a2);
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)v13, a4);
          if (v11 != v13) {
            free(v13);
          }
        }

        else
        {
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)block - v10, a4);
        }

        return;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
      do
      {
        *(void *)&v7[8 * v9] = v9;
        ++v9;
      }

      while (a2 != v9);
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
    }

    __CFSortIndexesN(v7, a2, v8, a4);
  }

void *__CFSortIndexes_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = result[4];
  uint64_t v3 = v2 * a2;
  uint64_t v4 = v2 * a2 + v2;
  if (v4 >= result[5]) {
    uint64_t v4 = result[5];
  }
  if (v3 < v4)
  {
    uint64_t v5 = result[6];
    do
    {
      *(void *)(v5 + 8 * v3) = v3;
      ++v3;
    }

    while (v4 != v3);
  }

  return result;
}

void __CFSortIndexesN(char *a1, uint64_t a2, int a3, uint64_t a4)
{
  void block[10] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (a2 + a3 - 1) / a3;
  uint64_t v8 = v6 + 15;
  BOOL v7 = v6 < -15;
  uint64_t v9 = v6 + 30;
  if (!v7) {
    uint64_t v9 = v8;
  }
  int64_t v10 = v9 & 0xFFFFFFFFFFFFFFF0LL;
  uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF0LL) + a2;
  int64_t v12 = (v11 - 1) / v10;
  uint64_t v13 = v11 - v10 * v12;
  MEMORY[0x1895F8858](a1, a2);
  uint64_t v15 = (const void **)((char *)&v25 - v14);
  size_t v17 = v16 << 7;
  if (v12 >= 1)
  {
    __int128 v18 = (void **)((char *)&v25 - v14);
    int64_t v19 = v12;
    do
    {
      *v18++ = malloc(v17);
      --v19;
    }

    while (v19);
  }

  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  void block[2] = ____CFSortIndexesN_block_invoke;
  block[3] = &unk_18999CB10;
  block[6] = v10;
  block[7] = v13;
  void block[8] = a1;
  block[9] = v15;
  block[4] = a4;
  void block[5] = v12;
  dispatch_apply(v12, 0LL, block);
  if (v12 >= 0) {
    int64_t v20 = v12;
  }
  else {
    int64_t v20 = v12 + 1;
  }
  if (v12 - 1 >= 0) {
    int64_t v21 = v12 - 1;
  }
  else {
    int64_t v21 = v12;
  }
  if (v12 >= 1)
  {
    size_t v27 = v20 & 0xFFFFFFFFFFFFFFFELL;
    size_t v26 = v21 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v22 = (unint64_t)(v12 + 1) >> 1;
    int64_t v28 = v12 - 1;
    CFIndex v23 = &a1[8 * v10 * (v12 - 1)];
    do
    {
      v30[0] = MEMORY[0x1895F87A8];
      v30[1] = 0x40000000LL;
      v30[2] = ____CFSortIndexesN_block_invoke_2;
      v30[3] = &unk_18999CB38;
      v30[6] = v10;
      v30[7] = v12;
      v30[8] = v13;
      v30[9] = v15;
      void v30[4] = a4;
      v30[5] = a1;
      dispatch_apply(v27, 0LL, v30);
      if ((v12 & 1) != 0) {
        memmove((void *)v15[v28], v23, 8 * v13);
      }
      v29[0] = MEMORY[0x1895F87A8];
      v29[1] = 0x40000000LL;
      v29[2] = ____CFSortIndexesN_block_invoke_3;
      uint64_t v29[3] = &unk_18999CB60;
      _BYTE v29[6] = v12;
      v29[7] = v13;
      v29[8] = v10;
      v29[9] = a1;
      v29[5] = v15;
      v29[4] = a4;
      dispatch_apply(v26, 0LL, v29);
      memmove(a1, *v15, v17);
      if ((v12 & 1) == 0) {
        memmove(v23, v15[v28], 8 * v13);
      }
      --v22;
    }

    while (v22);
    do
    {
      unint64_t v24 = (void *)*v15++;
      free(v24);
      --v12;
    }

    while (v12);
  }

uint64_t __CFSimpleMergeSort(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 2)
  {
    unint64_t v5 = a2;
    uint64_t v6 = (void *)result;
    if (a2 == 3)
    {
      uint64_t v9 = *(void *)result;
      uint64_t v10 = *(void *)(result + 8);
      uint64_t v11 = *(void *)(result + 16);
      uint64_t v12 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a4 + 16))(a4, *(void *)result, v10);
      if (v12 <= 0) {
        uint64_t v13 = v10;
      }
      else {
        uint64_t v13 = v9;
      }
      if (v12 > 0) {
        uint64_t v9 = v10;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v13, v11);
      if (result < 1)
      {
        uint64_t v14 = v13;
        uint64_t v13 = v11;
      }

      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v9, v11);
        if (result <= 0) {
          uint64_t v14 = v11;
        }
        else {
          uint64_t v14 = v9;
        }
        if (result > 0) {
          uint64_t v9 = v11;
        }
      }

      void *v6 = v9;
      v6[1] = v14;
      void v6[2] = v13;
    }

    else if (a2 == 2)
    {
      uint64_t v7 = *(void *)result;
      uint64_t v8 = *(void *)(result + 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a4 + 16))(a4, *(void *)result, v8);
      if (result >= 1)
      {
        void *v6 = v8;
        v6[1] = v7;
      }
    }

    else
    {
      unint64_t v16 = (unint64_t)a2 >> 1;
      __CFSimpleMergeSort(result, (unint64_t)a2 >> 1, a3, a4);
      uint64_t result = __CFSimpleMergeSort(&v6[v16], v5 - (v5 >> 1), a3, a4);
      if ((uint64_t)(v5 - (v5 >> 1)) >= 1)
      {
        if (v5 < 0x11
          || (uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(a4 + 16))(a4, v6[v16 - 1], v6[v16]),
              result >= 1))
        {
          int64_t v17 = 0LL;
          unint64_t v18 = 0LL;
          int64_t v19 = v5 >> 1;
          while (v19 < (uint64_t)v5)
          {
            uint64_t v20 = v6[v18];
            uint64_t v21 = v6[v19];
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v20, v21);
            if (result <= 0) {
              uint64_t v22 = v20;
            }
            else {
              uint64_t v22 = v21;
            }
            if (result > 0) {
              ++v19;
            }
            if (result < 1) {
              ++v18;
            }
            *(void *)(a3 + 8 * v17++) = v22;
            if (v18 >= v16)
            {
              do
              {
                v6[v17 - 1] = *(void *)(a3 - 8 + 8 * v17);
                --v17;
              }

              while (v17);
              return result;
            }
          }

          if (v17 < (uint64_t)v5)
          {
            uint64_t v23 = v16;
            do
              v6[--v5] = v6[--v23];
            while (v17 < (uint64_t)v5);
          }

          for (; v17; --v17)
            v6[v17 - 1] = *(void *)(a3 - 8 + 8 * v17);
        }
      }
    }
  }

  return result;
}

void CFQSortArray( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v42[8] = *MEMORY[0x1895F89C0];
  if (a2 < 2 || a3 < 1) {
    return;
  }
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to qsort array - count: %ld elementSize: %ld product overflows",  a3,  a4,  a5,  a6,  a7,  a8,  a2);
    uint64_t v39 = (void *)&unk_18C539000;
    uint64_t v40 = "qsort - count/elementSize overflow";
LABEL_23:
    v39[334] = v40;
    __break(1u);
    goto LABEL_24;
  }

  uint64_t v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to qsort array - list: %lu count: %ld elementSize: %ld - array access overflows",  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)a1);
    uint64_t v39 = (void *)&unk_18C539000;
    uint64_t v40 = "qsort - array access overflow";
    goto LABEL_23;
  }

  MEMORY[0x1895F8858](a1, a2);
  uint64_t v15 = (char *)&v42[-1] - v14;
  unint64_t v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    uint64_t v17 = (uint64_t)malloc(8 * a2);
    unint64_t v16 = (char *)v17;
    if (!v17) {
LABEL_24:
    }
      CFQSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }

  v42[0] = MEMORY[0x1895F87A8];
  v42[1] = 0x40000000LL;
  v42[2] = __CFQSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_12_1;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 0, (uint64_t)v42);
  MEMORY[0x1895F8858](v25, v26);
  CFIndex v34 = (char *)&v42[-1] - v33;
  uint64_t v35 = (char *)&v42[-1] - v33;
  if (v36 < a2) {
    uint64_t v35 = (char *)malloc(a3 * a2);
  }
  uint64_t v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to qsort array - list: %lu count: %ld elementSize: %ld array - store overflows",  v27,  v28,  v29,  v30,  v31,  v32,  (uint64_t)a1);
    uint64_t v39 = &unk_18C539000;
    uint64_t v40 = "qsort - array storage overflow";
    goto LABEL_23;
  }

  uint64_t v37 = 0LL;
  CFRange v38 = v35;
  do
  {
    if (a3 == 8) {
      *(void *)&v35[8 * v37] = a1[*(void *)&v16[8 * v37]];
    }
    else {
      memmove(v38, (char *)a1 + *(void *)&v16[8 * v37] * a3, a3);
    }
    ++v37;
    v38 += a3;
  }

  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35) {
    free(v35);
  }
  if (v15 != v16) {
    free(v16);
  }
}

uint64_t __CFQSortArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 32))( *(void *)(a1 + 40) + *(void *)(a1 + 48) * a2,  *(void *)(a1 + 40) + *(void *)(a1 + 48) * a3,  *(void *)(a1 + 56));
}

void CFMergeSortArray( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v42[8] = *MEMORY[0x1895F89C0];
  if (a2 < 2 || a3 < 1) {
    return;
  }
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to mergesort array - count: %ld elementSize: %ld overflows",  a3,  a4,  a5,  a6,  a7,  a8,  a2);
    uint64_t v39 = (void *)&unk_18C539000;
    uint64_t v40 = "merge sort - count/elementSize overflow";
LABEL_23:
    v39[334] = v40;
    __break(1u);
    goto LABEL_24;
  }

  uint64_t v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array access overflows",  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)a1);
    uint64_t v39 = (void *)&unk_18C539000;
    uint64_t v40 = "merge sort - array access overflow";
    goto LABEL_23;
  }

  MEMORY[0x1895F8858](a1, a2);
  uint64_t v15 = (char *)&v42[-1] - v14;
  unint64_t v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    uint64_t v17 = (uint64_t)malloc(8 * a2);
    unint64_t v16 = (char *)v17;
    if (!v17) {
LABEL_24:
    }
      CFMergeSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }

  v42[0] = MEMORY[0x1895F87A8];
  v42[1] = 0x40000000LL;
  v42[2] = __CFMergeSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_25;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 16, (uint64_t)v42);
  MEMORY[0x1895F8858](v25, v26);
  CFIndex v34 = (char *)&v42[-1] - v33;
  uint64_t v35 = (char *)&v42[-1] - v33;
  if (v36 < a2) {
    uint64_t v35 = (char *)malloc(a3 * a2);
  }
  uint64_t v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    uint64_t v17 = CFLog( 3LL,  (uint64_t)@"Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array store overflows",  v27,  v28,  v29,  v30,  v31,  v32,  (uint64_t)a1);
    uint64_t v39 = &unk_18C539000;
    uint64_t v40 = "merge sort - overflow array storage";
    goto LABEL_23;
  }

  uint64_t v37 = 0LL;
  CFRange v38 = v35;
  do
  {
    if (a3 == 8) {
      *(void *)&v35[8 * v37] = a1[*(void *)&v16[8 * v37]];
    }
    else {
      memmove(v38, (char *)a1 + *(void *)&v16[8 * v37] * a3, a3);
    }
    ++v37;
    v38 += a3;
  }

  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35) {
    free(v35);
  }
  if (v15 != v16) {
    free(v16);
  }
}

uint64_t __CFMergeSortArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 32))( *(void *)(a1 + 40) + *(void *)(a1 + 48) * a2,  *(void *)(a1 + 40) + *(void *)(a1 + 48) * a3,  *(void *)(a1 + 56));
}

uint64_t *__CFSortIndexesNMerge( uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a3;
  uint64_t v13 = result;
  if (a4 + a2 >= 17)
  {
    uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, result[a2 - 1], *a3);
    if ((uint64_t)result <= 0)
    {
      if (a6) {
        uint64_t v30 = v11;
      }
      else {
        uint64_t v30 = v13;
      }
      if (a6) {
        uint64_t v31 = a4;
      }
      else {
        uint64_t v31 = a2;
      }
      return (uint64_t *)memmove(a5, v30, 8 * v31);
    }
  }

  if (!a6)
  {
    if (a2 < 1) {
      return result;
    }
    uint64_t v22 = &v13[a2];
    uint64_t v23 = &v11[a4];
    uint64_t v24 = &a5[a2];
    while (1)
    {
      if (v23 <= v11)
      {
        uint64_t v28 = *v13++;
        uint64_t v27 = v28;
      }

      else
      {
        if (v22 > v13)
        {
          uint64_t v25 = *v13;
          uint64_t v26 = *v11;
          uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v13, *v11);
          if ((uint64_t)result <= 0)
          {
            *a5 = v25;
            ++v13;
          }

          else
          {
            *a5 = v26;
            ++v11;
          }

          goto LABEL_25;
        }

        uint64_t v29 = *v11++;
        uint64_t v27 = v29;
      }

      *a5 = v27;
LABEL_25:
      if (++a5 >= v24) {
        return result;
      }
    }
  }

  if (a4 >= 1)
  {
    uint64_t v14 = &a5[a4];
    uint64_t v15 = &v11[a4 - 1];
    unint64_t v16 = &v13[a2 - 1];
    do
    {
      if (v15 >= v11)
      {
        if (v16 >= v13)
        {
          uint64_t v20 = *v16;
          uint64_t v21 = *v15;
          uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v16, *v15);
          if ((uint64_t)result <= 0)
          {
            *(v14 - 1) = v21;
            --v15;
          }

          else
          {
            *(v14 - 1) = v20;
            --v16;
          }

          goto LABEL_11;
        }

        uint64_t v19 = *--v15;
        uint64_t v17 = v19;
      }

      else
      {
        uint64_t v18 = *--v16;
        uint64_t v17 = v18;
      }

      *(v14 - 1) = v17;
LABEL_11:
      --v14;
    }

    while (v14 > a5);
  }

  return result;
}

uint64_t __CFStorageGetCapacity(uint64_t a1)
{
  uint64_t NodeCapacity = __CFStorageGetNodeCapacity(a1 + 144);
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1) {
    return NodeCapacity / *(void *)(a1 + 16);
  }
  else {
    return NodeCapacity >> v3;
  }
}

uint64_t __CFStorageGetNodeCapacity(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = 0LL;
    while (!*(_BYTE *)(v1 + 13))
    {
      uint64_t NodeCapacity = __CFStorageGetNodeCapacity(*(void *)(v1 + 16));
      uint64_t v4 = __CFStorageGetNodeCapacity(*(void *)(v1 + 24));
      uint64_t v1 = *(void *)(v1 + 32);
      v2 += NodeCapacity + v4;
      if (!v1) {
        goto LABEL_7;
      }
    }

    uint64_t v5 = *(void *)(v1 + 16);
  }

  else
  {
    uint64_t v2 = 0LL;
LABEL_7:
    uint64_t v5 = 0LL;
  }

  return v5 + v2;
}

uint64_t __CFStorageGetValueSize(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t __CFStorageEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 144);
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1) {
    uint64_t v4 = v2 / *(void *)(a1 + 16);
  }
  else {
    uint64_t v4 = v2 >> v3;
  }
  uint64_t v5 = *(void *)(a2 + 144);
  int v6 = *(_DWORD *)(a2 + 24);
  if (v6 == -1) {
    uint64_t v7 = v5 / *(void *)(a2 + 16);
  }
  else {
    uint64_t v7 = v5 >> v6;
  }
  if (v4 != v7) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (v8 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  unsigned int ValueAtIndex = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  while (v13 < v4)
  {
    if (v13 >= v11 + v12)
    {
      unsigned int ValueAtIndex = (char *)CFStorageGetValueAtIndex(a1, v13, &v25);
      uint64_t v10 = v23;
      uint64_t v9 = v24;
    }

    uint64_t v16 = v9 + v10;
    if (v13 >= v9 + v10)
    {
      uint64_t v15 = (char *)CFStorageGetValueAtIndex(a2, v13, &v23);
      uint64_t v10 = v23;
      uint64_t v9 = v24;
      uint64_t v16 = v24 + v23;
    }

    uint64_t v12 = v25;
    uint64_t v11 = v26;
    if (v16 >= v26 + v25) {
      uint64_t v17 = v26 + v25;
    }
    else {
      uint64_t v17 = v16;
    }
    size_t v18 = (v17 - v13) * v8;
    int v19 = memcmp(ValueAtIndex, v15, v18);
    ValueAtIndex += v18;
    v15 += v18;
    uint64_t v13 = v17;
    if (v19) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t __CFStorageHash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1) {
    return v1 / *(void *)(a1 + 16);
  }
  else {
    return v1 >> v2;
  }
}

__CFString *__CFStorageCopyDescription(uint64_t a1)
{
  int v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0LL);
  uint64_t v4 = *(void *)(a1 + 144);
  int v5 = *(_DWORD *)(a1 + 24);
  if (v5 == -1)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v6 = v4 / v8;
    uint64_t v7 = __CFStorageGetNodeCapacity(a1 + 144) / v8;
  }

  else
  {
    uint64_t v6 = v4 >> v5;
    uint64_t v7 = __CFStorageGetNodeCapacity(a1 + 144) >> v5;
  }

  CFStringAppendFormat(Mutable, 0LL, @"<CFStorage %p [%p]>[count = %lu, capacity = %lu]\n", a1, v2, v6, v7);
  __CFStorageDescribeNode((uint64_t *)(a1 + 144), Mutable, 0LL);
  return Mutable;
}

uint64_t CFStorageCreate( const __CFAllocator *a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x1AuLL, 168LL, 0LL, a5, a6, a7, a8);
  uint64_t v10 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0;
    *(void *)(Instance + 16) = a2;
    BOOL v11 = (a2 & (a2 - 1)) != 0 || a2 <= 0;
    int v12 = __clz(__rbit64(a2));
    if (v11) {
      int v12 = -1;
    }
    *(_DWORD *)(Instance + 24) = v12;
    *(void *)(Instance + 32) = 850045857LL;
    *(_OWORD *)(Instance + 40) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(void *)(Instance + 8_Block_object_dispose(va, 8) = 0LL;
    *(void *)(Instance + 136) = 12288LL;
    if (a2 && 12288 % a2) {
      *(void *)(Instance + 136) = 12288 - 12288 % a2;
    }
    *(_BYTE *)(Instance + 157) = 1;
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return v10;
}

uint64_t CFStorageGetTypeID()
{
  return 26LL;
}

uint64_t CFStorageCreateWithSubrange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v58[3] = *MEMORY[0x1895F89C0];
  uint64_t v6 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v13 = CFStorageCreate(v6, *(void *)(a1 + 16), v7, v8, v9, v10, v11, v12);
  if (a3 >= 1)
  {
    int v14 = *(_DWORD *)(a1 + 24);
    if (v14 == -1)
    {
      uint64_t v17 = *(void *)(a1 + 16);
      uint64_t v15 = v17 * a2;
      uint64_t v16 = v17 * a3;
    }

    else
    {
      uint64_t v15 = a2 << v14;
      uint64_t v16 = a3 << v14;
    }

    uint64_t v18 = a1 + 144;
    if (*(_BYTE *)(a1 + 157))
    {
      uint64_t v19 = 0LL;
    }

    else
    {
      uint64_t v19 = 0LL;
      uint64_t v20 = v15;
      do
      {
        uint64_t v21 = *(uint64_t **)(v18 + 16);
        uint64_t v22 = *(void **)(v18 + 24);
        v58[0] = v21;
        v58[1] = v22;
        uint64_t v23 = *(void **)(v18 + 32);
        v58[2] = v23;
        if (v22) {
          uint64_t v22 = (void *)*v22;
        }
        if (v23) {
          uint64_t v23 = (void *)*v23;
        }
        uint64_t v24 = *v21;
        v57[0] = 0LL;
        v57[1] = v24;
        uint64_t v25 = (char *)v22 + v24;
        v57[2] = (char *)v22 + v24;
        uint64_t v26 = v20 & ~(v20 >> 63);
        uint64_t v27 = v20 + v16;
        if (v24 >= v20 + v16) {
          uint64_t v28 = v20 + v16;
        }
        else {
          uint64_t v28 = v24;
        }
        BOOL v29 = __OFSUB__(v28, v26);
        uint64_t v30 = v28 - v26;
        if ((v30 < 0) ^ v29 | (v30 == 0)) {
          uint64_t v30 = 0LL;
        }
        if (v24 <= v20) {
          uint64_t v31 = v20;
        }
        else {
          uint64_t v31 = v24;
        }
        else {
          uint64_t v32 = v25;
        }
        BOOL v29 = __OFSUB__(v32, v31);
        uint64_t v33 = (uint64_t)&v32[-v31];
        if ((v33 < 0) ^ v29 | (v33 == 0)) {
          uint64_t v33 = 0LL;
        }
        else {
          uint64_t v34 = (uint64_t)v25;
        }
        uint64_t v35 = &v25[(void)v23];
        BOOL v36 = (uint64_t)v35 <= v34;
        uint64_t v37 = &v35[-v34];
        if (v36) {
          uint64_t v37 = 0LL;
        }
        uint64_t v38 = v33 != 0;
        if (v30) {
          ++v38;
        }
        if (v37) {
          uint64_t v39 = v38 + 1;
        }
        else {
          uint64_t v39 = v38;
        }
        if (v39 != 1) {
          break;
        }
        uint64_t v40 = v33 ? 1LL : 2LL;
        uint64_t v41 = v30 ? 0LL : v40;
        uint64_t v18 = v58[v41];
        uint64_t v42 = v57[v41];
        v20 -= v42;
        v19 += v42;
      }

      while (!*(_BYTE *)(v18 + 13));
    }

    if (*(_BYTE *)(v18 + 13))
    {
      CFStorageInsertValues(v13, 0LL, a3);
      uint64_t v43 = *(void *)(v18 + 24);
      if (v43) {
        CFStorageReplaceValues((char *)v13, 0LL, a3, (char *)(v43 + v15 - v19));
      }
    }

    else
    {
      uint64_t v44 = 0LL;
      uint64_t v45 = *(void *)v18;
      *(void *)(v13 + 160) = 0LL;
      *(_BYTE *)(v13 + 157) = 0;
      *(void *)(v13 + 144) = v45;
      *(void *)(v13 + 16_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v13 + 176) = 0LL;
      do
      {
        uint64_t v46 = *(void *)(v18 + 16 + 8 * v44);
        if (!v46) {
          break;
        }
        __int128 v47 = (unsigned int *)(v46 + 8);
        int v48 = *(_DWORD *)(v46 + 8);
        *(_BYTE *)(v46 + 12) = 1;
        if (v48)
        {
          do
            unsigned int v49 = __ldxr(v47);
          while (__stxr(v49 + 1, v47));
        }

        *(void *)(v13 + 160 + 8 * v44++) = v46;
      }

      while (v44 != 3);
      int v50 = *(_DWORD *)(v13 + 24);
      if (v50 == -1)
      {
        uint64_t v53 = *(void *)(v13 + 16);
        uint64_t v51 = v19 / v53;
        uint64_t v52 = v45 / v53;
      }

      else
      {
        uint64_t v51 = v19 >> v50;
        uint64_t v52 = v45 >> v50;
      }

      uint64_t v54 = a2 - v51;
      uint64_t v55 = v51 - a2 - a3;
      if (v55 + v52 >= 1) {
        CFStorageDeleteValues(v13, -v55, v55 + v52);
      }
      if (v54 >= 1) {
        CFStorageDeleteValues(v13, 0LL, v54);
      }
    }
  }

  return v13;
}

void CFStorageInsertValues(uint64_t cf, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(cf + 24);
  if (v4 == -1)
  {
    uint64_t v7 = *(void *)(cf + 16);
    uint64_t v5 = v7 * a3;
    uint64_t v6 = v7 * a2;
  }

  else
  {
    uint64_t v5 = a3 << v4;
    uint64_t v6 = a2 << v4;
  }

  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)cf);
  if (v5 >= 1)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)(cf + 136);
    do
    {
      if (v5 >= v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v5;
      }
      __CFStorageInsertUnfrozen(v9, cf, cf + 144, v6, v11, v6);
      if (v12)
      {
        uint64_t v13 = v12;
        Node = __CFStorageCreateNode(v9, cf, *(_BYTE *)(cf + 157), *(void *)(cf + 144));
        uint64_t v15 = *(void *)(cf + 176);
        *((_OWORD *)Node + 1) = *(_OWORD *)(cf + 160);
        *((void *)Node + 4) = v15;
        if (*(_BYTE *)(cf + 157))
        {
          os_unfair_lock_lock_with_options();
          *(void *)(cf + 104) = 0LL;
          *(void *)(cf + 112) = 0LL;
          *(void *)(cf + 120) = 0LL;
          os_unfair_lock_unlock((os_unfair_lock_t)(cf + 128));
          *(_BYTE *)(cf + 157) = 0;
        }

        *(void *)(cf + 160) = Node;
        *(void *)(cf + 16_Block_object_dispose(va, 8) = v13;
        *(void *)(cf + 176) = 0LL;
        *(void *)(cf + 144) = *v13 + *(void *)Node;
      }

      v6 += v11;
      BOOL v16 = v5 <= v11;
      v5 -= v11;
    }

    while (!v16);
  }

char *CFStorageReplaceValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  v42[1] = *MEMORY[0x1895F89C0];
  if (a3 >= 1)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    CFAllocatorRef v8 = (os_unfair_lock_s *)(result + 128);
    uint64_t v38 = (pthread_mutex_t *)(result + 32);
    uint64_t v39 = (uint64_t)(result + 144);
    do
    {
      os_unfair_lock_lock_with_options();
      uint64_t v10 = *((void *)v7 + 13);
      uint64_t v9 = *((void *)v7 + 14);
      uint64_t v11 = *((void *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10 || *(_BYTE *)(v10 + 12)) {
        goto LABEL_5;
      }
      if (!*(void *)(v10 + 24))
      {
        uint64_t v21 = (malloc_zone_t *)CFGetAllocator(v7);
        uint64_t v22 = *(void *)v10;
        uint64_t v23 = *MEMORY[0x1895FD590];
        else {
          uint64_t v24 = v23 + 1;
        }
        if (v22 <= v24 >> 1)
        {
          uint64_t v33 = v22 + 63;
          BOOL v32 = v22 < -63;
          uint64_t v34 = v22 + 126;
          if (!v32) {
            uint64_t v34 = v33;
          }
          int64_t v26 = v34 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v25 = (v22 + v23 - 1) & -(int)v23;
          if (*((void *)v7 + 17) >= v25) {
            int64_t v26 = v25;
          }
          else {
            int64_t v26 = *((void *)v7 + 17);
          }
        }

        if (v26 > *(void *)(v10 + 16))
        {
          pthread_mutex_lock(v38);
          if (v26 > *(void *)(v10 + 16))
          {
            *(void *)(v10 + 24) = __CFSafelyReallocateWithAllocator(v21, *(void **)(v10 + 24), v26, 0LL, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v10 + 16) = v26;
          }

          pthread_mutex_unlock(v38);
        }
      }

      if ((uint64_t v35 = a2 - v9, a2 >= v9)
        && v11 + v9 > a2
        && ((uint64_t v28 = *((unsigned int *)v7 + 6), (_DWORD)v28 != -1)
          ? (uint64_t v36 = v35 << v28)
          : (uint64_t v36 = *((void *)v7 + 2) * v35),
            (uint64_t v37 = *(void *)(v10 + 24)) != 0))
      {
        Byte = (void *)(v37 + v36);
      }

      else
      {
LABEL_5:
        int v12 = *((_DWORD *)v7 + 6);
        if (v12 == -1) {
          uint64_t v13 = *((void *)v7 + 2) * a2;
        }
        else {
          uint64_t v13 = a2 << v12;
        }
        Byte = (void *)__CFStorageFindByte(v7, v39, v13, 0LL, v42, &v40, 1);
        uint64_t v15 = v42[0];
        uint64_t v16 = v40;
        if (v42[0])
        {
          uint64_t v17 = *(void *)v42[0];
          int v18 = *((_DWORD *)v7 + 6);
          if (v18 == -1)
          {
            uint64_t v27 = *((void *)v7 + 2);
            uint64_t v19 = v40 / v27;
            uint64_t v20 = v17 / v27;
          }

          else
          {
            uint64_t v19 = v40 >> v18;
            uint64_t v20 = v17 >> v18;
          }
        }

        else
        {
          uint64_t v19 = 0LL;
          uint64_t v20 = 0LL;
        }

        os_unfair_lock_lock_with_options();
        *((void *)v7 + 13) = v15;
        *((void *)v7 + 14) = v19;
        *((void *)v7 + 15) = v20;
        os_unfair_lock_unlock(v8);
        uint64_t v28 = *((unsigned int *)v7 + 6);
        if ((_DWORD)v28 == -1)
        {
          uint64_t v29 = *((void *)v7 + 2);
          uint64_t v9 = v16 / v29;
          uint64_t v11 = v41 / v29;
        }

        else
        {
          uint64_t v9 = v16 >> v28;
          uint64_t v11 = v41 >> v28;
        }
      }

      if (v5 >= v11 - a2 + v9) {
        uint64_t v30 = v11 - a2 + v9;
      }
      else {
        uint64_t v30 = v5;
      }
      if (v28 == 0xFFFFFFFFLL) {
        size_t v31 = *((void *)v7 + 2) * v30;
      }
      else {
        size_t v31 = v30 << v28;
      }
      uint64_t result = (char *)memmove(Byte, a4, v31);
      a4 += v31;
      a2 += v30;
      BOOL v32 = v5 <= v30;
      v5 -= v30;
    }

    while (!v32);
  }

  return result;
}

void CFStorageDeleteValues(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (malloc_zone_t *)CFGetAllocator((CFTypeRef)a1);
  int v7 = *(_DWORD *)(a1 + 24);
  if (v7 == -1)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    uint64_t v8 = v10 * a2;
    uint64_t v9 = v10 * a3;
  }

  else
  {
    uint64_t v8 = a2 << v7;
    uint64_t v9 = a3 << v7;
  }

  os_unfair_lock_lock_with_options();
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 120) = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 128));
  uint64_t v11 = __CFStorageDeleteUnfrozen(v6, a1, a1 + 144, v8, v9, 1);
  if (v11)
  {
    uint64_t v12 = v11;
    if (v11 != a1 + 144)
    {
      uint64_t v13 = *(void *)v11;
      char v14 = *(_BYTE *)(v11 + 13);
      *(void *)(a1 + 160) = 0LL;
      uint64_t v15 = (int64_t *)(a1 + 160);
      *(void *)(a1 + 144) = v13;
      *(_BYTE *)(a1 + 157) = v14;
      *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 176) = 0LL;
      if (*(_BYTE *)(v11 + 13))
      {
        if (*(_BYTE *)(v11 + 12))
        {
          uint64_t v16 = *(const void **)(v11 + 24);
          if (v16)
          {
            uint64_t v17 = *MEMORY[0x1895FD590];
            else {
              uint64_t v18 = v17 + 1;
            }
            if (v13 <= v18 >> 1)
            {
              uint64_t v31 = v13 + 63;
              BOOL v30 = v13 < -63;
              uint64_t v32 = v13 + 126;
              if (!v30) {
                uint64_t v32 = v31;
              }
              int64_t v20 = v32 & 0xFFFFFFFFFFFFFFC0LL;
            }

            else
            {
              int v19 = (v13 + v17 - 1) & -(int)v17;
              if (*(void *)(a1 + 136) >= v19) {
                int64_t v20 = v19;
              }
              else {
                int64_t v20 = *(void *)(a1 + 136);
              }
            }

            if (v20 > *v15)
            {
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
              if (v20 > *(void *)(a1 + 160))
              {
                *(void *)(a1 + 16_Block_object_dispose(va, 8) = __CFSafelyReallocateWithAllocator(v6, *(void **)(a1 + 168), v20, 0LL, 0LL);
                if (__CFOASafe) {
                  __CFSetLastAllocationEventName();
                }
                *uint64_t v15 = v20;
              }

              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
              uint64_t v16 = *(const void **)(v12 + 24);
            }

            memmove(*(void **)(a1 + 168), v16, *(void *)v12);
          }
        }

        else
        {
          *(void *)(a1 + 16_Block_object_dispose(va, 8) = *(void *)(v11 + 24);
          *(void *)(v11 + 16) = 0LL;
          *(void *)(v11 + 24) = 0LL;
          *(void *)(v11 + 32) = 0LL;
        }
      }

      else
      {
        int64_t v21 = *(void *)(v11 + 16);
        uint64_t v22 = (unsigned int *)(v21 + 8);
        if (*(_DWORD *)(v21 + 8))
        {
          do
            unsigned int v23 = __ldxr(v22);
          while (__stxr(v23 + 1, v22));
        }

        *uint64_t v15 = v21;
        uint64_t v24 = *(void *)(v11 + 24);
        int v25 = (unsigned int *)(v24 + 8);
        if (*(_DWORD *)(v24 + 8))
        {
          do
            unsigned int v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }

        *(void *)(a1 + 16_Block_object_dispose(va, 8) = v24;
        uint64_t v27 = *(void *)(v11 + 32);
        if (v27)
        {
          uint64_t v28 = (unsigned int *)(v27 + 8);
          if (*(_DWORD *)(v27 + 8))
          {
            do
              unsigned int v29 = __ldxr(v28);
            while (__stxr(v29 + 1, v28));
          }

          *(void *)(a1 + 176) = v27;
        }
      }
    }

    uint64_t v33 = (unsigned int *)(v12 + 8);
    if (*(_DWORD *)(v12 + 8))
    {
      do
      {
        unsigned int v34 = __ldxr(v33);
        unsigned int v35 = v34 - 1;
      }

      while (__stxr(v35, v33));
      if (!v35) {
        __CFStorageDeallocateNode((const void *)a1, v12);
      }
    }
  }

  else
  {
    __CFStorageClearRootNode(a1);
  }

uint64_t CFStorageGetCount(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1) {
    return v1 / *(void *)(a1 + 16);
  }
  else {
    return v1 >> v2;
  }
}

uint64_t CFStorageGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v40[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  uint64_t v7 = *(void *)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (v7 && !*(_BYTE *)(v7 + 12))
  {
    if (!*(void *)(v7 + 24))
    {
      int v19 = (malloc_zone_t *)CFGetAllocator((CFTypeRef)a1);
      uint64_t v20 = *(void *)v7;
      uint64_t v21 = *MEMORY[0x1895FD590];
      else {
        uint64_t v22 = v21 + 1;
      }
      if (v20 <= v22 >> 1)
      {
        uint64_t v32 = v20 + 63;
        BOOL v31 = v20 < -63;
        uint64_t v33 = v20 + 126;
        if (!v31) {
          uint64_t v33 = v32;
        }
        int64_t v24 = v33 & 0xFFFFFFFFFFFFFFC0LL;
      }

      else
      {
        int v23 = (v20 + v21 - 1) & -(int)v21;
        if (*(void *)(a1 + 136) >= v23) {
          int64_t v24 = v23;
        }
        else {
          int64_t v24 = *(void *)(a1 + 136);
        }
      }

      if (v24 > *(void *)(v7 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v24 > *(void *)(v7 + 16))
        {
          *(void *)(v7 + 24) = __CFSafelyReallocateWithAllocator(v19, *(void **)(v7 + 24), v24, 0LL, 0LL);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(v7 + 16) = v24;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }

    uint64_t v34 = a2 - v8;
    if (a2 >= v8 && v9 + v8 > a2)
    {
      if (a3)
      {
        *a3 = v8;
        a3[1] = v9;
      }

      uint64_t v35 = *(void *)(v7 + 24);
      int v36 = *(_DWORD *)(a1 + 24);
      if (v36 == -1)
      {
        uint64_t v37 = *(void *)(a1 + 16) * v34;
        if (!v35) {
          goto LABEL_3;
        }
      }

      else
      {
        uint64_t v37 = v34 << v36;
        if (!v35) {
          goto LABEL_3;
        }
      }

      return v35 + v37;
    }
  }

uint64_t CFStorageGetConstValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v40[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  uint64_t v7 = *(void *)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (!v7) {
    goto LABEL_29;
  }
  if (!*(void *)(v7 + 24))
  {
    int v10 = (malloc_zone_t *)CFGetAllocator((CFTypeRef)a1);
    uint64_t v11 = *(void *)v7;
    uint64_t v12 = *MEMORY[0x1895FD590];
    else {
      uint64_t v13 = v12 + 1;
    }
    if (v11 <= v13 >> 1)
    {
      uint64_t v16 = v11 + 63;
      BOOL v19 = v11 < -63;
      uint64_t v17 = v11 + 126;
      if (!v19) {
        uint64_t v17 = v16;
      }
      int64_t v15 = v17 & 0xFFFFFFFFFFFFFFC0LL;
    }

    else
    {
      int v14 = (v11 + v12 - 1) & -(int)v12;
      if (*(void *)(a1 + 136) >= v14) {
        int64_t v15 = v14;
      }
      else {
        int64_t v15 = *(void *)(a1 + 136);
      }
    }

    if (v15 > *(void *)(v7 + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
      if (v15 > *(void *)(v7 + 16))
      {
        *(void *)(v7 + 24) = __CFSafelyReallocateWithAllocator(v10, *(void **)(v7 + 24), v15, 0LL, 0LL);
        if (__CFOASafe) {
          __CFSetLastAllocationEventName();
        }
        *(void *)(v7 + 16) = v15;
      }

      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    }
  }

  uint64_t v18 = a2 - v8;
  BOOL v19 = a2 < v8 || v9 + v8 <= a2;
  if (v19) {
    goto LABEL_29;
  }
  if (a3)
  {
    *a3 = v8;
    a3[1] = v9;
  }

  uint64_t v20 = *(void *)(v7 + 24);
  int v21 = *(_DWORD *)(a1 + 24);
  if (v21 == -1)
  {
    uint64_t v22 = *(void *)(a1 + 16) * v18;
    if (v20) {
      return v20 + v22;
    }
LABEL_29:
    int v24 = *(_DWORD *)(a1 + 24);
    if (v24 == -1) {
      uint64_t v25 = *(void *)(a1 + 16) * a2;
    }
    else {
      uint64_t v25 = a2 << v24;
    }
    uint64_t Byte = __CFStorageFindByte((void *)a1, a1 + 144, v25, 0LL, v40, &v38, 0);
    uint64_t v26 = v40[0];
    uint64_t v27 = v38;
    if (v40[0])
    {
      uint64_t v28 = *(void *)v40[0];
      int v29 = *(_DWORD *)(a1 + 24);
      if (v29 == -1)
      {
        uint64_t v32 = *(void *)(a1 + 16);
        uint64_t v30 = v38 / v32;
        uint64_t v31 = v28 / v32;
      }

      else
      {
        uint64_t v30 = v38 >> v29;
        uint64_t v31 = v28 >> v29;
      }
    }

    else
    {
      uint64_t v30 = 0LL;
      uint64_t v31 = 0LL;
    }

    os_unfair_lock_lock_with_options();
    *(void *)(a1 + 104) = v26;
    *(void *)(a1 + 112) = v30;
    *(void *)(a1 + 120) = v31;
    os_unfair_lock_unlock(v6);
    int v33 = *(_DWORD *)(a1 + 24);
    if (v33 == -1)
    {
      uint64_t v37 = *(void *)(a1 + 16);
      uint64_t v34 = v27 / v37;
      uint64_t v35 = v39 / v37;
      if (!a3) {
        return Byte;
      }
    }

    else
    {
      uint64_t v34 = v27 >> v33;
      uint64_t v35 = v39 >> v33;
      if (!a3) {
        return Byte;
      }
    }

    *a3 = v34;
    a3[1] = v35;
    return Byte;
  }

  uint64_t v22 = v18 << v21;
  if (!v20) {
    goto LABEL_29;
  }
  return v20 + v22;
}

uint64_t __CFStorageInsertUnfrozen( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(_BYTE *)(a3 + 13))
  {
    uint64_t v22 = a4 - 1;
    uint64_t v24 = a3 + 16;
    uint64_t v23 = *(void *)(a3 + 16);
    uint64_t v25 = *(void *)v23;
    if (*(void *)v23 < a4)
    {
      v22 -= v25;
      uint64_t v23 = *(void *)(a3 + 24);
      uint64_t v26 = v22 - *(void *)v23;
      if (v22 >= *(void *)v23)
      {
        uint64_t v23 = *(void *)(a3 + 32);
        uint64_t v32 = 2LL;
        uint64_t v22 = v26;
      }

      else
      {
        uint64_t v32 = 1LL;
      }
    }

    else
    {
      uint64_t v32 = 0LL;
    }

    int64_t v55 = v22 + 1;
    if (*(_BYTE *)(v23 + 12))
    {
      if (*(_DWORD *)(v23 + 8) != 1)
      {
        CFRange v56 = a1;
        inserted = __CFStorageInsertFrozen(a1, a2, v23, v55, a5, a6);
LABEL_49:
        int v59 = inserted;
        uint64_t v60 = v58;
        if ((_DWORD *)v23 != inserted)
        {
          uint64_t v61 = (unsigned int *)(v23 + 8);
          if (*(_DWORD *)(v23 + 8))
          {
            do
            {
              unsigned int v62 = __ldxr(v61);
              unsigned int v63 = v62 - 1;
            }

            while (__stxr(v63, v61));
            if (!v63) {
              __CFStorageDeallocateNode((const void *)a2, v23);
            }
          }

          *(void *)(v24 + 8 * v32) = v59;
        }

        if (v60)
        {
          if (*(void *)(a3 + 32))
          {
            Node = __CFStorageCreateNode(v56, a2, 0, 0LL);
            if (v32 == 1)
            {
              Node[2] = v60;
              Node[3] = *(void *)(a3 + 32);
            }

            else if (v32)
            {
              Node[2] = *(void *)(a3 + 32);
              Node[3] = v60;
            }

            else
            {
              Node[2] = *(void *)(a3 + 24);
              Node[3] = *(void *)(a3 + 32);
              *(void *)(a3 + 24) = v60;
            }

            *(void *)(a3 + 32) = 0LL;
            *(void *)a3 = **(void **)(a3 + 24) + **(void **)(a3 + 16);
            void *Node = *(void *)Node[3] + *(void *)Node[2];
            return a3;
          }

          if (v25 >= a4) {
            *(void *)(a3 + 32) = *(void *)(a3 + 24);
          }
          *(void *)(v24 + 8 * v32 + _Block_object_dispose(va, 8) = v60;
        }

        uint64_t v65 = *(void *)a3 + a5;
LABEL_65:
        *(void *)a3 = v65;
        return a3;
      }

      *(_BYTE *)(v23 + 12) = 0;
    }

    CFRange v56 = a1;
    inserted = (_DWORD *)__CFStorageInsertUnfrozen(a1, a2, v23, v55, a5, a6);
    goto LABEL_49;
  }

  uint64_t v12 = *(void *)a3;
  uint64_t v13 = *(void *)a3 + a5;
  uint64_t v14 = *(void *)(a2 + 136);
  if (v13 > v14)
  {
    uint64_t v15 = v12 - a4;
    if (!v15)
    {
      uint64_t v16 = __CFStorageCreateNode(a1, a2, 1, a5);
      uint64_t v17 = v16;
      if (v16)
      {
        uint64_t v18 = *(void *)v16;
        int v19 = *(_DWORD *)(a2 + 24);
        if (v19 == -1)
        {
          uint64_t v77 = *(void *)(a2 + 16);
          uint64_t v20 = a6 / v77;
          uint64_t v21 = v18 / v77;
        }

        else
        {
          uint64_t v20 = a6 >> v19;
          uint64_t v21 = v18 >> v19;
        }
      }

      else
      {
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
      }

      int v78 = (os_unfair_lock_s *)(a2 + 128);
      os_unfair_lock_lock_with_options();
      *(void *)(a2 + 104) = v17;
      goto LABEL_141;
    }

    if (a4)
    {
      uint64_t v33 = a5 + a4;
      if (a5 + a4 > v14)
      {
        uint64_t v35 = __CFStorageCreateNode(a1, a2, 1, v13 - v14);
        int v36 = v35;
        uint64_t v37 = *(void *)(a3 + 24);
        if (v37)
        {
          uint64_t v38 = *(void *)a3;
          uint64_t v39 = *(void *)(a2 + 136);
          uint64_t v40 = *(void *)a3 + a5 - v39;
          uint64_t v41 = (uint64_t *)MEMORY[0x1895FD590];
          uint64_t v42 = *MEMORY[0x1895FD590];
          else {
            uint64_t v43 = v42 + 1;
          }
          uint64_t v44 = (malloc_zone_t *)a1;
          if (v40 <= v43 >> 1)
          {
            uint64_t v80 = v40 + 63;
            BOOL v47 = v40 < -63;
            uint64_t v81 = v40 + 126;
            if (!v47) {
              uint64_t v81 = v80;
            }
            int64_t v46 = v81 & 0xFFFFFFFFFFFFFFC0LL;
          }

          else
          {
            int v45 = (v40 + v42 - 1) & -(int)v42;
            if (v39 >= v45) {
              int64_t v46 = v45;
            }
            else {
              int64_t v46 = *(void *)(a2 + 136);
            }
          }

          if (v46 > *((void *)v35 + 2))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v46 > *((void *)v36 + 2))
            {
              *((void *)v36 + 3) = __CFSafelyReallocateWithAllocator(v44, *((void **)v36 + 3), v46, 0LL, 0LL);
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              *((void *)v36 + 2) = v46;
            }

            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
            uint64_t v39 = *(void *)(a2 + 136);
            uint64_t v37 = *(void *)(a3 + 24);
            uint64_t v38 = *(void *)a3;
          }

          memmove((void *)(*((void *)v36 + 3) + a4 + a5 - v39), (const void *)(v37 + a4), v38 - a4);
          uint64_t v82 = *(void *)(a2 + 136);
          uint64_t v83 = *v41;
          if (*v41 >= 0) {
            uint64_t v84 = *v41;
          }
          else {
            uint64_t v84 = v83 + 1;
          }
          if (v82 <= v84 >> 1)
          {
            uint64_t v92 = v82 + 63;
            BOOL v47 = v82 < -63;
            uint64_t v93 = v82 + 126;
            if (!v47) {
              uint64_t v93 = v92;
            }
            int64_t v86 = v93 & 0xFFFFFFFFFFFFFFC0LL;
          }

          else
          {
            int v85 = (v82 + v83 - 1) & -(int)v83;
            if (v82 >= v85) {
              int64_t v86 = v85;
            }
            else {
              int64_t v86 = *(void *)(a2 + 136);
            }
          }

          if (v86 > *(void *)(a3 + 16))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v86 > *(void *)(a3 + 16))
            {
              *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocator(v44, *(void **)(a3 + 24), v86, 0LL, 0LL);
              if (__CFOASafe) {
                __CFSetLastAllocationEventName();
              }
              *(void *)(a3 + 16) = v86;
            }

            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          }
        }

        uint64_t v94 = a6 - a4;
        uint64_t v95 = *(void *)a3;
        int v96 = *(_DWORD *)(a2 + 24);
        if (v96 == -1)
        {
          uint64_t v99 = *(void *)(a2 + 16);
          uint64_t v97 = v94 / v99;
          uint64_t v98 = v95 / v99;
        }

        else
        {
          uint64_t v97 = v94 >> v96;
          uint64_t v98 = v95 >> v96;
        }

        os_unfair_lock_lock_with_options();
        *(void *)(a2 + 104) = a3;
        *(void *)(a2 + 112) = v97;
        *(void *)(a2 + 120) = v98;
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
        uint64_t v65 = *(void *)(a2 + 136);
        goto LABEL_65;
      }

      BOOL v68 = __CFStorageCreateNode(a1, a2, 1, v15);
      mach_port_t v69 = v68;
      uint64_t v70 = *(void *)(a3 + 24);
      if (v70)
      {
        int64_t v71 = *(void *)a3 - a4;
        unsigned int v72 = (uint64_t *)MEMORY[0x1895FD590];
        uint64_t v73 = *MEMORY[0x1895FD590];
        else {
          uint64_t v74 = v73 + 1;
        }
        if (v71 <= v74 >> 1)
        {
          int64_t v87 = v71 + 63;
          if (v71 < -63) {
            int64_t v87 = v71 + 126;
          }
          int64_t v76 = v87 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v75 = (v71 + v73 - 1) & -(int)v73;
          if (*(void *)(a2 + 136) >= v75) {
            int64_t v76 = v75;
          }
          else {
            int64_t v76 = *(void *)(a2 + 136);
          }
        }

        if (v76 > *((void *)v68 + 2))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v76 > *((void *)v69 + 2))
          {
            *((void *)v69 + 3) = __CFSafelyReallocateWithAllocator( (malloc_zone_t *)a1,  *((void **)v69 + 3),  v76,  0LL,  0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *((void *)v69 + 2) = v76;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          uint64_t v70 = *(void *)(a3 + 24);
          int64_t v71 = *(void *)a3 - a4;
        }

        memmove(*((void **)v69 + 3), (const void *)(v70 + a4), v71);
        uint64_t v88 = *v72;
        if (*v72 >= 0) {
          uint64_t v89 = *v72;
        }
        else {
          uint64_t v89 = v88 + 1;
        }
        if (v33 <= v89 >> 1)
        {
          uint64_t v100 = v33 + 63;
          if (v33 < -63) {
            uint64_t v100 = v33 + 126;
          }
          int64_t v91 = v100 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v90 = (v33 + v88 - 1) & -(int)v88;
          if (*(void *)(a2 + 136) >= v90) {
            int64_t v91 = v90;
          }
          else {
            int64_t v91 = *(void *)(a2 + 136);
          }
        }

        if (v91 > *(void *)(a3 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v91 > *(void *)(a3 + 16))
          {
            *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocator( (malloc_zone_t *)a1,  *(void **)(a3 + 24),  v91,  0LL,  0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(a3 + 16) = v91;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
      }

      *(void *)a3 = v33;
      uint64_t v101 = a6 - a4;
      int v102 = *(_DWORD *)(a2 + 24);
      if (v102 == -1)
      {
        uint64_t v103 = *(void *)(a2 + 16);
        uint64_t v20 = v101 / v103;
        uint64_t v21 = v33 / v103;
      }

      else
      {
        uint64_t v20 = v101 >> v102;
        uint64_t v21 = v33 >> v102;
      }
    }

    else
    {
      uint64_t v66 = __CFStorageCreateNode(a1, a2, 1, 0LL);
      *uint64_t v66 = *(void *)a3;
      v66[2] = *(void *)(a3 + 16);
      v66[3] = *(void *)(a3 + 24);
      *(void *)a3 = a5;
      *(void *)(a3 + 16) = 0LL;
      *(void *)(a3 + 24) = 0LL;
      int v67 = *(_DWORD *)(a2 + 24);
      if (v67 == -1)
      {
        uint64_t v79 = *(void *)(a2 + 16);
        uint64_t v20 = a6 / v79;
        uint64_t v21 = a5 / v79;
      }

      else
      {
        uint64_t v20 = a6 >> v67;
        uint64_t v21 = a5 >> v67;
      }
    }

    int v78 = (os_unfair_lock_s *)(a2 + 128);
    os_unfair_lock_lock_with_options();
    *(void *)(a2 + 104) = a3;
LABEL_141:
    *(void *)(a2 + 112) = v20;
    *(void *)(a2 + 120) = v21;
    os_unfair_lock_unlock(v78);
    return a3;
  }

  uint64_t v27 = *(void *)(a3 + 24);
  if (v27)
  {
    uint64_t v28 = *MEMORY[0x1895FD590];
    else {
      uint64_t v29 = v28 + 1;
    }
    if (v13 <= v29 >> 1)
    {
      uint64_t v48 = v13 + 63;
      BOOL v47 = v13 < -63;
      uint64_t v49 = v13 + 126;
      if (!v47) {
        uint64_t v49 = v48;
      }
      int64_t v31 = v49 & 0xFFFFFFFFFFFFFFC0LL;
    }

    else
    {
      int v30 = (v13 + v28 - 1) & -(int)v28;
      if (v14 >= v30) {
        int64_t v31 = v30;
      }
      else {
        int64_t v31 = *(void *)(a2 + 136);
      }
    }

    if (v31 > *(void *)(a3 + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
      if (v31 > *(void *)(a3 + 16))
      {
        *(void *)(a3 + 24) = __CFSafelyReallocateWithAllocator( (malloc_zone_t *)a1,  *(void **)(a3 + 24),  v31,  0LL,  0LL);
        if (__CFOASafe) {
          __CFSetLastAllocationEventName();
        }
        *(void *)(a3 + 16) = v31;
      }

      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
      uint64_t v27 = *(void *)(a3 + 24);
      uint64_t v12 = *(void *)a3;
    }

    memmove((void *)(v27 + a4 + a5), (const void *)(v27 + a4), v12 - a4);
    uint64_t v13 = *(void *)a3 + a5;
  }

  *(void *)a3 = v13;
  uint64_t v50 = a6 - a4;
  int v51 = *(_DWORD *)(a2 + 24);
  if (v51 == -1)
  {
    uint64_t v54 = *(void *)(a2 + 16);
    uint64_t v52 = v50 / v54;
    uint64_t v53 = v13 / v54;
  }

  else
  {
    uint64_t v52 = v50 >> v51;
    uint64_t v53 = v13 >> v51;
  }

  os_unfair_lock_lock_with_options();
  *(void *)(a2 + 104) = a3;
  *(void *)(a2 + 112) = v52;
  *(void *)(a2 + 120) = v53;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
  return a3;
}

_DWORD *__CFStorageCreateNode(const __CFAllocator *a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v7 = CFAllocatorAllocate(a1, 40LL, 0LL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  int v7[2] = 1;
  *((_BYTE *)v7 + 12) = *(_BYTE *)(a2 + 96);
  *((_BYTE *)v7 + 13) = a3;
  *(void *)uint64_t v7 = a4;
  if ((a3 & 1) == 0) {
    *((void *)v7 + 4) = 0LL;
  }
  *((void *)v7 + 2) = 0LL;
  *((void *)v7 + 3) = 0LL;
  return v7;
}

uint64_t __CFStorageDeleteUnfrozen(malloc_zone_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)a3 - a5;
  if (*(void *)a3 == a5) {
    return 0LL;
  }
  uint64_t v7 = a3;
  if (*(_BYTE *)(a3 + 13))
  {
    *(void *)a3 = v6;
    uint64_t v12 = *(void *)(a3 + 24);
    if (v12)
    {
      memmove((void *)(v12 + a4), (const void *)(v12 + a4 + a5), v6 - a4);
      if (a6)
      {
        uint64_t v13 = *(void *)v7;
        uint64_t v14 = *MEMORY[0x1895FD590];
        else {
          uint64_t v15 = v14 + 1;
        }
        if (v13 <= v15 >> 1)
        {
          uint64_t v47 = v13 + 63;
          BOOL v28 = v13 < -63;
          uint64_t v48 = v13 + 126;
          if (!v28) {
            uint64_t v48 = v47;
          }
          unint64_t v17 = v48 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v16 = (v13 + v14 - 1) & -(int)v14;
          if (*(void *)(a2 + 136) >= v16) {
            unint64_t v17 = v16;
          }
          else {
            unint64_t v17 = *(void *)(a2 + 136);
          }
        }

        if (v17 != *(void *)(v7 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v17 != *(void *)(v7 + 16))
          {
            *(void *)(v7 + 24) = __CFSafelyReallocateWithAllocator(a1, *(void **)(v7 + 24), v17, 0LL, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v7 + 16) = v17;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
      }
    }

    goto LABEL_65;
  }

  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  __int128 v52 = 0uLL;
  uint64_t v21 = (void *)(a3 + 16);
  uint64_t v22 = a4 + a5;
  uint64_t v53 = 0LL;
  do
  {
    uint64_t v23 = (_DWORD *)v21[v20];
    if (!v23) {
      break;
    }
    uint64_t v24 = *(void *)v23;
    if (a4 <= v19) {
      uint64_t v25 = v19;
    }
    else {
      uint64_t v25 = a4;
    }
    uint64_t v26 = v24 + v19;
    if (v22 >= v24 + v19) {
      uint64_t v27 = v24 + v19;
    }
    else {
      uint64_t v27 = a4 + a5;
    }
    BOOL v28 = v27 <= v25;
    uint64_t v29 = v27 - v25;
    if (v28) {
      uint64_t v30 = 0LL;
    }
    else {
      uint64_t v30 = v29;
    }
    if (v28) {
      uint64_t v31 = 0LL;
    }
    else {
      uint64_t v31 = v25;
    }
    if (!v30)
    {
      uint64_t v33 = v23 + 2;
      if (v23[2])
      {
        do
          unsigned int v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }

void __CFStorageClearRootNode(uint64_t a1)
{
  int v2 = CFGetAllocator((CFTypeRef)a1);
  if (*(_BYTE *)(a1 + 157))
  {
    CFAllocatorDeallocate(v2, *(void **)(a1 + 168));
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3)
    {
      int v4 = (unsigned int *)(v3 + 8);
      if (*(_DWORD *)(v3 + 8))
      {
        do
        {
          unsigned int v5 = __ldxr(v4);
          unsigned int v6 = v5 - 1;
        }

        while (__stxr(v6, v4));
        if (!v6) {
          __CFStorageDeallocateNode((const void *)a1, v3);
        }
      }
    }

    uint64_t v7 = *(void *)(a1 + 168);
    if (v7)
    {
      uint64_t v8 = (unsigned int *)(v7 + 8);
      if (*(_DWORD *)(v7 + 8))
      {
        do
        {
          unsigned int v9 = __ldxr(v8);
          unsigned int v10 = v9 - 1;
        }

        while (__stxr(v10, v8));
        if (!v10) {
          __CFStorageDeallocateNode((const void *)a1, v7);
        }
      }
    }

    uint64_t v11 = *(void *)(a1 + 176);
    if (v11)
    {
      uint64_t v12 = (unsigned int *)(v11 + 8);
      if (*(_DWORD *)(v11 + 8))
      {
        do
        {
          unsigned int v13 = __ldxr(v12);
          unsigned int v14 = v13 - 1;
        }

        while (__stxr(v14, v12));
        if (!v14) {
          __CFStorageDeallocateNode((const void *)a1, v11);
        }
      }
    }
  }

  *(_BYTE *)(a1 + 157) = 1;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
}

char *CFStorageGetValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  v41[1] = *MEMORY[0x1895F89C0];
  if (a3 >= 1)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    uint64_t v8 = (os_unfair_lock_s *)(result + 128);
    unsigned int v37 = (pthread_mutex_t *)(result + 32);
    uint64_t v38 = (uint64_t)(result + 144);
    while (1)
    {
      os_unfair_lock_lock_with_options();
      uint64_t v10 = *((void *)v7 + 13);
      uint64_t v9 = *((void *)v7 + 14);
      uint64_t v11 = *((void *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10) {
        break;
      }
      if (!*(void *)(v10 + 24))
      {
        uint64_t v12 = (malloc_zone_t *)CFGetAllocator(v7);
        uint64_t v13 = *(void *)v10;
        uint64_t v14 = *MEMORY[0x1895FD590];
        else {
          uint64_t v15 = v14 + 1;
        }
        if (v13 <= v15 >> 1)
        {
          uint64_t v19 = v13 + 63;
          BOOL v22 = v13 < -63;
          uint64_t v20 = v13 + 126;
          if (!v22) {
            uint64_t v20 = v19;
          }
          int64_t v17 = v20 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v16 = (v13 + v14 - 1) & -(int)v14;
          if (*((void *)v7 + 17) >= v16) {
            int64_t v17 = v16;
          }
          else {
            int64_t v17 = *((void *)v7 + 17);
          }
        }

        if (v17 > *(void *)(v10 + 16))
        {
          pthread_mutex_lock(v37);
          if (v17 > *(void *)(v10 + 16))
          {
            *(void *)(v10 + 24) = __CFSafelyReallocateWithAllocator(v12, *(void **)(v10 + 24), v17, 0LL, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *(void *)(v10 + 16) = v17;
          }

          pthread_mutex_unlock(v37);
        }
      }

      uint64_t v18 = *((unsigned int *)v7 + 6);
      uint64_t v21 = a2 - v9;
      BOOL v22 = a2 < v9 || v11 + v9 <= a2;
      if (v22) {
        goto LABEL_31;
      }
      uint64_t v23 = v18 == 0xFFFFFFFFLL ? *((void *)v7 + 2) * v21 : v21 << v18;
      uint64_t v24 = *(void *)(v10 + 24);
      if (!v24) {
        goto LABEL_31;
      }
      uint64_t Byte = (const void *)(v24 + v23);
LABEL_42:
      if (v5 >= v11 - a2 + v9) {
        uint64_t v35 = v11 - a2 + v9;
      }
      else {
        uint64_t v35 = v5;
      }
      if (v18 == 0xFFFFFFFFLL) {
        size_t v36 = *((void *)v7 + 2) * v35;
      }
      else {
        size_t v36 = v35 << v18;
      }
      uint64_t result = (char *)memmove(a4, Byte, v36);
      a4 += v36;
      a2 += v35;
      BOOL v22 = v5 <= v35;
      v5 -= v35;
      if (v22) {
        return result;
      }
    }

    uint64_t v18 = *((unsigned int *)v7 + 6);
LABEL_31:
    if (v18 == 0xFFFFFFFFLL) {
      uint64_t v26 = *((void *)v7 + 2) * a2;
    }
    else {
      uint64_t v26 = a2 << v18;
    }
    uint64_t Byte = (const void *)__CFStorageFindByte(v7, v38, v26, 0LL, v41, &v39, 0);
    uint64_t v27 = v41[0];
    uint64_t v28 = v39;
    if (v41[0])
    {
      uint64_t v29 = *(void *)v41[0];
      int v30 = *((_DWORD *)v7 + 6);
      if (v30 == -1)
      {
        uint64_t v33 = *((void *)v7 + 2);
        uint64_t v31 = v39 / v33;
        uint64_t v32 = v29 / v33;
      }

      else
      {
        uint64_t v31 = v39 >> v30;
        uint64_t v32 = v29 >> v30;
      }
    }

    else
    {
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
    }

    os_unfair_lock_lock_with_options();
    *((void *)v7 + 13) = v27;
    *((void *)v7 + 14) = v31;
    *((void *)v7 + 15) = v32;
    os_unfair_lock_unlock(v8);
    uint64_t v18 = *((unsigned int *)v7 + 6);
    if ((_DWORD)v18 == -1)
    {
      uint64_t v34 = *((void *)v7 + 2);
      uint64_t v9 = v28 / v34;
      uint64_t v11 = v40 / v34;
    }

    else
    {
      uint64_t v9 = v28 >> v18;
      uint64_t v11 = v40 >> v18;
    }

    goto LABEL_42;
  }

  return result;
}

uint64_t _CFStorageFastEnumeration(uint64_t a1, unint64_t *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  unint64_t v3 = *a2;
  if (v3)
  {
    unint64_t v4 = a2[3];
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 144);
    int v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1) {
      unint64_t v4 = v5 / *(void *)(a1 + 16);
    }
    else {
      unint64_t v4 = v5 >> v6;
    }
    a2[3] = v4;
  }

  if (v3 >= v4) {
    return 0LL;
  }
  uint64_t ValueAtIndex = CFStorageGetValueAtIndex(a1, v3, &v9);
  uint64_t result = v10;
  *a2 += v10;
  a2[1] = ValueAtIndex;
  return result;
}

uint64_t CFStorageApplyFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[7] = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(a1 + 16);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  int v7[2] = __CFStorageApplyFunction_block_invoke;
  v7[3] = &__block_descriptor_tmp_10;
  v7[4] = a4;
  uint64_t v7[5] = a5;
  v7[6] = v5;
  return CFStorageApplyBlock(a1, a2, a3, 0, (uint64_t)v7);
}

uint64_t CFStorageApplyBlock(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int8 a4, uint64_t a5)
{
  if (a3)
  {
    int v6 = *(_DWORD *)(result + 24);
    if (v6 == -1)
    {
      uint64_t v9 = *(void *)(result + 16);
      uint64_t v7 = v9 * a2;
      uint64_t v8 = v9 * a3;
    }

    else
    {
      uint64_t v7 = a2 << v6;
      uint64_t v8 = a3 << v6;
    }

    if (((a3 >= 0x100000) & a4) != 0) {
      uint64_t v10 = 3LL;
    }
    else {
      uint64_t v10 = 0LL;
    }
    return __CFStorageEnumerateNodesInByteRangeWithBlock(result, result + 144, 0LL, v7, v8, v10, a5);
  }

  return result;
}

uint64_t __CFStorageApplyFunction_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    do
    {
      --v4;
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(v6 + 32))(a2, *(void *)(v6 + 40));
      a2 += *(void *)(v6 + 48);
    }

    while (v4);
  }

  return result;
}

BOOL __CFStorageEnumerateNodesInByteRangeWithBlock( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v69[3] = *MEMORY[0x1895F89C0];
  unsigned __int8 v66 = 0;
  if (*(_BYTE *)(a2 + 13))
  {
    if (a5 >= *(void *)a2 - a4) {
      uint64_t v12 = *(void *)a2 - a4;
    }
    else {
      uint64_t v12 = a5;
    }
    if (!*(void *)(a2 + 24))
    {
      uint64_t v13 = (malloc_zone_t *)CFGetAllocator((CFTypeRef)a1);
      uint64_t v14 = *(void *)a2;
      uint64_t v15 = *MEMORY[0x1895FD590];
      else {
        uint64_t v16 = v15 + 1;
      }
      if (v14 <= v16 >> 1)
      {
        uint64_t v51 = v14 + 63;
        BOOL v29 = v14 < -63;
        uint64_t v52 = v14 + 126;
        if (!v29) {
          uint64_t v52 = v51;
        }
        int64_t v18 = v52 & 0xFFFFFFFFFFFFFFC0LL;
      }

      else
      {
        int v17 = (v14 + v15 - 1) & -(int)v15;
        if (*(void *)(a1 + 136) >= v17) {
          int64_t v18 = v17;
        }
        else {
          int64_t v18 = *(void *)(a1 + 136);
        }
      }

      if (v18 > *(void *)(a2 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v18 > *(void *)(a2 + 16))
        {
          *(void *)(a2 + 24) = __CFSafelyReallocateWithAllocator(v13, *(void **)(a2 + 24), v18, 0LL, 0LL);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(a2 + 16) = v18;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }

    uint64_t v53 = a4 + a3;
    int v54 = *(_DWORD *)(a1 + 24);
    if (v54 == -1)
    {
      uint64_t v57 = *(void *)(a1 + 16);
      uint64_t v55 = v53 / v57;
      uint64_t v56 = v12 / v57;
    }

    else
    {
      uint64_t v55 = v53 >> v54;
      uint64_t v56 = v12 >> v54;
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int8 *))(a7 + 16))( a7,  *(void *)(a2 + 24) + a4,  v55,  v56,  &v66);
    int v49 = v66;
    return v49 != 0;
  }

  uint64_t v19 = *(uint64_t **)(a2 + 16);
  uint64_t v20 = *(uint64_t **)(a2 + 24);
  v69[0] = v19;
  v69[1] = v20;
  uint64_t v21 = *(uint64_t **)(a2 + 32);
  v69[2] = v21;
  uint64_t v22 = *v19;
  if (v20) {
    uint64_t v23 = *v20;
  }
  else {
    uint64_t v23 = 0LL;
  }
  if (v21) {
    uint64_t v24 = *v21;
  }
  else {
    uint64_t v24 = 0LL;
  }
  v68[0] = 0LL;
  v68[1] = v22;
  uint64_t v25 = v23 + v22;
  v68[2] = v23 + v22;
  uint64_t v26 = a4 & ~(a4 >> 63);
  uint64_t v27 = a4 + a5;
  if (v22 >= a4 + a5) {
    uint64_t v28 = a4 + a5;
  }
  else {
    uint64_t v28 = v22;
  }
  BOOL v29 = v28 <= v26;
  uint64_t v30 = v28 - v26;
  if (v29) {
    uint64_t v31 = 0LL;
  }
  else {
    uint64_t v31 = v30;
  }
  if (v29) {
    uint64_t v32 = 0LL;
  }
  else {
    uint64_t v32 = a4 & ~(a4 >> 63);
  }
  v67[0] = v32;
  v67[1] = v31;
  if (v22 <= a4) {
    uint64_t v33 = a4;
  }
  else {
    uint64_t v33 = v22;
  }
  if (v25 >= v27) {
    uint64_t v34 = v27;
  }
  else {
    uint64_t v34 = v25;
  }
  BOOL v35 = v34 <= v33;
  uint64_t v36 = v34 - v33;
  if (v35) {
    uint64_t v37 = 0LL;
  }
  else {
    uint64_t v37 = v36;
  }
  if (v35) {
    uint64_t v38 = 0LL;
  }
  else {
    uint64_t v38 = v33;
  }
  v67[2] = v38;
  v67[3] = v37;
  if (v25 <= a4) {
    uint64_t v39 = a4;
  }
  else {
    uint64_t v39 = v25;
  }
  uint64_t v40 = v25 + v24;
  if (v40 >= v27) {
    uint64_t v40 = v27;
  }
  BOOL v41 = v40 <= v39;
  uint64_t v42 = v40 - v39;
  if (v41) {
    uint64_t v43 = 0LL;
  }
  else {
    uint64_t v43 = v42;
  }
  if (v41) {
    uint64_t v44 = 0LL;
  }
  else {
    uint64_t v44 = v39;
  }
  v67[4] = v44;
  v67[5] = v43;
  unint64_t v45 = v37 != 0;
  if (v31) {
    ++v45;
  }
  if (v43) {
    ++v45;
  }
  uint64_t v46 = a6 - (v45 > 1);
  if (v45 < 2 || v46 < 0)
  {
    uint64_t v59 = v44;
    if (v31 < 1)
    {
      if (v37 < 1)
      {
        if (v43 <= 0)
        {
          int v49 = 0;
          return v49 != 0;
        }

        goto LABEL_90;
      }
    }

    else
    {
      int v50 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v19, a3, v32);
      if (v37 > 0) {
        int v49 = 1;
      }
      else {
        int v49 = v50;
      }
      if (v37 < 1 || (v50 & 1) != 0) {
        goto LABEL_86;
      }
    }

    int v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v20, v22 + a3, v38 - v22);
LABEL_86:
    if (v43 <= 0) {
      return v49 != 0;
    }
    if ((v49 & 1) != 0)
    {
      int v49 = 1;
      return v49 != 0;
    }

uint64_t __CFStorageSetAlwaysFrozen(uint64_t result, char a2)
{
  *(_BYTE *)(result + 96) = a2;
  return result;
}

void __CFStorageDescribeNode(uint64_t *a1, __CFString *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v6 = a3;
    do
    {
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CFStringAppendCString(a2, "  ", SystemEncoding);
      --v6;
    }

    while (v6);
  }

  uint64_t v8 = *a1;
  if (*((_BYTE *)a1 + 13))
  {
    uint64_t v9 = "yes";
    if (!*((_BYTE *)a1 + 12)) {
      uint64_t v9 = "no";
    }
    CFStringAppendFormat( a2,  0LL,  @"Leaf %ld/%ld (%p) refcount: %u frozen: %s\n",  v8,  a1[2],  a1,  *((unsigned int *)a1 + 2),  v9);
  }

  else
  {
    uint64_t v10 = "yes";
    if (!*((_BYTE *)a1 + 12)) {
      uint64_t v10 = "no";
    }
    CFStringAppendFormat( a2,  0LL,  @"Node %ld (%p) refcount: %u frozen: %s\n",  v8,  a1,  *((unsigned int *)a1 + 2),  v10);
    for (uint64_t i = 0LL; i != 3; ++i)
    {
      uint64_t v12 = a1[i + 2];
      if (v12) {
        __CFStorageDescribeNode(v12, a2, a3 + 1);
      }
    }
  }

uint64_t __CFStorageFindByte(void *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, void *a6, int a7)
{
  uint64_t v9 = a2;
  uint64_t v10 = (char *)cf;
  if (!*(_BYTE *)(a2 + 13))
  {
    uint64_t v53 = (pthread_mutex_t *)(cf + 4);
    while (1)
    {
      uint64_t v12 = a3;
      uint64_t v14 = v9 + 16;
      uint64_t v13 = *(void **)(v9 + 16);
      BOOL v15 = a3 < *v13;
      a3 -= *v13;
      if (v15) {
        break;
      }
      uint64_t v13 = *(void **)(v9 + 24);
      if (a3 < *v13)
      {
        uint64_t v16 = 1LL;
LABEL_8:
        uint64_t v9 = (uint64_t)v13;
        if (a7) {
          goto LABEL_11;
        }
        goto LABEL_53;
      }

      uint64_t v9 = *(void *)(v9 + 32);
      uint64_t v16 = 2LL;
      a3 -= *v13;
      if (a7)
      {
LABEL_11:
        if (*(_BYTE *)(v9 + 12))
        {
          int v17 = (unsigned int *)(v9 + 8);
          if (*(_DWORD *)(v9 + 8) == 1)
          {
            *(_BYTE *)(v9 + 12) = 0;
          }

          else
          {
            int64_t v18 = CFGetAllocator(v10);
            Node = (int64_t *)__CFStorageCreateNode(v18, (uint64_t)v10, *(_BYTE *)(v9 + 13), *(void *)v9);
            uint64_t v20 = Node;
            if (*(_BYTE *)(v9 + 13))
            {
              uint64_t v21 = *(const void **)(v9 + 24);
              if (v21)
              {
                int64_t v22 = *Node;
                uint64_t v23 = *MEMORY[0x1895FD590];
                else {
                  uint64_t v24 = v23 + 1;
                }
                if (v22 <= v24 >> 1)
                {
                  int64_t v37 = v22 + 63;
                  if (v22 < -63) {
                    int64_t v37 = v22 + 126;
                  }
                  int64_t v25 = v37 & 0xFFFFFFFFFFFFFFC0LL;
                }

                else
                {
                  int64_t v25 = (int)((v22 + v23 - 1) & -(int)v23);
                  if (cf[17] < v25) {
                    int64_t v25 = cf[17];
                  }
                }

                if (v25 > Node[2])
                {
                  int v51 = a7;
                  uint64_t v38 = v53;
                  int64_t v52 = v25;
                  pthread_mutex_lock(v53);
                  if (v52 > v20[2])
                  {
                    v20[3] = (int64_t)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)v18,  (void *)v20[3],  v52,  0LL,  0LL);
                    if (__CFOASafe) {
                      __CFSetLastAllocationEventName();
                    }
                    uint64_t v38 = v53;
                    v20[2] = v52;
                  }

                  pthread_mutex_unlock(v38);
                  uint64_t v21 = *(const void **)(v9 + 24);
                  int64_t v22 = *v20;
                  a7 = v51;
                }

                memmove((void *)v20[3], v21, v22);
              }
            }

            else
            {
              int64_t v26 = *(void *)(v9 + 16);
              uint64_t v27 = (unsigned int *)(v26 + 8);
              if (*(_DWORD *)(v26 + 8))
              {
                do
                  unsigned int v28 = __ldxr(v27);
                while (__stxr(v28 + 1, v27));
              }

              Node[2] = v26;
              int64_t v29 = *(void *)(v9 + 24);
              if (v29)
              {
                uint64_t v30 = (unsigned int *)(v29 + 8);
                if (*(_DWORD *)(v29 + 8))
                {
                  do
                    unsigned int v31 = __ldxr(v30);
                  while (__stxr(v31 + 1, v30));
                }

                Node[3] = v29;
              }

              int64_t v32 = *(void *)(v9 + 32);
              if (v32)
              {
                uint64_t v33 = (unsigned int *)(v32 + 8);
                if (*(_DWORD *)(v32 + 8))
                {
                  do
                    unsigned int v34 = __ldxr(v33);
                  while (__stxr(v34 + 1, v33));
                }

                Node[4] = v32;
              }

              if (*(_BYTE *)(v9 + 12))
              {
                *(_BYTE *)(Node[2] + 12) = 1;
                int64_t v35 = Node[3];
                if (v35) {
                  *(_BYTE *)(v35 + 12) = 1;
                }
                int64_t v36 = Node[4];
                if (v36) {
                  *(_BYTE *)(v36 + 12) = 1;
                }
              }
            }

            *(void *)(v14 + 8 * v16) = v20;
            if (!*v17) {
              goto LABEL_52;
            }
            do
            {
              unsigned int v39 = __ldxr(v17);
              unsigned int v40 = v39 - 1;
            }

            while (__stxr(v40, v17));
            if (v40)
            {
LABEL_52:
              uint64_t v9 = (uint64_t)v20;
              uint64_t v10 = (char *)cf;
            }

            else
            {
              __CFStorageDeallocateNode(cf, v9);
              uint64_t v9 = (uint64_t)v20;
              uint64_t v10 = (char *)cf;
            }
          }
        }
      }

LABEL_53:
      a4 = a4 + v12 - a3;
      if (*(_BYTE *)(v9 + 13)) {
        goto LABEL_54;
      }
    }

    uint64_t v16 = 0LL;
    a3 = v12;
    goto LABEL_8;
  }

            MEMORY[0x1895F8858](Length, v22.location);
            unsigned int v63 = &v64;
            __strlcpy_chk();
            __strlcat_chk();
            goto LABEL_54;
          }

          uint64_t v30 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          int64_t v26 = v30 - 1;
          CFIndex Length = CFStringGetLength(v6);
          v22.CFIndex location = Length - v26;
          if (Length < v26) {
            goto LABEL_53;
          }
          uint64_t v27 = @"";
        }

        else
        {
          int64_t v29 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          int64_t v26 = v29 - 1;
          CFIndex Length = CFStringGetLength(v6);
          v22.CFIndex location = Length - v26;
          if (Length < v26) {
            goto LABEL_53;
          }
          uint64_t v27 = @"";
        }
      }

      else
      {
        unsigned int v28 = CFStringGetLength(v6);
        CFStringReplaceAll(v6, theString);
        int64_t v26 = v28 - 1;
        CFIndex Length = CFStringGetLength(v6);
        v22.CFIndex location = Length - v26;
        if (Length < v26) {
          goto LABEL_53;
        }
        uint64_t v27 = @"";
      }
    }

    else
    {
      int64_t v25 = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      int64_t v26 = v25 - 1;
      CFIndex Length = CFStringGetLength(v6);
      v22.CFIndex location = Length - v26;
      if (Length < v26) {
        goto LABEL_53;
      }
      uint64_t v27 = @"";
    }

    v22.CFIndex length = v26;
    CFStringReplace(v6, v22, v27);
    goto LABEL_18;
  }

  MEMORY[0x1895F8858](0LL, v5);
  unsigned int v63 = &v66;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_54:
  uint64_t result = (CFTypeRef)__strlcat_chk();
  qword_18C539A70 = (uint64_t)v63;
  __break(1u);
  return result;
}

    int64_t v25 = v23 & 0x7F | ((v18 & 0x7F) << 8);
    int64_t v26 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    uint64_t v27 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      unsigned int v28 = (0xF83E0F83E0F83E1LL * (v27 - v26)) >> 1;
      int64_t v29 = &v26[33 * v28];
      uint64_t v30 = *v29;
      if (v30 <= v25) {
        break;
      }
      uint64_t v27 = v29 - 33;
LABEL_59:
      if (v26 > v27) {
        goto LABEL_78;
      }
    }

    if (v30 + 32 <= v25)
    {
      int64_t v26 = v29 + 33;
      goto LABEL_59;
    }

    unsigned int v31 = v26[33 * v28 + 1 + (int)(v25 - v30)];
    if (v31 != 65533 && v31 != 0)
    {
      if (!v14
        || (int v50 = v15,
            int64_t v52 = v16,
            IsDecomposableCharacter = __CFStringEncodingIsDecomposableCharacter(v31, (a1 >> 7) & 1),
            BOOL v15 = v50,
            uint64_t v16 = v52,
            !IsDecomposableCharacter))
      {
        if (a5) {
          *a4++ = v31;
        }
        uint64_t v12 = *a6 + 1;
        uint64_t v19 = 2LL;
        goto LABEL_18;
      }

      uint64_t v43 = __CFStringEncodingDecomposeCharacter(a1, v31, v53, v52);
      uint64_t v44 = *a6;
      uint64_t v12 = *a6 + v43;
      *a6 = v12;
      if (!a5)
      {
        uint64_t v19 = 2LL;
        BOOL v15 = v50;
        uint64_t v16 = v52;
        goto LABEL_19;
      }

      if (v12 > a5)
      {
        *a6 = v44;
        return v13;
      }

      BOOL v15 = v50;
      uint64_t v16 = v52;
      if (v43 >= 1)
      {
        uint64_t v45 = v43 + 1;
        int v46 = v53;
        do
        {
          int64_t v47 = *v46++;
          *a4++ = v47;
          --v45;
        }

        while (v45 > 1);
      }

      uint64_t v19 = 2LL;
LABEL_19:
      v13 += v19;
      a2 += v19;
      uint64_t v20 = (uint64_t)v9 <= v19;
      v9 -= v19;
      if (v20) {
        return v13;
      }
      continue;
    }

    break;
  }

  int64_t v35 = 0LL;
LABEL_54:
  v120 = 0LL;
  int64_t v121 = 0LL;
  ptr = 0LL;
  v124 = 0LL;
  v122 = 0LL;
  int64_t v36 = a2 + a3;
  int64_t v37 = a5 + a6;
  __src = a4;
  int v128 = a2 + a3;
  unint64_t v131 = (CFTypeRef)(a5 + a6);
  do
  {
    if (a2 >= v36) {
      goto LABEL_101;
    }
    uint64_t v38 = __extendLocationForward( a2,  buffer,  _CFCompareStringsWithLocale_alnumBMP,  _CFCompareStringsWithLocale_punctBMP,  _CFCompareStringsWithLocale_controlBMP,  v36);
    a2 = v38;
    a3 = v38 - v15;
    if (v15 < 0) {
      goto LABEL_58;
    }
    unsigned int v39 = *((void *)buffer + 20);
    if (v38 > v39) {
      goto LABEL_58;
    }
    uint64_t v43 = *((void *)buffer + 17);
    if (!v43)
    {
      if (a3 <= 64)
      {
        if (v38 > *((void *)buffer + 22) || (uint64_t v44 = *((void *)buffer + 21), v15 < v44))
        {
          if (v15 + 64 < v39) {
            unsigned int v39 = v15 + 64;
          }
          *((void *)buffer + 21) = v15;
          *((void *)buffer + 22) = v39;
          v45.CFIndex length = v39 - v15;
          int64_t v47 = *((void *)buffer + 18);
          int v46 = *((void *)buffer + 19);
          if (v47)
          {
            uint64_t v44 = v15;
            if (v45.length)
            {
              uint64_t v48 = v47 + v46;
              uint64_t v49 = buffer;
              do
              {
                *v49++ = *(char *)(v48 + v15);
                ++v48;
                --v39;
              }

              while (v15 != v39);
              uint64_t v44 = v15;
            }
          }

          else
          {
            v45.CFIndex location = v46 + v15;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v45, buffer);
            uint64_t v44 = *((void *)buffer + 21);
          }
        }

        p_dst = &buffer[v15 - v44];
        goto LABEL_100;
      }

  uint64_t v33 = 0;
LABEL_54:
  unsigned int v34 = a3;
  int64_t v35 = a2;
  while (2)
  {
    int64_t v36 = v34 - 1;
    int64_t v37 = *v35;
    if ((v37 & 0x80000000) == 0 || (v37 + 32) > 0xC0u)
    {
LABEL_69:
      ++v35;
      unsigned int v34 = v36;
      if (v36 <= 0)
      {
        if ((v33 & 1) == 0)
        {
          uint64_t v30 = 0LL;
          *a6 = 0LL;
          int v46 = 1LL;
          while (1)
          {
            if (a5)
            {
              if (v46 - 1 >= a5) {
                return v30;
              }
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!(_DWORD)a1) {
                return v30;
              }
              int64_t v47 = a1;
              *v8++ = v59;
            }

            else
            {
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!(_DWORD)a1) {
                return v30;
              }
              int64_t v47 = a1;
            }

            *a6 = v46;
            v30 += v47;
            v10 += v47;
            ++v46;
            uint64_t v14 = v9 <= v47;
            v9 -= v47;
            if (v14) {
              return v30;
            }
          }
        }

        goto LABEL_92;
      }

      continue;
    }

    break;
  }

  else {
    uint64_t v38 = 15;
  }
  unsigned int v39 = v38 + *v35;
  unsigned int v40 = 2 * v39;
  a1 = (2 * (v39 & 0x1FF)) | 1u;
  uint64_t v41 = *++v35;
  uint64_t v42 = v41 + ((char)(2 * v39) >> 7);
  uint64_t v43 = v40 + 2;
  else {
    uint64_t v44 = v43;
  }
  else {
    uint64_t v45 = -125;
  }
  if ((v44 - 127) >= 0xA1u && (v42 + v45 - 127) >= 0xA1u)
  {
    int64_t v36 = v34 - 2;
    goto LABEL_69;
  }

  if ((v33 & 1) != 0)
  {
    uint64_t v30 = 0LL;
    *a6 = 0LL;
    uint64_t v48 = 1LL;
    while (1)
    {
      if (a5)
      {
        if (v48 - 1 >= a5) {
          return v30;
        }
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!(_DWORD)a1) {
          return v30;
        }
        uint64_t v49 = a1;
        *v8++ = v59;
      }

      else
      {
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!(_DWORD)a1) {
          return v30;
        }
        uint64_t v49 = a1;
      }

      *a6 = v48;
      v30 += v49;
      v10 += v49;
      ++v48;
      uint64_t v14 = v9 <= v49;
      v9 -= v49;
      if (v14) {
        return v30;
      }
    }
  }

LABEL_54:
  uint64_t v41 = *(void *)v9;
  *a6 = a4;
  a6[1] = v41;
  *a5 = v9;
  uint64_t v42 = (malloc_zone_t *)CFGetAllocator(v10);
  uint64_t v43 = *(void *)v9;
  uint64_t v44 = *MEMORY[0x1895FD590];
  else {
    uint64_t v45 = v44 + 1;
  }
  if (v43 <= v45 >> 1)
  {
    uint64_t v48 = v43 + 63;
    BOOL v15 = v43 < -63;
    uint64_t v49 = v43 + 126;
    if (!v15) {
      uint64_t v49 = v48;
    }
    int64_t v47 = v49 & 0xFFFFFFFFFFFFFFC0LL;
  }

  else
  {
    int v46 = (v43 + v44 - 1) & -(int)v44;
    if (*((void *)v10 + 17) >= v46) {
      int64_t v47 = v46;
    }
    else {
      int64_t v47 = *((void *)v10 + 17);
    }
  }

  if (v47 > *(void *)(v9 + 16))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
    if (v47 > *(void *)(v9 + 16))
    {
      *(void *)(v9 + 24) = __CFSafelyReallocateWithAllocator(v42, *(void **)(v9 + 24), v47, 0LL, 0LL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      *(void *)(v9 + 16) = v47;
    }

    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 32));
  }

  return *(void *)(v9 + 24) + a3;
}

        bufferWrite_0(v15, p_src, v16);
        return v10;
      case 23LL:
      case 24LL:
      case 25LL:
      case 26LL:
      case 27LL:
      case 28LL:
        goto LABEL_14;
      case 29LL:
        int v17 = CFURLGetString((CFURLRef)a2);
        if (!v17) {
          return 0LL;
        }
        int64_t v18 = v17;
        uint64_t v19 = CFURLGetBaseURL((CFURLRef)a2);
        if (v19) {
          uint64_t v20 = 13;
        }
        else {
          uint64_t v20 = 12;
        }
        __src = v20;
        bufferWrite_0((uint64_t)a1, &__src, 1LL);
        if (v19) {
          __writeObject15(a1, v19);
        }
        __writeObject15(a1, v18);
        return 1LL;
      default:
        if (v4 == 34)
        {
          __src = 14;
          bufferWrite_0((uint64_t)a1, &__src, 1LL);
          int64_t v25 = CFUUIDGetTypeID();
          else {
            uint64_t v48 = CFUUIDGetUUIDBytes((CFUUIDRef)a2);
          }
          BytePtr = &v48;
          unsigned int v31 = (uint64_t)a1;
          int64_t v32 = 16LL;
          goto LABEL_70;
        }

        if (v4 != 42) {
          goto LABEL_14;
        }
        __src = 51;
        bufferWrite_0((uint64_t)a1, &__src, 1LL);
        int64_t v47 = bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime((CFDateRef)a2)));
        bufferWrite_0((uint64_t)a1, &v47, 8LL);
        return 1LL;
    }

    goto LABEL_70;
  }

  if (v4 != 7)
  {
    if (v4 == 16)
    {
      __src = 0;
      uint64_t v10 = 1LL;
      bufferWrite_0((uint64_t)a1, &__src, 1LL);
      return v10;
    }

void __CFStorageDeallocateNode(const void *a1, uint64_t a2)
{
  uint64_t v4 = CFGetAllocator(a1);
  uint64_t v5 = v4;
  if (*(_BYTE *)(a2 + 13))
  {
    uint64_t v6 = *(void **)(a2 + 24);
    if (v6) {
      CFAllocatorDeallocate(v4, v6);
    }
  }

  else
  {
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7)
    {
      uint64_t v8 = (unsigned int *)(v7 + 8);
      if (*(_DWORD *)(v7 + 8))
      {
        do
        {
          unsigned int v9 = __ldxr(v8);
          unsigned int v10 = v9 - 1;
        }

        while (__stxr(v10, v8));
        if (!v10) {
          __CFStorageDeallocateNode(a1);
        }
      }
    }

    uint64_t v11 = *(void *)(a2 + 24);
    if (v11)
    {
      uint64_t v12 = (unsigned int *)(v11 + 8);
      if (*(_DWORD *)(v11 + 8))
      {
        do
        {
          unsigned int v13 = __ldxr(v12);
          unsigned int v14 = v13 - 1;
        }

        while (__stxr(v14, v12));
        if (!v14) {
          __CFStorageDeallocateNode(a1);
        }
      }
    }

    uint64_t v15 = *(void *)(a2 + 32);
    if (v15)
    {
      uint64_t v16 = (unsigned int *)(v15 + 8);
      if (*(_DWORD *)(v15 + 8))
      {
        do
        {
          unsigned int v17 = __ldxr(v16);
          unsigned int v18 = v17 - 1;
        }

        while (__stxr(v18, v16));
        if (!v18) {
          __CFStorageDeallocateNode(a1);
        }
      }
    }
  }

  CFAllocatorDeallocate(v5, (void *)a2);
}

_DWORD *__CFStorageInsertFrozen( const __CFAllocator *a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v9 = (_DWORD *)a3;
  uint64_t v93 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a3 + 13))
  {
    uint64_t v12 = *(void *)a3 + a5;
    uint64_t v13 = *(void *)(a2 + 136);
    uint64_t v14 = v12 - v13;
    if (v12 > v13)
    {
      if (*(void *)a3 == a4)
      {
        Node = __CFStorageCreateNode(a1, a2, 1, a5);
        uint64_t v16 = Node;
        if (!Node)
        {
          uint64_t v19 = 0LL;
          uint64_t v20 = 0LL;
          goto LABEL_128;
        }

        uint64_t v17 = *(void *)Node;
        int v18 = *(_DWORD *)(a2 + 24);
        if (v18 != -1)
        {
          uint64_t v19 = a6 >> v18;
          uint64_t v20 = v17 >> v18;
LABEL_128:
          os_unfair_lock_lock_with_options();
          *(void *)(a2 + 104) = v16;
          *(void *)(a2 + 112) = v19;
          *(void *)(a2 + 120) = v20;
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
          return v9;
        }

        uint64_t v84 = *(void *)(a2 + 16);
        uint64_t v19 = a6 / v84;
LABEL_127:
        uint64_t v20 = v17 / v84;
        goto LABEL_128;
      }

      if (a4)
      {
        uint64_t v16 = __CFStorageCreateNode(a1, a2, 1, v13);
        int v90 = (malloc_zone_t *)a1;
        uint64_t v33 = __CFStorageCreateNode(a1, a2, 1, v12 - v13);
        uint64_t v34 = *MEMORY[0x1895FD590];
        else {
          uint64_t v35 = v34 + 1;
        }
        uint64_t v36 = v35 >> 1;
        if (v36 >= v13)
        {
          uint64_t v64 = v13 + 63;
          if (v13 < -63) {
            uint64_t v64 = v13 + 126;
          }
          int64_t v38 = v64 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v37 = (v13 + v34 - 1) & -(int)v34;
          if (*(void *)(a2 + 136) >= v37) {
            int64_t v38 = v37;
          }
          else {
            int64_t v38 = *(void *)(a2 + 136);
          }
        }

        if (v38 > *((void *)v16 + 2))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v38 > *((void *)v16 + 2))
          {
            *((void *)v16 + 3) = __CFSafelyReallocateWithAllocator(v90, *((void **)v16 + 3), v38, 0LL, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *((void *)v16 + 2) = v38;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          uint64_t v34 = *MEMORY[0x1895FD590];
          else {
            uint64_t v65 = v34 + 1;
          }
          uint64_t v36 = v65 >> 1;
        }

        if (v36 >= v14)
        {
          uint64_t v68 = v14 + 63;
          if (v14 < -63) {
            uint64_t v68 = v14 + 126;
          }
          int64_t v67 = v68 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v66 = (v14 + v34 - 1) & -(int)v34;
          if (*(void *)(a2 + 136) >= v66) {
            int64_t v67 = v66;
          }
          else {
            int64_t v67 = *(void *)(a2 + 136);
          }
        }

        if (v67 > *((void *)v33 + 2))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v67 > *((void *)v33 + 2))
          {
            *((void *)v33 + 3) = __CFSafelyReallocateWithAllocator(v90, *((void **)v33 + 3), v67, 0LL, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *((void *)v33 + 2) = v67;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }

        memmove(*((void **)v16 + 3), *((const void **)v9 + 3), a4);
        uint64_t v69 = a5 + a4;
        uint64_t v70 = (a5 + a4) & ~((a5 + a4) >> 63);
        uint64_t v71 = a5;
        uint64_t v72 = *(void *)v9 + a5;
        if (v13 >= v72) {
          uint64_t v73 = v72;
        }
        else {
          uint64_t v73 = v13;
        }
        BOOL v74 = v73 <= v70;
        int64_t v75 = v73 - v70;
        if (v74) {
          int64_t v76 = 0LL;
        }
        else {
          int64_t v76 = v75;
        }
        if (v74) {
          uint64_t v77 = 0LL;
        }
        else {
          uint64_t v77 = v70;
        }
        if (v76 >= 1) {
          memmove((void *)(*((void *)v16 + 3) + v77), (const void *)(*((void *)v9 + 3) + v77 - v71), v76);
        }
        if (v13 <= v69) {
          uint64_t v78 = v69;
        }
        else {
          uint64_t v78 = v13;
        }
        if (v12 >= v72) {
          uint64_t v79 = v72;
        }
        else {
          uint64_t v79 = v12;
        }
        BOOL v80 = v79 <= v78;
        int64_t v81 = v79 - v78;
        if (v80) {
          int64_t v82 = 0LL;
        }
        else {
          int64_t v82 = v81;
        }
        if (v80) {
          uint64_t v78 = 0LL;
        }
        if (v82 >= 1) {
          memmove((void *)(*((void *)v33 + 3) + v78 - v13), (const void *)(*((void *)v9 + 3) + v78 - v71), v82);
        }
        uint64_t v40 = a6 - a4;
        uint64_t v41 = *(void *)v16;
        int v42 = *(_DWORD *)(a2 + 24);
        if (v42 != -1) {
          goto LABEL_120;
        }
        goto LABEL_122;
      }

      uint64_t v60 = (unsigned int *)(a3 + 8);
      if (*(_DWORD *)(a3 + 8))
      {
        do
          unsigned int v61 = __ldxr(v60);
        while (__stxr(v61 + 1, v60));
      }

      uint64_t v62 = __CFStorageCreateNode(a1, a2, 1, a5);
      uint64_t v16 = v62;
      if (v62)
      {
        uint64_t v17 = *(void *)v62;
        int v63 = *(_DWORD *)(a2 + 24);
        if (v63 == -1)
        {
          uint64_t v84 = *(void *)(a2 + 16);
          uint64_t v19 = a6 / v84;
          unsigned int v9 = v62;
          goto LABEL_127;
        }

        uint64_t v19 = a6 >> v63;
        uint64_t v20 = v17 >> v63;
LABEL_121:
        unsigned int v9 = v16;
        goto LABEL_128;
      }

      uint64_t v19 = 0LL;
      uint64_t v20 = 0LL;
LABEL_125:
      unsigned int v9 = 0LL;
      goto LABEL_128;
    }

    uint64_t v27 = __CFStorageCreateNode(a1, a2, 1, *(void *)a3 + a5);
    uint64_t v16 = v27;
    unsigned int v28 = (const void *)*((void *)v9 + 3);
    if (v28)
    {
      uint64_t v29 = *MEMORY[0x1895FD590];
      else {
        uint64_t v30 = v29 + 1;
      }
      if (v12 <= v30 >> 1)
      {
        uint64_t v39 = v12 + 63;
        if (v12 < -63) {
          uint64_t v39 = v12 + 126;
        }
        int64_t v32 = v39 & 0xFFFFFFFFFFFFFFC0LL;
      }

      else
      {
        int v31 = (v12 + v29 - 1) & -(int)v29;
        if (*(void *)(a2 + 136) >= v31) {
          int64_t v32 = v31;
        }
        else {
          int64_t v32 = *(void *)(a2 + 136);
        }
      }

      if (v32 > *((void *)v27 + 2))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
        if (v32 > *((void *)v16 + 2))
        {
          *((void *)v16 + 3) = __CFSafelyReallocateWithAllocator( (malloc_zone_t *)a1,  *((void **)v16 + 3),  v32,  0LL,  0LL);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *((void *)v16 + 2) = v32;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        unsigned int v28 = (const void *)*((void *)v9 + 3);
      }

      memmove(*((void **)v16 + 3), v28, a4);
      memmove((void *)(*((void *)v16 + 3) + a4 + a5), (const void *)(*((void *)v9 + 3) + a4), *(void *)v9 - a4);
    }

    else if (!v27)
    {
      uint64_t v19 = 0LL;
      uint64_t v20 = 0LL;
      goto LABEL_125;
    }

    uint64_t v40 = a6 - a4;
    uint64_t v41 = *(void *)v16;
    int v42 = *(_DWORD *)(a2 + 24);
    if (v42 != -1)
    {
LABEL_120:
      uint64_t v19 = v40 >> v42;
      uint64_t v20 = v41 >> v42;
      goto LABEL_121;
    }

_DWORD *__CFStorageDeleteFrozen( const __CFAllocator *a1, uint64_t a2, uint64_t *a3, int64_t a4, uint64_t a5)
{
  v37[3] = *MEMORY[0x1895F89C0];
  if (*((_BYTE *)a3 + 13))
  {
    uint64_t v10 = *a3 - a5;
    if (*a3 != a5)
    {
      Node = __CFStorageCreateNode(a1, a2, 1, *a3 - a5);
      uint64_t v12 = Node;
      if (a3[3])
      {
        uint64_t v13 = *MEMORY[0x1895FD590];
        else {
          uint64_t v14 = v13 + 1;
        }
        if (v10 <= v14 >> 1)
        {
          uint64_t v33 = v10 + 63;
          if (v10 < -63) {
            uint64_t v33 = v10 + 126;
          }
          int64_t v16 = v33 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          int v15 = (v10 + v13 - 1) & -(int)v13;
          if (*(void *)(a2 + 136) >= v15) {
            int64_t v16 = v15;
          }
          else {
            int64_t v16 = *(void *)(a2 + 136);
          }
        }

        uint64_t v34 = a4 + a5;
        uint64_t v35 = *a3;
        if (v16 > *((void *)Node + 2))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v16 > *((void *)v12 + 2))
          {
            *((void *)v12 + 3) = __CFSafelyReallocateWithAllocator( (malloc_zone_t *)a1,  *((void **)v12 + 3),  v16,  0LL,  0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            *((void *)v12 + 2) = v16;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }

        if (a4 >= 1) {
          memmove(*((void **)v12 + 3), (const void *)a3[3], a4);
        }
        if (v35 - v34 >= 1) {
          memmove((void *)(*((void *)v12 + 3) + a4), (const void *)(a3[3] + v34), v35 - v34);
        }
      }

      return v12;
    }

    return 0LL;
  }

  if (a5 == *a3) {
    return 0LL;
  }
  uint64_t v18 = 0LL;
  int64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v21 = a4 + a5;
  do
  {
    int64_t v22 = (uint64_t *)a3[v20 + 2];
    if (!v22) {
      break;
    }
    uint64_t v23 = *v22;
    int64_t v24 = a4 <= v19 ? v19 : a4;
    int64_t v25 = v23 + v19;
    int64_t v26 = v21 >= v23 + v19 ? v23 + v19 : a4 + a5;
    BOOL v27 = v26 <= v24;
    int64_t v28 = v26 - v24;
    if (v27 ? 0LL : v28)
    {
      uint64_t v30 = __CFStorageDeleteFrozen(a1, a2);
      if (v30) {
        v37[v18++] = v30;
      }
    }

    else
    {
      int v31 = (unsigned int *)(v22 + 1);
      if (*((_DWORD *)v22 + 2))
      {
        do
          unsigned int v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
      }

      v37[v18++] = v22;
      *((_BYTE *)v22 + 12) = 1;
    }

    ++v20;
    int64_t v19 = v25;
  }

  while (v20 != 3);
  if (v18 == 1) {
    return (_DWORD *)v37[0];
  }
  uint64_t v36 = __CFStorageCreateNode(a1, a2, 0, 0LL);
  uint64_t v12 = v36;
  if (v18) {
    memcpy(v36 + 4, v37, 8 * v18);
  }
  *(void *)uint64_t v12 = *a3 - a5;
  return v12;
}

void _CFStreamClose(uint64_t a1)
{
  uint64_t Status = _CFStreamGetStatus(a1);
  if (!Status || Status == 6) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (Status == 7)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if ((v4 & 0x80) != 0) {
      return;
    }
  }

  else
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if ((v4 & 0x80) != 0) {
      return;
    }
  }

  *(void *)(a1 + 16) = v4 | 0xC0;
  uint64_t v5 = *(void (**)(uint64_t, void))(v3 + 88);
  if (v5) {
    v5(a1, *(void *)(a1 + 40));
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6 && *(void *)(v6 + 56))
  {
    if ((*(_BYTE *)(a1 + 17) & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7)
      {
        uint64_t v8 = *(void **)(v7 + 56);
        if (v8)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          *(void *)(*(void *)(a1 + 32) + 56LL) = 0LL;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          CFRelease(v8);
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v8);
          CFRelease(v8);
          goto LABEL_33;
        }

        *(void *)(v7 + 56) = 0LL;
      }

      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      goto LABEL_33;
    }

    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)a1);
    uint64_t v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
    CFIndex Count = CFArrayGetCount(v10);
    v20.CFIndex location = 0LL;
    v20.CFIndex length = Count;
    FirstIndexOfCFTypeRef Value = CFArrayGetFirstIndexOfValue(v10, v20, (const void *)a1);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v10, FirstIndexOfValue);
      --Count;
    }

    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13 && (uint64_t v14 = *(__CFRunLoopSource **)(v13 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v13 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        uint64_t ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)Value, 0LL);
        int64_t v16 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, 1LL);
        CFRunLoopRemoveSource(ValueAtIndex, v14, v16);
        CFRelease(v14);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }

      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
    }

    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    uint64_t v17 = *(void *)(a1 + 32);
    if (v17)
    {
      uint64_t v18 = *(void **)(v17 + 56);
      if (v18)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        *(void *)(*(void *)(a1 + 32) + 56LL) = 0LL;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFRelease(v18);
        if (!Count) {
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v18);
        }
        CFRelease(v18);
        goto LABEL_32;
      }

      *(void *)(v17 + 56) = 0LL;
    }

    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
LABEL_32:
    *(void *)(a1 + 16) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
  }

uint64_t _CFStreamGetStatus(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = v2 & 0x1F;
  *(void *)(a1 + 16) = v2 | 0x40;
  if (result != 1) {
    goto LABEL_39;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 48);
  uint64_t v5 = (uint64_t (*)(uint64_t, __int128 *, void))v4[5];
  if (!v5) {
    goto LABEL_29;
  }
  if (*v4 <= 1)
  {
    __int128 v19 = 0uLL;
    int v6 = v5(a1, &v19, *(void *)(a1 + 40));
    if (DWORD2(v19))
    {
      uint64_t v7 = *(_OWORD **)(a1 + 24);
      if (!v7)
      {
        uint64_t v8 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v7 = CFAllocatorAllocate(v8, 16LL, 0LL);
        *(void *)(a1 + 24) = v7;
      }

      _OWORD *v7 = v19;
    }

    if (v6) {
      goto LABEL_9;
    }
LABEL_29:
    uint64_t result = 1LL;
    goto LABEL_39;
  }

uint64_t _CFStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

void __CFStreamDeallocate(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  uint64_t v3 = CFGetAllocator((CFTypeRef)a1);
  _CFStreamClose(a1);
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    if (v4[1])
    {
      uint64_t v5 = (void (*)(void))v4[3];
      if (v5)
      {
        v5();
        uint64_t v4 = *(void **)(a1 + 32);
      }
    }

    int v6 = (const void *)v4[8];
    if (v6)
    {
      CFRelease(v6);
      uint64_t v4 = *(void **)(a1 + 32);
    }

    CFAllocatorDeallocate(v3, v4);
    *(void *)(a1 + 32) = 0LL;
  }

  if (v2)
  {
    uint64_t v7 = (void (*)(void))v2[2];
    if (v7)
    {
      if (*v2) {
        ((void (*)(uint64_t, void))v7)(a1, *(void *)(a1 + 40));
      }
      else {
        v7(*(void *)(a1 + 40));
      }
    }

    uint64_t v8 = *(void **)(a1 + 24);
    if (v8)
    {
      if (*v2 <= 1)
      {
        CFAllocatorDeallocate(v3, v8);
        goto LABEL_19;
      }

      goto LABEL_18;
    }
  }

  else
  {
    uint64_t v8 = *(void **)(a1 + 24);
    if (v8) {
LABEL_18:
    }
      CFRelease(v8);
  }

CFStringRef __CFStreamCopyDescription(void *cf)
{
  uint64_t v2 = (void *)cf[6];
  uint64_t v3 = (uint64_t (*)(void))v2[3];
  if (v3)
  {
    if (*v2) {
      CFStringRef v4 = (CFStringRef)((uint64_t (*)(void *, void))v3)(cf, cf[5]);
    }
    else {
      CFStringRef v4 = (CFStringRef)v3(cf[5]);
    }
  }

  else
  {
    uint64_t v5 = CFGetAllocator(cf);
    CFStringRef v4 = CFStringCreateWithFormat(v5, 0LL, @"info = %p", cf[5]);
  }

  CFStringRef v6 = v4;
  CFTypeID v7 = CFGetTypeID(cf);
  uint64_t v8 = CFGetAllocator(cf);
  if (v7 == 38) {
    CFStringRef v9 = CFStringCreateWithFormat(v8, 0LL, @"<CFReadStream %p>{%@}", cf, v6);
  }
  else {
    CFStringRef v9 = CFStringCreateWithFormat(v8, 0LL, @"<CFWriteStream %p>{%@}", cf, v6);
  }
  CFStringRef v10 = v9;
  CFRelease(v6);
  return v10;
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return 38LL;
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return 39LL;
}

uint64_t _CFStreamCreateWithConstantCallbacks( const __CFAllocator *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 != 1LL) {
    return 0LL;
  }
  double v11 = _CFStreamCreate(a1, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v12 = v10;
  if (v10)
  {
    *(void *)(v10 + 16) |= 0x20uLL;
    *(void *)(v10 + 4_Block_object_dispose(va, 8) = a3;
    uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t, double))a3[1];
    if (v13) {
      a2 = v13(v10, a2, v11);
    }
    *(void *)(v12 + 40) = a2;
  }

  return v12;
}

double _CFStreamCreate( const __CFAllocator *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    unint64_t v8 = 38LL;
  }
  else {
    unint64_t v8 = 39LL;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, v8, 128LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    uint64_t v11 = *(void *)(Instance + 16);
    if ((v11 & 0x1E) != 6) {
      *(void *)(Instance + 16) = v11 & 0xFFFFFFE0;
    }
    *(void *)(Instance + 56) = 850045857LL;
    double result = 0.0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(void *)(Instance + 112) = 0LL;
  }

  return result;
}

void *CFReadStreamCreate( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  _CFStreamCreate(a1, 1, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = v11;
  if (v11)
  {
    uint64_t v13 = (char *)CFAllocatorAllocate(a1, 136LL, 0LL);
    if (v13)
    {
      uint64_t v14 = v13;
      if (*(void *)a2 == 1LL)
      {
        uint64_t v18 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        if (v18)
        {
          uint64_t v8 = v18(v12, v8);
          uint64_t v18 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        }

        v12[5] = v8;
        uint64_t v19 = 1LL;
      }

      else
      {
        if (!*(void *)a2)
        {
          uint64_t v15 = *(void *)(v8 + 8);
          int64_t v16 = *(uint64_t (**)(uint64_t))(v8 + 16);
          if (v16)
          {
            uint64_t v15 = v16(v15);
            int64_t v16 = *(uint64_t (**)(uint64_t))(v8 + 16);
          }

          v12[5] = v15;
          *(void *)uint64_t v14 = 0LL;
          *((void *)v14 + 1) = v16;
          *((_OWORD *)v14 + 1) = *(_OWORD *)(v8 + 24);
          *((_OWORD *)v14 + 2) = *(_OWORD *)(a2 + 8);
          *((_OWORD *)v14 + 3) = *(_OWORD *)(a2 + 24);
          *((void *)v14 + _Block_object_dispose(va, 8) = *(void *)(a2 + 40);
          *((void *)v14 + 9) = 0LL;
          *((void *)v14 + 10) = 0LL;
          *(_OWORD *)(v14 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
          *((void *)v14 + 13) = 0LL;
          *((void *)v14 + 14) = 0LL;
          *((void *)v14 + 15) = *(void *)(a2 + 64);
          uint64_t v17 = (void *)(a2 + 72);
          goto LABEL_16;
        }

        uint64_t v18 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        if (v18)
        {
          uint64_t v8 = v18(v12, v8);
          uint64_t v18 = *(uint64_t (**)(void *, uint64_t))(a2 + 8);
        }

        v12[5] = v8;
        uint64_t v19 = 2LL;
      }

      *(void *)uint64_t v14 = v19;
      *((void *)v14 + 1) = v18;
      *((_OWORD *)v14 + 1) = *(_OWORD *)(a2 + 16);
      *((_OWORD *)v14 + 2) = *(_OWORD *)(a2 + 32);
      *((_OWORD *)v14 + 3) = *(_OWORD *)(a2 + 48);
      *((void *)v14 + _Block_object_dispose(va, 8) = *(void *)(a2 + 64);
      *((void *)v14 + 9) = 0LL;
      *((void *)v14 + 10) = 0LL;
      *(_OWORD *)(v14 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(v14 + 104) = *(_OWORD *)(a2 + 88);
      *((void *)v14 + 15) = *(void *)(a2 + 104);
      uint64_t v17 = (void *)(a2 + 112);
LABEL_16:
      *((void *)v14 + 16) = *v17;
      v12[6] = v14;
      return v12;
    }

    CFRelease(v12);
    return 0LL;
  }

  return v12;
}

void *CFWriteStreamCreate( const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  _CFStreamCreate(a1, 0, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = v11;
  if (v11)
  {
    uint64_t v13 = CFAllocatorAllocate(a1, 136LL, 0LL);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *a2;
      if (*a2 == 1 || v15)
      {
        *uint64_t v13 = v15;
        uint64_t v19 = (uint64_t (*)(void *, uint64_t))a2[1];
        if (v19)
        {
          uint64_t v8 = v19(v12, v8);
          uint64_t v19 = (uint64_t (*)(void *, uint64_t))a2[1];
        }

        v12[5] = v8;
        v14[1] = v19;
        *((_OWORD *)v14 + 1) = *((_OWORD *)a2 + 1);
        *((_OWORD *)v14 + 2) = *((_OWORD *)a2 + 2);
        v14[7] = 0LL;
        v14[8] = 0LL;
        v14[6] = 0LL;
        *(_OWORD *)(v14 + 9) = *((_OWORD *)a2 + 3);
        *(_OWORD *)(v14 + 11) = *((_OWORD *)a2 + 4);
        *(_OWORD *)(v14 + 13) = *((_OWORD *)a2 + 5);
        v14[15] = a2[12];
        uint64_t v18 = a2 + 13;
      }

      else
      {
        uint64_t v16 = *(void *)(v8 + 8);
        uint64_t v17 = *(uint64_t (**)(uint64_t))(v8 + 16);
        if (v17)
        {
          uint64_t v16 = v17(v16);
          uint64_t v17 = *(uint64_t (**)(uint64_t))(v8 + 16);
        }

        v12[5] = v16;
        *uint64_t v14 = 0LL;
        v14[1] = v17;
        *((_OWORD *)v14 + 1) = *(_OWORD *)(v8 + 24);
        *((_OWORD *)v14 + 2) = *(_OWORD *)(a2 + 1);
        v14[7] = 0LL;
        v14[8] = 0LL;
        v14[6] = 0LL;
        *(_OWORD *)(v14 + 9) = *(_OWORD *)(a2 + 3);
        *(_OWORD *)(v14 + 11) = *(_OWORD *)(a2 + 5);
        v14[13] = 0LL;
        v14[14] = 0LL;
        v14[15] = a2[7];
        uint64_t v18 = a2 + 8;
      }

      v14[16] = *v18;
      v12[6] = v14;
    }

    else
    {
      CFRelease(v12);
      return 0LL;
    }
  }

  return v12;
}

void _CFStreamSignalEvent( char *cf, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v10 = *((void *)cf + 2);
  unint64_t v11 = v10 & 0x1F;
  if ((v10 & 0x1F) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"Stream %p is sending an event before being opened",  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)cf);
    goto LABEL_7;
  }

  if ((v10 & 0x1E) == 6)
  {
LABEL_7:
    unint64_t v13 = 0LL;
    goto LABEL_8;
  }

  unint64_t v13 = a2;
  if (v11 == 1)
  {
    if ((a2 & 1) != 0)
    {
      uint64_t v10 = v10 & 0xFFFFFFE0 | 2LL;
      *((void *)cf + 2) = v10;
    }

    goto LABEL_22;
  }

  if (v11 != 5)
  {
    unint64_t v13 = a2 & 0xFFFFFFFFFFFFFFFELL;
LABEL_22:
    if (v11 <= 4 && (v13 & 0x10) != 0 && (v10 & 0x1E) != 6) {
      *((void *)cf + 2) = v10 & 0xFFFFFFE0 | 5LL;
    }
    goto LABEL_30;
  }

  unint64_t v13 = a2 & 8;
LABEL_30:
  if ((v13 & 8) != 0)
  {
    if (**((uint64_t **)cf + 6) > 1)
    {
      CFRetain(a3);
      int64_t v25 = (const void *)*((void *)cf + 3);
      if (v25) {
        CFRelease(v25);
      }
      *((void *)cf + 3) = a3;
    }

    else
    {
      uint64_t v23 = (_OWORD *)*((void *)cf + 3);
      if (!v23)
      {
        int64_t v24 = CFGetAllocator(cf);
        uint64_t v23 = CFAllocatorAllocate(v24, 16LL, 0LL);
        *((void *)cf + 3) = v23;
      }

      _OWORD *v23 = *a3;
    }

    uint64_t v26 = *((void *)cf + 2);
    if ((v26 & 0x1F) != 7) {
      *((void *)cf + 2) = v26 & 0xFFFFFFE0 | 7LL;
    }
  }

void _cfstream_solo_signalEventSync(uint64_t a1)
{
  void block[5] = *MEMORY[0x1895F89C0];
  if ((CFGetTypeID((CFTypeRef)a1) & 0xFFFFFFFFFFFFFFFELL) == 0x26)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(_BYTE *)(a1 + 136))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    }

    else
    {
      int v8 = *(dispatch_queue_s **)(a1 + 128);
      if (v8)
      {
        dispatch_retain(*(dispatch_object_t *)(a1 + 128));
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFRetain((CFTypeRef)a1);
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        void block[2] = ___signalEventQueue_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a1;
        dispatch_async(v8, block);
        dispatch_release(v8);
      }

      else
      {
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        _signalEventSync(a1);
      }

      CFRelease((CFTypeRef)a1);
    }
  }

  else
  {
    CFLog(3LL, (uint64_t)@"Expected a read or write stream for %p", v2, v3, v4, v5, v6, v7, a1);
  }

void _wakeUpRunLoop(uint64_t a1)
{
  uint64_t v1 = _CFStreamCopyRunLoopsAndModes(a1);
  if (!v1) {
    return;
  }
  uint64_t v2 = v1;
  CFIndex Count = CFArrayGetCount(v1);
  if (Count == 2) {
    goto LABEL_3;
  }
  CFIndex v5 = Count;
  if (Count < 3) {
    goto LABEL_23;
  }
  uint64_t ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0LL);
  if (ValueAtIndex)
  {
    uint64_t v4 = ValueAtIndex;
    uint64_t v7 = 4LL;
    do
    {
      int v8 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v7 - 2);
      BOOL v9 = v8 == v4 && v7 < v5;
      v7 += 2LL;
    }

    while (v9);
    if (v8 != v4) {
      uint64_t v4 = 0LL;
    }
    if (v4) {
      goto LABEL_4;
    }
  }

  CFIndex v10 = 0LL;
  while (1)
  {
    uint64_t v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v10);
    CFRunLoopMode v11 = CFRunLoopCopyCurrentMode(v4);
    if (v11) {
      break;
    }
LABEL_21:
    v10 += 2LL;
    if (v10 >= v5) {
      goto LABEL_3;
    }
  }

  CFRunLoopMode v12 = v11;
  unint64_t v13 = CFArrayGetValueAtIndex(v2, v10 + 1);
  if (!CFEqual(v12, v13) || !CFRunLoopIsWaiting(v4))
  {
    CFRelease(v12);
    goto LABEL_21;
  }

  CFRelease(v12);
  if (v4)
  {
LABEL_4:
    CFRunLoopWakeUp(v4);
    goto LABEL_23;
  }

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  else {
    return _CFStreamGetStatus((uint64_t)stream);
  }
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  else {
    return _CFStreamGetStatus((uint64_t)stream);
  }
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  else {
    StreamCFErrorRef Error = _CFStreamGetStreamError((uint64_t)stream);
  }
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

__CFError *_CFStreamGetStreamError(uint64_t a1)
{
  CFStreamError result = *(__CFError **)(a1 + 24);
  if (result)
  {
    else {
      return *(__CFError **)result;
    }
  }

  return result;
}

CFStreamError CFWriteStreamGetError(CFWriteStreamRef stream)
{
  else {
    StreamCFErrorRef Error = _CFStreamGetStreamError((uint64_t)stream);
  }
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  else {
    return _CFStreamCopyError(stream);
  }
}

CFErrorRef _CFStreamCopyError(CFTypeRef cf)
{
  CFErrorRef result = (CFErrorRef)*((void *)cf + 3);
  if (result)
  {
    if (**((uint64_t **)cf + 6) > 1)
    {
      CFRetain(result);
      return (CFErrorRef)*((void *)cf + 3);
    }

    else
    {
      uint64_t v3 = CFGetAllocator(cf);
      return _CFStreamCreateErrorFromStreamError(v3, *((int **)cf + 3));
    }
  }

  return result;
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  else {
    return _CFStreamCopyError(stream);
  }
}

uint64_t _CFStreamOpen(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  if (!_CFStreamGetStatus(a1))
  {
    if ((*(void *)(a1 + 16) & 0x1ELL) == 6) {
      uint64_t v4 = *(void *)(a1 + 16) | 0x40LL;
    }
    else {
      uint64_t v4 = *(void *)(a1 + 16) & 0xFFFFFFA0LL | 0x41;
    }
    *(void *)(a1 + 16) = v4;
    CFIndex v5 = (uint64_t (*)(uint64_t, uint64_t, char *, void))v2[4];
    if (v5)
    {
      if (*v2 > 1)
      {
        uint64_t v3 = v5(a1, a1 + 24, &v16, *(void *)(a1 + 40));
      }

      else
      {
        __int128 v15 = 0uLL;
        uint64_t v3 = v5(a1, (uint64_t)&v15, &v16, *(void *)(a1 + 40));
        if (DWORD2(v15))
        {
          uint64_t v6 = *(_OWORD **)(a1 + 24);
          if (!v6)
          {
            uint64_t v7 = CFGetAllocator((CFTypeRef)a1);
            uint64_t v6 = CFAllocatorAllocate(v7, 16LL, 0LL);
            *(void *)(a1 + 24) = v6;
          }

          _OWORD *v6 = v15;
        }
      }

      if (!v16) {
        goto LABEL_33;
      }
      uint64_t v4 = *(void *)(a1 + 16);
      if (!(_DWORD)v3)
      {
        if ((*(void *)(a1 + 16) & 0x1FLL) != 7) {
          *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFE0LL | 7;
        }
        uint64_t v11 = *(void *)(a1 + 32);
        if (v11 && (*(_BYTE *)(v11 + 48) & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
          uint64_t v12 = *(void *)(a1 + 32);
          if (v12 && (unint64_t v13 = *(__CFRunLoopSource **)(v12 + 56)) != 0LL)
          {
            CFRetain(*(CFTypeRef *)(v12 + 56));
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
            *(void *)(*(void *)(a1 + 32) + 72LL) |= 8uLL;
            CFRunLoopSourceSignal(v13);
            CFRelease(v13);
            _wakeUpRunLoop(a1);
          }

          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          }
        }

        uint64_t v3 = 0LL;
        goto LABEL_33;
      }
    }

    else
    {
      uint64_t v3 = 1LL;
      char v16 = 1;
    }

    if ((v4 & 0x1F) == 1) {
      *(void *)(a1 + 16) = v4 & 0xFFFFFFE0 | 2LL;
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8 && (*(_BYTE *)(v8 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9 && (CFIndex v10 = *(__CFRunLoopSource **)(v9 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v9 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72LL) |= 1uLL;
        CFRunLoopSourceSignal(v10);
        CFRelease(v10);
        _wakeUpRunLoop(a1);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return 1;
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return 1;
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  else {
    _CFStreamClose((uint64_t)stream);
  }
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  else {
    _CFStreamClose((uint64_t)stream);
  }
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  uint64_t v3 = (uint64_t *)*((void *)stream + 6);
  uint64_t v4 = (uint64_t (*)(CFReadStreamRef, char *, void))v3[8];
  if (!v4) {
    return 1;
  }
  *((void *)stream + 2) |= 0x40uLL;
  if (*v3 > 1)
  {
    Boolean v2 = v4(stream, (char *)stream + 24, *((void *)stream + 5));
    if (*((void *)stream + 3))
    {
      uint64_t v5 = *((void *)stream + 2);
      if ((v5 & 0x1F) != 7) {
        *((void *)stream + 2) = v5 & 0xFFFFFFE0 | 7LL;
      }
      uint64_t v6 = *((void *)stream + 4);
      if (v6 && (*(_BYTE *)(v6 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v7 = *((void *)stream + 4);
        if (v7 && (uint64_t v8 = *(__CFRunLoopSource **)(v7 + 56)) != 0LL)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72LL) |= 8uLL;
          CFRunLoopSourceSignal(v8);
          CFRelease(v8);
          _wakeUpRunLoop((uint64_t)stream);
        }

        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }

  else
  {
    Boolean v2 = ((uint64_t (*)(CFReadStreamRef, void))v4)(stream, *((void *)stream + 5));
  }

  *((void *)stream + 2) &= ~0x40uLL;
  return v2;
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  uint64_t v8 = *((void *)stream + 6);
  if (Status == 1)
  {
    *((void *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((void *)stream + 2) &= ~0x40uLL;
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  }

  if ((unint64_t)(Status - 2) >= 2)
  {
    if (Status == 5) {
      return 0LL;
    }
    else {
      return -1LL;
    }
  }

  else
  {
    uint64_t v9 = *((void *)stream + 2);
    *((void *)stream + 2) = v9 | 0x40;
    uint64_t v10 = *((void *)stream + 4);
    if (v10) {
      *(void *)(v10 + 72) &= ~2uLL;
    }
    if ((v9 & 0x1E) != 6) {
      *((void *)stream + 2) = v9 & 0xFFFFFFA0 | 0x43LL;
    }
    if (*(uint64_t *)v8 > 1)
    {
      CFIndex v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, char *, char *, void))(v8 + 48))( stream,  buffer,  bufferLength,  (char *)stream + 24,  &v22,  *((void *)stream + 5));
    }

    else
    {
      __int128 v21 = 0uLL;
      CFIndex v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, __int128 *, char *, void))(v8 + 48))( stream,  buffer,  bufferLength,  &v21,  &v22,  *((void *)stream + 5));
      if (DWORD2(v21))
      {
        uint64_t v12 = (_OWORD *)*((void *)stream + 3);
        if (!v12)
        {
          unint64_t v13 = CFGetAllocator(stream);
          uint64_t v12 = CFAllocatorAllocate(v13, 16LL, 0LL);
          *((void *)stream + 3) = v12;
        }

        *uint64_t v12 = v21;
      }
    }

    if (*((void *)stream + 3))
    {
      uint64_t v14 = *((void *)stream + 2);
      if ((v14 & 0x1F) != 7) {
        *((void *)stream + 2) = v14 & 0xFFFFFFE0 | 7LL;
      }
      uint64_t v15 = *((void *)stream + 4);
      if (v15 && (*(_BYTE *)(v15 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v16 = *((void *)stream + 4);
        if (v16 && (uint64_t v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0LL)
        {
          CFRetain(*(CFTypeRef *)(v16 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72LL) |= 8uLL;
          CFRunLoopSourceSignal(v17);
          CFRelease(v17);
          _wakeUpRunLoop((uint64_t)stream);
        }

        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }

      CFIndex v11 = -1LL;
    }

    else if (v22)
    {
      if ((*((void *)stream + 2) & 0x1ELL) != 6) {
        *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0LL | 5;
      }
      uint64_t v18 = *((void *)stream + 4);
      if (v18 && (*(_BYTE *)(v18 + 48) & 0x10) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v19 = *((void *)stream + 4);
        if (v19 && (int v20 = *(__CFRunLoopSource **)(v19 + 56)) != 0LL)
        {
          CFRetain(*(CFTypeRef *)(v19 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72LL) |= 0x10uLL;
          CFRunLoopSourceSignal(v20);
          CFRelease(v20);
          _wakeUpRunLoop((uint64_t)stream);
        }

        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }

    else if ((*((void *)stream + 2) & 0x1ELL) != 6)
    {
      *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0LL | 2;
    }

    *((void *)stream + 2) &= ~0x40uLL;
  }

  return v11;
}

uint64_t waitForOpen(uint64_t a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  _CFStreamScheduleWithRunLoop((char *)a1, Current, @"_kCFStreamBlockingOpenMode");
  while ((*(void *)(a1 + 16) & 0x1FLL) == 1)
    CFRunLoopRunInMode(@"_kCFStreamBlockingOpenMode", 1.0e20, 1u);
  return _CFStreamUnscheduleFromRunLoop(a1, Current, @"_kCFStreamBlockingOpenMode");
}

const UInt8 *__cdecl CFReadStreamGetBuffer(CFReadStreamRef stream, CFIndex maxBytesToRead, CFIndex *numBytesRead)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    *(void *)&__int128 v25 = 0LL;
    else {
      return 0LL;
    }
  }

  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  uint64_t v8 = (uint64_t *)*((void *)stream + 6);
  if (Status == 1)
  {
    *((void *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((void *)stream + 2) &= ~0x40uLL;
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  }

  if ((unint64_t)(Status - 2) >= 2)
  {
    if (Status != 5)
    {
      uint64_t v6 = 0LL;
      *numBytesRead = -1LL;
      return v6;
    }

    goto LABEL_13;
  }

  uint64_t v9 = (uint64_t (*)(CFReadStreamRef, CFIndex, CFIndex *, char *, char *, void))v8[7];
  if (!v9)
  {
LABEL_13:
    uint64_t v6 = 0LL;
    *numBytesRead = 0LL;
    return v6;
  }

  uint64_t v10 = *((void *)stream + 4);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 + 72);
    uint64_t v12 = (uint64_t *)((char *)stream + 16);
    uint64_t v13 = *((void *)stream + 2) | 0x40LL;
    *((void *)stream + 2) = v13;
    if ((v11 & 2) != 0)
    {
      *(void *)(v10 + 72) = v11 & 0xFFFFFFFFFFFFFFFDLL;
      char v14 = 1;
    }

    else
    {
      char v14 = 0;
    }
  }

  else
  {
    char v14 = 0;
    uint64_t v12 = (uint64_t *)((char *)stream + 16);
    uint64_t v13 = *((void *)stream + 2) | 0x40LL;
    *((void *)stream + 2) = v13;
  }

  if ((v13 & 0x1E) != 6) {
    *uint64_t v12 = v13 & 0xFFFFFFE0 | 3LL;
  }
  if (*v8 > 1)
  {
    uint64_t v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)stream + 24, &v26, *((void *)stream + 5));
  }

  else
  {
    __int128 v25 = 0uLL;
    uint64_t v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)&v25, &v26, *((void *)stream + 5));
    if (DWORD2(v25))
    {
      uint64_t v15 = (_OWORD *)*((void *)stream + 3);
      if (!v15)
      {
        uint64_t v16 = CFGetAllocator(stream);
        uint64_t v15 = CFAllocatorAllocate(v16, 16LL, 0LL);
        *((void *)stream + 3) = v15;
      }

      *uint64_t v15 = v25;
    }
  }

  if (*((void *)stream + 3))
  {
    *numBytesRead = -1LL;
    if ((*v12 & 0x1F) != 7) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0LL | 7;
    }
    uint64_t v17 = *((void *)stream + 4);
    if (v17 && (*(_BYTE *)(v17 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v18 = *((void *)stream + 4);
      if (v18 && (uint64_t v19 = *(__CFRunLoopSource **)(v18 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v18 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(void *)(*((void *)stream + 4) + 72LL) |= 8uLL;
        CFRunLoopSourceSignal(v19);
        CFRelease(v19);
        _wakeUpRunLoop((uint64_t)stream);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }

    uint64_t v6 = 0LL;
  }

  else if (v26)
  {
    if ((*v12 & 0x1E) != 6) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0LL | 5;
    }
    uint64_t v20 = *((void *)stream + 4);
    if (v20 && (*(_BYTE *)(v20 + 48) & 0x10) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v21 = *((void *)stream + 4);
      if (v21 && (char v22 = *(__CFRunLoopSource **)(v21 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v21 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(void *)(*((void *)stream + 4) + 72LL) |= 0x10uLL;
        CFRunLoopSourceSignal(v22);
        CFRelease(v22);
        _wakeUpRunLoop((uint64_t)stream);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }
  }

  else
  {
    char v23 = v14 ^ 1;
    if (v6) {
      char v23 = 1;
    }
    if ((v23 & 1) == 0) {
      *(void *)(*((void *)stream + 4) + 72LL) |= 2uLL;
    }
    if ((*v12 & 0x1E) != 6) {
      *uint64_t v12 = *v12 & 0xFFFFFFE0LL | 2;
    }
  }

  *v12 &= ~0x40uLL;
  return v6;
}

Boolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream)
{
  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  if (Status != 4 && Status != 2) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)*((void *)stream + 6);
  uint64_t v5 = (uint64_t (*)(CFWriteStreamRef, char *, void))v4[10];
  if (!v5) {
    return 1;
  }
  *((void *)stream + 2) |= 0x40uLL;
  if (*v4 > 1)
  {
    Boolean v2 = v5(stream, (char *)stream + 24, *((void *)stream + 5));
    if (*((void *)stream + 3))
    {
      uint64_t v6 = *((void *)stream + 2);
      if ((v6 & 0x1F) != 7) {
        *((void *)stream + 2) = v6 & 0xFFFFFFE0 | 7LL;
      }
      uint64_t v7 = *((void *)stream + 4);
      if (v7 && (*(_BYTE *)(v7 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        uint64_t v8 = *((void *)stream + 4);
        if (v8 && (uint64_t v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0LL)
        {
          CFRetain(*(CFTypeRef *)(v8 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(void *)(*((void *)stream + 4) + 72LL) |= 8uLL;
          CFRunLoopSourceSignal(v9);
          CFRelease(v9);
          _wakeUpRunLoop((uint64_t)stream);
        }

        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }

  else
  {
    Boolean v2 = ((uint64_t (*)(CFWriteStreamRef, void))v5)(stream, *((void *)stream + 5));
  }

  *((void *)stream + 2) &= ~0x40uLL;
  return v2;
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  uint64_t v8 = *((void *)stream + 6);
  if (Status == 1)
  {
    *((void *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((void *)stream + 2) &= ~0x40uLL;
    uint64_t Status = _CFStreamGetStatus((uint64_t)stream);
  }

  if (Status == 4 || Status == 2)
  {
    if ((*((void *)stream + 2) & 0x1ELL) == 6) {
      uint64_t v9 = *((void *)stream + 2) | 0x40LL;
    }
    else {
      uint64_t v9 = *((void *)stream + 2) & 0xFFFFFFA0LL | 0x44;
    }
    *((void *)stream + 2) = v9;
    uint64_t v10 = *((void *)stream + 4);
    if (v10) {
      *(void *)(v10 + 72) &= ~4uLL;
    }
    if (*(uint64_t *)v8 > 1)
    {
      CFIndex v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, char *, void))(v8 + 72))( stream,  buffer,  bufferLength,  (char *)stream + 24,  *((void *)stream + 5));
    }

    else
    {
      __int128 v23 = 0uLL;
      CFIndex v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, __int128 *, void))(v8 + 72))( stream,  buffer,  bufferLength,  &v23,  *((void *)stream + 5));
      if (DWORD2(v23))
      {
        uint64_t v12 = (_OWORD *)*((void *)stream + 3);
        if (!v12)
        {
          uint64_t v13 = CFGetAllocator(stream);
          uint64_t v12 = CFAllocatorAllocate(v13, 16LL, 0LL);
          *((void *)stream + 3) = v12;
        }

        *uint64_t v12 = v23;
      }
    }

    if (*((void *)stream + 3))
    {
      uint64_t v14 = *((void *)stream + 2);
      if ((v14 & 0x1F) != 7) {
        *((void *)stream + 2) = v14 & 0xFFFFFFE0 | 7LL;
      }
      uint64_t v15 = *((void *)stream + 4);
      if (!v15 || (*(_BYTE *)(v15 + 48) & 8) == 0) {
        goto LABEL_39;
      }
      uint64_t v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v17 = *((void *)stream + 4);
      if (v17)
      {
        uint64_t v18 = *(__CFRunLoopSource **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v19 = *((void *)stream + 4);
          uint64_t v20 = *(void *)(v19 + 72) | 8LL;
LABEL_26:
          *(void *)(v19 + 72) = v20;
          CFRunLoopSourceSignal(v18);
          CFRelease(v18);
          _wakeUpRunLoop((uint64_t)stream);
LABEL_39:
          *((void *)stream + 2) &= ~0x40uLL;
          return v11;
        }
      }
    }

    else
    {
      if (v11)
      {
        if ((*((void *)stream + 2) & 0x1ELL) != 6) {
          *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0LL | 2;
        }
        goto LABEL_39;
      }

      if ((*((void *)stream + 2) & 0x1ELL) != 6) {
        *((void *)stream + 2) = *((void *)stream + 2) & 0xFFFFFFE0LL | 5;
      }
      uint64_t v21 = *((void *)stream + 4);
      if (!v21 || (*(_BYTE *)(v21 + 48) & 0x10) == 0) {
        goto LABEL_39;
      }
      uint64_t v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      uint64_t v22 = *((void *)stream + 4);
      if (v22)
      {
        uint64_t v18 = *(__CFRunLoopSource **)(v22 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v22 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          uint64_t v19 = *((void *)stream + 4);
          uint64_t v20 = *(void *)(v19 + 72) | 0x10LL;
          goto LABEL_26;
        }
      }
    }

    pthread_mutex_unlock(v16);
    goto LABEL_39;
  }

  return -1LL;
}

uint64_t _CFStreamCopyProperty(void *a1, uint64_t a2)
{
  Boolean v2 = *(uint64_t (**)(void *, uint64_t, void))(a1[6] + 96LL);
  if (!v2) {
    return 0LL;
  }
  a1[2] |= 0x40uLL;
  uint64_t result = v2(a1, a2, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  uint64_t v5 = *(uint64_t (**)(CFReadStreamRef, CFStreamPropertyKey, void))(*((void *)stream + 6) + 96LL);
  if (!v5) {
    return 0LL;
  }
  *((void *)stream + 2) |= 0x40uLL;
  CFTypeRef result = (CFTypeRef)v5(stream, propertyName, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  uint64_t v5 = *(uint64_t (**)(CFWriteStreamRef, CFStreamPropertyKey, void))(*((void *)stream + 6) + 96LL);
  if (!v5) {
    return 0LL;
  }
  *((void *)stream + 2) |= 0x40uLL;
  CFTypeRef result = (CFTypeRef)v5(stream, propertyName, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

uint64_t _CFStreamSetProperty(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t, uint64_t, void))(a1[6] + 104LL);
  if (!v3) {
    return 0LL;
  }
  a1[2] |= 0x40uLL;
  uint64_t result = v3(a1, a2, a3, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

Boolean CFReadStreamSetProperty( CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  if (!v7) {
    return 0;
  }
  *((void *)stream + 2) |= 0x40uLL;
  Boolean result = v7(stream, propertyName, propertyValue, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

Boolean CFWriteStreamSetProperty( CFWriteStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  if (!v7) {
    return 0;
  }
  *((void *)stream + 2) |= 0x40uLL;
  Boolean result = v7(stream, propertyName, propertyValue, *((void *)stream + 5));
  *((void *)stream + 2) &= ~0x40uLL;
  return result;
}

uint64_t _CFStreamSetClient(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    BOOL v6 = a3 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  BOOL v7 = v6 || a4 == 0;
  char v8 = v7;
  if (v7) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = a3;
  }
  if (v7) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = a2;
  }
  uint64_t v11 = a1[4];
  if (v11)
  {
LABEL_17:
    if (*(void *)(v11 + 40))
    {
      uint64_t v12 = *(void (**)(void))(v11 + 24);
      if (v12)
      {
        v12(*(void *)(v11 + 8));
        uint64_t v11 = a1[4];
      }
    }

    *(void *)(v11 + 40) = v9;
    if ((v8 & 1) != 0)
    {
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + _Block_object_dispose(va, 8) = 0u;
    }

    else
    {
      *(_OWORD *)(v11 + 16) = *(_OWORD *)(a4 + 16);
      uint64_t v14 = *(void *)(a4 + 8);
      *(void *)uint64_t v11 = *(void *)a4;
      *(void *)(v11 + 32) = *(void *)(a4 + 32);
      uint64_t v15 = *(uint64_t (**)(void))(a4 + 16);
      if (v15 && v14)
      {
        uint64_t v14 = v15();
        uint64_t v11 = a1[4];
      }

      *(void *)(v11 + _Block_object_dispose(va, 8) = v14;
    }

    if (*(void *)(v11 + 48) != v10)
    {
      uint64_t v16 = a1[6];
      *(void *)(v11 + 4_Block_object_dispose(va, 8) = v10;
      uint64_t v17 = *(void (**)(void *, uint64_t, void))(v16 + 112);
      if (v17) {
        v17(a1, v10, a1[5]);
      }
    }

    return 1LL;
  }

  if ((v8 & 1) == 0)
  {
    _initializeClient(a1);
    uint64_t v11 = a1[4];
    if (!v11) {
      return 0LL;
    }
    goto LABEL_17;
  }

  return 1LL;
}

double _initializeClient(void *a1)
{
  Boolean v2 = CFGetAllocator(a1);
  uint64_t v3 = CFAllocatorAllocate(v2, 80LL, 0LL);
  a1[4] = v3;
  double result = 0.0;
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  void v3[2] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  return result;
}

double _CFReadStreamInitialize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 56) = 850045857LL;
    double result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(void *)(a1 + 112) = 0LL;
  }

  return result;
}

double _CFWriteStreamInitialize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 56) = 850045857LL;
    double result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(void *)(a1 + 112) = 0LL;
  }

  return result;
}

Boolean CFReadStreamSetClient( CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    return -[__CFReadStream _setCFClientFlags:callback:context:]( stream,  "_setCFClientFlags:callback:context:",  streamEvents,  clientCB,  clientContext);
  }
  if (clientCB)
  {
    uint64_t v9 = -[_CFStreamDelegate initWithStreamEvents:callback:context:]( objc_alloc(&OBJC_CLASS____CFStreamDelegate),  "initWithStreamEvents:callback:context:",  streamEvents,  clientCB,  clientContext);
    -[__CFReadStream setDelegate:](stream, "setDelegate:", v9);
    uint64_t v10 = (const void *)objc_opt_class();
    objc_setAssociatedObject(stream, v10, v9, (void *)0x301);
  }

  else
  {
    -[__CFReadStream setDelegate:](stream, "setDelegate:", 0LL);
  }

  return 1;
}

Boolean CFWriteStreamSetClient( CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    return -[__CFWriteStream _setCFClientFlags:callback:context:]( stream,  "_setCFClientFlags:callback:context:",  streamEvents,  clientCB,  clientContext);
  }
  if (clientCB)
  {
    uint64_t v9 = -[_CFStreamDelegate initWithStreamEvents:callback:context:]( objc_alloc(&OBJC_CLASS____CFStreamDelegate),  "initWithStreamEvents:callback:context:",  streamEvents,  clientCB,  clientContext);
    -[__CFWriteStream setDelegate:](stream, "setDelegate:", v9);
    uint64_t v10 = (const void *)objc_opt_class();
    objc_setAssociatedObject(stream, v10, v9, (void *)0x301);
  }

  else
  {
    -[__CFWriteStream setDelegate:](stream, "setDelegate:", 0LL);
  }

  return 1;
}

uint64_t _CFReadStreamGetClient(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    return *(void *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

uint64_t _CFWriteStreamGetClient(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    return *(void *)(v1 + 8);
  }
  else {
    return 0LL;
  }
}

void _CFStreamScheduleWithRunLoop(char *cf, void *a2, const __CFString *a3)
{
  values[2] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v6 = *((void *)cf + 6);
  uint64_t v7 = *((void *)cf + 4);
  if (!v7)
  {
    _initializeClient(cf);
    uint64_t v7 = *((void *)cf + 4);
    if (!v7) {
      return;
    }
  }

  if (!*(void *)(v7 + 56))
  {
    values[0] = a2;
    values[1] = (void *)a3;
    CFArrayRef v10 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)values,  2LL,  &kCFTypeArrayCallBacks);
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFMutableArrayRef Mutable = (const __CFDictionary *)sSharedSources;
    if (!sSharedSources)
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      sSharedSources = (uint64_t)Mutable;
    }

    CFTypeRef Value = (const __CFArray *)CFDictionaryGetValue(Mutable, v10);
    if (!Value)
    {
      *(_OWORD *)&v46.copyDescription = xmmword_18999CD30;
      *(_OWORD *)&v46.hash = unk_18999CD40;
      *(_OWORD *)&v46.cancel = xmmword_18999CD50;
      v46.version = 0LL;
      *(_OWORD *)&v46.retain = *(_OWORD *)&off_18999CD20;
      CFMutableArrayRef v13 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
      CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, v10, v13);
      v46.info = v13;
      CFRunLoopSourceRef v31 = CFRunLoopSourceCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &v46);
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      uint64_t v32 = *((void *)cf + 4);
      if (v32)
      {
        uint64_t v33 = *(const void **)(v32 + 56);
        if (v33)
        {
          CFRetain(*(CFTypeRef *)(v32 + 56));
          uint64_t v32 = *((void *)cf + 4);
        }

        *(void *)(v32 + 56) = v31;
        if (v31) {
          CFRetain(v31);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        if (v33)
        {
          CFRelease(v33);
          CFRelease(v33);
        }
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }

      CFRunLoopAddSource((CFRunLoopRef)a2, v31, a3);
      CFRelease(v31);
      goto LABEL_57;
    }

    CFMutableArrayRef v13 = Value;
    uint64_t ValueAtIndex = (char *)CFArrayGetValueAtIndex(Value, 0LL);
    if (ValueAtIndex)
    {
      uint64_t v15 = ValueAtIndex;
      uint64_t v16 = (pthread_mutex_t *)(ValueAtIndex + 56);
      pthread_mutex_lock((pthread_mutex_t *)(ValueAtIndex + 56));
      uint64_t v17 = *((void *)v15 + 4);
      if (v17)
      {
        uint64_t v18 = *(const void **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock(v16);
          pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
          uint64_t v19 = *((void *)cf + 4);
          if (v19)
          {
            uint64_t v20 = *(const void **)(v19 + 56);
            if (v20)
            {
              CFRetain(*(CFTypeRef *)(v19 + 56));
              *(void *)(*((void *)cf + 4) + 56LL) = v18;
              CFRetain(v18);
              pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
              CFRelease(v20);
              CFRelease(v20);
LABEL_55:
              CFRelease(v18);
              goto LABEL_56;
            }

            *(void *)(v19 + 56) = v18;
            CFRetain(v18);
          }

          pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
          goto LABEL_55;
        }
      }

      pthread_mutex_unlock(v16);
    }

void _cfstream_shared_signalEventSync(const void *a1)
{
  void block[5] = *MEMORY[0x1895F89C0];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFArrayGetTypeID())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      CFIndex v10 = 0LL;
      uint64_t v12 = 0LL;
      CFMutableArrayRef v13 = 0LL;
    }

    else
    {
      CFIndex v10 = 0LL;
      while (1)
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (!*((_BYTE *)ValueAtIndex + 136))
        {
          uint64_t v12 = (uint64_t)ValueAtIndex;
          if (*(void *)(ValueAtIndex[4] + 72LL)) {
            break;
          }
        }

        if (Count == ++v10)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
          return;
        }
      }

      CFRetain(ValueAtIndex);
      CFMutableArrayRef v13 = *(dispatch_queue_s **)(v12 + 128);
      if (v13) {
        dispatch_retain(*(dispatch_object_t *)(v12 + 128));
      }
      *(_BYTE *)(v12 + 136) = 1;
    }

    if (v10 < Count)
    {
      while (1)
      {
        uint64_t v14 = (char *)CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (v14 != (char *)v12)
        {
          uint64_t v15 = v14;
          if (!v14[136])
          {
            if (*(void *)(*((void *)v14 + 4) + 72LL)) {
              break;
            }
          }
        }

        if (Count == ++v10) {
          goto LABEL_18;
        }
      }

      pthread_mutex_lock((pthread_mutex_t *)(v14 + 56));
      uint64_t v16 = *((void *)v15 + 4);
      if (v16 && (uint64_t v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v16 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
        CFRunLoopSourceSignal(v17);
        CFRelease(v17);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
      }
    }

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      -[__CFReadStream _scheduleInCFRunLoop:forMode:](stream, "_scheduleInCFRunLoop:forMode:", runLoop, runLoopMode);
    }
    else {
      -[__CFReadStream scheduleInRunLoop:forMode:]( stream,  "scheduleInRunLoop:forMode:",  _CFRunLoopGet2((uint64_t)runLoop),  runLoopMode);
    }
  }

  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      -[__CFWriteStream _scheduleInCFRunLoop:forMode:](stream, "_scheduleInCFRunLoop:forMode:", runLoop, runLoopMode);
    }
    else {
      -[__CFWriteStream scheduleInRunLoop:forMode:]( stream,  "scheduleInRunLoop:forMode:",  _CFRunLoopGet2((uint64_t)runLoop),  runLoopMode);
    }
  }

  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }

uint64_t _CFStreamUnscheduleFromRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(void *)(result + 32);
  if (!v3 || !*(void *)(v3 + 56)) {
    return result;
  }
  uint64_t v6 = result;
  uint64_t v7 = *(void *)(result + 48);
  if ((*(_BYTE *)(result + 17) & 1) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(result + 56));
    uint64_t v8 = *(void *)(v6 + 32);
    if (v8 && (CFRunLoopSourceRef v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0LL)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v9, a3);
      CFRelease(v9);
    }

    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }

    goto LABEL_24;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
  CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)v6);
  uint64_t v11 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
  CFIndex Count = CFArrayGetCount(v11);
  v26.CFIndex location = 0LL;
  v26.CFIndex length = Count;
  FirstIndexOfCFTypeRef Value = CFArrayGetFirstIndexOfValue(v11, v26, (const void *)v6);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(v11, FirstIndexOfValue);
    --Count;
  }

  if (!Count)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
    uint64_t v14 = *(void *)(v6 + 32);
    if (v14 && (uint64_t v15 = *(__CFRunLoopSource **)(v14 + 56)) != 0LL)
    {
      CFRetain(*(CFTypeRef *)(v14 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v15, a3);
      CFRelease(v15);
    }

    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }

    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
  }

  CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)v6);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  uint64_t v16 = *(void *)(v6 + 32);
  if (v16)
  {
    uint64_t v17 = *(void **)(v16 + 56);
    if (v17)
    {
      CFRetain(*(CFTypeRef *)(v16 + 56));
      *(void *)(*(void *)(v6 + 32) + 56LL) = 0LL;
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRelease(v17);
      if (!Count) {
        CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v17);
      }
      CFRelease(v17);
      goto LABEL_23;
    }

    *(void *)(v16 + 56) = 0LL;
  }

  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
LABEL_23:
  *(void *)(v6 + 16) &= ~0x100uLL;
  os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
LABEL_24:
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  uint64_t v18 = *(void *)(v6 + 32);
  uint64_t v19 = *(const __CFArray **)(v18 + 64);
  if (v19)
  {
    CFIndex v20 = CFArrayGetCount(*(CFArrayRef *)(v18 + 64));
    if (v20 >= 2)
    {
      CFIndex v21 = v20;
      CFIndex v22 = 1LL;
      while (1)
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v19, v22 - 1);
        if (CFEqual(ValueAtIndex, a2))
        {
          uint64_t v24 = CFArrayGetValueAtIndex(v19, v22);
          if (CFEqual(v24, a3)) {
            break;
          }
        }

        v22 += 2LL;
        if (v22 >= v21) {
          goto LABEL_32;
        }
      }

      CFArrayRemoveValueAtIndex(v19, v22 - 1);
      CFArrayRemoveValueAtIndex(v19, v22 - 1);
    }
  }

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      -[__CFReadStream _unscheduleFromCFRunLoop:forMode:]( stream,  "_unscheduleFromCFRunLoop:forMode:",  runLoop,  runLoopMode);
    }
    else {
      -[__CFReadStream removeFromRunLoop:forMode:]( stream,  "removeFromRunLoop:forMode:",  _CFRunLoopGet2((uint64_t)runLoop),  runLoopMode);
    }
  }

  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }

void CFWriteStreamUnscheduleFromRunLoop( CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      -[__CFWriteStream _unscheduleFromCFRunLoop:forMode:]( stream,  "_unscheduleFromCFRunLoop:forMode:",  runLoop,  runLoopMode);
    }
    else {
      -[__CFWriteStream removeFromRunLoop:forMode:]( stream,  "removeFromRunLoop:forMode:",  _CFRunLoopGet2((uint64_t)runLoop),  runLoopMode);
    }
  }

  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }

uint64_t _CFStreamSetDispatchQueue(uint64_t a1, dispatch_object_s *a2)
{
  uint64_t v4 = _CFStreamCopyRunLoopsAndModes(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0LL; i < v7; i += 2LL)
      {
        uint64_t ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v5, i);
        CFIndex v10 = (const __CFString *)CFArrayGetValueAtIndex(v5, i + 1);
        _CFStreamUnscheduleFromRunLoop(a1, ValueAtIndex, v10);
      }
    }

    CFRelease(v5);
  }

  if (a2)
  {
    if (_legacyStreamRunLoop_sOnce != -1) {
      dispatch_once(&_legacyStreamRunLoop_sOnce, &__block_literal_global_17);
    }
    _CFStreamScheduleWithRunLoop((char *)a1, (void *)sLegacyRL, @"kCFRunLoopDefaultMode");
    uint64_t v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(void *)(a1 + 32))
    {
      uint64_t v12 = *(dispatch_object_s **)(a1 + 128);
      if (v12 != a2)
      {
        if (v12) {
          dispatch_release(v12);
        }
        *(void *)(a1 + 12_Block_object_dispose(va, 8) = a2;
        dispatch_retain(a2);
      }
    }
  }

  else
  {
    uint64_t v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(void *)(a1 + 32))
    {
      CFMutableArrayRef v13 = *(dispatch_object_s **)(a1 + 128);
      if (v13) {
        dispatch_release(v13);
      }
      *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
    }
  }

  return pthread_mutex_unlock(v11);
}

dispatch_object_s *_CFStreamCopyDispatchQueue(uint64_t a1)
{
  CFTypeID v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (*(void *)(a1 + 32))
  {
    uint64_t v3 = *(dispatch_object_s **)(a1 + 128);
    if (v3) {
      dispatch_retain(v3);
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  pthread_mutex_unlock(v2);
  return v3;
}

CFArrayRef _CFStreamCopyRunLoopsAndModes(uint64_t a1)
{
  CFArrayRef Copy = (CFArrayRef)a1;
  if (a1)
  {
    if (*(void *)(a1 + 32))
    {
      CFTypeID v2 = (pthread_mutex_t *)(a1 + 56);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      if (*(void *)(*((void *)Copy + 4) + 64LL))
      {
        uint64_t v3 = CFGetAllocator(Copy);
        CFArrayRef Copy = CFArrayCreateCopy(v3, *(CFArrayRef *)(*((void *)Copy + 4) + 64LL));
      }

      else
      {
        CFArrayRef Copy = 0LL;
      }

      pthread_mutex_unlock(v2);
    }

    else
    {
      return 0LL;
    }
  }

  return Copy;
}

void CFReadStreamSignalEvent( char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFWriteStreamSignalEvent( char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFReadStreamSignalEventDelayed( char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _CFReadStreamClearEvent(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (v2) {
    *(void *)(v2 + 72) &= ~a2;
  }
  return result;
}

void _CFWriteStreamSignalEventDelayed( char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t CFReadStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t CFWriteStreamGetInfoPointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t _CFStreamInstanceSize()
{
  return 128LL;
}

uint64_t _signalEventSync(uint64_t a1)
{
  *(void *)(a1 + 16) |= 0x40uLL;
  uint64_t v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3 && (unint64_t v4 = v3[9]) != 0)
  {
    uint64_t v5 = (uint64_t (*)(uint64_t, unint64_t, uint64_t))v3[5];
    uint64_t v7 = v3[1];
    uint64_t v6 = (uint64_t (*)(void))v3[2];
    if (v6)
    {
      uint64_t v7 = v6(v3[1]);
      uint64_t v3 = *(void **)(a1 + 32);
      uint64_t v8 = (uint64_t (*)(uint64_t))v3[3];
      unint64_t v4 = v3[9];
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    v3[9] = 0LL;
    *(_BYTE *)(a1 + 136) = 0;
    uint64_t result = pthread_mutex_unlock(v2);
    if (v4)
    {
      for (unint64_t i = 1LL; i <= v4; i *= 2LL)
      {
        pthread_mutex_lock(v2);
        if ((i & v4) != 0 && (uint64_t v11 = *(void *)(a1 + 32)) != 0)
        {
          unint64_t v12 = *(void *)(v11 + 48) & i;
          uint64_t result = pthread_mutex_unlock(v2);
          if (v12) {
            uint64_t result = v5(a1, i, v7);
          }
        }

        else
        {
          uint64_t result = pthread_mutex_unlock(v2);
        }
      }
    }

    if (v8) {
      uint64_t result = v8(v7);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 136) = 0;
    uint64_t result = pthread_mutex_unlock(v2);
  }

  *(void *)(a1 + 16) &= ~0x40uLL;
  return result;
}

void ___signalEventQueue_block_invoke(uint64_t a1)
{
}

void ___legacyStreamRunLoop_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  sLegacyRL = 0LL;
  dispatch_semaphore_t dsema = dispatch_semaphore_create(0LL);
  pthread_attr_init(&__attr);
  pthread_attr_setdetachstate(&__attr, 2);
  qos_class_t v0 = qos_class_main();
  pthread_attr_set_qos_class_np(&__attr, v0, 0);
  pthread_create(&v1, &__attr, (void *(__cdecl *)(void *))_legacyStreamRunLoop_workThread, &dsema);
  pthread_attr_destroy(&__attr);
  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(dsema);
}

void _legacyStreamRunLoop_workThread(dispatch_semaphore_t *a1)
{
  sLegacyRL = (uint64_t)CFRunLoopGetCurrent();
  uint64_t v2 = (__CFString *)CFStringCreateWithFormat(0LL, 0LL, @"<< CFStreamLegacySource for Runloop %p >>", sLegacyRL);
  context.version = 0LL;
  context.info = v2;
  context.retain = CFRetain;
  context.release = CFRelease;
  context.copyDescription = CFCopyDescription;
  context.equal = CFEqual;
  context.hash = CFHash;
  context.schedule = 0LL;
  context.cancel = 0LL;
  context.perform = (void (__cdecl *)(void *))_perform;
  uint64_t v3 = CFRunLoopSourceCreate(0LL, 0LL, &context);
  CFRelease(v2);
  CFRunLoopAddSource((CFRunLoopRef)sLegacyRL, v3, @"kCFRunLoopDefaultMode");
  CFRelease(v3);
  dispatch_semaphore_signal(*a1);
  while (1)
    CFRunLoopRunInMode(@"kCFRunLoopDefaultMode", 1.0e30, 1u);
}

void _perform()
{
  do
    unint64_t v0 = __ldxr(&sPerformCount);
  while (__stxr(v0 + 1, &sPerformCount));
}

uint64_t _CFStringGetInputIdentifierFormatterMappingFromDescriptor(uint64_t a1)
{
  v2[5] = *MEMORY[0x1895F89C0];
  v2[0] = MEMORY[0x1895F87A8];
  v2[1] = 3221225472LL;
  v2[2] = ___CFStringGetInputIdentifierFormatterMappingFromDescriptor_block_invoke;
  v2[3] = &__block_descriptor_40_e5_v8__0l;
  v2[4] = a1;
  if (_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init != -1) {
    dispatch_once(&_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init, v2);
  }
  return _CFStringGetInputIdentifierFormatterMappingFromDescriptor_localizedStringFormattingFamilyInfo;
}

void sub_180AEC8D4(_Unwind_Exception *exception_object)
{
}

BOOL __CFStringCopyCharSetWithPattern(const __CFString *a1, char **a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  HIDWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = 0;
  CFIndex Length = CFStringGetLength(a1);
  if (CFStringGetCharactersPtr(a1))
  {
    uint64_t v7 = uset_openPattern();
  }

  else
  {
    MEMORY[0x1895F8858](0LL, v5);
    v12.CFIndex location = 0LL;
    v12.CFIndex length = Length;
    CFStringGetCharacters(a1, v12, (UniChar *)((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL)));
    uint64_t v7 = uset_openPattern();
  }

  if (SHIDWORD(v10) > 0) {
    return 0LL;
  }
  *a2 = _CFCreateCharacterSetFromUSet(v7, v6);
  uset_close();
  return *a2 != 0LL;
}

void *_CFStringGetRelevantLocaleInfoFromLocaleSummary(const __CFDictionary *a1, const __CFLocale *a2)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  value = 0LL;
  unint64_t Count = CFDictionaryGetCount(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return value;
  }
  if (Count >> 60)
  {
    CFStringRef v19 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  Count);
    CFIndex v20 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v19,  0LL);
    CFRelease(v19);
    objc_exception_throw(v20);
    CFIndex v22 = v21;
    free(v2);
    _Unwind_Resume(v22);
  }

  uint64_t v8 = Mutable;
  if (Count <= 1) {
    uint64_t v9 = 1LL;
  }
  else {
    uint64_t v9 = Count;
  }
  unint64_t v10 = MEMORY[0x1895F8858](v9, v7);
  CFRange v12 = (const void **)((char *)&v23 - v11);
  if (Count >= 0x101)
  {
    CFRange v12 = (const void **)_CFCreateArrayStorage(v10, 0, &v23);
    CFMutableArrayRef v13 = v12;
  }

  else
  {
    CFMutableArrayRef v13 = 0LL;
  }

  CFDictionaryGetKeysAndValues(a1, v12, 0LL);
  for (; Count; --Count)
    CFArrayAppendValue(v8, *v12++);
  values[0] = (void *)CFLocaleGetIdentifier(a2);
  uint64_t v14 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 1LL, &kCFTypeArrayCallBacks);
  uint64_t v15 = CFBundleCopyLocalizationsForPreferences(v8, v14);
  uint64_t v16 = CFBundleCopyPreferredLocalizationsFromArray(v15);
  if (CFArrayGetCount(v16) > 0)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v16, 0LL);
    free(v13);
    if (!v16) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }

  free(v13);
  if (v16) {
LABEL_17:
  }
    CFRelease(v16);
LABEL_18:
  if (v15) {
    CFRelease(v15);
  }
  CFRelease(v8);
  if (v14) {
    CFRelease(v14);
  }
  return value;
}

uint64_t _CFStringContentsInCharacterSet(const __CFString *a1, const __CFCharacterSet *a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = 1LL;
  if (a1)
  {
    if (a2)
    {
      MutableCFArrayRef Copy = CFCharacterSetCreateMutableCopy(0LL, a2);
      if (MutableCopy)
      {
        uint64_t v5 = MutableCopy;
        CFCharacterSetInvert(MutableCopy);
        CFCharacterSetRemoveCharactersInString(v5, @" ");
        CFRange v8 = (CFRange)xmmword_180C33AB0;
        v10.CFIndex length = CFStringGetLength(a1);
        v10.CFIndex location = 0LL;
        if (CFStringFindCharacterFromSet(a1, v5, v10, 0LL, &v8)) {
          BOOL v6 = 0;
        }
        else {
          BOOL v6 = v8.location == -1;
        }
        uint64_t v2 = v6;
        CFRelease(v5);
      }
    }
  }

  return v2;
}

uint64_t _CFStringConditionalFormattingMeetsCondition(const __CFString *a1, CFLocaleRef locale)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t result = (uint64_t)CFLocaleGetValue(locale, @"kCFLocaleLanguageCodeKey");
  if (result)
  {
    uint64_t result = CFEqual((CFTypeRef)result, @"fi");
    if ((_DWORD)result)
    {
      CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      CFRange v5 = (CFRange)xmmword_180C33AB0;
      v7.CFIndex length = CFStringGetLength(a1);
      v7.CFIndex location = 0LL;
      return CFStringFindCharacterFromSet(a1, Predefined, v7, 0LL, &v5) != 0;
    }
  }

  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName(const __CFString *a1, CFLocaleRef locale)
{
  CFTypeRef Value = CFLocaleGetValue(locale, @"kCFLocaleLanguageCodeKey");
  if (!Value) {
    return CFRetain(a1);
  }
  CFRange v5 = Value;
  if (CFEqual(Value, @"cs")) {
    return _CFStringCopyVocativeCaseOfGivenName_cs(a1, locale);
  }
  if (CFEqual(v5, @"el")) {
    return _CFStringCopyVocativeCaseOfGivenName_el(a1, locale);
  }
  if (CFEqual(v5, @"uk")) {
    return _CFStringCopyVocativeCaseOfGivenName_uk(a1, locale);
  }
  if (CFEqual(v5, @"lt")) {
    return _CFStringCopyVocativeCaseOfGivenName_lt(a1, locale);
  }
  else {
    return CFRetain(a1);
  }
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_cs(CFStringRef theString, const __CFLocale *a2)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, theString);
  if (MutableCopy)
  {
    uint64_t v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    CFIndex Count = CFArrayGetCount((CFArrayRef)&off_189B40330);
    v64.CFIndex location = 0LL;
    v64.CFIndex length = Count;
    CFIndex v8 = CFArrayBSearchValues((CFArrayRef)&off_189B40330, v64, v6, (CFComparatorFunction)CFStringCompare, 0LL);
    if (v8 < Count)
    {
      uint64_t ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)&off_189B40330, v8);
      if (CFStringCompare(v6, ValueAtIndex, 0LL) == kCFCompareEqualTo)
      {
        CFStringRef v25 = theString;
        goto LABEL_24;
      }
    }

    if (CFStringCompare(v6, @"seth", 0LL) == kCFCompareEqualTo)
    {
      CFIndex Length = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      CFIndex v23 = Length - 1;
      CFIndex v17 = CFStringGetLength(v6);
      v18.CFIndex location = v17 - v23;
      if (v17 >= v23)
      {
        v18.CFIndex length = v23;
        CFStringReplace(v6, v18, @"ethe");
LABEL_23:
        CFStringRef v25 = v6;
LABEL_24:
        CFTypeRef v26 = CFRetain(v25);
        CFRelease(v6);
        if (v26) {
          return v26;
        }
        return CFRetain(theString);
      }

      goto LABEL_57;
    }

    if (CFStringHasSuffix(v6, @"a"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 0)
      {
        v19.CFIndex location = v17 - 1;
        CFIndex v20 = @"o";
LABEL_8:
        CFIndex v21 = v6;
        v19.CFIndex length = 1LL;
LABEL_22:
        CFStringReplace(v21, v19, v20);
        goto LABEL_23;
      }

      goto LABEL_57;
    }

    uint64_t v57 = @"uk";
    uint64_t v58 = 0LL;
    __int128 v55 = @"k";
    uint64_t v56 = @"ck";
    unsigned int v53 = @"g";
    unsigned int v54 = @"ik";
    if (__CFStringHasOneOfSuffixes(v6, v10, v11, v12, v13, v14, v15, v16, (uint64_t)@"h"))
    {
      CFStringReplaceAll(v6, theString);
      UniChar chars = 117;
      p_UniChar chars = &chars;
LABEL_13:
      CFStringAppendCharacters(v6, p_chars, 1LL);
      goto LABEL_23;
    }

    if (CFStringHasSuffix(v6, @"nec"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.CFIndex location = v17 - 2;
        CFIndex v20 = @"e";
LABEL_21:
        CFIndex v21 = v6;
        v19.CFIndex length = 2LL;
        goto LABEL_22;
      }
    }

    else if (CFStringHasSuffix(v6, @"ius"))
    {
      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.CFIndex location = v17 - 2;
        CFIndex v20 = @"e";
        goto LABEL_21;
      }
    }

    else
    {
      if (CFStringHasSuffix(v6, @"uce"))
      {
        CFStringReplaceAll(v6, theString);
        CFIndex v17 = CFStringGetLength(v6);
        if (v17 > 0)
        {
          v19.CFIndex location = v17 - 1;
          CFIndex v20 = @"i";
          goto LABEL_8;
        }

        goto LABEL_57;
      }

      uint64_t v57 = @"xel";
      uint64_t v58 = 0LL;
      __int128 v55 = @"rel";
      uint64_t v56 = @"bel";
      if (!__CFStringHasOneOfSuffixes(v6, v28, v29, v30, v31, v32, v33, v34, (uint64_t)@"vel"))
      {
        if (CFStringHasSuffix(v6, @"les"))
        {
          CFStringReplaceAll(v6, theString);
          v65.CFIndex location = CFStringGetLength(v6) - 1;
          v65.CFIndex length = 1LL;
          CFStringDelete(v6, v65);
          goto LABEL_23;
        }

        uint64_t v57 = @"o";
        uint64_t v58 = 0LL;
        __int128 v55 = @"c";
        uint64_t v56 = @"lix";
        unsigned int v53 = @"j";
        unsigned int v54 = @"ex";
        uint64_t v51 = @"";
        int64_t v52 = @"el";
        unsigned int v50 = @"z";
        if (__CFStringHasOneOfSuffixes(v6, v35, v36, v37, v38, v39, v40, v41, (uint64_t)@"s"))
        {
          CFStringReplaceAll(v6, theString);
          __int16 v61 = 105;
          p_UniChar chars = (UniChar *)&v61;
          goto LABEL_13;
        }

        if (CFStringHasSuffix(v6, @"dk"))
        {
          CFStringReplaceAll(v6, theString);
          CFIndex v17 = CFStringGetLength(v6);
          if (v17 <= 2) {
            goto LABEL_57;
          }
          v19.CFIndex location = v17 - 3;
          CFIndex v20 = @"ku";
        }

        else
        {
          if (!CFStringHasSuffix(v6, @"nk"))
          {
            if (CFStringHasSuffix(v6, @"ek"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.CFIndex location = v17 - 2;
                CFIndex v20 = @"ku";
                goto LABEL_21;
              }
            }

            else if (CFStringHasSuffix(v6, @"ter"))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.CFIndex location = v17 - 2;
                CFIndex v20 = @"e";
                goto LABEL_21;
              }
            }

            else
            {
              if (!CFStringHasSuffix(v6, @"tr"))
              {
                uint64_t v58 = @"b";
                uint64_t v59 = 0LL;
                uint64_t v56 = @"p";
                uint64_t v57 = @"f";
                unsigned int v54 = @"m";
                __int128 v55 = @"l";
                int64_t v52 = @"n";
                unsigned int v53 = @"v";
                unsigned int v50 = @"d";
                uint64_t v51 = @"t";
                if (!__CFStringHasOneOfSuffixes(v6, v42, v43, v44, v45, v46, v47, v48, (uint64_t)@"h"))
                {
                  CFRelease(v6);
                  return CFRetain(theString);
                }

                CFStringReplaceAll(v6, theString);
                __int16 v60 = 101;
                p_UniChar chars = (UniChar *)&v60;
                goto LABEL_13;
              }

              CFStringReplaceAll(v6, theString);
              CFIndex v17 = CFStringGetLength(v6);
              if (v17 > 0)
              {
                v19.CFIndex location = v17 - 1;
                CFIndex v20 = @"e";
                goto LABEL_8;
              }
            }

            goto LABEL_57;
          }

          CFStringReplaceAll(v6, theString);
          CFIndex v17 = CFStringGetLength(v6);
          if (v17 <= 2) {
            goto LABEL_57;
          }
          v19.CFIndex location = v17 - 3;
          CFIndex v20 = @"ku";
        }

        CFIndex v21 = v6;
        v19.CFIndex length = 3LL;
        goto LABEL_22;
      }

      CFStringReplaceAll(v6, theString);
      CFIndex v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.CFIndex location = v17 - 2;
        CFIndex v20 = @"le";
        goto LABEL_21;
      }
    }

LABEL_57:
    MEMORY[0x1895F8858](v17, v18.location);
    uint64_t v49 = &v50;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_58;
  }

  MEMORY[0x1895F8858](0LL, v5);
  uint64_t v49 = &v52;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_58:
  CFTypeRef result = (CFTypeRef)__strlcat_chk();
  qword_18C539A70 = (uint64_t)v49;
  __break(1u);
  return result;
}

    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v20;
    return 1LL;
  }

  CFTypeRef result = *(void *)(a1 + 88);
  if (result)
  {
    if (a3)
    {
      CFIndex v21 = *(void *)(a1 + 16);
      CFIndex v22 = v11;
    }

    else
    {
      CFIndex v22 = *(void *)(a1 + 32);
      CFIndex v21 = v11;
    }

    CFIndex v23 = v22 - v21;
    if (v23 < 0) {
      CFIndex v23 = -v23;
    }
    if ((unint64_t)v23 <= 0x10)
    {
      uint64_t v24 = *(_DWORD *)(a1 + 124);
      if (v24 <= 4) {
        *(_DWORD *)(a1 + 124) = ++v24;
      }
      goto LABEL_40;
    }

    __break(1u);
  }

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_el(CFStringRef theString1, const __CFLocale *a2)
{
  uint64_t v4 = 0LL;
  uint64_t v35 = *MEMORY[0x1895F89C0];
  do
  {
    if (CFStringCompare(theString1, _CFStringCopyVocativeCaseOfGivenName_el_keys[v4], 0LL) == kCFCompareEqualTo) {
      return CFRetain(_CFStringCopyVocativeCaseOfGivenName_el_values[v4]);
    }
    ++v4;
  }

  while (v4 != 12);
  MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, theString1);
  if (MutableCopy)
  {
    CFRange v7 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    uint64_t v33 = @"";
    uint64_t v34 = 0LL;
    v32[3] = @"";
    v32[4] = @"";
    if (CFStringHasSuffix(v7, @"")) {
      goto LABEL_10;
    }
    if (CFStringHasSuffix(v7, @""))
    {
      CFStringReplaceAll(v7, theString1);
      CFIndex Length = CFStringGetLength(v7);
      if (Length > 1)
      {
        v18.CFIndex location = Length - 2;
        CFRange v19 = @"";
        goto LABEL_15;
      }

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_uk(CFStringRef theString, const __CFLocale *a2)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, theString);
  if (MutableCopy)
  {
    uint64_t v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    if (CFStringCompare(v6, @"", 0LL))
    {
      if (CFStringCompare(v6, @"", 0LL))
      {
        if (CFStringCompare(v6, @"", 0LL))
        {
          if (CFStringCompare(v6, @"", 0LL))
          {
            uint64_t v72 = @"";
            uint64_t v73 = 0LL;
            uint64_t v71 = @"";
            uint64_t v72 = @"";
            uint64_t v73 = 0LL;
            uint64_t v71 = @"";
            if (__CFStringHasOneOfSuffixes(v6, v14, v15, v16, v17, v18, v19, v20, (uint64_t)@""))
            {
LABEL_22:
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.CFIndex location = Length - 1;
                uint64_t v24 = @"";
                goto LABEL_30;
              }

              goto LABEL_53;
            }

            uint64_t v72 = @"";
            uint64_t v73 = 0LL;
            uint64_t v70 = @"";
            uint64_t v71 = @"";
            uint64_t v69 = @"";
            if (__CFStringHasOneOfSuffixes(v6, v33, v34, v35, v36, v37, v38, v39, (uint64_t)@""))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.CFIndex location = Length - 1;
                uint64_t v24 = @"";
                goto LABEL_30;
              }

              goto LABEL_53;
            }

            uint64_t v71 = @"";
            uint64_t v72 = 0LL;
            uint64_t v69 = @"";
            uint64_t v70 = @"";
            int64_t v67 = @"";
            uint64_t v68 = @"";
            CFRange v65 = @"";
            int v66 = @"";
            if (__CFStringHasOneOfSuffixes(v6, v40, v41, v42, v43, v44, v45, v46, (uint64_t)@""))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.CFIndex location = Length - 1;
                uint64_t v24 = @"";
                goto LABEL_30;
              }

              goto LABEL_53;
            }

            if (CFStringHasSuffix(v6, @"")) {
              goto LABEL_22;
            }
            uint64_t v71 = @"";
            uint64_t v72 = 0LL;
            if (__CFStringHasOneOfSuffixes(v6, v48, v49, v50, v51, v52, v53, v54, (uint64_t)@""))
            {
              CFStringReplaceAll(v6, theString);
              UniChar chars = 1091;
              p_UniChar chars = &chars;
              goto LABEL_35;
            }

            if (CFStringHasSuffix(v6, @""))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.CFIndex location = Length - 1;
                uint64_t v24 = @"";
                goto LABEL_30;
              }

              goto LABEL_53;
            }

            if (CFStringHasSuffix(v6, @""))
            {
              CFStringReplaceAll(v6, theString);
              CFIndex Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.CFIndex location = Length - 2;
                uint64_t v24 = @"";
LABEL_45:
                uint64_t v47 = v6;
                v23.CFIndex length = 2LL;
                goto LABEL_31;
              }
            }

            else
            {
              if (!CFStringHasSuffix(v6, @""))
              {
                if (CFStringHasSuffix(v6, @""))
                {
LABEL_7:
                  CFStringReplaceAll(v6, theString);
                  CFIndex Length = CFStringGetLength(v6);
                  if (Length > 0)
                  {
                    v23.CFIndex location = Length - 1;
                    uint64_t v24 = @"";
LABEL_30:
                    uint64_t v47 = v6;
                    v23.CFIndex length = 1LL;
LABEL_31:
                    CFStringReplace(v47, v23, v24);
                    goto LABEL_18;
                  }

                  goto LABEL_53;
                }

                if (CFStringHasSuffix(v6, @""))
                {
                  CFStringReplaceAll(v6, theString);
                  __int16 v75 = 1086;
                  p_UniChar chars = (UniChar *)&v75;
                }

                else
                {
                  uint64_t v71 = @"";
                  uint64_t v72 = 0LL;
                  uint64_t v69 = @"";
                  uint64_t v70 = @"";
                  int64_t v67 = @"";
                  uint64_t v68 = @"";
                  CFRange v65 = @"";
                  int v66 = @"";
                  CFRange v64 = @"";
                  if (!__CFStringHasOneOfSuffixes(v6, v56, v57, v58, v59, v60, v61, v62, (uint64_t)@""))
                  {
                    CFRelease(v6);
                    return CFRetain(theString);
                  }

                  CFStringReplaceAll(v6, theString);
                  __int16 v74 = 1077;
                  p_UniChar chars = (UniChar *)&v74;
                }

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_lt(CFStringRef theString, const __CFLocale *a2)
{
  v16[9] = *MEMORY[0x1895F89C0];
  MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, theString);
  if (!MutableCopy)
  {
    MEMORY[0x1895F8858](0LL, v5);
    uint64_t v14 = v16;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_25;
  }

  uint64_t v6 = MutableCopy;
  CFStringLowercase(MutableCopy, a2);
  if (CFStringHasSuffix(v6, @"jas"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.CFIndex location = Length - 1;
      uint64_t v10 = @"u";
LABEL_8:
      uint64_t v11 = v6;
      v9.CFIndex length = 1LL;
LABEL_9:
      CFStringReplace(v11, v9, v10);
      goto LABEL_10;
    }

    goto LABEL_24;
  }

  if (CFStringHasSuffix(v6, @"as"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.CFIndex location = Length - 1;
      uint64_t v10 = @"i";
      goto LABEL_8;
    }

    goto LABEL_24;
  }

  if (CFStringHasSuffix(v6, @"us"))
  {
    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 1)
    {
      v9.CFIndex location = Length - 2;
      uint64_t v10 = @"au";
      uint64_t v11 = v6;
      v9.CFIndex length = 2LL;
      goto LABEL_9;
    }

BOOL __CFStringHasOneOfSuffixes( CFStringRef theString, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = (CFStringRef *)&a9;
  do
  {
    uint64_t v10 = v13++;
    CFStringRef v11 = *v10;
  }

  while (*v10 && !CFStringHasSuffix(theString, *v10));
  return v11 != 0LL;
}

uint64_t __CFStringApproximateSyllableCount_el_GR(const __CFString *a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  CFStringRef theString = a1;
  uint64_t v32 = 0LL;
  CFIndex Length = CFStringGetLength(a1);
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0LL;
  CFIndex v30 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  unint64_t v34 = 0LL;
  int64_t v35 = 0LL;
  CFTypeRef v31 = CStringPtr;
  CFIndex v4 = Length;
  if (Length >= 1)
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    while (2)
    {
      if (v30)
      {
        UniChar v8 = v30[v32 + v5];
      }

      else if (v31)
      {
        UniChar v8 = v31[v32 + v5];
      }

      else
      {
        BOOL v9 = v35 > (uint64_t)v5 && v7 <= (uint64_t)v5;
        if (!v9)
        {
          unint64_t v10 = v5 - 4;
          if (v5 < 4) {
            unint64_t v10 = 0LL;
          }
          unint64_t v34 = v10;
          int64_t v35 = v4;
          v37.CFIndex location = v32 + v10;
          v37.CFIndex length = v4 - v10;
          CFStringGetCharacters(theString, v37, v28);
          uint64_t v7 = v34;
        }

        UniChar v8 = v28[v5 - v7];
      }

      switch(v8)
      {
        case 0x3ACu:
        case 0x3ADu:
        case 0x3AEu:
        case 0x3AFu:
        case 0x3B7u:
        case 0x3C9u:
        case 0x3CCu:
        case 0x3CDu:
        case 0x3CEu:
          goto LABEL_20;
        case 0x3B0u:
        case 0x3B2u:
        case 0x3B3u:
        case 0x3B4u:
        case 0x3B6u:
        case 0x3B8u:
        case 0x3BAu:
        case 0x3BBu:
        case 0x3BCu:
        case 0x3BDu:
        case 0x3BEu:
        case 0x3C0u:
        case 0x3C1u:
        case 0x3C2u:
        case 0x3C3u:
        case 0x3C4u:
        case 0x3C6u:
        case 0x3C7u:
        case 0x3C8u:
        case 0x3CAu:
        case 0x3CBu:
          goto LABEL_21;
        case 0x3B1u:
        case 0x3B5u:
        case 0x3C5u:
          int64_t v11 = v5 + 1;
          CFIndex v12 = Length;
          if (v30)
          {
            UniChar v13 = v30[v32 + v11];
          }

          else if (v31)
          {
            UniChar v13 = v31[v32 + v11];
          }

          else
          {
            if (v35 <= v11 || v7 > v11)
            {
              unint64_t v18 = v5 - 3;
              if (v5 < 3) {
                unint64_t v18 = 0LL;
              }
              unint64_t v34 = v18;
              int64_t v35 = v12;
              v38.CFIndex location = v32 + v18;
              v38.CFIndex length = v12 - v18;
              CFStringGetCharacters(theString, v38, v28);
              uint64_t v7 = v34;
            }

            UniChar v13 = v28[v11 - v7];
          }

          if (v13 != 953 && v13 != 943) {
            goto LABEL_20;
          }
          goto LABEL_77;
        case 0x3B9u:
          int64_t v11 = v5 + 1;
          CFIndex v14 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              UniChar v15 = v30[v32 + v11];
            }

            else if (v31)
            {
              UniChar v15 = v31[v32 + v11];
            }

            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                unint64_t v19 = v5 - 3;
                if (v5 < 3) {
                  unint64_t v19 = 0LL;
                }
                unint64_t v34 = v19;
                int64_t v35 = v14;
                v39.CFIndex location = v32 + v19;
                v39.CFIndex length = v14 - v19;
                CFStringGetCharacters(theString, v39, v28);
                uint64_t v7 = v34;
              }

              UniChar v15 = v28[v11 - v7];
            }

            unsigned int v20 = v15 - 940;
            BOOL v9 = v20 > 0x22;
            uint64_t v21 = (1LL << v20) & 0x420000021LL;
            if (!v9 && v21 != 0) {
              goto LABEL_77;
            }
          }

          goto LABEL_20;
        case 0x3BFu:
          int64_t v11 = v5 + 1;
          CFIndex v16 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              UniChar v17 = v30[v32 + v11];
            }

            else if (v31)
            {
              UniChar v17 = v31[v32 + v11];
            }

            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                unint64_t v23 = v5 - 3;
                if (v5 < 3) {
                  unint64_t v23 = 0LL;
                }
                unint64_t v34 = v23;
                int64_t v35 = v16;
                v40.CFIndex location = v32 + v23;
                v40.CFIndex length = v16 - v23;
                CFStringGetCharacters(theString, v40, v28);
                uint64_t v7 = v34;
              }

              UniChar v17 = v28[v11 - v7];
            }

            unsigned int v24 = v17 - 943;
            BOOL v9 = v24 > 0x1E;
            int v25 = (1 << v24) & 0x40400401;
            if (!v9 && v25 != 0) {
LABEL_77:
            }
              unint64_t v5 = v11;
          }

void CFStreamCreateBoundPair( CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize)
{
  v20[1] = *(void ***)MEMORY[0x1895F89C0];
  if (readStream) {
    *readStream = 0LL;
  }
  if (writeStream) {
    *writeStream = 0LL;
  }
  v20[0] = 0LL;
  if (cbInit(v20, transferBufferSize))
  {
    UniChar v8 = (char *)CFAllocatorAllocate(alloc, 176LL, 0LL);
    *(_OWORD *)UniChar v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + _Block_object_dispose(va, 8) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((void ***)v8 + 12) = v20[0];
    *((void *)v8 + 11) = alloc;
    pthread_mutex_init((pthread_mutex_t *)(v8 + 104), 0LL);
    *((void *)v8 + 21) = transferBufferSize;
    *((void *)v8 + 3) = @"_kCFBoundPairReadPrivateRunLoopMode";
    *((void *)v8 + 1) = CFRunLoopSourceCreate(alloc, 0LL, &_emptySourceCtxt);
    *((void *)v8 + 9) = @"_kCFBoundPairWritePrivateRunLoopMode";
    *((void *)v8 + 7) = CFRunLoopSourceCreate(alloc, 0LL, &_emptySourceCtxt);
    CFReadStreamCreate(alloc, (uint64_t)&boundPairReadCallBacks, (uint64_t)v8, v9, v10, v11, v12, v13);
    CFWriteStreamCreate(alloc, boundPairWriteCallBacks, (uint64_t)v8, v14, v15, v16, v17, v18);
    unint64_t v19 = (__CFReadStream *)*((void *)v8 + 4);
    if (v19 && *((void *)v8 + 10))
    {
      if (readStream) {
        *readStream = v19;
      }
      if (writeStream) {
        *writeStream = (CFWriteStreamRef)*((void *)v8 + 10);
      }
    }

    else
    {
      boundPairCommonFinalize((uint64_t)v8);
    }
  }

void boundPairCommonFinalize(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t v2 = *(__CFRunLoopSource **)(a1 + 56);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 56));
    *(void *)(a1 + 56) = 0LL;
  }

  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 104));
  CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 88), (void *)a1);
}

uint64_t boundPairReadCreate(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 32) = a1;
  }
  return a2;
}

void boundPairReadFinalize(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    int v4 = *(unsigned __int8 *)(a2 + 48);
    *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 4) = 0;
    unint64_t v5 = *(const void **)(a2 + 16);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a2 + 16) = 0LL;
    }

    uint64_t v6 = *(const void **)(a2 + 40);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a2 + 40) = 0LL;
    }

    pthread_mutex_unlock(v3);
    if (v4) {
      boundPairCommonFinalize(a2);
    }
  }

uint64_t boundPairReadOpen( char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a4 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0LL, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v12, a4)) {
      CFReadStreamSignalEvent(a1, 2uLL, 0LL, v13, v14, v15, v16, v17);
    }
    _wakeReadStreamScheduledRunLoops();
  }

  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  *a3 = 1;
  return 1LL;
}

uint64_t boundPairReadOpenComplete( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a3 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0LL, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v10, a3)) {
      CFReadStreamSignalEvent(a1, 2uLL, 0LL, v11, v12, v13, v14, v15);
    }
    _wakeReadStreamScheduledRunLoops();
  }

  return 1LL;
}

uint64_t boundPairRead(char *a1, char *a2, int a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)a6)
  {
    *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = 22;
    *(void *)a4 = 1LL;
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, (uint64_t)a5, a6, a7, a8);
      _wakeReadStreamScheduledRunLoops();
    }

    return -1LL;
  }

  pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
  while (1)
  {
    if (*(_BYTE *)a6)
    {
      int v20 = *(unsigned __int8 *)(a6 + 3);
      goto LABEL_10;
    }

    if (_cbCanRead(*(void *)(a6 + 96))) {
      break;
    }
    int v20 = *(unsigned __int8 *)(a6 + 3);
    if (v20 == 1) {
      break;
    }
LABEL_10:
    if (v20) {
      break;
    }
    if (*(_WORD *)(a6 + 52))
    {
      _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0LL, v15, v16, v17, v18, v19);
      _wakeWriteStreamScheduledRunLoops();
    }

    CFRunLoopRef Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
    CFRange v22 = *(const void **)(a6 + 16);
    if (v22) {
      CFRelease(v22);
    }
    if (Current) {
      CFTypeRef v23 = CFRetain(Current);
    }
    else {
      CFTypeRef v23 = 0LL;
    }
    *(void *)(a6 + 16) = v23;
    *(_BYTE *)(a6 + 1) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    CFRunLoopRunInMode(*(CFRunLoopMode *)(a6 + 24), 1.0e20, 1u);
    pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
    *(_BYTE *)(a6 + 1) = 0;
    CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
  }

  int v29 = cbRead(*(void *)(a6 + 96), a2, a3);
  if (!v29 && *(_BYTE *)(a6 + 3) == 1)
  {
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(*(char **)(a6 + 32), 0x10uLL, 0LL, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }

    else
    {
      *a5 = 1;
    }

    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    return 0LL;
  }

  if (*(_BYTE *)a6)
  {
    if (*(_BYTE *)(a6 + 3) == 1)
    {
      unint64_t v30 = 16LL;
      goto LABEL_28;
    }
  }

  else
  {
    _cbCanRead(*(void *)(a6 + 96));
    if (*(_BYTE *)(a6 + 3) == 1)
    {
      unint64_t v30 = 2LL;
LABEL_28:
      CFReadStreamSignalEvent(a1, v30, 0LL, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }
  }

  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = 0;
  *a5 = 0;
  if (*(_BYTE *)(a6 + 49))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a6 + 56));
    CFTypeRef v31 = *(__CFRunLoop **)(a6 + 64);
    if (v31) {
      CFRunLoopWakeUp(v31);
    }
  }

  if (*(_WORD *)(a6 + 4) && !*(_BYTE *)(a6 + 3))
  {
    _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0LL, v24, v25, v26, v27, v28);
    _wakeWriteStreamScheduledRunLoops();
  }

  if (*(_WORD *)(a6 + 52) && !*(_BYTE *)a6 && (_cbCanRead(*(void *)(a6 + 96)) || *(_BYTE *)(a6 + 3) == 1))
  {
    CFReadStreamSignalEvent(a1, 2uLL, 0LL, v32, v33, v34, v35, v36);
    _wakeReadStreamScheduledRunLoops();
  }

  pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
  return v29;
}

BOOL boundPairReadCanRead(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (*(_BYTE *)a2) {
    return 0LL;
  }
  if (_cbCanRead(*(void *)(a2 + 96))) {
    return 1LL;
  }
  return *(_BYTE *)(a2 + 3) == 1;
}

void boundPairReadClose(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v3 = (pthread_mutex_t *)(a2 + 104);
    UniChar v8 = 0LL;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(_BYTE *)(a2 + 2) = 1;
    if (!*(_BYTE *)(a2 + 50))
    {
      if (*(_WORD *)(a2 + 52))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 80), *(CFTypeRef *)(a2 + 56), *(CFTypeRef *)(a2 + 64));
      }

      else
      {
        unint64_t v5 = *(const void **)(a2 + 56);
        int v4 = *(const void **)(a2 + 64);
        uint64_t v6 = 0LL;
        if (v5) {
          CFRetain(v5);
        }
        uint64_t v7 = v5;
        if (v4) {
          CFRetain(v4);
        }
        UniChar v8 = v4;
      }
    }

    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }

const void *boundPairReadCopyProperty(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  if (a2 && a3)
  {
    if (*(void *)(a3 + 40) && CFStringCompare(@"_kCFStreamPropertyHTTPTrailer", a2, 1uLL) == kCFCompareEqualTo)
    {
      CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), a2);
      uint64_t v3 = Value;
      if (Value) {
        CFRetain(Value);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v3;
}

__CFDictionary *boundPairReadSetProperty(uint64_t a1, const __CFString *a2, const void *a3, uint64_t a4)
{
  if (!a2) {
    return 0LL;
  }
  CFComparisonResult v7 = CFStringCompare(@"_kCFStreamPropertyHTTPTrailer", a2, 1uLL);
  CFTypeRef result = 0LL;
  if (a4)
  {
    if (v7 == kCFCompareEqualTo)
    {
      CFTypeRef result = *(__CFDictionary **)(a4 + 40);
      if (result
        || (CFTypeRef result = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks),  (*(void *)(a4 + 40) = result) != 0LL))
      {
        if (a3) {
          CFDictionarySetValue(result, a2, a3);
        }
        else {
          CFDictionaryRemoveValue(result, a2);
        }
        return (__CFDictionary *)1;
      }
    }
  }

  return result;
}

void boundPairReadSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = *(const void **)(a4 + 16);
    if (v6) {
      CFRelease(v6);
    }
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0LL;
    }
    *(void *)(a4 + 16) = v7;
    ++*(_WORD *)(a4 + 4);
  }

void boundPairReadUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = *(__int16 *)(a4 + 4);
    BOOL v5 = __OFSUB__(v4, 1);
    int v6 = v4 - 1;
    if (v6 < 0 == v5) {
      *(_WORD *)(a4 + 4) = v6;
    }
  }

void _wakeReadStreamScheduledRunLoops()
{
  unint64_t v0 = (const __CFArray *)_CFReadStreamCopyRunLoopsAndModes();
  if (v0)
  {
    pthread_t v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }

void _wakeRunLoops(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0LL; i < v3; CFIndex i = v6 + 1)
    {
      uint64_t ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(a1, i);
      CFIndex v6 = i + 1;
      CFTypeRef v7 = CFArrayGetValueAtIndex(a1, v6);
      CFRunLoopMode v8 = CFRunLoopCopyCurrentMode(ValueAtIndex);
      if (!v8) {
        break;
      }
      CFRunLoopMode v9 = v8;
      if (CFEqual(v8, v7)) {
        CFRunLoopWakeUp(ValueAtIndex);
      }
      CFRelease(v9);
    }
  }

void _wakeWriteStreamScheduledRunLoops()
{
  unint64_t v0 = (const __CFArray *)_CFWriteStreamCopyRunLoopsAndModes();
  if (v0)
  {
    pthread_t v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }

void *setupScheduledStreamCloseBlock(void *result, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  CFTypeRef v7 = result;
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  void *v7 = cf;
  if (a3) {
    CFTypeRef result = CFRetain(a3);
  }
  v7[1] = a3;
  if (a4) {
    CFTypeRef result = CFRetain(a4);
  }
  int v7[2] = a4;
  return result;
}

void performUnlockParamsAndDealloc(uint64_t a1)
{
  uint64_t v2 = *(char **)a1;
  if (v2)
  {
    CFTypeID v3 = CFGetTypeID(v2);
    CFTypeID TypeID = CFReadStreamGetTypeID();
    uint64_t v10 = *(char **)a1;
    if (v3 == TypeID)
    {
      CFReadStreamSignalEvent(v10, 2uLL, 0LL, v4, v5, v6, v7, v8);
      char v11 = 0;
      goto LABEL_6;
    }

    CFWriteStreamSignalEvent(v10, 0x10uLL, 0LL, v4, v5, v6, v7, v8);
  }

  char v11 = 1;
LABEL_6:
  uint64_t v12 = *(__CFRunLoopSource **)(a1 + 8);
  if (v12) {
    CFRunLoopSourceSignal(v12);
  }
  if (*(void *)a1)
  {
    if ((v11 & 1) != 0) {
      _wakeWriteStreamScheduledRunLoops();
    }
    else {
      _wakeReadStreamScheduledRunLoops();
    }
  }

  uint64_t v13 = *(__CFRunLoop **)(a1 + 16);
  if (v13) {
    CFRunLoopWakeUp(v13);
  }
  if (*(void *)a1)
  {
    CFRelease(*(CFTypeRef *)a1);
    *(void *)a1 = 0LL;
  }

  uint64_t v14 = *(const void **)(a1 + 8);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

  uint64_t v15 = *(const void **)(a1 + 16);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 16) = 0LL;
  }

uint64_t boundPairWriteCreate(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 80) = a1;
  }
  return a2;
}

void boundPairWriteFinalize(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    CFTypeID v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    int v4 = *a2;
    a2[48] = 1;
    *((_WORD *)a2 + 26) = 0;
    uint64_t v5 = (const void *)*((void *)a2 + 8);
    if (v5)
    {
      CFRelease(v5);
      *((void *)a2 + _Block_object_dispose(va, 8) = 0LL;
    }

    pthread_mutex_unlock(v3);
    if (v4) {
      boundPairCommonFinalize((uint64_t)a2);
    }
  }

uint64_t boundPairWriteOpen( char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a4 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0LL, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0LL, v11, v12, v13, v14, v15);
    _wakeWriteStreamScheduledRunLoops();
  }

  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  *a3 = 1;
  return 1LL;
}

uint64_t boundPairWriteOpenComplete( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a3 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0LL, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0LL, v9, v10, v11, v12, v13);
    _wakeWriteStreamScheduledRunLoops();
  }

  return 1LL;
}

uint64_t boundPairWrite( char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 > 0)
  {
    unsigned int v10 = a3;
    pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
    if (!a5) {
      goto LABEL_5;
    }
LABEL_3:
    if (!*(_BYTE *)(a5 + 48) && _cbCanWrite(*(void *)(a5 + 96)))
    {
      if (!*(_BYTE *)(a5 + 2))
      {
        uint64_t v20 = (int)cbWrite(*(void *)(a5 + 96), a2, v10);
        goto LABEL_20;
      }
    }

    else
    {
LABEL_5:
      while (!*(_BYTE *)(a5 + 2))
      {
        if (*(_WORD *)(a5 + 4))
        {
          _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0LL, v12, v13, v14, v15, v16);
          _wakeReadStreamScheduledRunLoops();
        }

        CFRunLoopRef Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        uint64_t v18 = *(const void **)(a5 + 64);
        if (v18) {
          CFRelease(v18);
        }
        if (Current) {
          CFTypeRef v19 = CFRetain(Current);
        }
        else {
          CFTypeRef v19 = 0LL;
        }
        *(void *)(a5 + 64) = v19;
        *(_BYTE *)(a5 + 49) = 1;
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        CFRunLoopRunInMode(*(CFRunLoopMode *)(a5 + 72), 1.0e20, 1u);
        pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
        *(_BYTE *)(a5 + 49) = 0;
        CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        if (a5) {
          goto LABEL_3;
        }
      }
    }

    uint64_t v20 = -1LL;
LABEL_20:
    if (*(_BYTE *)(a5 + 1))
    {
      CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a5 + 8));
      uint64_t v21 = *(__CFRunLoop **)(a5 + 16);
      if (v21) {
        CFRunLoopWakeUp(v21);
      }
    }

    if (*(_WORD *)(a5 + 4))
    {
      _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0LL, v12, v13, v14, v15, v16);
      _wakeReadStreamScheduledRunLoops();
    }

    if (!*(_WORD *)(a5 + 52)) {
      goto LABEL_32;
    }
    if (*(_BYTE *)(a5 + 48) || !_cbCanWrite(*(void *)(a5 + 96)))
    {
      if (!*(_BYTE *)(a5 + 2))
      {
LABEL_32:
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        return v20;
      }

      unint64_t v22 = 16LL;
    }

    else
    {
      unint64_t v22 = 4LL;
    }

    CFWriteStreamSignalEvent(a1, v22, 0LL, v12, v13, v14, v15, v16);
    _wakeWriteStreamScheduledRunLoops();
    goto LABEL_32;
  }

  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = 22;
  *(void *)a4 = 1LL;
  if (*(_WORD *)(a5 + 52))
  {
    CFWriteStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, a5, a6, a7, a8);
    _wakeWriteStreamScheduledRunLoops();
  }

  return -1LL;
}

BOOL boundPairCanWrite(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (*(_BYTE *)(a2 + 48)) {
    return 0LL;
  }
  return _cbCanWrite(*(void *)(a2 + 96));
}

void boundPairWriteClose(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    CFTypeID v3 = (pthread_mutex_t *)(a2 + 104);
    uint64_t v8 = 0LL;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(_BYTE *)(a2 + 50) = 1;
    *(_BYTE *)(a2 + 3) = 1;
    if (!*(_BYTE *)(a2 + 2))
    {
      if (*(_WORD *)(a2 + 4))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 32), *(CFTypeRef *)(a2 + 8), *(CFTypeRef *)(a2 + 16));
      }

      else
      {
        uint64_t v5 = *(const void **)(a2 + 8);
        int v4 = *(const void **)(a2 + 16);
        uint64_t v6 = 0LL;
        if (v5) {
          CFRetain(v5);
        }
        uint64_t v7 = v5;
        if (v4) {
          CFRetain(v4);
        }
        uint64_t v8 = v4;
      }
    }

    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }

void boundPairWriteSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = *(const void **)(a4 + 64);
    if (v6) {
      CFRelease(v6);
    }
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0LL;
    }
    *(void *)(a4 + 64) = v7;
    ++*(_WORD *)(a4 + 52);
  }

void boundPairWriteUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    int v4 = *(__int16 *)(a4 + 52);
    BOOL v5 = __OFSUB__(v4, 1);
    int v6 = v4 - 1;
    if (v6 < 0 == v5) {
      *(_WORD *)(a4 + 52) = v6;
    }
  }

uint64_t (**__CFStringEncodingGetSimplifiedChineseConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter)
  {
    __CFStringEncodingIsDecomposableCharacter = (_UNKNOWN *)a2(1LL);
    __CFStringEncodingDecomposeCharacter = (_UNKNOWN *)a2(2LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_1 = (_UNKNOWN *)a2(3LL);
    __CFStringEncodingPrecomposeLatinCharacter_3 = (_UNKNOWN *)a2(4LL);
  }

  int v4 = __CFConverterEUC_CN;
  BOOL v5 = __CFConverterMacSimplifiedChinese;
  if (a1 != 25) {
    BOOL v5 = 0LL;
  }
  if (a1 != 2352) {
    int v4 = v5;
  }
  if (a1 == 2565) {
    return __CFConverterGB_HZ;
  }
  else {
    return v4;
  }
}

uint64_t __CFToEUC_CN(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 < 0x80)
  {
    uint64_t result = 1LL;
    goto LABEL_3;
  }

  int v4 = (unsigned __int16 *)&__CFToGB2312CharMap;
  BOOL v5 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    uint64_t v6 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v5 - v4)) >> 1;
    CFTypeRef v7 = &v4[17 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    BOOL v5 = v7 - 17;
LABEL_10:
    if (v4 > v5) {
      return 0LL;
    }
  }

  if (v8 + 16 <= a2)
  {
    int v4 = v7 + 17;
    goto LABEL_10;
  }

  unsigned __int16 v9 = v4[17 * v6 + 1 + (int)(a2 - v8)];
  if (!v9 || v9 == 65533) {
    return 0LL;
  }
  LOBYTE(a2) = v9 | 0x80;
  *a3++ = (unsigned __int16)(v9 | 0x8080) >> 8;
  uint64_t result = 2LL;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromEUC_CN(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  unsigned __int16 v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1LL;
  }

  uint64_t result = 0LL;
  if (a3 >= 2 && (v4 + 1) >= 0xA2u)
  {
    unsigned int v6 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
    CFTypeRef v7 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    unsigned int v8 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      uint64_t v9 = (0xF83E0F83E0F83E1LL * (v8 - v7)) >> 1;
      unsigned int v10 = &v7[33 * v9];
      unsigned int v11 = *v10;
      if (v11 <= v6)
      {
        if (v11 + 32 > v6)
        {
          unsigned __int16 v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
          if (v12)
          {
            *a4 = v12;
            if (v12 != 65533) {
              return 2LL;
            }
            return 0LL;
          }

uint64_t __CFToEUC_CNLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1LL;
    }
    else {
      uint64_t v5 = 2LL;
    }
    result += v5;
  }

  return result;
}

uint64_t __CFFromEUC_CNLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1LL;
    }
    else {
      uint64_t v7 = 2LL;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2LL;
    }
    else {
      uint64_t v8 = -1LL;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }

  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToEUC_CNPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  unsigned int v9 = *a2;
  if (v9 > 0x7F)
  {
    int v11 = a2[1];
    if (v9 == 12454) {
      int v12 = 12532;
    }
    else {
      int v12 = v9 + 1;
    }
    int v13 = v9 + 2;
    if (v11 != 12442) {
      int v13 = 65533;
    }
    if (v11 == 12441) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = v13;
    }
    if ((v9 & 0xFFFFFFDF) == 0x418) {
      int v15 = v9 + 1;
    }
    else {
      int v15 = -3;
    }
    if (v9 == 1077) {
      int v16 = 1105;
    }
    else {
      int v16 = -3;
    }
    if (v9 == 1045) {
      unsigned int v17 = 1025;
    }
    else {
      unsigned int v17 = v16;
    }
    if (v11 != 776) {
      unsigned int v17 = 65533;
    }
    if (v11 == 774) {
      unsigned int v17 = v15;
    }
    if (a2[1] <= 0x3098u) {
      uint64_t v10 = v17;
    }
    else {
      uint64_t v10 = v14;
    }
  }

  else
  {
    uint64_t v10 = __CFStringEncodingPrecomposeLatinCharacter_3(a2, a3, 0LL);
  }

  int v18 = __CFToEUC_CN(v10, (unsigned __int16)v10, v22);
  char v19 = v22[0];
  if (v18) {
    BOOL v20 = v22[0] == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    uint64_t result = 2LL;
    *a6 = 2LL;
    if (!a5) {
      return result;
    }
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2LL;
    }
  }

  return 0LL;
}

uint64_t __CFIsValidCombiningCharSimplifiedChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1LL << (a1 - 6)) & 0x4000000000005LL) != 0
    || (a1 - 12441) < 2)
  {
    return 1LL;
  }

  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_1();
  }

uint64_t __CFToMacSimplifiedChinese( char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v58[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v19 = 0LL;
    uint64_t v12 = 0LL;
    goto LABEL_171;
  }

  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v55 = a3 + 1;
  int v13 = (unsigned __int16 *)&__CFToMacSimplifiedChineseMap;
  while (1)
  {
    if (!a5 || v11 < a5) {
      goto LABEL_15;
    }
    if ((a1 & 0x10) == 0) {
      goto LABEL_170;
    }
    uint64_t v14 = *a2;
    if ((v14 - 774) <= 0x32 && ((1LL << (v14 - 6)) & 0x4000000000005LL) != 0
      || (v14 - 12441) < 2)
    {
      goto LABEL_16;
    }

    unsigned int v17 = (char *)v13;
    char IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1( *a2,  1LL,  0x4000000000005LL);
    int v13 = (unsigned __int16 *)v17;
    if ((IsValidCombiningCharacterForLatin1_1 & 1) == 0)
    {
      uint64_t v14 = *a2;
      if ((v14 & 0xFFF0) != 0xF870) {
        goto LABEL_170;
      }
    }

    else
    {
LABEL_15:
      uint64_t v14 = *a2;
    }

LABEL_170:
  uint64_t v19 = v11;
LABEL_171:
  *a6 = v19;
  return v12;
}

        __int16 v75 = v111;
        int64_t v76 = v111 + 4;
        v111 += 4LL;
        if (v9)
        {
          if (v76 > v8)
          {
            v111 = v75;
            break;
          }

          uint64_t v77 = bswap32(v66);
          if ((_DWORD)a4 != 402653440) {
            uint64_t v77 = v66;
          }
          *(_DWORD *)unsigned int v9 = v77;
          v9 += 2;
        }

        if (HIWORD(v66)) {
          uint64_t v78 = 2LL;
        }
        else {
          uint64_t v78 = 1LL;
        }
        i += v78;
      }
    }

uint64_t __CFFromMacSimplifiedChinese( uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 2LL;
  }
  else {
    uint64_t v15 = 3LL;
  }
  if ((a1 & 0x200) != 0) {
    uint64_t v16 = 1LL;
  }
  else {
    uint64_t v16 = 2LL;
  }
  while (2)
  {
    if (a5 && v12 >= a5) {
      return v13;
    }
    int v17 = (char)*a2;
    int v18 = *a2;
    if (v18 == 128)
    {
      if (v14)
      {
        if (!a5)
        {
          uint64_t v21 = a4;
          uint64_t v22 = v15;
          goto LABEL_63;
        }

        if (v12 + v15 > a5) {
          return v13;
        }
        *(_DWORD *)a4 = 50856053;
        uint64_t v21 = a4 + 2;
        if ((a1 & 0x200) != 0)
        {
          uint64_t v22 = 2LL;
          goto LABEL_63;
        }

        uint64_t v22 = 3LL;
      }

      else
      {
        if (!a5)
        {
          uint64_t v21 = a4;
          uint64_t v22 = v16;
          goto LABEL_63;
        }

        if (v12 + v16 > a5) {
          return v13;
        }
        *a4 = 252;
        uint64_t v21 = a4 + 1;
        if ((a1 & 0x200) != 0)
        {
          uint64_t v22 = 1LL;
          goto LABEL_63;
        }

        uint64_t v22 = 2LL;
      }

      *uint64_t v21 = -1921;
      uint64_t v21 = &a4[v22];
LABEL_63:
      v12 += v22;
      a4 = v21;
LABEL_17:
      uint64_t v19 = 1LL;
      goto LABEL_18;
    }

    if ((v18 + 3) <= 0x85u)
    {
      if (*a2 > 0xFCu)
      {
        if (v18 == 253)
        {
          LOWORD(v1_Block_object_dispose(va, 8) = 169;
        }

        else if (v18 == 254)
        {
          LOWORD(v1_Block_object_dispose(va, 8) = 8482;
        }

        else
        {
          LOWORD(v1_Block_object_dispose(va, 8) = 8230;
        }

        goto LABEL_14;
      }

      if (v18 == 129)
      {
        if ((a1 & 0x200) == 0)
        {
          LOWORD(v1_Block_object_dispose(va, 8) = -1920;
          goto LABEL_14;
        }
      }

      else if (v18 == 130 && (a1 & 0x200) == 0)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = -1919;
LABEL_14:
        if (a5) {
          *a4++ = v18;
        }
        ++v12;
        goto LABEL_17;
      }

      uint64_t v19 = 1LL;
      goto LABEL_19;
    }

    if (v9 < 2) {
      return v13;
    }
    if (v18 == 161)
    {
      int v23 = a2[1];
      __int16 v24 = 183;
      switch(a2[1])
      {
        case 0xA4u:
          goto LABEL_105;
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
          break;
        case 0xAAu:
          __int16 v24 = 8212;
          goto LABEL_105;
        case 0xABu:
          __int16 v24 = 12316;
          goto LABEL_105;
        case 0xACu:
          __int16 v24 = 8214;
          goto LABEL_105;
        case 0xADu:
          __int16 v24 = 8943;
          goto LABEL_105;
        default:
          if (v23 == 233)
          {
            __int16 v24 = 162;
            goto LABEL_105;
          }

          if (v23 == 234)
          {
            __int16 v24 = 163;
            goto LABEL_105;
          }

          break;
      }
    }

    else
    {
      if (v18 == 163)
      {
        int v23 = a2[1];
        if (v23 != 164)
        {
          if (v23 == 254)
          {
            __int16 v24 = 8254;
            goto LABEL_105;
          }

          goto LABEL_53;
        }

        __int16 v24 = 165;
LABEL_105:
        if (a5) {
          *a4++ = v24;
        }
        goto LABEL_107;
      }

      int v23 = a2[1];
    }

uint64_t __CFFromMacSimplifiedChineseLen(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (BOOL v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (BOOL v4 = 1),
          v4 ? (BOOL v5 = (unint64_t)a3 >= 2) : (BOOL v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      int v6 = *a2;
      uint64_t v7 = a3 - 1;
      if (v6 == 128) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2 + 2;
      }
      if (v6 == 128)
      {
        uint64_t v9 = result + 1;
      }

      else
      {
        uint64_t v7 = a3 - 2;
        uint64_t v9 = result;
      }

      if (v6 == 161) {
        a2 += 2;
      }
      else {
        a2 = v8;
      }
      if (v6 == 161) {
        a3 -= 2LL;
      }
      else {
        a3 = v7;
      }
      if (v6 == 161) {
        ++result;
      }
      else {
        uint64_t result = v9;
      }
    }

    else
    {
      ++a2;
      --a3;
    }

    ++result;
  }

  while (a3 > 0);
  return result;
}

uint64_t __CFToGB_HZ(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  unint64_t v7 = (unint64_t)a2;
  uint64_t v84 = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v10 = 0LL;
    uint64_t v15 = a2;
    goto LABEL_138;
  }

  uint64_t v10 = 0LL;
  unint64_t v11 = (unint64_t)&a2[a3];
  if (a5) {
    uint64_t v12 = -1LL;
  }
  else {
    uint64_t v12 = 0LL;
  }
  uint64_t v76 = v12;
  uint64_t v13 = 0x8EA4u;
  uint64_t v14 = 1LL;
  uint64_t v15 = (unsigned __int16 *)v7;
  uint64_t v16 = "~{";
  while (2)
  {
    if (a5 && v10 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_114;
      }
      uint64_t v17 = *v15;
      if ((v17 - 774) <= 0x32 && ((1LL << (v17 - 6)) & 0x4000000000005LL) != 0
        || (v17 - 12441) < 2)
      {
        goto LABEL_38;
      }

      unint64_t v20 = v11;
      unint64_t v77 = v7;
      uint64_t v80 = v10;
      uint64_t v21 = v16;
      uint64_t v22 = a1;
      uint64_t v23 = a5;
      uint64_t v24 = v14;
      int IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
      uint64_t v14 = v24;
      a5 = v23;
      a1 = v22;
      uint64_t v16 = v21;
      unint64_t v7 = v77;
      uint64_t v10 = v80;
      uint64_t v13 = 36516LL;
      unint64_t v11 = v20;
      if (!IsValidCombiningCharacterForLatin1_1) {
        goto LABEL_114;
      }
    }

    uint64_t v17 = *v15;
    if (v17 <= 0x7F)
    {
      uint64_t v26 = v10 + 2;
      if ((v14 & 1) != 0)
      {
        uint64_t v26 = v10;
        uint64_t v27 = 0LL;
      }

      else
      {
        uint64_t v27 = "~}";
      }

      uint64_t v28 = "~";
      if ((v14 & 1) == 0) {
        uint64_t v28 = "~}~";
      }
      if ((_DWORD)v17 == 126) {
        uint64_t v29 = v26 + 1;
      }
      else {
        uint64_t v29 = v26;
      }
      if ((_DWORD)v17 == 126) {
        unsigned int v30 = v28;
      }
      else {
        unsigned int v30 = v27;
      }
      uint64_t v10 = v29 + 1;
      if (a5)
      {
        if (v29 >= a5)
        {
          else {
            size_t v74 = ~strlen(v30);
          }
          v10 += v74;
          goto LABEL_138;
        }

        if ((((_DWORD)v17 != 126) & v14) == 0)
        {
          char v31 = *v30;
          if (*v30)
          {
            unsigned int v32 = (unsigned __int8 *)(v30 + 1);
            do
            {
              *a4++ = v31;
              int v33 = *v32++;
              char v31 = v33;
            }

            while (v33);
          }
        }

        *a4++ = v17;
      }

      uint64_t v14 = 1LL;
      goto LABEL_110;
    }

_BYTE *__CFFromGB_HZ( uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  unint64_t v9 = (unint64_t)&a2[a3];
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    char v14 = 1;
    uint64_t v22 = a2;
    if (a5) {
      goto LABEL_75;
    }
    goto LABEL_80;
  }

  uint64_t v12 = 0LL;
  int v13 = a1 & 0xC0;
  char v14 = 1;
  uint64_t v15 = 0x3E22u;
  uint64_t v16 = &OBJC_IVAR_____NSBlockVariable_containedObject;
  uint64_t v17 = a2;
LABEL_3:
  char v18 = v14;
  if (a5) {
    BOOL v19 = v12 < a5;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = v19;
  uint64_t v21 = v17;
  while (1)
  {
    if (!v20)
    {
      char v14 = v18;
      uint64_t v22 = v17;
      if (a5) {
        goto LABEL_75;
      }
      goto LABEL_80;
    }

    uint64_t v22 = v21 + 1;
    int v23 = *v21;
    if ((v14 & 1) == 0) {
      break;
    }
    if (v23 != 126)
    {
      ++v12;
      if (a5) {
        *a4++ = v23;
      }
LABEL_52:
      uint64_t v17 = v22;
      goto LABEL_3;
    }

    uint64_t v22 = v21 + 2;
    int v24 = v21[1];
    if (v24 == 10)
    {
      v21 += 2;
LABEL_25:
      char v14 = 1;
      goto LABEL_26;
    }

    if (v24 != 123)
    {
      if (v24 != 126)
      {
LABEL_71:
        char v14 = 1;
        goto LABEL_73;
      }

      if (a5) {
        *a4++ = 126;
      }
      ++v12;
      goto LABEL_52;
    }

    char v14 = 0;
    v21 += 2;
LABEL_26:
  }

  if (v23 == 126)
  {
    if ((unint64_t)v22 >= v9)
    {
      if ((a1 & 1) == 0) {
        goto LABEL_72;
      }
    }

    else if ((a1 & 1) == 0 && *v22 != 125)
    {
      goto LABEL_72;
    }

    v21 += 2;
    goto LABEL_25;
  }

  unsigned int v25 = *v22 & 0x7F | ((v23 & 0x7F) << 8);
  uint64_t v26 = (unsigned __int16 *)&__CFFromGB2312CharMap;
  uint64_t v27 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + v15);
  while (2)
  {
    uint64_t v28 = (0xF83E0F83E0F83E1LL * (v27 - v26)) >> 1;
    uint64_t v29 = &v26[33 * v28];
    unsigned int v30 = *v29;
    if (v30 > v25)
    {
      uint64_t v27 = v29 - 33;
      goto LABEL_37;
    }

    if (v30 + 32 <= v25)
    {
      uint64_t v26 = v29 + 33;
LABEL_37:
      if (v26 > v27) {
        goto LABEL_48;
      }
      continue;
    }

    break;
  }

  unsigned __int16 v31 = v26[33 * v28 + 1 + (int)(v25 - v30)];
  if (v31) {
    BOOL v32 = v31 == 65533;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32)
  {
LABEL_48:
    if ((a1 & 1) == 0)
    {
      char v14 = 0;
      if (a5) {
        goto LABEL_75;
      }
      goto LABEL_80;
    }

    if (a5) {
      *a4++ = 63;
    }
    ++v12;
    uint64_t v22 = v21 + 2;
    goto LABEL_52;
  }

  if (!v13
    || (unsigned int v39 = v31,
        unsigned __int16 v40 = v31,
        int v33 = (*((uint64_t (**)(void))v16 + 448))(),
        unsigned __int16 v31 = v40,
        uint64_t v16 = &OBJC_IVAR_____NSBlockVariable_containedObject,
        uint64_t v15 = 15906LL,
        !v33))
  {
    if (a5) {
      *a4++ = v31;
    }
    uint64_t v35 = v12 + 1;
LABEL_65:
    uint64_t v22 = v21 + 2;
    uint64_t v12 = v35;
    goto LABEL_52;
  }

  int v34 = __CFStringEncodingDecomposeCharacter(a1, v39, v41, 15906LL);
  uint64_t v35 = v12 + (unsigned __int16)v34;
  if (!a5)
  {
    uint64_t v15 = 15906LL;
    uint64_t v16 = &OBJC_IVAR_____NSBlockVariable_containedObject;
    goto LABEL_65;
  }

  if (v35 <= a5)
  {
    uint64_t v15 = 15906LL;
    uint64_t v16 = &OBJC_IVAR_____NSBlockVariable_containedObject;
    if ((_WORD)v34)
    {
      uint64_t v36 = (__int16 *)v41;
      do
      {
        --v34;
        unsigned __int16 v37 = *v36++;
        *a4++ = v37;
      }

      while ((_WORD)v34);
    }

    goto LABEL_65;
  }

uint64_t __CFStringInitializeSystemEncoding()
{
  __CFIsReadyToInitializeCFStringEncoding SystemEncoding = 1;
  return CFStringGetSystemEncoding();
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  if ((__CFDefaultSystemEncoding & 1) == 0)
  {
    if ((__CFIsReadyToInitializeSystemEncoding & 1) != 0)
    {
      if ((__CFStringIsBeingInitialized & 1) == 0)
      {
        __CFStringIsBeingInitialized = 1;
        uint64_t Converter = CFStringEncodingGetConverter(0LL);
        __CFDefaultCFStringEncoding SystemEncoding = 1;
        if (!Converter) {
          uint64_t Converter = CFStringEncodingGetConverter(0LL);
        }
        if (*(_BYTE *)(Converter + 20) == 1) {
          uint64_t v1 = *(void *)(Converter + 8);
        }
        else {
          uint64_t v1 = 0LL;
        }
        __CFSetCharToUniCharFunc(v1);
        __CFStringIsBeingInitialized = 0;
      }
    }

    else if (!__CFCharToUniCharFunc)
    {
      uint64_t v2 = CFStringEncodingGetConverter(0LL);
      __CFSetCharToUniCharFunc(*(void *)(v2 + 8));
    }
  }

  return 0;
}

uint64_t __CFStringIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t __CFStringMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t __CFStringIsCF(uint64_t a1, _BYTE *a2, void *a3, BOOL *a4)
{
  char v9 = atomic_load((unint64_t *)(a1 + 8));
  *a2 = v9 & 1;
  char v10 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v11 = v10 & 5;
  char v12 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v13 = v12 & 0x60;
  if (v11 == 4)
  {
    char v14 = (unsigned __int8 ***)(a1 + 16);
    if (v13)
    {
      uint64_t v15 = *v14;
    }

    else
    {
      uint64_t v17 = atomic_load((unint64_t *)(a1 + 8));
      uint64_t v15 = (unsigned __int8 **)&v14[(v17 & 5) != 4];
    }

    uint64_t v16 = *(unsigned __int8 *)v15;
  }

  else if ((v12 & 0x60) != 0)
  {
    uint64_t v16 = *(void *)(a1 + 24);
  }

  else
  {
    uint64_t v16 = *(void *)(a1 + 16);
  }

  *a3 = v16;
  unsigned int v18 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t result = 1LL;
  *a4 = ((v18 >> 4) & 1) == 0;
  return result;
}

BOOL __CFStringIsEightBit(uint64_t a1)
{
  unsigned int v1 = atomic_load((unint64_t *)(a1 + 8));
  return ((v1 >> 4) & 1) == 0;
}

uint64_t CFStringFileSystemEncoding()
{
  if ((__CFDefaultFileSystemEncoding & 1) == 0) {
    __CFDefaultFileCFStringEncoding SystemEncoding = 1;
  }
  return 134217984LL;
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  CFIndex v2 = length;
  HIDWORD(v4) = encoding - 134217984;
  LODWORD(v4) = encoding - 134217984;
  int v3 = v4 >> 26;
  if ((v3 - 4) < 2 || v3 == 1)
  {
    CFIndex v6 = 4 * length;
    unint64_t v7 = (unint64_t)length >> 61;
    goto LABEL_7;
  }

  if (!v3)
  {
    CFIndex v8 = 3 * length;
    CFIndex v9 = 0x2AAAAAAAAAAAAAAALL;
    goto LABEL_12;
  }

  CFStringEncoding v11 = encoding & 0xFFF;
  if (v11 > 0x4FF)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v11 == 2817) {
        return v2;
      }
      if (v11 == 3071)
      {
        CFIndex v8 = 6 * length;
        CFIndex v9 = 0x1555555555555555LL;
LABEL_12:
        if (length > v9) {
          return -1LL;
        }
        else {
          return v8;
        }
      }
    }

    else if (v11 == 1280 || v11 == 1536)
    {
      return v2;
    }

    goto LABEL_29;
  }

  if ((encoding & 0xFFF) == 0) {
    return v2;
  }
  if (v11 == 256)
  {
    CFIndex v6 = 2 * length;
    unint64_t v7 = (unint64_t)length >> 62;
LABEL_7:
    if (v7) {
      return -1LL;
    }
    else {
      return v6;
    }
  }

  if (v11 == 513) {
    return v2;
  }
LABEL_29:
  uint64_t Converter = CFStringEncodingGetConverter(*(uint64_t *)&encoding);
  if (Converter)
  {
    unint64_t v13 = *((unsigned __int16 *)Converter + 8);
    int64_t v14 = 0x7FFFFFFFFFFFFFFFLL / v13;
    CFIndex v15 = v13 * v2;
    if (v14 < v2) {
      return -1LL;
    }
    else {
      return v15;
    }
  }

  return v2;
}

uint64_t __CFStringComputeEightBitStringEncoding()
{
  if ((__CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 & 1) != 0) {
    return 1536LL;
  }
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 1;
  int v1 = _CFExecutableLinkedOnOrAfter(9uLL);
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 0;
  if (v1)
  {
    uint64_t result = 1536LL;
LABEL_5:
    __CFDefaultEightBitStringEncoding = result;
    return result;
  }

  if (__CFStringIsBeingInitialized == 1 || __CFIsReadyToInitializeSystemEncoding == 0) {
    return 0LL;
  }
  uint64_t result = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    if (CFStringGetSystemEncoding() == -1) {
      return 1536LL;
    }
    uint64_t result = 0LL;
    goto LABEL_5;
  }

  return result;
}

BOOL __CFStringEqual(CFStringRef theString, CFStringRef a2)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  char v4 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v4 & 0x60) != 0)
  {
    CFIndex v6 = *p_data;
  }

  else
  {
    char v7 = atomic_load((unint64_t *)&theString->info);
    CFIndex v6 = (char *)&p_data[(v7 & 5) != 4LL];
  }

  char v8 = atomic_load((unint64_t *)&a2->info);
  CFIndex v9 = &a2->data;
  if ((v8 & 0x60) != 0)
  {
    char v10 = *v9;
  }

  else
  {
    char v11 = atomic_load((unint64_t *)&a2->info);
    char v10 = (char *)&v9[(v11 & 5) != 4LL];
  }

  char v12 = atomic_load((unint64_t *)&theString->info);
  if ((v12 & 5) == 4LL)
  {
    int64_t length = *v6;
  }

  else
  {
    char v14 = atomic_load((unint64_t *)&theString->info);
    if ((v14 & 0x60) != 0) {
      int64_t length = theString->length;
    }
    else {
      int64_t length = (int64_t)*p_data;
    }
  }

  char v15 = atomic_load((unint64_t *)&a2->info);
  if ((v15 & 5) == 4LL)
  {
    uint64_t v16 = *v10;
  }

  else
  {
    char v17 = atomic_load((unint64_t *)&a2->info);
    if ((v17 & 0x60) != 0) {
      uint64_t v16 = a2->length;
    }
    else {
      uint64_t v16 = (uint64_t)*v9;
    }
  }

  if (length == v16)
  {
    unint64_t v18 = atomic_load((unint64_t *)&theString->info);
    BOOL v19 = (unsigned __int8 *)&v6[(v18 >> 2) & 1];
    unint64_t v20 = atomic_load((unint64_t *)&a2->info);
    uint64_t v21 = (unsigned __int8 *)&v10[(v20 >> 2) & 1];
    char v22 = atomic_load((unint64_t *)&theString->info);
    if ((v22 & 0x10) == 0)
    {
      char v23 = atomic_load((unint64_t *)&a2->info);
      if ((v23 & 0x10) == 0) {
        return memcmp(v19, v21, length) == 0;
      }
    }

    char v25 = atomic_load((unint64_t *)&theString->info);
    if ((v25 & 0x10) != 0)
    {
      char v32 = atomic_load((unint64_t *)&a2->info);
      if ((v32 & 0x10) != 0)
      {
        if (length >= 1)
        {
          BOOL result = 1LL;
          while (1)
          {
            int v40 = *(unsigned __int16 *)v19;
            v19 += 2;
            int v39 = v40;
            int v41 = *(unsigned __int16 *)v21;
            v21 += 2;
            if (v39 != v41) {
              break;
            }
            if (!--length) {
              return result;
            }
          }

          return 0LL;
        }
      }

      else
      {
        CFStringRef theStringa = a2;
        uint64_t v82 = 0LL;
        int64_t v83 = length;
        CharactersPtr = CFStringGetCharactersPtr(a2);
        int v34 = 0LL;
        uint64_t v80 = CharactersPtr;
        if (!CharactersPtr)
        {
          int v35 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            int v35 = __CFDefaultEightBitStringEncoding;
          }

          if (v35 != 1536)
          {
            if (v35 == -1)
            {
              __CFStringComputeEightBitStringEncoding();
              int v35 = __CFDefaultEightBitStringEncoding;
            }

            if (v35 != 1536) {
              goto LABEL_42;
            }
          }

          p_info = &a2->info;
          char v37 = atomic_load((unint64_t *)&a2->info);
          if ((v37 & 0x10) == 0 || (char v38 = atomic_load((unint64_t *)p_info), (v38 & 8) != 0))
          {
            char v44 = atomic_load((unint64_t *)p_info);
            if ((v44 & 0x60) != 0)
            {
              uint64_t v45 = *v9;
            }

            else
            {
              char v62 = atomic_load((unint64_t *)&a2->info);
              uint64_t v45 = (char *)&v9[(v62 & 5) != 4LL];
            }

            unint64_t v63 = atomic_load((unint64_t *)&a2->info);
            int v34 = &v45[(v63 >> 2) & 1];
          }

          else
          {
LABEL_42:
            int v34 = 0LL;
          }
        }

        uint64_t v84 = 0LL;
        uint64_t v85 = 0LL;
        uint64_t v81 = v34;
        if (length >= 1)
        {
          uint64_t v64 = 0LL;
          uint64_t v65 = 0LL;
          uint64_t v66 = 0LL;
          for (uint64_t i = 64LL; ; ++i)
          {
            uint64_t v68 = (unint64_t)v66 >= 4 ? 4LL : v66;
            if (v80)
            {
              UniChar v69 = v80[v66 + v82];
            }

            else if (v81)
            {
              UniChar v69 = v81[v82 + v66];
            }

            else
            {
              if (v85 <= v66 || v65 > v66)
              {
                uint64_t v71 = -v68;
                uint64_t v72 = v68 + v64;
                uint64_t v73 = i - v68;
                uint64_t v74 = v66 + v71;
                int64_t v75 = v74 + 64;
                if (v74 + 64 >= v83) {
                  int64_t v75 = v83;
                }
                uint64_t v84 = v74;
                uint64_t v85 = v75;
                v76.CFIndex location = v74 + v82;
                if (v83 >= v73) {
                  uint64_t v77 = v73;
                }
                else {
                  uint64_t v77 = v83;
                }
                v76.int64_t length = v77 + v72;
                CFStringGetCharacters(theStringa, v76, v78);
                uint64_t v65 = v84;
              }

              UniChar v69 = v78[v66 - v65];
            }

            ++v66;
            --v64;
            if (length == v66) {
              return 1LL;
            }
          }

          return 0LL;
        }
      }
    }

    else
    {
      CFStringRef theStringa = theString;
      uint64_t v82 = 0LL;
      int64_t v83 = length;
      uint64_t v26 = CFStringGetCharactersPtr(theString);
      uint64_t v27 = 0LL;
      uint64_t v80 = v26;
      if (!v26)
      {
        int v28 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding();
          int v28 = __CFDefaultEightBitStringEncoding;
        }

        if (v28 != 1536)
        {
          if (v28 == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            int v28 = __CFDefaultEightBitStringEncoding;
          }

          if (v28 != 1536) {
            goto LABEL_31;
          }
        }

        uint64_t v29 = &theString->info;
        char v30 = atomic_load((unint64_t *)&theString->info);
        if ((v30 & 0x10) == 0 || (char v31 = atomic_load((unint64_t *)v29), (v31 & 8) != 0))
        {
          char v42 = atomic_load((unint64_t *)v29);
          if ((v42 & 0x60) != 0)
          {
            uint64_t v43 = *p_data;
          }

          else
          {
            char v46 = atomic_load((unint64_t *)&theString->info);
            uint64_t v43 = (char *)&p_data[(v46 & 5) != 4LL];
          }

          unint64_t v47 = atomic_load((unint64_t *)&theString->info);
          uint64_t v27 = &v43[(v47 >> 2) & 1];
        }

        else
        {
LABEL_31:
          uint64_t v27 = 0LL;
        }
      }

      uint64_t v84 = 0LL;
      uint64_t v85 = 0LL;
      uint64_t v81 = v27;
      if (length >= 1)
      {
        uint64_t v48 = 0LL;
        uint64_t v49 = 0LL;
        uint64_t v50 = 0LL;
        for (uint64_t j = 64LL; ; ++j)
        {
          uint64_t v52 = (unint64_t)v50 >= 4 ? 4LL : v50;
          if (v80)
          {
            UniChar v53 = v80[v50 + v82];
          }

          else if (v81)
          {
            UniChar v53 = v81[v82 + v50];
          }

          else
          {
            if (v85 <= v50 || v49 > v50)
            {
              uint64_t v55 = -v52;
              uint64_t v56 = v52 + v48;
              uint64_t v57 = j - v52;
              uint64_t v58 = v50 + v55;
              int64_t v59 = v58 + 64;
              if (v58 + 64 >= v83) {
                int64_t v59 = v83;
              }
              uint64_t v84 = v58;
              uint64_t v85 = v59;
              v60.CFIndex location = v58 + v82;
              if (v83 >= v57) {
                uint64_t v61 = v57;
              }
              else {
                uint64_t v61 = v83;
              }
              v60.int64_t length = v61 + v56;
              CFStringGetCharacters(theStringa, v60, v78);
              uint64_t v49 = v84;
            }

            UniChar v53 = v78[v50 - v49];
          }

          ++v50;
          --v48;
          if (length == v50) {
            return 1LL;
          }
        }

        return 0LL;
      }
    }

    return 1LL;
  }

  return 0LL;
}

uint64_t __CFStrHashEightBit2(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0LL;
    uint64_t v4 = a2;
    do
    {
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * a1[v5 + 3])
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * a1[v5])
      BOOL v6 = v5 >= 0x1C;
      v5 += 4LL;
    }

    while (!v6);
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v8 + v7))
      uint64_t v9 = v7 - 16;
      v7 += 4LL;
    }

    while (v9 < 12);
    char v10 = &a1[a2 - 32];
    do
    {
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v10[3])
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v10)
      v10 += 4;
    }

    while (v10 < &a1[a2]);
  }

  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      CFIndex v2 = a1;
      uint64_t v4 = a2;
      int v3 = a1;
    }

    else
    {
      CFIndex v2 = a1;
      int v3 = a1;
      uint64_t v4 = a2;
      do
      {
        uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v3[3])
           + 67503105 * v4
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v3)
        v3 += 4;
        v2 += 4;
      }

      while (v3 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }

    if (v3 < &a1[a2])
    {
      char v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v3++;
        uint64_t v4 = 257 * v4 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v12);
        --v11;
      }

      while (v11);
    }
  }

  return (v4 << (a2 & 0x1F)) + v4;
}

uint64_t CFStringHashISOLatin1CString(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0LL;
    uint64_t v4 = a2;
    do
    {
      uint64_t v4 = a1[v5 + 3] + 67503105 * v4 + 257 * (257 * ((a1[v5] | (a1[v5] << 8)) + a1[v5 + 1]) + a1[v5 + 2]);
      BOOL v6 = v5 >= 0x1C;
      v5 += 4LL;
    }

    while (!v6);
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v4 = *(unsigned __int8 *)(v8 + v7 + 3)
         + 67503105 * v4
         + 257
         * (257
      uint64_t v9 = v7 - 16;
      v7 += 4LL;
    }

    while (v9 < 12);
    char v10 = &a1[a2 - 32];
    do
    {
      uint64_t v4 = v10[3] + 67503105 * v4 + 257 * (257 * ((*v10 | (*v10 << 8)) + v10[1]) + v10[2]);
      v10 += 4;
    }

    while (v10 < &a1[a2]);
  }

  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      CFIndex v2 = a1;
      uint64_t v4 = a2;
      int v3 = a1;
    }

    else
    {
      CFIndex v2 = a1;
      int v3 = a1;
      uint64_t v4 = a2;
      do
      {
        uint64_t v4 = v3[3] + 67503105 * v4 + 257 * (257 * ((*v3 | (*v3 << 8)) + v3[1]) + v3[2]);
        v3 += 4;
        v2 += 4;
      }

      while (v3 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }

    if (v3 < &a1[a2])
    {
      char v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v3++;
        uint64_t v4 = 257 * v4 + v12;
        --v11;
      }

      while (v11);
    }
  }

  return (v4 << (a2 & 0x1F)) + v4;
}

uint64_t CFStringHashCString(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0LL;
    uint64_t v4 = a2;
    do
    {
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * a1[v5 + 3])
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * a1[v5])
      BOOL v6 = v5 >= 0x1C;
      v5 += 4LL;
    }

    while (!v6);
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v8 + v7))
      uint64_t v9 = v7 - 16;
      v7 += 4LL;
    }

    while (v9 < 12);
    char v10 = &a1[a2 - 32];
    do
    {
      uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v10[3])
         + 67503105 * v4
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v10)
      v10 += 4;
    }

    while (v10 < &a1[a2]);
  }

  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      CFIndex v2 = a1;
      uint64_t v4 = a2;
      int v3 = a1;
    }

    else
    {
      CFIndex v2 = a1;
      int v3 = a1;
      uint64_t v4 = a2;
      do
      {
        uint64_t v4 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v3[3])
           + 67503105 * v4
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v3)
        v3 += 4;
        v2 += 4;
      }

      while (v3 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }

    if (v3 < &a1[a2])
    {
      char v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        unsigned int v12 = *v3++;
        uint64_t v4 = 257 * v4 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v12);
        --v11;
      }

      while (v11);
    }
  }

  return (v4 << (a2 & 0x1F)) + v4;
}

uint64_t CFStringHashCharacters(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 >= 97)
  {
    unint64_t v5 = 0LL;
    uint64_t v4 = a2;
    do
    {
      uint64_t v4 = a1[v5 + 3] + 67503105 * v4 + 257 * (257 * (257 * a1[v5] + a1[v5 + 1]) + a1[v5 + 2]);
      BOOL v6 = v5 >= 0x1C;
      v5 += 4LL;
    }

    while (!v6);
    uint64_t v7 = (unsigned __int16 *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFFELL) - 32);
    for (uint64_t i = -20LL; i < 12; i += 4LL)
    {
      uint64_t v4 = v7[3] + 67503105 * v4 + 257 * (257 * (257 * *v7 + v7[1]) + v7[2]);
      v7 += 4;
    }

    uint64_t v9 = &a1[a2];
    char v10 = v9 - 32;
    do
    {
      uint64_t v4 = v10[3] + 67503105 * v4 + 257 * (257 * (257 * *v10 + v10[1]) + v10[2]);
      v10 += 4;
    }

    while (v10 < v9);
  }

  else
  {
    CFIndex v2 = &a1[a2];
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      uint64_t v4 = a2;
    }

    else
    {
      int v3 = &a1[a2 & 0xFFFFFFFFFFFFFFFCLL];
      uint64_t v4 = a2;
      do
      {
        uint64_t v4 = a1[3] + 67503105 * v4 + 257 * (257 * (257 * *a1 + a1[1]) + a1[2]);
        a1 += 4;
      }

      while (a1 < v3);
    }

    while (a1 < v2)
    {
      unsigned int v11 = *a1++;
      uint64_t v4 = 257 * v4 + v11;
    }
  }

  return (v4 << (a2 & 0x1F)) + v4;
}

uint64_t CFStringHashNSString(void *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v2 = [a1 length];
  uint64_t v3 = v2;
  uint64_t v4 = v9;
  if (v2 >= 97)
  {
    objc_msgSend(a1, "getCharacters:range:", v9, 0, 32);
    objc_msgSend(a1, "getCharacters:range:", &v10, ((unint64_t)v2 >> 1) - 16, 32);
    objc_msgSend(a1, "getCharacters:range:", &v11, v2 - 32, 32);
    unint64_t v5 = (unsigned __int16 *)&v12;
    BOOL v6 = (unsigned __int16 *)&v12;
LABEL_5:
    uint64_t v4 = v9;
    do
    {
      uint64_t v3 = v4[3] + 67503105 * v3 + 257 * (257 * (257 * *v4 + v4[1]) + v4[2]);
      v4 += 4;
    }

    while (v4 < v6);
    goto LABEL_9;
  }

  objc_msgSend(a1, "getCharacters:range:", v9, 0, v2);
  unint64_t v5 = &v9[v2];
  if ((uint64_t)(v2 & 0xFFFFFFFFFFFFFFFCLL) >= 1)
  {
    BOOL v6 = &v9[v2 & 0xFFFFFFFFFFFFFFFCLL];
    goto LABEL_5;
  }

uint64_t __CFStringHash(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v2 = (unsigned __int16 **)(a1 + 16);
  if ((v1 & 0x60) != 0)
  {
    uint64_t v3 = *v2;
  }

  else
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v3 = (unsigned __int16 *)&v2[(v4 & 5) != 4LL];
  }

  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 5) == 4LL)
  {
    uint64_t v6 = *(unsigned __int8 *)v3;
  }

  else
  {
    char v7 = atomic_load((unint64_t *)(a1 + 8));
    if ((v7 & 0x60) != 0) {
      uint64_t v6 = *(void *)(a1 + 24);
    }
    else {
      uint64_t v6 = (uint64_t)*v2;
    }
  }

  char v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 0x10) != 0)
  {
    if (v6 >= 97)
    {
      unint64_t v24 = 0LL;
      uint64_t v14 = v6;
      do
      {
        uint64_t v14 = v3[v24 + 3] + 67503105 * v14 + 257 * (257 * (257 * v3[v24] + v3[v24 + 1]) + v3[v24 + 2]);
        BOOL v18 = v24 >= 0x1C;
        v24 += 4LL;
      }

      while (!v18);
      char v25 = (unsigned __int16 *)((char *)v3 + (v6 & 0xFFFFFFFFFFFFFFFELL) - 32);
      for (uint64_t i = -20LL; i < 12; i += 4LL)
      {
        uint64_t v14 = v25[3] + 67503105 * v14 + 257 * (257 * (257 * *v25 + v25[1]) + v25[2]);
        v25 += 4;
      }

      uint64_t v27 = &v3[v6];
      int v28 = v27 - 32;
      do
      {
        uint64_t v14 = v28[3] + 67503105 * v14 + 257 * (257 * (257 * *v28 + v28[1]) + v28[2]);
        v28 += 4;
      }

      while (v28 < v27);
    }

    else
    {
      char v15 = &v3[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        uint64_t v14 = v6;
      }

      else
      {
        uint64_t v16 = &v3[v6 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v14 = v6;
        do
        {
          uint64_t v14 = v3[3] + 67503105 * v14 + 257 * (257 * (257 * *v3 + v3[1]) + v3[2]);
          v3 += 4;
        }

        while (v3 < v16);
      }

      while (v3 < v15)
      {
        unsigned int v30 = *v3++;
        uint64_t v14 = 257 * v14 + v30;
      }
    }
  }

  else
  {
    unint64_t v9 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v10 = (v9 >> 2) & 1;
    uint64_t v11 = (unsigned __int8 *)v3 + v10;
    if (v6 >= 97)
    {
      unint64_t v17 = 0LL;
      uint64_t v14 = v6;
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *((unsigned __int8 *)v3 + v10 + v17 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *((unsigned __int8 *)v3 + v10 + v17))
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *((unsigned __int8 *)v3 + v10 + v17 + 1)))
             + *(unsigned __int16 *)(__CFCharToUniCharTable
                                                 + 2LL * *((unsigned __int8 *)v3 + v10 + v17 + 2)));
        BOOL v18 = v17 >= 0x1C;
        v17 += 4LL;
      }

      while (!v18);
      uint64_t v19 = 0LL;
      uint64_t v20 = (uint64_t)v3 + v10 + ((unint64_t)v6 >> 1) - 16;
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v20 + v19 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(v20 + v19))
        uint64_t v21 = v19 - 16;
        v19 += 4LL;
      }

      while (v21 < 12);
      char v22 = &v11[v6];
      char v23 = &v11[v6 - 32];
      do
      {
        uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v23[3])
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v23)
        v23 += 4;
      }

      while (v23 < v22);
    }

    else
    {
      uint64_t v12 = &v11[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        uint64_t v14 = v6;
      }

      else
      {
        unint64_t v13 = &v11[v6 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v14 = v6;
        do
        {
          uint64_t v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * v11[3])
              + 67503105 * v14
              + 257
              * (257
               * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *v11)
          v11 += 4;
        }

        while (v11 < v13);
      }
    }
  }

  return (v14 << (v6 & 0x1F)) + v14;
}

unint64_t *_CFNonObjCStringCreateCopy( __objc2_class **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (unint64_t *)(a2 + 8);
  char v11 = atomic_load((unint64_t *)(a2 + 8));
  if ((v11 & 1) != 0) {
    goto LABEL_12;
  }
  uint64_t v12 = a1;
  if (a1)
  {
    if (a2 < 0)
    {
LABEL_4:
      unint64_t v13 = &kCFAllocatorSystemDefault;
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v14 = _CFGetTSD(1u);
    uint64_t v12 = &__kCFAllocatorSystemDefault;
    if (v14) {
      uint64_t v12 = (__objc2_class **)v14;
    }
    if (a2 < 0) {
      goto LABEL_4;
    }
  }

  char v15 = atomic_load((unint64_t *)(a2 + 8));
  if (v15 < 0) {
    unint64_t v13 = &kCFAllocatorSystemDefault;
  }
  else {
    unint64_t v13 = (const CFAllocatorRef *)(a2 - 16);
  }
LABEL_11:
  if (v12 == *(__objc2_class ***)v13)
  {
    char v22 = atomic_load((unint64_t *)(a2 + 8));
    if ((v22 & 0x60) == 0) {
      return _CFNonObjCRetain((unint64_t *)a2);
    }
    char v23 = atomic_load((unint64_t *)(a2 + 8));
    if ((v23 & 0x20) != 0 || __CFRuntimeIsImmortal(a2)) {
      return _CFNonObjCRetain((unint64_t *)a2);
    }
  }

void __CFStringDeallocate(uint64_t a1)
{
  char v1 = (unint64_t *)(a1 + 8);
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x60) == 0) {
    return;
  }
  char v4 = atomic_load(v1);
  char v5 = atomic_load(v1);
  if ((v5 & 0x20) == 0) {
    goto LABEL_11;
  }
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  char v7 = (void **)(a1 + 16);
  if ((v6 & 0x60) == 0)
  {
    char v15 = atomic_load((unint64_t *)(a1 + 8));
    char v8 = &v7[(v15 & 5) != 4LL];
    if (v8) {
      goto LABEL_5;
    }
LABEL_11:
    if ((v4 & 1) == 0) {
      return;
    }
    goto LABEL_14;
  }

  char v8 = (void **)*v7;
  if (!*v7) {
    goto LABEL_11;
  }
LABEL_5:
  if ((v4 & 1) == 0)
  {
    char v9 = atomic_load((unint64_t *)(a1 + 8));
    if ((~v9 & 0x60) == 0)
    {
      char v10 = atomic_load((unint64_t *)(a1 + 8));
      BOOL v11 = (v10 & 5) == 4LL;
      uint64_t v12 = 32LL;
      if (v11) {
        uint64_t v12 = 24LL;
      }
      unint64_t v13 = *(const __CFAllocator **)(a1 + v12);
      CFAllocatorDeallocate(v13, v8);
      uint64_t v14 = v13;
      goto LABEL_16;
    }

    if (a1 < 0)
    {
      char v17 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }

    else
    {
      char v18 = atomic_load((unint64_t *)(a1 + 8));
      if (v18 < 0) {
        char v17 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }
      else {
        char v17 = (CFAllocatorRef *)(a1 - 16);
      }
    }

    CFAllocatorDeallocate(*v17, v8);
    return;
  }

  __CFStrDeallocateMutableContents(a1, v8);
LABEL_14:
  char v16 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v16 & 0x60) == 0)
  {
    uint64_t v14 = *(const __CFAllocator **)(a1 + 48);
LABEL_16:
    CFRelease(v14);
  }

CFStringRef __CFStringCopyFormattingDescription(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000LL) != 0)
  {
    p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
  }

  else
  {
    char v2 = atomic_load((unint64_t *)&theString->info);
    if (v2 < 0) {
      p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }
    else {
      p_data = (CFAllocatorRef *)&theString[-1].data;
    }
  }

  return CFStringCreateCopy(*p_data, theString);
}

CFStringRef __CFStringCopyDescription(uint64_t a1)
{
  char v1 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000LL) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if (v2 < 0) {
      char v1 = &kCFAllocatorSystemDefault;
    }
    else {
      char v1 = (const CFAllocatorRef *)(a1 - 16);
    }
  }

  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFString %p [%p]>{contents = %@}",  a1,  *v1,  a1);
}

uint64_t _CFStringInitializeTaggedStrings(uint64_t a1)
{
  uint64_t result = _CFExecutableLinkedOnOrAfter(8uLL);
  if ((_DWORD)result)
  {
    if (*MEMORY[0x189616650])
    {
      uint64_t result = _objc_registerTaggedPointerClass();
      __CFTaggedStringClass Class = a1;
    }
  }

  return result;
}

CFTypeID CFStringGetTypeID(void)
{
  return 7LL;
}

CFTypeRef __CFStringCreateImmutableFunnel3( __objc2_class **allocator, int8x16_t *ptr, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v112[126] = *MEMORY[0x1895F89C0];
  uint64_t v8 = (a5 >> 2) & 1;
  BOOL v105 = (a5 & 0x30) != 0;
  CFIndex v9 = a3 - v8;
  if (a3 < v8)
  {
    return 0LL;
  }

  unsigned int v12 = a5;
  unint64_t v14 = a3;
  char v16 = allocator;
  int v102 = a5 & 0x30;
  if (!allocator)
  {
    uint64_t v17 = _CFGetTSD(1u);
    if (v17) {
      char v16 = (__objc2_class **)v17;
    }
    else {
      char v16 = &__kCFAllocatorSystemDefault;
    }
  }

  char v18 = (const __CFAllocator *)v16;
  if (a6 != -1)
  {
    if (a6)
    {
      char v18 = (const __CFAllocator *)a6;
      if (v14) {
        goto LABEL_19;
      }
      goto LABEL_16;
    }

    uint64_t v19 = _CFGetTSD(1u);
    if (v19) {
      char v18 = (const __CFAllocator *)v19;
    }
    else {
      char v18 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  if (v14) {
    goto LABEL_19;
  }
LABEL_16:
  if (&__kCFAllocatorSystemDefault == v16
    || !v16 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
  {
    if (v102 && v18 != (const __CFAllocator *)&__kCFAllocatorNull) {
      CFAllocatorDeallocate(v18, ptr);
    }
    return CFRetain(&stru_1899EF170);
  }

LABEL_227:
  if (v109) {
    CFAllocatorDeallocate(allocatora, ptr);
  }
  return (CFTypeRef)Instance;
}

CFTypeRef __CFStringCreateImmutableFunnel2( __objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, char a9, uint64_t a10)
{
  return __CFStringCreateImmutableFunnel3( a1,  a2,  a3,  a4,  (a5 != 0) | (2 * (a6 != 0)) | (a7 != 0) | (8 * ((_DWORD)a8 != 0)) | (16 * (a9 != 0)),  a10,  0LL,  a8);
}

CFStringRef CFStringCreateWithPascalString( CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)pStr,  *pStr + 1LL,  *(uint64_t *)&encoding,  4LL,  -1LL,  0LL,  v3);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  uint64_t v3 = *(void *)&encoding;
  size_t v6 = strlen(cStr);
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)cStr,  v6,  v3,  8LL,  -1LL,  0LL,  v7);
}

CFStringRef CFStringCreateWithPascalStringNoCopy( CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)pStr,  *pStr + 1LL,  *(uint64_t *)&encoding,  20LL,  (uint64_t)contentsDeallocator,  0LL,  v4);
}

CFStringRef CFStringCreateWithCStringNoCopy( CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  uint64_t v5 = *(void *)&encoding;
  size_t v8 = strlen(cStr);
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)cStr,  v8,  v5,  24LL,  (uint64_t)contentsDeallocator,  0LL,  v9);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)chars,  2 * numChars,  256LL,  2LL,  -1LL,  0LL,  v3);
}

CFStringRef CFStringCreateWithCharactersNoCopy( CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)chars,  2 * numChars,  256LL,  16LL,  (uint64_t)contentsDeallocator,  0LL,  v4);
}

CFStringRef CFStringCreateWithBytes( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  (int8x16_t *)bytes,  numBytes,  *(uint64_t *)&encoding,  (isExternalRepresentation != 0) | 2u,  -1LL,  0LL,  v5);
}

CFTypeRef _CFStringCreateWithBytesNoCopy( __objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x12u, a6, 0LL, a8);
}

CFStringRef CFStringCreateWithBytesNoCopy( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3(alloc, (void *)bytes);
}

CFTypeRef _CFStringCreateWithBytesNoCopyDisallowROM( __objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x22u, a6, 0LL, a8);
}

CFStringRef CFStringCreateStringWithValidatedFormat( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, CFErrorRef *errorPtr, ...)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0LL, (uint64_t)validFormatSpecifiers);
}

CFStringRef CFStringCreateStringWithValidatedFormatAndArguments( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, va_list arguments, CFErrorRef *errorPtr)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0LL, (uint64_t)validFormatSpecifiers);
}

CFStringRef _CFStringCreateStringWithValidatedFormatAux( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  else {
    CFStringRef Copy = 0LL;
  }
  CFRelease(Mutable);
  return Copy;
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  uint64_t v7 = alloc;
  if (!alloc)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      uint64_t v7 = (const __CFAllocator *)v8;
    }
    else {
      uint64_t v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t Instance = (__CFString *)_CFRuntimeCreateInstance(v7, 7uLL, 32LL, 0LL, v2, v3, v4, v5);
  if (Instance)
  {
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    p_info = (unint64_t *)&Instance->info;
    unint64_t v11 = atomic_load((unint64_t *)&Instance->info);
    while (1)
    {
      unint64_t v12 = __ldaxr(p_info);
      if (v12 != v11) {
        break;
      }
      if (__stlxr(v11 & 0xFFFFFFFFFFFFFF9FLL | 0x20, p_info)) {
        goto LABEL_13;
      }
      int v13 = 1;
LABEL_14:
      unint64_t v11 = v12;
      if (v13)
      {
        unint64_t v14 = atomic_load(p_info);
        while (1)
        {
          unint64_t v15 = __ldaxr(p_info);
          if (v15 != v14) {
            break;
          }
          if (__stlxr(v14 & 0xFFFFFFFFFFFFFFEFLL, p_info)) {
            goto LABEL_20;
          }
          int v16 = 1;
LABEL_21:
          unint64_t v14 = v15;
          if (v16)
          {
            unint64_t v17 = atomic_load(p_info);
            while (1)
            {
              unint64_t v18 = __ldaxr(p_info);
              if (v18 != v17) {
                break;
              }
              if (__stlxr(v17 | 1, p_info)) {
                goto LABEL_27;
              }
              int v19 = 1;
LABEL_28:
              unint64_t v17 = v18;
              if (v19)
              {
                Instance->data = 0LL;
                char v20 = atomic_load((unint64_t *)&Instance->info);
                BOOL v21 = (v20 & 0x60) == 0LL;
                uint64_t v22 = 24LL;
                if (v21) {
                  uint64_t v22 = 16LL;
                }
                *(void **)((char *)&Instance->isa + v22) = 0LL;
                CFIndex v23 = (16 * maxLength) | 2;
                if (!maxLength) {
                  CFIndex v23 = 512LL;
                }
                Instance[1].isa = 0LL;
                Instance[1].info = v23;
                char v24 = atomic_load((unint64_t *)&Instance->info);
                if ((~v24 & 0x60) == 0)
                {
                  CFRetain(v7);
                  Instance[1].data = (char *)v7;
                }

                return Instance;
              }
            }

            __clrex();
LABEL_27:
            int v19 = 0;
            goto LABEL_28;
          }
        }

        __clrex();
LABEL_20:
        int v16 = 0;
        goto LABEL_21;
      }
    }

    __clrex();
LABEL_13:
    int v13 = 0;
    goto LABEL_14;
  }

  return Instance;
}

void __CFStringAppendFormatCore( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __CFString *a9, uint64_t a10, _OWORD *a11, uint64_t a12, __int16 *a13, CFArrayRef *a14, CFErrorRef *a15)
{
  uint64_t v15 = MEMORY[0x1895F8858](a1, a2);
  unint64_t v17 = v16;
  int v19 = v18;
  CFTypeRef cf = v21;
  v502 = v20;
  CFIndex v23 = v22;
  unint64_t v25 = v24;
  v499 = v26;
  int8x16_t v27 = (__CFString *)v15;
  int8x16_t v29 = a14;
  int8x16_t v28 = a15;
  uint64_t v528 = *MEMORY[0x1895F89C0];
  bzero(v525, 0x3D0uLL);
  v504 = v25;
  if (v25)
  {
    CFTypeID v30 = CFGetTypeID(v25);
    BOOL v503 = v30 == CFLocaleGetTypeID();
  }

  else
  {
    BOOL v503 = 0;
  }

  CFArrayRef theArray = 0LL;
  p_CFArrayRef theArray = &theArray;
  if (!a14) {
    p_CFArrayRef theArray = 0LL;
  }
  v507 = p_theArray;
  uint64_t FormatSpecifierConfiguration = _CFStringGetFormatSpecifierConfiguration(v17);
  if (FormatSpecifierConfiguration) {
    uint64_t v33 = (const __CFDictionary *)FormatSpecifierConfiguration;
  }
  else {
    uint64_t v33 = v23;
  }
  if (v19)
  {
    if (a10 >= 11)
    {
      if (!a15) {
        return;
      }
      CFMutableStringRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue( Mutable,  @"NSDebugDescription",  @"Exceeded maximum number of allowed nested stringsdict entry references");
      *a15 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 2048LL, Mutable);
LABEL_43:
      CFRelease(Mutable);
      return;
    }

    CFStringRef v505 = v27;
    uint64_t v35 = (uint64_t)v17;
    v524[0] = 0LL;
    v523[0] = 0LL;
    ptr[0] = 0LL;
    int8x16_t chars = 0uLL;
    CFIndex Length = CFStringGetLength(v19);
    __CFStringSetUpFormatAndSpecBuffers( (uint64_t)v19,  Length,  v524,  v523,  (UniChar **)ptr,  v527,  &chars.i64[1],  v526,  &chars,  v522);
    uint64_t v37 = (_BYTE *)chars.i64[1];
    int FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString( (uint64_t)v524[0],  (uint64_t)v523[0],  Length,  chars.i64[1],  0LL,  0LL);
    if (ptr[0] != v527) {
      CFAllocatorDeallocate(0LL, ptr[0]);
    }
    if (v37 != v526) {
      CFAllocatorDeallocate(0LL, v37);
    }
    if (!Length || !FormatSpecifiersInString)
    {
      if (!a15) {
        return;
      }
      CFMutableStringRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFStringRef v54 = CFStringCreateWithFormat(0LL, 0LL, @"Expected format '%@' is invalid", v19);
      CFDictionarySetValue(Mutable, @"NSDebugDescription", v54);
      *a15 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 2048LL, Mutable);
      CFRelease(v54);
      goto LABEL_43;
    }

    unint64_t v17 = (__CFString *)v35;
    int8x16_t v27 = (__CFString *)v505;
  }

  CFIndex v39 = CFStringGetLength(v17);
  if (v39 >= 0x80000000LL)
  {
    if (a15)
    {
LABEL_26:
      uint64_t v40 = _CFGetTSD(1u);
      if (v40) {
        __int32 v41 = (const __CFAllocator *)v40;
      }
      else {
        __int32 v41 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      uint64_t v42 = CFDictionaryCreateMutable(v41, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, @"NSDebugDescription", @"Overflow occurred");
      CFErrorRef v43 = CFErrorCreate(v41, @"NSCocoaErrorDomain", 2048LL, v42);
      char v44 = 0LL;
      uint64_t v45 = 0LL;
      goto LABEL_72;
    }

LABEL_884:
    char v44 = 0LL;
    CFDictionaryRef v500 = 0LL;
    uint64_t v70 = 0LL;
    BOOL v71 = 0LL;
    uint64_t v72 = 0LL;
    uint64_t v45 = 0LL;
    goto LABEL_885;
  }

  CFIndex range = v39;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)v17))
  {
    unint64_t v46 = 0LL;
    unint64_t v47 = 0LL;
LABEL_32:
    v48.int64_t length = range;
    goto LABEL_33;
  }

  char v61 = atomic_load((unint64_t *)&v17->info);
  char v62 = atomic_load((unint64_t *)&v17->info);
  uint64_t v63 = v62 & 0x60;
  p_data = &v17->data;
  if ((v61 & 0x10) != 0)
  {
    unint64_t v47 = 0LL;
    if (v63)
    {
      unint64_t v46 = (unint64_t)*p_data;
    }

    else
    {
      uint64_t v443 = atomic_load((unint64_t *)&v17->info);
      unint64_t v46 = (unint64_t)&p_data[(v443 & 5) != 4];
    }

    goto LABEL_32;
  }

  if (v63)
  {
    BOOL v65 = (char **)*p_data;
  }

  else
  {
    uint64_t v441 = atomic_load((unint64_t *)&v17->info);
    BOOL v65 = &p_data[(v441 & 5) != 4];
  }

  v48.int64_t length = range;
  unint64_t v46 = 0LL;
  if (v65)
  {
    unint64_t v442 = atomic_load((unint64_t *)&v17->info);
    unint64_t v47 = (unint64_t)v65 + ((v442 >> 2) & 1);
  }

  else
  {
    unint64_t v47 = 0LL;
  }

LABEL_104:
    size_t __count = v83;
    char v92 = v86 + 20;
    if (v91 + 1 >= (int)v79)
    {
      LODWORD(v84) = v91 + 1;
      goto LABEL_203;
    }

    unsigned int v93 = 0;
    uint64_t v94 = 0LL;
    int v95 = 0;
    int v96 = 0;
    int v97 = 0;
    int v492 = 0;
    v481 = v86 + 16;
    v473 = v86 + 25;
    unint64_t v98 = v86 + 26;
    uint64_t v99 = -1LL;
    unsigned __int8 v100 = -1;
    unsigned __int8 v101 = -1;
    LODWORD(v84) = v91 + 1;
    v508 = v86 + 20;
LABEL_106:
    uint64_t v102 = (int)v84;
    if (v80) {
      unsigned int v103 = *(unsigned __int8 *)(v80 + (int)v84);
    }
    else {
      unsigned int v103 = *(unsigned __int16 *)(v81 + 2LL * (int)v84);
    }
    LODWORD(v84) = v84 + 1;
    if (v99 < 0)
    {
      __src = v90;
      while (1)
      {
        while (v103 - 49 < 9)
        {
          uint64_t v108 = 0LL;
          else {
            int v109 = v84;
          }
          uint64_t v110 = v109 - (uint64_t)(int)v84;
          uint64_t v111 = (unsigned __int16 *)(v81 + 2LL * (int)v84);
          CFDataRef v112 = (unsigned __int8 *)(v80 + (int)v84);
          do
          {
            uint64_t v113 = (unsigned __int128)(v108 * (__int128)10LL) >> 64;
            uint64_t v114 = 10 * v108;
            if (v113 != v114 >> 63) {
              goto LABEL_284;
            }
            uint64_t v115 = v103 - 48LL;
            BOOL v53 = __OFADD__(v114, v115);
            uint64_t v108 = v114 + v115;
            if (v53) {
              goto LABEL_284;
            }
            if (!v110)
            {
              ImmutableFunnel3 = 0LL;
              char v90 = __src;
              __int16 *__src = 43;
              LODWORD(v84) = v109;
              unint64_t v81 = v494;
              char v92 = v86 + 20;
              goto LABEL_250;
            }

            if (v80) {
              unsigned int v103 = *v112;
            }
            else {
              unsigned int v103 = *v111;
            }
            --v110;
            ++v111;
            ++v112;
            LODWORD(v84) = v84 + 1;
          }

          while (v103 - 48 < 0xA);
          if (v103 == 36)
          {
            char v90 = __src;
            char v92 = v86 + 20;
            if (v108 >= 128)
            {
              if (a15)
              {
                uint64_t v452 = _CFGetTSD(1u);
                if (v452) {
                  v453 = (const __CFAllocator *)v452;
                }
                else {
                  v453 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
                }
                v454 = CFDictionaryCreateMutable( v453,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                CFDictionarySetValue(v454, @"NSDebugDescription", @"Overflow occurred");
                CFErrorRef v455 = CFErrorCreate(v453, @"NSCocoaErrorDomain", 2048LL, v454);
                CFRelease(v454);
                BOOL v71 = 0LL;
                *a15 = v455;
              }

              else
              {
                BOOL v71 = 0LL;
              }

              int8x16_t v29 = a14;
              char v44 = alloc;
              uint64_t v45 = v469;
              goto LABEL_875;
            }

            unint64_t v81 = v494;
            if (v101 == 254)
            {
              unsigned __int8 v101 = v108 - 1;
              _BYTE *v473 = v108 - 1;
            }

            else
            {
              unsigned __int8 v119 = v108 - 1;
              if (v100 == 254)
              {
                *unint64_t v98 = v119;
                unsigned __int8 v100 = v119;
              }

              else
              {
                v86[24] = v119;
              }
            }

    unsigned __int16 *v6 = v7;
    return v8;
  }

  return v9;
}

LABEL_159:
            if ((int)v84 >= (int)v79)
            {
LABEL_203:
              ImmutableFunnel3 = 0LL;
              *char v90 = 43;
              goto LABEL_250;
            }

            goto LABEL_106;
          }

          if (v492) {
            unint64_t v116 = v86 + 16;
          }
          else {
            unint64_t v116 = v86 + 12;
          }
          char v92 = v86 + 20;
          if (v108 >= 0x80000000LL)
          {
LABEL_284:
            if (a15)
            {
              uint64_t v152 = _CFGetTSD(1u);
              if (v152) {
                v153 = (const __CFAllocator *)v152;
              }
              else {
                v153 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
              }
              int v154 = CFDictionaryCreateMutable( v153,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
              CFDictionarySetValue(v154, @"NSDebugDescription", @"Overflow occurred");
              CFErrorRef v155 = CFErrorCreate(v153, @"NSCocoaErrorDomain", 2048LL, v154);
              CFRelease(v154);
              uint64_t v72 = v513;
              BOOL v71 = 0LL;
              *a15 = v155;
            }

            else
            {
              BOOL v71 = 0LL;
            }

            int8x16_t v29 = a14;
            char v44 = alloc;
            uint64_t v45 = v469;
            uint64_t v70 = v487;
            goto LABEL_876;
          }

          *unint64_t v116 = v108;
          unint64_t v81 = v494;
        }

        switch(v103)
        {
          case ' ':
            if ((v93 & 4) != 0) {
              goto LABEL_200;
            }
            v93 |= 8u;
            goto LABEL_172;
          case '#':
            int v97 = 1;
            goto LABEL_200;
          case '*':
            unsigned __int8 v100 = -2;
            *unint64_t v98 = -2;
            goto LABEL_200;
          case '+':
            unsigned int v93 = v93 & 0xFFFFFFF3 | 4;
            goto LABEL_172;
          case '-':
            unsigned int v93 = v93 & 0xFFFFFFFC | 2;
            goto LABEL_172;
          case '.':
            if ((int)v84 >= (int)v79)
            {
              ImmutableFunnel3 = 0LL;
              __int16 v137 = 43;
LABEL_234:
              char v90 = __src;
              __int16 *__src = v137;
              goto LABEL_250;
            }

            if (v80) {
              unsigned int v103 = *(unsigned __int8 *)(v80 + (int)v84);
            }
            else {
              unsigned int v103 = *(unsigned __int16 *)(v81 + 2LL * (int)v84);
            }
            LODWORD(v84) = v84 + 1;
            int v492 = 1;
            if (v103 == 42)
            {
              unsigned __int8 v101 = -2;
              _BYTE *v473 = -2;
LABEL_175:
              int v492 = 1;
              goto LABEL_200;
            }

            break;
          case '0':
            if (v492)
            {
              _DWORD *v481 = 0;
              goto LABEL_175;
            }

            if ((v93 & 2) != 0)
            {
              int v492 = 0;
            }

            else
            {
              int v492 = 0;
              v93 |= 1u;
LABEL_172:
              *char v92 = v93;
            }

            goto LABEL_200;
          case '@':
            if (v97)
            {
              int v97 = 0;
              uint64_t v99 = (int)v84;
LABEL_200:
              char v90 = __src;
              goto LABEL_159;
            }

            ImmutableFunnel3 = 0LL;
            __int16 v139 = 37;
LABEL_247:
            char v90 = __src;
            __int16 *__src = v139;
LABEL_248:
            __int16 v138 = 4;
LABEL_249:
            *(_WORD *)int v86 = v138;
            goto LABEL_250;
          case 'A':
          case 'a':
            goto LABEL_215;
          case 'C':
            ImmutableFunnel3 = 0LL;
            char v90 = __src;
            __int16 *__src = 41;
            __int16 v138 = 2;
            goto LABEL_249;
          case 'D':
          case 'U':
          case 'd':
          case 'i':
          case 'u':
            int v135 = _CFExecutableLinkedOnOrAfter(8uLL);
            char v92 = v86 + 20;
            if (v135) {
              *v508 |= 0x20u;
            }
            uint64_t v72 = v513;
            if ((v103 & 0xFFDF) == 0x55) {
              char v136 = 4;
            }
            else {
              char v136 = 1;
            }
            v513[32 * __count + 28] = v136;
            unint64_t v80 = v495;
            uint64_t v79 = range;
            unint64_t v81 = v494;
            __int128 v85 = xmmword_180C44970;
            goto LABEL_233;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
            int v125 = _CFExecutableLinkedOnOrAfter(8uLL);
            char v92 = v86 + 20;
            if (v125) {
              *v508 |= 0x20u;
            }
            if (v103 - 65 >= 0x1A) {
              __int16 v126 = v103;
            }
            else {
              __int16 v126 = v103 + 32;
            }
            uint64_t v72 = v513;
            v513[32 * __count + 28] = ((v126 & 0xFFFE) == 102) | (2 * ((v126 & 0xFFFD) == 101));
            unint64_t v80 = v495;
            uint64_t v79 = range;
            unint64_t v81 = v494;
            __int128 v85 = xmmword_180C44970;
LABEL_215:
            char v90 = __src;
            __int16 *__src = 34;
            if (*(_WORD *)v86 == 5)
            {
              ImmutableFunnel3 = 0LL;
              goto LABEL_250;
            }

            ImmutableFunnel3 = 0LL;
            goto LABEL_248;
          case 'L':
            __int16 v120 = 5;
            goto LABEL_199;
          case 'O':
          case 'X':
          case 'o':
          case 'x':
LABEL_233:
            ImmutableFunnel3 = 0LL;
            __int16 v137 = 33;
            goto LABEL_234;
          case 'P':
            ImmutableFunnel3 = 0LL;
            __int16 v139 = 40;
            goto LABEL_247;
          case 'S':
            ImmutableFunnel3 = 0LL;
            __int16 v139 = 38;
            goto LABEL_247;
          case '[':
            if (!v96) {
              uint64_t v99 = (int)v84;
            }
            int v96 = 1;
            goto LABEL_200;
          case 'c':
            ImmutableFunnel3 = 0LL;
            char v90 = __src;
            __int16 *__src = 33;
            __int16 v138 = 1;
            goto LABEL_249;
          case 'h':
            if ((int)v84 < (int)v79
              && (!v80
                ? (int v121 = *(unsigned __int16 *)(v81 + 2LL * (int)v84))
                : (int v121 = *(unsigned __int8 *)(v80 + (int)v84)),
                  v121 == 104))
            {
              LODWORD(v84) = v84 + 1;
              __int16 v120 = 1;
            }

            else
            {
              __int16 v120 = 2;
            }

            goto LABEL_199;
          case 'j':
          case 'q':
          case 't':
          case 'z':
            goto LABEL_198;
          case 'l':
            if ((int)v84 < (int)v79)
            {
              int v122 = v80 ? *(unsigned __int8 *)(v80 + (int)v84) : *(unsigned __int16 *)(v81 + 2LL * (int)v84);
              if (v122 == 108) {
                LODWORD(v84) = v84 + 1;
              }
            }

              ++v9;
              uint64_t v56 = *((void *)buffer + 20);
              --v57;
              ++v58;
              if (v56 > v9) {
                continue;
              }
              break;
          }
        }

        break;
      }
    }
  }

  *a6 = v11;
  return v12;
}

LABEL_198:
            __int16 v120 = 4;
LABEL_199:
            *(_WORD *)int v86 = v120;
            goto LABEL_200;
          case 'n':
            ImmutableFunnel3 = 0LL;
            __int16 v139 = 42;
            goto LABEL_247;
          case 'p':
            ImmutableFunnel3 = 0LL;
            __int16 v139 = 35;
            goto LABEL_247;
          case 's':
            ImmutableFunnel3 = 0LL;
            __int16 v139 = 39;
            goto LABEL_247;
          default:
            __int16 *__src = 32;
            goto LABEL_281;
        }
      }
    }

    if (v103 >= 0x30 && v103 - 58 >= 7)
    {
      BOOL v105 = v103 == 95 || v103 - 91 >= 6;
      BOOL v106 = !v105;
      if (v103 <= 0x7A && !v106) {
        goto LABEL_159;
      }
    }

    if (v103 == 93)
    {
      uint64_t v117 = v102 - v99;
      BOOL v118 = v96 == 0;
      if (v96) {
        int v95 = 1;
      }
      else {
        int v96 = 0;
      }
      if (!v118) {
        uint64_t v94 = v117;
      }
      goto LABEL_159;
    }

    if (v103 != 64)
    {
      uint64_t v99 = -1LL;
      goto LABEL_159;
    }

    int v127 = v93 | 0x40;
    if (!v95) {
      int v127 = v93;
    }
    *char v92 = v127 | 0x10;
    if (v95) {
      uint64_t v128 = v94;
    }
    else {
      uint64_t v128 = v102 - v99;
    }
    *char v90 = 37;
    *(_WORD *)int v86 = 4;
    if (v128 < 1)
    {
      ImmutableFunnel3 = 0LL;
      goto LABEL_250;
    }

    char v129 = v90;
    if (v80)
    {
      uint64_t v130 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        unint64_t v80 = v495;
        uint64_t v130 = __CFDefaultEightBitStringEncoding;
      }

      unint64_t v131 = (int8x16_t *)(v80 + v99);
      int64_t v132 = v128;
      uint64_t v133 = 2LL;
      uint64_t v134 = -1LL;
    }

    else
    {
      int64_t v132 = 2 * v128;
      unint64_t v131 = (int8x16_t *)(v81 + 2 * v99);
      uint64_t v130 = 256LL;
      uint64_t v133 = 16LL;
      uint64_t v134 = (uint64_t)&__kCFAllocatorNull;
    }

    ImmutableFunnel3 = (const __CFString *)__CFStringCreateImmutableFunnel3(0LL, v131, v132, v130, v133, v134, 0LL, v79);
    char v90 = v129;
    uint64_t v72 = v513;
    unint64_t v80 = v495;
    uint64_t v79 = range;
    unint64_t v81 = v494;
    __int128 v85 = xmmword_180C44970;
    char v92 = v508;
    if (*v129 != 32)
    {
LABEL_250:
      if ((*v92 & 0x10) == 0)
      {
        size_t v83 = __count;
LABEL_275:
        *char v88 = v84 - v91;
        goto LABEL_276;
      }

      __srca = v90;
      if ((*v92 & 0x40) != 0)
      {
        if (!ImmutableFunnel3)
        {
          int64_t v143 = v500;
          v487[v486] = (unsigned __int8 *)v500;
LABEL_267:
          if (v143)
          {
            _BYTE *v89 = v486;
            CFTypeRef Value = CFDictionaryGetValue(v143, @"NSStringFormatSpecTypeKey");
            v150 = CFDictionaryGetValue(v143, @"NSStringFormatValueTypeKey");
            if (!Value || (v151 = v150, !CFEqual(Value, @"NSStringPluralRuleType")))
            {
              ++v486;
              uint64_t v72 = v513;
              unint64_t v80 = v495;
              uint64_t v79 = range;
              unint64_t v81 = v494;
              size_t v83 = __count;
              __int128 v85 = xmmword_180C44970;
              goto LABEL_275;
            }

            uint64_t v72 = v513;
            unint64_t v80 = v495;
            uint64_t v79 = range;
            unint64_t v81 = v494;
            size_t v83 = __count;
            __int128 v85 = xmmword_180C44970;
            if (v151)
            {
              ++v486;
              goto LABEL_275;
            }

            __int16 v124 = 44;
            ++v486;
          }

          else
          {
            __int16 v124 = 32;
            uint64_t v79 = range;
            unint64_t v81 = v494;
            size_t v83 = __count;
            __int128 v85 = xmmword_180C44970;
          }

          char v90 = __srca;
          goto LABEL_274;
        }

        v530.int64_t length = CFStringGetLength(ImmutableFunnel3);
        v530.CFIndex location = 0LL;
        if (CFStringCompareWithOptionsAndLocale(ImmutableFunnel3, @"tt", v530, 0LL, 0LL))
        {
          v531.int64_t length = CFStringGetLength(ImmutableFunnel3);
          char v141 = @"VocativeName";
          v531.CFIndex location = 0LL;
          if (!CFStringFindWithOptionsAndLocale(ImmutableFunnel3, @"VocativeName", v531, 8uLL, 0LL, 0LL))
          {
            MutableCFStringRef Copy = 0LL;
            CFDictionaryRef v500 = 0LL;
            goto LABEL_265;
          }
        }

        else
        {
          char v141 = @"TechnicalTerm";
        }

        v144 = CFDictionaryGetValue((CFDictionaryRef)&unk_189B3FFC0, @"NSStringFormatFamilyInfoKey");
        InputIdentifierFormatterMappingFromDescriptor = (const void *)_CFStringGetInputIdentifierFormatterMappingFromDescriptor((uint64_t)v144);
        ssize_t v146 = (const __CFDictionary *)CFDictionaryGetValue( (CFDictionaryRef)&unk_189B3FFC0,  @"NSStringFormatRuleInfoKey");
        unint64_t v147 = (const __CFDictionary *)CFDictionaryGetValue(v146, v141);
        CFIndex Count = CFDictionaryGetCount(v147);
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, v147);
        CFDictionaryAddValue( MutableCopy,  @"NSStringFormatFamilyInfoKey",  InputIdentifierFormatterMappingFromDescriptor);
        CFDictionaryRef v500 = MutableCopy;
        goto LABEL_265;
      }

      if (theDict && ImmutableFunnel3)
      {
        MutableCFStringRef Copy = (__CFDictionary *)CFDictionaryGetValue(theDict, ImmutableFunnel3);
LABEL_265:
        v142 = (__CFDictionary **)&v487[v486];
        char *v142 = MutableCopy;
        goto LABEL_266;
      }

      v142 = (__CFDictionary **)&v487[v486];
      char *v142 = 0LL;
      if (ImmutableFunnel3)
      {
LABEL_266:
        CFRelease(ImmutableFunnel3);
        int64_t v143 = *v142;
        uint64_t v72 = v513;
        unint64_t v80 = v495;
        goto LABEL_267;
      }

      __int16 v124 = 32;
      size_t v83 = __count;
LABEL_274:
      *char v90 = v124;
      goto LABEL_275;
    }

LABEL_422:
                CharactersPtr = v218;
              }

              else
              {
                BOOL v209 = v208 >= 0x30 && v208 - 58 >= 7;
                if (!v209
                  || (v208 != 95 ? (BOOL v210 = v208 - 91 >= 6) : (BOOL v210 = 1),
                      v210 ? (int v211 = 0) : (int v211 = 1),
                      v208 <= 0x7A ? (BOOL v212 = v211 == 0) : (BOOL v212 = 0),
                      !v212))
                {
                  if (v208 != 93)
                  {
                    if (v208 == 64)
                    {
LABEL_472:
                      __int16 v219 = 4;
                      __int16 v220 = 37;
                      goto LABEL_456;
                    }

                    uint64_t v206 = -1LL;
                  }
                }
              }

LABEL_423:
              ;
            }

            while (v205 < (int)v190);
LABEL_446:
            __int16 v220 = 43;
LABEL_455:
            __int16 v219 = cf2;
          }

LABEL_456:
          if (v191) {
            CFAllocatorDeallocate(alloc, v191);
          }
          p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
          if (!v472) {
            goto LABEL_464;
          }
          CFRange v236 = CFStringFind(v476, @"%", 0LL);
          if (v236.location != -1 || v236.length)
          {
            char v44 = alloc;
            v448 = CFDictionaryCreateMutable( alloc,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue( v448,  @"NSDebugDescription",  @"Invalid format for NSStringFormatValueTypeKey");
            *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048LL, v448);
            CFRelease(v448);
            uint64_t v45 = v469;
            uint64_t v70 = v487;
            goto LABEL_908;
          }

          if (((0xC0100000000uLL >> v220) & 1) != 0)
          {
LABEL_464:
            uint64_t v72 = v513;
          }

          else
          {
            *(_WORD *)v522 = v219;
            *(_WORD *)&v522[2] = v220;
            *(_OWORD *)&v522[4] = *(_OWORD *)(v165 + 4);
            *(_OWORD *)&v522[16] = *((_OWORD *)v165 + 1);
            uint64_t v237 = __CFStringValidateFormatSpec(v472, (unsigned __int16 *)v522, (uint64_t)v478);
            uint64_t v72 = v513;
            CFMutableStringRef v478 = (CFMutableStringRef)v237;
            if (v237 < 0)
            {
              char v44 = alloc;
              CFStringRef v450 = CFStringCreateWithFormat( alloc,  0LL,  @"NSStringFormatValueTypeKey '%@' does not match expected specifiers '%@'",  v476,  v472);
              v451 = CFDictionaryCreateMutable( alloc,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
              CFDictionarySetValue(v451, @"NSDebugDescription", v450);
              *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048LL, v451);
              CFRelease(v451);
              CFRelease(v450);
              uint64_t v72 = v513;
LABEL_905:
              uint64_t v45 = v469;
              uint64_t v70 = v487;
              goto LABEL_909;
            }
          }

          v238 = (__int16 *)&__srcb[16 * *v497];
          v238[1] = v219;
          __int16 *v238 = v220;
        }

        else
        {
          uint64_t v72 = v513;
        }

        v172 = v183;
      }

      uint64_t v239 = *v509;
      if (v239 != -1) {
        *(_DWORD *)&__srcb[16 * v239] = 33;
      }
      uint64_t v240 = (char)*v172;
      if (v240 != -1) {
        *(_DWORD *)&__srcb[16 * v240] = 33;
      }
      uint64_t v163 = v83;
LABEL_308:
      if (++v160 == v163) {
        goto LABEL_483;
      }
      continue;
    }
  }

  int v164 = 3 * (v49 + (_DWORD)a9) + 1;
LABEL_483:
  if (v164 >= 1)
  {
    uint64_t v241 = 0LL;
    int v242 = 0;
    v243 = a11;
    v244 = (__int16 *)__srcb;
    do
    {
      if (a11 && v241 < a12 && !*v244) {
        *(_OWORD *)v244 = *v243;
      }
      unsigned int v245 = *v244;
      if (v245 > 0x2C)
      {
LABEL_919:
        __break(1u);
        return;
      }

      if (((1LL << v245) & 0x7EE00000000LL) != 0)
      {
        int v242 = v241;
      }

      else if (((1LL << v245) & 0x180100000001LL) == 0)
      {
        goto LABEL_919;
      }

      ++v241;
      v244 += 8;
      ++v243;
    }

    while (v164 != v241);
    uint64_t v246 = 0LL;
    uint64_t v247 = v242;
    v248 = __srcb + 8;
    do
    {
      switch(*((_WORD *)v248 - 4))
      {
        case '!':
        case ')':
          switch(*((_WORD *)v248 - 3))
          {
            case 1:
              v251 = (char *)a13;
              a13 += 4;
              uint64_t v250 = *v251;
              break;
            case 2:
              v255 = a13;
              a13 += 4;
              uint64_t v250 = *v255;
              break;
            case 4:
              goto LABEL_496;
            default:
              v254 = a13;
              a13 += 4;
              uint64_t v250 = *(int *)v254;
              break;
          }

          goto LABEL_497;
        case '""':
          v253 = a13;
          a13 += 4;
          void *v248 = *(void *)v253;
          break;
        case '#':
        case '%':
        case '&':
        case '\'':
        case '(':
LABEL_496:
          v249 = a13;
          a13 += 4;
          uint64_t v250 = *(void *)v249;
LABEL_497:
          void *v248 = v250;
          break;
        case '$':
          break;
        case '*':
          a13 += 4;
          void *v248 = &chars.i64[1];
          break;
        default:
          if (!*((_WORD *)v248 - 4))
          {
            int v252 = dyld_program_sdk_at_least();
            if (v246 < v247)
            {
              if (v252) {
                a13 += 4;
              }
            }
          }

          break;
      }

      v248 += 2;
      ++v246;
    }

    while (v164 != v246);
  }

  uint64_t v256 = v164;
  BOOL v71 = __srcb;
  if (a11) {
    v257 = (char *)a11;
  }
  else {
    v257 = __srcb;
  }
  uint64_t v498 = v164;
  if (a11) {
    uint64_t v256 = a12;
  }
  uint64_t v465 = v256;
  v466 = v257;
  if (!(_DWORD)v83)
  {
    v440 = 0LL;
    uint64_t v45 = v469;
    goto LABEL_874;
  }

  CFIndex v510 = v83;
  v493 = (char *)calloc(v83, 0x20uLL);
  uint64_t v259 = 0LL;
  char keya = 0;
  CFIndex v462 = 0LL;
  int cf2a = 0;
  v260 = v513;
  v261 = v513 - 8;
  uint64_t v262 = 1LL;
  while (2)
  {
    v263 = &v260[32 * v259];
    v265 = v263 + 26;
    uint64_t v264 = (char)v263[26];
    if (v264 == -1)
    {
      unsigned int v266 = 0;
      int v267 = 0;
    }

    else
    {
      unsigned int v266 = v71[4 * v264 + 2];
      int v267 = 1;
    }

    v269 = v263 + 25;
    uint64_t v268 = (char)v263[25];
    __counta = &v260[32 * v259];
    if (v268 == -1)
    {
      unsigned int v270 = 0;
      int v271 = 0;
    }

    else
    {
      unsigned int v270 = v71[4 * v268 + 2];
      int v271 = 1;
    }

    v272 = &v260[32 * v259];
    int v275 = *((__int16 *)v272 + 1);
    v274 = v272 + 2;
    int v273 = v275;
    unsigned int v276 = *(_DWORD *)(v274 + 10);
    if (v276 == -1) {
      unint64_t v277 = v266;
    }
    else {
      unint64_t v277 = v276;
    }
    if (v276 == -1) {
      int v278 = v267;
    }
    else {
      int v278 = 1;
    }
    unsigned int v279 = *(_DWORD *)(v274 + 14);
    if (v279 == -1) {
      uint64_t v280 = v270;
    }
    else {
      uint64_t v280 = v279;
    }
    if (v279 == -1) {
      int v281 = v271;
    }
    else {
      int v281 = 1;
    }
    switch(v273)
    {
      case ' ':
        if (a14)
        {
          v314 = (unint64_t *)v506;
          CFIndex v315 = CFStringGetLength(v506);
          v260 = v513;
          CFIndex v316 = v315;
        }

        else
        {
          CFIndex v316 = 0LL;
          v314 = (unint64_t *)v506;
        }

        v357 = &v260[32 * v259];
        uint64_t v359 = *((int *)v357 + 1);
        unint64_t v358 = *((int *)v357 + 2);
        unint64_t v360 = v495;
        if (v495)
        {
          uint64_t v361 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            unint64_t v360 = v495;
            uint64_t v361 = __CFDefaultEightBitStringEncoding;
          }

          __CFStringAppendBytes(v314, (unsigned __int8 *)(v360 + v359), v358, v361);
          if (a14)
          {
LABEL_635:
            CFIndex v356 = CFStringGetLength((CFStringRef)v314);
            goto LABEL_651;
          }
        }

        else
        {
          CFStringAppendCharacters((CFMutableStringRef)v314, (const UniChar *)(v494 + 2 * v359), v358);
          if (a14) {
            goto LABEL_635;
          }
        }

        CFIndex v356 = 0LL;
LABEL_651:
        *(_OWORD *)v522 = *__counta;
        *(_OWORD *)&v522[16] = __counta[1];
        v365 = v507;
        CFIndex v364 = v510;
        BOOL v71 = __srcb;
LABEL_655:
        uint64_t v366 = (uint64_t)v71;
        uint64_t v367 = v498;
        CFIndex v321 = v316;
LABEL_720:
        int v384 = 0;
        goto LABEL_824;
      case '!':
      case '""':
        if (!v503 || (v260[32 * v259 + 20] & 0x20) == 0) {
          goto LABEL_538;
        }
        if (a14)
        {
          unint64_t v354 = v277;
          cStrc = (char *)CFStringGetLength(v506);
          BOOL v71 = __srcb;
          int v355 = __CFStringFormatLocalizedNumber(v506, v504, (uint64_t)__srcb, (uint64_t)__counta, v354, v280, v281);
          unint64_t v277 = v354;
          v260 = v513;
          if (v355)
          {
            CFIndex v356 = CFStringGetLength(v506);
            CFIndex v321 = (CFIndex)cStrc;
            goto LABEL_695;
          }
        }

        else
        {
          unint64_t v377 = v277;
          int v378 = __CFStringFormatLocalizedNumber(v506, v504, (uint64_t)v71, (uint64_t)__counta, v277, v280, v281);
          unint64_t v277 = v377;
          v260 = v513;
          if (v378)
          {
            CFIndex v321 = 0LL;
            CFIndex v356 = 0LL;
LABEL_695:
            v379 = __counta;
LABEL_719:
            *(_OWORD *)v522 = *v379;
            *(_OWORD *)&v522[16] = v379[1];
            v365 = v507;
            CFIndex v364 = v510;
            uint64_t v366 = (uint64_t)v71;
            uint64_t v367 = v498;
            goto LABEL_720;
          }
        }

LABEL_538:
        v282 = &v260[32 * v259];
        uint64_t v284 = *((int *)v282 + 2);
        v283 = (int *)(v282 + 8);
        CFIndex v285 = v284 + 1;
        if ((v284 + 1) < 0x81)
        {
          v287 = 0LL;
          v288 = (const char *)v523;
        }

        else
        {
          unint64_t v286 = v277;
          v287 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v285, 0LL);
          unint64_t v277 = v286;
          v288 = v287;
        }

        v482 = (void *)v277;
        CFMutableStringRef v479 = (CFMutableStringRef)v287;
        if ((int)v280 + (int)v277 < 17)
        {
          v296 = 0LL;
          v297 = v522;
          CFIndex v295 = 528LL;
        }

        else
        {
          CFIndex v295 = (int)v280 + (int)v277 + 512;
          v296 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v295, 0LL);
          v297 = v296;
        }

        v298 = v513;
        uint64_t v299 = *(int *)&v513[32 * v259 + 4];
        int v300 = *v283;
        if (v495)
        {
          if (v300 >= 1)
          {
            uint64_t v301 = 0LL;
            int v302 = 0;
            do
            {
              int v303 = *(unsigned __int8 *)(v495 + v301 + v299);
              if (v303 == 36)
              {
                if ((v302 & 0x80000000) == 0)
                {
                  v304 = &v288[v302 - 1];
                  do
                  {
                    int v305 = *(unsigned __int8 *)v304--;
                    --v302;
                  }

                  while ((v305 - 48) < 0xA);
                }
              }

              else
              {
                v288[v302] = v303;
                int v300 = *v283;
              }

              ++v302;
              ++v301;
            }

            while (v301 < v300);
            goto LABEL_570;
          }
        }

        else if (v300 >= 1)
        {
          uint64_t v306 = 0LL;
          int v302 = 0;
          do
          {
            int v307 = *(unsigned __int16 *)(v494 + 2 * (v306 + v299));
            if (v307 == 36)
            {
              if ((v302 & 0x80000000) == 0)
              {
                v308 = &v288[v302 - 1];
                do
                {
                  int v309 = *(unsigned __int8 *)v308--;
                  --v302;
                }

                while ((v309 - 48) < 0xA);
              }
            }

            else
            {
              v288[v302] = v307;
              int v300 = *v283;
            }

            ++v302;
            ++v306;
          }

          while (v306 < v300);
LABEL_570:
          v477 = (__CFString *)v296;
          v288[v302] = 0;
          cStrb = v297;
          v297[v295 - 1] = 0;
          if (a14)
          {
            CFIndex v310 = CFStringGetLength(v506);
            v298 = v513;
            uint64_t v475 = v310;
          }

          else
          {
            uint64_t v475 = 0LL;
          }

          switch(*(_WORD *)v274)
          {
            case '!':
              v311 = *(void **)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
              if (*(_WORD *)__counta == 4)
              {
                int v350 = *v269;
                v351 = v482;
                v313 = cStrb;
                if (*v265 != 255) {
                  goto LABEL_657;
                }
              }

              else
              {
                int v350 = *v269;
                v351 = v482;
                v313 = cStrb;
                if (*v265 != 255)
                {
LABEL_657:
                  if (v350 == 255) {
                    snprintf_l( v313,  0x1FFuLL,  0LL,  v288,  v351,  *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8],  v457,  v458,  v459,  v460,  v461);
                  }
                  else {
                    snprintf_l( v313,  0x1FFuLL,  0LL,  v288,  v351,  v280,  *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8],  v458,  v459,  v460,  v461);
                  }
                  goto LABEL_733;
                }
              }

              if (v350 != 255) {
                goto LABEL_629;
              }
LABEL_661:
              snprintf_l(v313, 0x1FFuLL, 0LL, v288, v311, v456, v457, v458, v459, v460, v461);
LABEL_733:
              CFStringEncoding v389 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding();
                CFStringEncoding v389 = __CFDefaultEightBitStringEncoding;
              }

              v390 = v506;
              CFStringAppendCString(v506, cStrb, v389);
              v392 = __counta;
              v391 = a14;
LABEL_736:
              BOOL v71 = __srcb;
              if (v391) {
                CFIndex v393 = CFStringGetLength(v390);
              }
              else {
                CFIndex v393 = 0LL;
              }
              __int128 v394 = v392[1];
              *(_OWORD *)ptr = *v392;
              __int128 v518 = v394;
              _CFStringFormatAppendMetadata(v507, v510, (uint64_t)__srcb, v498, (uint64_t)ptr, v475, v393, 0);
              if (v477) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v477);
              }
              if (v479) {
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v479);
              }
              break;
            case '""':
              double v352 = *(double *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
              int v353 = *v269;
              if (*v265 == 255)
              {
                if (v353 == 255)
                {
                  snprintf_l(cStrb, 0x1FFuLL, 0LL, v288, v352, *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8]);
                }

                else
                {
                  uint64_t v456 = *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
                  snprintf_l(cStrb, 0x1FFuLL, 0LL, v288, v352, v280);
                }
              }

              else
              {
                if (v353 == 255)
                {
                  uint64_t v456 = *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
                }

                else
                {
                  v457 = *(char **)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
                  uint64_t v456 = v280;
                }

                snprintf_l(cStrb, 0x1FFuLL, 0LL, v288, v352, v482);
              }

              if (!v504) {
                goto LABEL_733;
              }
              CFTypeID v385 = CFGetTypeID(v504);
              v386 = (const __CFString *)(v385 == CFLocaleGetTypeID()
                                        ? CFLocaleGetValue((CFLocaleRef)v504, @"kCFLocaleDecimalSeparatorKey")
                                        : CFDictionaryGetValue((CFDictionaryRef)v504, @"NSDecimalSeparator"));
              v387 = v386;
              if (!v386) {
                goto LABEL_733;
              }
              v388 = cStrb + 1;
              while (2)
              {
                if (!*(v388 - 1)) {
                  goto LABEL_733;
                }
                if (*(v388 - 1) != 46)
                {
                  ++v388;
                  continue;
                }

                break;
              }

              *((_BYTE *)v388 - 1) = 0;
              CFStringEncoding v400 = __CFDefaultEightBitStringEncoding;
              v392 = __counta;
              v391 = a14;
              v390 = v506;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding();
                CFStringEncoding v400 = __CFDefaultEightBitStringEncoding;
              }

              CFStringAppendCString(v506, cStrb, v400);
              CFStringAppend(v506, v387);
              CFStringEncoding v401 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding();
                CFStringEncoding v401 = __CFDefaultEightBitStringEncoding;
              }

              CFStringAppendCString(v506, v388, v401);
              goto LABEL_736;
            case '#':
            case '*':
              v311 = *(void **)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
              int v312 = *v269;
              if (*v265 != 255)
              {
                v313 = cStrb;
                if (v312 == 255)
                {
                  uint64_t v456 = *(void *)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
                }

                else
                {
                  uint64_t v456 = v280;
                  v457 = *(char **)&__srcb[16 * (char)v298[32 * v259 + 24] + 8];
                }

                v311 = v482;
                goto LABEL_661;
              }

              v313 = cStrb;
              if (v312 == 255) {
                goto LABEL_661;
              }
LABEL_629:
              snprintf_l(v313, 0x1FFuLL, 0LL, v288, v280, v311, v457, v458, v459, v460, v461);
              goto LABEL_733;
            default:
              goto LABEL_733;
          }

          goto LABEL_825;
        }

        int v302 = 0;
        goto LABEL_570;
      case '#':
        goto LABEL_538;
      case '%':
      case ',':
        int v289 = v277;
        if (a14)
        {
          v290 = v506;
          CFIndex v291 = CFStringGetLength(v506);
          v260 = v513;
          cStr = (char *)v291;
        }

        else
        {
          cStr = 0LL;
          v290 = v506;
        }

        v322 = &v260[32 * v259];
        v323 = v322 + 27;
        if (v322[27] != 255)
        {
          if (*(_WORD *)v274 == 44)
          {
            if (!cf) {
              goto LABEL_814;
            }
            v484 = v322 + 27;
            v324 = cf;
LABEL_590:
            v325 = (__CFString *)CFRetain(v324);
LABEL_809:
            v413 = v325;
          }

          else
          {
            v340 = &v260[32 * v259];
            uint64_t v343 = (char)v340[24];
            v342 = v340 + 24;
            uint64_t v341 = v343;
            switch(*(_WORD *)&__srcb[16 * v343])
            {
              case '!':
                v484 = v323;
                v402 = &__srcb[16 * v341 + 8];
                v403 = alloc;
                CFNumberType v404 = kCFNumberSInt64Type;
                goto LABEL_808;
              case '""':
                v484 = v323;
                v405 = &__srcb[16 * v341];
                if (*((_WORD *)v405 + 1) == 5)
                {
                  *(void *)v522 = *((void *)v405 + 1);
                  v402 = v522;
                }

                else
                {
                  v402 = v405 + 8;
                }

                v403 = alloc;
                CFNumberType v404 = kCFNumberDoubleType;
                goto LABEL_808;
              case '#':
                v484 = v323;
                v402 = &__srcb[16 * v341 + 8];
                v403 = alloc;
                CFNumberType v404 = kCFNumberCFIndexType;
LABEL_808:
                v325 = (__CFString *)CFNumberCreate(v403, v404, v402);
                goto LABEL_809;
              case '%':
                v324 = *(const void **)&__srcb[16 * v341 + 8];
                if (!v324) {
                  goto LABEL_814;
                }
                v484 = v323;
                goto LABEL_590;
              case '&':
                v406 = *(const UniChar **)&__srcb[16 * v341 + 8];
                if (!v406) {
                  goto LABEL_814;
                }
                v484 = v323;
                v480 = CFStringCreateMutable(alloc, 0LL);
                uint64_t v407 = 0LL;
                while (v406[v407++])
                  ;
                int v409 = v407 - 1;
                else {
                  int v411 = v280;
                }
                if ((v513[32 * v259 + 20] & 2) != 0)
                {
                  CFStringAppendCharacters(v480, v406, v411);
                  if (!v278) {
                    goto LABEL_865;
                  }
                  int v426 = v289 - v411;
                  if (v289 <= v411) {
                    goto LABEL_865;
                  }
                  v413 = v480;
                  do
                  {
                    if (v426 >= 10) {
                      int v427 = 10;
                    }
                    else {
                      int v427 = v426;
                    }
                    __CFStringAppendBytes((unint64_t *)v480, "          ", v427, 1536LL);
                    BOOL v53 = __OFSUB__(v426, 10);
                    v426 -= 10;
                  }

                  while (!((v426 < 0) ^ v53 | (v426 == 0)));
                }

                else
                {
                  int v412 = v289;
                  v413 = v480;
                  if (v278)
                  {
                    int v414 = v412 - v411;
                    if (v412 > v411)
                    {
                      do
                      {
                        if (v414 >= 10) {
                          int v415 = 10;
                        }
                        else {
                          int v415 = v414;
                        }
                        __CFStringAppendBytes((unint64_t *)v480, "          ", v415, 1536LL);
                        BOOL v53 = __OFSUB__(v414, 10);
                        v414 -= 10;
                      }

                      while (!((v414 < 0) ^ v53 | (v414 == 0)));
                    }
                  }

                  CFStringAppendCharacters(v480, v406, v411);
                }

                break;
              case '\'':
              case '(':
                if (!*(void *)&__srcb[16 * v341 + 8]) {
                  goto LABEL_814;
                }
                v484 = v323;
                v480 = CFStringCreateMutable(alloc, 0LL);
                v344 = *(unsigned __int8 **)&__srcb[16 * *v342 + 8];
                if (*(_WORD *)v274 == 40)
                {
                  int v346 = *v344++;
                  int v345 = v346;
                  else {
                    int v348 = v280;
                  }
                }

                else if (v281)
                {
                  v417 = memchr(v344, 0, (int)v280);
                  if (v417) {
                    int v348 = (_DWORD)v417 - (_DWORD)v344;
                  }
                  else {
                    int v348 = v280;
                  }
                }

                else
                {
                  int v348 = strlen((const char *)v344);
                }

                if ((v513[32 * v259 + 20] & 2) != 0)
                {
                  if ((__CFDefaultSystemEncoding & 1) != 0)
                  {
                    int v433 = 1;
                  }

                  else
                  {
                    CFStringGetSystemEncoding();
                    int v433 = __CFDefaultSystemEncoding;
                  }

                  __CFStringAppendBytes((unint64_t *)v480, v344, v348, (v433 - 1));
                  if (v278 && (int v434 = v289 - v348, v289 > v348))
                  {
                    v413 = v480;
                    do
                    {
                      if (v434 >= 10) {
                        int v435 = 10;
                      }
                      else {
                        int v435 = v434;
                      }
                      __CFStringAppendBytes((unint64_t *)v480, "          ", v435, 1536LL);
                      BOOL v53 = __OFSUB__(v434, 10);
                      v434 -= 10;
                    }

                    while (!((v434 < 0) ^ v53 | (v434 == 0)));
                  }

                  else
                  {
LABEL_865:
                    v413 = v480;
                  }
                }

                else
                {
                  int v429 = v289;
                  v413 = v480;
                  if (v278)
                  {
                    int v430 = v429 - v348;
                    if (v429 > v348)
                    {
                      do
                      {
                        if (v430 >= 10) {
                          int v431 = 10;
                        }
                        else {
                          int v431 = v430;
                        }
                        __CFStringAppendBytes((unint64_t *)v480, "          ", v431, 1536LL);
                        BOOL v53 = __OFSUB__(v430, 10);
                        v430 -= 10;
                      }

                      while (!((v430 < 0) ^ v53 | (v430 == 0)));
                    }
                  }

                  if ((__CFDefaultSystemEncoding & 1) != 0)
                  {
                    int v432 = 1;
                  }

                  else
                  {
                    CFStringGetSystemEncoding();
                    int v432 = __CFDefaultSystemEncoding;
                  }

                  __CFStringAppendBytes((unint64_t *)v480, v344, v348, (v432 - 1));
                }

                break;
              case ')':
                v484 = v323;
                chars.i16[0] = *(void *)&__srcb[16 * v341 + 8];
                v325 = (__CFString *)__CFStringCreateImmutableFunnel3( (__objc2_class **)alloc,  &chars,  2LL,  256LL,  16LL,  (uint64_t)&__kCFAllocatorNull,  0LL,  v258);
                goto LABEL_809;
              default:
                goto LABEL_814;
            }
          }

          if (v413)
          {
            _CFCopyResolvedFormatStringWithConfiguration(v413, (CFDictionaryRef)v487[*v484], v504);
            v420 = v419;
            CFRelease(v413);
            if (v420)
            {
              *(void *)v522 = v519;
              if ((char)v513[32 * v259 + 24] < 0)
              {
                v422 = v261;
                uint64_t v423 = v262;
                v421 = theDict;
                BOOL v71 = __srcb;
                v334 = __counta;
                if (v259)
                {
                  do
                  {
                    int v424 = *v422;
                    v422 -= 32;
                    if ((v424 & 0x80000000) == 0) {
                      break;
                    }
                    --v423;
                  }

                  while (v423 >= 2);
                }
              }

              else
              {
                v421 = theDict;
                BOOL v71 = __srcb;
                v334 = __counta;
              }

              uint64_t v460 = 0LL;
              v461 = a15;
              uint64_t v458 = v465;
              uint64_t v459 = *(void *)v522;
              uint64_t v456 = a10 + 1;
              v457 = v466;
              theDict = v421;
              int appended = __CFStringAppendFormatCore(v290, v499, v502, v504, v421, 0LL, v472);
              CFRelease(v420);
              if (!appended)
              {
                free(v493);
                char v44 = alloc;
                uint64_t v45 = v469;
                uint64_t v70 = v487;
                uint64_t v72 = v513;
                goto LABEL_910;
              }

              goto LABEL_819;
            }
          }

LABEL_814:
          CFStringAppendCString(v290, "(null)", 0x600u);
          int v399 = 0;
          BOOL v71 = __srcb;
          v334 = __counta;
          goto LABEL_820;
        }

        uint64_t v332 = (char)v322[24];
        v331 = v322 + 24;
        uint64_t v333 = *(void *)&__srcb[16 * v332 + 8];
        if (!v333) {
          goto LABEL_814;
        }
        v334 = __counta;
        if (v502)
        {
          v522[0] = 0;
          uint64_t v335 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(v502, v333, (uint64_t)theString);
          uint64_t v336 = (uint64_t)v504;
          if (v522[0])
          {
            v337 = (__CFString *)CFRetain(@"%@NSCONTEXT");
            __int128 v338 = __counta[1];
            v339 = &v493[32 * cf2a];
            *(_OWORD *)v339 = *__counta;
            *((_OWORD *)v339 + 1) = v338;
            ++cf2a;
          }

          else
          {
            v337 = (__CFString *)v335;
          }

          if (v337) {
            goto LABEL_751;
          }
          uint64_t v333 = *(void *)&__srcb[16 * *v331 + 8];
        }

        else
        {
          uint64_t v336 = (uint64_t)v504;
        }

        if (!v499)
        {
          uint64_t v395 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__( (uint64_t (*)(uint64_t, uint64_t))__CFCopyFormattingDescription,  v333,  v336);
          if (!v395)
          {
            uint64_t v418 = *v331;
            BOOL v71 = __srcb;
            v337 = (__CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(*(const void **)&__srcb[16 * v418 + 8]);
            if (v337) {
              goto LABEL_752;
            }
            goto LABEL_748;
          }

          v337 = (__CFString *)v395;
LABEL_751:
          BOOL v71 = __srcb;
LABEL_752:
          int v396 = __CFStringAppendFormatCore_disableIsolates;
          if (__CFStringAppendFormatCore_disableIsolates == 255)
          {
            else {
              int v396 = 1;
            }
            __CFStringAppendFormatCore_disableIsolates = v396;
          }

          BOOL v59 = v396 == 0;
          BOOL v397 = v503;
          if (!v59) {
            BOOL v397 = 0;
          }
          if (!v397)
          {
            CFStringAppend(v290, v337);
LABEL_763:
            int v399 = 0;
            goto LABEL_764;
          }

          if ((keya & 1) != 0) {
            goto LABEL_761;
          }
          CFIndex v398 = CFStringGetLength(v337);
          if ((_CFStringHasStrongRTL(v337, 0LL, v398) & 1) != 0) {
            goto LABEL_761;
          }
          CFIndex v416 = CFStringGetLength(v290);
          if (v416)
          {
            if (v416 <= v462 || (_CFStringHasStrongRTL(v290, v462, v416 - v462) & 1) == 0)
            {
LABEL_839:
              CFStringAppend(v290, v337);
              CFIndex v462 = CFStringGetLength(v290);
              char keya = 0;
              goto LABEL_763;
            }
          }

          else
          {
            uint64_t v428 = *(int *)&v513[32 * v259 + 8] + (uint64_t)*(int *)&v513[32 * v259 + 4];
          }

LABEL_761:
          *(_WORD *)v522 = 8296;
          char keya = 1;
          CFStringAppendCharacters(v290, (const UniChar *)v522, 1LL);
          CFStringAppend(v290, v337);
          *(_WORD *)v522 = 8297;
          CFStringAppendCharacters(v290, (const UniChar *)v522, 1LL);
          int v399 = 1;
LABEL_764:
          CFRelease(v337);
          goto LABEL_820;
        }

        v337 = (__CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__(v499, v333, v336);
        BOOL v71 = __srcb;
        if (v337) {
          goto LABEL_752;
        }
LABEL_748:
        CFStringAppendCString(v290, "(null description)", 0x600u);
LABEL_819:
        int v399 = 0;
LABEL_820:
        if (a14) {
          CFIndex v356 = CFStringGetLength(v290);
        }
        else {
          CFIndex v356 = 0LL;
        }
        *(_OWORD *)v522 = *v334;
        *(_OWORD *)&v522[16] = v334[1];
        v365 = v507;
        CFIndex v364 = v510;
        uint64_t v366 = (uint64_t)v71;
        uint64_t v367 = v498;
        CFIndex v321 = (CFIndex)cStr;
        int v384 = v399;
LABEL_824:
        _CFStringFormatAppendMetadata(v365, v364, v366, v367, (uint64_t)v522, v321, v356, v384);
LABEL_825:
        v260 = v513;
LABEL_826:
        ++v259;
        ++v262;
        v261 += 32;
        if (v259 != v510) {
          continue;
        }
        uint64_t v45 = v469;
        if (cf2a >= 1)
        {
          uint64_t v436 = 0LL;
          do
          {
            CFRange v437 = CFStringFind(v506, @"%@NSCONTEXT", 0LL);
            v438 = (const __CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__( v502,  *(void *)&v71[4 * v493[v436 + 24] + 2],  (uint64_t)v506);
            if (v438)
            {
              v439 = v438;
              CFStringReplace(v506, v437, v438);
              CFRelease(v439);
            }

            v436 += 32LL;
            BOOL v71 = __srcb;
          }

          while (32LL * cf2a != v436);
        }

        v440 = v493;
LABEL_874:
        free(v440);
        int8x16_t v29 = a14;
        char v44 = alloc;
LABEL_875:
        uint64_t v70 = v487;
        uint64_t v72 = v513;
LABEL_876:
        if (v72 != v526) {
          goto LABEL_885;
        }
LABEL_886:
        if (v71 != (_DWORD *)v525) {
          CFAllocatorDeallocate(v44, v71);
        }
        if (v45 && v45 != v527) {
          CFAllocatorDeallocate(v44, v45);
        }
        if (v70 != v524) {
          CFAllocatorDeallocate(v44, v70);
        }
        if (v500) {
          CFRelease(v500);
        }
        if (v29)
        {
          if (theArray)
          {
            *int8x16_t v29 = CFArrayCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theArray);
            CFRelease(theArray);
          }
        }

        return;
      case '&':
        int v483 = v277;
        if (a14)
        {
          v317 = v506;
          CFIndex v318 = CFStringGetLength(v506);
          v260 = v513;
        }

        else
        {
          CFIndex v318 = 0LL;
          v317 = v506;
        }

        v362 = *(const UniChar **)&v71[4 * (char)v260[32 * v259 + 24] + 2];
        cStra = (char *)v318;
        if (!v362)
        {
          CFStringAppendCString(v317, "(null)", 0x600u);
          goto LABEL_714;
        }

        if (v281)
        {
          if ((int)v280 < 1)
          {
            LODWORD(i) = 0;
          }

          else
          {
            for (uint64_t i = 0LL; i != v280; ++i)
            {
              if (!v362[i]) {
                goto LABEL_698;
              }
            }

            LODWORD(i) = v280;
          }
        }

        else
        {
          LODWORD(i) = -1;
          v375 = v362;
          do
          {
            int v376 = *v375++;
            LODWORD(i) = i + 1;
          }

          while (v376);
        }

LABEL_698:
        if ((v260[32 * v259 + 20] & 2) != 0)
        {
          CFStringAppendCharacters(v317, v362, i);
          if (v278)
          {
            int v382 = v483 - i;
            if (v483 > (int)i)
            {
              do
              {
                if (v382 >= 10) {
                  int v383 = 10;
                }
                else {
                  int v383 = v382;
                }
                __CFStringAppendBytes((unint64_t *)v317, "          ", v383, 1536LL);
                BOOL v53 = __OFSUB__(v382, 10);
                v382 -= 10;
              }

              while (!((v382 < 0) ^ v53 | (v382 == 0)));
            }
          }
        }

        else
        {
          if (v278)
          {
            int v380 = v483 - i;
            if (v483 > (int)i)
            {
              do
              {
                if (v380 >= 10) {
                  int v381 = 10;
                }
                else {
                  int v381 = v380;
                }
                __CFStringAppendBytes((unint64_t *)v317, "          ", v381, 1536LL);
                BOOL v53 = __OFSUB__(v380, 10);
                v380 -= 10;
              }

              while (!((v380 < 0) ^ v53 | (v380 == 0)));
            }
          }

          CFStringAppendCharacters(v317, v362, i);
        }

LABEL_714:
        BOOL v71 = __srcb;
        if (a14)
        {
          v374 = v317;
LABEL_716:
          CFIndex v356 = CFStringGetLength(v374);
        }

        else
        {
LABEL_717:
          CFIndex v356 = 0LL;
        }

        v379 = __counta;
        CFIndex v321 = (CFIndex)cStra;
        goto LABEL_719;
      case '\'':
      case '(':
        int v292 = v277;
        if (a14)
        {
          v293 = (unint64_t *)v506;
          CFIndex v294 = CFStringGetLength(v506);
          v260 = v513;
          cStra = (char *)v294;
        }

        else
        {
          cStra = 0LL;
          v293 = (unint64_t *)v506;
        }

        v326 = *(unsigned __int8 **)&v71[4 * (char)v260[32 * v259 + 24] + 2];
        if (v326)
        {
          if (*(_WORD *)v274 == 40)
          {
            int v328 = *v326++;
            int v327 = v328;
            else {
              int v330 = v280;
            }
          }

          else
          {
            if (v281)
            {
              v349 = memchr(v326, 0, (int)v280);
              if (v349) {
                int v330 = (_DWORD)v349 - (_DWORD)v326;
              }
              else {
                int v330 = v280;
              }
            }

            else
            {
              int v330 = strlen((const char *)v326);
            }

            v260 = v513;
          }

          if ((v260[32 * v259 + 20] & 2) != 0)
          {
            if ((__CFDefaultSystemEncoding & 1) != 0)
            {
              int v371 = 1;
            }

            else
            {
              CFStringGetSystemEncoding();
              int v371 = __CFDefaultSystemEncoding;
            }

            __CFStringAppendBytes(v293, v326, v330, (v371 - 1));
            if (v278)
            {
              int v372 = v292 - v330;
              if (v292 > v330)
              {
                do
                {
                  if (v372 >= 10) {
                    int v373 = 10;
                  }
                  else {
                    int v373 = v372;
                  }
                  __CFStringAppendBytes(v293, "          ", v373, 1536LL);
                  BOOL v53 = __OFSUB__(v372, 10);
                  v372 -= 10;
                }

                while (!((v372 < 0) ^ v53 | (v372 == 0)));
              }
            }
          }

          else
          {
            if (v278)
            {
              int v368 = v292 - v330;
              if (v292 > v330)
              {
                do
                {
                  if (v368 >= 10) {
                    int v369 = 10;
                  }
                  else {
                    int v369 = v368;
                  }
                  __CFStringAppendBytes(v293, "          ", v369, 1536LL);
                  BOOL v53 = __OFSUB__(v368, 10);
                  v368 -= 10;
                }

                while (!((v368 < 0) ^ v53 | (v368 == 0)));
              }
            }

            if ((__CFDefaultSystemEncoding & 1) != 0)
            {
              int v370 = 1;
            }

            else
            {
              CFStringGetSystemEncoding();
              int v370 = __CFDefaultSystemEncoding;
            }

            __CFStringAppendBytes(v293, v326, v330, (v370 - 1));
          }
        }

        else
        {
          CFStringAppendCString((CFMutableStringRef)v293, "(null)", 0x600u);
        }

        BOOL v71 = __srcb;
        if (!a14) {
          goto LABEL_717;
        }
        v374 = (const __CFString *)v293;
        goto LABEL_716;
      case ')':
        if (a14)
        {
          v319 = v506;
          CFIndex v320 = CFStringGetLength(v506);
          v260 = v513;
          CFIndex v316 = v320;
        }

        else
        {
          CFIndex v316 = 0LL;
          v319 = v506;
        }

        chars.i16[0] = *(void *)&v71[4 * (char)v260[32 * v259 + 24] + 2];
        CFStringAppendCharacters(v319, (const UniChar *)&chars, 1LL);
        if (a14) {
          CFIndex v356 = CFStringGetLength(v319);
        }
        else {
          CFIndex v356 = 0LL;
        }
        *(_OWORD *)v522 = *__counta;
        *(_OWORD *)&v522[16] = __counta[1];
        v365 = v507;
        CFIndex v364 = v510;
        goto LABEL_655;
      case '+':
        if (a14) {
          CFIndex v321 = CFStringGetLength(v506);
        }
        else {
          CFIndex v321 = 0LL;
        }
        CFIndex v364 = v510;
        *(_OWORD *)v522 = *__counta;
        *(_OWORD *)&v522[16] = __counta[1];
        v365 = v507;
        uint64_t v366 = (uint64_t)v71;
        uint64_t v367 = v498;
        CFIndex v356 = v321;
        goto LABEL_720;
      default:
        goto LABEL_826;
    }
  }

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)_CFNonObjCStringCreateCopy((__objc2_class **)alloc, (uint64_t)theString, v5, v6, v7, v8, v9, v10);
}

CFStringRef CFStringCreateWithFormatAndArguments( CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  if (CF_IS_OBJC(7uLL, (__objc2_class **)format) && _CFStringObjCFormatRequiresInflection((void *)format)) {
    return (CFStringRef)_CFStringCreateFormatWithInflectionAndArguments( (uint64_t)alloc,  (uint64_t)formatOptions,  (uint64_t)format,  (uint64_t)arguments);
  }
  else {
    return _CFStringCreateWithFormatAndArgumentsReturningMetadata( alloc,  0LL,  0LL,  (uint64_t)formatOptions,  0LL,  0LL,  (uint64_t)format,  0LL,  (__int16 *)arguments);
  }
}

uint64_t _CFStringCreateWithFormatAndArgumentsAux2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, a3, a4, 0LL, a5, a6, 0LL, a7);
}

CFStringRef _CFStringCreateWithFormatAndArgumentsReturningMetadata( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFArrayRef *a8, __int16 *a9)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  __CFStringAppendFormatCore( (uint64_t)Mutable,  a2,  a3,  a4,  a5,  a6,  0LL,  a7,  0LL,  0LL,  0LL,  0LL,  a9,  a8,  (CFErrorRef *)cf);
  if (v24)
  {
    CFStringRef Copy = CFStringCreateCopy(a1, Mutable);
  }

  else
  {
    CFLog(3LL, (uint64_t)@"ERROR: Failed to format string: %@", v18, v19, v20, v21, v22, v23, (uint64_t)cf[0]);
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    CFStringRef Copy = 0LL;
  }

  CFRelease(Mutable);
  return Copy;
}

CFStringRef _CFStringCreateWithFormatAndArgumentsAux( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, 0LL, a3, 0LL, 0LL, a4, 0LL, a5);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, va);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)str)) {
    return (CFStringRef)-[__CFString _createSubstringWithRange:]( (id)str,  "_createSubstringWithRange:",  location,  length);
  }
  if (!location)
  {
    char v14 = atomic_load((unint64_t *)&str->info);
    uint64_t v15 = v14 & 5;
    char v16 = atomic_load((unint64_t *)&str->info);
    uint64_t v17 = v16 & 0x60;
    if (v15 == 4)
    {
      p_data = &str->data;
      if (v17)
      {
        uint64_t v19 = *p_data;
      }

      else
      {
        uint64_t v21 = atomic_load((unint64_t *)&str->info);
        uint64_t v19 = (char *)&p_data[(v21 & 5) != 4];
      }

      uint64_t v20 = (char *)*v19;
    }

    else
    {
      uint64_t v20 = (v16 & 0x60) != 0 ? (char *)str->length : str->data;
    }
  }

  char v22 = atomic_load((unint64_t *)&str->info);
  char v23 = atomic_load((unint64_t *)&str->info);
  uint64_t v24 = v23 & 0x60;
  unint64_t v25 = &str->data;
  if ((v22 & 0x10) != 0)
  {
    if (v24)
    {
      int8x16_t v27 = *v25;
    }

    else
    {
      uint64_t v36 = atomic_load((unint64_t *)&str->info);
      int8x16_t v27 = (char *)&v25[(v36 & 5) != 4];
    }

    uint64_t v33 = (int8x16_t *)&v27[2 * location];
    int64_t v34 = 2 * length;
    uint64_t v32 = (__objc2_class **)alloc;
    uint64_t v31 = 256LL;
    uint64_t v35 = 2LL;
  }

  else
  {
    if (v24)
    {
      unint64_t v26 = *v25;
    }

    else
    {
      uint64_t v28 = atomic_load((unint64_t *)&str->info);
      unint64_t v26 = (char *)&v25[(v28 & 5) != 4];
    }

    unint64_t v29 = atomic_load((unint64_t *)&str->info);
    uint64_t v30 = (uint64_t)&v26[location + ((v29 >> 2) & 1)];
    uint64_t v31 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      uint64_t v31 = __CFDefaultEightBitStringEncoding;
    }

    uint64_t v32 = (__objc2_class **)alloc;
    uint64_t v33 = (int8x16_t *)v30;
    int64_t v34 = length;
    uint64_t v35 = 0LL;
  }

  return (CFStringRef)__CFStringCreateImmutableFunnel3(v32, v33, v34, v31, v35, -1LL, 0LL, v12);
}

unint64_t _CFStringCreateTaggedPointerString(unsigned __int8 *a1, uint64_t a2)
{
  if (!a2) {
    return (unint64_t)&stru_1899EF170;
  }
  if (!__CFTaggedStringClass) {
    return 0LL;
  }
  if (a2 > 7)
  {
    if ((unint64_t)a2 <= 0xB)
    {
      if ((unint64_t)a2 >= 0xA)
      {
        uint64_t v6 = 0LL;
        uint64_t v9 = a2;
        while (1)
        {
          unint64_t v10 = charToSixBitLookup_0[*a1];
          if (v10 > 0x1F) {
            break;
          }
          uint64_t v6 = v10 | (32 * v6);
          ++a1;
          if (!--v9)
          {
LABEL_15:
            unint64_t result = (8 * a2) | (v6 << 7) | 0x8000000000000002LL;
            unint64_t v5 = result ^ *MEMORY[0x189616658];
            goto LABEL_16;
          }
        }
      }

      else
      {
        uint64_t v6 = 0LL;
        uint64_t v7 = a2;
        while (1)
        {
          unint64_t v8 = charToSixBitLookup_0[*a1];
          if (v8 > 0x3F) {
            break;
          }
          uint64_t v6 = v8 | (v6 << 6);
          ++a1;
          if (!--v7) {
            goto LABEL_15;
          }
        }
      }
    }

    return 0LL;
  }

  __memmove_chk();
  unint64_t result = (8 * a2) | 0x8000000000000002LL;
  unint64_t v5 = *MEMORY[0x189616658] ^ result;
LABEL_16:
  if ((~v5 & 0xC000000000000007LL) != 0) {
    return v5 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v5 & 7));
  }
  return result;
}

CFStringRef _CFStringCopyBundleUnloadingProtectedString(unint64_t *a1)
{
  uint64_t CStringPtrInternal = (const char *)_CFStringGetCStringPtrInternal(a1, 0x8000100u, 1, 1);
  if (!CStringPtrInternal) {
    return _CFStringSlowPathCopyBundleUnloadingProtectedString((__CFString *)a1);
  }
  uint64_t v4 = (int8x16_t *)CStringPtrInternal;
  strlen(CStringPtrInternal);
  if ((__objc2_class *)*a1 == __CFConstantStringClassReferencePtr) {
    return (const __CFString *)a1;
  }
  size_t v5 = strlen(v4->i8);
  return (const __CFString *)__CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  v4,  v5,  134217984LL,  24LL,  (uint64_t)&__kCFAllocatorNull,  0LL,  v6);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)_CFStringGetCStringPtrInternal((unint64_t *)theString, encoding, 1, 1);
}

CFStringRef _CFStringSlowPathCopyBundleUnloadingProtectedString(__CFString *a1)
{
  v19[1] = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  if (!Length) {
    return &stru_1899EF170;
  }
  CFIndex v3 = Length;
  uint64_t FastestEncoding = CFStringGetFastestEncoding(a1);
  uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, FastestEncoding, 0, 1);
  if (!CStringPtrInternal)
  {
    CharactersPtr = CFStringGetCharactersPtr(a1);
    if (CharactersPtr)
    {
      uint64_t v7 = (int8x16_t *)CharactersPtr;
      int64_t v8 = 2 * v3;
      uint64_t v9 = 256LL;
      return (const __CFString *)__CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  v7,  v8,  v9,  2LL,  -1LL,  0LL,  v6);
    }

    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v3, FastestEncoding);
    unint64_t v15 = MaximumSizeForEncoding;
    v19[0] = 0LL;
    if (MaximumSizeForEncoding < 0x101)
    {
      if (MaximumSizeForEncoding)
      {
        MEMORY[0x1895F8858](MaximumSizeForEncoding, v14);
        char v16 = (int8x16_t *)((char *)v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
      }

      else
      {
        char v16 = 0LL;
      }
    }

    else
    {
      char v16 = (int8x16_t *)malloc(MaximumSizeForEncoding);
    }

    v20.CFIndex location = 0LL;
    v20.CFIndex length = v3;
    if (CFStringGetBytes(a1, v20, FastestEncoding, 0, 0, (UInt8 *)v16, v15, v19)) {
      ImmutableFunnel3 = (void *)__CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  v16,  v19[0],  FastestEncoding,  2LL,  -1LL,  0LL,  v17);
    }
    else {
      ImmutableFunnel3 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, a1);
    }
    unint64_t v10 = ImmutableFunnel3;
    if (v15 >= 0x101) {
      free(v16);
    }
    return (const __CFString *)v10;
  }

  uint64_t v7 = (int8x16_t *)CStringPtrInternal;
  int64_t v8 = v3;
  uint64_t v9 = FastestEncoding;
  return (const __CFString *)__CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  v7,  v8,  v9,  2LL,  -1LL,  0LL,  v6);
}

CFStringRef __CFStringMakeConstantString(const char *cStr)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!constantStringTable)
  {
    CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_18999D120;
    *(_OWORD *)&valueCallBacks.version = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.version;
    *(_OWORD *)&valueCallBacks.release = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.release;
    valueCallBacks.equal = 0LL;
    uint64_t v2 = (__objc2_class **)CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &keyCallBacks,  &valueCallBacks);
    _CFDictionarySetCapacity(v2, 2500LL);
    os_unfair_lock_lock_with_options();
    if (!constantStringTable) {
      constantStringTable = (uint64_t)v2;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    if ((__objc2_class **)constantStringTable != v2) {
      CFRelease(v2);
    }
  }

  os_unfair_lock_lock_with_options();
  CFTypeRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, cStr);
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
  if (!Value)
  {
    uint64_t v4 = cStr;
    while (1)
    {
      int v5 = *v4;
      if (!*v4) {
        break;
      }
      ++v4;
      if (v5 < 0)
      {
        CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
        char v13 = *cStr;
        if (*cStr)
        {
          uint64_t v14 = cStr + 1;
          do
          {
            if (v13 < 0) {
              CFStringAppendFormat(Mutable, 0LL, @"\\%3o", v13);
            }
            else {
              CFStringAppendFormat(Mutable, 0LL, @"%1c", v13);
            }
            int v15 = *(unsigned __int8 *)v14++;
            char v13 = v15;
          }

          while (v15);
        }

        CFLog( 4LL,  (uint64_t)@"WARNING: @%@ has non-7 bit chars, interpreting using MacOS Roman encoding for now, but this will change. Please eliminate usages of non-7 bit chars (including escaped characters above \\177 octal) in @.",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)Mutable);
        CFRelease(Mutable);
        break;
      }
    }

    size_t v16 = strlen(cStr);
    ImmutableFunnel3 = (__objc2_class **)__CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  (int8x16_t *)cStr,  v16,  0LL,  8LL,  -1LL,  0LL,  v17);
    if (!ImmutableFunnel3) {
      __CFStringMakeConstantString_cold_1(0LL, v19, v20, v21, v22, v23, v24, v25);
    }
    unint64_t v26 = (unint64_t *)ImmutableFunnel3;
    int v27 = CF_IS_OBJC(7uLL, ImmutableFunnel3);
    if (v27) {
      goto LABEL_27;
    }
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    char v28 = atomic_load(v26 + 1);
    if ((v28 & 0x10) != 0
      || ((char v29 = atomic_load(v26 + 1), v30 = v26 + 2, (v29 & 0x60) == 0)
        ? (v32 = atomic_load(v26 + 1), uint64_t v31 = &v30[(v32 & 5) != 4LL])
        : (uint64_t v31 = (void *)*v30),
          unint64_t v33 = atomic_load(v26 + 1),
          !v31))
    {
LABEL_27:
      size_t v35 = strlen(cStr) + 1;
      int64_t v34 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v35, 0LL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      strlcpy(v34, cStr, v35);
    }

    else
    {
      int64_t v34 = (char *)v31 + ((v33 >> 2) & 1);
    }

    os_unfair_lock_lock_with_options();
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)constantStringTable);
    CFDictionaryAddValue((CFMutableDictionaryRef)constantStringTable, v34, v26);
    if (CFDictionaryGetCount((CFDictionaryRef)constantStringTable) == Count)
    {
      CFTypeRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, v34);
    }

    else
    {
      CFTypeRef Value = (const __CFString *)v26;
      if (!v27)
      {
        CFTypeRef Value = (const __CFString *)v26;
        if (!__CFRuntimeIsImmortal((uint64_t)v26))
        {
          __CFRuntimeSetImmortal((uint64_t)v26);
          CFTypeRef Value = (const __CFString *)v26;
        }
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    CFRelease(v26);
  }

  return Value;
}

CFTypeRef __cStrCopyDescription(int8x16_t *__s)
{
  uint64_t v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    uint64_t v2 = __CFDefaultEightBitStringEncoding;
  }

  size_t v3 = strlen(__s->i8);
  return __CFStringCreateImmutableFunnel3( &__kCFAllocatorSystemDefault,  __s,  v3,  v2,  24LL,  (uint64_t)&__kCFAllocatorNull,  0LL,  v4);
}

BOOL __cStrEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t __cStrHash(const char *a1)
{
  char v1 = a1;
  int64_t v2 = strlen(a1);
  if (v2 > 4)
  {
    uint64_t v6 = v1[1] + (uint64_t)*v1 + ((uint64_t)*v1 << 8);
    uint64_t v7 = v6 + v1[v2 - 2] + (v6 << 8);
    uint64_t v4 = v7 + v1[v2 - 1] + (v7 << 8);
  }

  else if ((_DWORD)v2)
  {
    int v3 = v2;
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = *v1++;
      uint64_t v4 = 257 * v4 + v5;
      --v3;
    }

    while (v3);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  return (v4 << (v2 & 0x1F)) + v4;
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    CFStringAppendFormatAndArguments(theString, formatOptions, format, va);
  }

  else
  {
    uint64_t v4 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendFormat_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy( CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator)
{
  uint64_t v12 = alloc;
  if (&__kCFAllocatorNull == (__objc2_class **)externalCharactersAllocator) {
    int v13 = 2;
  }
  else {
    int v13 = 3;
  }
  if (externalCharactersAllocator) {
    int v14 = v13;
  }
  else {
    int v14 = 1;
  }
  if (!alloc)
  {
    uint64_t v15 = _CFGetTSD(1u);
    if (v15) {
      uint64_t v12 = (const __CFAllocator *)v15;
    }
    else {
      uint64_t v12 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  if (v14 == 3) {
    uint64_t v16 = 40LL;
  }
  else {
    uint64_t v16 = 32LL;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v12, 7uLL, v16, 0LL, (uint64_t)externalCharactersAllocator, v5, v6, v7);
  if (Instance)
  {
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    uint64_t v18 = (unint64_t *)(Instance + 8);
    unint64_t v19 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v20 = __ldaxr(v18);
      if (v20 != v19) {
        break;
      }
      int v21 = 1;
LABEL_23:
      unint64_t v19 = v20;
      if (v21)
      {
        unint64_t v22 = atomic_load(v18);
        while (1)
        {
          unint64_t v23 = __ldaxr(v18);
          if (v23 != v22) {
            break;
          }
          if (__stlxr(v22 | 0x10, v18)) {
            goto LABEL_29;
          }
          int v24 = 1;
LABEL_30:
          unint64_t v22 = v23;
          if (v24)
          {
            unint64_t v25 = atomic_load(v18);
            while (1)
            {
              unint64_t v26 = __ldaxr(v18);
              if (v26 != v25) {
                break;
              }
              if (__stlxr(v25 | 1, v18)) {
                goto LABEL_36;
              }
              int v27 = 1;
LABEL_37:
              unint64_t v25 = v26;
              if (v27)
              {
                *(void *)(Instance + 16) = 0LL;
                char v28 = (unint64_t *)(Instance + 8);
                char v29 = atomic_load((unint64_t *)(Instance + 8));
                BOOL v30 = (v29 & 0x60) == 0LL;
                uint64_t v31 = 24LL;
                if (v30) {
                  uint64_t v31 = 16LL;
                }
                *(void *)(Instance + v31) = 0LL;
                *(_OWORD *)(Instance + 32) = xmmword_180C44980;
                char v32 = atomic_load(v28);
                if ((~v32 & 0x60) == 0)
                {
                  CFRetain(v12);
                  *(void *)(Instance + 4_Block_object_dispose(va, 8) = v12;
                }

                *(void *)(Instance + 40) |= 4uLL;
                char v33 = atomic_load(v28);
                if ((~v33 & 0x60) == 0)
                {
                  CFRelease(*(CFTypeRef *)(Instance + 48));
                  CFRetain(externalCharactersAllocator);
                  *(void *)(Instance + 4_Block_object_dispose(va, 8) = externalCharactersAllocator;
                }

                CFStringSetExternalCharactersNoCopy((CFMutableStringRef)Instance, chars, numChars, capacity);
                return (CFMutableStringRef)Instance;
              }
            }

            __clrex();
LABEL_36:
            int v27 = 0;
            goto LABEL_37;
          }
        }

        __clrex();
LABEL_29:
        int v24 = 0;
        goto LABEL_30;
      }
    }

    __clrex();
LABEL_22:
    int v21 = 0;
    goto LABEL_23;
  }

  return (CFMutableStringRef)Instance;
}

void CFStringSetExternalCharactersNoCopy( CFMutableStringRef theString, UniChar *chars, CFIndex length, CFIndex capacity)
{
  char v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) != 0)
  {
    theString->data = (char *)chars;
    char v13 = atomic_load((unint64_t *)&theString->info);
    BOOL v14 = (v13 & 0x60) == 0LL;
    uint64_t v15 = 24LL;
    if (v14) {
      uint64_t v15 = 16LL;
    }
    *(void **)((char *)&theString->isa + v15) = (void *)length;
    uint64_t v16 = theString[1].info | 8;
    theString[1].isa = (void *)(2 * capacity);
    theString[1].info = v16;
  }

  else
  {
    uint64_t v5 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringSetExternalCharactersNoCopy_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  char v3 = (__CFString *)theString;
  void v23[2] = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFStringCreateMutable(alloc, maxLength);
  if (Mutable == v3)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3);
    char v3 = (__CFString *)Copy;
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFIndex Length = CFStringGetLength(v3);
  if (Length < 1)
  {
    BOOL v11 = 0;
  }

  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)v3))
    {
      int v10 = -[__CFString _encodingCantBeStoredInEightBitCFString](v3, "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v12 = atomic_load((unint64_t *)&v3->info);
      int v10 = (v12 >> 4) & 1;
    }

    BOOL v11 = v10 != 0;
  }

  v23[0] = 0LL;
  v23[1] = 0LL;
  __CFStringChangeSizeMultiple((char *)Mutable, (uint64_t)v23, 1LL, Length, v11);
  char v13 = atomic_load((unint64_t *)&Mutable->info);
  char v14 = atomic_load((unint64_t *)&Mutable->info);
  uint64_t v15 = v14 & 0x60;
  p_data = (UniChar **)&Mutable->data;
  if ((v13 & 0x10) == 0)
  {
    if (v15)
    {
      uint64_t v17 = *p_data;
    }

    else
    {
      uint64_t v19 = atomic_load((unint64_t *)&Mutable->info);
      uint64_t v17 = (UniChar *)&p_data[(v19 & 5) != 4];
    }

    CFStringEncoding v20 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v20 = __CFDefaultEightBitStringEncoding;
    }

    unint64_t v21 = atomic_load((unint64_t *)&Mutable->info);
    v24.CFIndex location = 0LL;
    v24.CFIndex length = Length;
    CFStringGetBytes(v3, v24, v20, 0, 0, (UInt8 *)v17 + ((v21 >> 2) & 1), Length, 0LL);
    goto LABEL_24;
  }

  if (v15)
  {
    uint64_t v18 = *p_data;
    if (!*p_data) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  uint64_t v22 = atomic_load((unint64_t *)&Mutable->info);
  uint64_t v18 = (UniChar *)&p_data[(v22 & 5) != 4];
  if (v18)
  {
LABEL_23:
    v25.CFIndex location = 0LL;
    v25.CFIndex length = Length;
    CFStringGetCharacters(v3, v25, v18);
  }

uint64_t _CFStrSetDesiredCapacity(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(result + 40) & 0xFLL | (16 * a2);
  return result;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    int v3 = *MEMORY[0x189616658];
    uint64_t v4 = (v3 ^ theString) & 7;
    while (v4 != *(unsigned __int8 *)(MEMORY[0x189616648] + v2))
    {
      if (++v2 == 7) {
        goto LABEL_10;
      }
    }

    if (v2 == 2) {
      return _NSTaggedPointerStringGetLength((uint64_t)theString);
    }
  }

unint64_t _CFStringGetLength2(unint64_t *a1)
{
  char v1 = atomic_load(a1 + 1);
  uint64_t v2 = v1 & 5;
  char v3 = atomic_load(a1 + 1);
  uint64_t v4 = v3 & 0x60;
  if (v2 == 4)
  {
    uint64_t v5 = (unsigned __int8 ***)(a1 + 2);
    if (v4)
    {
      char v6 = *v5;
    }

    else
    {
      uint64_t v8 = atomic_load(a1 + 1);
      char v6 = (unsigned __int8 **)&v5[(v8 & 5) != 4];
    }

    return *(unsigned __int8 *)v6;
  }

  else if ((v3 & 0x60) != 0)
  {
    return a1[3];
  }

  else
  {
    return a1[2];
  }

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  char v5 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v5 & 0x60) != 0)
  {
    uint64_t v7 = *p_data;
  }

  else
  {
    char v8 = atomic_load((unint64_t *)&theString->info);
    uint64_t v7 = (char *)&p_data[(v8 & 5) != 4LL];
  }

  char v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 0x10) != 0)
  {
    BOOL v11 = (UniChar *)&v7[2 * idx];
  }

  else
  {
    unint64_t v10 = atomic_load((unint64_t *)&theString->info);
    BOOL v11 = (UniChar *)(__CFCharToUniCharTable + 2LL * v7[((v10 >> 2) & 1) + idx]);
  }

  return *v11;
}

uint64_t _CFStringCheckAndGetCharacterAtIndex(uint64_t a1, uint64_t a2, _WORD *a3)
{
  if (a2 < 0 && !dyld_program_sdk_at_least())
  {
    __int16 v17 = 0;
  }

  else
  {
    char v6 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v7 = (unsigned __int8 ***)(a1 + 16);
    if ((v6 & 0x60) != 0)
    {
      char v8 = *v7;
      if (a2 < 0) {
        return 3LL;
      }
    }

    else
    {
      char v9 = atomic_load((unint64_t *)(a1 + 8));
      char v8 = (unsigned __int8 **)&v7[(v9 & 5) != 4LL];
      if (a2 < 0) {
        return 3LL;
      }
    }

    char v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 5) == 4LL)
    {
      BOOL v11 = (unsigned __int8 **)*(unsigned __int8 *)v8;
    }

    else
    {
      char v12 = atomic_load((unint64_t *)(a1 + 8));
      if ((v12 & 0x60) != 0) {
        BOOL v11 = *(unsigned __int8 ***)(a1 + 24);
      }
      else {
        BOOL v11 = *v7;
      }
    }

    char v13 = atomic_load((unint64_t *)(a1 + 8));
    if ((v13 & 0x10) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)v8 + 2 * a2;
    }

    else
    {
      unint64_t v14 = atomic_load((unint64_t *)(a1 + 8));
      uint64_t v15 = (unsigned __int8 *)(__CFCharToUniCharTable + 2LL * *((unsigned __int8 *)v8 + ((v14 >> 2) & 1) + a2));
    }

    __int16 v17 = *(_WORD *)v15;
  }

  uint64_t result = 0LL;
  *a3 = v17;
  return result;
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString getCharacters:range:]((id)theString, "getCharacters:range:", buffer, location, length);
  }

  else
  {
    char v7 = atomic_load((unint64_t *)&theString->info);
    p_data = &theString->data;
    if ((v7 & 0x60) != 0)
    {
      char v9 = *p_data;
    }

    else
    {
      char v10 = atomic_load((unint64_t *)&theString->info);
      char v9 = (char *)&p_data[(v10 & 5) != 4LL];
    }

    char v11 = atomic_load((unint64_t *)&theString->info);
    if ((v11 & 0x10) != 0)
    {
      memmove(buffer, &v9[2 * location], 2 * length);
    }

    else
    {
      unint64_t v12 = atomic_load((unint64_t *)&theString->info);
      __CFStrConvertBytesToUnicode((unsigned __int8 *)&v9[location + ((v12 >> 2) & 1)], buffer, length);
    }
  }

uint64_t _CFStringCheckAndGetCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *__dst)
{
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  char v5 = (unsigned __int8 ***)(a1 + 16);
  if ((v4 & 0x60) != 0)
  {
    char v6 = *v5;
  }

  else
  {
    char v7 = atomic_load((unint64_t *)(a1 + 8));
    char v6 = (unsigned __int8 **)&v5[(v7 & 5) != 4LL];
  }

  char v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 5) == 4LL)
  {
    char v9 = (unsigned __int8 **)*(unsigned __int8 *)v6;
  }

  else
  {
    char v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 0x60) != 0) {
      char v9 = *(unsigned __int8 ***)(a1 + 24);
    }
    else {
      char v9 = *v5;
    }
  }

  char v12 = atomic_load((unint64_t *)(a1 + 8));
  if ((v12 & 0x10) != 0)
  {
    memmove(__dst, (char *)v6 + 2 * a2, 2 * a3);
  }

  else
  {
    unint64_t v13 = atomic_load((unint64_t *)(a1 + 8));
    __CFStrConvertBytesToUnicode((unsigned __int8 *)v6 + a2 + ((v13 >> 2) & 1), __dst, a3);
  }

  return 0LL;
}

CFIndex _CFNonObjCStringGetBytes( const __CFString *a1, CFIndex a2, int64_t a3, uint64_t a4, unsigned int a5, int a6, UniChar *__dst, uint64_t a8, int64_t *a9)
{
  char v17 = atomic_load((unint64_t *)&a1->info);
  if ((v17 & 0x10) != 0) {
    goto LABEL_36;
  }
  int v18 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v18 = __CFDefaultEightBitStringEncoding;
  }

  if (v18 != (_DWORD)a4)
  {
    if (v18 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v18 = __CFDefaultEightBitStringEncoding;
    }

    if (v18 != 1536) {
      goto LABEL_36;
    }
    switch(BYTE1(a4))
    {
      case 0:
        goto LABEL_5;
      case 1:
        if ((_DWORD)a4 != 134217984) {
          goto LABEL_36;
        }
        goto LABEL_5;
      case 2:
        if ((_DWORD)a4 == 518) {
          goto LABEL_36;
        }
        goto LABEL_5;
      case 6:
        if ((_DWORD)a4 != 1536) {
          goto LABEL_36;
        }
        goto LABEL_5;
      case 8:
      case 0xC:
        goto LABEL_36;
      case 0xA:
        int v25 = 1 << (a4 - 1);
        int v26 = 32785;
        break;
      case 0xB:
        int v25 = 1 << (a4 + 13);
        int v26 = 4099;
        break;
      default:
        goto LABEL_5;
    }

    if ((v25 & v26) != 0)
    {
LABEL_36:
      v27.CFIndex location = a2;
      v27.CFIndex length = a3;
      return __CFStringEncodeByteStream(a1, v27, a6, a4, a5, __dst, a8, a9);
    }
  }

CFIndex CFStringGetBytes( CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  int v10 = isExternalRepresentation;
  unsigned int v11 = lossByte;
  uint64_t v12 = *(void *)&encoding;
  CFIndex length = range.length;
  CFIndex location = range.location;
  v34[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    if (!v11)
    {
      unint64_t v16 = CFStringConvertEncodingToNSStringEncoding(v12);
      unint64_t v17 = v16;
      v33[0] = location;
      v33[1] = length;
      uint64_t v18 = 0LL;
      int v19 = *MEMORY[0x189616658];
      uint64_t v20 = (v19 ^ theString) & 7;
      while (v20 != *(unsigned __int8 *)(MEMORY[0x189616648] + v18))
      {
        if (++v18 == 7) {
          goto LABEL_35;
        }
      }

      if (v10
        || !buffer
        || v18 != 2
        || v16 > 5
        || ((1LL << v16) & 0x32) == 0
        || (int64_t Bytes = _NSTaggedPointerStringGetBytes((uint64_t)theString, v34), Bytes < length)
        || location > Bytes - length)
      {
LABEL_35:
        if (-[__CFString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]( (id)theString,  "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:",  buffer,  maxBufLen,  usedBufLen,  v17,  2LL * (v10 != 0),  location,  length,  v33)) {
          return v33[0] - location;
        }
        else {
          return 0LL;
        }
      }

      if (length >= maxBufLen) {
        CFIndex length = maxBufLen;
      }
      CFRange v27 = (char *)v34 + location;
      goto LABEL_42;
    }
  }

  else
  {
    char v21 = atomic_load((unint64_t *)&theString->info);
    if ((v21 & 0x10) == 0)
    {
      int v22 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v22 = __CFDefaultEightBitStringEncoding;
      }

      if (v22 == (_DWORD)v12) {
        goto LABEL_14;
      }
      if (v22 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v22 = __CFDefaultEightBitStringEncoding;
      }

      if (v22 == 1536)
      {
        switch(BYTE1(v12))
        {
          case 0:
            goto LABEL_14;
          case 1:
            if ((_DWORD)v12 != 134217984) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 2:
            if ((_DWORD)v12 == 518) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 6:
            if ((_DWORD)v12 != 1536) {
              goto LABEL_59;
            }
            goto LABEL_14;
          case 8:
          case 0xC:
            goto LABEL_59;
          case 0xA:
            int v31 = 1 << (v12 - 1);
            int v32 = 32785;
            break;
          case 0xB:
            int v31 = 1 << (v12 + 13);
            int v32 = 4099;
            break;
          default:
            goto LABEL_14;
        }

        if ((v31 & v32) == 0)
        {
LABEL_14:
          char v23 = atomic_load((unint64_t *)&theString->info);
          p_data = &theString->data;
          if ((v23 & 0x60) != 0)
          {
            int v25 = *p_data;
            if (!buffer)
            {
LABEL_43:
              if (usedBufLen) {
                *CFIndex usedBufLen = length;
              }
              return length;
            }
          }

          else
          {
            char v28 = atomic_load((unint64_t *)&theString->info);
            int v25 = (char *)&p_data[(v28 & 5) != 4LL];
            if (!buffer) {
              goto LABEL_43;
            }
          }

          if (length >= maxBufLen) {
            CFIndex length = maxBufLen;
          }
          unint64_t v29 = atomic_load((unint64_t *)&theString->info);
          CFRange v27 = &v25[location + ((v29 >> 2) & 1)];
LABEL_42:
          memmove(buffer, v27, length);
          goto LABEL_43;
        }
      }
    }
  }

ConstStringPtr CFStringGetPascalStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  if (((unint64_t)theString & 0x8000000000000000LL) != 0)
  {
    uint64_t v4 = 0LL;
    int v5 = *MEMORY[0x189616658];
    uint64_t v6 = (v5 ^ theString) & 7;
    while (v6 != *(unsigned __int8 *)(MEMORY[0x189616648] + v4))
    {
      if (++v4 == 7) {
        goto LABEL_9;
      }
    }

    if (v4 == 2) {
      return 0LL;
    }
  }

uint64_t _CFNonObjCStringGetCStringPtr(unint64_t *a1, unsigned int a2, int a3)
{
  return _CFStringGetCStringPtrInternal(a1, a2, a3, 0);
}

uint64_t _CFStringGetCStringPtrInternal(unint64_t *a1, unsigned int a2, int a3, int a4)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0 && a4)
  {
    uint64_t v8 = 0LL;
    int v9 = *MEMORY[0x189616658];
    uint64_t v10 = (v9 ^ a1) & 7;
    while (v10 != *(unsigned __int8 *)(MEMORY[0x189616648] + v8))
    {
      if (++v8 == 7) {
        goto LABEL_10;
      }
    }

    if (v8 == 2) {
      return 0LL;
    }
  }

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000LL) != 0)
  {
    uint64_t v2 = 0LL;
    int v3 = *MEMORY[0x189616658];
    uint64_t v4 = (v3 ^ theString) & 7;
    while (v4 != *(unsigned __int8 *)(MEMORY[0x189616648] + v2))
    {
      if (++v2 == 7) {
        goto LABEL_9;
      }
    }

    if (v2 == 2) {
      return 0LL;
    }
  }

Boolean CFStringGetPascalString( CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  v25[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = bufferSize - 1;
  if (bufferSize < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)&encoding;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    CFIndex Length = CFStringGetLength(theString);
    if (Length <= 255)
    {
LABEL_41:
      v26.CFIndex location = 0LL;
      v26.CFIndex length = Length;
      CFIndex v24 = __CFStringEncodeByteStream(theString, v26, 0, v5, 0, (UniChar *)(buffer + 1), v4, v25);
      Boolean result = 0;
      BOOL v16 = v24 == Length;
      LOBYTE(Length) = 0;
      if (v16)
      {
        Boolean result = 1;
        LOBYTE(Length) = v25[0];
      }

      goto LABEL_44;
    }

    return 0;
  }

  char v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    uint64_t v12 = *p_data;
  }

  else
  {
    char v13 = atomic_load((unint64_t *)&theString->info);
    uint64_t v12 = (char *)&p_data[(v13 & 5) != 4LL];
  }

  char v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) == 4LL)
  {
    CFIndex Length = *v12;
  }

  else
  {
    char v15 = atomic_load((unint64_t *)&theString->info);
    BOOL v16 = (v15 & 0x60) == 0LL;
    uint64_t v17 = 24LL;
    if (v16) {
      uint64_t v17 = 16LL;
    }
    CFIndex Length = *(CFIndex *)((char *)&theString->isa + v17);
    if (Length > 255) {
      return 0;
    }
  }

  char v18 = atomic_load((unint64_t *)&theString->info);
  if ((v18 & 0x10) != 0) {
    goto LABEL_41;
  }
  int v19 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v19 = __CFDefaultEightBitStringEncoding;
  }

  if (v19 != (_DWORD)v5)
  {
    if (v19 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v19 = __CFDefaultEightBitStringEncoding;
    }

    if (v19 != 1536) {
      goto LABEL_41;
    }
    switch(BYTE1(v5))
    {
      case 0:
        goto LABEL_17;
      case 1:
        if ((_DWORD)v5 != 134217984) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 2:
        if ((_DWORD)v5 == 518) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 6:
        if ((_DWORD)v5 != 1536) {
          goto LABEL_41;
        }
        goto LABEL_17;
      case 8:
      case 0xC:
        goto LABEL_41;
      case 0xA:
        int v22 = 1 << (v5 - 1);
        int v23 = 32785;
        break;
      case 0xB:
        int v22 = 1 << (v5 + 13);
        int v23 = 4099;
        break;
      default:
        goto LABEL_17;
    }

    if ((v22 & v23) != 0) {
      goto LABEL_41;
    }
  }

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  v23[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = bufferSize - 1;
  if (bufferSize < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)&encoding;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString)) {
    return -[__CFString _getCString:maxLength:encoding:]( (id)theString,  "_getCString:maxLength:encoding:",  buffer,  v4,  v5);
  }
  char v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    uint64_t v12 = *p_data;
  }

  else
  {
    char v13 = atomic_load((unint64_t *)&theString->info);
    uint64_t v12 = (char *)&p_data[(v13 & 5) != 4LL];
  }

  char v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) == 4LL)
  {
    CFIndex length = *v12;
  }

  else
  {
    char v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 0x60) != 0) {
      CFIndex length = theString->length;
    }
    else {
      CFIndex length = (CFIndex)*p_data;
    }
  }

  char v17 = atomic_load((unint64_t *)&theString->info);
  if ((v17 & 0x10) != 0) {
    goto LABEL_41;
  }
  int v18 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v18 = __CFDefaultEightBitStringEncoding;
  }

  if (v18 == (_DWORD)v5) {
    goto LABEL_17;
  }
  if (v18 == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v18 = __CFDefaultEightBitStringEncoding;
  }

  if (v18 != 1536) {
    goto LABEL_41;
  }
  switch(BYTE1(v5))
  {
    case 0:
      goto LABEL_17;
    case 1:
      if ((_DWORD)v5 != 134217984) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 2:
      if ((_DWORD)v5 == 518) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 6:
      if ((_DWORD)v5 != 1536) {
        goto LABEL_41;
      }
      goto LABEL_17;
    case 8:
    case 0xC:
      goto LABEL_41;
    case 0xA:
      int v20 = 1 << (v5 - 1);
      int v21 = 32785;
      break;
    case 0xB:
      int v20 = 1 << (v5 + 13);
      int v21 = 4099;
      break;
    default:
      goto LABEL_17;
  }

  if ((v20 & v21) == 0)
  {
LABEL_17:
    if (length >= bufferSize)
    {
      Boolean result = 0;
      *UniChar buffer = 0;
    }

    else
    {
      unint64_t v19 = atomic_load((unint64_t *)&theString->info);
      memmove(buffer, &v12[(v19 >> 2) & 1], length);
      buffer[length] = 0;
      return 1;
    }
  }

  else
  {
LABEL_41:
    v24.CFIndex location = 0LL;
    v24.CFIndex length = length;
    Boolean result = __CFStringEncodeByteStream(theString, v24, 0, v5, 0, (UniChar *)buffer, v4, v23) == length;
    int64_t v22 = v23[0];
    if (!result) {
      int64_t v22 = 0LL;
    }
    buffer[v22] = 0;
  }

  return result;
}

uint64_t _CFStringCompareASCIICaseInsensitive(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v3 = __ASCII_LOWERCASE_TABLE[*a1] - __ASCII_LOWERCASE_TABLE[*a2];
    if ((_DWORD)v3) {
      break;
    }
    ++a2;
    ++a1;
    if (!--a3) {
      return 0LL;
    }
  }

  return v3;
}

CFComparisonResult CFStringCompareWithOptionsAndLocale( CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  CFIndex length = rangeToCompare.length;
  CFIndex location = rangeToCompare.location;
  uint64_t v348 = *MEMORY[0x1895F89C0];
  CFIndex v11 = CFStringGetLength(theString2);
  CFStringCompareFlags v12 = compareOptions;
  uint64_t v13 = v11;
  unsigned int v14 = (locale == 0LL) & (compareOptions >> 5);
  CFStringCompareFlags v321 = compareOptions;
  if (v14 == 1)
  {
    char v15 = CFLocaleCopyCurrent();
    CFStringCompareFlags v12 = compareOptions;
    locale = v15;
  }

  CFStringCompareFlags v16 = v12 & 0x191;
  if (locale)
  {
    uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 1);
    CFStringCompareFlags v12 = v321;
    __s1 = (char *)SpecialCaseHandlingLanguageIdentifierForLocale;
  }

  else
  {
    __s1 = 0LL;
  }

  int v18 = __CFStringFillCharacterSetInlineBuffer((uint64_t)&theSet, v12);
  unint64_t v19 = v321;
  CFComparisonResult v20 = kCFCompareEqualTo;
  if (v16) {
    char v21 = 1;
  }
  else {
    char v21 = v18;
  }
  char v311 = v21;
  int v317 = v18;
  CFStringRef theString = (__CFString *)theString1;
  if ((v321 & 0x40) != 0 || locale)
  {
    uint64_t v22 = 0LL;
    goto LABEL_28;
  }

  uint64_t v22 = 0LL;
  if ((v18 & 1) != 0) {
    goto LABEL_28;
  }
  unsigned int v23 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    unsigned int v23 = __CFDefaultEightBitStringEncoding;
  }

  uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)theString, v23, 0, 1);
  uint64_t v25 = _CFStringGetCStringPtrInternal((unint64_t *)theString2, v23, 0, 1);
  CFRange v26 = (unsigned __int8 *)v25;
  if (CStringPtrInternal && v25)
  {
    unint64_t v19 = v321 & 0xFFFFFFFFFFFFFFEFLL;
    if ((v321 & 0x200) != 0 || v23 != 1536)
    {
      if ((v321 & 0x81) != 0)
      {
        if (length >= v13) {
          uint64_t v202 = v13;
        }
        else {
          uint64_t v202 = length;
        }
        CStringPtrInternal += location;
        if (v202 >= 1)
        {
          uint64_t v22 = 0LL;
          CFComparisonResult v20 = kCFCompareEqualTo;
          while (1)
          {
            unsigned int v203 = *(unsigned __int8 *)(CStringPtrInternal + v22);
            unsigned int v204 = *(unsigned __int8 *)(v25 + v22);
            if (v203 != v204)
            {
              if (((v204 | v203) & 0x80) != 0)
              {
                uint64_t CStringPtrInternal = 0LL;
                goto LABEL_633;
              }

              if (v203 < v204) {
                uint64_t v205 = -1LL;
              }
              else {
                uint64_t v205 = 1LL;
              }
              if ((v321 & 1) != 0)
              {
                if (v203 - 65 < 0x1A) {
                  v203 += 32;
                }
                if (v204 - 65 < 0x1A) {
                  v204 += 32;
                }
              }

              BOOL v206 = v203 >= v204;
              if (v203 != v204) {
                goto LABEL_656;
              }
            }

            if (v202 == ++v22) {
              goto LABEL_634;
            }
          }
        }

        CFComparisonResult v20 = kCFCompareEqualTo;
        uint64_t v22 = 0LL;
LABEL_633:
        if (v22 == v202)
        {
LABEL_634:
          CFComparisonResult v277 = kCFCompareLessThan;
          if ((_DWORD)length == (_DWORD)v13) {
            return v20;
          }
          else {
            return v277;
          }
        }

LABEL_431:
        uint64_t v32 = 1LL;
        if (!CStringPtrInternal) {
          goto LABEL_28;
        }
        goto LABEL_610;
      }
    }

    else if ((v321 & 1) != 0)
    {
      if (length >= v13) {
        CFIndex v27 = v13;
      }
      else {
        CFIndex v27 = length;
      }
      if (v27)
      {
        char v28 = (unsigned __int8 *)(CStringPtrInternal + location);
        while (1)
        {
          int v29 = __ASCII_LOWERCASE_TABLE[*v28] - __ASCII_LOWERCASE_TABLE[*v26];
          if (v29) {
            break;
          }
          ++v26;
          ++v28;
          if (!--v27) {
            goto LABEL_624;
          }
        }
      }

      else
      {
LABEL_624:
        int v29 = length - v13;
      }

      BOOL v43 = v29 == 0;
      BOOL v270 = v29 < 0;
      goto LABEL_626;
    }

    CFComparisonResult v20 = kCFCompareEqualTo;
    uint64_t v22 = 0LL;
    goto LABEL_431;
  }

  CFComparisonResult v20 = kCFCompareEqualTo;
  uint64_t v32 = 1LL;
  unint64_t v19 = v321;
  if ((v311 & 1) == 0 && !CStringPtrInternal)
  {
    uint64_t v22 = 0LL;
    if (v25) {
      goto LABEL_609;
    }
    uint64_t CStringPtrInternal = (uint64_t)CFStringGetCharactersPtr(theString);
    CharactersPtr = CFStringGetCharactersPtr(theString2);
    CFRange v26 = (unsigned __int8 *)CharactersPtr;
    CFComparisonResult v20 = kCFCompareEqualTo;
    uint64_t v32 = 2LL;
    if (!CStringPtrInternal)
    {
      uint64_t v22 = 0LL;
      unint64_t v19 = v321;
      goto LABEL_28;
    }

    unint64_t v19 = v321;
    if (CharactersPtr)
    {
      if (length >= v13) {
        uint64_t v34 = v13;
      }
      else {
        uint64_t v34 = length;
      }
      if (v34 < 1) {
        goto LABEL_46;
      }
      uint64_t v35 = CStringPtrInternal + 2 * location;
      unint64_t v36 = v35 + 2 * v34;
      unint64_t v37 = v35 + 2;
      do
      {
        unsigned int v38 = *(unsigned __int16 *)v26;
        v26 += 2;
        uint64_t v39 = *(unsigned __int16 *)(v37 - 2);
        uint64_t v40 = v39 - v38;
        BOOL v41 = v39 != v38 || v37 >= v36;
        v37 += 2LL;
      }

      while (!v41);
      if (!v40) {
LABEL_46:
      }
        uint64_t v40 = length - v13;
      CFComparisonResult v42 = (v40 >> 63) | 1;
      BOOL v43 = v40 == 0;
      goto LABEL_628;
    }
  }

  uint64_t v22 = 0LL;
LABEL_609:
  if (!CStringPtrInternal) {
    goto LABEL_28;
  }
LABEL_610:
  if (v26)
  {
    if (length >= v13) {
      CFIndex v267 = v13;
    }
    else {
      CFIndex v267 = length;
    }
    int v268 = memcmp((const void *)(CStringPtrInternal + v32 * location), v26, v32 * v267);
    int v269 = length - v13;
    if (v268) {
      int v269 = v268;
    }
    BOOL v43 = v269 == 0;
    BOOL v270 = v269 < 0;
LABEL_626:
    CFComparisonResult v42 = kCFCompareLessThan;
    if (!v270) {
      CFComparisonResult v42 = kCFCompareGreaterThan;
    }
LABEL_628:
    if (v43) {
      return 0LL;
    }
    else {
      return v42;
    }
  }

LABEL_445:
              UTF32Char v218 = v217;
              if (((v217 < 0x80u) & ~v49) != 0) {
                break;
              }
              if (v217 >> 10 == 54 && v59 >= -1)
              {
                int64_t v219 = v59 + 1;
                CFIndex v220 = v343;
                if (v343 > v59 + 1)
                {
                  uint64_t v221 = (UniChar *)v340;
                  if (v340)
                  {
                    CFIndex v222 = v342 + v219;
                    goto LABEL_451;
                  }

                  if (v341)
                  {
                    UniChar v223 = *(char *)(v341 + v342 + v219);
                  }

                  else
                  {
                    if (v345 <= v219 || (uint64_t v237 = v344, v344 > v219))
                    {
                      uint64_t v238 = v59 - 3;
                      if (v238 + 64 < v343) {
                        CFIndex v220 = v238 + 64;
                      }
                      uint64_t v344 = v238;
                      uint64_t v345 = v220;
                      v356.CFIndex location = v342 + v238;
                      v356.CFIndex length = v220 - v238;
                      CFStringGetCharacters(v339, v356, v338);
                      int64_t v50 = v213;
                      int v49 = v317;
                      uint64_t v48 = v212;
                      uint64_t v237 = v344;
                    }

                    CFIndex v222 = v219 - v237;
                    uint64_t v221 = v338;
LABEL_451:
                    UniChar v223 = v221[v222];
                  }

                  if (v223 >> 10 == 55) {
                    UTF32Char v218 = (v218 << 10) + v223 - 56613888;
                  }
                }
              }

              if (!(_DWORD)v313) {
                goto LABEL_463;
              }
              uint64_t v224 = BitmapPtrForPlane;
              if (v218 >= 0x10000)
              {
                uint64_t v224 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v218));
                int64_t v50 = v213;
                int v49 = v317;
                uint64_t v48 = v212;
              }

              if (!v224 || ((*(unsigned __int8 *)(v224 + ((unsigned __int16)v218 >> 3)) >> (v218 & 7)) & 1) == 0)
              {
LABEL_463:
                if (!v49) {
                  break;
                }
                unsigned int v225 = v324 & 4;
                if (v325 > v218 || v326 <= v218)
                {
                  if ((v324 & 4) == 0) {
                    break;
                  }
                }

                else if (HIWORD(v218) || (v324 & 2) != 0)
                {
                  int IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet, v218);
                  int64_t v50 = v213;
                  int v49 = v317;
                  uint64_t v48 = v212;
                  if (!IsLongCharacterMember) {
                    break;
                  }
                }

                else if (v327)
                {
                  if ((v324 & 1) != 0)
                  {
                    unsigned int v231 = v225 >> 2;
                    uint64_t v232 = *(unsigned __int8 *)(v327 + ((unint64_t)v218 >> 8));
                    if (*(_BYTE *)(v327 + ((unint64_t)v218 >> 8)))
                    {
                      if ((_DWORD)v232 == 255)
                      {
                        unsigned int v231 = v225 == 0;
                      }

                      else
                      {
                        BOOL v235 = v225 == 0;
                        if ((((unint64_t)*(unsigned __int8 *)(v327
                                                                    + 32 * v232
                                                                    + (v218 >> 3)
                                                                    + 224) >> (v218 & 7)) & 1) != 0)
                          unsigned int v231 = v235;
                      }
                    }

                    if (!v231) {
                      break;
                    }
                  }

                  else
                  {
                    BOOL v43 = v225 == 0;
                    BOOL v226 = v225 != 0;
                    char v227 = v43;
                    if (!v226) {
                      break;
                    }
                  }
                }

                else
                {
                  BOOL v43 = v225 == 0;
                  BOOL v229 = v225 != 0;
                  char v230 = v43;
                  if ((v324 & 1) == 0) {
                    BOOL v229 = v230;
                  }
                  if (!v229) {
                    break;
                  }
                }
              }

              if (v218 < 0x10000) {
                uint64_t v236 = 1LL;
              }
              else {
                uint64_t v236 = 2LL;
              }
              v59 += v236;
            }

            while (v60 < v13)
            {
              if (v60 < 0 || (uint64_t v239 = v335, v335 <= v60))
              {
                UniChar v242 = 0;
              }

              else
              {
                uint64_t v240 = v332;
                if (v332)
                {
                  uint64_t v241 = v334 + v60;
LABEL_520:
                  UniChar v242 = v240[v241];
                  goto LABEL_522;
                }

                if (!v333)
                {
                  if (v337 <= v60 || (uint64_t v258 = v336, v336 > v60))
                  {
                    uint64_t v259 = v60 - 4;
                    if (v259 + 64 < v335) {
                      uint64_t v239 = v259 + 64;
                    }
                    uint64_t v336 = v259;
                    uint64_t v337 = v239;
                    v357.CFIndex location = v334 + v259;
                    v357.CFIndex length = v239 - v259;
                    CFStringGetCharacters(v331, v357, buffer);
                    int64_t v50 = v213;
                    int v49 = v317;
                    uint64_t v48 = v212;
                    uint64_t v258 = v336;
                  }

                  uint64_t v241 = v60 - v258;
                  uint64_t v240 = buffer;
                  goto LABEL_520;
                }

                UniChar v242 = *(char *)(v333 + v334 + v60);
              }

LABEL_522:
              UTF32Char v243 = v242;
              if (((v242 < 0x80u) & ~v49) != 0) {
                break;
              }
              if (v242 >> 10 == 54 && v60 >= -1)
              {
                int64_t v244 = v60 + 1;
                uint64_t v245 = v335;
                if (v335 > v60 + 1)
                {
                  uint64_t v246 = v332;
                  if (v332)
                  {
                    int64_t v247 = v334 + v244;
                    goto LABEL_528;
                  }

                  if (v333)
                  {
                    UniChar v248 = *(char *)(v333 + v334 + v244);
                  }

                  else
                  {
                    if (v337 <= v244 || (uint64_t v262 = v336, v336 > v244))
                    {
                      uint64_t v263 = v60 - 3;
                      if (v263 + 64 < v335) {
                        uint64_t v245 = v263 + 64;
                      }
                      uint64_t v336 = v263;
                      uint64_t v337 = v245;
                      v358.CFIndex location = v334 + v263;
                      v358.CFIndex length = v245 - v263;
                      CFStringGetCharacters(v331, v358, buffer);
                      int64_t v50 = v213;
                      int v49 = v317;
                      uint64_t v48 = v212;
                      uint64_t v262 = v336;
                    }

                    int64_t v247 = v244 - v262;
                    uint64_t v246 = buffer;
LABEL_528:
                    UniChar v248 = v246[v247];
                  }

                  if (v248 >> 10 == 55) {
                    UTF32Char v243 = (v243 << 10) + v248 - 56613888;
                  }
                }
              }

              if (!(_DWORD)v313) {
                goto LABEL_540;
              }
              uint64_t v249 = BitmapPtrForPlane;
              if (v243 >= 0x10000)
              {
                uint64_t v249 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v243));
                int64_t v50 = v213;
                int v49 = v317;
                uint64_t v48 = v212;
              }

              if (!v249 || ((*(unsigned __int8 *)(v249 + ((unsigned __int16)v243 >> 3)) >> (v243 & 7)) & 1) == 0)
              {
LABEL_540:
                if (!v49) {
                  break;
                }
                unsigned int v250 = v324 & 4;
                if (v325 > v243 || v326 <= v243)
                {
                  if ((v324 & 4) == 0) {
                    break;
                  }
                }

                else if (HIWORD(v243) || (v324 & 2) != 0)
                {
                  int v253 = CFCharacterSetIsLongCharacterMember(theSet, v243);
                  int64_t v50 = v213;
                  int v49 = v317;
                  uint64_t v48 = v212;
                  if (!v253) {
                    break;
                  }
                }

                else if (v327)
                {
                  if ((v324 & 1) != 0)
                  {
                    unsigned int v256 = v250 >> 2;
                    uint64_t v257 = *(unsigned __int8 *)(v327 + ((unint64_t)v243 >> 8));
                    if (*(_BYTE *)(v327 + ((unint64_t)v243 >> 8)))
                    {
                      if ((_DWORD)v257 == 255)
                      {
                        unsigned int v256 = v250 == 0;
                      }

                      else
                      {
                        BOOL v260 = v250 == 0;
                        if ((((unint64_t)*(unsigned __int8 *)(v327
                                                                    + 32 * v257
                                                                    + (v243 >> 3)
                                                                    + 224) >> (v243 & 7)) & 1) != 0)
                          unsigned int v256 = v260;
                      }
                    }

                    if (!v256) {
                      break;
                    }
                  }

                  else
                  {
                    BOOL v43 = v250 == 0;
                    BOOL v251 = v250 != 0;
                    char v252 = v43;
                    if (!v251) {
                      break;
                    }
                  }
                }

                else
                {
                  BOOL v43 = v250 == 0;
                  BOOL v254 = v250 != 0;
                  char v255 = v43;
                  if ((v324 & 1) == 0) {
                    BOOL v254 = v255;
                  }
                  if (!v254) {
                    break;
                  }
                }
              }

              if (v243 < 0x10000) {
                uint64_t v261 = 1LL;
              }
              else {
                uint64_t v261 = 2LL;
              }
              v60 += v261;
            }
          }

          if (v201 && (v296 & 1) == 0 && v48 && v59 == length && v60 == v13) {
            uint64_t v48 = _CFCompareStringsWithLocale(v338, v55, length - v55, buffer, v50, v13 - v50, v295, v201);
          }
          char v264 = v297 ^ 1;
          if (!v201) {
            char v264 = 1;
          }
          if ((v264 & 1) == 0)
          {
            uint64_t v265 = v48;
            CFRelease(v201);
            uint64_t v48 = v265;
          }

          if (v60 < v13) {
            CFComparisonResult v266 = kCFCompareLessThan;
          }
          else {
            CFComparisonResult v266 = v48;
          }
          if (v59 < length) {
            return 1LL;
          }
          else {
            return v266;
          }
        }

        goto LABEL_59;
      }

      if ((v62 & 1) == 0)
      {
        unsigned __int8 v207 = cf;
        if (cf)
        {
          int64_t v208 = v315 - v22;
          int64_t v209 = v294 - v57;
          int64_t v47 = v22;
          int64_t v210 = v57;
          goto LABEL_435;
        }

        goto LABEL_655;
      }

      if (v67 < v68) {
        CFComparisonResult v77 = kCFCompareLessThan;
      }
      else {
        CFComparisonResult v77 = kCFCompareGreaterThan;
      }
      if (((v48 == 0) & (v46 >> 9)) != 0)
      {
        uint64_t v48 = v77;
        int64_t v50 = v58;
        int64_t v55 = v47;
      }

      if (v67 >= 0x80 || v68 >= 0x80) {
        int v79 = 0;
      }
      else {
        int v79 = v56;
      }
      if (v79 == 1)
      {
        if (cf)
        {
          int64_t v271 = v315 - v59;
          unint64_t v272 = v295;
          int64_t v273 = v294 - v60;
          int64_t v47 = v59;
          int64_t v274 = v60;
          int v275 = cf;
          goto LABEL_618;
        }

        if ((v46 & 1) == 0) {
          return v77;
        }
      }

      if ((v67 & 0xFC00) == 0xD800 && v59 >= -1)
      {
        int64_t v80 = v59 + 1;
        CFIndex v81 = v343;
        if (v343 > v59 + 1)
        {
          unint64_t v82 = (UniChar *)v340;
          if (v340)
          {
            CFIndex v83 = v342 + v80;
          }

          else
          {
            if (v341)
            {
              UniChar v84 = *(char *)(v341 + v342 + v80);
LABEL_132:
              if (v84 >> 10 == 55)
              {
                UTF32Char v67 = ((unsigned __int16)v67 << 10) - 56613888 + v84;
                uint64_t v329 = 2LL;
              }

              goto LABEL_134;
            }

            if (v345 <= v80 || (uint64_t v117 = v344, v344 > v80))
            {
              uint64_t v118 = v59 - 3;
              if (v118 + 64 < v343) {
                CFIndex v81 = v118 + 64;
              }
              uint64_t v344 = v118;
              uint64_t v345 = v81;
              v352.CFIndex location = v342 + v118;
              v352.CFIndex length = v81 - v118;
              uint64_t v284 = v51;
              uint64_t v279 = v48;
              int64_t v292 = v55;
              int64_t v119 = v50;
              CFStringGetCharacters(v339, v352, v338);
              uint64_t v64 = v316;
              uint64_t v61 = v318;
              unsigned int v46 = v321;
              uint64_t v57 = v306;
              int v56 = v317 ^ 1;
              uint64_t v51 = v284;
              int64_t v58 = v303;
              int64_t v47 = v304;
              int64_t v50 = v119;
              int64_t v55 = v292;
              int v49 = v317;
              uint64_t v48 = v279;
              uint64_t v117 = v344;
            }

            CFIndex v83 = v80 - v117;
            unint64_t v82 = v338;
          }

          UniChar v84 = v82[v83];
          goto LABEL_132;
        }
      }

LABEL_144:
      if (!v49) {
        goto LABEL_331;
      }
      char v89 = v324;
      UTF32Char v90 = v325;
      unsigned int v91 = v324 & 4;
      if (v325 > v67 || v326 <= v67)
      {
        if ((v324 & 4) == 0) {
          goto LABEL_220;
        }
        goto LABEL_189;
      }

      if (HIWORD(v67) || (v324 & 2) != 0) {
        break;
      }
      if (v327)
      {
        if ((v324 & 1) != 0)
        {
          unsigned int v120 = v91 >> 2;
          uint64_t v100 = *(unsigned __int8 *)(v327 + ((unint64_t)v67 >> 8));
          if (*(_BYTE *)(v327 + ((unint64_t)v67 >> 8)))
          {
            if ((_DWORD)v100 == 255)
            {
              unsigned int v101 = v91 == 0;
            }

            else if ((((unint64_t)*(unsigned __int8 *)(v327 + 32 * v100 + (v67 >> 3) + 224) >> (v67 & 7)) & 1) != 0)
            {
              unsigned int v101 = v91 == 0;
            }

            else
            {
              unsigned int v101 = v91 >> 2;
            }
          }

          else
          {
            unsigned int v101 = v91 >> 2;
          }

          uint64_t v57 = v306;
          if (!v101) {
            goto LABEL_221;
          }
        }

        else
        {
          BOOL v92 = v91 != 0;
          uint64_t v57 = v306;
          if (!v92) {
            goto LABEL_220;
          }
        }
      }

      else
      {
        BOOL v99 = v91 != 0;
        if ((v324 & 1) == 0) {
          BOOL v99 = v91 == 0;
        }
        if (!v99)
        {
LABEL_220:
          unsigned int v120 = v91 >> 2;
          goto LABEL_221;
        }
      }

LABEL_251:
      uint64_t v61 = v318;
      if (v52 == v318 && v318 > 0) {
        uint64_t v61 = 0LL;
      }
      uint64_t v134 = v328;
      if (v61) {
        uint64_t v134 = 0LL;
      }
      v60 += v134;
      CFIndex length = v315;
      if (v315 <= v59 || (v51 -= v53 > 0, v60 >= v294))
      {
LABEL_437:
        int64_t v201 = cf;
        uint64_t v13 = v294;
        goto LABEL_438;
      }

      continue;
    }

    break;
  }

  BOOL v43 = v91 == 0;
  BOOL v129 = v91 != 0;
  char v130 = v43;
  if ((v89 & 1) == 0) {
    BOOL v129 = v130;
  }
  if (v129) {
    goto LABEL_251;
  }
LABEL_330:
  uint64_t v57 = v60;
  uint64_t v61 = v318;
  uint64_t v298 = v53;
  uint64_t v300 = v318;
  uint64_t v22 = v59;
LABEL_331:
  char v165 = v313 ^ 1;
  if (v22 < 1) {
    char v165 = 1;
  }
  uint64_t v166 = v281;
  if ((v165 & 1) != 0)
  {
    uint64_t v168 = v286;
    uint64_t v54 = v300;
  }

  else
  {
    uint64_t v54 = v300;
    if (v53)
    {
      BOOL v167 = 0;
      if (!v61) {
        goto LABEL_346;
      }
LABEL_357:
      if (v167) {
        v57 -= v328;
      }
    }

    else
    {
      uint64_t v169 = BitmapPtrForPlane;
      if (v67 >= 0x10000)
      {
        uint64_t v170 = v48;
        int64_t v171 = v50;
        uint64_t v172 = v51;
        uint64_t v173 = v57;
        uint64_t v169 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v67));
        uint64_t v57 = v173;
        int v56 = v317 ^ 1;
        uint64_t v51 = v172;
        uint64_t v166 = v281;
        int64_t v58 = v303;
        int64_t v47 = v304;
        unsigned int v46 = v321;
        int64_t v50 = v171;
        uint64_t v54 = v300;
        int v49 = v317;
        uint64_t v48 = v170;
      }

      if (v169)
      {
        int v174 = (1 << (v67 & 7)) & *(unsigned __int8 *)(v169 + ((unsigned __int16)v67 >> 3));
        BOOL v167 = v174 != 0;
        if (v174) {
          UTF32Char v67 = v68;
        }
      }

      else
      {
        BOOL v167 = 0;
      }

      if (v318) {
        goto LABEL_357;
      }
LABEL_346:
      uint64_t v175 = BitmapPtrForPlane;
      if (v68 >= 0x10000)
      {
        uint64_t v176 = v48;
        int64_t v177 = v50;
        uint64_t v178 = v51;
        uint64_t v308 = v57;
        uint64_t v175 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v68));
        uint64_t v57 = v308;
        int v56 = v317 ^ 1;
        uint64_t v51 = v178;
        uint64_t v166 = v281;
        int64_t v58 = v303;
        int64_t v47 = v304;
        unsigned int v46 = v321;
        int64_t v50 = v177;
        int v49 = v317;
        uint64_t v48 = v176;
        uint64_t v54 = v300;
      }

      if (!v175) {
        goto LABEL_357;
      }
      int v179 = (1 << (v68 & 7)) & *(unsigned __int8 *)(v175 + ((unsigned __int16)v68 >> 3));
      if (v179) {
        UTF32Char v180 = v67;
      }
      else {
        UTF32Char v180 = v68;
      }
      if (((v167 ^ (v179 != 0)) & 1) != 0)
      {
        uint64_t v181 = v328;
        if (!v167) {
          uint64_t v181 = 0LL;
        }
        v57 -= v181;
        if (v179)
        {
          v22 -= v329;
          UTF32Char v68 = v67;
        }
      }

      else
      {
        UTF32Char v68 = v180;
      }
    }

    uint64_t v168 = v286;
    uint64_t v61 = v318;
  }

  if (v67 == v68)
  {
    CFIndex length = v315;
    uint64_t v13 = v294;
    uint64_t v53 = v298;
    goto LABEL_381;
  }

  if (v53)
  {
    BOOL v182 = 0;
    uint64_t v53 = v298;
    goto LABEL_379;
  }

  if (!v166 || v166 == v22)
  {
    uint64_t v309 = v57;
    int64_t v183 = v50;
    uint64_t v184 = v48;
    char v322 = 0;
    uint64_t v185 = v22;
    int64_t v186 = v22;
    uint64_t v187 = v51;
    uint64_t v188 = __CFStringFoldCharacterClusterAtIndex(v67, v338, v185, v295, __s1, v347, &v329, &v322);
    uint64_t v53 = v188;
    if (v188 > 0) {
      uint64_t v51 = 1LL;
    }
    else {
      uint64_t v51 = v187;
    }
    if (v188 > 0) {
      UTF32Char v67 = v347[0];
    }
    if (v322)
    {
      uint64_t v189 = v51;
      uint64_t RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theString, v186, 1LL);
      uint64_t v51 = v189;
      uint64_t v166 = RangeOfCharacterClusterAtIndex + v191;
    }

    else
    {
      uint64_t v166 = 0LL;
    }

    int64_t v58 = v303;
    int64_t v47 = v304;
    uint64_t v48 = v184;
    int v49 = v317;
    int64_t v50 = v183;
    uint64_t v61 = v318;
    unsigned int v46 = v321;
    uint64_t v22 = v186;
    int v56 = v317 ^ 1;
    uint64_t v57 = v309;
    uint64_t v54 = v300;
  }

  else
  {
    uint64_t v53 = 0LL;
  }

  BOOL v182 = v53 == 0;
  if (!v53 && v54 >= 1)
  {
    unsigned __int8 v207 = cf;
    if (cf)
    {
      int64_t v208 = v315 - v47;
      int64_t v209 = v294 - v58;
      int64_t v210 = v58;
LABEL_435:
      CFComparisonResult v77 = _CFCompareStringsWithLocale(v338, v47, v208, buffer, v210, v209, v295, v207);
      if (!v297) {
        return v77;
      }
      int v211 = v207;
LABEL_620:
      CFRelease(v211);
      return v77;
    }

LABEL_655:
    BOOL v206 = v67 >= v68;
    goto LABEL_656;
  }

LABEL_379:
  uint64_t v281 = v166;
  if (!v61)
  {
    if (v67 != v68) {
      BOOL v182 = 1;
    }
    if (v182)
    {
      uint64_t v13 = v294;
      if (v286 && v286 != v57)
      {
        uint64_t v54 = 0LL;
        CFIndex length = v315;
        goto LABEL_311;
      }

      uint64_t v299 = v53;
      uint64_t v192 = v51;
      int64_t v193 = v50;
      uint64_t v194 = v48;
      char v322 = 0;
      int64_t v195 = v57;
      uint64_t v196 = __CFStringFoldCharacterClusterAtIndex(v68, buffer, v57, v295, __s1, v346, &v328, &v322);
      unsigned int v197 = v346[0];
      if (v196 <= 0) {
        unsigned int v197 = v68;
      }
      else {
        uint64_t v52 = 1LL;
      }
      if (v196 && v67 == v197)
      {
        uint64_t v198 = v196;
        if (v322)
        {
          uint64_t v199 = CFStringGetRangeOfCharacterClusterAtIndex(v280, v195, 1LL);
          uint64_t v168 = v199 + v200;
        }

        else
        {
          uint64_t v168 = 0LL;
        }

        CFIndex length = v315;
        uint64_t v48 = v194;
        int v49 = v317;
        int64_t v50 = v193;
        unsigned int v46 = v321;
        int64_t v58 = v303;
        int64_t v47 = v304;
        uint64_t v51 = v192;
        int v56 = v317 ^ 1;
        uint64_t v57 = v195;
        uint64_t v53 = v299;
        uint64_t v54 = v198;
        goto LABEL_381;
      }

      int v275 = cf;
      if (!cf)
      {
        BOOL v206 = v67 >= v197;
        goto LABEL_656;
      }

      int64_t v274 = v303;
      int64_t v47 = v304;
      int64_t v271 = v315 - v304;
      int64_t v273 = v294 - v303;
LABEL_641:
      unint64_t v272 = v295;
LABEL_618:
      CFComparisonResult v77 = _CFCompareStringsWithLocale(v338, v47, v271, buffer, v274, v273, v272, v275);
      if (!v297) {
        return v77;
      }
      int v211 = v275;
      goto LABEL_620;
    }

    uint64_t v54 = 0LL;
    goto LABEL_310;
  }

  CFIndex length = v315;
  uint64_t v13 = v294;
  uint64_t v168 = v286;
LABEL_381:
  uint64_t v286 = v168;
  if (v53 < 1 || v54 < 1) {
    goto LABEL_311;
  }
  while (v51 < v53 && v52 < v54)
  {
    if (v347[v51] != v346[v52]) {
      goto LABEL_639;
    }
    ++v51;
    ++v52;
  }

  if (v51 >= v53 || v52 >= v54) {
    goto LABEL_311;
  }
LABEL_639:
  int v275 = cf;
  if (cf)
  {
    int64_t v271 = length - v47;
    int64_t v273 = v13 - v58;
    int64_t v274 = v58;
    goto LABEL_641;
  }

  BOOL v206 = v347[v51] >= v346[v52];
LABEL_656:
  if (v206) {
    return 1LL;
  }
  else {
    return -1LL;
  }
}

uint64_t _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(const __CFLocale *a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!__CFLocaleGetDoesNotRequireSpecialCaseHandling(a1))
  {
    os_unfair_lock_lock_with_options();
    uint64_t v5 = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale;
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
    if (v5) {
      BOOL v6 = v5 == (void)a1;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      return _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID;
    }
    if (a2) {
      CFTypeRef Value = (const __CFString *)CFLocaleGetValue(a1, @"locale:collator id");
    }
    else {
      CFTypeRef Value = CFLocaleGetIdentifier(a1);
    }
    uint64_t v8 = (unint64_t *)Value;
    if (CFStringGetLength(Value) >= 2)
    {
      uint64_t CStringPtrInternal = (const char *)_CFStringGetCStringPtrInternal(v8, 0x8000100u, 1, 1);
      if (CStringPtrInternal
        || (uint64_t CStringPtrInternal = (const char *)buffer,
            v13.CFIndex location = 0LL,
            v13.CFIndex length = 2LL,
            CFStringGetBytes((CFStringRef)v8, v13, 0x8000100u, 0, 0, buffer, 2LL, 0LL) == 2))
      {
        uint64_t v4 = "az";
        if (!strncmp(CStringPtrInternal, "az", 2uLL)
          || (uint64_t v4 = "lt", !strncmp(CStringPtrInternal, "lt", 2uLL))
          || (uint64_t v4 = "tr", !strncmp(CStringPtrInternal, "tr", 2uLL))
          || (uint64_t v4 = "nl", !strncmp(CStringPtrInternal, "nl", 2uLL))
          || (uint64_t v4 = "el", !strncmp(CStringPtrInternal, "el", 2uLL)))
        {
          os_unfair_lock_lock_with_options();
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale = (uint64_t)a1;
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID = (uint64_t)v4;
          os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
          return (uint64_t)v4;
        }
      }
    }
  }

  return 0LL;
}

uint64_t __CFStringFillCharacterSetInlineBuffer(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x10000) != 0)
  {
    if (!__CFStringFillCharacterSetInlineBuffer_nonAlnumChars)
    {
      CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
      MutableCFStringRef Copy = CFCharacterSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Predefined);
      CFCharacterSetInvert(MutableCopy);
      while (!__ldaxr((unint64_t *)&__CFStringFillCharacterSetInlineBuffer_nonAlnumChars))
      {
        if (!__stlxr( (unint64_t)MutableCopy,  (unint64_t *)&__CFStringFillCharacterSetInlineBuffer_nonAlnumChars)) {
          goto LABEL_8;
        }
      }

      __clrex();
      CFRelease(MutableCopy);
    }

uint64_t __CFStringFoldCharacterClusterAtIndex( unsigned int a1, UniChar *buffer, uint64_t a3, __int16 a4, char *__s1, unsigned int *a6, void *a7, _BYTE *a8)
{
  uint64_t v115 = *MEMORY[0x1895F89C0];
  unsigned int v113 = a1;
  if (!a1) {
    return 0LL;
  }
  unsigned int v14 = a1;
  unsigned int v15 = HIWORD(a1);
  if (!__CFStringFoldCharacterClusterAtIndex_decompBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_decompBMP = CFUniCharGetBitmapPtrForPlane(9u, 0);
    __CFStringFoldCharacterClusterAtIndex_graphemeBMP = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  }

  uint64_t v16 = 1LL;
  if (v15) {
    uint64_t v16 = 2LL;
  }
  uint64_t v110 = a3;
  uint64_t v111 = a8;
  int64_t v17 = v16 + a3;
  if (v14 <= 0x7F)
  {
    if (!__s1 || v14 != 73)
    {
      uint64_t v18 = 0LL;
      char v19 = 0;
      if ((a4 & 1) == 0 || v14 - 65 > 0x19) {
        goto LABEL_118;
      }
      char v19 = 0;
      unsigned int v113 = v14 + 32;
      *a6 = v14 + 32;
      goto LABEL_17;
    }

    uint64_t v18 = 0LL;
LABEL_36:
    unsigned int v15 = 0;
    goto LABEL_37;
  }

  if ((a4 & 0x100) != 0 && v14 - 65280 <= 0xEF)
  {
    uint64_t v18 = 1LL;
    CFUniCharCompatibilityDecompose((int *)&v113, 1LL, 1LL);
    LOWORD(v14) = v113;
    *a6 = v113;
  }

  else
  {
    uint64_t v18 = 0LL;
    if (v15) {
      goto LABEL_37;
    }
  }

  unsigned int v15 = 0;
  if ((v14 & 0xFC00) == 0xD800 && (v17 & 0x8000000000000000LL) == 0)
  {
    int64_t v20 = *((void *)buffer + 20);
    if (v20 > v17)
    {
      uint64_t v21 = *((void *)buffer + 17);
      if (v21)
      {
        UniChar v22 = *(_WORD *)(v21 + 2 * (*((void *)buffer + 19) + v17));
      }

      else
      {
        uint64_t v23 = *((void *)buffer + 18);
        if (v23)
        {
          UniChar v22 = *(char *)(v23 + *((void *)buffer + 19) + v17);
        }

        else
        {
          if (*((void *)buffer + 22) <= v17 || (int64_t v24 = *((void *)buffer + 21), v24 > v17))
          {
            int64_t v25 = v17 - 4;
            if (v25 + 64 < v20) {
              int64_t v20 = v25 + 64;
            }
            *((void *)buffer + 21) = v25;
            *((void *)buffer + 22) = v20;
            v116.CFIndex location = *((void *)buffer + 19) + v25;
            v116.CFIndex length = v20 - v25;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v116, buffer);
            int64_t v24 = *((void *)buffer + 21);
          }

          UniChar v22 = buffer[v17 - v24];
        }
      }

      if (v22 >> 10 == 55)
      {
        unsigned int v113 = ((unsigned __int16)v113 << 10) + v22 - 56613888;
        ++v17;
        unsigned int v15 = HIWORD(v113);
        goto LABEL_37;
      }
    }

    goto LABEL_36;
  }

LABEL_201:
              while ((v17 & 0x8000000000000000LL) == 0)
              {
                int64_t v90 = *((void *)buffer + 20);
                if (v90 <= v17) {
                  break;
                }
                uint64_t v91 = *((void *)buffer + 17);
                if (v91)
                {
                  UniChar v92 = *(_WORD *)(v91 + 2 * (*((void *)buffer + 19) + v17));
                }

                else
                {
                  uint64_t v99 = *((void *)buffer + 18);
                  if (v99)
                  {
                    UniChar v92 = *(char *)(v99 + *((void *)buffer + 19) + v17);
                  }

                  else
                  {
                    if (*((void *)buffer + 22) <= v17 || (int64_t v100 = *((void *)buffer + 21), v100 > v17))
                    {
                      int64_t v101 = v17 - 4;
                      if (v101 + 64 < v90) {
                        int64_t v90 = v101 + 64;
                      }
                      *((void *)buffer + 21) = v101;
                      *((void *)buffer + 22) = v90;
                      v120.CFIndex location = *((void *)buffer + 19) + v101;
                      v120.CFIndex length = v90 - v101;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v120, buffer);
                      int64_t v100 = *((void *)buffer + 21);
                    }

                    UniChar v92 = buffer[v17 - v100];
                  }
                }

                unsigned int v113 = v92;
                if (v92 >> 10 != 54) {
                  goto LABEL_206;
                }
                int64_t v102 = v17 + 1;
                int64_t v103 = *((void *)buffer + 20);
                if (v103 <= v17 + 1) {
                  goto LABEL_206;
                }
                uint64_t v104 = *((void *)buffer + 17);
                if (v104)
                {
                  UniChar v105 = *(_WORD *)(v104 + 2 * (*((void *)buffer + 19) + v102));
                }

                else
                {
                  uint64_t v106 = *((void *)buffer + 18);
                  if (v106)
                  {
                    UniChar v105 = *(char *)(v106 + *((void *)buffer + 19) + v102);
                  }

                  else
                  {
                    if (*((void *)buffer + 22) <= v102 || (int64_t v107 = *((void *)buffer + 21), v107 > v102))
                    {
                      int64_t v108 = v17 - 3;
                      if (v108 + 64 < v103) {
                        int64_t v103 = v108 + 64;
                      }
                      *((void *)buffer + 21) = v108;
                      *((void *)buffer + 22) = v103;
                      v121.CFIndex location = *((void *)buffer + 19) + v108;
                      v121.CFIndex length = v103 - v108;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v121, buffer);
                      int64_t v107 = *((void *)buffer + 21);
                    }

                    UniChar v105 = buffer[v102 - v107];
                  }
                }

                if (v105 >> 10 != 55) {
                  goto LABEL_206;
                }
                unsigned int v113 = ((unsigned __int16)v113 << 10) + v105 - 56613888;
                uint64_t v93 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
                uint64_t v94 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v113));
                if ((v19 & 1) != 0) {
                  goto LABEL_222;
                }
LABEL_207:
                if (!v93) {
                  goto LABEL_129;
                }
                uint64_t v95 = (unsigned __int16)v113 >> 3;
                int v96 = 1 << (v113 & 7);
                if ((_DWORD)v59)
                {
                  if (v94 && (v96 & *(_BYTE *)(v94 + v95)) != 0)
                  {
                    uint64_t v97 = CFUniCharDecomposeCharacter(v113, &a6[v18], 64 - v18);
                    v18 += v97;
                    if (!v97) {
                      goto LABEL_127;
                    }
                  }

                  else
                  {
                    a6[v18++] = v113;
                  }
                }

                else if ((unint64_t)v18 <= 1)
                {
                  uint64_t v18 = 1LL;
                }

                if (v93 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
                  uint64_t v98 = 1LL;
                }
                else {
                  uint64_t v98 = 2LL;
                }
                v17 += v98;
LABEL_222:
                char v19 = 0;
                if (v18 >= 64) {
                  goto LABEL_127;
                }
              }

              unsigned int v113 = 0;
LABEL_206:
              uint64_t v93 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              uint64_t v94 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
              if ((v19 & 1) != 0) {
                goto LABEL_222;
              }
              goto LABEL_207;
            }
          }
        }
      }

      uint64_t v59 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
      uint64_t v72 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
      if (__CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
        goto LABEL_151;
      }
    }

LABEL_200:
    uint64_t v18 = 0LL;
    goto LABEL_201;
  }

uint64_t CFStringGetRangeOfCharacterClusterAtIndex(__CFString *a1, int64_t a2, uint64_t a3)
{
  uint64_t v183 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  if (a3 == 1) {
    unsigned int v7 = 110;
  }
  else {
    unsigned int v7 = 8;
  }
  if (Length <= a2) {
    return -1LL;
  }
  int64_t v8 = Length;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)a1)
    || (char v9 = atomic_load((unint64_t *)&a1->info), (v9 & 0x10) != 0))
  {
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(v7, 0);
    uint64_t v11 = CFUniCharGetBitmapPtrForPlane(5u, 0);
    if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP) {
      CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    }
    CFStringRef theString = a1;
    uint64_t v179 = 0LL;
    int64_t v180 = v8;
    CharactersPtr = CFStringGetCharactersPtr(a1);
    uint64_t CStringPtrInternal = 0LL;
    int64_t v177 = (UniChar *)CharactersPtr;
    if (!CharactersPtr) {
      uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, 0x600u, 1, 1);
    }
    uint64_t v181 = 0LL;
    uint64_t v182 = 0LL;
    uint64_t v178 = CStringPtrInternal;
    uint64_t v14 = BitmapPtrForPlane;
    uint64_t ComposedRange = _CFStringInlineBufferGetComposedRange(buffer, a2, a3, BitmapPtrForPlane, v7);
    unint64_t v17 = ComposedRange;
    uint64_t v18 = v16;
    unsigned int v163 = v7;
    uint64_t v164 = a3;
    if (a3 > 2)
    {
      a2 = ComposedRange;
      goto LABEL_208;
    }

    uint64_t v160 = v16;
    if (ComposedRange < 0 || (int64_t v19 = v180, v180 <= ComposedRange))
    {
      LOWORD(v23) = 0;
      uint64_t v24 = v11;
      goto LABEL_22;
    }

    int64_t v20 = v177;
    if (v177)
    {
      unint64_t v21 = v179 + ComposedRange;
    }

    else
    {
      if (v178)
      {
        UniChar v22 = *(char *)(v178 + v179 + ComposedRange);
        goto LABEL_27;
      }

      if (v182 <= ComposedRange || (uint64_t v133 = v181, v181 > ComposedRange))
      {
        uint64_t v134 = ComposedRange - 4;
        if (v134 + 64 < v180) {
          int64_t v19 = v134 + 64;
        }
        uint64_t v181 = v134;
        uint64_t v182 = v19;
        v193.CFIndex location = v179 + v134;
        v193.CFIndex length = v19 - v134;
        CFStringGetCharacters(theString, v193, buffer);
        uint64_t v133 = v181;
      }

      unint64_t v21 = v17 - v133;
      int64_t v20 = buffer;
    }

    UniChar v22 = v20[v21];
LABEL_27:
    unsigned int v23 = v22;
    if (v18 < 2 || (v22 & 0xFC00) != 0xD800 || (int64_t v25 = v17 + 1, v26 = v180, v180 <= (uint64_t)(v17 + 1)))
    {
      uint64_t v24 = v11;
      goto LABEL_34;
    }

    CFIndex v27 = v177;
    if (v177)
    {
      int64_t v28 = v179 + v25;
    }

    else
    {
      if (v178)
      {
        UniChar v29 = *(char *)(v178 + v179 + v25);
LABEL_286:
        uint64_t v24 = v11;
        if (v29 >> 10 == 55)
        {
          unsigned int v23 = (v23 << 10) + v29 - 56613888;
          uint64_t v24 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v23));
        }

LABEL_252:
                uint64_t v121 = v164;
                if ((a2 & 0x8000000000000000LL) == 0 && a2 < v8)
                {
                  uint64_t v122 = v18;
                  UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, a2, &v173);
                  uint64_t v124 = 0LL;
                  int64_t v125 = v174;
                  while (LongCharacterFromInlineBuffer == 8205
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER)
                       || u_getIntPropertyValue(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_CLUSTER_BREAK) == 10)
                  {
                    int64_t v125 = v173;
                    if (!v173) {
                      goto LABEL_331;
                    }
                    v124 += v174;
                    if (v124 >= 64) {
                      goto LABEL_331;
                    }
                    UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer( buffer,  v8,  v173 - 1,  &v173);
                  }

                  __int128 v169 = xmmword_180C33AB0;
                  uint64_t v170 = -1LL;
                  uint64_t v171 = -1LL;
                  uint64_t v172 = -1LL;
                  int64_t v126 = v173;
                  uint64_t v127 = 0LL;
                  if (__CFStringGetExtendedPictographicSequenceComponent( buffer,  v8,  v173,  (uint64_t *)&v169))
                  {
                    do
                    {
                      int64_t v126 = v169;
                      v127 += *((void *)&v169 + 1);
                      int64_t v173 = v169 - 1;
                      int64_t v174 = 0LL;
                    }

                    while (v171 != -1
                         && __CFStringGetExtendedPictographicSequenceComponent( buffer,  v8,  v169 - 1,  (uint64_t *)&v169));
                  }

                  if (v170 == -1 && v171 == -1)
                  {
                    BOOL v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
                      int64_t v165 = v173;
                      UChar32 v135 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v173, &v173);
                      if (u_getIntPropertyValue(v135, UCHAR_GRAPHEME_CLUSTER_BREAK) == 11)
                      {
                        int64_t v130 = v173;
                        uint64_t v129 = v174;
                      }

                      else
                      {
                        uint64_t v129 = 0LL;
                        int64_t v130 = v165;
                      }

                      BOOL v131 = v124 > 0;
                      goto LABEL_298;
                    }
                  }

                  else
                  {
                    uint64_t v129 = 0LL;
                    int64_t v126 = v172;
                    v127 += v169 - v172;
                    int64_t v130 = v172 + 1;
                    BOOL v131 = v124 > 0;
                    BOOL v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
LABEL_298:
                      if (v129 || !v132)
                      {
                        BOOL v168 = v131;
                        int64_t v166 = v130;
                        uint64_t v162 = v129;
                        int64_t v138 = v129 + v130;
                        BOOL v139 = !v132;
                        if (v132) {
                          int64_t v140 = v138;
                        }
                        else {
                          int64_t v140 = v127 + v126;
                        }
                        if (v132) {
                          int64_t v141 = v138;
                        }
                        else {
                          int64_t v141 = v126;
                        }
                        if (!v139) {
                          uint64_t v127 = 0LL;
                        }
                        int64_t v173 = v140;
                        int64_t v174 = 0LL;
                        if (__CFStringGetExtendedPictographicSequenceComponent( buffer,  v8,  v140,  (uint64_t *)&v169))
                        {
                          do
                          {
                            if (v127 >= 1 && v171 == -1) {
                              break;
                            }
                            v127 += *((void *)&v169 + 1);
                            v173 += *((void *)&v169 + 1);
                          }

                          while ((__CFStringGetExtendedPictographicSequenceComponent( buffer,  v8,  v173,  (uint64_t *)&v169) & 1) != 0);
                        }

                        int64_t v159 = v141;
                        if (v168)
                        {
                          int64_t v142 = v127 + v141;
                          if (v127 + v141 >= v124 + v125)
                          {
                            uint64_t v143 = 0LL;
                          }

                          else
                          {
                            int64_t v142 = v125;
                            uint64_t v143 = v124;
                          }

                          int64_t v144 = v142 + v143;
                          int64_t v173 = v142 + v143;
                          int64_t v174 = 0LL;
                        }

                        else
                        {
                          int64_t v144 = v173;
                          uint64_t v143 = v174;
                        }

                        if (v144 < v8)
                        {
                          UChar32 v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v144, &v173);
                          do
                          {
                            if (v145 != 8205
                              && !u_hasBinaryProperty(v145, UCHAR_GRAPHEME_EXTEND)
                              && !u_hasBinaryProperty(v145, UCHAR_EMOJI_MODIFIER)
                              && u_getIntPropertyValue(v145, UCHAR_GRAPHEME_CLUSTER_BREAK) != 10)
                            {
                              break;
                            }

                            v143 += v174;
                            v173 += v174;
                            UChar32 v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v173, &v173);
                          }

                          while (v143 < 64);
                        }

                        int64_t v146 = v166;
                        if (v127 >= 1)
                        {
                          if (v162 <= 0) {
                            int64_t v146 = v159;
                          }
                          if (a2 >= v146 && v122 + a2 <= v127 + (v162 & ~(v162 >> 63)) + (v143 & ~(v143 >> 63)) + v146)
                          {
                            a2 = v146;
                            uint64_t v18 = v127 + (v162 & ~(v162 >> 63)) + (v143 & ~(v143 >> 63));
                          }

                          else
                          {
                            uint64_t v18 = v122;
                          }

                          goto LABEL_332;
                        }
                      }
                    }
                  }

LABEL_331:
                  uint64_t v18 = v122;
                }

LABEL_332:
                if (a2 >= 1 && v18 == 1)
                {
                  int64_t v147 = v180;
                  if (v180 <= a2) {
                    goto LABEL_342;
                  }
                  uint64_t v148 = v177;
                  if (v177)
                  {
                    int64_t v149 = v179 + a2;
                    goto LABEL_337;
                  }

                  if (v178) {
                    goto LABEL_342;
                  }
                  if (v182 <= a2 || (uint64_t v155 = v181, v181 > a2))
                  {
                    int64_t v156 = a2 - 4;
                    if (v156 + 64 < v180) {
                      int64_t v147 = v156 + 64;
                    }
                    uint64_t v181 = v156;
                    uint64_t v182 = v147;
                    v196.CFIndex location = v179 + v156;
                    v196.CFIndex length = v147 - v156;
                    CFStringGetCharacters(theString, v196, buffer);
                    uint64_t v155 = v181;
                  }

                  int64_t v149 = a2 - v155;
                  uint64_t v148 = buffer;
LABEL_337:
                  if (v148[v149] != 8205)
                  {
LABEL_342:
                    uint64_t v18 = 1LL;
                  }

                  else
                  {
                    uint64_t v150 = _CFStringInlineBufferGetComposedRange(buffer, a2 - 1, v121, v14, v163);
                    if (a2 == v150 + v151)
                    {
                      a2 = v150;
                      uint64_t v18 = v151 + 1;
                    }

                    else
                    {
                      uint64_t v18 = 1LL;
                    }
                  }
                }

                int64_t v152 = v18 + a2;
                if (v18 + a2 < v8 && (v152 & 0x8000000000000000LL) == 0)
                {
                  int64_t v153 = v180;
                  if (v180 > v152 && !v177 && !v178 && (v182 <= v152 || v181 > v152))
                  {
                    int64_t v154 = v152 - 4;
                    if (v154 + 64 < v180) {
                      int64_t v153 = v154 + 64;
                    }
                    uint64_t v181 = v154;
                    uint64_t v182 = v153;
                    v195.CFIndex location = v179 + v154;
                    v195.CFIndex length = v153 - v154;
                    CFStringGetCharacters(theString, v195, buffer);
                  }
                }

                return a2;
              }

              while (2)
              {
                int64_t v66 = v64 - 1;
                if (v64 < 1 || (int64_t v67 = v180, v180 < v64))
                {
                  LOWORD(v6_Block_object_dispose(va, 8) = 0;
                  goto LABEL_129;
                }

                if (v177)
                {
                  uint64_t v69 = &v177[v179 + v66];
                }

                else
                {
                  if (v178)
                  {
                    LOWORD(v6_Block_object_dispose(va, 8) = *(char *)(v178 + v179 + v66);
                    goto LABEL_129;
                  }

                  if (v182 < v64 || (uint64_t v83 = v181, v181 >= v64))
                  {
                    int64_t v84 = v64 - 5;
                    if (v84 + 64 < v180) {
                      int64_t v67 = v84 + 64;
                    }
                    uint64_t v181 = v84;
                    uint64_t v182 = v67;
                    v189.CFIndex location = v179 + v84;
                    v189.CFIndex length = v67 - v84;
                    CFStringGetCharacters(theString, v189, buffer);
                    uint64_t v83 = v181;
                  }

                  uint64_t v69 = &buffer[v66 - v83];
                }

                int v68 = *v69;
                if (v68 != 847 && v68 != 8205)
                {
LABEL_129:
                  if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                    || !*(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                 + ((unint64_t)(unsigned __int16)v68 >> 8))
                    || *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                                      + ((unint64_t)(unsigned __int16)v68 >> 8)) << 8)
                                - 256
                                + v68
                                + 256) != 9
                    || (unsigned __int16)v68 == 3021 && !_CFStringIsJoiningPulliAtIndex(buffer, v64 - 1, 0LL, v8))
                  {
LABEL_206:
                    uint64_t v18 = v64 - a2;
                    goto LABEL_207;
                  }

                  if (v64 < 0)
                  {
LABEL_150:
                    LOWORD(v76) = 0;
                    goto LABEL_183;
                  }
                }

                int64_t v71 = v180;
                if (v180 <= v64) {
                  goto LABEL_150;
                }
                if (v177)
                {
                  uint64_t v72 = &v177[v179 + v64];
                  goto LABEL_146;
                }

                if (v178)
                {
                  LOWORD(v73) = *(char *)(v178 + v179 + v64);
                  goto LABEL_153;
                }

                if (v182 <= v64 || (uint64_t v81 = v181, v181 > v64))
                {
                  int64_t v82 = v64 - 4;
                  if (v82 + 64 < v180) {
                    int64_t v71 = v82 + 64;
                  }
                  uint64_t v181 = v82;
                  uint64_t v182 = v71;
                  v188.CFIndex location = v179 + v82;
                  v188.CFIndex length = v71 - v82;
                  CFStringGetCharacters(theString, v188, buffer);
                  uint64_t v81 = v181;
                }

                uint64_t v72 = &buffer[v64 - v81];
LABEL_146:
                int v73 = *v72;
                if (v73 != 8205)
                {
LABEL_153:
                  int64_t v74 = v64;
                  goto LABEL_154;
                }

                int64_t v74 = v64 + 1;
                int64_t v75 = v180;
                if (v180 <= v64 + 1)
                {
                  LOWORD(v76) = 0;
                  goto LABEL_182;
                }

                if (v177)
                {
                  LOWORD(v73) = v177[v179 + v74];
                }

                else if (v178)
                {
                  LOWORD(v73) = *(char *)(v178 + v179 + v74);
                }

                else
                {
                  if (v182 <= v74 || (uint64_t v89 = v181, v181 > v74))
                  {
                    int64_t v90 = v64 - 3;
                    if (v90 + 64 < v180) {
                      int64_t v75 = v90 + 64;
                    }
                    uint64_t v181 = v90;
                    uint64_t v182 = v75;
                    v191.CFIndex location = v179 + v90;
                    v191.CFIndex length = v75 - v90;
                    CFStringGetCharacters(theString, v191, buffer);
                    uint64_t v89 = v181;
                  }

                  LOWORD(v73) = buffer[v74 - v89];
                }

LABEL_154:
                unsigned int v76 = (unsigned __int16)v73;
                if ((unsigned __int16)v73 >> 10 == 54)
                {
                  int64_t v77 = v74 + 1;
                  int64_t v78 = v180;
                  if (v180 > v74 + 1)
                  {
                    if (v177)
                    {
                      UniChar v79 = v177[v179 + v77];
                    }

                    else if (v178)
                    {
                      UniChar v79 = *(char *)(v178 + v179 + v77);
                    }

                    else
                    {
                      if (v182 <= v77 || (uint64_t v87 = v181, v181 > v77))
                      {
                        int64_t v88 = v74 - 3;
                        if (v88 + 64 < v180) {
                          int64_t v78 = v88 + 64;
                        }
                        uint64_t v181 = v88;
                        uint64_t v182 = v78;
                        v190.CFIndex location = v179 + v88;
                        v190.CFIndex length = v78 - v88;
                        CFStringGetCharacters(theString, v190, buffer);
                        uint64_t v87 = v181;
                      }

                      UniChar v79 = buffer[v77 - v87];
                    }

                    if (v79 >> 10 == 55)
                    {
                      unsigned int v76 = (v76 << 10) + v79 - 56613888;
                      uint64_t v80 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v76));
                      int64_t v64 = v74;
                      goto LABEL_184;
                    }

                    goto LABEL_182;
                  }

                  int64_t v64 = v74;
                  uint64_t v80 = v11;
                }

                else
                {
LABEL_182:
                  int64_t v64 = v74;
LABEL_183:
                  uint64_t v80 = v11;
                }

            v23 += v61;
          }

          while (v23 < Length);
        }
      }
    }
  }

LABEL_184:
                if (!v80) {
                  goto LABEL_206;
                }
                uint64_t v85 = _CFStringInlineBufferGetComposedRange(buffer, v64, v164, BitmapPtrForPlane, v7);
                int64_t v64 = v85 + v86;
                if (v85 + v86 >= v8) {
                  goto LABEL_206;
                }
                continue;
              }
            }

            int64_t v32 = v30 - 1;
            int64_t v33 = v180;
            if (v180 >= a2)
            {
              uint64_t v35 = v177;
              if (v177)
              {
                int64_t v36 = v179 + v32;
              }

              else
              {
                if (v178)
                {
                  LOWORD(v34) = *(char *)(v178 + v179 + v32);
                  goto LABEL_47;
                }

                if (v182 < a2 || (uint64_t v56 = v181, v181 >= a2))
                {
                  int64_t v57 = a2 - 5;
                  if (v57 + 64 < v180) {
                    int64_t v33 = v57 + 64;
                  }
                  uint64_t v181 = v57;
                  uint64_t v182 = v33;
                  v184.CFIndex location = v179 + v57;
                  v184.CFIndex length = v33 - v57;
                  CFStringGetCharacters(theString, v184, buffer);
                  uint64_t v56 = v181;
                }

                int64_t v36 = v32 - v56;
                uint64_t v35 = buffer;
              }

              int v34 = v35[v36];
              if (v34 == 847) {
                goto LABEL_67;
              }
              if (v34 == 3021)
              {
                if (!_CFStringIsJoiningPulliAtIndex(buffer, a2 - 1, 0LL, v8)) {
                  goto LABEL_121;
                }
                LOWORD(v34) = 3021;
              }
            }

            else
            {
              LOWORD(v34) = 0;
            }

CFComparisonResult CFStringCompareWithOptions( CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return CFStringCompareWithOptionsAndLocale(theString1, theString2, rangeToCompare, compareOptions, 0LL);
}

CFComparisonResult CFStringCompare( CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  v7.CFIndex length = CFStringGetLength(theString1);
  v7.CFIndex location = 0LL;
  return CFStringCompareWithOptionsAndLocale(theString1, theString2, v7, compareOptions, 0LL);
}

Boolean CFStringFindWithOptionsAndLocale( CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  CFIndex length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v509 = *MEMORY[0x1895F89C0];
  CFIndex v13 = CFStringGetLength(stringToFind);
  int v14 = __CFStringFillCharacterSetInlineBuffer((uint64_t)&theSet, searchOptions);
  LOBYTE(v15) = 0;
  if (v14) {
    p_CFCharacterSetRef theSet = &theSet;
  }
  else {
    p_CFCharacterSetRef theSet = 0LL;
  }
  int v433 = p_theSet;
  if ((searchOptions & 0x91) != 0) {
    int v17 = 1;
  }
  else {
    int v17 = v14;
  }
  else {
    int v18 = v17;
  }
  if (v13 < 1 || length < 1 || !v18) {
    return v15;
  }
  CFStringRef theStringa = (__CFString *)theString;
  int v465 = v14;
  unsigned int v19 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    unsigned int v19 = __CFDefaultEightBitStringEncoding;
  }

  uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)theStringa, v19, 0, 1);
  uint64_t v423 = (__CFString *)stringToFind;
  uint64_t v460 = _CFStringGetCStringPtrInternal((unint64_t *)stringToFind, v19, 0, 1);
  *(void *)v422 = location;
  uint64_t v20 = location + length;
  if (locale)
  {
    uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale( locale,  1);
  }

  else if ((searchOptions & 0x20) != 0)
  {
    unint64_t v21 = CFLocaleCopyCurrent();
    uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale( v21,  1);
    CFRelease(v21);
  }

  else
  {
    uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = 0LL;
  }

  CFStringRef v500 = theStringa;
  uint64_t v503 = 0LL;
  int64_t v504 = location + length;
  CharactersPtr = CFStringGetCharactersPtr(theStringa);
  uint64_t v23 = 0LL;
  v501 = (UniChar *)CharactersPtr;
  if (!CharactersPtr) {
    uint64_t v23 = _CFStringGetCStringPtrInternal((unint64_t *)theStringa, 0x600u, 0, 1);
  }
  int64_t v506 = 0LL;
  uint64_t v502 = v23;
  int64_t v505 = 0LL;
  *(void *)&__int128 v494 = v423;
  *((void *)&v495 + 1) = 0LL;
  range_8.CFIndex location = v13;
  uint64_t v24 = CFStringGetCharactersPtr(v423);
  uint64_t v25 = 0LL;
  *((void *)&v494 + 1) = v24;
  if (!v24) {
    uint64_t v25 = _CFStringGetCStringPtrInternal((unint64_t *)v423, 0x600u, 0, 1);
  }
  CFStringCompareFlags v455 = searchOptions & 1;
  CFIndex v497 = 0LL;
  *(void *)&__int128 v495 = v25;
  range_8.CFIndex length = 0LL;
  v421 = result;
  if (v17) {
    uint64_t v26 = 1LL;
  }
  else {
    uint64_t v26 = v13;
  }
  if ((searchOptions & 4) != 0)
  {
    int64_t v28 = v20 - v26;
    if ((searchOptions & 8) != 0) {
      int v30 = v17;
    }
    else {
      int v30 = 1;
    }
    if (v30) {
      CFIndex v29 = location;
    }
    else {
      CFIndex v29 = v28;
    }
  }

  else
  {
    CFIndex v27 = v20 - v26;
    int64_t v28 = location;
    if ((searchOptions & 8) != 0) {
      CFIndex v29 = location;
    }
    else {
      CFIndex v29 = v27;
    }
  }

  int v31 = v465;
  int v459 = (searchOptions >> 8) & 1 | v17;
  CFStringCompareFlags v436 = searchOptions & 0xC;
  CFIndex v432 = v29;
  if (v28 > v29) {
    char v32 = -1;
  }
  else {
    char v32 = 1;
  }
  int64_t v462 = location + length;
  CFIndex v454 = v13;
  __int16 v446 = searchOptions;
  if (!CStringPtrInternal || !v460)
  {
    if (!((searchOptions >> 8) & 1 | v17 & 1))
    {
      for (i = v32; ; int64_t v28 = v163 + i)
      {
        uint64_t v162 = 0LL;
        CFIndex v163 = v28;
        while (1)
        {
          if (v28 < 0 || (int64_t v164 = v504, v504 <= v28))
          {
            UniChar v165 = 0;
          }

          else if (v501)
          {
            UniChar v165 = v501[v503 + v28];
          }

          else if (v502)
          {
            UniChar v165 = *(char *)(v502 + v503 + v28);
          }

          else
          {
            if (v506 <= v28 || (int64_t v170 = v505, v505 > v28))
            {
              int64_t v171 = v28 - 4;
              if (v171 + 64 < v504) {
                int64_t v164 = v171 + 64;
              }
              int64_t v505 = v171;
              int64_t v506 = v164;
              v517.CFIndex location = v503 + v171;
              v517.CFIndex length = v164 - v171;
              CFStringGetCharacters(v500, v517, &buffer);
              int64_t v170 = v505;
            }

            UniChar v165 = *(_WORD *)&v499[2 * (v28 - v170) - 2];
          }

          CFIndex v166 = range_8.location;
          if (range_8.location <= v162)
          {
            UniChar v167 = 0;
          }

          else if (*((void *)&v494 + 1))
          {
            UniChar v167 = *(_WORD *)(*((void *)&v494 + 1) + 2 * (*((void *)&v495 + 1) + v162));
          }

          else if ((void)v495)
          {
            UniChar v167 = *(char *)(v495 + *((void *)&v495 + 1) + v162);
          }

          else
          {
            if (v497 <= v162 || (CFIndex v168 = range_8.length, range_8.length > v162))
            {
              CFIndex v169 = v162 - 4;
              if (v169 + 64 < range_8.location) {
                CFIndex v166 = v169 + 64;
              }
              range_8.CFIndex length = v169;
              CFIndex v497 = v166;
              v516.CFIndex location = *((void *)&v495 + 1) + v169;
              v516.CFIndex length = v166 - v169;
              CFStringGetCharacters((CFStringRef)v494, v516, v486);
              CFIndex v168 = range_8.length;
            }

            UniChar v167 = v486[v162 - v168];
          }

          if (v165 != v167) {
            break;
          }
          ++v28;
          if (++v162 == v13) {
            goto LABEL_424;
          }
        }

        if (v162 == v13)
        {
LABEL_424:
          if (v421)
          {
            v421->CFIndex location = v163;
            v421->CFIndex length = v13;
          }

          goto LABEL_432;
        }

        if (v163 == v432) {
          goto LABEL_1112;
        }
      }
    }

    int64_t v445 = v28;
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
    uint64_t UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    uint64_t v415 = UnicodePropertyDataForPlane;
    if ((searchOptions & 0x10000) != 0) {
      goto LABEL_528;
    }
    __int128 v483 = v495;
    CFRange v484 = range_8;
    __int128 v478 = v490;
    __int128 v479 = v491;
    __int128 v480 = v492;
    CFIndex v485 = v497;
    __int128 v481 = v493;
    __int128 v482 = v494;
    *(_OWORD *)int v474 = *(_OWORD *)v486;
    __int128 v475 = v487;
    __int128 v476 = v488;
    __int128 v477 = v489;
    if (CF_IS_OBJC(7uLL, (__objc2_class **)theStringa))
    {
      if (-[__CFString _encodingCantBeStoredInEightBitCFString]( theStringa,  "_encodingCantBeStoredInEightBitCFString")) {
        goto LABEL_438;
      }
    }

    else
    {
      unsigned int v172 = atomic_load((unint64_t *)&theStringa->info);
      if (((v172 >> 4) & 1) != 0) {
        goto LABEL_438;
      }
    }

    if (CF_IS_OBJC(7uLL, (__objc2_class **)v423))
    {
      int v173 = -[__CFString _encodingCantBeStoredInEightBitCFString](v423, "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v174 = atomic_load((unint64_t *)&v423->info);
      int v173 = (v174 >> 4) & 1;
    }

    if (!v173) {
      goto LABEL_528;
    }
LABEL_438:
    uint64_t v175 = 0LL;
    uint64_t v176 = 0LL;
    int v473 = 0;
    uint64_t v177 = 64LL;
    while (1)
    {
      else {
        uint64_t v178 = v176;
      }
      uint64_t v179 = v484.location;
      if (v484.location <= v176)
      {
        UniChar v180 = 0;
      }

      else if (*((void *)&v482 + 1))
      {
        UniChar v180 = *(_WORD *)(*((void *)&v482 + 1) + 2 * (v176 + *((void *)&v483 + 1)));
      }

      else if ((void)v483)
      {
        UniChar v180 = *(char *)(v483 + *((void *)&v483 + 1) + v176);
      }

      else
      {
        CFIndex v182 = v484.length;
        if (v485 <= v176 || v484.length > v176)
        {
          uint64_t v184 = v178 + v175;
          uint64_t v185 = v177 - v178;
          uint64_t v186 = v176 - v178;
          uint64_t v187 = v186 + 64;
          if (v186 + 64 >= v484.location) {
            uint64_t v187 = v484.location;
          }
          v484.CFIndex length = v186;
          CFIndex v485 = v187;
          if (v484.location >= v185) {
            uint64_t v179 = v185;
          }
          v518.CFIndex length = v179 + v184;
          v518.CFIndex location = v186 + *((void *)&v483 + 1);
          CFStringGetCharacters((CFStringRef)v482, v518, v474);
          CFIndex v182 = v484.length;
        }

        UniChar v180 = v474[v176 - v182];
      }

      if (u_isdigit(v180)) {
        goto LABEL_465;
      }
      unsigned int Script = uscript_getScript();
      if (v473 > 0) {
        goto LABEL_470;
      }
      if (Script) {
        break;
      }
      ++v176;
      --v175;
      ++v177;
      if (v13 == v176) {
        goto LABEL_470;
      }
    }

    if (Script > 0xF || ((1 << Script) & 0x8410) == 0)
    {
LABEL_470:
      uint64_t v20 = location + length;
      goto LABEL_527;
    }

LABEL_465:
    *(_DWORD *)int v474 = 0;
    uint64_t v188 = length << 32;
    if ((searchOptions & 4) != 0)
    {
      if ((v432 & 0x8000000000000000LL) == 0)
      {
        int64_t v192 = v432 + (int)length;
        int64_t v193 = v504;
        uint64_t v20 = location + length;
        if (v192 <= v504)
        {
          if (v501)
          {
            CFRange v191 = &v501[v503 + v432];
            goto LABEL_504;
          }

          if (v188 <= 0x4000000000LL)
          {
            if (v192 > v506 || v432 < v505)
            {
              if (v432 + 64 < v504) {
                int64_t v193 = v432 + 64;
              }
              int64_t v505 = v432;
              int64_t v506 = v193;
              v200.CFIndex location = v503 + v432;
              v200.CFIndex length = v193 - v432;
              if (v502)
              {
                if (v200.length)
                {
                  int64_t v201 = (char *)(v502 + v200.location);
                  CFIndex v202 = v432 - v193;
                  p_UniChar buffer = &buffer;
                  do
                  {
                    UniChar v204 = *v201++;
                    *p_buffer++ = v204;
                    BOOL v199 = __CFADD__(v202++, 1LL);
                  }

                  while (!v199);
                }
              }

              else
              {
                CFStringGetCharacters(v500, v200, &buffer);
              }
            }

            int64_t v205 = v432 - v505;
            goto LABEL_503;
          }
        }

LABEL_473:
        CFRange v191 = 0LL;
        goto LABEL_504;
      }
    }

    else if ((v445 & 0x8000000000000000LL) == 0)
    {
      int64_t v189 = v445 + (int)length;
      int64_t v190 = v504;
      uint64_t v20 = location + length;
      if (v189 <= v504)
      {
        if (v501)
        {
          CFRange v191 = &v501[v503 + v445];
          goto LABEL_504;
        }

        if (v188 <= 0x4000000000LL)
        {
          if (v189 > v506 || v445 < v505)
          {
            if (v445 + 64 < v504) {
              int64_t v190 = v445 + 64;
            }
            int64_t v505 = v445;
            int64_t v506 = v190;
            v194.CFIndex location = v503 + v445;
            v194.CFIndex length = v190 - v445;
            if (v502)
            {
              if (v194.length)
              {
                CFRange v195 = (char *)(v502 + v194.location);
                int64_t v196 = v445 - v190;
                unsigned int v197 = &buffer;
                do
                {
                  UniChar v198 = *v195++;
                  *v197++ = v198;
                  BOOL v199 = __CFADD__(v196++, 1LL);
                }

                while (!v199);
              }
            }

            else
            {
              CFStringGetCharacters(v500, v194, &buffer);
            }
          }

          int64_t v205 = v445 - v505;
LABEL_503:
          CFRange v191 = (UniChar *)&v499[2 * v205 - 2];
LABEL_504:
          if ((int)v13 <= range_8.location)
          {
            if (*((void *)&v494 + 1)) {
              goto LABEL_518;
            }
            if (v13 << 32 <= 0x4000000000LL)
            {
              if ((int)v13 > v497 || range_8.length >= 1)
              {
                if (range_8.location >= 64) {
                  v206.CFIndex length = 64LL;
                }
                else {
                  v206.CFIndex length = range_8.location;
                }
                range_8.CFIndex length = 0LL;
                CFIndex v497 = v206.length;
                v206.CFIndex location = *((void *)&v495 + 1);
                if ((void)v495)
                {
                  if (v206.length)
                  {
                    unsigned __int8 v207 = (char *)(v495 + *((void *)&v495 + 1));
                    int64_t v208 = v486;
                    do
                    {
                      UniChar v209 = *v207++;
                      *v208++ = v209;
                      --v206.length;
                    }

                    while (v206.length);
                  }
                }

                else
                {
                  CFStringGetCharacters((CFStringRef)v494, v206, v486);
                }
              }

LABEL_518:
              if (v191)
              {
                ucol_open();
                if (*(int *)v474 <= 0)
                {
                  ucol_setStrength();
                  usearch_openFromCollator();
                  if (*(int *)v474 <= 0)
                  {
                    if ((searchOptions & 4) != 0) {
                      unsigned int v210 = usearch_last();
                    }
                    else {
                      unsigned int v210 = usearch_first();
                    }
                    unsigned int v211 = v210;
                    if (*(int *)v474 < 1)
                    {
                      if ((v210 & 0x80000000) != 0)
                      {
                        LOBYTE(v15) = 0;
                      }

                      else
                      {
                        MatchedCFIndex Length = usearch_getMatchedLength();
                        if ((searchOptions & 8) != 0)
                        {
                          if ((searchOptions & 4) != 0) {
                            BOOL v15 = MatchedLength + v211 == length;
                          }
                          else {
                            BOOL v15 = v211 == 0;
                          }
                        }

                        else
                        {
                          BOOL v15 = 1;
                        }

                        if (v421 && v15)
                        {
                          v421->CFIndex location = location + v211;
                          v421->CFIndex length = MatchedLength;
                          LOBYTE(v15) = 1;
                        }
                      }

                      usearch_close();
                      ucol_close();
                      return v15;
                    }

                    usearch_close();
                  }

                  ucol_close();
                }
              }
            }
          }

LABEL_527:
          uint64_t UnicodePropertyDataForPlane = v415;
LABEL_528:
          uint64_t v212 = 0LL;
          uint64_t v213 = 0LL;
          uint64_t v418 = 0LL;
          uint64_t v419 = 0LL;
          uint64_t v416 = 0LL;
          BOOL v214 = v436 == 8;
          BOOL v216 = (searchOptions & 1) != 0 && SpecialCaseHandlingLanguageIdentifierForLocale != 0LL;
          uint64_t v217 = (uint64_t)&v469;
          int v218 = v465;
          if (!v465) {
            uint64_t v217 = 8LL;
          }
          int v424 = (int *)v217;
          uint64_t v219 = (uint64_t)&v470;
          if (!v465) {
            uint64_t v219 = 12LL;
          }
          uint64_t v434 = 0LL;
          int v435 = (UTF32Char *)v219;
          if (v465) {
            uint64_t v220 = (uint64_t)&v471;
          }
          else {
            uint64_t v220 = 16LL;
          }
          uint64_t v221 = (uint64_t)&v472;
          if (!v465) {
            uint64_t v221 = 24LL;
          }
          v417 = (uint64_t *)v221;
          uint64_t v420 = searchOptions & 0x90;
          uint64_t v414 = UnicodePropertyDataForPlane + 256;
          int v426 = (UTF32Char *)v220;
          uint64_t v427 = v32;
          CFIndex v222 = v445;
          BOOL v458 = v216;
          while (1)
          {
            uint64_t v223 = 0LL;
            uint64_t v224 = 0LL;
            uint64_t v225 = 0LL;
            uint64_t v443 = 0LL;
            uint64_t v429 = 0LL;
            uint64_t v430 = 0LL;
            uint64_t v428 = 0LL;
            uint64_t v226 = v222;
            CFIndex v461 = v222;
            while (1)
            {
              uint64_t v438 = v226;
              uint64_t v439 = v223;
              uint64_t v437 = v224;
              uint64_t v227 = v225;
              uint64_t v441 = v225;
              while (1)
              {
                uint64_t v228 = v223 - 4;
                CFIndex v449 = v228;
                uint64_t v448 = v228 + 64;
                uint64_t v229 = v223 + 1;
                uint64_t v230 = v223 - 3;
                CFIndex v453 = v230;
                uint64_t v451 = v230 + 64;
                if (v227 <= 0) {
                  uint64_t v231 = 0LL;
                }
                else {
                  uint64_t v231 = -1LL;
                }
                uint64_t v464 = v227;
                if (v224)
                {
LABEL_554:
                  UTF32Char v232 = __s1[v212++];
                  if (!v227) {
                    goto LABEL_563;
                  }
LABEL_555:
                  UTF32Char v233 = __s2[v213++];
                  goto LABEL_570;
                }

                while (1)
                {
                  if (v226 < 0 || (uint64_t v234 = v504, v504 <= v226))
                  {
                    UTF32Char v232 = 0;
                    goto LABEL_562;
                  }

                  BOOL v235 = v501;
                  if (v501)
                  {
                    uint64_t v236 = v503 + v226;
                  }

                  else
                  {
                    if (v502)
                    {
                      UniChar v237 = *(char *)(v502 + v503 + v226);
                      goto LABEL_631;
                    }

                    if (v506 <= v226 || (int64_t v270 = v505, v505 > v226))
                    {
                      uint64_t v271 = v226 - 4;
                      if (v271 + 64 < v504) {
                        uint64_t v234 = v271 + 64;
                      }
                      int64_t v505 = v271;
                      int64_t v506 = v234;
                      v521.CFIndex location = v503 + v271;
                      v521.CFIndex length = v234 - v271;
                      CFStringGetCharacters(v500, v521, &buffer);
                      uint64_t v227 = v464;
                      BOOL v216 = v458;
                      BOOL v214 = v436 == 8;
                      CFIndex v222 = v461;
                      int v218 = v465;
                      int64_t v270 = v505;
                    }

                    uint64_t v236 = v226 - v270;
                    BOOL v235 = &buffer;
                  }

                  UniChar v237 = v235[v236];
LABEL_631:
                  UTF32Char v232 = v237;
                  if (v455 && v237 >= 0x41u && v237 <= 0x5Au)
                  {
                    if (v237 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0LL) {
                      UTF32Char v232 = v237 + 32;
                    }
                    else {
                      UTF32Char v232 = 73;
                    }
                  }

LABEL_562:
                  uint64_t v467 = 1LL;
                  if (v227) {
                    goto LABEL_555;
                  }
LABEL_563:
                  if ((v223 & 0x8000000000000000LL) == 0)
                  {
                    CFIndex v238 = range_8.location;
                    if (range_8.location > v223)
                    {
                      uint64_t v239 = (UniChar *)*((void *)&v494 + 1);
                      if (*((void *)&v494 + 1))
                      {
                        uint64_t v240 = *((void *)&v495 + 1) + v223;
                        goto LABEL_567;
                      }

                      if ((void)v495)
                      {
                        UniChar v241 = *(char *)(v495 + *((void *)&v495 + 1) + v223);
                      }

                      else
                      {
                        if (v497 <= v223 || (CFIndex v272 = range_8.length, range_8.length > v223))
                        {
                          if (v448 < range_8.location) {
                            CFIndex v238 = v448;
                          }
                          range_8.CFIndex length = v449;
                          CFIndex v497 = v238;
                          v522.CFIndex location = *((void *)&v495 + 1) + v449;
                          v522.CFIndex length = v238 - v449;
                          CFStringGetCharacters((CFStringRef)v494, v522, v486);
                          uint64_t v227 = v464;
                          BOOL v216 = v458;
                          BOOL v214 = v436 == 8;
                          CFIndex v222 = v461;
                          int v218 = v465;
                          CFIndex v272 = range_8.length;
                        }

                        uint64_t v240 = v223 - v272;
                        uint64_t v239 = v486;
LABEL_567:
                        UniChar v241 = v239[v240];
                      }

                      UTF32Char v233 = v241;
                      if (v455 && v241 >= 0x41u && v241 <= 0x5Au)
                      {
                        if (v241 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0LL) {
                          UTF32Char v233 = v241 + 32;
                        }
                        else {
                          UTF32Char v233 = 73;
                        }
                      }

                      goto LABEL_569;
                    }
                  }

                  UTF32Char v233 = 0;
LABEL_569:
                  uint64_t v466 = 1LL;
LABEL_570:
                  if (v232 == v233)
                  {
                    uint64_t v225 = v227;
                    uint64_t v325 = v454;
                    goto LABEL_729;
                  }

                  if ((v233 | v232) > 0x7F) {
                    int v242 = 1;
                  }
                  else {
                    int v242 = v218;
                  }
                  if ((v242 | v216) != 1)
                  {
                    char v311 = 1;
                    goto LABEL_836;
                  }

                  if ((v232 & 0xFC00) == 0xD800 && v226 >= -1)
                  {
                    int64_t v243 = v226 + 1;
                    uint64_t v244 = v504;
                    if (v504 <= v226 + 1)
                    {
                      uint64_t v20 = v462;
                      goto LABEL_586;
                    }

                    uint64_t v245 = v501;
                    if (v501)
                    {
                      int64_t v246 = v503 + v243;
                      goto LABEL_580;
                    }

                    if (v502)
                    {
                      UniChar v247 = *(char *)(v502 + v503 + v243);
                    }

                    else
                    {
                      if (v506 <= v243 || (int64_t v268 = v505, v505 > v243))
                      {
                        uint64_t v269 = v226 - 3;
                        if (v269 + 64 < v504) {
                          uint64_t v244 = v269 + 64;
                        }
                        int64_t v505 = v269;
                        int64_t v506 = v244;
                        v520.CFIndex location = v503 + v269;
                        v520.CFIndex length = v244 - v269;
                        CFStringGetCharacters(v500, v520, &buffer);
                        uint64_t v227 = v464;
                        BOOL v216 = v458;
                        BOOL v214 = v436 == 8;
                        CFIndex v222 = v461;
                        int v218 = v465;
                        int64_t v268 = v505;
                      }

                      int64_t v246 = v243 - v268;
                      uint64_t v245 = &buffer;
LABEL_580:
                      UniChar v247 = v245[v246];
                    }

                    uint64_t v20 = v462;
                    if (v247 >> 10 == 55)
                    {
                      UTF32Char v232 = ((unsigned __int16)v232 << 10) - 56613888 + v247;
                      uint64_t v467 = 2LL;
                    }
                  }

LABEL_586:
                  if ((v233 & 0xFC00) != 0xD800) {
                    goto LABEL_596;
                  }
                  if (v223 < -1) {
                    goto LABEL_596;
                  }
                  CFIndex v248 = range_8.location;
                  if (range_8.location <= v229) {
                    goto LABEL_596;
                  }
                  uint64_t v249 = (UniChar *)*((void *)&v494 + 1);
                  if (*((void *)&v494 + 1))
                  {
                    uint64_t v250 = *((void *)&v495 + 1) + v229;
LABEL_591:
                    UniChar v251 = v249[v250];
                    goto LABEL_594;
                  }

                  if (!(void)v495)
                  {
                    if (v497 <= v229 || (CFIndex v264 = range_8.length, range_8.length > v229))
                    {
                      if (v451 < range_8.location) {
                        CFIndex v248 = v451;
                      }
                      range_8.CFIndex length = v453;
                      CFIndex v497 = v248;
                      v519.CFIndex location = *((void *)&v495 + 1) + v453;
                      v519.CFIndex length = v248 - v453;
                      CFStringGetCharacters((CFStringRef)v494, v519, v486);
                      uint64_t v227 = v464;
                      BOOL v216 = v458;
                      BOOL v214 = v436 == 8;
                      CFIndex v222 = v461;
                      int v218 = v465;
                      CFIndex v264 = range_8.length;
                    }

                    uint64_t v250 = v229 - v264;
                    uint64_t v249 = v486;
                    goto LABEL_591;
                  }

                  UniChar v251 = *(char *)(v495 + *((void *)&v495 + 1) + v229);
LABEL_594:
                  if (v251 >> 10 == 55)
                  {
                    UTF32Char v233 = ((unsigned __int16)v233 << 10) - 56613888 + v251;
                    uint64_t v466 = 2LL;
                  }

LABEL_596:
                  if (!v218)
                  {
                    uint64_t v289 = v438;
                    uint64_t v223 = v439;
                    goto LABEL_746;
                  }

                  int v252 = v226 != v222 || v214;
                  char v253 = v469;
                  if (v252 != 1 || v226 >= v20) {
                    goto LABEL_691;
                  }
                  unsigned int v254 = v469 & 4;
                  if (v470 > v232 || v471 <= v232)
                  {
                    if ((v469 & 4) == 0) {
                      goto LABEL_691;
                    }
                    goto LABEL_660;
                  }

                  if (HIWORD(v232) || (v469 & 2) != 0) {
                    break;
                  }
                  if (v472)
                  {
                    if ((v469 & 1) != 0)
                    {
                      unsigned int v260 = v254 >> 2;
                      uint64_t v261 = *(unsigned __int8 *)(v472 + ((unint64_t)v232 >> 8));
                      if (*(_BYTE *)(v472 + ((unint64_t)v232 >> 8)))
                      {
                        if ((_DWORD)v261 == 255)
                        {
                          unsigned int v260 = v254 == 0;
                        }

                        else
                        {
                          BOOL v265 = v254 == 0;
                          if ((((unint64_t)*(unsigned __int8 *)(v472
                                                                      + 32 * v261
                                                                      + (v232 >> 3)
                                                                      + 224) >> (v232 & 7)) & 1) != 0)
                            unsigned int v260 = v265;
                        }
                      }

                      if (!v260) {
                        goto LABEL_691;
                      }
                    }

                    else
                    {
                      BOOL v49 = v254 == 0;
                      BOOL v255 = v254 != 0;
                      char v256 = v49;
                      if (!v255) {
                        goto LABEL_691;
                      }
                    }
                  }

                  else
                  {
                    BOOL v49 = v254 == 0;
                    BOOL v258 = v254 != 0;
                    char v259 = v49;
                    if ((v469 & 1) == 0) {
                      BOOL v258 = v259;
                    }
                    if (!v258) {
                      goto LABEL_691;
                    }
                  }

LABEL_660:
                  if (v212 == v224 && v224 > 0) {
                    uint64_t v224 = 0LL;
                  }
                  uint64_t v267 = v467;
                  if (v224) {
                    uint64_t v267 = 0LL;
                  }
                  v226 += v267;
                  v213 += v231;
                  if (v224) {
                    goto LABEL_554;
                  }
                }

                int IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet, v232);
                uint64_t v227 = v464;
                BOOL v216 = v458;
                BOOL v214 = v436 == 8;
                CFIndex v222 = v461;
                int v218 = v465;
                if (IsLongCharacterMember) {
                  goto LABEL_660;
                }
                char v253 = v469;
LABEL_691:
                unsigned int v273 = v253 & 4;
                if (v470 > v233 || v471 <= v233)
                {
                  if ((v253 & 4) == 0) {
                    goto LABEL_809;
                  }
                  goto LABEL_719;
                }

                if (HIWORD(v233) || (v253 & 2) != 0)
                {
                  int v276 = CFCharacterSetIsLongCharacterMember(theSet, v233);
                  uint64_t v227 = v464;
                  BOOL v216 = v458;
                  BOOL v214 = v436 == 8;
                  CFIndex v222 = v461;
                  int v218 = v465;
                  if (!v276) {
                    goto LABEL_809;
                  }
                  goto LABEL_719;
                }

                if (!v472)
                {
                  BOOL v49 = v273 == 0;
                  BOOL v277 = v273 != 0;
                  char v278 = v49;
                  if ((v253 & 1) != 0) {
                    char v279 = v277;
                  }
                  else {
                    char v279 = v278;
                  }
                  if ((v279 & 1) == 0) {
                    goto LABEL_809;
                  }
                  goto LABEL_719;
                }

                if ((v253 & 1) != 0) {
                  break;
                }
                BOOL v274 = v273 != 0;
                BOOL v275 = v273 == 0;
                if (!v274) {
                  goto LABEL_809;
                }
LABEL_719:
                if (v213 == v227 && v227 > 0) {
                  uint64_t v227 = 0LL;
                }
                uint64_t v284 = v466;
                if (v227) {
                  uint64_t v284 = 0LL;
                }
                v223 += v284;
                v212 -= v224 > 0;
                if (v223 >= v454)
                {
                  uint64_t v325 = v454;
                  goto LABEL_869;
                }
              }

              unsigned int v280 = v273 >> 2;
              uint64_t v281 = *(unsigned __int8 *)(v472 + ((unint64_t)v233 >> 8));
              if (*(_BYTE *)(v472 + ((unint64_t)v233 >> 8)))
              {
                if ((_DWORD)v281 == 255)
                {
                  unsigned int v280 = v273 == 0;
                }

                else
                {
                  BOOL v282 = v273 == 0;
                }
              }

              if (v280) {
                goto LABEL_719;
              }
LABEL_809:
              uint64_t v441 = v227;
              uint64_t v289 = v226;
              uint64_t v437 = v224;
LABEL_746:
              uint64_t v325 = v454;
              __int16 v290 = v446;
              uint64_t v291 = v443;
              if ((v446 & 0x80) == 0 || v289 <= v222) {
                goto LABEL_772;
              }
              if (v224) {
                goto LABEL_749;
              }
              uint64_t v293 = BitmapPtrForPlane;
              if (v232 >= 0x10000)
              {
                uint64_t v293 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v232));
                __int16 v290 = v446;
                uint64_t v227 = v464;
                uint64_t v291 = v443;
                BOOL v216 = v458;
                BOOL v214 = v436 == 8;
                CFIndex v222 = v461;
                int v218 = v465;
              }

              if (!v293)
              {
LABEL_749:
                BOOL v292 = 0;
                if (!v227) {
                  goto LABEL_757;
                }
              }

              else
              {
                int v294 = 1 << (v232 & 7);
                uint64_t v291 = v443;
                BOOL v292 = (v294 & *(_BYTE *)(v293 + ((unsigned __int16)v232 >> 3))) != 0;
                if (!v227)
                {
LABEL_757:
                  uint64_t v295 = BitmapPtrForPlane;
                  if (v233 >= 0x10000)
                  {
                    __int16 v296 = v290;
                    uint64_t v295 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v233));
                    __int16 v290 = v296;
                    uint64_t v325 = v454;
                    uint64_t v227 = v464;
                    uint64_t v291 = v443;
                    BOOL v216 = v458;
                    BOOL v214 = v436 == 8;
                    CFIndex v222 = v461;
                    int v218 = v465;
                  }

                  if (v295)
                  {
                    int v297 = (1 << (v233 & 7)) & *(unsigned __int8 *)(v295 + ((unsigned __int16)v233 >> 3));
                    if (v297) {
                      UTF32Char v298 = v232;
                    }
                    else {
                      UTF32Char v298 = v233;
                    }
                    if (((v292 ^ (v297 != 0)) & 1) != 0)
                    {
                      uint64_t v299 = v466;
                      if (!v292) {
                        uint64_t v299 = 0LL;
                      }
                      v223 -= v299;
                      if (v297)
                      {
                        v289 -= v467;
                        UTF32Char v233 = v232;
                      }
                    }

                    else
                    {
                      UTF32Char v233 = v298;
                    }

LABEL_771:
                    uint64_t v291 = v443;
                    goto LABEL_772;
                  }
                }
              }

              if (v292)
              {
                v223 -= v466;
                goto LABEL_771;
              }

LABEL_772:
              if (v232 == v233)
              {
                uint64_t v300 = v434;
                uint64_t v224 = v437;
                goto LABEL_778;
              }

              if (v224)
              {
                BOOL v301 = 0;
                uint64_t v300 = v434;
                uint64_t v224 = v437;
                goto LABEL_776;
              }

              if (v418 && v418 != v289)
              {
                uint64_t v224 = 0LL;
                uint64_t v300 = v434;
                goto LABEL_828;
              }

              uint64_t v300 = v434;
              uint64_t v212 = v289 - v434 + 1;
              if (v419 >= 1 && v289 >= v434 && v289 < v434 + v416 && v212 < v419)
              {
                BOOL v301 = 0;
                uint64_t v418 = 0LL;
                UTF32Char v232 = __s1[v289 - v434];
                uint64_t v224 = v419;
                goto LABEL_776;
              }

              LOBYTE(v474[0]) = 0;
              uint64_t v419 = __CFStringFoldCharacterClusterAtIndex( v232,  &buffer,  v289,  v290,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s1,  &v467,  v474);
              if (v419 > 0)
              {
                uint64_t v212 = 1LL;
                UTF32Char v232 = __s1[0];
              }

              uint64_t v416 = v467;
              if (LOBYTE(v474[0]))
              {
                uint64_t RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theStringa, v289, 1LL);
                uint64_t v306 = RangeOfCharacterClusterAtIndex + v305;
                uint64_t v307 = 2LL;
                if (RangeOfCharacterClusterAtIndex > 2) {
                  uint64_t v307 = RangeOfCharacterClusterAtIndex;
                }
                uint64_t v308 = v307 - 1;
                if (v445 > v432) {
                  uint64_t v306 = v308;
                }
                uint64_t v418 = v306;
              }

              else
              {
                uint64_t v418 = 0LL;
              }

              uint64_t v300 = v289;
              uint64_t v224 = v419;
              int v218 = v465;
              CFIndex v222 = v461;
              BOOL v214 = v436 == 8;
              BOOL v216 = v458;
              uint64_t v227 = v464;
              __int16 v290 = v446;
LABEL_828:
              BOOL v301 = v224 == 0;
              if (!v224 && v441 > 0)
              {
                uint64_t v434 = v300;
                uint64_t v224 = 0LL;
                goto LABEL_985;
              }

LABEL_776:
              if (v227)
              {
LABEL_777:
                uint64_t v291 = v443;
                goto LABEL_778;
              }

              if (v232 != v233) {
                BOOL v301 = 1;
              }
              if (!v301)
              {
                uint64_t v434 = v300;
                goto LABEL_808;
              }

              if (!v429 || v429 == v223) {
                break;
              }
              uint64_t v434 = v300;
              if (v232 != v233) {
                goto LABEL_985;
              }
LABEL_808:
              uint64_t v226 = v289;
              uint64_t v225 = 0LL;
LABEL_729:
              if (v212 == v224 && v224 > 0) {
                uint64_t v224 = 0LL;
              }
              if (v213 == v225 && v225 > 0) {
                uint64_t v225 = 0LL;
              }
              uint64_t v287 = v467;
              if (v224) {
                uint64_t v287 = 0LL;
              }
              v226 += v287;
              uint64_t v288 = v466;
              if (v225) {
                uint64_t v288 = 0LL;
              }
              v223 += v288;
              if (v223 >= v325) {
                goto LABEL_869;
              }
            }

            uint64_t v213 = v223 - v443 + 1;
            if (v430 < 1 || v223 < v443 || v223 >= v443 + v428 || v213 >= v430)
            {
              LOBYTE(v474[0]) = 0;
              uint64_t v430 = __CFStringFoldCharacterClusterAtIndex( v233,  v486,  v223,  v290,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s2,  &v466,  v474);
              uint64_t v428 = v466;
              uint64_t v434 = v300;
              if (LOBYTE(v474[0]))
              {
                uint64_t v309 = CFStringGetRangeOfCharacterClusterAtIndex(v423, v223, 1LL);
                uint64_t v429 = v309 + v310;
              }

              else
              {
                uint64_t v429 = 0LL;
              }

              int v218 = v465;
              CFIndex v222 = v461;
              BOOL v214 = v436 == 8;
              BOOL v216 = v458;
              uint64_t v226 = v289;
              if (!v430 || v232 != __s2[0]) {
                goto LABEL_869;
              }
              uint64_t v213 = 1LL;
              uint64_t v291 = v223;
              uint64_t v441 = v430;
              uint64_t v300 = v434;
LABEL_778:
              uint64_t v443 = v291;
              uint64_t v434 = v300;
              if (v224 < 1)
              {
                uint64_t v226 = v289;
                uint64_t v225 = v441;
                goto LABEL_729;
              }

              if (v441 < 1)
              {
                uint64_t v226 = v289;
                uint64_t v225 = v441;
                goto LABEL_729;
              }

              BOOL v302 = v213 < v441;
              BOOL v303 = v212 < v224;
              uint64_t v226 = v289;
              if (v212 < v224)
              {
                uint64_t v225 = v441;
                if (v213 < v441)
                {
                  while (__s1[v212] == __s2[v213])
                  {
                    ++v212;
                    BOOL v302 = ++v213 < v441;
                    BOOL v303 = v212 < v224;
                    if (v212 >= v224 || v213 >= v441) {
                      goto LABEL_799;
                    }
                  }

                  goto LABEL_869;
                }
              }

              else
              {
                uint64_t v225 = v441;
              }

LABEL_799:
              if (!v303 || !v302) {
                goto LABEL_729;
              }
            }

            else
            {
              if (v232 == __s2[v223 - v443])
              {
                uint64_t v429 = 0LL;
                uint64_t v441 = v430;
                goto LABEL_777;
              }

              uint64_t v434 = v300;
LABEL_985:
              uint64_t v226 = v289;
            }

LABEL_869:
            if (v226 == v20) {
              int v326 = v218;
            }
            else {
              int v326 = 0;
            }
            if (v326 != 1 || v223 >= v325)
            {
              char v311 = v465 ^ 1;
              goto LABEL_836;
            }

            uint64_t v327 = v224;
            uint64_t v328 = v424;
            while (2)
            {
              if (v223 < 0 || (CFIndex v329 = range_8.location, range_8.location <= v223))
              {
                UTF32Char v333 = 0;
              }

              else
              {
                int v330 = (UniChar *)*((void *)&v494 + 1);
                if (*((void *)&v494 + 1))
                {
                  uint64_t v331 = *((void *)&v495 + 1) + v223;
                  goto LABEL_879;
                }

                if ((void)v495)
                {
                  UniChar v332 = *(char *)(v495 + *((void *)&v495 + 1) + v223);
                }

                else
                {
                  if (v497 <= v223 || (CFIndex v348 = range_8.length, range_8.length > v223))
                  {
                    CFIndex v349 = v223 - 4;
                    if (v349 + 64 < range_8.location) {
                      CFIndex v329 = v349 + 64;
                    }
                    range_8.CFIndex length = v349;
                    CFIndex v497 = v329;
                    v523.CFIndex location = *((void *)&v495 + 1) + v349;
                    v523.CFIndex length = v329 - v349;
                    CFStringGetCharacters((CFStringRef)v494, v523, v486);
                    BOOL v216 = v458;
                    BOOL v214 = v436 == 8;
                    CFIndex v222 = v461;
                    int v218 = v465;
                    CFIndex v348 = range_8.length;
                  }

                  uint64_t v331 = v223 - v348;
                  int v330 = v486;
LABEL_879:
                  UniChar v332 = v330[v331];
                }

                UTF32Char v333 = v332;
                if (v332 >> 10 == 54)
                {
                  uint64_t v341 = v223 + 1;
                  CFIndex v342 = range_8.location;
                  if (range_8.location <= v223 + 1)
                  {
                    uint64_t v328 = v424;
                  }

                  else
                  {
                    CFIndex v343 = (UniChar *)*((void *)&v494 + 1);
                    if (*((void *)&v494 + 1))
                    {
                      uint64_t v344 = *((void *)&v495 + 1) + v341;
                      goto LABEL_908;
                    }

                    if ((void)v495)
                    {
                      UniChar v345 = *(char *)(v495 + *((void *)&v495 + 1) + v341);
                    }

                    else
                    {
                      if (v497 <= v341 || (CFIndex v353 = range_8.length, range_8.length > v341))
                      {
                        CFIndex v354 = v223 - 3;
                        if (v354 + 64 < range_8.location) {
                          CFIndex v342 = v354 + 64;
                        }
                        range_8.CFIndex length = v354;
                        CFIndex v497 = v342;
                        v524.CFIndex location = *((void *)&v495 + 1) + v354;
                        v524.CFIndex length = v342 - v354;
                        CFStringGetCharacters((CFStringRef)v494, v524, v486);
                        BOOL v216 = v458;
                        BOOL v214 = v436 == 8;
                        CFIndex v222 = v461;
                        int v218 = v465;
                        CFIndex v353 = range_8.length;
                      }

                      uint64_t v344 = v341 - v353;
                      CFIndex v343 = v486;
LABEL_908:
                      UniChar v345 = v343[v344];
                    }

                    uint64_t v328 = v424;
                    if (v345 >> 10 == 55) {
                      UTF32Char v333 = (v333 << 10) - 56613888 + v345;
                    }
                  }
                }
              }

              int v334 = *v328;
              unsigned int v335 = *v328 & 4;
              if (*v435 > v333 || *v426 <= v333)
              {
                if (!v335) {
                  goto LABEL_945;
                }
                goto LABEL_895;
              }

              if (HIWORD(v333) || (v334 & 2) != 0)
              {
                int v340 = CFCharacterSetIsLongCharacterMember(*v433, v333);
                BOOL v216 = v458;
                BOOL v214 = v436 == 8;
                CFIndex v222 = v461;
                int v218 = v465;
                if (!v340) {
                  goto LABEL_945;
                }
LABEL_895:
                if (v333 < 0x10000) {
                  uint64_t v339 = 1LL;
                }
                else {
                  uint64_t v339 = 2LL;
                }
                v223 += v339;
                if (v223 >= v325) {
                  goto LABEL_945;
                }
                continue;
              }

              break;
            }

            uint64_t v336 = *v417;
            if (*v417)
            {
              if ((v334 & 1) != 0)
              {
                unsigned int v350 = v335 >> 2;
                uint64_t v351 = *(unsigned __int8 *)(v336 + ((unint64_t)v333 >> 8));
                if (*(_BYTE *)(v336 + ((unint64_t)v333 >> 8)))
                {
                  if ((_DWORD)v351 == 255)
                  {
                    unsigned int v350 = v335 == 0;
                  }

                  else
                  {
                    BOOL v352 = v335 == 0;
                  }
                }

                if (!v350) {
                  goto LABEL_945;
                }
              }

              else
              {
                BOOL v49 = v335 == 0;
                BOOL v337 = v335 != 0;
                char v338 = v49;
                if (!v337) {
                  goto LABEL_945;
                }
              }

              goto LABEL_895;
            }

            BOOL v49 = v335 == 0;
            BOOL v346 = v335 != 0;
            char v347 = v49;
            if ((v334 & 1) == 0) {
              BOOL v346 = v347;
            }
            if (v346) {
              goto LABEL_895;
            }
LABEL_945:
            char v311 = v465 ^ 1;
            uint64_t v226 = v20;
            uint64_t v224 = v327;
LABEL_836:
            if (v223 != v454) {
              goto LABEL_963;
            }
            if (v224 < 1)
            {
LABEL_849:
              if (!v420 || v226 >= v20) {
                goto LABEL_1039;
              }
              if (v226 < 0 || (uint64_t v314 = v504, v504 <= v226))
              {
                unsigned int v318 = 0;
              }

              else
              {
                uint64_t v315 = v501;
                if (v501)
                {
                  uint64_t v316 = v503 + v226;
                  goto LABEL_855;
                }

                if (v502)
                {
                  UniChar v317 = *(char *)(v502 + v503 + v226);
                }

                else
                {
                  if (v506 <= v226 || (int64_t v362 = v505, v505 > v226))
                  {
                    uint64_t v363 = v226 - 4;
                    if (v363 + 64 < v504) {
                      uint64_t v314 = v363 + 64;
                    }
                    int64_t v505 = v363;
                    int64_t v506 = v314;
                    v525.CFIndex location = v503 + v363;
                    v525.CFIndex length = v314 - v363;
                    CFStringGetCharacters(v500, v525, &buffer);
                    BOOL v216 = v458;
                    BOOL v214 = v436 == 8;
                    CFIndex v222 = v461;
                    int v218 = v465;
                    int64_t v362 = v505;
                  }

                  uint64_t v316 = v226 - v362;
                  uint64_t v315 = &buffer;
LABEL_855:
                  UniChar v317 = v315[v316];
                }

                unsigned int v318 = v317;
                if (v317 >> 10 == 54)
                {
                  uint64_t v355 = v226 + 1;
                  uint64_t v356 = v504;
                  if (v504 > v226 + 1)
                  {
                    CFRange v357 = v501;
                    if (v501)
                    {
                      uint64_t v358 = v503 + v355;
                      goto LABEL_952;
                    }

                    if (v502)
                    {
                      UniChar v359 = *(char *)(v502 + v503 + v355);
                    }

                    else
                    {
                      if (v506 <= v355 || (int64_t v366 = v505, v505 > v355))
                      {
                        uint64_t v367 = v226 - 3;
                        if (v367 + 64 < v504) {
                          uint64_t v356 = v367 + 64;
                        }
                        int64_t v505 = v367;
                        int64_t v506 = v356;
                        v527.CFIndex location = v503 + v367;
                        v527.CFIndex length = v356 - v367;
                        CFStringGetCharacters(v500, v527, &buffer);
                        BOOL v216 = v458;
                        BOOL v214 = v436 == 8;
                        CFIndex v222 = v461;
                        int v218 = v465;
                        int64_t v366 = v505;
                      }

                      uint64_t v358 = v355 - v366;
                      CFRange v357 = &buffer;
LABEL_952:
                      UniChar v359 = v357[v358];
                    }

                    uint64_t v319 = BitmapPtrForPlane;
                    if (v359 >> 10 == 55)
                    {
                      unsigned int v318 = (v318 << 10) - 56613888 + v359;
                      uint64_t v319 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v318));
                      BOOL v216 = v458;
                      BOOL v214 = v436 == 8;
                      CFIndex v222 = v461;
                      int v218 = v465;
                    }

LABEL_858:
                    if (v319 && ((*(unsigned __int8 *)(v319 + ((unsigned __int16)v318 >> 3)) >> (v318 & 7)) & 1) != 0)
                    {
                      if ((v446 & 0x80) == 0) {
                        goto LABEL_963;
                      }
                      if (!HIWORD(v318))
                      {
                        uint64_t v368 = -v226;
                        uint64_t v369 = v226 + 64;
                        uint64_t v370 = v226;
                        do
                        {
                          else {
                            uint64_t v371 = v370;
                          }
                          uint64_t v372 = v370 - 1;
                          if (v370 >= 1 && (int64_t v373 = v504, v504 >= v370))
                          {
                            if (v501)
                            {
                              UniChar v374 = v501[v370 - 1 + v503];
                            }

                            else if (v502)
                            {
                              UniChar v374 = *(char *)(v502 + v503 + v370 - 1);
                            }

                            else
                            {
                              if (v506 < v370 || (int64_t v375 = v505, v505 >= v370))
                              {
                                uint64_t v376 = -v371;
                                int64_t v377 = v369 - v371;
                                uint64_t v378 = v371 + v368;
                                int64_t v379 = v370 + v376;
                                int64_t v380 = v379 + 64;
                                if (v379 + 64 >= v504) {
                                  int64_t v380 = v504;
                                }
                                int64_t v505 = v379;
                                int64_t v506 = v380;
                                if (v504 >= v377) {
                                  int64_t v373 = v377;
                                }
                                v528.CFIndex length = v373 + v378;
                                v528.CFIndex location = v379 + v503;
                                CFStringGetCharacters(v500, v528, &buffer);
                                CFIndex v222 = v461;
                                int64_t v375 = v505;
                              }

                              UniChar v374 = *((_WORD *)&v497 + v370 - v375 + 3);
                            }
                          }

                          else
                          {
                            UniChar v374 = 0;
                          }

                          ++v368;
                          --v369;
                          --v370;
                        }

                        while (*(uint64_t *)v422 < v372);
                        if (v374 > 0x50Fu)
                        {
                          uint64_t v20 = v462;
                        }

                        else
                        {
                          uint64_t v381 = v226 + 1;
                          uint64_t v20 = v462;
                          do
                          {
                            uint64_t v226 = v381;
                            if (v381 >= v462) {
                              break;
                            }
                            if (v381 - 1 >= -1)
                            {
                              uint64_t v384 = v504;
                              uint64_t v383 = BitmapPtrForPlane;
                              if (v504 <= v226)
                              {
                                UniChar v382 = 0;
                              }

                              else if (v501)
                              {
                                UniChar v382 = v501[v226 + v503];
                              }

                              else if (v502)
                              {
                                UniChar v382 = *(char *)(v502 + v503 + v226);
                              }

                              else
                              {
                                if (v506 <= v226 || (int64_t v387 = v505, v505 > v226))
                                {
                                  uint64_t v388 = v226 - 4;
                                  if (v388 + 64 < v504) {
                                    uint64_t v384 = v388 + 64;
                                  }
                                  int64_t v505 = v388;
                                  int64_t v506 = v384;
                                  v529.CFIndex location = v503 + v388;
                                  v529.CFIndex length = v384 - v388;
                                  CFStringGetCharacters(v500, v529, &buffer);
                                  CFIndex v222 = v461;
                                  int64_t v387 = v505;
                                }

                                UniChar v382 = *(_WORD *)&v499[2 * v226 - 2 + -2 * v387];
                              }
                            }

                            else
                            {
                              UniChar v382 = 0;
                              uint64_t v383 = BitmapPtrForPlane;
                            }

                            if (!v383) {
                              break;
                            }
                            unsigned int v385 = *(unsigned __int8 *)(v383 + (v382 >> 3));
                            char v386 = v382 & 7;
                            uint64_t v381 = v226 + 1;
                          }

                          while (((v385 >> v386) & 1) != 0);
                        }
                      }

                      goto LABEL_1039;
                    }

                    if ((v446 & 0x80) != 0) {
                      goto LABEL_1039;
                    }
                    uint64_t v320 = v226 - 1;
                    if (v226 < 1 || (uint64_t v321 = v504, v504 < v226))
                    {
                      UniChar v322 = 0;
                      goto LABEL_955;
                    }

                    v323 = v501;
                    if (v501)
                    {
                      uint64_t v324 = v503 + v320;
                      goto LABEL_868;
                    }

                    if (v502)
                    {
                      UniChar v322 = *(char *)(v502 + v503 + v320);
                    }

                    else
                    {
                      if (v506 < v226 || (int64_t v364 = v505, v505 >= v226))
                      {
                        uint64_t v365 = v226 - 5;
                        if (v365 + 64 < v504) {
                          uint64_t v321 = v365 + 64;
                        }
                        int64_t v505 = v365;
                        int64_t v506 = v321;
                        v526.CFIndex location = v503 + v365;
                        v526.CFIndex length = v321 - v365;
                        CFStringGetCharacters(v500, v526, &buffer);
                        CFIndex v222 = v461;
                        int64_t v364 = v505;
                      }

                      uint64_t v324 = v320 - v364;
                      v323 = &buffer;
LABEL_868:
                      UniChar v322 = v323[v324];
                    }

LABEL_955:
                    if (v318 == 847
                      || v322 == 847
                      || v322 == 8205
                      || (unsigned __int16)(v322 - 4352) < 0xFAu
                      || v415
                      && *(_BYTE *)(v415 + HIBYTE(v322))
                      && *(_BYTE *)(v414 + (*(unsigned __int8 *)(v415 + HIBYTE(v322)) << 8) - 256 + v322) == 9)
                    {
                      uint64_t v360 = CFStringGetRangeOfCharacterClusterAtIndex(theStringa, v226 - 1, 1LL);
                      BOOL v216 = v458;
                      BOOL v214 = v436 == 8;
                      CFIndex v222 = v461;
                      int v218 = v465;
                      if (v226 < v360 + v361) {
                        goto LABEL_963;
                      }
                    }

LABEL_1039:
                    if (v436 == 12) {
                      char v389 = v311;
                    }
                    else {
                      char v389 = 1;
                    }
                    if ((v389 & 1) == 0 && v226 < v20)
                    {
                      do
                      {
                        if (v226 < 0 || (uint64_t v390 = v504, v504 <= v226))
                        {
                          UTF32Char v392 = 0;
                        }

                        else
                        {
                          if (v501)
                          {
                            UniChar v391 = v501[v503 + v226];
                          }

                          else if (v502)
                          {
                            UniChar v391 = *(char *)(v502 + v503 + v226);
                          }

                          else
                          {
                            if (v506 <= v226 || (int64_t v402 = v505, v505 > v226))
                            {
                              uint64_t v403 = v226 - 4;
                              if (v403 + 64 < v504) {
                                uint64_t v390 = v403 + 64;
                              }
                              int64_t v505 = v403;
                              int64_t v506 = v390;
                              v530.CFIndex location = v503 + v403;
                              v530.CFIndex length = v390 - v403;
                              CFStringGetCharacters(v500, v530, &buffer);
                              CFIndex v222 = v461;
                              int64_t v402 = v505;
                            }

                            UniChar v391 = *(_WORD *)&v499[2 * (v226 - v402) - 2];
                          }

                          UTF32Char v392 = v391;
                          if (v391 >> 10 == 54)
                          {
                            uint64_t v404 = v226 + 1;
                            uint64_t v405 = v504;
                            if (v504 > v226 + 1)
                            {
                              if (v501)
                              {
                                UniChar v406 = v501[v503 + v404];
                              }

                              else if (v502)
                              {
                                UniChar v406 = *(char *)(v502 + v503 + v404);
                              }

                              else
                              {
                                if (v506 <= v404 || (int64_t v410 = v505, v505 > v404))
                                {
                                  uint64_t v411 = v226 - 3;
                                  if (v411 + 64 < v504) {
                                    uint64_t v405 = v411 + 64;
                                  }
                                  int64_t v505 = v411;
                                  int64_t v506 = v405;
                                  v531.CFIndex location = v503 + v411;
                                  v531.CFIndex length = v405 - v411;
                                  CFStringGetCharacters(v500, v531, &buffer);
                                  CFIndex v222 = v461;
                                  int64_t v410 = v505;
                                }

                                UniChar v406 = *(_WORD *)&v499[2 * (v404 - v410) - 2];
                              }

                              if (v406 >> 10 == 55) {
                                UTF32Char v392 = (v392 << 10) - 56613888 + v406;
                              }
                            }
                          }
                        }

                        int v393 = *v424;
                        unsigned int v394 = *v424 & 4;
                        if (*v435 > v392 || *v426 <= v392)
                        {
                          if (!v394) {
                            break;
                          }
                        }

                        else if (HIWORD(v392) || (v393 & 2) != 0)
                        {
                          int v399 = CFCharacterSetIsLongCharacterMember(*v433, v392);
                          CFIndex v222 = v461;
                          if (!v399) {
                            break;
                          }
                        }

                        else
                        {
                          uint64_t v395 = *v417;
                          if (*v417)
                          {
                            if ((v393 & 1) != 0)
                            {
                              unsigned int v407 = v394 >> 2;
                              uint64_t v408 = *(unsigned __int8 *)(v395 + ((unint64_t)v392 >> 8));
                              if (*(_BYTE *)(v395 + ((unint64_t)v392 >> 8)))
                              {
                                if ((_DWORD)v408 == 255)
                                {
                                  unsigned int v407 = v394 == 0;
                                }

                                else
                                {
                                  BOOL v409 = v394 == 0;
                                  if ((((unint64_t)*(unsigned __int8 *)(v395
                                                                              + 32 * v408
                                                                              + (v392 >> 3)
                                                                              + 224) >> (v392 & 7)) & 1) != 0)
                                    unsigned int v407 = v409;
                                }
                              }

                              if (!v407) {
                                break;
                              }
                            }

                            else
                            {
                              BOOL v49 = v394 == 0;
                              BOOL v396 = v394 != 0;
                              char v397 = v49;
                              if (!v396) {
                                break;
                              }
                            }
                          }

                          else
                          {
                            BOOL v49 = v394 == 0;
                            BOOL v400 = v394 != 0;
                            char v401 = v49;
                            if ((v393 & 1) == 0) {
                              BOOL v400 = v401;
                            }
                            if (!v400) {
                              break;
                            }
                          }
                        }

                        if (v392 < 0x10000) {
                          uint64_t v398 = 1LL;
                        }
                        else {
                          uint64_t v398 = 2LL;
                        }
                        v226 += v398;
                      }

                      while (v226 < v20);
                    }

                    if (v436 == 12 && v226 != v20) {
                      goto LABEL_1112;
                    }
                    if (v421)
                    {
                      v421->CFIndex location = v222;
                      v421->CFIndex length = v226 - v222;
                    }

LABEL_432:
                    LOBYTE(v15) = 1;
                    return v15;
                  }
                }
              }

              uint64_t v319 = BitmapPtrForPlane;
              goto LABEL_858;
            }

            if ((v446 & 0x80) != 0 && __s1[0] <= 0x50F)
            {
              if (v212 < v224)
              {
                while (1)
                {
                  unsigned int v312 = __s1[v212];
                  uint64_t v313 = BitmapPtrForPlane;
                  if (v312 >= 0x10000)
                  {
                    uint64_t v313 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v312));
                    BOOL v216 = v458;
                    BOOL v214 = v436 == 8;
                    CFIndex v222 = v461;
                    int v218 = v465;
                  }

                  if (v224 == ++v212) {
                    goto LABEL_848;
                  }
                }
              }

              if (v212 == v224)
              {
LABEL_848:
                v226 += v467;
                uint64_t v212 = v224;
                goto LABEL_849;
              }
            }

        CFIndex v27 = 0LL;
        goto LABEL_30;
      }

      if (v28 == 0x10000)
      {
        if (v20 >= 6)
        {
          unsigned int v19 = (unsigned __int16 *)__s1;
          if (!__s1[4]) {
            goto LABEL_425;
          }
          goto LABEL_536;
        }

        goto LABEL_432;
      }

      if (v28 != 592859725)
      {
        if (v28 != 622940243) {
          goto LABEL_142;
        }
        unsigned int v19 = (unsigned __int16 *)__s1;
        if (v20 < 11) {
          goto LABEL_536;
        }
        BOOL v76 = v26;
        if (!strncmp(__s1 + 4, "-Adobe-", 7uLL))
        {
          CFIndex v27 = "ps";
          goto LABEL_506;
        }

        uint64_t v20 = v146;
        if ((unint64_t)v146 < 0xE)
        {
          CFIndex v27 = 0LL;
        }

        else
        {
          if (!strncmp(__s1 + 4, "-AdobeFont", 0xAuLL))
          {
            CFIndex v27 = "pfa";
            goto LABEL_506;
          }

          CFIndex v27 = 0LL;
          uint64_t v20 = v146;
        }

        uint64_t v26 = v76;
        goto LABEL_31;
      }

      if (v20 < 6) {
        goto LABEL_432;
      }
      unsigned int v19 = (unsigned __int16 *)__s1;
      int64_t v71 = *((unsigned __int16 *)__s1 + 2);
      int64_t v72 = 8268;
    }

LABEL_963:
            if (v222 == v432) {
              goto LABEL_1112;
            }
            v222 += v427;
          }
        }
      }

      goto LABEL_473;
    }

    CFRange v191 = 0LL;
    uint64_t v20 = location + length;
    goto LABEL_504;
  }

  LODWORD(v33) = 0;
  uint64_t v34 = 0LL;
  if (v465) {
    uint64_t v35 = (uint64_t)&v469;
  }
  else {
    uint64_t v35 = 8LL;
  }
  if (v465) {
    uint64_t v36 = (uint64_t)&v470;
  }
  else {
    uint64_t v36 = 12LL;
  }
  uint64_t v37 = (uint64_t)&v471;
  if (!v465) {
    uint64_t v37 = 16LL;
  }
  v457 = (_DWORD *)v37;
  uint64_t v38 = (uint64_t)&v472;
  if (!v465) {
    uint64_t v38 = 24LL;
  }
  CFErrorRef v447 = (uint64_t *)v38;
  uint64_t v440 = v32;
  uint64_t v450 = v36;
  uint64_t v452 = v35;
  while (2)
  {
    if (v28 >= v20)
    {
      uint64_t v39 = 0LL;
      int64_t v40 = v28;
      goto LABEL_263;
    }

    uint64_t v39 = 0LL;
    int64_t v40 = v28;
    int64_t v444 = v28;
    while (1)
    {
      int64_t v41 = -v40;
      int64_t v42 = v40 + 64;
      unsigned int v442 = v34;
      uint64_t v43 = v34;
      uint64_t v44 = v40;
      while (1)
      {
        else {
          uint64_t v45 = v44;
        }
        int v46 = *(unsigned __int8 *)(CStringPtrInternal + v44);
        int v47 = *(unsigned __int8 *)(v460 + v39);
        if (v46 == v47) {
          goto LABEL_243;
        }
        if (!v459)
        {
          int64_t v28 = v444;
          uint64_t v34 = v442;
          goto LABEL_263;
        }

        int v48 = (char)v46;
        BOOL v49 = SpecialCaseHandlingLanguageIdentifierForLocale && (char)v46 == 73;
        BOOL v50 = !v49;
        if (v48 < 0 || !v50)
        {
          if (v44 < 0 || v504 <= v44)
          {
            UniChar v53 = 0;
          }

          else if (v501)
          {
            UniChar v53 = v501[v44 + v503];
          }

          else if (v502)
          {
            UniChar v53 = *(char *)(v502 + v503 + v44);
          }

          else
          {
            if (v506 <= v44 || (int64_t v68 = v505, v505 > v44))
            {
              uint64_t v69 = -v45;
              uint64_t v70 = v45 + v41;
              int64_t v71 = v42 - v45;
              int64_t v72 = v44 + v69;
              int64_t v73 = v72 + 64;
              if (v72 + 64 >= v504) {
                int64_t v73 = v504;
              }
              int64_t v505 = v72;
              int64_t v506 = v73;
              if (v504 < v71) {
                int64_t v71 = v504;
              }
              v510.CFIndex length = v71 + v70;
              v510.CFIndex location = v72 + v503;
              CFStringGetCharacters(v500, v510, &buffer);
              int64_t v68 = v505;
            }

            UniChar v53 = *(_WORD *)&v499[2 * v44 - 2 + -2 * v68];
          }

          uint64_t v43 = v53;
          uint64_t v54 = __CFStringFoldCharacterClusterAtIndex( v53,  &buffer,  v44,  v446,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s1,  0LL,  0LL);
          if (v54 <= 0)
          {
            __s1[0] = v43;
            unint64_t v52 = 1LL;
          }

          else
          {
            unint64_t v52 = v54;
          }

          int v31 = v465;
          uint64_t v36 = v450;
          uint64_t v35 = v452;
        }

        else
        {
          __s1[0] = v48;
          unint64_t v52 = 1LL;
        }

        BOOL v55 = v436 != 8 && v444 == v44;
        char v56 = v465 ^ 1;
        if (v55) {
          char v56 = 1;
        }
        if ((v56 & 1) != 0) {
          break;
        }
        if ((v48 & 0x80u) == 0) {
          unint64_t v57 = v48;
        }
        else {
          unint64_t v57 = v43;
        }
        int v58 = *(_DWORD *)v35;
        unsigned int v59 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v57 || *v457 <= v57)
        {
          if (!v59) {
            break;
          }
        }

        else if ((v58 & 2) != 0)
        {
          int v63 = CFCharacterSetIsLongCharacterMember(*v433, v57);
          uint64_t v36 = v450;
          uint64_t v35 = v452;
          int v31 = v465;
          if (!v63) {
            break;
          }
        }

        else
        {
          uint64_t v60 = *v447;
          if (*v447)
          {
            if ((v58 & 1) != 0)
            {
              unsigned int v66 = v59 >> 2;
              uint64_t v67 = *(unsigned __int8 *)(v60 + (v57 >> 8));
              if (*(_BYTE *)(v60 + (v57 >> 8)))
              {
                if ((_DWORD)v67 == 255)
                {
                  unsigned int v66 = v59 == 0;
                }

                else
                {
                  BOOL v74 = v59 == 0;
                }
              }

              if (!v66) {
                break;
              }
            }

            else
            {
              BOOL v49 = v59 == 0;
              BOOL v61 = v59 != 0;
              char v62 = v49;
              if (!v61) {
                break;
              }
            }
          }

          else
          {
            BOOL v49 = v59 == 0;
            BOOL v64 = v59 != 0;
            char v65 = v49;
            if ((v58 & 1) == 0) {
              BOOL v64 = v65;
            }
            if (!v64) {
              break;
            }
          }
        }

        ++v44;
        --v41;
        ++v42;
        if (v44 >= v462) {
          goto LABEL_262;
        }
      }

      unsigned __int8 v75 = v47;
      if (SpecialCaseHandlingLanguageIdentifierForLocale) {
        BOOL v76 = (char)v47 == 73;
      }
      else {
        BOOL v76 = 0;
      }
      int v77 = !v76;
      if (((char)v47 & 0x80000000) == 0 && v77)
      {
        __s2[0] = v75;
        unint64_t v79 = 1LL;
        if (!v31) {
          goto LABEL_175;
        }
        goto LABEL_159;
      }

      if (v39 < 0 || (CFIndex v80 = range_8.location, range_8.location <= v39))
      {
        UniChar v83 = 0;
      }

      else
      {
        uint64_t v81 = (UniChar *)*((void *)&v494 + 1);
        if (*((void *)&v494 + 1))
        {
          uint64_t v82 = *((void *)&v495 + 1) + v39;
LABEL_153:
          UniChar v83 = v81[v82];
          goto LABEL_155;
        }

        if (!(void)v495)
        {
          if (v497 <= v39 || (CFIndex v110 = range_8.length, range_8.length > v39))
          {
            CFIndex v111 = v39 - 4;
            if (v111 + 64 < range_8.location) {
              CFIndex v80 = v111 + 64;
            }
            range_8.CFIndex length = v111;
            CFIndex v497 = v80;
            v513.CFIndex location = *((void *)&v495 + 1) + v111;
            v513.CFIndex length = v80 - v111;
            CFStringGetCharacters((CFStringRef)v494, v513, v486);
            CFIndex v110 = range_8.length;
          }

          uint64_t v82 = v39 - v110;
          uint64_t v81 = v486;
          goto LABEL_153;
        }

        UniChar v83 = *(char *)(v495 + *((void *)&v495 + 1) + v39);
      }

LABEL_155:
      LODWORD(v33) = v83;
      uint64_t v84 = __CFStringFoldCharacterClusterAtIndex( v83,  v486,  v39,  v446,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s2,  0LL,  0LL);
      if (v84 <= 0)
      {
        __s2[0] = v33;
        unint64_t v79 = 1LL;
      }

      else
      {
        unint64_t v79 = v84;
      }

      int v31 = v465;
      uint64_t v36 = v450;
      uint64_t v35 = v452;
      if (!v465) {
        goto LABEL_175;
      }
LABEL_159:
      unint64_t v85 = (v75 & 0x80u) == 0 ? v75 : v33;
      unsigned int v86 = v469 & 4;
      if (v470 > v85 || v471 <= v85)
      {
        if ((v469 & 4) != 0) {
          goto LABEL_230;
        }
      }

      else if ((v469 & 2) != 0)
      {
        int v105 = CFCharacterSetIsLongCharacterMember(theSet, v85);
        uint64_t v36 = v450;
        uint64_t v35 = v452;
        int v31 = v465;
        if (v105) {
          goto LABEL_230;
        }
      }

      else if (v472)
      {
        if ((v469 & 1) != 0)
        {
          unsigned int v108 = v86 >> 2;
          uint64_t v109 = *(unsigned __int8 *)(v472 + (v85 >> 8));
          if (*(_BYTE *)(v472 + (v85 >> 8)))
          {
            if ((_DWORD)v109 == 255)
            {
              unsigned int v108 = v86 == 0;
            }

            else
            {
              BOOL v112 = v86 == 0;
            }
          }

          if (v108) {
            goto LABEL_230;
          }
        }

        else
        {
          BOOL v49 = v86 == 0;
          BOOL v87 = v86 != 0;
          char v88 = v49;
          if (v87) {
            goto LABEL_230;
          }
        }
      }

      else
      {
        BOOL v49 = v86 == 0;
        BOOL v106 = v86 != 0;
        char v107 = v49;
        if ((v469 & 1) == 0) {
          BOOL v106 = v107;
        }
        if (v106)
        {
LABEL_230:
          int64_t v40 = v44;
          uint64_t v34 = v43;
          int64_t v28 = v444;
          goto LABEL_245;
        }
      }

  if (!theLocale && v17) {
    CFRelease(v17);
  }
}

LABEL_175:
      if (v52 == 1 && v79 == 1)
      {
        int64_t v40 = v44;
        uint64_t v34 = v43;
        int64_t v28 = v444;
        if (__s1[0] != __s2[0]) {
          goto LABEL_263;
        }
        goto LABEL_244;
      }

      if (!v455 && v52 != v79) {
        goto LABEL_262;
      }
      else {
        unint64_t v89 = v52;
      }
      if (memcmp(__s1, __s2, 4 * v89)) {
        goto LABEL_325;
      }
      if (v52 < v79)
      {
        int v31 = v465;
        uint64_t v36 = v450;
        uint64_t v35 = v452;
        if ((uint64_t)(v79 + v44) <= v462)
        {
          int64_t v90 = &__s2[v79];
          uint64_t v91 = &__s2[v52];
          int64_t v28 = v444;
          while (1)
          {
            int64_t v92 = v44 + 1;
            if (v44 < -1 || (uint64_t v93 = v504, v504 <= v92))
            {
              UniChar v94 = 0;
            }

            else if (v501)
            {
              UniChar v94 = v501[v44 + 1 + v503];
            }

            else if (v502)
            {
              UniChar v94 = *(char *)(v502 + v503 + v44 + 1);
            }

            else
            {
              if (v506 <= v92 || (int64_t v95 = v505, v505 > v92))
              {
                uint64_t v96 = v44 - 3;
                if (v96 + 64 < v504) {
                  uint64_t v93 = v96 + 64;
                }
                int64_t v505 = v96;
                int64_t v506 = v93;
                v511.CFIndex location = v503 + v96;
                v511.CFIndex length = v93 - v96;
                CFStringGetCharacters(v500, v511, &buffer);
                int64_t v95 = v505;
              }

              UniChar v94 = *(_WORD *)&v499[2 * v44 + -2 * v95];
            }

            if (__CFStringFoldCharacterClusterAtIndex( v94,  &buffer,  v44 + 1,  v446,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s1,  0LL,  0LL) > 0)
            {
              int64_t v40 = v44;
              uint64_t v34 = v43;
              goto LABEL_326;
            }

            int v31 = v465;
            uint64_t v36 = v450;
            uint64_t v35 = v452;
            if (*v91 != __s1[0]) {
              break;
            }
            ++v91;
            ++v44;
            if (v91 >= v90)
            {
              uint64_t v44 = v92;
              goto LABEL_244;
            }
          }

          int64_t v40 = v44;
          uint64_t v34 = v43;
          goto LABEL_263;
        }

LABEL_262:
        int64_t v40 = v44;
        uint64_t v34 = v43;
        int64_t v28 = v444;
        goto LABEL_263;
      }

      int v31 = v465;
      uint64_t v36 = v450;
      uint64_t v35 = v452;
      if (v79 < v52) {
        break;
      }
LABEL_243:
      int64_t v28 = v444;
LABEL_244:
      int64_t v40 = v44 + 1;
      uint64_t v34 = v43;
LABEL_245:
      ++v39;
      if (v40 >= v462 || v39 >= v454) {
        goto LABEL_263;
      }
    }

    uint64_t v97 = &__s1[v52];
    uint64_t v98 = &__s1[v79];
    uint64_t v99 = v44 + 1;
    else {
      CFIndex v100 = 0LL;
    }
    while (1)
    {
      if (v44 < -1 || (CFIndex v101 = range_8.location, range_8.location <= v99))
      {
        UniChar v102 = 0;
      }

      else if (*((void *)&v494 + 1))
      {
        UniChar v102 = *(_WORD *)(*((void *)&v494 + 1) + 2 * (v44 + *((void *)&v495 + 1)) + 2);
      }

      else if ((void)v495)
      {
        UniChar v102 = *(char *)(v495 + *((void *)&v495 + 1) + v44 + 1);
      }

      else
      {
        if (v497 <= v99 || (CFIndex v104 = range_8.length, range_8.length > v99))
        {
          if (v100 + 64 < range_8.location) {
            CFIndex v101 = v100 + 64;
          }
          range_8.CFIndex length = v100;
          CFIndex v497 = v101;
          v512.CFIndex location = *((void *)&v495 + 1) + v100;
          v512.CFIndex length = v101 - v100;
          CFStringGetCharacters((CFStringRef)v494, v512, v486);
          CFIndex v104 = range_8.length;
        }

        UniChar v102 = v486[v44 + 1 - v104];
      }

      uint64_t v103 = v39 + 1;
      if (__CFStringFoldCharacterClusterAtIndex( v102,  v486,  v39 + 1,  v446,  SpecialCaseHandlingLanguageIdentifierForLocale,  __s2,  0LL,  0LL) > 0) {
        break;
      }
      int v31 = v465;
      uint64_t v36 = v450;
      uint64_t v35 = v452;
      if (*v98 != __s2[0]) {
        goto LABEL_262;
      }
      ++v98;
      ++v39;
      if (v98 >= v97)
      {
        uint64_t v39 = v103;
        goto LABEL_243;
      }
    }

LABEL_325:
    int64_t v40 = v44;
    uint64_t v34 = v43;
    int64_t v28 = v444;
LABEL_326:
    int v31 = v465;
    uint64_t v36 = v450;
    uint64_t v35 = v452;
LABEL_263:
    if (v40 == v462) {
      int v113 = v31;
    }
    else {
      int v113 = 0;
    }
    if (v113 == 1 && v39 < v454)
    {
      uint64_t v115 = -v39;
      uint64_t v116 = v39 + 64;
      while (1)
      {
        else {
          uint64_t v117 = v39;
        }
        if (v39 < 0 || (uint64_t v118 = range_8.location, range_8.location <= v39))
        {
          UniChar v119 = 0;
        }

        else if (*((void *)&v494 + 1))
        {
          UniChar v119 = *(_WORD *)(*((void *)&v494 + 1) + 2 * (v39 + *((void *)&v495 + 1)));
        }

        else if ((void)v495)
        {
          UniChar v119 = *(char *)(v495 + *((void *)&v495 + 1) + v39);
        }

        else
        {
          if (v497 <= v39 || (CFIndex v128 = range_8.length, range_8.length > v39))
          {
            uint64_t v129 = -v117;
            uint64_t v130 = v117 + v115;
            uint64_t v131 = v116 - v117;
            CFIndex v132 = v39 + v129;
            CFIndex v133 = v132 + 64;
            if (v132 + 64 >= range_8.location) {
              CFIndex v133 = range_8.location;
            }
            range_8.CFIndex length = v132;
            CFIndex v497 = v133;
            if (range_8.location >= v131) {
              uint64_t v118 = v131;
            }
            v514.CFIndex length = v118 + v130;
            v514.CFIndex location = v132 + *((void *)&v495 + 1);
            CFStringGetCharacters((CFStringRef)v494, v514, v486);
            uint64_t v36 = v450;
            uint64_t v35 = v452;
            int v31 = v465;
            CFIndex v128 = range_8.length;
          }

          UniChar v119 = v486[v39 - v128];
        }

        unint64_t v33 = v119;
        int v120 = *(_DWORD *)v35;
        unsigned int v121 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v119 || *v457 <= v119)
        {
          if (!v121) {
            break;
          }
        }

        else if ((v120 & 2) != 0)
        {
          int v125 = CFCharacterSetIsLongCharacterMember(*v433, v119);
          uint64_t v36 = v450;
          uint64_t v35 = v452;
          int v31 = v465;
          if (!v125) {
            break;
          }
        }

        else
        {
          uint64_t v122 = *v447;
          if (*v447)
          {
            if ((v120 & 1) != 0)
            {
              unsigned int v134 = v121 >> 2;
              uint64_t v135 = *(unsigned __int8 *)(v122 + (v33 >> 8));
              if (*(_BYTE *)(v122 + (v33 >> 8)))
              {
                if ((_DWORD)v135 == 255)
                {
                  unsigned int v134 = v121 == 0;
                }

                else
                {
                  BOOL v136 = v121 == 0;
                }
              }

              if (!v134) {
                break;
              }
            }

            else
            {
              BOOL v49 = v121 == 0;
              BOOL v123 = v121 != 0;
              char v124 = v49;
              if (!v123) {
                break;
              }
            }
          }

          else
          {
            BOOL v49 = v121 == 0;
            BOOL v126 = v121 != 0;
            char v127 = v49;
            if ((v120 & 1) == 0) {
              BOOL v126 = v127;
            }
            if (!v126) {
              break;
            }
          }
        }

        ++v39;
        --v115;
        ++v116;
        if (v454 == v39) {
          goto LABEL_332;
        }
      }
    }

    if (v39 == v454)
    {
LABEL_332:
      if (v436 == 12) {
        int v138 = v31;
      }
      else {
        int v138 = 0;
      }
      if (v138 == 1)
      {
        int64_t v139 = v462;
        if (v40 < v462)
        {
          int64_t v140 = -v40;
          int64_t v141 = v40 + 64;
          do
          {
            else {
              uint64_t v142 = v40;
            }
            if (v40 < 0 || (int64_t v143 = v504, v504 <= v40))
            {
              UniChar v144 = 0;
            }

            else if (v501)
            {
              UniChar v144 = v501[v40 + v503];
            }

            else if (v502)
            {
              UniChar v144 = *(char *)(v502 + v503 + v40);
            }

            else
            {
              if (v506 <= v40 || (int64_t v154 = v505, v505 > v40))
              {
                uint64_t v155 = -v142;
                uint64_t v156 = v142 + v140;
                int64_t v157 = v141 - v142;
                int64_t v158 = v40 + v155;
                int64_t v159 = v158 + 64;
                if (v158 + 64 >= v504) {
                  int64_t v159 = v504;
                }
                int64_t v505 = v158;
                int64_t v506 = v159;
                if (v504 >= v157) {
                  int64_t v143 = v157;
                }
                v515.CFIndex length = v143 + v156;
                v515.CFIndex location = v158 + v503;
                CFStringGetCharacters(v500, v515, &buffer);
                int64_t v154 = v505;
              }

              UniChar v144 = *(_WORD *)&v499[2 * v40 - 2 + -2 * v154];
            }

            unsigned int v145 = v469 & 4;
            if (v470 <= v144 && v471 > v144)
            {
              if ((v469 & 2) != 0)
              {
                if (!CFCharacterSetIsLongCharacterMember(*v433, v144)) {
                  goto LABEL_428;
                }
              }

              else if (v472)
              {
                if ((v469 & 1) != 0)
                {
                  unsigned int v152 = v145 >> 2;
                  uint64_t v153 = *(unsigned __int8 *)(v472 + ((unint64_t)v144 >> 8));
                  if (*(_BYTE *)(v472 + ((unint64_t)v144 >> 8)))
                  {
                    if ((_DWORD)v153 == 255)
                    {
                      unsigned int v152 = v145 == 0;
                    }

                    else
                    {
                      BOOL v160 = v145 == 0;
                    }
                  }

                  if (!v152) {
                    goto LABEL_428;
                  }
                }

                else
                {
                  BOOL v147 = v145 != 0;
                  BOOL v148 = v145 == 0;
                  if (!v147) {
                    goto LABEL_428;
                  }
                }
              }

              else
              {
                BOOL v49 = v145 == 0;
                BOOL v149 = v145 != 0;
                char v150 = v49;
                if ((v469 & 1) != 0) {
                  char v151 = v149;
                }
                else {
                  char v151 = v150;
                }
                if ((v151 & 1) == 0) {
                  goto LABEL_428;
                }
              }
            }

            else if ((v469 & 4) == 0)
            {
              goto LABEL_428;
            }

            ++v40;
            --v140;
            ++v141;
          }

          while (v462 != v40);
          int64_t v40 = v462;
LABEL_430:
          if (v421)
          {
            v421->CFIndex location = v28;
            v421->CFIndex length = v40 - v28;
          }

          goto LABEL_432;
        }
      }

      else
      {
        int64_t v139 = v462;
      }

LABEL_428:
      if (v436 == 12 && v40 != v139) {
        break;
      }
      goto LABEL_430;
    }

    if (v28 != v432)
    {
      v28 += v440;
      uint64_t v20 = v462;
      continue;
    }

    break;
  }

LABEL_1112:
  LOBYTE(v15) = 0;
  return v15;
}

uint64_t _CFStringCompareForHFS(__CFString *a1, __CFString *a2, __int16 a3)
{
  uint64_t v130 = *MEMORY[0x1895F89C0];
  CharactersPtr = CFStringGetCharactersPtr(a1);
  BOOL v6 = CFStringGetCharactersPtr(a2);
  if (CharactersPtr)
  {
    uint64_t CStringPtrInternal = 0LL;
  }

  else
  {
    unsigned int v8 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v8 = __CFDefaultEightBitStringEncoding;
    }

    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, v8, 1, 1);
  }

  uint64_t v105 = CStringPtrInternal;
  if (v6)
  {
    uint64_t v106 = 0LL;
  }

  else
  {
    unsigned int v9 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v9 = __CFDefaultEightBitStringEncoding;
    }

    uint64_t v106 = _CFStringGetCStringPtrInternal((unint64_t *)a2, v9, 1, 1);
    uint64_t CStringPtrInternal = v105;
  }

  if ((a3 & 0x10) == 0 || CStringPtrInternal && v106)
  {
    uint64_t BitmapPtrForPlane = 0LL;
    uint64_t v101 = 0LL;
    int v10 = 1;
  }

  else
  {
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x65u, 0);
    if (BitmapPtrForPlane)
    {
      uint64_t v101 = CFUniCharGetBitmapPtrForPlane(8u, 0);
      int v10 = 0;
    }

    else
    {
      uint64_t BitmapPtrForPlane = 0LL;
      uint64_t v101 = 0LL;
      int v10 = 1;
    }

    uint64_t CStringPtrInternal = v105;
  }

  unint64_t v11 = (unint64_t)CharactersPtr | CStringPtrInternal;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v12 = CFStringGetLength(a2);
  if (((v10 ^ 1) & 1) != 0 || !v11)
  {
    CFStringRef theString = a1;
    uint64_t v126 = 0LL;
    CFIndex v127 = Length;
    CFIndex v13 = CFStringGetCharactersPtr(a1);
    uint64_t v14 = 0LL;
    char v124 = v13;
    if (!v13) {
      uint64_t v14 = _CFStringGetCStringPtrInternal((unint64_t *)a1, 0x600u, 1, 1);
    }
    uint64_t v129 = 0LL;
    uint64_t v125 = v14;
    uint64_t v128 = 0LL;
  }

  uint64_t v15 = v106;
  else {
    int v16 = 1;
  }
  if (v16 == 1)
  {
    CFStringRef v115 = a2;
    uint64_t v118 = 0LL;
    CFIndex v119 = v12;
    int v17 = CFStringGetCharactersPtr(a2);
    uint64_t v18 = 0LL;
    uint64_t v116 = v17;
    if (!v17) {
      uint64_t v18 = _CFStringGetCStringPtrInternal((unint64_t *)a2, 0x600u, 1, 1);
    }
    uint64_t v121 = 0LL;
    uint64_t v117 = v18;
    uint64_t v120 = 0LL;
    uint64_t v15 = v106;
  }

  CFIndex v19 = Length;
  BOOL v20 = Length > 0;
  BOOL v21 = v12 > 0;
  if (Length < 1)
  {
    uint64_t v22 = v105;
  }

  else
  {
    char v102 = v10;
    uint64_t v22 = v105;
    if (v12 >= 1)
    {
      uint64_t v23 = 0LL;
      uint64_t v24 = 0LL;
      p_info = &OBJC_METACLASS_____NSCFTimer.info;
      do
      {
        uint64_t v26 = -v23;
        uint64_t v27 = v23 + 64;
        do
        {
          else {
            uint64_t v28 = v23;
          }
          if (CharactersPtr)
          {
            UniChar v29 = CharactersPtr[v23];
          }

          else if (v22)
          {
            UniChar v29 = *((_WORD *)&p_info[96]->flags + *(unsigned __int8 *)(v22 + v23));
          }

          else if (v23 < 0 || (CFIndex v30 = v127, v127 <= v23))
          {
            UniChar v29 = 0;
          }

          else if (v124)
          {
            UniChar v29 = v124[v23 + v126];
          }

          else if (v125)
          {
            UniChar v29 = *(char *)(v125 + v126 + v23);
          }

          else
          {
            if (v129 <= v23 || (uint64_t v32 = v128, v128 > v23))
            {
              uint64_t v33 = -v28;
              uint64_t v34 = v28 + v26;
              CFIndex v35 = v27 - v28;
              uint64_t v36 = v23 + v33;
              CFIndex v37 = v36 + 64;
              if (v36 + 64 >= v127) {
                CFIndex v37 = v127;
              }
              uint64_t v128 = v36;
              uint64_t v129 = v37;
              if (v127 >= v35) {
                CFIndex v30 = v35;
              }
              v131.CFIndex length = v30 + v34;
              v131.CFIndex location = v36 + v126;
              CFStringGetCharacters(theString, v131, buffer);
              p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
              CFIndex v19 = Length;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v32 = v128;
            }

            UniChar v29 = buffer[v23 - v32];
          }

          unsigned int v31 = v29;
          if (__CFHFSLowerTable[HIBYTE(v29)]) {
            UniChar v29 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v29)] + v29];
          }
          if (++v23 >= v19) {
            break;
          }
          --v26;
          ++v27;
        }

        while (!v29);
        unsigned int v38 = v29;
        uint64_t v39 = v23 - 1;
        uint64_t v40 = -v24;
        uint64_t v41 = v24 + 64;
        do
        {
          else {
            uint64_t v42 = v24;
          }
          if (v6)
          {
            UniChar v43 = v6[v24];
          }

          else if (v15)
          {
            UniChar v43 = *((_WORD *)&p_info[96]->flags + *(unsigned __int8 *)(v15 + v24));
          }

          else if (v24 < 0 || (CFIndex v44 = v119, v119 <= v24))
          {
            UniChar v43 = 0;
          }

          else if (v116)
          {
            UniChar v43 = v116[v24 + v118];
          }

          else if (v117)
          {
            UniChar v43 = *(char *)(v117 + v118 + v24);
          }

          else
          {
            if (v121 <= v24 || (uint64_t v46 = v120, v120 > v24))
            {
              uint64_t v47 = -v42;
              uint64_t v48 = v42 + v40;
              CFIndex v49 = v41 - v42;
              uint64_t v50 = v24 + v47;
              CFIndex v51 = v50 + 64;
              if (v50 + 64 >= v119) {
                CFIndex v51 = v119;
              }
              uint64_t v120 = v50;
              uint64_t v121 = v51;
              uint64_t v108 = v39;
              if (v119 >= v49) {
                CFIndex v44 = v49;
              }
              v132.CFIndex length = v44 + v48;
              unsigned int v100 = v38;
              v132.CFIndex location = v50 + v118;
              CFStringGetCharacters(v115, v132, v114);
              unsigned int v38 = v100;
              uint64_t v39 = v108;
              p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
              CFIndex v19 = Length;
              uint64_t v22 = v105;
              uint64_t v15 = v106;
              uint64_t v46 = v120;
            }

            UniChar v43 = v114[v24 - v46];
          }

          unsigned int v45 = v43;
          if (__CFHFSLowerTable[HIBYTE(v43)]) {
            UniChar v43 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v43)] + v43];
          }
          if (++v24 >= v12) {
            break;
          }
          --v40;
          ++v41;
        }

        while (!v43);
        if ((a3 & 1) != 0) {
          unsigned int v52 = v38;
        }
        else {
          unsigned int v52 = v31;
        }
        if ((a3 & 1) != 0) {
          unsigned int v53 = v43;
        }
        else {
          unsigned int v53 = v45;
        }
        if (v52 == v53) {
          goto LABEL_154;
        }
        char v54 = v102;
        if ((v53 | v52) < 0x80) {
          char v54 = 1;
        }
        if ((v54 & 1) != 0) {
          goto LABEL_240;
        }
        if (v23 < v19 && (v52 & 0xFC00) == 0xD800)
        {
          if (CharactersPtr)
          {
            UniChar v55 = CharactersPtr[v23];
          }

          else if (v22)
          {
            UniChar v55 = *((_WORD *)&p_info[96]->flags + *(unsigned __int8 *)(v22 + v23));
          }

          else
          {
            if (v39 < -1) {
              goto LABEL_108;
            }
            CFIndex v71 = v127;
            if (v127 <= v23) {
              goto LABEL_108;
            }
            if (v124)
            {
              UniChar v55 = v124[v126 + v23];
            }

            else if (v125)
            {
              UniChar v55 = *(char *)(v125 + v126 + v23);
            }

            else
            {
              if (v129 <= v23 || (uint64_t v73 = v128, v128 > v23))
              {
                uint64_t v74 = v23 - 4;
                unsigned int v75 = v52;
                if (v74 + 64 < v127) {
                  CFIndex v71 = v74 + 64;
                }
                uint64_t v128 = v74;
                uint64_t v129 = v71;
                uint64_t v76 = v39;
                v133.CFIndex location = v126 + v74;
                v133.CFIndex length = v71 - v74;
                CFStringGetCharacters(theString, v133, buffer);
                unsigned int v52 = v75;
                uint64_t v39 = v76;
                p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
                uint64_t v15 = v106;
                uint64_t v73 = v128;
              }

              UniChar v55 = buffer[v23 - v73];
            }
          }

          if (v55 >> 10 == 55) {
            unsigned int v52 = (v52 << 10) - 56613888 + v55;
          }
        }

Boolean CFStringFindWithOptions( CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return CFStringFindWithOptionsAndLocale(theString, stringToFind, rangeToSearch, searchOptions, 0LL, result);
}

CFArrayRef CFStringCreateArrayWithFindResults( CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  allocator = alloc;
  if (!alloc)
  {
    uint64_t v9 = _CFGetTSD(1u);
    int v10 = &__kCFAllocatorSystemDefault;
    if (v9) {
      int v10 = (__objc2_class **)v9;
    }
    allocator = (const __CFAllocator *)v10;
  }

  if (length < 1) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  CFMutableStringRef Mutable = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = (location + length);
  while (1)
  {
    v25.CFIndex location = location;
    v25.uint64_t length = length;
    if (!CFStringFindWithOptionsAndLocale(theString, stringToFind, v25, compareOptions, 0LL, &result)) {
      break;
    }
    if ((compareOptions & 4) != 0)
    {
      uint64_t length = result.location - location;
    }

    else
    {
      CFIndex location = result.length + result.location;
      uint64_t length = v16 - (result.length + result.location);
    }

    if (v14 >= v13)
    {
      if (!Mutable) {
        CFMutableStringRef Mutable = CFDataCreateMutable(allocator, 0LL);
      }
      uint64_t v13 = 2 * v13 + 8;
      CFDataSetLength(Mutable, 24 * v13);
      uint64_t v15 = (CFRange *)&CFDataGetMutableBytePtr(Mutable)[v11];
    }

    *uint64_t v15 = result;
    v15[1].CFIndex location = (CFIndex)Mutable;
    uint64_t v15 = (CFRange *)((char *)v15 + 24);
    ++v14;
    v11 += 24LL;
    if (length <= 0) {
      goto LABEL_18;
    }
  }

  if (!v14) {
    return 0LL;
  }
LABEL_18:
  *(_OWORD *)&callBacks.version = xmmword_18999D150;
  *(_OWORD *)&callBacks.release = *(_OWORD *)off_18999D160;
  callBacks.equal = (CFArrayEqualCallBack)__rangeEqual;
  CFDataSetLength(Mutable, 24 * v14);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v18 = CFArrayCreateMutable(allocator, 8 * v14, &callBacks);
  do
  {
    CFArrayAppendValue(v18, MutableBytePtr);
    MutableBytePtr += 24;
    --v14;
  }

  while (v14);
  CFRelease(Mutable);
  return v18;
}

uint64_t __rangeRetain(uint64_t a1, uint64_t a2)
{
  return a2;
}

void __rangeRelease(uint64_t a1, uint64_t a2)
{
}

CFStringRef __rangeCopyDescription(void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"{%ld, %ld}", *a1, a1[1]);
}

BOOL __rangeEqual(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  v13.CFIndex length = CFStringGetLength(theString);
  v13.CFIndex location = 0LL;
  int v6 = CFStringFindWithOptionsAndLocale(theString, stringToFind, v13, compareOptions, 0LL, &result);
  BOOL v7 = v6 == 0;
  if (v6) {
    CFIndex location = result.location;
  }
  else {
    CFIndex location = -1LL;
  }
  if (v7) {
    CFIndex length = 0LL;
  }
  else {
    CFIndex length = result.length;
  }
  v12.CFIndex length = length;
  v12.CFIndex location = location;
  return v12;
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  v5.CFIndex length = CFStringGetLength(theString);
  v5.CFIndex location = 0LL;
  return CFStringFindWithOptionsAndLocale(theString, prefix, v5, 8uLL, 0LL, 0LL);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  v5.CFIndex length = CFStringGetLength(theString);
  v5.CFIndex location = 0LL;
  return CFStringFindWithOptionsAndLocale(theString, suffix, v5, 0xCuLL, 0LL, 0LL);
}

uint64_t _CFStringInlineBufferGetComposedRange( UniChar *buffer, int64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v7 = a2;
  uint64_t v9 = a2 + 1;
  if (a2 < 0) {
    goto LABEL_160;
  }
  int64_t v10 = *((void *)buffer + 20);
  if (v10 <= a2)
  {
    unsigned int v13 = 0;
LABEL_6:
    uint64_t BitmapPtrForPlane = a4;
    goto LABEL_7;
  }

  uint64_t v11 = *((void *)buffer + 17);
  if (v11)
  {
    UniChar v12 = *(_WORD *)(v11 + 2 * (*((void *)buffer + 19) + a2));
  }

  else
  {
    uint64_t v30 = *((void *)buffer + 18);
    if (v30)
    {
      UniChar v12 = *(char *)(v30 + *((void *)buffer + 19) + a2);
    }

    else
    {
      if (*((void *)buffer + 22) <= a2 || (int64_t v31 = *((void *)buffer + 21), v31 > a2))
      {
        int64_t v32 = a2 - 4;
        if (v32 + 64 < v10) {
          int64_t v10 = v32 + 64;
        }
        *((void *)buffer + 21) = v32;
        *((void *)buffer + 22) = v10;
        v98.CFIndex location = *((void *)buffer + 19) + v32;
        v98.CFIndex length = v10 - v32;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v98, buffer);
        int64_t v31 = *((void *)buffer + 21);
      }

      UniChar v12 = buffer[v7 - v31];
    }
  }

  unsigned int v13 = v12;
  if (v12 >> 10 != 54) {
    goto LABEL_6;
  }
  uint64_t v35 = *((void *)buffer + 20);
  if (v35 <= v9) {
    goto LABEL_6;
  }
  uint64_t v36 = *((void *)buffer + 17);
  if (v36)
  {
    UniChar v37 = *(_WORD *)(v36 + 2 * (*((void *)buffer + 19) + v9));
  }

  else
  {
    uint64_t v92 = *((void *)buffer + 18);
    if (v92)
    {
      UniChar v37 = *(char *)(v92 + *((void *)buffer + 19) + v9);
    }

    else
    {
      if (*((void *)buffer + 22) <= v9 || (uint64_t v93 = *((void *)buffer + 21), v93 > v9))
      {
        uint64_t v94 = v7 - 3;
        if (v94 + 64 < v35) {
          uint64_t v35 = v94 + 64;
        }
        *((void *)buffer + 21) = v94;
        *((void *)buffer + 22) = v35;
        v103.CFIndex location = *((void *)buffer + 19) + v94;
        v103.CFIndex length = v35 - v94;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v103, buffer);
        uint64_t v93 = *((void *)buffer + 21);
      }

      UniChar v37 = buffer[v9 - v93];
    }
  }

  uint64_t BitmapPtrForPlane = a4;
  if (v37 >> 10 == 55)
  {
    uint64_t v9 = v7 + 2;
    unsigned int v13 = (v13 << 10) + v37 - 56613888;
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
  }

LABEL_118:
    char v41 = 1;
    goto LABEL_121;
  }

LABEL_123:
  if ((v9 & 0x8000000000000000LL) == 0)
  {
    uint64_t v56 = *((void *)buffer + 20);
    if (v56 > v9)
    {
      uint64_t v57 = -v9;
      uint64_t v58 = v9 + 64;
      while (2)
      {
        uint64_t v59 = (unint64_t)v9 >= 4 ? 4LL : v9;
        uint64_t v60 = *((void *)buffer + 17);
        if (v60)
        {
          UniChar v61 = *(_WORD *)(v60 + 2 * (v9 + *((void *)buffer + 19)));
        }

        else
        {
          uint64_t v62 = *((void *)buffer + 18);
          if (v62)
          {
            UniChar v61 = *(char *)(v62 + *((void *)buffer + 19) + v9);
          }

          else
          {
            if (*((void *)buffer + 22) <= v9 || (uint64_t v63 = *((void *)buffer + 21), v63 > v9))
            {
              uint64_t v64 = -v59;
              uint64_t v65 = v59 + v57;
              uint64_t v66 = v58 - v59;
              uint64_t v67 = v9 + v64;
              uint64_t v68 = v67 + 64;
              if (v67 + 64 >= v56) {
                uint64_t v68 = v56;
              }
              *((void *)buffer + 21) = v67;
              *((void *)buffer + 22) = v68;
              if (v56 >= v66) {
                uint64_t v56 = v66;
              }
              v100.CFIndex length = v56 + v65;
              v100.CFIndex location = v67 + *((void *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v100, buffer);
              uint64_t v63 = *((void *)buffer + 21);
            }

            UniChar v61 = buffer[v9 - v63];
          }
        }

        if (v61
          && (v61 - 4352 < 0xFA || (unsigned __int16)((unsigned __int16)(v61 + 21504) >> 4) <= 0x2BAu))
        {
          switch(v34)
          {
            case 1:
            case 3:
              if (v61 - 4448 <= 0x99)
              {
                if (v61 >> 3 < 0x235u) {
                  char v34 = 1;
                }
                else {
                  char v34 = 2;
                }
                goto LABEL_159;
              }

              break;
            case 2:
            case 4:
              if (v61 - 4520 < 0x52)
              {
                char v34 = 2;
                goto LABEL_159;
              }

              break;
            default:
              if (v61 >> 5 >= 0x8Bu)
              {
                if (v61 >> 3 >= 0x235u)
                {
                  if (v61 >> 10 < 0x2Bu) {
                    break;
                  }
                  HIDWORD(v69) = -1227133513 * v61 - 1840706560;
                  LODWORD(v69) = HIDWORD(v69);
                  else {
                    char v34 = 4;
                  }
                }

                else
                {
                  char v34 = 1;
                }
              }

              else
              {
                char v34 = 0;
              }

LABEL_160:
  do
  {
    unint64_t v70 = v9;
    if (v9 < 0) {
      break;
    }
    uint64_t v71 = *((void *)buffer + 20);
    if (v71 <= v9) {
      break;
    }
    uint64_t v72 = *((void *)buffer + 17);
    if (v72)
    {
      UniChar v73 = *(_WORD *)(v72 + 2 * (*((void *)buffer + 19) + v9));
    }

    else
    {
      uint64_t v74 = *((void *)buffer + 18);
      if (v74)
      {
        UniChar v73 = *(char *)(v74 + *((void *)buffer + 19) + v9);
      }

      else
      {
        if (*((void *)buffer + 22) <= v9 || (uint64_t v75 = *((void *)buffer + 21), v75 > v9))
        {
          uint64_t v76 = v9 - 4;
          if (v76 + 64 < v71) {
            uint64_t v71 = v76 + 64;
          }
          *((void *)buffer + 21) = v76;
          *((void *)buffer + 22) = v71;
          v101.CFIndex location = *((void *)buffer + 19) + v76;
          v101.CFIndex length = v71 - v76;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v101, buffer);
          uint64_t v75 = *((void *)buffer + 21);
        }

        UniChar v73 = buffer[v9 - v75];
      }
    }

    unsigned int v77 = v73;
    if (v73 >> 10 != 54) {
      goto LABEL_194;
    }
    uint64_t v78 = v9 + 1;
    int64_t v79 = *((void *)buffer + 20);
    uint64_t v80 = *((void *)buffer + 17);
    if (v80)
    {
      UniChar v81 = *(_WORD *)(v80 + 2 * (*((void *)buffer + 19) + v78));
    }

    else
    {
      uint64_t v82 = *((void *)buffer + 18);
      if (v82)
      {
        UniChar v81 = *(char *)(v82 + *((void *)buffer + 19) + v78);
      }

      else
      {
        if (*((void *)buffer + 22) <= v78 || (uint64_t v83 = *((void *)buffer + 21), v83 > v78))
        {
          unint64_t v84 = v70 - 3;
          if (v70 < 3) {
            unint64_t v84 = 0LL;
          }
          *((void *)buffer + 21) = v84;
          *((void *)buffer + 22) = v79;
          v102.CFIndex location = *((void *)buffer + 19) + v84;
          v102.CFIndex length = v79 - v84;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v102, buffer);
          uint64_t v83 = *((void *)buffer + 21);
        }

        UniChar v81 = buffer[v78 - v83];
      }
    }

    if (v81 >> 10 == 55)
    {
      unsigned int v77 = (v77 << 10) + v81 - 56613888;
      uint64_t v85 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v77));
      uint64_t v86 = 2LL;
      if (v85) {
        goto LABEL_195;
      }
    }

    else
    {
LABEL_194:
      uint64_t v86 = 1LL;
      uint64_t v85 = a4;
      if (a4)
      {
LABEL_195:
        int v87 = (*(unsigned __int8 *)(v85 + ((unsigned __int16)v77 >> 3)) >> (v77 & 7)) & 1;
        goto LABEL_196;
      }
    }

    LOBYTE(v87) = 0;
LABEL_196:
    uint64_t v9 = v86 + v70;
    BOOL v90 = v77 != 8205 && (v77 & 0xFFFFFFFE) != 65438 && (v77 & 0x1FFFF0) != 63600 && v77 - 127995 >= 5;
  }

  while (!v90 || (v87 & 1) != 0 || v77 - 917536 < 0x60);
  return v7;
}

BOOL _CFStringIsJoiningPulliAtIndex(void *__src, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[1] = *MEMORY[0x1895F89C0];
  if (a3 >= a2 || a3 + a4 <= a2) {
    return 0LL;
  }
  uint64_t v5 = a2 - 1;
  if (a3 + a4 - (a2 - 1) >= 4) {
    CFIndex v6 = 4LL;
  }
  else {
    CFIndex v6 = a3 + a4 - (a2 - 1);
  }
  v21[0] = 0LL;
  if (*((void *)__src + 17))
  {
    __memmove_chk();
  }

  else
  {
    uint64_t v11 = *((void *)__src + 21);
    if (v11 < a2 && (uint64_t v12 = *((void *)__src + 22), v12 >= a2))
    {
      CFIndex v15 = v12 - v5;
      if (v6 >= v15) {
        CFIndex v16 = v15;
      }
      else {
        CFIndex v16 = v6;
      }
      __memmove_chk();
      uint64_t v14 = (UniChar *)v21 + v16;
      v5 += v16;
      v6 -= v16;
    }

    else
    {
      CFIndex v13 = v6 + v5 - v11;
      if (v6 + v5 <= v11)
      {
        uint64_t v14 = (UniChar *)v21;
      }

      else
      {
        uint64_t v14 = (UniChar *)v21;
        if (v6 + v5 < *((void *)__src + 22))
        {
          CFIndex v6 = v11 - v5;
          memmove((char *)v21 + 2 * (v11 - v5), __src, 2 * v13);
        }
      }
    }

    if (v6 >= 1)
    {
      uint64_t v17 = *((void *)__src + 18);
      v18.CFIndex location = *((void *)__src + 19) + v5;
      if (v17)
      {
        uint64_t v19 = (char *)(v17 + v18.location);
        do
        {
          UniChar v20 = *v19++;
          *v14++ = v20;
          --v6;
        }

        while (v6);
      }

      else
      {
        v18.CFIndex length = v6;
        CFStringGetCharacters(*((CFStringRef *)__src + 16), v18, v14);
      }
    }
  }

  return LODWORD(v21[0]) == 197987221 && WORD2(v21[0]) == 2999
      || v21[0] == 0xBC00BB00BCD0BB6LL
      || v21[0] == 0xBC00BB00BCD0BB8LL;
}

BOOL __CFStringIsRegionalIndicatorAtIndex(UniChar *buffer, int64_t a2)
{
  if (a2 < 0) {
    return 0LL;
  }
  int64_t v4 = *((void *)buffer + 20);
  if (v4 <= a2) {
    return 0LL;
  }
  uint64_t v5 = *((void *)buffer + 17);
  if (v5)
  {
    CFIndex v6 = (UniChar *)(v5 + 2 * (*((void *)buffer + 19) + a2));
  }

  else
  {
    if (*((void *)buffer + 18)) {
      return 0LL;
    }
    if (*((void *)buffer + 22) <= a2 || (int64_t v12 = *((void *)buffer + 21), v12 > a2))
    {
      int64_t v13 = a2 - 4;
      if (v13 + 64 < v4) {
        int64_t v4 = v13 + 64;
      }
      *((void *)buffer + 21) = v13;
      *((void *)buffer + 22) = v4;
      v17.CFIndex location = *((void *)buffer + 19) + v13;
      v17.CFIndex length = v4 - v13;
      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v17, buffer);
      int64_t v12 = *((void *)buffer + 21);
    }

    CFIndex v6 = &buffer[a2 - v12];
  }

  if (*v6 != 55356) {
    return 0LL;
  }
  int64_t v7 = a2 + 1;
  int64_t v8 = *((void *)buffer + 20);
  if (v8 <= a2 + 1)
  {
    UniChar v10 = 0;
  }

  else
  {
    uint64_t v9 = *((void *)buffer + 17);
    if (v9)
    {
      UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + v7));
    }

    else
    {
      uint64_t v14 = *((void *)buffer + 18);
      if (v14)
      {
        UniChar v10 = *(char *)(v14 + *((void *)buffer + 19) + v7);
      }

      else
      {
        if (*((void *)buffer + 22) <= v7 || (int64_t v15 = *((void *)buffer + 21), v15 > v7))
        {
          int64_t v16 = a2 - 3;
          if (v16 + 64 < v8) {
            int64_t v8 = v16 + 64;
          }
          *((void *)buffer + 21) = v16;
          *((void *)buffer + 22) = v8;
          v18.CFIndex location = *((void *)buffer + 19) + v16;
          v18.CFIndex length = v8 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v18, buffer);
          int64_t v15 = *((void *)buffer + 21);
        }

        UniChar v10 = buffer[v7 - v15];
      }
    }
  }

  return (unsigned __int16)(v10 + 8730) < 0x1Au;
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex((__CFString *)theString, theIndex, 2LL);
  result.CFIndex length = v3;
  result.CFIndex location = RangeOfCharacterClusterAtIndex;
  return result;
}

Boolean CFStringFindCharacterFromSet( CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  char v6 = searchOptions;
  CFIndex length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v63 = *MEMORY[0x1895F89C0];
  CFIndex v11 = CFStringGetLength(theString);
  Boolean v12 = 0;
  if (!length || location + length > v11) {
    return v12;
  }
  if ((v6 & 4) != 0) {
    uint64_t v13 = location;
  }
  else {
    uint64_t v13 = location + length - 1;
  }
  if ((v6 & 4) != 0) {
    uint64_t v14 = location + length - 1;
  }
  else {
    uint64_t v14 = location;
  }
  if ((v6 & 8) != 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = v13;
  }
  if (v14 > v15) {
    uint64_t v16 = -1LL;
  }
  else {
    uint64_t v16 = 1LL;
  }
  CFStringRef theStringa = theString;
  CFIndex v59 = location;
  CFIndex v60 = length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr) {
    uint64_t CStringPtrInternal = 0LL;
  }
  else {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, 1);
  }
  int64_t v61 = 0LL;
  int64_t v62 = 0LL;
  uint64_t v58 = CStringPtrInternal;
  CFCharacterSetInitInlineBuffer((__objc2_class **)theSet, (uint64_t)&theSeta);
  for (CFIndex i = v14; ; i += v16)
  {
    int64_t v19 = i - location;
    if (i - location >= 0)
    {
      CFIndex v20 = v60;
      if (v60 > v19) {
        break;
      }
    }

    UniChar v23 = 0;
LABEL_25:
    unsigned int v24 = v51 & 4;
    if (v52 <= v23 && v53 > v23)
    {
      if ((v51 & 2) != 0)
      {
        if (CFCharacterSetIsLongCharacterMember(theSeta, v23)) {
          goto LABEL_104;
        }
      }

      else if (v54)
      {
        if ((v51 & 1) != 0)
        {
          unsigned int v41 = v24 >> 2;
          uint64_t v42 = *(unsigned __int8 *)(v54 + ((unint64_t)v23 >> 8));
          if (*(_BYTE *)(v54 + ((unint64_t)v23 >> 8)))
          {
            if ((_DWORD)v42 == 255)
            {
              unsigned int v41 = v24 == 0;
            }

            else
            {
              BOOL v45 = v24 == 0;
            }
          }

          if (v41)
          {
LABEL_104:
            Boolean v12 = 1;
            if (!result) {
              return v12;
            }
            CFRange v48 = (CFRange)vdupq_n_s64(1uLL);
            v48.CFIndex location = i;
            goto LABEL_106;
          }
        }

        else
        {
          BOOL v26 = v24 != 0;
          BOOL v27 = v24 == 0;
          if (v26) {
            goto LABEL_104;
          }
        }
      }

      else
      {
        BOOL v29 = v24 == 0;
        BOOL v30 = v24 != 0;
        char v31 = v29;
        if ((v51 & 1) != 0) {
          char v32 = v30;
        }
        else {
          char v32 = v31;
        }
        if ((v32 & 1) != 0) {
          goto LABEL_104;
        }
      }
    }

    else if ((v51 & 4) != 0)
    {
      goto LABEL_104;
    }

    if (i == v15) {
      return 0;
    }
LABEL_92:
    ;
  }

  uint64_t v21 = (UniChar *)CharactersPtr;
  if (CharactersPtr)
  {
    CFIndex v22 = v59 + v19;
LABEL_23:
    UniChar v23 = v21[v22];
    goto LABEL_42;
  }

  if (!v58)
  {
    if (v62 <= v19 || (int64_t v43 = v61, v61 > v19))
    {
      int64_t v44 = v19 - 4;
      if (v44 + 64 < v60) {
        CFIndex v20 = v44 + 64;
      }
      int64_t v61 = v44;
      int64_t v62 = v20;
      v64.CFIndex location = v59 + v44;
      v64.CFIndex length = v20 - v44;
      CFStringGetCharacters(theStringa, v64, buffer);
      int64_t v43 = v61;
    }

    CFIndex v22 = v19 - v43;
    uint64_t v21 = buffer;
    goto LABEL_23;
  }

  UniChar v23 = *(char *)(v58 + v59 + v19);
LABEL_42:
  if (v23 >> 11 != 27) {
    goto LABEL_25;
  }
  CFIndex v28 = (int)i + (int)v16;
  if (v14 <= v15)
  {
    if (v28 > v15) {
      return 0;
    }
  }

  else if (v28 < v15)
  {
    return 0;
  }

  int64_t v33 = v28 - location;
  if (v28 - location < 0 || (CFIndex v34 = v60, v60 <= v33))
  {
    UniChar v37 = 0;
  }

  else
  {
    uint64_t v35 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      CFIndex v36 = v59 + v33;
      goto LABEL_59;
    }

    if (v58)
    {
      UniChar v37 = *(char *)(v58 + v59 + v33);
    }

    else
    {
      if (v62 <= v33 || (int64_t v46 = v61, v61 > v33))
      {
        int64_t v47 = v33 - 4;
        if (v47 + 64 < v60) {
          CFIndex v34 = v47 + 64;
        }
        int64_t v61 = v47;
        int64_t v62 = v34;
        v65.CFIndex location = v59 + v47;
        v65.CFIndex length = v34 - v47;
        CFStringGetCharacters(theStringa, v65, buffer);
        int64_t v46 = v61;
      }

      CFIndex v36 = v33 - v46;
      uint64_t v35 = buffer;
LABEL_59:
      UniChar v37 = v35[v36];
    }
  }

  if (i >= v28) {
    UniChar v38 = v37;
  }
  else {
    UniChar v38 = v23;
  }
  if (i >= v28) {
    UniChar v37 = v23;
  }
  if (v38 >> 10 != 54 || (v37 & 0xFC00) != 0xDC00)
  {
LABEL_86:
    CFIndex i = (int)i + (int)v16;
    if (v28 == v15) {
      return 0;
    }
    goto LABEL_92;
  }

  UTF32Char v39 = (v38 << 10) + v37 - 56613888;
  if (v52 > v39 || v53 <= v39)
  {
    if ((v51 & 4) != 0) {
      goto LABEL_109;
    }
    goto LABEL_86;
  }

  if (!CFCharacterSetIsLongCharacterMember(theSeta, v39)) {
    goto LABEL_86;
  }
LABEL_109:
  if (result)
  {
    if (i >= v28) {
      CFIndex v49 = (int)i + (int)v16;
    }
    else {
      CFIndex v49 = i;
    }
    CFRange v48 = (CFRange)vdupq_n_s64(2uLL);
    v48.CFIndex location = v49;
LABEL_106:
    *CFRange result = v48;
  }

  return 1;
}

void CFStringGetLineBounds( CFStringRef theString, CFRange range, CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString)) {
    -[__CFString getLineStart:end:contentsEnd:forRange:]( (id)theString,  "getLineStart:end:contentsEnd:forRange:",  lineBeginIndex,  lineEndIndex,  contentsEndIndex,  location,  length);
  }
  else {
    __CFStringGetLineOrParagraphBounds( theString,  location,  length,  lineBeginIndex,  (unint64_t)lineEndIndex,  contentsEndIndex,  1);
  }
}

void __CFStringGetLineOrParagraphBounds( CFStringRef theString, int64_t a2, uint64_t a3, int64_t *a4, unint64_t a5, uint64_t *a6, int a7)
{
  uint64_t v100 = *MEMORY[0x1895F89C0];
  char v14 = atomic_load((unint64_t *)&theString->info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)&theString->info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      int64_t v19 = *p_data;
    }

    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      int64_t v19 = (char *)&p_data[(v21 & 5) != 4];
    }

    uint64_t length = *v19;
    if (!a4) {
      goto LABEL_87;
    }
  }

  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
    if (!a4) {
      goto LABEL_87;
    }
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
    if (!a4) {
      goto LABEL_87;
    }
  }

  if (!a2)
  {
    int64_t v28 = 0LL;
    goto LABEL_86;
  }

  CFStringRef theStringa = theString;
  uint64_t v96 = 0LL;
  int64_t v97 = length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  UniChar v23 = 0LL;
  uint64_t v94 = (UniChar *)CharactersPtr;
  if (!CharactersPtr)
  {
    int v24 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v24 = __CFDefaultEightBitStringEncoding;
    }

    if (v24 != 1536)
    {
      if (v24 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v24 = __CFDefaultEightBitStringEncoding;
      }

      if (v24 != 1536) {
        goto LABEL_21;
      }
    }

    p_info = &theString->info;
    char v26 = atomic_load((unint64_t *)&theString->info);
    if ((v26 & 0x10) == 0 || (char v27 = atomic_load((unint64_t *)p_info), (v27 & 8) != 0))
    {
      char v29 = atomic_load((unint64_t *)p_info);
      BOOL v30 = &theString->data;
      if ((v29 & 0x60) != 0)
      {
        char v31 = *v30;
      }

      else
      {
        char v32 = atomic_load((unint64_t *)&theString->info);
        char v31 = (char *)&v30[(v32 & 5) != 4LL];
      }

      unint64_t v33 = atomic_load((unint64_t *)&theString->info);
      UniChar v23 = &v31[(v33 >> 2) & 1];
    }

    else
    {
LABEL_21:
      UniChar v23 = 0LL;
    }
  }

  int64_t v98 = 0LL;
  int64_t v99 = 0LL;
  uint64_t v95 = v23;
  uint64_t v90 = length;
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    int64_t v34 = v97;
    if (v97 > a2)
    {
      if (v94)
      {
        int64_t v35 = 0LL;
        UniChar v36 = v94[v96 + a2];
      }

      else if (v23)
      {
        int64_t v35 = 0LL;
        UniChar v36 = v23[v96 + a2];
      }

      else
      {
        int64_t v38 = a2 - 4;
        if (v38 + 64 < v97) {
          int64_t v34 = v38 + 64;
        }
        int64_t v98 = v38;
        int64_t v99 = v34;
        v101.CFIndex location = v96 + v38;
        v101.uint64_t length = v34 - v38;
        CFStringGetCharacters(theStringa, v101, &buffer);
        int64_t v35 = v98;
        UniChar v36 = *(_WORD *)&v92[2 * (a2 - v98) - 2];
      }

      int64_t v37 = a2 - 1;
      if (v36 != 10) {
        goto LABEL_49;
      }
      int64_t v39 = v97;
      if (v97 < a2) {
        goto LABEL_49;
      }
      p_UniChar buffer = v94;
      if (v94)
      {
        int64_t v41 = v96 + v37;
      }

      else
      {
        if (v95)
        {
          UniChar v42 = v95[v96 + v37];
          goto LABEL_47;
        }

        if (v99 < a2 || v35 >= a2)
        {
          int64_t v86 = a2 - 5;
          if (v86 + 64 < v97) {
            int64_t v39 = v86 + 64;
          }
          int64_t v98 = v86;
          int64_t v99 = v39;
          v104.CFIndex location = v96 + v86;
          v104.uint64_t length = v39 - v86;
          CFStringGetCharacters(theStringa, v104, &buffer);
          int64_t v35 = v98;
        }

        int64_t v41 = v37 - v35;
        p_UniChar buffer = &buffer;
      }

      UniChar v42 = p_buffer[v41];
LABEL_47:
      if (v42 != 13) {
        goto LABEL_49;
      }
      int64_t v37 = a2 - 2;
      if (((a2 - 2) & 0x8000000000000000LL) == 0) {
        goto LABEL_49;
      }
LABEL_32:
      int64_t v28 = 0LL;
      uint64_t length = v90;
      goto LABEL_86;
    }
  }

  int64_t v35 = 0LL;
  int64_t v37 = a2 - 1;
  if (a2 - 1 < 0) {
    goto LABEL_32;
  }
LABEL_49:
  UniChar v89 = a6;
  int64_t v43 = -v37;
  int64_t v44 = v37 + 64;
  while (1)
  {
    else {
      uint64_t v45 = v37;
    }
    if (v97 <= v37)
    {
      UniChar v46 = 0;
      goto LABEL_78;
    }

    if (v94)
    {
      UniChar v46 = v94[v37 + v96];
    }

    else if (v95)
    {
      UniChar v46 = v95[v96 + v37];
    }

    else
    {
      BOOL v47 = v99 > v37 && v35 <= v37;
      if (!v47)
      {
        uint64_t v48 = -v45;
        uint64_t v49 = v45 + v43;
        int64_t v50 = v44 - v45;
        int64_t v51 = v37 + v48;
        int64_t v52 = v51 + 64;
        if (v51 + 64 >= v97) {
          int64_t v52 = v97;
        }
        int64_t v98 = v51;
        int64_t v99 = v52;
        v53.CFIndex location = v51 + v96;
        if (v97 >= v50) {
          int64_t v54 = v50;
        }
        else {
          int64_t v54 = v97;
        }
        v53.uint64_t length = v54 + v49;
        CFStringGetCharacters(theStringa, v53, &buffer);
        int64_t v35 = v98;
      }

      UniChar v46 = *(_WORD *)&v92[2 * v37 - 2 + -2 * v35];
    }

    BOOL v55 = v46 == 10 || v46 == 13;
    if (v55 || v46 == 8233) {
      break;
    }
LABEL_78:
    if (a7 && (v46 == 8232 || v46 == 133)) {
      break;
    }
LABEL_81:
    ++v43;
    --v44;
    BOOL v47 = v37-- <= 0;
    if (v47)
    {
      int64_t v28 = 0LL;
      goto LABEL_85;
    }
  }

  int64_t v28 = v37 + 1;
LABEL_85:
  a6 = v89;
  uint64_t length = v90;
LABEL_86:
  *a4 = v28;
LABEL_87:
  CFStringRef theStringa = theString;
  uint64_t v96 = 0LL;
  int64_t v97 = length;
  uint64_t v57 = CFStringGetCharactersPtr(theString);
  uint64_t v58 = 0LL;
  uint64_t v94 = (UniChar *)v57;
  if (!v57)
  {
    int v67 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      int v67 = __CFDefaultEightBitStringEncoding;
    }

    if (v67 == 1536)
    {
      if (!theString) {
        goto LABEL_142;
      }
    }

    else
    {
      if (v67 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v67 = __CFDefaultEightBitStringEncoding;
      }

      uint64_t v58 = 0LL;
      if (!theString || v67 != 1536) {
        goto LABEL_89;
      }
    }

    UniChar v73 = &theString->info;
    char v74 = atomic_load((unint64_t *)&theString->info);
    if ((v74 & 0x10) == 0 || (char v75 = atomic_load((unint64_t *)v73), (v75 & 8) != 0))
    {
      char v76 = atomic_load((unint64_t *)v73);
      unsigned int v77 = &theString->data;
      if ((v76 & 0x60) != 0)
      {
        uint64_t v78 = *v77;
      }

      else
      {
        char v79 = atomic_load((unint64_t *)&theString->info);
        uint64_t v78 = (char *)&v77[(v79 & 5) != 4LL];
      }

      unint64_t v80 = atomic_load((unint64_t *)&theString->info);
      uint64_t v58 = &v78[(v80 >> 2) & 1];
      goto LABEL_89;
    }

LABEL_142:
    uint64_t v58 = 0LL;
  }

                                      int64_t v19 = 2LL;
                                      char v14 = v107;
                                      uint64_t v15 = v114;
                                      char v16 = v111;
                                      uint64_t v17 = v22;
                                      goto LABEL_18;
                                    }

        if (a5)
        {
          *(a4 - 2) = -95;
          *(a4 - 1) = v33;
        }

        goto LABEL_41;
      case 63614:
        uint64_t v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
        char v14 = 42642LL;
        if (a5) {
          *((_WORD *)a4 - 1) = 20641;
        }
        goto LABEL_41;
      case 63615:
        UniChar v42 = *(a2 - 1);
        uint64_t v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
        char v14 = 42642LL;
        if (v42 > 0xFF07)
        {
          if (*(a2 - 1) > 0xFF3Bu)
          {
            if (*(a2 - 1) > 0xFF5Au)
            {
              if (v42 == 65371)
              {
                int64_t v44 = -95;
                int64_t v43 = -95;
                goto LABEL_155;
              }

              if (v42 != 65373) {
                goto LABEL_159;
              }
              int64_t v43 = -94;
              goto LABEL_151;
            }

            if (v42 != 65340)
            {
              if (v42 != 65343) {
                goto LABEL_159;
              }
              int64_t v43 = 90;
              goto LABEL_151;
            }

            int64_t v43 = 64;
            int64_t v44 = -94;
LABEL_155:
            if (!a5) {
              goto LABEL_41;
            }
            *(a4 - 2) = v44;
            goto LABEL_157;
          }

          switch(v42)
          {
            case 0xFF08u:
              int64_t v43 = 125;
              int64_t v44 = -95;
              goto LABEL_155;
            case 0xFF09u:
              int64_t v43 = 126;
              break;
            case 0xFF0Fu:
              int64_t v43 = -2;
              break;
            default:
              goto LABEL_159;
          }

void CFStringGetParagraphBounds( CFStringRef string, CFRange range, CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)string)) {
    -[__CFString getParagraphStart:end:contentsEnd:forRange:]( (id)string,  "getParagraphStart:end:contentsEnd:forRange:",  parBeginIndex,  parEndIndex,  contentsEndIndex,  location,  length);
  }
  else {
    __CFStringGetLineOrParagraphBounds( string,  location,  length,  parBeginIndex,  (unint64_t)parEndIndex,  contentsEndIndex,  0);
  }
}

CFStringRef CFStringCreateByCombiningStrings( CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  CFIndex Count = CFArrayGetCount(theArray);
  int v68 = CF_IS_OBJC(7uLL, (__objc2_class **)separatorString);
  if (v68)
  {
    BOOL v8 = 0;
  }

  else
  {
    char v9 = atomic_load((unint64_t *)&separatorString->info);
    BOOL v8 = (v9 & 0x10) == 0LL;
  }

  if (Count == 1)
  {
    uint64_t ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0LL);
    return CFStringCreateCopy(alloc, ValueAtIndex);
  }

  else
  {
    if (Count)
    {
      if (!alloc)
      {
        CFRange v18 = (const __CFAllocator *)_CFGetTSD(1u);
        if (v18) {
          alloc = v18;
        }
        else {
          alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
        }
      }

      CFStringRef theString = separatorString;
      CFIndex v19 = CFStringGetLength(separatorString) * (Count - 1);
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i != Count; ++i)
        {
          uint64_t v21 = (__CFString *)CFArrayGetValueAtIndex(theArray, i);
          CFIndex Length = CFStringGetLength(v21);
          if (CF_IS_OBJC(7uLL, (__objc2_class **)v21)
            || (char v23 = atomic_load((unint64_t *)&v21->info), (v23 & 0x10) != 0))
          {
            BOOL v8 = 0;
          }

          v19 += Length;
        }
      }

      uint64_t v63 = 2 * v19;
      if (v8) {
        CFIndex v24 = v19 + 1;
      }
      else {
        CFIndex v24 = 2 * v19;
      }
      UniChar v25 = (char *)CFAllocatorAllocate(alloc, v24, 0LL);
      if (!v25) {
        __CFStringHandleOutOfMemory();
      }
      CFAllocatorRef v64 = alloc;
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      char v69 = !v8;
      CFIndex v26 = CFStringGetLength(theString);
      __s = v25;
      if (Count >= 1)
      {
        CFIndex v27 = 0LL;
        int64_t v28 = 0LL;
        size_t v29 = v26 << v69;
        p_data = (uint64_t *)&theString->data;
        do
        {
          if (v27)
          {
            if (v28)
            {
              memmove(v25, v28, v29);
            }

            else
            {
              if (v68)
              {
                v70.CFIndex length = CFStringGetLength(theString);
                v70.CFIndex location = 0LL;
                CFStringGetCharacters(theString, v70, (UniChar *)v25);
              }

              else if (v8 || (char v30 = atomic_load((unint64_t *)&theString->info), (v30 & 0x10) != 0))
              {
                char v33 = atomic_load((unint64_t *)&theString->info);
                if ((v33 & 0x60) != 0)
                {
                  int64_t v34 = (uint64_t *)*p_data;
                }

                else
                {
                  char v35 = atomic_load((unint64_t *)&theString->info);
                  int64_t v34 = &p_data[(v35 & 5) != 4LL];
                }

                unint64_t v36 = atomic_load((unint64_t *)&theString->info);
                memmove(v25, (char *)v34 + ((v36 >> 2) & 1), v29);
              }

              else
              {
                char v31 = atomic_load((unint64_t *)&theString->info);
                if ((v31 & 0x60) != 0)
                {
                  char v32 = (unsigned __int8 *)*p_data;
                }

                else
                {
                  char v54 = atomic_load((unint64_t *)&theString->info);
                  char v32 = (unsigned __int8 *)&p_data[(v54 & 5) != 4LL];
                }

                unint64_t v55 = atomic_load((unint64_t *)&theString->info);
                char v56 = atomic_load((unint64_t *)&theString->info);
                char v57 = atomic_load((unint64_t *)&theString->info);
                uint64_t v58 = v57 & 0x60;
                if ((v56 & 5) == 4LL)
                {
                  if (v58)
                  {
                    uint64_t v59 = (uint64_t *)*p_data;
                  }

                  else
                  {
                    char v61 = atomic_load((unint64_t *)&theString->info);
                    uint64_t v59 = &p_data[(v61 & 5) != 4LL];
                  }

                  uint64_t v60 = *(unsigned __int8 *)v59;
                }

                else if (v58)
                {
                  uint64_t v60 = theString->length;
                }

                else
                {
                  uint64_t v60 = *p_data;
                }

                __CFStrConvertBytesToUnicode(&v32[(v55 >> 2) & 1], v25, v60);
              }

              int64_t v28 = v25;
            }

            v25 += v29;
          }

          int64_t v37 = (__CFString *)CFArrayGetValueAtIndex(theArray, v27);
          if (CF_IS_OBJC(7uLL, (__objc2_class **)v37))
          {
            CFIndex v38 = CFStringGetLength(v37);
            v71.CFIndex location = 0LL;
            v71.CFIndex length = v38;
            CFStringGetCharacters(v37, v71, (UniChar *)v25);
            size_t v39 = 2 * v38;
          }

          else
          {
            char v40 = atomic_load((unint64_t *)&v37->info);
            int64_t v41 = (uint64_t *)&v37->data;
            if ((v40 & 0x60) != 0)
            {
              UniChar v42 = (unsigned __int8 **)*v41;
            }

            else
            {
              char v43 = atomic_load((unint64_t *)&v37->info);
              UniChar v42 = (unsigned __int8 **)&v41[(v43 & 5) != 4LL];
            }

            char v44 = atomic_load((unint64_t *)&v37->info);
            if ((v44 & 5) == 4LL)
            {
              uint64_t v45 = *(unsigned __int8 *)v42;
            }

            else
            {
              char v46 = atomic_load((unint64_t *)&v37->info);
              if ((v46 & 0x60) != 0) {
                uint64_t v45 = v37->length;
              }
              else {
                uint64_t v45 = *v41;
              }
            }

            size_t v39 = v45 << v69;
            if (v8
              || (p_info = (unint64_t *)&v37->info,
                  char v48 = atomic_load((unint64_t *)&v37->info),
                  (v48 & 0x10) != 0))
            {
              unint64_t v52 = atomic_load((unint64_t *)&v37->info);
              memmove(v25, (char *)v42 + ((v52 >> 2) & 1), v39);
            }

            else
            {
              unint64_t v49 = atomic_load(p_info);
              char v50 = atomic_load(p_info);
              if ((v50 & 5) == 4LL)
              {
                uint64_t v51 = *(unsigned __int8 *)v42;
              }

              else
              {
                char v53 = atomic_load((unint64_t *)&v37->info);
                if ((v53 & 0x60) != 0) {
                  uint64_t v51 = v37->length;
                }
                else {
                  uint64_t v51 = *v41;
                }
              }

              __CFStrConvertBytesToUnicode((unsigned __int8 *)v42 + ((v49 >> 2) & 1), v25, v51);
            }
          }

          v25 += v39;
          ++v27;
        }

        while (Count != v27);
      }

      if (v8)
      {
        *UniChar v25 = 0;
        uint64_t v62 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding();
          uint64_t v62 = __CFDefaultEightBitStringEncoding;
        }

        size_t v12 = strlen(__s);
        UniChar v10 = (__objc2_class **)v64;
        CFIndex v11 = (int8x16_t *)__s;
        uint64_t v13 = v62;
        uint64_t v14 = 24LL;
        uint64_t v15 = (uint64_t)v64;
      }

      else
      {
        size_t v12 = v63;
        UniChar v10 = (__objc2_class **)v64;
        CFIndex v11 = (int8x16_t *)__s;
        uint64_t v13 = 256LL;
        uint64_t v14 = 16LL;
        uint64_t v15 = (uint64_t)v64;
      }
    }

    else
    {
      UniChar v10 = (__objc2_class **)alloc;
      CFIndex v11 = 0LL;
      size_t v12 = 0LL;
      uint64_t v13 = 256LL;
      uint64_t v14 = 2LL;
      uint64_t v15 = -1LL;
    }

    return (CFStringRef)__CFStringCreateImmutableFunnel3(v10, v11, v12, v13, v14, v15, 0LL, v7);
  }

CFArrayRef CFStringCreateArrayBySeparatingStrings( CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  v17[1] = *(const void **)MEMORY[0x1895F89C0];
  v17[0] = theString;
  CFIndex Length = CFStringGetLength(theString);
  v20.CFIndex location = 0LL;
  v20.CFIndex length = Length;
  Results = CFStringCreateArrayWithFindResults(alloc, theString, separatorString, v20, 0LL);
  if (!Results) {
    return CFArrayCreate(alloc, v17, 1LL, &kCFTypeArrayCallBacks);
  }
  BOOL v8 = Results;
  CFIndex Count = CFArrayGetCount(Results);
  CFMutableStringRef Mutable = CFArrayCreateMutable(alloc, Count + 2, &kCFTypeArrayCallBacks);
  if (Count < 1)
  {
    CFIndex v12 = 0LL;
  }

  else
  {
    CFIndex v11 = 0LL;
    CFIndex v12 = 0LL;
    do
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v8, v11);
      v18.CFIndex length = *ValueAtIndex - v12;
      v18.CFIndex location = v12;
      CFStringRef v14 = CFStringCreateWithSubstring(alloc, theString, v18);
      CFArrayAppendValue(Mutable, v14);
      CFRelease(v14);
      CFIndex v12 = ValueAtIndex[1] + *ValueAtIndex;
      ++v11;
    }

    while (Count != v11);
  }

  v19.CFIndex length = Length - v12;
  v19.CFIndex location = v12;
  CFStringRef v15 = CFStringCreateWithSubstring(alloc, theString, v19);
  CFArrayAppendValue(Mutable, v15);
  CFRelease(v15);
  CFRelease(v8);
  return Mutable;
}

CFStringRef CFStringCreateFromExternalRepresentation( CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  uint64_t v3 = *(void *)&encoding;
  BytePtr = (int8x16_t *)CFDataGetBytePtr(data);
  CFIndex Length = CFDataGetLength(data);
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, BytePtr, Length, v3, 3LL, -1LL, 0LL, v8);
}

CFDataRef CFStringCreateExternalRepresentation( CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  unsigned int v4 = lossByte;
  uint64_t v5 = *(void *)&encoding;
  size[1] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    CFIndex data = CFStringGetLength(theString);
  }

  else
  {
    char v9 = atomic_load((unint64_t *)&theString->info);
    uint64_t v10 = v9 & 5;
    char v11 = atomic_load((unint64_t *)&theString->info);
    uint64_t v12 = v11 & 0x60;
    if (v10 == 4)
    {
      p_CFIndex data = &theString->data;
      if (v12)
      {
        CFStringRef v14 = *p_data;
      }

      else
      {
        uint64_t v15 = atomic_load((unint64_t *)&theString->info);
        CFStringRef v14 = (char *)&p_data[(v15 & 5) != 4];
      }

      CFIndex data = *v14;
    }

    else if ((v11 & 0x60) != 0)
    {
      CFIndex data = theString->length;
    }

    else
    {
      CFIndex data = (CFIndex)theString->data;
    }

    char v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 0x10) == 0)
    {
      int v17 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v17 = __CFDefaultEightBitStringEncoding;
      }

      if (v17 == (_DWORD)v5) {
        goto LABEL_15;
      }
      if (v17 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        int v17 = __CFDefaultEightBitStringEncoding;
      }

      if (v17 == 1536)
      {
        switch(BYTE1(v5))
        {
          case 0:
            goto LABEL_15;
          case 1:
            if ((_DWORD)v5 != 134217984) {
              goto LABEL_48;
            }
            goto LABEL_15;
          case 2:
            if ((_DWORD)v5 == 518) {
              goto LABEL_48;
            }
            goto LABEL_15;
          case 6:
            if ((_DWORD)v5 != 1536) {
              goto LABEL_48;
            }
            goto LABEL_15;
          case 8:
          case 0xC:
            goto LABEL_48;
          case 0xA:
            int v30 = 1 << (v5 - 1);
            int v31 = 32785;
            break;
          case 0xB:
            int v30 = 1 << (v5 + 13);
            int v31 = 4099;
            break;
          default:
            goto LABEL_15;
        }

        if ((v30 & v31) == 0)
        {
LABEL_15:
          char v18 = atomic_load((unint64_t *)&theString->info);
          CFRange v19 = &theString->data;
          if ((v18 & 0x60) != 0)
          {
            CFRange v20 = *v19;
          }

          else
          {
            char v21 = atomic_load((unint64_t *)&theString->info);
            CFRange v20 = (char *)&v19[(v21 & 5) != 4LL];
          }

          unint64_t v22 = atomic_load((unint64_t *)&theString->info);
          char v23 = atomic_load((unint64_t *)&theString->info);
          char v24 = atomic_load((unint64_t *)&theString->info);
          uint64_t v25 = v24 & 0x60;
          if ((v23 & 5) == 4LL)
          {
            if (v25)
            {
              CFIndex v26 = *v19;
            }

            else
            {
              uint64_t v28 = atomic_load((unint64_t *)&theString->info);
              CFIndex v26 = (char *)&v19[(v28 & 5) != 4];
            }

            CFIndex v27 = *v26;
          }

          else if (v25)
          {
            CFIndex v27 = theString->length;
          }

          else
          {
            CFIndex v27 = (CFIndex)*v19;
          }

          return CFDataCreate(alloc, (const UInt8 *)&v20[(v22 >> 2) & 1], v27);
        }
      }
    }
  }

CFStringEncoding CFStringGetSmallestEncoding(CFStringRef theString)
{
  p_info = &theString->info;
  char v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 0x10) != 0)
  {
    char v6 = atomic_load((unint64_t *)p_info);
    uint64_t v7 = v6 & 5;
    char v8 = atomic_load((unint64_t *)p_info);
    uint64_t v9 = v8 & 0x60;
    if (v7 == 4)
    {
      p_CFIndex data = &theString->data;
      if (v9)
      {
        char v11 = *p_data;
      }

      else
      {
        uint64_t v13 = atomic_load((unint64_t *)&theString->info);
        char v11 = (char *)&p_data[(v13 & 5) != 4];
      }

      CFIndex length = *v11;
    }

    else if ((v8 & 0x60) != 0)
    {
      CFIndex length = theString->length;
    }

    else
    {
      CFIndex length = (CFIndex)theString->data;
    }

    uint64_t v14 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      uint64_t v14 = __CFDefaultEightBitStringEncoding;
    }

    v17.CFIndex location = 0LL;
    v17.CFIndex length = length;
    CFIndex v15 = __CFStringEncodeByteStream(theString, v17, 0, v14, 0, 0LL, 0x7FFFFFFFFFFFFFFFLL, 0LL);
    CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
    if (v15 == length)
    {
      if (__CFDefaultEightBitStringEncoding != -1) {
        return v5;
      }
      goto LABEL_5;
    }

    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
    }

    if ((__CFDefaultSystemEncoding & 1) != 0)
    {
      if (!v5) {
        return 256;
      }
    }

    else
    {
      CFStringGetSystemEncoding();
      if ((__CFDefaultSystemEncoding & 1) == 0)
      {
        CFStringGetSystemEncoding();
        uint64_t v16 = __CFDefaultSystemEncoding - 1;
LABEL_28:
        v18.CFIndex location = 0LL;
        v18.CFIndex length = length;
        if (__CFStringEncodeByteStream(theString, v18, 0, v16, 0, 0LL, 0x7FFFFFFFFFFFFFFFLL, 0LL) == length)
        {
          if ((__CFDefaultSystemEncoding & 1) != 0) {
            return 0;
          }
          CFStringGetSystemEncoding();
          return __CFDefaultSystemEncoding - 1;
        }

        return 256;
      }
    }

    uint64_t v16 = 0LL;
    goto LABEL_28;
  }

  CFStringEncoding v5 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
LABEL_5:
    __CFStringComputeEightBitStringEncoding();
    return __CFDefaultEightBitStringEncoding;
  }

  return v5;
}

CFStringEncoding CFStringGetFastestEncoding(CFStringRef theString)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 0x10) != 0) {
    return 256;
  }
  CFStringEncoding result = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    return __CFDefaultEightBitStringEncoding;
  }

  return result;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v5 = 0;
  CFStringRef v7 = str;
  uint64_t v10 = 0LL;
  CFIndex Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v7);
  uint64_t CStringPtrInternal = 0LL;
  char v8 = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)str, 0x600u, 0, 1);
  }
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v9 = CStringPtrInternal;
  else {
    return 0;
  }
}

double CFStringGetDoubleValue(CFStringRef str)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  int v6 = 0;
  CFStringRef v9 = str;
  uint64_t v12 = 0LL;
  CFIndex Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v9);
  uint64_t CStringPtrInternal = 0LL;
  uint64_t v10 = CharactersPtr;
  if (!CharactersPtr) {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)str, 0x600u, 0, 1);
  }
  uint64_t v11 = CStringPtrInternal;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  int v4 = __CFStringScanDouble(buffer, 0LL, &v6, &v7);
  double result = v7;
  if (!v4) {
    return 0.0;
  }
  return result;
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  v30[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)str))
  {
    -[__CFString insertString:atIndex:](str, "insertString:atIndex:", insertedStr, idx);
    return;
  }

  char v6 = atomic_load((unint64_t *)&str->info);
  if ((v6 & 1) == 0)
  {
    double v7 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringInsert_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }

  if (insertedStr == str)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, str);
    insertedStr = Copy;
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFIndex Length = CFStringGetLength(insertedStr);
  if (Length < 1)
  {
    BOOL v18 = 0;
  }

  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)insertedStr))
    {
      int v17 = -[__CFString _encodingCantBeStoredInEightBitCFString]( (id)insertedStr,  "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v19 = atomic_load((unint64_t *)&insertedStr->info);
      int v17 = (v19 >> 4) & 1;
    }

    BOOL v18 = v17 != 0;
  }

  v30[0] = idx;
  v30[1] = 0LL;
  __CFStringChangeSizeMultiple((char *)str, (uint64_t)v30, 1LL, Length, v18);
  char v20 = atomic_load((unint64_t *)&str->info);
  char v21 = atomic_load((unint64_t *)&str->info);
  uint64_t v22 = v21 & 0x60;
  p_CFIndex data = &str->data;
  if ((v20 & 0x10) == 0)
  {
    if (v22)
    {
      char v24 = *p_data;
    }

    else
    {
      uint64_t v26 = atomic_load((unint64_t *)&str->info);
      char v24 = (char *)&p_data[(v26 & 5) != 4];
    }

    CFStringEncoding v27 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v27 = __CFDefaultEightBitStringEncoding;
    }

    unint64_t v28 = atomic_load((unint64_t *)&str->info);
    v31.CFIndex location = 0LL;
    v31.CFIndex length = Length;
    CFStringGetBytes(insertedStr, v31, v27, 0, 0, (UInt8 *)&v24[idx + ((v28 >> 2) & 1)], Length, 0LL);
    goto LABEL_27;
  }

  if (!v22)
  {
    uint64_t v29 = atomic_load((unint64_t *)&str->info);
    uint64_t v25 = (char *)&p_data[(v29 & 5) != 4];
    if (!v25) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  uint64_t v25 = *p_data;
  if (v25)
  {
LABEL_26:
    v32.CFIndex location = 0LL;
    v32.CFIndex length = Length;
    CFStringGetCharacters(insertedStr, v32, (UniChar *)&v25[2 * idx]);
  }

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  void v14[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString deleteCharactersInRange:](theString, "deleteCharactersInRange:", location, length);
  }

  else
  {
    char v5 = atomic_load((unint64_t *)&theString->info);
    if ((v5 & 1) != 0)
    {
      v14[0] = location;
      v14[1] = length;
      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)v14, 1LL, 0LL, 0);
    }

    else
    {
      char v6 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        CFStringDelete_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  v31[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString replaceCharactersInRange:withString:]( theString,  "replaceCharactersInRange:withString:",  location,  length,  replacement);
    return;
  }

  char v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    uint64_t v8 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      CFStringReplace_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return;
  }

  if (replacement == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFIndex v17 = CFStringGetLength(replacement);
  if (v17 < 1)
  {
    BOOL v19 = 0;
  }

  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)replacement))
    {
      int v18 = -[__CFString _encodingCantBeStoredInEightBitCFString]( (id)replacement,  "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v20 = atomic_load((unint64_t *)&replacement->info);
      int v18 = (v20 >> 4) & 1;
    }

    BOOL v19 = v18 != 0;
  }

  v31[0] = location;
  v31[1] = length;
  __CFStringChangeSizeMultiple((char *)theString, (uint64_t)v31, 1LL, v17, v19);
  char v21 = atomic_load((unint64_t *)&theString->info);
  char v22 = atomic_load((unint64_t *)&theString->info);
  uint64_t v23 = v22 & 0x60;
  p_CFIndex data = &theString->data;
  if ((v21 & 0x10) == 0)
  {
    if (v23)
    {
      uint64_t v25 = *p_data;
    }

    else
    {
      uint64_t v27 = atomic_load((unint64_t *)&theString->info);
      uint64_t v25 = (char *)&p_data[(v27 & 5) != 4];
    }

    CFStringEncoding v28 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v28 = __CFDefaultEightBitStringEncoding;
    }

    unint64_t v29 = atomic_load((unint64_t *)&theString->info);
    v32.CFIndex location = 0LL;
    v32.CFIndex length = v17;
    CFStringGetBytes(replacement, v32, v28, 0, 0, (UInt8 *)&v25[location + ((v29 >> 2) & 1)], v17, 0LL);
    goto LABEL_27;
  }

  if (!v23)
  {
    uint64_t v30 = atomic_load((unint64_t *)&theString->info);
    uint64_t v26 = (char *)&p_data[(v30 & 5) != 4];
    if (!v26) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  uint64_t v26 = *p_data;
  if (v26)
  {
LABEL_26:
    v33.CFIndex location = 0LL;
    v33.CFIndex length = v17;
    CFStringGetCharacters(replacement, v33, (UniChar *)&v26[2 * location]);
  }

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
  v37[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString setString:](theString, "setString:", replacement);
    return;
  }

  p_info = &theString->info;
  char v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    char v6 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      CFStringReplaceAll_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    return;
  }

  char v14 = atomic_load((unint64_t *)p_info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_CFIndex data = &theString->data;
    if (v17)
    {
      BOOL v19 = *p_data;
    }

    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      BOOL v19 = (char *)&p_data[(v21 & 5) != 4];
    }

    uint64_t length = *v19;
  }

  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  if (replacement == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFIndex v23 = CFStringGetLength(replacement);
  if (v23 < 1)
  {
    BOOL v25 = 0;
  }

  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)replacement))
    {
      int v24 = -[__CFString _encodingCantBeStoredInEightBitCFString]( (id)replacement,  "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v26 = atomic_load((unint64_t *)&replacement->info);
      int v24 = (v26 >> 4) & 1;
    }

    BOOL v25 = v24 != 0;
  }

  v37[0] = 0LL;
  v37[1] = length;
  __CFStringChangeSizeMultiple((char *)theString, (uint64_t)v37, 1LL, v23, v25);
  char v27 = atomic_load((unint64_t *)&theString->info);
  char v28 = atomic_load((unint64_t *)&theString->info);
  uint64_t v29 = v28 & 0x60;
  uint64_t v30 = &theString->data;
  if ((v27 & 0x10) == 0)
  {
    if (v29)
    {
      CFRange v31 = *v30;
    }

    else
    {
      uint64_t v33 = atomic_load((unint64_t *)&theString->info);
      CFRange v31 = (char *)&v30[(v33 & 5) != 4];
    }

    CFStringEncoding v34 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v34 = __CFDefaultEightBitStringEncoding;
    }

    unint64_t v35 = atomic_load((unint64_t *)&theString->info);
    v38.CFIndex location = 0LL;
    v38.uint64_t length = v23;
    CFStringGetBytes(replacement, v38, v34, 0, 0, (UInt8 *)&v31[(v35 >> 2) & 1], v23, 0LL);
    goto LABEL_35;
  }

  if (!v29)
  {
    uint64_t v36 = atomic_load((unint64_t *)&theString->info);
    CFRange v32 = (UniChar *)&v30[(v36 & 5) != 4];
    if (!v32) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }

  CFRange v32 = (UniChar *)*v30;
  if (*v30)
  {
LABEL_34:
    v39.CFIndex location = 0LL;
    v39.uint64_t length = v23;
    CFStringGetCharacters(replacement, v39, v32);
  }

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  v37[2] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString appendString:](theString, "appendString:", appendedString);
    return;
  }

  p_info = &theString->info;
  char v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    char v6 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
      CFStringAppend_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    return;
  }

  char v14 = atomic_load((unint64_t *)p_info);
  uint64_t v15 = v14 & 5;
  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_CFIndex data = &theString->data;
    if (v17)
    {
      BOOL v19 = *p_data;
    }

    else
    {
      uint64_t v21 = atomic_load((unint64_t *)&theString->info);
      BOOL v19 = (char *)&p_data[(v21 & 5) != 4];
    }

    uint64_t length = *v19;
  }

  else if ((v16 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  if (appendedString == theString)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    appendedString = Copy;
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFIndex v23 = CFStringGetLength(appendedString);
  if (v23 < 1)
  {
    BOOL v25 = 0;
  }

  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)appendedString))
    {
      int v24 = -[__CFString _encodingCantBeStoredInEightBitCFString]( (id)appendedString,  "_encodingCantBeStoredInEightBitCFString");
    }

    else
    {
      unsigned int v26 = atomic_load((unint64_t *)&appendedString->info);
      int v24 = (v26 >> 4) & 1;
    }

    BOOL v25 = v24 != 0;
  }

  v37[0] = length;
  v37[1] = 0LL;
  __CFStringChangeSizeMultiple((char *)theString, (uint64_t)v37, 1LL, v23, v25);
  char v27 = atomic_load((unint64_t *)&theString->info);
  char v28 = atomic_load((unint64_t *)&theString->info);
  uint64_t v29 = v28 & 0x60;
  uint64_t v30 = &theString->data;
  if ((v27 & 0x10) == 0)
  {
    if (v29)
    {
      CFRange v31 = *v30;
    }

    else
    {
      uint64_t v33 = atomic_load((unint64_t *)&theString->info);
      CFRange v31 = (char *)&v30[(v33 & 5) != 4];
    }

    CFStringEncoding v34 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v34 = __CFDefaultEightBitStringEncoding;
    }

    unint64_t v35 = atomic_load((unint64_t *)&theString->info);
    v38.CFIndex location = 0LL;
    v38.uint64_t length = v23;
    CFStringGetBytes(appendedString, v38, v34, 0, 0, (UInt8 *)&v31[length + ((v35 >> 2) & 1)], v23, 0LL);
    goto LABEL_35;
  }

  if (!v29)
  {
    uint64_t v36 = atomic_load((unint64_t *)&theString->info);
    CFRange v32 = (char *)&v30[(v36 & 5) != 4];
    if (!v32) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }

  CFRange v32 = *v30;
  if (v32)
  {
LABEL_34:
    v39.CFIndex location = 0LL;
    v39.uint64_t length = v23;
    CFStringGetCharacters(appendedString, v39, (UniChar *)&v32[2 * length]);
  }

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString appendCharacters:length:](theString, "appendCharacters:length:", chars, numChars);
    return;
  }

  p_info = &theString->info;
  char v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    uint64_t v8 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      CFStringAppendCharacters_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return;
  }

  char v16 = atomic_load((unint64_t *)p_info);
  uint64_t v17 = v16 & 5;
  char v18 = atomic_load((unint64_t *)p_info);
  uint64_t v19 = v18 & 0x60;
  if (v17 == 4)
  {
    p_CFIndex data = &theString->data;
    if (v19)
    {
      uint64_t v21 = *p_data;
    }

    else
    {
      uint64_t v23 = atomic_load((unint64_t *)&theString->info);
      uint64_t v21 = (char *)&p_data[(v23 & 5) != 4];
    }

    uint64_t length = *v21;
  }

  else if ((v18 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  char v24 = atomic_load((unint64_t *)&theString->info);
  if ((v24 & 0x10) != 0)
  {
    uint64_t v41 = length;
    uint64_t v42 = 0LL;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v41, 1LL, numChars, 1);
    char v31 = atomic_load((unint64_t *)&theString->info);
    uint64_t v30 = &theString->data;
    if ((v31 & 0x60) == 0)
    {
      char v28 = &theString->info;
LABEL_31:
      char v36 = atomic_load((unint64_t *)v28);
      CFRange v32 = (char *)&v30[(v36 & 5) != 4LL];
      goto LABEL_32;
    }

void __CFStringAppendBytes(unint64_t *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if ((_DWORD)a4 == 1536) {
    goto LABEL_5;
  }
  int v8 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    int v8 = __CFDefaultEightBitStringEncoding;
  }

  if (v8 == (_DWORD)a4)
  {
LABEL_5:
    BOOL v9 = 0;
    int v10 = 0;
    int v11 = 0;
    goto LABEL_6;
  }

  if ((_DWORD)a4 == 256)
  {
    if (a3 >= 2)
    {
      unint64_t v40 = 0LL;
      do
      {
        unsigned int v41 = *(unsigned __int16 *)&a2[2 * v40];
        BOOL v9 = v41 < 0x80;
        ++v40;
      }

      while (v41 <= 0x7F && v40 < a3 >> 1);
    }

    else
    {
      BOOL v9 = 1;
    }

    int v10 = 0;
    int v11 = !v9;
    a3 >>= 1;
LABEL_6:
    if (CF_IS_OBJC(7uLL, (__objc2_class **)a1))
    {
      if (v9 | v11) {
        [a1 appendCharacters:a2 length:a3];
      }
      else {
        [a1 _cfAppendCString:a2 length:a3];
      }
      return;
    }

    char v12 = atomic_load(a1 + 1);
    uint64_t v13 = v12 & 5;
    char v14 = atomic_load(a1 + 1);
    uint64_t v15 = v14 & 0x60;
    if (v13 == 4)
    {
      char v16 = (unsigned __int8 ***)(a1 + 2);
      if (v15)
      {
        uint64_t v17 = *v16;
      }

      else
      {
        uint64_t v23 = atomic_load(a1 + 1);
        uint64_t v17 = (unsigned __int8 **)&v16[(v23 & 5) != 4];
      }

      unint64_t v18 = *(unsigned __int8 *)v17;
      if ((v11 & 1) != 0) {
        goto LABEL_30;
      }
LABEL_32:
      unint64_t v25 = atomic_load(a1 + 1);
      uint64_t v24 = (v25 >> 4) & 1;
LABEL_33:
      v51[0] = v18;
      v51[1] = 0LL;
      __CFStringChangeSizeMultiple((char *)a1, (uint64_t)v51, 1LL, a3, v24);
      unsigned int v26 = a1 + 1;
      char v27 = atomic_load(a1 + 1);
      if ((v27 & 0x10) != 0)
      {
        char v32 = atomic_load(v26);
        char v33 = a1 + 2;
        if ((v32 & 0x60) != 0)
        {
          CFStringEncoding v34 = (void *)*v33;
        }

        else
        {
          char v36 = atomic_load(a1 + 1);
          CFStringEncoding v34 = &v33[(v36 & 5) != 4LL];
        }

        if (!v11)
        {
          __CFStrConvertBytesToUnicode(a2, (_WORD *)v34 + v18, a3);
          goto LABEL_60;
        }

        size_t v37 = 2 * a3;
        unint64_t v38 = (char *)v34 + 2 * v18;
        CFRange v39 = a2;
      }

      else
      {
        char v28 = atomic_load(v26);
        uint64_t v29 = v28 & 0x60;
        uint64_t v30 = a1 + 2;
        if (v9)
        {
          if (v29)
          {
            char v31 = (void *)*v30;
          }

          else
          {
            uint64_t v43 = atomic_load(a1 + 1);
            char v31 = &v30[(v43 & 5) != 4];
          }

          unint64_t v44 = atomic_load(a1 + 1);
          if ((uint64_t)a3 >= 1)
          {
            uint64_t v45 = (unsigned __int8 *)v31 + v18 + ((v44 >> 2) & 1);
            char v46 = a2;
            do
            {
              unsigned __int8 v47 = *v46;
              v46 += 2;
              *v45++ = v47;
              --a3;
            }

            while (a3);
          }

          goto LABEL_60;
        }

        if (v29)
        {
          unint64_t v35 = (void *)*v30;
        }

        else
        {
          uint64_t v48 = atomic_load(a1 + 1);
          unint64_t v35 = &v30[(v48 & 5) != 4];
        }

        unint64_t v49 = atomic_load(a1 + 1);
        unint64_t v38 = (char *)v35 + v18 + ((v49 >> 2) & 1);
        CFRange v39 = a2;
        size_t v37 = a3;
      }

      memmove(v38, v39, v37);
LABEL_60:
      if (v10)
      {
        int v50 = (const __CFAllocator *)_CFGetTSD(1u);
        if (!v50) {
          int v50 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        }
        CFAllocatorDeallocate(v50, a2);
      }

      return;
    }

    if ((v14 & 0x60) != 0)
    {
      unint64_t v18 = a1[3];
      if ((v11 & 1) == 0) {
        goto LABEL_32;
      }
    }

    else
    {
      unint64_t v18 = a1[2];
      if ((v11 & 1) == 0) {
        goto LABEL_32;
      }
    }

void CFStringAppendPascalString(CFMutableStringRef theString, ConstStr255Param pStr, CFStringEncoding encoding)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)pStr + 1, *pStr, *(uint64_t *)&encoding);
  }

  else
  {
    int v4 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendPascalString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    uint64_t v12 = *(void *)&encoding;
    size_t v15 = strlen(cStr);
    __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)cStr, v15, v12);
  }

  else
  {
    int v4 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringAppendCString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

void CFStringAppendFormatAndArguments( CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  char v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) != 0)
  {
    if (!__CFStringAppendFormatCore(theString, 0LL, 0LL, formatOptions, 0LL, 0LL, 0LL))
    {
      CFLog(3LL, (uint64_t)@"ERROR: Failed to format string: %@", v13, v14, v15, v16, v17, v18, (uint64_t)v19);
      if (v19) {
        CFRelease(v19);
      }
    }
  }

  else
  {
    uint64_t v5 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringAppendFormatAndArguments_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }

CFIndex CFStringFindAndReplace( CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length = rangeToSearch.length;
  CFIndex location = rangeToSearch.location;
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString)) {
    return -[__CFString replaceOccurrencesOfString:withString:options:range:]( theString,  "replaceOccurrencesOfString:withString:options:range:",  stringToFind,  replacementString,  compareOptions,  location,  length);
  }
  if (length < 1) {
    return 0LL;
  }
  CFStringRef theStringa = theString;
  CFStringRef v63 = replacementString;
  uint64_t v12 = 0LL;
  unint64_t v13 = 0LL;
  unsigned int v14 = compareOptions;
  uint64_t v15 = (location + length);
  CFStringCompareFlags v64 = compareOptions;
  uint64_t v16 = 62LL;
  uint64_t v17 = (uint64_t *)__src;
  while (1)
  {
    v72.CFIndex location = location;
    v72.uint64_t length = length;
    if (!CFStringFindWithOptionsAndLocale(theStringa, stringToFind, v72, compareOptions, 0LL, &result)) {
      break;
    }
    if (((v14 >> 2) & 1) != 0)
    {
      uint64_t length = result.location - location;
    }

    else
    {
      CFIndex location = result.length + result.location;
      uint64_t length = v15 - (result.length + result.location);
    }

    if ((uint64_t)v13 >= v16)
    {
      uint64_t v16 = 2 * v16 + 8;
      else {
        uint64_t v18 = v17;
      }
      uint64_t v19 = (uint64_t *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v18,  16 * v16,  0LL,  0LL);
      BOOL v20 = v17 == (uint64_t *)__src;
      uint64_t v17 = v19;
      if (v20) {
        memmove(v19, __src, 0x3E0uLL);
      }
      compareOptions = v64;
    }

    *(CFRange *)&v17[v12] = result;
    ++v13;
    v12 += 2LL;
    if (length <= 0) {
      goto LABEL_20;
    }
  }

  if (!(v12 * 8)) {
    return 0LL;
  }
LABEL_20:
  if ((v14 & 4) != 0)
  {
    uint64_t v21 = (v13 - 1);
    if ((int)v21 >= 1)
    {
      uint64_t v22 = 0LL;
      uint64_t v23 = v21 - 1;
      uint64_t v24 = (__int128 *)v17;
      unint64_t v25 = (__int128 *)&v17[2 * v21];
      do
      {
        __int128 v66 = *v24;
        *v24++ = *v25;
        *v25-- = v66;
      }

      while (++v22 < v23--);
    }
  }

  char v27 = atomic_load((unint64_t *)&theStringa->info);
  if ((v27 & 1) != 0)
  {
    char v36 = (__CFString *)v63;
    if (v63 == theStringa)
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theStringa);
      char v36 = (__CFString *)Copy;
    }

    else
    {
      CFStringRef Copy = 0LL;
    }

    CFIndex v38 = CFStringGetLength(v36);
    if (v38 < 1)
    {
      BOOL v40 = 0;
    }

    else
    {
      if (CF_IS_OBJC(7uLL, (__objc2_class **)v36))
      {
        int v39 = -[__CFString _encodingCantBeStoredInEightBitCFString](v36, "_encodingCantBeStoredInEightBitCFString");
      }

      else
      {
        unsigned int v41 = atomic_load((unint64_t *)&v36->info);
        int v39 = (v41 >> 4) & 1;
      }

      BOOL v40 = v39 != 0;
    }

    __CFStringChangeSizeMultiple((char *)theStringa, (uint64_t)v17, v13, v38, v40);
    char v42 = atomic_load((unint64_t *)&theStringa->info);
    char v43 = atomic_load((unint64_t *)&theStringa->info);
    uint64_t v44 = v43 & 0x60;
    p_CFIndex data = &theStringa->data;
    if ((v42 & 0x10) != 0)
    {
      if (v44)
      {
        unsigned __int8 v47 = *p_data;
      }

      else
      {
        uint64_t v58 = atomic_load((unint64_t *)&theStringa->info);
        unsigned __int8 v47 = (char *)&p_data[(v58 & 5) != 4];
      }

      uint64_t v59 = (UniChar *)&v47[2 * *v17];
      v71.CFIndex location = 0LL;
      v71.uint64_t length = v38;
      CFStringGetCharacters(v36, v71, v59);
      if (v13 >= 2)
      {
        unint64_t v60 = v13 - 1;
        uint64_t v61 = v17 + 2;
        do
        {
          v47 += 2 * (v38 - *(v61 - 1));
          uint64_t v62 = *v61;
          v61 += 2;
          memmove(&v47[2 * v62], v59, 2 * v38);
          --v60;
        }

        while (v60);
      }
    }

    else
    {
      if (v44)
      {
        char v46 = (char **)*p_data;
      }

      else
      {
        uint64_t v48 = atomic_load((unint64_t *)&theStringa->info);
        char v46 = &p_data[(v48 & 5) != 4];
      }

      unint64_t v49 = (char *)v46 + *v17;
      unint64_t v50 = atomic_load((unint64_t *)&theStringa->info);
      int v51 = (UInt8 *)&v49[(v50 >> 2) & 1];
      CFStringEncoding v52 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFStringEncoding v52 = __CFDefaultEightBitStringEncoding;
      }

      v70.CFIndex location = 0LL;
      v70.uint64_t length = v38;
      CFStringGetBytes(v36, v70, v52, 0, 0, v51, v38, 0LL);
      unint64_t v53 = atomic_load((unint64_t *)&theStringa->info);
      if (v13 >= 2)
      {
        char v54 = (char *)v46 + ((v53 >> 2) & 1);
        unint64_t v55 = v13 - 1;
        unint64_t v56 = v17 + 2;
        do
        {
          v54 += v38 - *(v56 - 1);
          uint64_t v57 = *v56;
          v56 += 2;
          memmove(&v54[v57], v51, v38);
          --v55;
        }

        while (v55);
      }
    }

    if (Copy) {
      CFRelease(Copy);
    }
  }

  else
  {
    char v28 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT)) {
      CFStringFindAndReplace_cold_1(v28, v29, v30, v31, v32, v33, v34, v35);
    }
  }

  return v13;
}

uint64_t __CFStringCheckAndReplace(__CFString *theString, unint64_t a2, uint64_t a3, __CFString *a4)
{
  v34[2] = *MEMORY[0x1895F89C0];
  char v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) == 0) {
    return 1LL;
  }
  uint64_t v6 = a4;
  if (!a4) {
    return 2LL;
  }
  unint64_t v10 = a2 + a3;
  char v11 = atomic_load((unint64_t *)&theString->info);
  uint64_t v12 = v11 & 5;
  char v13 = atomic_load((unint64_t *)&theString->info);
  uint64_t v14 = v13 & 0x60;
  if (v12 == 4)
  {
    p_CFIndex data = &theString->data;
    if (v14)
    {
      uint64_t v16 = *p_data;
    }

    else
    {
      uint64_t v18 = atomic_load((unint64_t *)&theString->info);
      uint64_t v16 = (char *)&p_data[(v18 & 5) != 4];
    }

    unint64_t length = *v16;
  }

  else if ((v13 & 0x60) != 0)
  {
    unint64_t length = theString->length;
  }

  else
  {
    unint64_t length = (unint64_t)theString->data;
  }

  uint64_t result = 3LL;
  if (v10 >= a2 && v10 <= length)
  {
    if (a4 == theString)
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
      uint64_t v6 = (__CFString *)Copy;
    }

    else
    {
      CFStringRef Copy = 0LL;
    }

    CFIndex v20 = CFStringGetLength(v6);
    if (v20 < 1)
    {
      BOOL v22 = 0;
    }

    else
    {
      if (CF_IS_OBJC(7uLL, (__objc2_class **)v6))
      {
        int v21 = -[__CFString _encodingCantBeStoredInEightBitCFString](v6, "_encodingCantBeStoredInEightBitCFString");
      }

      else
      {
        unsigned int v23 = atomic_load((unint64_t *)&v6->info);
        int v21 = (v23 >> 4) & 1;
      }

      BOOL v22 = v21 != 0;
    }

    v34[0] = a2;
    v34[1] = a3;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)v34, 1LL, v20, v22);
    char v24 = atomic_load((unint64_t *)&theString->info);
    char v25 = atomic_load((unint64_t *)&theString->info);
    uint64_t v26 = v25 & 0x60;
    char v27 = &theString->data;
    if ((v24 & 0x10) == 0)
    {
      if (v26)
      {
        char v28 = *v27;
      }

      else
      {
        uint64_t v30 = atomic_load((unint64_t *)&theString->info);
        char v28 = (char *)&v27[(v30 & 5) != 4];
      }

      CFStringEncoding v31 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFStringEncoding v31 = __CFDefaultEightBitStringEncoding;
      }

      unint64_t v32 = atomic_load((unint64_t *)&theString->info);
      v35.CFIndex location = 0LL;
      v35.unint64_t length = v20;
      CFStringGetBytes(v6, v35, v31, 0, 0, (UInt8 *)&v28[a2 + ((v32 >> 2) & 1)], v20, 0LL);
      goto LABEL_36;
    }

    if (v26)
    {
      uint64_t v29 = *v27;
      if (!v29) {
        goto LABEL_36;
      }
    }

    else
    {
      uint64_t v33 = atomic_load((unint64_t *)&theString->info);
      uint64_t v29 = (char *)&v27[(v33 & 5) != 4];
      if (!v29)
      {
LABEL_36:
        if (Copy) {
          CFRelease(Copy);
        }
        return 0LL;
      }
    }

    v36.CFIndex location = 0LL;
    v36.unint64_t length = v20;
    CFStringGetCharacters(v6, v36, (UniChar *)&v29[2 * a2]);
    goto LABEL_36;
  }

  return result;
}

uint64_t __CFStringNoteErrors()
{
  return 1LL;
}

void CFStringPad(CFMutableStringRef theString, CFStringRef padString, CFIndex length, CFIndex indexIntoPad)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfPad:length:padIndex:](theString, "_cfPad:length:padIndex:", padString, length, indexIntoPad);
    return;
  }

  p_info = &theString->info;
  char v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 1) == 0)
  {
    unint64_t v10 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
      CFStringPad_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    }
    return;
  }

  char v18 = atomic_load((unint64_t *)p_info);
  uint64_t v19 = v18 & 5;
  char v20 = atomic_load((unint64_t *)p_info);
  uint64_t v21 = v20 & 0x60;
  if (v19 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v21)
    {
      unsigned int v23 = *p_data;
    }

    else
    {
      uint64_t v25 = atomic_load((unint64_t *)&theString->info);
      unsigned int v23 = (char *)&p_data[(v25 & 5) != 4];
    }

    uint64_t data = *v23;
  }

  else if ((v20 & 0x60) != 0)
  {
    uint64_t data = theString->length;
  }

  else
  {
    uint64_t data = (uint64_t)theString->data;
  }

  if (data > length)
  {
    CFIndex v46 = length;
    uint64_t v47 = data - length;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v46, 1LL, 0LL, 0);
    return;
  }

  if (data < length)
  {
    uint64_t v26 = length - data;
    if (CF_IS_OBJC(7uLL, (__objc2_class **)padString))
    {
      CFIndex v27 = CFStringGetLength(padString);
    }

    else
    {
      char v28 = atomic_load((unint64_t *)&padString->info);
      uint64_t v29 = v28 & 5;
      char v30 = atomic_load((unint64_t *)&padString->info);
      uint64_t v31 = v30 & 0x60;
      if (v29 == 4)
      {
        unint64_t v32 = &padString->data;
        if (v31)
        {
          uint64_t v33 = *v32;
        }

        else
        {
          uint64_t v34 = atomic_load((unint64_t *)&padString->info);
          uint64_t v33 = (char *)&v32[(v34 & 5) != 4];
        }

        CFIndex v27 = *v33;
      }

      else if ((v30 & 0x60) != 0)
      {
        CFIndex v27 = padString->length;
      }

      else
      {
        CFIndex v27 = (CFIndex)padString->data;
      }

      char v35 = atomic_load((unint64_t *)&theString->info);
      if ((v35 & 0x10) == 0)
      {
        unint64_t v36 = atomic_load((unint64_t *)&padString->info);
        uint64_t v37 = (v36 >> 4) & 1;
        goto LABEL_30;
      }
    }

    LODWORD(v37) = 1;
LABEL_30:
    CFIndex v46 = data;
    uint64_t v47 = 0LL;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v46, 1LL, v26, v37);
    char v38 = atomic_load((unint64_t *)&theString->info);
    int v39 = &theString->data;
    if ((v38 & 0x60) != 0)
    {
      BOOL v40 = *v39;
    }

    else
    {
      char v41 = atomic_load((unint64_t *)&theString->info);
      BOOL v40 = (char *)&v39[(v41 & 5) != 4LL];
    }

    unint64_t v42 = atomic_load((unint64_t *)&theString->info);
    if (v26 >= 1)
    {
      if (v26 >= v27 - indexIntoPad) {
        CFIndex v43 = v27 - indexIntoPad;
      }
      else {
        CFIndex v43 = v26;
      }
      uint64_t v44 = (UniChar *)&v40[(data << v37) + ((v42 >> 2) & 1)];
      do
      {
        if ((_DWORD)v37)
        {
          v49.CFIndex location = indexIntoPad;
          v49.unint64_t length = v43;
          CFStringGetCharacters(padString, v49, v44);
        }

        else
        {
          CFStringEncoding v45 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            CFStringEncoding v45 = __CFDefaultEightBitStringEncoding;
          }

          v50.CFIndex location = indexIntoPad;
          v50.unint64_t length = v43;
          CFStringGetBytes(padString, v50, v45, 0, 0, (UInt8 *)v44, v26, 0LL);
        }

        indexIntoPad = 0LL;
        uint64_t v44 = (UniChar *)((char *)v44 + (v43 << v37));
        v26 -= v43;
        if (v26 >= v43) {
          CFIndex v43 = v27;
        }
        else {
          CFIndex v43 = v26;
        }
      }

      while (v26 > 0);
    }
  }

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfTrim:](theString, "_cfTrim:", trimString);
  }

  else
  {
    p_info = &theString->info;
    char v5 = atomic_load((unint64_t *)&theString->info);
    if ((v5 & 1) != 0)
    {
      char v14 = atomic_load((unint64_t *)p_info);
      uint64_t v15 = v14 & 5;
      char v16 = atomic_load((unint64_t *)p_info);
      uint64_t v17 = v16 & 0x60;
      if (v15 == 4)
      {
        p_uint64_t data = &theString->data;
        if (v17)
        {
          uint64_t v19 = *p_data;
        }

        else
        {
          uint64_t v21 = atomic_load((unint64_t *)&theString->info);
          uint64_t v19 = (char *)&p_data[(v21 & 5) != 4];
        }

        CFIndex length = *v19;
      }

      else if ((v16 & 0x60) != 0)
      {
        CFIndex length = theString->length;
      }

      else
      {
        CFIndex length = (CFIndex)theString->data;
      }

      v44.CFIndex location = 0LL;
      v44.CFIndex length = length;
      if (CFStringFindWithOptionsAndLocale(theString, trimString, v44, 8uLL, 0LL, &result))
      {
        do
        {
          CFIndex v22 = result.length + result.location;
          CFIndex v23 = length - (result.length + result.location);
          v45.CFIndex location = result.length + result.location;
          v45.CFIndex length = v23;
        }

        while (CFStringFindWithOptionsAndLocale(theString, trimString, v45, 8uLL, 0LL, &result));
      }

      else
      {
        CFIndex v22 = 0LL;
        CFIndex v23 = length;
      }

      if (v22 >= length)
      {
        CFIndex v41 = 0LL;
        CFIndex v42 = length;
      }

      else
      {
        unint64_t v24 = atomic_load((unint64_t *)&theString->info);
        char v25 = atomic_load((unint64_t *)&theString->info);
        uint64_t v26 = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          CFIndex v27 = *v26;
        }

        else
        {
          char v28 = atomic_load((unint64_t *)&theString->info);
          CFIndex v27 = (char *)&v26[(v28 & 5) != 4LL];
        }

        uint64_t v29 = (v24 >> 4) & 1;
        char v30 = &theString->info;
        unint64_t v31 = atomic_load((unint64_t *)&theString->info);
        unint64_t v32 = &v27[(v31 >> 2) & 1];
        if (CFStringGetLength(trimString) < v23)
        {
          while (1)
          {
            v46.CFIndex location = v22;
            v46.CFIndex length = v23;
            if (!CFStringFindWithOptionsAndLocale(theString, trimString, v46, 0xCuLL, 0LL, &result)) {
              break;
            }
            CFIndex v23 = result.location - v22;
          }
        }

        memmove(v32, &v32[v22 << v29], v23 << v29);
        char v33 = atomic_load((unint64_t *)v30);
        uint64_t v34 = v33 & 5;
        char v35 = atomic_load((unint64_t *)v30);
        uint64_t v36 = v35 & 0x60;
        if (v34 == 4)
        {
          if (v36)
          {
            uint64_t v37 = *v26;
          }

          else
          {
            char v39 = atomic_load((unint64_t *)&theString->info);
            uint64_t v37 = (char *)&v26[(v39 & 5) != 4LL];
          }

          uint64_t v38 = *v37;
        }

        else if (v36)
        {
          uint64_t v38 = theString->length;
        }

        else
        {
          uint64_t v38 = (uint64_t)*v26;
        }

        CFIndex v41 = v23;
        CFIndex v42 = v38 - v23;
      }

      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v41, 1LL, 0LL, 0);
    }

    else
    {
      uint64_t v6 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        CFStringTrim_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
  }

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfTrimWS](theString, "_cfTrimWS");
  }

  else
  {
    p_info = &theString->info;
    char v3 = atomic_load((unint64_t *)&theString->info);
    if ((v3 & 1) != 0)
    {
      char v12 = atomic_load((unint64_t *)p_info);
      uint64_t v13 = v12 & 5;
      char v14 = atomic_load((unint64_t *)p_info);
      uint64_t v15 = v14 & 0x60;
      if (v13 == 4)
      {
        p_uint64_t data = &theString->data;
        if (v15)
        {
          uint64_t v17 = *p_data;
        }

        else
        {
          uint64_t v19 = atomic_load((unint64_t *)&theString->info);
          uint64_t v17 = (char *)&p_data[(v19 & 5) != 4];
        }

        uint64_t length = *v17;
      }

      else if ((v14 & 0x60) != 0)
      {
        uint64_t length = theString->length;
      }

      else
      {
        uint64_t length = (uint64_t)theString->data;
      }

      CFStringRef theStringa = theString;
      uint64_t v70 = 0LL;
      uint64_t v71 = length;
      CharactersPtr = CFStringGetCharactersPtr(theString);
      uint64_t v21 = 0LL;
      CFRange v68 = CharactersPtr;
      if (!CharactersPtr)
      {
        int v22 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding();
          int v22 = __CFDefaultEightBitStringEncoding;
        }

        if (v22 != 1536)
        {
          if (v22 == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            int v22 = __CFDefaultEightBitStringEncoding;
          }

          if (v22 != 1536) {
            goto LABEL_23;
          }
        }

        CFIndex v23 = &theString->info;
        char v24 = atomic_load((unint64_t *)&theString->info);
        if ((v24 & 0x10) == 0 || (char v25 = atomic_load((unint64_t *)v23), (v25 & 8) != 0))
        {
          char v26 = atomic_load((unint64_t *)v23);
          CFIndex v27 = &theString->data;
          if ((v26 & 0x60) != 0)
          {
            char v28 = *v27;
          }

          else
          {
            char v29 = atomic_load((unint64_t *)&theString->info);
            char v28 = (char *)&v27[(v29 & 5) != 4LL];
          }

          unint64_t v30 = atomic_load((unint64_t *)&theString->info);
          uint64_t v21 = &v28[(v30 >> 2) & 1];
        }

        else
        {
LABEL_23:
          uint64_t v21 = 0LL;
        }
      }

      int64_t v72 = 0LL;
      int64_t v73 = 0LL;
      uint64_t v69 = v21;
      if (length < 1)
      {
LABEL_46:
        uint64_t v64 = 0LL;
        uint64_t v65 = length;
      }

      else
      {
        int64_t v31 = 0LL;
        while (1)
        {
          if (v68)
          {
            UniChar v32 = v68[v70 + v31];
          }

          else if (v69)
          {
            UniChar v32 = v69[v70 + v31];
          }

          else
          {
            int64_t v33 = v72;
            BOOL v34 = v73 > v31 && v72 <= v31;
            if (!v34)
            {
              int64_t v35 = v31 - 4;
              int64_t v36 = v35 + 64;
              if (v35 + 64 >= v71) {
                int64_t v36 = v71;
              }
              int64_t v72 = v35;
              int64_t v73 = v36;
              v75.CFIndex location = v70 + v35;
              v75.uint64_t length = v36 - v35;
              CFStringGetCharacters(theStringa, v75, buffer);
              int64_t v33 = v72;
            }

            UniChar v32 = buffer[v31 - v33];
          }

          if (++v31 == length) {
            goto LABEL_46;
          }
        }

        char v37 = atomic_load((unint64_t *)&theString->info);
        uint64_t v38 = &theString->data;
        CFStringRef v63 = &theString->data;
        if ((v37 & 0x60) != 0)
        {
          char v39 = *v38;
        }

        else
        {
          char v40 = atomic_load((unint64_t *)&theString->info);
          char v39 = (char *)&v38[(v40 & 5) != 4LL];
        }

        unint64_t v41 = atomic_load((unint64_t *)&theString->info);
        CFIndex v42 = &v39[(v41 >> 2) & 1];
        unint64_t v43 = atomic_load((unint64_t *)&theString->info);
        uint64_t v44 = (v43 >> 4) & 1;
        uint64_t v45 = -length;
        uint64_t v46 = length + 64;
        do
        {
          uint64_t v47 = length;
          else {
            uint64_t v48 = length;
          }
          BOOL v34 = length-- < 1;
          if (v34) {
            break;
          }
          if (v68)
          {
            UniChar v49 = v68[v47 - 1 + v70];
          }

          else if (v69)
          {
            UniChar v49 = v69[v70 - 1 + v47];
          }

          else
          {
            int64_t v50 = v72;
            if (v73 < v47 || v72 >= v47)
            {
              uint64_t v52 = -v48;
              uint64_t v53 = v48 + v45;
              uint64_t v54 = v46 - v48;
              int64_t v55 = v47 + v52;
              int64_t v56 = v55 + 64;
              if (v55 + 64 >= v71) {
                int64_t v56 = v71;
              }
              int64_t v72 = v55;
              int64_t v73 = v56;
              if (v71 < v54) {
                uint64_t v54 = v71;
              }
              v76.uint64_t length = v54 + v53;
              v76.CFIndex location = v55 + v70;
              CFStringGetCharacters(theStringa, v76, buffer);
              int64_t v50 = v72;
            }

            UniChar v49 = buffer[v47 - 1 - v50];
          }

          ++v45;
          --v46;
        }

        while ((CFUniCharIsMemberOf(v49, 3u) & 1) != 0);
        memmove(v42, &v42[v31 << v44], (v47 - v31) << v44);
        char v57 = atomic_load((unint64_t *)&theString->info);
        char v58 = atomic_load((unint64_t *)&theString->info);
        uint64_t v59 = v58 & 0x60;
        if ((v57 & 5) == 4LL)
        {
          if (v59)
          {
            unint64_t v60 = *v63;
          }

          else
          {
            char v62 = atomic_load((unint64_t *)&theString->info);
            unint64_t v60 = (char *)&v63[(v62 & 5) != 4LL];
          }

          uint64_t v61 = *v60;
        }

        else if (v59)
        {
          uint64_t v61 = theString->length;
        }

        else
        {
          uint64_t v61 = (uint64_t)*v63;
        }

        uint64_t v64 = v47 - v31;
        uint64_t v65 = v61 + v31 - v47;
      }

      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v64, 1LL, 0LL, 0);
    }

    else
    {
      char v4 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
        CFStringTrimWhitespace_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
      }
    }
  }

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfLowercase:](theString, "_cfLowercase:", locale);
    return;
  }

  char v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringLowercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }

  char v15 = atomic_load((unint64_t *)&theString->info);
  uint64_t v16 = v15 & 5;
  char v17 = atomic_load((unint64_t *)&theString->info);
  uint64_t v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v18)
    {
      char v20 = *p_data;
    }

    else
    {
      uint64_t v22 = atomic_load((unint64_t *)&theString->info);
      char v20 = (char *)&p_data[(v22 & 5) != 4];
    }

    uint64_t length = *v20;
  }

  else if ((v17 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  if (locale) {
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  }
  uint64_t v23 = 0LL;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_28:
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
    }

    char v31 = atomic_load((unint64_t *)&theString->info);
    UniChar v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      unint64_t v33 = (unint64_t)*v32;
    }

    else
    {
      char v34 = atomic_load((unint64_t *)&theString->info);
      unint64_t v33 = (unint64_t)&v32[(v34 & 5) != 4LL];
    }

    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      uint64_t v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        int v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00) {
          unsigned int v36 = v44 + (v36 << 10) - 56613888;
        }
      }

      if (locale || v36 == 931) {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags( v36,  v33,  v23,  length,  0,  (unsigned __int16 *)locale,  ConditionalCaseMappingFlags);
      }
      else {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      uint64_t v39 = CFUniCharMapCaseTo(v36, &v53, 8LL, 0LL, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      uint64_t v40 = v39 - 1;
      if (v39 >= 1) {
        *(_WORD *)(v33 + 2 * v23) = v53;
      }
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          uint64_t v51 = v23;
LABEL_60:
          uint64_t v52 = 1LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
          char v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v47 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v47 & 5) != 4LL];
          }

          --length;
          goto LABEL_73;
        }

        if (v39 >= 2)
        {
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, v40, 1);
          char v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v48 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v48 & 5) != 4LL];
          }

          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_72:
          v23 += v40;
        }
      }

      else
      {
        uint64_t v41 = v39 - 2;
        if (v39 != 2)
        {
          uint64_t v40 = v39 - 1;
          if (v39 == 1)
          {
            uint64_t v51 = v23 + 1;
            goto LABEL_60;
          }

          if (!v39)
          {
            uint64_t v51 = v23;
            uint64_t v52 = 2LL;
            __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
            char v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              unint64_t v33 = (unint64_t)*v32;
            }

            else
            {
              char v49 = atomic_load((unint64_t *)&theString->info);
              unint64_t v33 = (unint64_t)&v32[(v49 & 5) != 4LL];
            }

            length -= 2LL;
            goto LABEL_73;
          }

          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, v41, 1);
          char v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v50 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v50 & 5) != 4LL];
          }

          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_72;
        }

        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfUppercase:](theString, "_cfUppercase:", locale);
    return;
  }

  char v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringUppercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }

  char v15 = atomic_load((unint64_t *)&theString->info);
  uint64_t v16 = v15 & 5;
  char v17 = atomic_load((unint64_t *)&theString->info);
  uint64_t v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v18)
    {
      char v20 = *p_data;
    }

    else
    {
      uint64_t v22 = atomic_load((unint64_t *)&theString->info);
      char v20 = (char *)&p_data[(v22 & 5) != 4];
    }

    uint64_t length = *v20;
  }

  else if ((v17 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  if (locale) {
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  }
  uint64_t v23 = 0LL;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_28:
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
    }

    char v31 = atomic_load((unint64_t *)&theString->info);
    UniChar v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      unint64_t v33 = (unint64_t)*v32;
    }

    else
    {
      char v34 = atomic_load((unint64_t *)&theString->info);
      unint64_t v33 = (unint64_t)&v32[(v34 & 5) != 4LL];
    }

    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      uint64_t v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        int v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00) {
          unsigned int v36 = v44 + (v36 << 10) - 56613888;
        }
      }

      if (locale) {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags( v36,  v33,  v23,  length,  1,  (unsigned __int16 *)locale,  ConditionalCaseMappingFlags);
      }
      else {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      uint64_t v39 = CFUniCharMapCaseTo(v36, &v53, 8LL, 1LL, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      uint64_t v40 = v39 - 1;
      if (v39 >= 1) {
        *(_WORD *)(v33 + 2 * v23) = v53;
      }
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          uint64_t v51 = v23;
LABEL_59:
          uint64_t v52 = 1LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
          char v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v47 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v47 & 5) != 4LL];
          }

          --length;
          goto LABEL_72;
        }

        if (v39 >= 2)
        {
          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, v40, 1);
          char v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v48 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v48 & 5) != 4LL];
          }

          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_71:
          v23 += v40;
        }
      }

      else
      {
        uint64_t v41 = v39 - 2;
        if (v39 != 2)
        {
          uint64_t v40 = v39 - 1;
          if (v39 == 1)
          {
            uint64_t v51 = v23 + 1;
            goto LABEL_59;
          }

          if (!v39)
          {
            uint64_t v51 = v23;
            uint64_t v52 = 2LL;
            __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, 0LL, 1);
            char v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              unint64_t v33 = (unint64_t)*v32;
            }

            else
            {
              char v49 = atomic_load((unint64_t *)&theString->info);
              unint64_t v33 = (unint64_t)&v32[(v49 & 5) != 4LL];
            }

            length -= 2LL;
            goto LABEL_72;
          }

          uint64_t v51 = v23 + 1;
          uint64_t v52 = 0LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v51, 1LL, v41, 1);
          char v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            unint64_t v33 = (unint64_t)*v32;
          }

          else
          {
            char v50 = atomic_load((unint64_t *)&theString->info);
            unint64_t v33 = (unint64_t)&v32[(v50 & 5) != 4LL];
          }

          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_71;
        }

        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  p_info = &theString->info;
  unsigned int v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfCapitalize:](theString, "_cfCapitalize:", locale);
    return;
  }

  char v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      CFStringCapitalize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return;
  }

  char v15 = atomic_load((unint64_t *)&theString->info);
  uint64_t v16 = v15 & 5;
  char v17 = atomic_load((unint64_t *)&theString->info);
  uint64_t v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_uint64_t data = &theString->data;
    if (v18)
    {
      char v20 = *p_data;
    }

    else
    {
      uint64_t v22 = atomic_load((unint64_t *)&theString->info);
      char v20 = (char *)&p_data[(v22 & 5) != 4];
    }

    uint64_t length = *v20;
  }

  else if ((v17 & 0x60) != 0)
  {
    uint64_t length = theString->length;
  }

  else
  {
    uint64_t length = (uint64_t)theString->data;
  }

  uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Du, 0);
  if (locale) {
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  }
  uint64_t v23 = 0LL;
  char IsMemberOf = 0;
  if (locale)
  {
    uint64_t v25 = BitmapPtrForPlane;
    goto LABEL_21;
  }

  uint64_t v25 = BitmapPtrForPlane;
  if (((v5 >> 4) & 1) != 0)
  {
LABEL_21:
    if (v23 >= length) {
      return;
    }
    if (((v5 >> 4) & 1) == 0)
    {
      uint64_t v62 = 0LL;
      uint64_t v63 = 0LL;
      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, 0LL, 1);
    }

    char v29 = atomic_load((unint64_t *)&theString->info);
    int v30 = &theString->data;
    uint64_t v61 = &theString->data;
    if ((v29 & 0x60) != 0)
    {
      unint64_t v31 = (unint64_t)*v30;
    }

    else
    {
      char v39 = atomic_load((unint64_t *)&theString->info);
      unint64_t v31 = (unint64_t)&v30[(v39 & 5) != 4LL];
    }

    unsigned int ConditionalCaseMappingFlags = 0;
    while (1)
    {
      unsigned int v41 = *(unsigned __int16 *)(v31 + 2 * v23);
      uint64_t v42 = v23 + 1;
      if ((v41 & 0xFC00) == 0xD800 && v42 < length)
      {
        int v51 = *(unsigned __int16 *)(v31 + 2 * v42);
        if ((v51 & 0xFC00) == 0xDC00) {
          unsigned int v41 = v51 + (v41 << 10) - 56613888;
        }
      }

      if (!locale && (v41 == 931 ? (BOOL v44 = IsMemberOf == 0) : (BOOL v44 = 1), v44)) {
        unsigned int ConditionalCaseMappingFlags = 0;
      }
      else {
        unsigned int ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags( v41,  v31,  v23,  length,  2 * (IsMemberOf == 0),  (unsigned __int16 *)locale,  ConditionalCaseMappingFlags);
      }
      uint64_t v45 = CFUniCharMapCaseTo( v41,  &v64,  8LL,  2 * (IsMemberOf == 0),  ConditionalCaseMappingFlags,  (unsigned __int16 *)locale);
      uint64_t v46 = v45 - 1;
      if (v45 >= 1) {
        *(_WORD *)(v31 + 2 * v23) = v64;
      }
      if (v41 >= 0x10000)
      {
        uint64_t v47 = v45 - 2;
        if (v45 == 2)
        {
          ++v23;
          *(_WORD *)(v31 + 2 * v23) = v65[0];
        }

        else
        {
          uint64_t v48 = v45 - 1;
          if (v45 == 1)
          {
            uint64_t v62 = v23 + 1;
            uint64_t v63 = 1LL;
            __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, 0LL, 1);
            char v53 = atomic_load((unint64_t *)&theString->info);
            if ((v53 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }

            else
            {
              char v58 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v58 & 5) != 4LL];
            }

            uint64_t v25 = BitmapPtrForPlane;
            --length;
          }

          else if (v45)
          {
            uint64_t v62 = v23 + 1;
            uint64_t v63 = 0LL;
            __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, v47, 1);
            char v54 = atomic_load((unint64_t *)&theString->info);
            if ((v54 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }

            else
            {
              char v59 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v59 & 5) != 4LL];
            }

            memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v48);
            length += v47;
            v23 += v48;
            uint64_t v25 = BitmapPtrForPlane;
          }

          else
          {
            uint64_t v62 = v23;
            uint64_t v63 = 2LL;
            __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, 0LL, 1);
            char v49 = atomic_load((unint64_t *)&theString->info);
            if ((v49 & 0x60) != 0)
            {
              unint64_t v31 = (unint64_t)*v61;
            }

            else
            {
              char v57 = atomic_load((unint64_t *)&theString->info);
              unint64_t v31 = (unint64_t)&v61[(v57 & 5) != 4LL];
            }

            uint64_t v25 = BitmapPtrForPlane;
            length -= 2LL;
          }
        }

        if ((CFUniCharIsMemberOf(v41, 0x6Du) & 1) != 0) {
          goto LABEL_98;
        }
LABEL_95:
        if ((CFUniCharIsMemberOf(v41, 7u) & 1) != 0) {
          char IsMemberOf = 1;
        }
        else {
          char IsMemberOf = CFUniCharIsMemberOf(v41, 6u);
        }
        goto LABEL_98;
      }

      if (!v45) {
        break;
      }
      if (v45 < 2) {
        goto LABEL_82;
      }
      uint64_t v62 = v23 + 1;
      uint64_t v63 = 0LL;
      __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, v46, 1);
      char v50 = atomic_load((unint64_t *)&theString->info);
      if ((v50 & 0x60) != 0)
      {
        unint64_t v31 = (unint64_t)*v61;
      }

      else
      {
        char v56 = atomic_load((unint64_t *)&theString->info);
        unint64_t v31 = (unint64_t)&v61[(v56 & 5) != 4LL];
      }

      memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v46);
      length += v46;
      v23 += v46;
      if (!v25) {
        goto LABEL_95;
      }
LABEL_86:
LABEL_98:
      if (++v23 >= length) {
        return;
      }
    }

    uint64_t v62 = v23;
    uint64_t v63 = 1LL;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v62, 1LL, 0LL, 1);
    char v52 = atomic_load((unint64_t *)&theString->info);
    if ((v52 & 0x60) != 0)
    {
      unint64_t v31 = (unint64_t)*v61;
    }

    else
    {
      char v55 = atomic_load((unint64_t *)&theString->info);
      unint64_t v31 = (unint64_t)&v61[(v55 & 5) != 4LL];
    }

    --length;
LABEL_82:
    if (!v25) {
      goto LABEL_95;
    }
    goto LABEL_86;
  }

  char v26 = atomic_load((unint64_t *)&theString->info);
  char v27 = &theString->data;
  if ((v26 & 0x60) != 0)
  {
    unint64_t v28 = *v27;
  }

  else
  {
    char v32 = atomic_load((unint64_t *)&theString->info);
    unint64_t v28 = (char *)&v27[(v32 & 5) != 4LL];
  }

  unint64_t v33 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    uint64_t v23 = 0LL;
    char IsMemberOf = 0;
    char v34 = &v28[(v33 >> 2) & 1];
    do
    {
      if (v34[v23] < 0) {
        goto LABEL_21;
      }
      unint64_t v35 = v34[v23];
      int v36 = v34[v23];
      if ((v35 - 65) > 0x19u)
      {
        if ((v36 - 97) > 0x19)
        {
          if (BitmapPtrForPlane)
          {
          }

          else
          {
            char IsMemberOf = 0;
          }

          goto LABEL_38;
        }

        if (IsMemberOf) {
          char v38 = 0;
        }
        else {
          char v38 = -32;
        }
        char v37 = v35 + v38;
      }

      else
      {
        char v37 = v36 + 32 * (IsMemberOf != 0);
      }

      v34[v23] = v37;
      char IsMemberOf = 1;
LABEL_38:
      ++v23;
    }

    while (length != v23);
  }

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
  CFMutableStringRef v2 = theString;
  __src[32] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfNormalize:](v2, "_cfNormalize:", theForm);
    return;
  }

  p_info = (unint64_t *)&v2->info;
  char v4 = atomic_load((unint64_t *)&v2->info);
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
      CFStringNormalize_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    return;
  }

  char v13 = atomic_load(p_info);
  uint64_t v14 = v13 & 5;
  char v15 = atomic_load(p_info);
  uint64_t v16 = v15 & 0x60;
  if (v14 == 4)
  {
    p_uint64_t data = &v2->data;
    if (v16)
    {
      uint64_t v18 = (unsigned __int8 **)*p_data;
    }

    else
    {
      uint64_t v20 = atomic_load((unint64_t *)&v2->info);
      uint64_t v18 = (unsigned __int8 **)&p_data[(v20 & 5) != 4];
    }

    uint64_t length = *(unsigned __int8 *)v18;
  }

  else if ((v15 & 0x60) != 0)
  {
    uint64_t length = v2->length;
  }

  else
  {
    uint64_t length = (uint64_t)v2->data;
  }

  char v21 = atomic_load((unint64_t *)&v2->info);
  if ((v21 & 0x10) != 0) {
    goto LABEL_25;
  }
  if (theForm == kCFStringNormalizationFormC) {
    return;
  }
  char v22 = atomic_load((unint64_t *)&v2->info);
  uint64_t v23 = &v2->data;
  if ((v22 & 0x60) != 0)
  {
    char v24 = (char **)*v23;
  }

  else
  {
    char v25 = atomic_load((unint64_t *)&v2->info);
    char v24 = &v23[(v25 & 5) != 4LL];
  }

  unint64_t v26 = atomic_load((unint64_t *)&v2->info);
  if (length < 1)
  {
LABEL_25:
    uint64_t v28 = 0LL;
    BOOL v141 = 1;
  }

  else
  {
    uint64_t v27 = (v26 >> 2) & 1;
    if (*((char *)v24 + v27) < 0)
    {
      BOOL v141 = 0;
      uint64_t v28 = 0LL;
    }

    else
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = (uint64_t)v24 + v27 + 1;
      do
      {
        if (length - 1 == v28) {
          return;
        }
        int v30 = *(char *)(v29 + v28++);
      }

      while ((v30 & 0x80000000) == 0);
      BOOL v141 = v28 >= length;
    }

    __src[0] = 0LL;
    __src[1] = 0LL;
    __CFStringChangeSizeMultiple((char *)v2, (uint64_t)__src, 1LL, 0LL, 1);
  }

  if (v28 < length)
  {
    char v31 = atomic_load((unint64_t *)&v2->info);
    char v32 = &v2->data;
    if ((v31 & 0x60) != 0)
    {
      unint64_t v33 = *v32;
    }

    else
    {
      char v34 = atomic_load((unint64_t *)&v2->info);
      unint64_t v33 = (char *)&v32[(v34 & 5) != 4LL];
    }

    unint64_t v35 = (unint64_t)&v33[2 * length];
    char v36 = atomic_load((unint64_t *)&v2->info);
    UniChar v144 = &v2->data;
    if ((v36 & 0x60) != 0)
    {
      char v37 = *v32;
    }

    else
    {
      char v38 = atomic_load((unint64_t *)&v2->info);
      char v37 = (char *)&v32[(v38 & 5) != 4LL];
    }

    CFIndex i = (unsigned __int16 *)&v37[2 * v28];
    uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, 0);
    uint64_t v40 = CFUniCharGetBitmapPtrForPlane(8u, 0);
    uint64_t UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    if ((unint64_t)i < v35)
    {
      uint64_t v42 = UnicodePropertyDataForPlane;
      uint64_t v157 = v40;
      uint64_t v156 = UnicodePropertyDataForPlane;
      uint64_t v140 = UnicodePropertyDataForPlane + 256;
      char v43 = (unsigned int *)__src;
      uint64_t v44 = 64LL;
      int64_t v143 = v2;
      while (1)
      {
        unsigned int v45 = *i;
        uint64_t v46 = i + 1;
        BOOL v47 = (v45 & 0xFC00) != 0xD800 || (unint64_t)v46 >= v35;
        if (v47 || (int v53 = *v46, (v53 & 0xFC00) != 0xDC00))
        {
          char v48 = 1;
          ++i;
          uint64_t v155 = 1LL;
          unsigned int v49 = v45;
          uint64_t v50 = BitmapPtrForPlane;
        }

        else
        {
          unsigned int v49 = (v45 << 10) - 56613888 + v53;
          i += 2;
          unsigned int v45 = (unsigned __int16)(((_WORD)v45 << 10) + 9216 + v53);
          uint64_t v50 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v49));
          char v48 = 0;
          uint64_t v155 = 2LL;
        }

        uint64_t v153 = v28;
        unint64_t v154 = v35;
        if (v50)
        {
          uint64_t v51 = v42;
          if ((v48 & 1) == 0) {
            uint64_t v51 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v49));
          }
          if (v51
            && *(_BYTE *)(v51 + ((unint64_t)v45 >> 8))
            && *(_BYTE *)(v51
                        + (*(unsigned __int8 *)(v51 + ((unint64_t)v45 >> 8)) << 8)
                        - 256
                        + v45
                        + 256)
            || (theForm & 2) != 0 && v49 - 55205 > 0xFFFFD45A)
          {
LABEL_50:
            uint64_t v52 = 0LL;
          }

          else
          {
            uint64_t v52 = CFUniCharDecomposeCharacter(v49, v43, 64LL);
          }
        }

        else
        {
          uint64_t v52 = 0LL;
        }

LABEL_94:
        if ((theForm & 2) == 0) {
          goto LABEL_229;
        }
        if (v52 >= 2)
        {
          char v142 = 0;
          unsigned int v63 = 0;
          uint64_t v64 = *v43;
          BOOL v147 = v43 - 1;
          uint64_t v65 = v43;
          uint64_t v66 = 1LL;
          char v151 = i;
          do
          {
            uint64_t v67 = v52;
            unsigned int v145 = v65;
            uint64_t v150 = v66;
            uint64_t v68 = v66;
            unsigned int v146 = v64;
            uint64_t v69 = v64;
            unsigned int v148 = v63;
LABEL_98:
            uint64_t v70 = &v147[v68];
            while (1)
            {
              uint64_t v71 = v70[1];
              if (v42)
              {
                if (*(_BYTE *)(v42 + BYTE1(v71))) {
                  LODWORD(v42) = *(unsigned __int8 *)(v42
                }
                                                    + (*(unsigned __int8 *)(v42 + BYTE1(v71)) << 8)
                                                    - 256
                                                    + v71
                                                    + 256);
                else {
                  LODWORD(v42) = 0;
                }
              }

              if ((theForm & 1) == 0) {
                break;
              }
              if ((v69 - 4352) <= 0xFE
                && (((_DWORD)v69 << 24) | 0xFFFFFFu) < 0x14FFFFFF
                && (((_DWORD)v71 << 16) - 293011456) >= 0xFFE90001)
              {
                uint64_t v73 = v68 + 1;
                v70[1] = 65533;
                if (v68 + 1 >= v67)
                {
                  LOWORD(v74) = 0;
                  uint64_t v42 = v156;
                }

                else
                {
                  int v74 = v70[2] - 4519;
                  uint64_t v42 = v156;
                  if ((v74 << 16) <= 0x1C0000)
                  {
                    uint64_t v73 = v68 + 2;
                    void v70[2] = 65533;
                  }

                  else
                  {
                    LOWORD(v74) = 0;
                  }
                }

                *uint64_t v65 = 28 * (((((_DWORD)v71 << 16) - 291569664) >> 16) + 21 * v69)
                     + (__int16)v74
                     + 44032;
                if (v67 >= 2)
                {
                  unint64_t v75 = v67 + 1;
                  CFRange v76 = &v147[v67];
                  uint64_t v77 = -v67;
                  do
                  {
                    if (*v76 == 65533)
                    {
                      uint64_t v78 = v67 - 1;
                      size_t v79 = 4 * (v67 + v77);
                      uint64_t v80 = v73 - 1;
                      memmove(v76, v76 + 1, v79);
                      uint64_t v73 = v80;
                      uint64_t v67 = v78;
                    }

                    --v75;
                    --v76;
                    ++v77;
                  }

                  while (v75 > 2);
                }

                uint64_t v65 = &v43[v73];
                uint64_t v69 = *v65;
                uint64_t v68 = v73 + 1;
                if (v73 + 1 >= v67)
                {
                  uint64_t v52 = v67;
                  LODWORD(v64) = *v65;
                  goto LABEL_146;
                }

                goto LABEL_98;
              }

              uint64_t v72 = v157;
              if (v72 && ((*(unsigned __int8 *)(v72 + ((unsigned __int16)v71 >> 3)) >> (v71 & 7)) & 1) != 0)
              {
                uint64_t v52 = v67;
                uint64_t v150 = v68;
                uint64_t v64 = v69;
                goto LABEL_129;
              }

              *uint64_t v65 = v69;
              uint64_t v65 = &v43[v68++];
              ++v70;
              uint64_t v69 = v71;
              uint64_t v42 = v156;
              if (v68 >= v67)
              {
                uint64_t v52 = v67;
                LODWORD(v64) = v71;
                uint64_t v65 = v70;
LABEL_146:
                CFMutableStringRef v2 = v143;
                unint64_t v35 = v154;
                CFIndex i = v151;
                goto LABEL_147;
              }
            }

            uint64_t v64 = v146;
            uint64_t v65 = v145;
LABEL_129:
            CFMutableStringRef v2 = v143;
            unint64_t v35 = v154;
            if (v148 && v42 <= v148)
            {
              LODWORD(v42) = v148;
              CFIndex i = v151;
            }

            else
            {
              unsigned int v81 = v71;
              uint64_t v82 = v64;
              uint64_t v83 = CFUniCharPrecomposeCharacter(v64, v81);
              uint64_t v64 = v82;
              CFIndex i = v151;
              if ((_DWORD)v83 != 65533)
              {
                v43[v150] = 65533;
                char v142 = 1;
                uint64_t v64 = v83;
                LODWORD(v42) = v148;
              }
            }

            uint64_t v66 = v150 + 1;
            unsigned int v63 = v42;
            uint64_t v42 = v156;
          }

          while (v150 + 1 < v52);
LABEL_147:
          *uint64_t v65 = v64;
          if ((v142 & 1) != 0 && v52 > 1)
          {
            unint64_t v87 = v52 + 1;
            uint64_t v88 = &v43[v52 - 1];
            uint64_t v89 = -v52;
            do
            {
              if (*v88 == 65533)
              {
                memmove(v88, v88 + 1, 4 * (v52 + v89));
                --v52;
              }

              --v87;
              --v88;
              ++v89;
            }

            while (v87 > 2);
            unint64_t v35 = v154;
            CFIndex i = v151;
          }

          goto LABEL_229;
        }

        if (v49 - 4352 < 0xFF)
        {
          if (((v49 << 24) | 0xFFFFFF) >= 0x14FFFFFF) {
            goto LABEL_229;
          }
          unsigned int v84 = *i - 4449;
          if (v84 > 0x15) {
            goto LABEL_229;
          }
          uint64_t v85 = v155 + 1;
          if ((unint64_t)(i + 1) >= v35)
          {
            LOWORD(v86) = 0;
            ++v155;
          }

          else
          {
            int v86 = i[1] - 4519;
            uint64_t v155 = v85;
          }

          *char v43 = 28 * ((__int16)v84 + 21 * (char)v49) + (__int16)v86 + 44032;
LABEL_187:
          CFRange v105 = v43 + 1;
          uint64_t v106 = v153;
          uint64_t v107 = v155;
LABEL_232:
          unsigned int v119 = 0;
          uint64_t v120 = v43;
          do
          {
            uint64_t v121 = v120 + 1;
            if (*((_WORD *)v120 + 1)) {
              int v122 = 2;
            }
            else {
              int v122 = 1;
            }
            v119 += v122;
            uint64_t v120 = v121;
          }

          while (v121 < v105);
          char v123 = 0;
          goto LABEL_240;
        }

        while (1)
        {
          uint64_t v90 = i;
          unint64_t v91 = *i;
          uint64_t v92 = v90;
          uint64_t v93 = v90 + 1;
          if ((v91 & 0xFC00) == 0xD800 && (unint64_t)v93 < v35)
          {
            int v97 = *v93;
            if ((v97 & 0xFC00) == 0xDC00) {
              break;
            }
          }

          if (!v157
            || ((*(unsigned __int8 *)(v157 + (v91 >> 3)) >> (v91 & 7)) & 1) == 0
            || v42
            && *(_BYTE *)(v42 + (v91 >> 8))
            && *(_BYTE *)(v140 + (*(unsigned __int8 *)(v42 + (v91 >> 8)) << 8) - 256 + v91))
          {
            goto LABEL_228;
          }

    CFRelease(MutableCopy);
    a4 = v43;
LABEL_95:
    uint64_t v11 = v78;
    if (v77) {
      CFRelease(cf);
    }
    char v13 = 0;
    int v53 = 1LL;
    if (!v52) {
      return 0LL;
    }
    goto LABEL_98;
  }

  char v24 = CFStringGetCharacterAtIndex(v8, 0LL);
  else {
    char v25 = CFStringGetCharacterAtIndex(v8, 1LL);
  }
  if (v24 <= 0x7F && (sURLValidCharacters[v24] & 2) != 0 && (v25 == 124 || v25 == 58)) {
    goto LABEL_70;
  }
  if (v24 == 47)
  {
    uint64_t v12 = 1;
    uint64_t v52 = POSIXPathToURLPath(v8, a4, 1, &v79);
    char v13 = 0;
    goto LABEL_76;
  }

  if (v24 == 92)
  {
LABEL_70:
    uint64_t v12 = 1;
    uint64_t v52 = WindowsPathToURLPath(v8, a1, a4, 1);
    char v13 = 0;
    int v53 = 2LL;
    if (v52) {
      goto LABEL_98;
    }
  }

  else
  {
    unsigned int v54 = WindowsPathToURLPath(v8, a1, a4, 0);
    if (v54)
    {
      uint64_t v52 = v54;
      char v13 = 0;
      int v53 = 2LL;
      goto LABEL_102;
    }
  }

  return 0LL;
}

    _CFPrefsApplyChangesQueueToDictionary((void *)value, (__CFDictionary *)Mutable);
    if (!v16) {
      goto LABEL_111;
    }
    goto LABEL_95;
  }

void CFStringFold(CFMutableStringRef theString, CFStringCompareFlags theFlags, CFLocaleRef theLocale)
{
  uint64_t v113 = *MEMORY[0x1895F89C0];
  char v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) == 0)
  {
    char v4 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      CFStringFold_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    return;
  }

  __int16 v13 = theFlags;
  uint64_t Length = CFStringGetLength(theString);
  int v16 = CF_IS_OBJC(7uLL, (__objc2_class **)theString);
  BOOL v97 = v16 != 0;
  char v17 = theLocale;
  if ((v13 & 0x20) != 0)
  {
    char v17 = theLocale;
    if (!theLocale) {
      char v17 = CFLocaleCopyCurrent();
    }
  }

  CFStringCompareFlags theFlagsa = v13 & 0x181;
  if ((v13 & 0x181) != 0 && Length)
  {
    if (v17) {
      uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale( v17,  1);
    }
    else {
      uint64_t SpecialCaseHandlingLanguageIdentifierForLocale = 0LL;
    }
    unsigned int v18 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unsigned int v18 = __CFDefaultEightBitStringEncoding;
    }

    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)theString, v18, 0, v97);
    if (!CStringPtrInternal || (v13 & 1) != 0 || v18 != 1536)
    {
      CFStringRef theStringa = theString;
      uint64_t v109 = 0LL;
      uint64_t v110 = Length;
      CharactersPtr = CFStringGetCharactersPtr(theString);
      uint64_t v21 = 0LL;
      uint64_t v107 = CharactersPtr;
      if (!CharactersPtr) {
        uint64_t v21 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
      }
      uint64_t v22 = 0LL;
      CFIndex v112 = 0LL;
      uint64_t v108 = v21;
      CFIndex v111 = 0LL;
      uint64_t v96 = v17;
      CFIndex v23 = 0LL;
      if ((v13 & 0x81) == 0 || !CStringPtrInternal) {
        goto LABEL_45;
      }
      uint64_t v94 = theLocale;
      if (v16)
      {
        char v24 = 0LL;
      }

      else
      {
        char v25 = atomic_load((unint64_t *)&theString->info);
        p_uint64_t data = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          uint64_t v27 = *p_data;
        }

        else
        {
          char v28 = atomic_load((unint64_t *)&theString->info);
          uint64_t v27 = (char *)&p_data[(v28 & 5) != 4LL];
        }

        unint64_t v29 = atomic_load((unint64_t *)&theString->info);
        char v24 = &v27[(v29 >> 2) & 1];
      }

      if (Length <= 0)
      {
        uint64_t v22 = 0LL;
        uint64_t v31 = CStringPtrInternal;
        goto LABEL_44;
      }

      uint64_t v30 = 0LL;
      uint64_t v22 = 0LL;
      uint64_t v31 = CStringPtrInternal;
      while (1)
      {
        if (*(char *)(CStringPtrInternal + v30) < 0 || SpecialCaseHandlingLanguageIdentifierForLocale)
        {
          uint64_t v32 = __CFStringFoldCharacterClusterAtIndex( *(unsigned __int16 *)(__CFCharToUniCharTable + 2LL * *(unsigned __int8 *)(CStringPtrInternal + v30)),  buffer,  v30,  theFlagsa,  SpecialCaseHandlingLanguageIdentifierForLocale,  v103,  0LL,  0LL);
          uint64_t v22 = v32;
          if (v32 >= 1)
          {
            if (v32 != 1 || v103[0] > 0x7F || !v24) {
              goto LABEL_44;
            }
            v24[v30] = v103[0];
            uint64_t v22 = 1LL;
          }

          goto LABEL_40;
        }

LABEL_146:
                    LOWORD(v92) = -3;
                  }

                  else if ((v89 & 0xFC00) == 0xDC00)
                  {
                    LOWORD(v92) = -3;
                  }

                  else
                  {
                    LOWORD(v92) = v89;
                  }

    if (Collator && !__CompareTextDefault(Collator, v126, a7, p_dst, a3, v35, a6, &v132, &v133))
    {
      unsigned int v91 = v133;
      if (v132)
      {
        unsigned int v92 = v120;
        char v36 = v128;
        char v93 = 1LL;
        if (v133 < 0) {
          char v93 = -1LL;
        }
        uint64_t v120 = v92;
        char v133 = 0;
        unsigned int v91 = 0;
        char v37 = (int64_t)v131;
        goto LABEL_169;
      }
    }

    else
    {
      if (!p_dst || !v35) {
        _CFCompareStringsWithLocale_cold_1();
      }
      if (a3 >= a6) {
        unsigned int v89 = a6;
      }
      else {
        unsigned int v89 = a3;
      }
      unsigned int v90 = memcmp(p_dst, v35, 2 * v89);
      char v133 = v90;
      if (!v90)
      {
        char v36 = v128;
        char v37 = (int64_t)v131;
        if (a3 < a6)
        {
          char v133 = -2;
          BOOL v97 = -1LL;
          goto LABEL_185;
        }

        if (a6 < a3)
        {
          char v133 = 2;
          BOOL v97 = 1LL;
          goto LABEL_185;
        }

        unsigned int v91 = 0;
        goto LABEL_169;
      }

      if (v90 < 0) {
        unsigned int v91 = v90 - 1;
      }
      else {
        unsigned int v91 = v90 + 1;
      }
      char v133 = v91;
    }

    char v36 = v128;
    char v37 = (int64_t)v131;
LABEL_169:
    if (!v91)
    {
      char v15 = a2;
      int v16 = a5;
    }
  }

  while (a2 < v36 || a5 < v37);
  uint64_t v94 = v91 == 0;
  unsigned int v95 = v91 < 0;
  uint64_t v96 = 1LL;
  if (v95) {
    uint64_t v96 = -1LL;
  }
  if (v94) {
    BOOL v97 = v120;
  }
  else {
    BOOL v97 = v96;
  }
LABEL_185:
  uint64_t v99 = v117;
  uint64_t v98 = cf;
  uint64_t v100 = Collator;
  if (v121 >= 1) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  }
  if (v122 >= 1) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v124);
  }
LABEL_189:
  if (v100 != v99)
  {
    if (v116)
    {
      uint64_t v101 = _CFGetTSD(9u);
      __collatorFinalize(v101);
    }

    _CFSetTSD(9u, v100, (uint64_t)__collatorFinalize);
    uint64_t v102 = CFRetain(v98);
    _CFSetTSD(8u, (uint64_t)v102, 0LL);
  }

  _CFSetTSD(0x11u, a7, 0LL);
  return v97;
}

LABEL_150:
                  *(_WORD *)int v86 = v92;
                  v86 += 2;
                  unint64_t v87 = v88;
                  if (v88 >= v59) {
                    goto LABEL_154;
                  }
                  continue;
                }
              }

              uint64_t v61 = 1LL;
            }

            else
            {
              if ((v13 & 1) != 0 && v53 >= 0x41u && v53 <= 0x5Au)
              {
                uint64_t v100 = 1LL;
                v103[0] = v53 + 32;
                uint64_t v59 = v104;
                uint64_t v60 = 1LL;
                uint64_t v61 = 1LL;
LABEL_112:
                uint64_t v71 = v103;
                do
                {
                  uint64_t v72 = v71 + 1;
                  if (*((_WORD *)v71 + 1)) {
                    ++v61;
                  }
                  ++v71;
                }

                while (v72 < v59);
                int v73 = 1;
                goto LABEL_119;
              }

              uint64_t v61 = 1LL;
            }

      if (v85 == 61)
      {
        char v77 = v90;
      }

      else
      {
        unsigned int v95 = v83 - 65;
        if ((v83 - 65) >= 0x1Au)
        {
          if ((v83 - 97) > 0x19u)
          {
            if ((v83 - 48) > 9u)
            {
              if (v83 == 47) {
                unsigned int v95 = 63;
              }
              else {
                unsigned int v95 = 0;
              }
              if (v83 == 43) {
                unsigned int v95 = 62;
              }
            }

            else
            {
              unsigned int v95 = v83 + 4;
            }
          }

          else
          {
            unsigned int v95 = v83 - 71;
          }
        }

        uint64_t v96 = v85 - 65;
        if ((v85 - 65) >= 0x1Au)
        {
          if ((v85 - 97) > 0x19u)
          {
            if ((v85 - 48) > 9u)
            {
              if (v85 == 47) {
                uint64_t v96 = 63;
              }
              else {
                uint64_t v96 = 0;
              }
              if (v85 == 43) {
                uint64_t v96 = 62;
              }
            }

            else
            {
              uint64_t v96 = v85 + 4;
            }
          }

          else
          {
            uint64_t v96 = v85 - 71;
          }
        }

        char v77 = v90 + 1;
        *((_BYTE *)&v73->location + v90) = v96 | (v95 << 6);
      }

      v78 += 4LL;
      if (v78 >= v71)
      {
        uint64_t v72 = CFDataCreate(v46, (const UInt8 *)v73, v77);
        if (v73 != (CFRange *)&v129) {
          goto LABEL_82;
        }
        goto LABEL_180;
      }
    }

    uint64_t v88 = v81 - 71;
    goto LABEL_127;
  }

  uint64_t v72 = 0LL;
  int v73 = 0LL;
LABEL_82:
  free(v73);
LABEL_180:
  CFRelease(Copy);
  if (!v72)
  {
LABEL_84:
    CFStringRef Copy = 0LL;
    char v123 = 0LL;
    CFIndex v67 = 1;
    goto LABEL_188;
  }

void _CFStringAppendFormatAndArgumentsAux2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  v14[1] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  __CFStringAppendFormatCore(a1, a2, a3, a4, 0LL, a5, 0LL, a6, 0LL, 0LL, 0LL, 0LL, a7, 0LL, v14);
  if (!v13)
  {
    CFLog(3LL, (uint64_t)@"ERROR: Failed to format string: %@", v7, v8, v9, v10, v11, v12, (uint64_t)v14[0]);
    if (v14[0]) {
      CFRelease(v14[0]);
    }
  }

void _CFStringAppendValidatedFormatAndArguments( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 *a6, CFErrorRef *a7)
{
}

void _CFStringAppendFormatAndArgumentsAux(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
}

uint64_t __CFStringFindFormatSpecifiersInString( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  if (a3 >= 1)
  {
    LODWORD(v9) = 0;
    LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = 0;
    if (a5) {
      BOOL v11 = a6 == 0LL;
    }
    else {
      BOOL v11 = 1;
    }
    int v12 = !v11;
    __int128 v13 = xmmword_180C44970;
    uint64_t v79 = a4;
    int v78 = v12;
    while (1)
    {
      uint64_t v14 = a4 + 32LL * (int)v9;
      *(_DWORD *)(v14 + 4) = v10;
      char v15 = (int *)(v14 + 4);
      *(_OWORD *)(v14 + _Block_object_dispose(va, 8) = v13;
      int v16 = (_DWORD *)(v14 + 8);
      *(_DWORD *)uint64_t v14 = 0;
      char v17 = (_BYTE *)(v14 + 26);
      *(_DWORD *)(v14 + 24) = -1;
      int v18 = v10;
      uint64_t v10 = (int)v10;
      if (a1)
      {
        if ((int)v10 < a3)
        {
          do
          {
            if (*(_BYTE *)(a1 + v10) == 37) {
              break;
            }
            ++v10;
          }

          while (v10 < a3);
          goto LABEL_17;
        }
      }

      else if ((int)v10 < a3)
      {
        do
        {
          if (*(_WORD *)(a2 + 2 * v10) == 37) {
            break;
          }
          ++v10;
        }

        while (v10 < a3);
LABEL_17:
        if (v18 != (_DWORD)v10)
        {
          LODWORD(v9) = v9 + (~(_DWORD)v9 >> 31);
          goto LABEL_124;
        }
      }

      uint64_t v19 = (__int16 *)(v14 + 2);
      LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v18 + 1;
      unsigned int v20 = 0;
      char v21 = 0;
      int v22 = 0;
      int v23 = 0;
      int v24 = 0;
      char v77 = (_DWORD *)(v14 + 20);
      char v25 = (_DWORD *)(v14 + 16);
      uint64_t v76 = (_BYTE *)(v14 + 25);
      uint64_t v26 = -1LL;
      unsigned __int8 v27 = -1;
      unsigned __int8 v28 = -1;
      char v81 = (_DWORD *)(v14 + 16);
LABEL_20:
      if (a1) {
        unsigned int v29 = *(unsigned __int8 *)(a1 + (int)v10);
      }
      else {
        unsigned int v29 = *(unsigned __int16 *)(a2 + 2LL * (int)v10);
      }
      LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v10 + 1;
      if (v26 < 0)
      {
        uint64_t v82 = v19;
        while (2)
        {
          if (v24) {
            char v34 = v25;
          }
          else {
            char v34 = (_DWORD *)(v14 + 12);
          }
          int v80 = v24;
          while (2)
          {
            if (v29 - 49 < 9)
            {
              uint64_t v35 = 0LL;
              else {
                int v36 = v10;
              }
              uint64_t v37 = v36 - (uint64_t)(int)v10;
              uint64_t v38 = (unsigned __int16 *)(a2 + 2LL * (int)v10);
              char v39 = (unsigned __int8 *)(a1 + (int)v10);
              do
              {
                uint64_t v40 = (unsigned __int128)(v35 * (__int128)10LL) >> 64;
                uint64_t v41 = 10 * v35;
                if (v40 != v41 >> 63) {
                  goto LABEL_120;
                }
                uint64_t v42 = v29 - 48LL;
                BOOL v43 = __OFADD__(v41, v42);
                uint64_t v35 = v41 + v42;
                if (v43) {
                  goto LABEL_120;
                }
                if (!v37)
                {
                  *uint64_t v82 = 43;
                  LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v36;
                  goto LABEL_120;
                }

                if (a1) {
                  unsigned int v29 = *v39;
                }
                else {
                  unsigned int v29 = *v38;
                }
                LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v10 + 1;
                --v37;
                ++v38;
                ++v39;
              }

              while (v29 - 48 < 0xA);
              if (v29 == 36)
              {
                char v25 = (_DWORD *)(v14 + 16);
                int v24 = v80;
                if (v35 <= 127)
                {
                  a4 = v79;
                  if (v28 == 254)
                  {
                    unsigned __int8 v28 = v35 - 1;
                    _BYTE *v76 = v35 - 1;
                  }

                  else if (v27 == 254)
                  {
                    *char v17 = v35 - 1;
                    unsigned __int8 v27 = v35 - 1;
                  }

                  else
                  {
                    *(_BYTE *)(v14 + 24) = v35 - 1;
                  }

LABEL_115:
                  int v12 = v78;
                  goto LABEL_116;
                }

                a4 = v79;
                int v12 = v78;
              }

              else
              {
                char v25 = (_DWORD *)(v14 + 16);
                int v24 = v80;
                if (v35 <= 0x7FFFFFFF)
                {
                  _DWORD *v34 = v35;
                  continue;
                }

LABEL_120:
                a4 = v79;
LABEL_121:
                int v12 = v78;
              }

              goto LABEL_122;
            }

            break;
          }

          switch(v29)
          {
            case ' ':
              a4 = v79;
              if ((v20 & 4) == 0)
              {
                v20 |= 8u;
                *char v77 = v20;
              }

              goto LABEL_94;
            case '#':
              int v23 = 1;
              goto LABEL_93;
            case '*':
              unsigned __int8 v27 = -2;
              *char v17 = -2;
              goto LABEL_93;
            case '+':
              unsigned int v20 = v20 & 0xFFFFFFF3 | 4;
              goto LABEL_86;
            case '-':
              unsigned int v20 = v20 & 0xFFFFFFFC | 2;
LABEL_86:
              *char v77 = v20;
              goto LABEL_93;
            case '.':
              a4 = v79;
              if ((int)v10 >= (int)a3)
              {
                *uint64_t v82 = 43;
                goto LABEL_121;
              }

              if (a1) {
                unsigned int v29 = *(unsigned __int8 *)(a1 + (int)v10);
              }
              else {
                unsigned int v29 = *(unsigned __int16 *)(a2 + 2LL * (int)v10);
              }
              LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v10 + 1;
              int v24 = 1;
              if (v29 != 42) {
                continue;
              }
              unsigned __int8 v28 = -2;
              _BYTE *v76 = -2;
LABEL_93:
              a4 = v79;
LABEL_94:
              int v12 = v78;
LABEL_116:
              uint64_t v19 = v82;
LABEL_71:
              if ((int)v10 >= (int)a3)
              {
LABEL_117:
                __int16 *v19 = 43;
                goto LABEL_122;
              }

              goto LABEL_20;
            case '0':
              a4 = v79;
              if (v24)
              {
                *char v25 = 0;
                int v24 = 1;
                goto LABEL_94;
              }

              int v24 = 0;
              if ((v20 & 2) == 0)
              {
                v20 |= 1u;
                *char v77 = v20;
              }

              goto LABEL_115;
            case '@':
              a4 = v79;
              if (v23)
              {
                int v23 = 0;
                uint64_t v26 = (int)v10;
                goto LABEL_94;
              }

              *uint64_t v82 = 37;
              *(_WORD *)uint64_t v14 = 4;
              goto LABEL_121;
            case 'A':
            case 'a':
              goto LABEL_135;
            case 'C':
              *uint64_t v82 = 41;
              __int16 v69 = 2;
              goto LABEL_190;
            case 'D':
            case 'U':
            case 'd':
            case 'i':
            case 'u':
              uint64_t v75 = a5;
              uint64_t v51 = a6;
              if ((v29 & 0xFFDF) == 0x55) {
                char v52 = 4;
              }
              else {
                char v52 = 1;
              }
              *(_BYTE *)(v79 + 32LL * (int)v9 + 2_Block_object_dispose(va, 8) = v52;
              a6 = v51;
              a5 = v75;
              __int128 v13 = xmmword_180C44970;
              goto LABEL_146;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              int v73 = a6;
              uint64_t v74 = a5;
              if (v29 - 65 >= 0x1A) {
                __int16 v49 = v29;
              }
              else {
                __int16 v49 = v29 + 32;
              }
              *(_BYTE *)(v79 + 32LL * (int)v9 + 2_Block_object_dispose(va, 8) = ((v49 & 0xFFFE) == 102) | (2 * ((v49 & 0xFFFD) == 101));
              a6 = v73;
              a5 = v74;
              __int128 v13 = xmmword_180C44970;
LABEL_135:
              *uint64_t v82 = 34;
              a4 = v79;
              if (*(_WORD *)v14 != 5) {
                *(_WORD *)uint64_t v14 = 4;
              }
              goto LABEL_148;
            case 'L':
              __int16 v44 = 5;
              goto LABEL_74;
            case 'O':
            case 'X':
            case 'o':
            case 'x':
LABEL_146:
              *uint64_t v82 = 33;
              goto LABEL_147;
            case 'P':
              __int16 v70 = 40;
              goto LABEL_189;
            case 'S':
              __int16 v70 = 38;
              goto LABEL_189;
            case '[':
              if (!v22) {
                uint64_t v26 = (int)v10;
              }
              int v22 = 1;
              goto LABEL_93;
            case 'c':
              *uint64_t v82 = 33;
              __int16 v71 = 1;
              goto LABEL_187;
            case 'h':
              a4 = v79;
              if ((int)v10 < (int)a3
                && (!a1
                  ? (int v46 = *(unsigned __int16 *)(a2 + 2LL * (int)v10))
                  : (int v46 = *(unsigned __int8 *)(a1 + (int)v10)),
                    v46 == 104))
              {
                LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v10 + 1;
                __int16 v47 = 1;
              }

              else
              {
                __int16 v47 = 2;
              }

              goto LABEL_114;
            case 'j':
            case 'q':
            case 't':
            case 'z':
              __int16 v44 = 4;
LABEL_74:
              *(_WORD *)uint64_t v14 = v44;
              goto LABEL_93;
            case 'l':
              a4 = v79;
              if ((int)v10 < (int)a3)
              {
                int v45 = a1 ? *(unsigned __int8 *)(a1 + (int)v10) : *(unsigned __int16 *)(a2 + 2LL * (int)v10);
                if (v45 == 108) {
                  LODWORD(_CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName, v6, v7, v8, v9, v10) = v10 + 1;
                }
              }

              __int16 v47 = 4;
LABEL_114:
              *(_WORD *)uint64_t v14 = v47;
              goto LABEL_115;
            case 'n':
              __int16 v70 = 42;
              goto LABEL_189;
            case 'p':
              *uint64_t v82 = 35;
              __int16 v71 = 4;
LABEL_187:
              *(_WORD *)uint64_t v14 = v71;
LABEL_147:
              a4 = v79;
LABEL_148:
              unint64_t v53 = (v10 - v18);
              *int v16 = v53;
              int v12 = v78;
              if (!v78) {
                goto LABEL_124;
              }
              uint64_t v54 = *v15;
              uint64_t v55 = a5;
              CFIndex v56 = a6;
              if (a1)
              {
                if ((int)v53 >= 1)
                {
                  uint64_t v57 = 0LL;
                  unsigned int v58 = 0;
                  while (1)
                  {
                    int v59 = *(unsigned __int8 *)(a1 + v57 + v54);
                    if (v59 == 36)
                    {
                      if ((v58 & 0x80000000) == 0)
                      {
                        uint64_t v60 = v58;
                        while (1)
                        {
                          BOOL v61 = v60-- < 1;
                          if (v61) {
                            break;
                          }
                        }

                        LODWORD(v60) = -1;
                        goto LABEL_160;
                      }
                    }

                    else
                    {
                      __s.i8[v58] = v59;
                    }

                    LODWORD(v60) = v58;
LABEL_160:
                    unsigned int v58 = v60 + 1;
                  }
                }

LABEL_178:
                unsigned int v58 = 0;
                goto LABEL_179;
              }

              uint64_t v62 = 0LL;
              unsigned int v58 = 0;
              break;
            case 's':
              __int16 v70 = 39;
LABEL_189:
              *uint64_t v82 = v70;
              __int16 v69 = 4;
LABEL_190:
              *(_WORD *)uint64_t v14 = v69;
              goto LABEL_120;
            default:
              *uint64_t v82 = 32;
              LODWORD(v9) = v9 + (~(_DWORD)v9 >> 31);
              a4 = v79;
              int v12 = v78;
              goto LABEL_124;
          }

          break;
        }

        while (2)
        {
          int v63 = *(unsigned __int16 *)(a2 + 2 * (v62 + v54));
          if (v63 == 36)
          {
            if ((v58 & 0x80000000) == 0)
            {
              uint64_t v64 = v58;
              while (1)
              {
                BOOL v61 = v64-- < 1;
                if (v61) {
                  break;
                }
              }

              LODWORD(v64) = -1;
LABEL_174:
              unsigned int v58 = v64 + 1;
              if (++v62 >= v53 || (int)v64 >= 127)
              {
LABEL_179:
                __s.i8[v58] = 0;
                size_t v65 = strlen(__s.i8);
                CFTypeRef v67 = __CFStringCreateImmutableFunnel3(0LL, &__s, v65, 134217984LL, 8LL, -1LL, 0LL, v66);
                a6 = v56;
                uint64_t v68 = (*v56)++;
                a5 = v55;
                *(void *)(v55 + 8 * v6_Block_object_dispose(va, 8) = v67;
                a4 = v79;
                int v12 = v78;
                __int128 v13 = xmmword_180C44970;
                goto LABEL_124;
              }

              continue;
            }
          }

          else
          {
            __s.i8[v58] = v63;
          }

          break;
        }

        LODWORD(v64) = v58;
        goto LABEL_174;
      }

      if (v29 >= 0x30 && v29 - 58 >= 7)
      {
        BOOL v31 = v29 == 95 || v29 - 91 >= 6;
        BOOL v32 = !v31;
        if (v29 <= 0x7A && !v32) {
          goto LABEL_71;
        }
      }

      if (v29 == 93)
      {
        if (v22) {
          char v21 = 1;
        }
        goto LABEL_71;
      }

      if (v29 != 64)
      {
        uint64_t v26 = -1LL;
        goto LABEL_71;
      }

      int v50 = v20 | 0x40;
      if (!v21) {
        int v50 = v20;
      }
      *char v77 = v50 | 0x10;
      __int16 *v19 = 37;
      *(_WORD *)uint64_t v14 = 4;
LABEL_122:
      *int v16 = v10 - v18;
      if (v12)
      {
        uint64_t v48 = (*a6)++;
        *(void *)(a5 + 8 * v4_Block_object_dispose(va, 8) = 0LL;
      }

LABEL_124:
      uint64_t v9 = (v9 + 1);
    }
  }

  return 0LL;
}

BOOL _CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  return __CFStringValidateFormat(a2, a1) >= 0;
}

uint64_t __CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v30 = v3;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v8 = (const __CFString *)v2;
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v9 = _CFGetTSD(1u);
  if (v9) {
    uint64_t v10 = (const __CFAllocator *)v9;
  }
  else {
    uint64_t v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  char v39 = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v35 = 0LL;
  ptr = 0LL;
  unint64_t v33 = 0LL;
  char v34 = 0LL;
  BOOL v31 = 0LL;
  BOOL v32 = 0LL;
  CFIndex Length = CFStringGetLength(v7);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)v7, Length, &v40, &v39, (UniChar **)&ptr, v48, &v34, v46, &v32, v44);
  CFIndex v12 = CFStringGetLength(v8);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)v8, v12, &v38, &v37, (UniChar **)&v35, v47, &v33, v45, &v31, v43);
  __int128 v13 = v34;
  uint64_t v14 = v32;
  int FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString( (uint64_t)v40,  (uint64_t)v39,  Length,  (uint64_t)v34,  (uint64_t)v32,  &v42);
  int v16 = v33;
  char v17 = v31;
  int v18 = __CFStringFindFormatSpecifiersInString((uint64_t)v38, (uint64_t)v37, v12, (uint64_t)v33, (uint64_t)v31, &v41);
  int v19 = __CFStringValidateFormatSpecBuffers(v13, FormatSpecifiersInString, v42, (uint64_t)v16, v18, v41, v5);
  int v20 = v19;
  if (v30 && (v19 & 1) == 0)
  {
    CFStringRef v21 = CFStringCreateWithFormat(v10, 0LL, @"Format '%@' does not match expected '%@'", v7, v8);
    CFMutableStringRef Mutable = CFDictionaryCreateMutable( v10,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"NSDebugDescription", v21);
    *uint64_t v30 = CFErrorCreate(v10, @"NSCocoaErrorDomain", 2048LL, Mutable);
    CFRelease(Mutable);
    CFRelease(v21);
  }

  if (ptr && ptr != v48) {
    CFAllocatorDeallocate(v10, ptr);
  }
  if (v35 && v35 != v47) {
    CFAllocatorDeallocate(v10, v35);
  }
  if (v16 != v45) {
    CFAllocatorDeallocate(v10, v16);
  }
  uint64_t v23 = v42;
  if (v42 >= 1)
  {
    uint64_t v24 = 0LL;
    do
    {
      char v25 = (const void *)v14[v24];
      if (v25)
      {
        CFRelease(v25);
        uint64_t v23 = v42;
      }

      ++v24;
    }

    while (v24 < v23);
  }

  uint64_t v26 = v41;
  if (v41 >= 1)
  {
    uint64_t v27 = 0LL;
    do
    {
      unsigned __int8 v28 = (const void *)v17[v27];
      if (v28)
      {
        CFRelease(v28);
        uint64_t v26 = v41;
      }

      ++v27;
    }

    while (v27 < v26);
  }

  if (v14 != (void *)v44) {
    CFAllocatorDeallocate(v10, v14);
  }
  if (v17 != (void *)v43) {
    CFAllocatorDeallocate(v10, v17);
  }
  if (v20) {
    return v5 + FormatSpecifiersInString;
  }
  else {
    return -1LL;
  }
}

void CFShowStr(CFStringRef str)
{
  if (!str)
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1895F89E0];
    char v3 = "(null)\n";
    size_t v4 = 7LL;
    goto LABEL_5;
  }

  if (CF_IS_OBJC(7uLL, (__objc2_class **)str))
  {
    uint64_t v2 = (FILE *)*MEMORY[0x1895F89E0];
    char v3 = "This is an NSString, not CFString\n";
    size_t v4 = 34LL;
LABEL_5:
    fwrite(v3, v4, 1uLL, v2);
    return;
  }

  CFAllocatorRef v5 = CFGetAllocator(str);
  uint64_t v6 = (FILE **)MEMORY[0x1895F89E0];
  char v7 = atomic_load((unint64_t *)&str->info);
  uint64_t v8 = v7 & 5;
  char v9 = atomic_load((unint64_t *)&str->info);
  uint64_t v10 = v9 & 0x60;
  if (v8 == 4)
  {
    p_uint64_t data = &str->data;
    if (v10)
    {
      uint64_t length = (char **)*p_data;
    }

    else
    {
      uint64_t v13 = atomic_load((unint64_t *)&str->info);
      uint64_t length = &p_data[(v13 & 5) != 4];
    }

    LODWORD(length) = *(unsigned __int8 *)length;
  }

  else if ((v9 & 0x60) != 0)
  {
    uint64_t length = (char **)str->length;
  }

  else
  {
    uint64_t length = (char **)str->data;
  }

  unsigned int v14 = atomic_load((unint64_t *)&str->info);
  fprintf((FILE *)*MEMORY[0x1895F89E0], "\nLength %d\nIsEightBit %d\n", (_DWORD)length, ((v14 >> 4) & 1) == 0);
  char v15 = *v6;
  unsigned int v16 = atomic_load((unint64_t *)&str->info);
  unsigned int v17 = atomic_load((unint64_t *)&str->info);
  char v18 = atomic_load((unint64_t *)&str->info);
  fprintf( v15,  "HasLengthByte %d\nHasNullByte %d\nInlineContents %d\n",  (v16 >> 2) & 1,  (v17 >> 3) & 1,  (v18 & 0x60) == 0LL);
  fwrite("Allocator ", 0xAuLL, 1uLL, *v6);
  int v19 = *v6;
  if (v5 == (CFAllocatorRef)&__kCFAllocatorSystemDefault) {
    fwrite("SystemDefault\n", 0xEuLL, 1uLL, v19);
  }
  else {
    fprintf(v19, "%p\n", v5);
  }
  int v20 = *v6;
  p_unint64_t info = &str->info;
  char v22 = atomic_load((unint64_t *)&str->info);
  fprintf(v20, "Mutable %d\n", v22 & 1);
  char v23 = atomic_load((unint64_t *)&str->info);
  if ((v23 & 1) != 0 || (char v24 = atomic_load((unint64_t *)p_info), (~v24 & 0x60) != 0))
  {
    char v29 = atomic_load((unint64_t *)p_info);
    if ((v29 & 1) != 0)
    {
      char v30 = atomic_load((unint64_t *)&str->info);
      if ((~v30 & 0x60) == 0) {
        fprintf(*v6, "ExternalContentsAllocator %p\n");
      }
    }
  }

  else
  {
    char v25 = atomic_load((unint64_t *)&str->info);
    BOOL v26 = (v25 & 5) == 4LL;
    uint64_t v27 = 32LL;
    if (v26) {
      uint64_t v27 = 24LL;
    }
    unsigned __int8 v28 = *v6;
    if (*(void **)((char *)&str->isa + v27))
    {
      atomic_load((unint64_t *)&str->info);
      fprintf(v28, "ContentsDeallocatorFunc %p\n");
    }

    else
    {
      fwrite("ContentsDeallocatorFunc None\n", 0x1DuLL, 1uLL, v28);
    }
  }

  char v31 = atomic_load((unint64_t *)&str->info);
  if ((v31 & 1) != 0)
  {
    BOOL v32 = "Fixed";
    unint64_t info = str[1].info;
    if ((info & 2) == 0) {
      BOOL v32 = "Desired";
    }
    fprintf(*v6, "CurrentCapacity %d\n%sCapacity %d\n", str[1].isa, v32, info >> 4);
  }

  char v34 = atomic_load((unint64_t *)&str->info);
  uint64_t v35 = &str->data;
  if ((v34 & 0x60) != 0)
  {
    int v36 = *v35;
  }

  else
  {
    char v37 = atomic_load((unint64_t *)&str->info);
    int v36 = (char *)&v35[(v37 & 5) != 4LL];
  }

  fprintf(*v6, "Contents %p\n", v36);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  if (CFStringGetLength(string)) {
    return -[__CFString getFileSystemRepresentation:maxLength:]( (id)string,  "getFileSystemRepresentation:maxLength:",  buffer,  maxBufLen);
  }
  if (!maxBufLen) {
    return 0;
  }
  *UniChar buffer = 0;
  return 1;
}

uint64_t _CFStringGetFileSystemRepresentation(__CFString *a1, _BYTE *a2, uint64_t a3)
{
  if (CFStringGetLength(a1)) {
    return -[__CFString getFileSystemRepresentation:maxLength:](a1, "getFileSystemRepresentation:maxLength:", a2, a3);
  }
  if (!a3) {
    return 0LL;
  }
  *a2 = 0;
  return 1LL;
}

CFStringRef _CFStringNeedsMarkdownParsing(const __CFString *a1, CFBundleRef bundle)
{
  if (!bundle) {
    return 0LL;
  }
  CFRange result = CFBundleGetIdentifier(bundle);
  if (result)
  {
    size_t v4 = result;
    v5.uint64_t length = CFStringGetLength(result);
    v5.CFIndex location = 0LL;
    CFRange result = (const __CFString *)CFStringFindWithOptionsAndLocale(v4, @"com.apple.", v5, 8uLL, 0LL, 0LL);
    if ((_DWORD)result) {
      return (const __CFString *)(CFStringFind(a1, @"^[", 0LL).location != -1);
    }
  }

  return result;
}

uint64_t _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(__CFString *a1, __CFBundle *a2, uint64_t a3)
{
  if (_CFStringNeedsMarkdownParsing(a1, a2))
  {
    uint64_t FormatSpecifierConfiguration = _CFStringGetFormatSpecifierConfiguration(a1);
    return _CFStringCreateWithMarkdownAndConfiguration((uint64_t)a1, FormatSpecifierConfiguration, (uint64_t)a2, a3);
  }

  else
  {
    CFRetain(a1);
    return (uint64_t)a1;
  }

void __CFStrDeallocateMutableContents(uint64_t a1, void *a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      char v3 = &kCFAllocatorSystemDefault;
    }

    else
    {
      char v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0) {
        char v3 = &kCFAllocatorSystemDefault;
      }
      else {
        char v3 = (const CFAllocatorRef *)(a1 - 16);
      }
    }
  }

  else
  {
    char v3 = (const CFAllocatorRef *)(a1 + 48);
  }

  CFRange v5 = *v3;
  char v6 = atomic_load((unint64_t *)(a1 + 8));
  if ((v6 & 1) != 0) {
    atomic_load((unint64_t *)(a1 + 8));
  }
  CFAllocatorDeallocate(v5, a2);
}

uint64_t __CFStringGetLongCharacterFromInlineBuffer( UniChar *buffer, int64_t a2, int64_t a3, int64_t *a4)
{
  if ((a3 & 0x8000000000000000LL) == 0)
  {
    int64_t v5 = a3;
    if (a3 < a2)
    {
      int64_t v8 = *((void *)buffer + 20);
      if (v8 <= a3)
      {
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v9 = *((void *)buffer + 17);
        if (v9)
        {
          UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + a3));
        }

        else
        {
          uint64_t v14 = *((void *)buffer + 18);
          if (v14)
          {
            UniChar v10 = *(char *)(v14 + *((void *)buffer + 19) + a3);
          }

          else
          {
            if (*((void *)buffer + 22) <= a3 || (int64_t v15 = *((void *)buffer + 21), v15 > a3))
            {
              int64_t v16 = a3 - 4;
              if (v16 + 64 < v8) {
                int64_t v8 = v16 + 64;
              }
              *((void *)buffer + 21) = v16;
              *((void *)buffer + 22) = v8;
              v32.CFIndex location = *((void *)buffer + 19) + v16;
              v32.uint64_t length = v8 - v16;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              int64_t v15 = *((void *)buffer + 21);
            }

            UniChar v10 = buffer[v5 - v15];
          }
        }

        uint64_t v11 = v10;
        if ((v10 & 0xFC00) != 0xD800 || a2 - 1 <= v5)
        {
          uint64_t v12 = 1LL;
          if (v5 && (v10 & 0xFC00) == 0xDC00)
          {
            int64_t v18 = *((void *)buffer + 20);
            if (v18 < v5) {
              goto LABEL_9;
            }
            int64_t v19 = v5 - 1;
            uint64_t v20 = *((void *)buffer + 17);
            if (v20)
            {
              UniChar v21 = *(_WORD *)(v20 + 2 * (*((void *)buffer + 19) + v19));
            }

            else
            {
              uint64_t v27 = *((void *)buffer + 18);
              if (v27)
              {
                UniChar v21 = *(char *)(v27 + *((void *)buffer + 19) + v19);
              }

              else
              {
                if (*((void *)buffer + 22) < v5 || (int64_t v30 = *((void *)buffer + 21), v30 >= v5))
                {
                  int64_t v31 = v5 - 5;
                  if (v31 + 64 < v18) {
                    int64_t v18 = v31 + 64;
                  }
                  *((void *)buffer + 21) = v31;
                  *((void *)buffer + 22) = v18;
                  v34.CFIndex location = *((void *)buffer + 19) + v31;
                  v34.uint64_t length = v18 - v31;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
                  int64_t v30 = *((void *)buffer + 21);
                }

                UniChar v21 = buffer[v19 - v30];
              }
            }

            if (v21 >> 10 != 54) {
              goto LABEL_9;
            }
            uint64_t v11 = v11 + (v21 << 10) - 56613888;
            uint64_t v12 = 2LL;
            --v5;
          }

uint64_t __CFStringGetExtendedPictographicSequenceComponent( UniChar *buffer, int64_t a2, int64_t a3, uint64_t *a4)
{
  uint64_t result = 0LL;
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a3 < 0 || a3 >= a2) {
    return result;
  }
  int64_t v21 = a3;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = -1LL;
  uint64_t v22 = 0LL;
  int64_t v10 = -1LL;
  int64_t v11 = -1LL;
  int64_t v12 = -1LL;
  while (1)
  {
    UChar32 LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, a3, &v21);
    if (u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
      || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER))
    {
      uint64_t v14 = v7 + 1;
      if (v7 > 63) {
        goto LABEL_21;
      }
      uint64_t v9 = v21;
      int64_t v12 = v21;
      goto LABEL_8;
    }

    if (LongCharacterFromInlineBuffer == 8205)
    {
      if (v12 != -1 || v11 != -1) {
        break;
      }
      int64_t v12 = -1LL;
      uint64_t v9 = v21;
      int64_t v11 = v21;
      goto LABEL_19;
    }

    if (!u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EXTENDED_PICTOGRAPHIC)
      || v10 != -1
      || v11 != -1
      || v12 != -1)
    {
      break;
    }

    uint64_t v9 = v21;
    int64_t v11 = -1LL;
    int64_t v10 = v21;
LABEL_19:
    uint64_t v14 = v7;
LABEL_8:
    v8 += v22;
    uint64_t v7 = v14;
    a3 = v9 - 1;
    int64_t v21 = v9 - 1;
    if (v9 < 1) {
      goto LABEL_21;
    }
  }

  uint64_t v14 = v7;
LABEL_21:
  if (v10 != -1)
  {
    int64_t v15 = a4;
    if (a4)
    {
      if (v12 != -1 && v11 == -1)
      {
        uint64_t v9 = v10;
        int64_t v16 = v12 - v10;
      }

      else
      {
        int64_t v16 = 0LL;
      }

      v8 += v16;
LABEL_27:
      *int64_t v15 = v9;
      v15[1] = v8;
      void v15[2] = v12;
      v15[3] = v11;
      uint64_t result = 1LL;
      v15[4] = v10;
      return result;
    }

    return 1LL;
  }

  if (v11 == -1 && v12 == -1) {
    return 0LL;
  }
  int64_t v17 = v9 + v8;
  int64_t v21 = v9 + v8;
  uint64_t v22 = 0LL;
  if (v9 + v8 >= a2) {
    return 0LL;
  }
  do
  {
    UChar32 v18 = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, v17, &v21);
    if (u_hasBinaryProperty(v18, UCHAR_GRAPHEME_EXTEND) || u_hasBinaryProperty(v18, UCHAR_EMOJI_MODIFIER))
    {
      uint64_t result = 0LL;
      if (v11 != -1 || v14 > 62) {
        return result;
      }
      ++v14;
      int64_t v11 = -1LL;
      int64_t v19 = v21;
      int64_t v10 = -1LL;
    }

    else if (v18 == 8205)
    {
      if (v11 != -1) {
        return 0LL;
      }
      int64_t v10 = -1LL;
      int64_t v19 = v21;
      int64_t v11 = v21;
    }

    else
    {
      uint64_t result = u_hasBinaryProperty(v18, UCHAR_EXTENDED_PICTOGRAPHIC);
      if (!(_DWORD)result) {
        return result;
      }
      int64_t v19 = v21;
      int64_t v10 = v21;
    }

    v8 += v22;
    int64_t v17 = v19 + v22;
    int64_t v21 = v19 + v22;
    uint64_t v22 = 0LL;
  }

  while (v10 == -1 && v17 < a2);
  uint64_t result = 0LL;
  if (v10 != -1 && v14 <= 63)
  {
    int64_t v15 = a4;
    if (a4) {
      goto LABEL_27;
    }
    return 1LL;
  }

  return result;
}

char *__CFStringChangeSizeMultiple(char *result, uint64_t a2, CFIndex size, uint64_t a4, int a5)
{
  uint64_t v158 = *MEMORY[0x1895F89C0];
  int64_t v5 = (unint64_t *)(result + 8);
  char v6 = atomic_load((unint64_t *)result + 1);
  uint64_t v7 = (uint64_t *)(result + 16);
  if ((v6 & 0x60) != 0)
  {
    uint64_t v8 = (uint64_t *)*v7;
    if (*v7) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v10 = 0LL;
    goto LABEL_10;
  }

  char v11 = atomic_load(v5);
  uint64_t v8 = &v7[(v11 & 5) != 4LL];
  if (!v8) {
    goto LABEL_6;
  }
LABEL_3:
  char v9 = atomic_load(v5);
  if ((v9 & 5) == 4LL)
  {
    uint64_t v10 = *(unsigned __int8 *)v8;
  }

  else
  {
    char v12 = atomic_load(v5);
    if ((v12 & 0x60) != 0) {
      uint64_t v10 = *((void *)result + 3);
    }
    else {
      uint64_t v10 = *v7;
    }
  }

LABEL_267:
          __CFStringHandleOutOfMemory();
        }
      }

      if ((v31 & 0x8000000000000000LL) != 0) {
        goto LABEL_267;
      }
      if (v31 <= (*((void *)v155 + 5) >> 4) * v156) {
        size_t v44 = (*((void *)v155 + 5) >> 4) * v156;
      }
      else {
        size_t v44 = v31;
      }
      char v45 = atomic_load((unint64_t *)v155 + 1);
      if ((~v45 & 0x60) != 0) {
        uint64_t v46 = malloc_good_size(v44);
      }
      else {
        uint64_t v46 = CFAllocatorGetPreferredSizeForSize(*((CFAllocatorRef *)v155 + 6), v44, 0LL);
      }
      if (v46 < 0) {
        CFIndex v30 = -1LL;
      }
      else {
        CFIndex v30 = v46;
      }
    }

    uint64_t v43 = (uint64_t)v155;
    goto LABEL_157;
  }

  int v47 = 0;
  unsigned int v48 = atomic_load(v5);
  unsigned int v49 = (v48 >> 2) & 1;
  uint64_t v50 = v151;
  uint64_t v51 = v152;
  uint64_t v52 = (uint64_t)&v152[v17];
  uint64_t result = v152;
  int v53 = (v18 & 0x10) >> 4;
LABEL_160:
  int64_t v143 = result;
  uint64_t v144 = v29;
  uint64_t v83 = (v18 >> 4) & 1;
  uint64_t v84 = (unsigned __int8 *)&v51[v49];
  if (v145 == v53)
  {
    unsigned int v140 = v49;
    int v141 = v47;
    uint64_t v85 = a4;
    uint64_t v86 = v154;
    if ((unsigned __int8 *)v52 != v84)
    {
      copyBlocks(v84, v52, v149, v83, (v18 >> 4) & 1, a2, v154, a4);
      goto LABEL_163;
    }

    if (v154 >= 1)
    {
      uint64_t v111 = 0LL;
      uint64_t v112 = 0LL;
      uint64_t v113 = 0LL;
      int v142 = 0;
      p_char ptr = &ptr;
      uint64_t v115 = 10LL;
      while (1)
      {
        CFRange v116 = (void *)(a2 + 16 * v112);
        uint64_t v117 = v116[1];
        uint64_t v118 = v117 + *v116;
        if (v86 - v112 == 1)
        {
          size_t v119 = (v149 - v118) * v34;
          if (!v119) {
            goto LABEL_257;
          }
        }

        else
        {
          size_t v119 = (v116[2] - v118) * v34;
        }

        uint64_t v120 = v118 * v34;
        v111 += (v85 - v117) * v34;
        if (v111 <= 0)
        {
          if (v111) {
            BOOL v123 = v119 == 0;
          }
          else {
            BOOL v123 = 1;
          }
          if (!v123)
          {
            uint64_t v124 = (void *)(v52 + v111 + v120);
            char v125 = (const void *)(v52 + v120);
            uint64_t v126 = p_ptr;
            uint64_t v127 = v115;
            memmove(v124, v125, v119);
            uint64_t v115 = v127;
            p_char ptr = v126;
            uint64_t v34 = v156;
          }

          if (v113 >= 1)
          {
            uint64_t v146 = v115;
            unint64_t v128 = v113 + 1;
            char v129 = p_ptr;
            uint64_t v130 = &p_ptr[24 * v113 - 8];
            uint64_t v86 = v154;
            do
            {
              size_t v131 = *((void *)v130 - 1);
              if (*(void *)v130) {
                BOOL v132 = v131 == 0;
              }
              else {
                BOOL v132 = 1;
              }
              if (!v132) {
                memmove( (void *)(v52 + *((void *)v130 - 2) + *(void *)v130),  (const void *)(v52 + *((void *)v130 - 2)),  v131);
              }
              --v128;
              v130 -= 24;
            }

            while (v128 > 1);
            uint64_t v113 = 0LL;
            uint64_t v34 = v156;
            p_char ptr = v129;
            uint64_t v115 = v146;
            goto LABEL_256;
          }
        }

        else
        {
          if (v113 == v115)
          {
            uint64_t v121 = p_ptr;
            uint64_t v122 = 2 * v115 + 8;
            if (v142)
            {
              p_char ptr = (char *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  p_ptr,  24 * v122,  0LL,  0LL);
            }

            else
            {
              uint64_t v147 = v115;
              int64_t v139 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 24 * v122, 0LL);
              memmove(v139, v121, 24 * v147);
              int v142 = 1;
              p_char ptr = (char *)v139;
            }

            uint64_t v34 = v156;
          }

          else
          {
            uint64_t v122 = v115;
          }

          char v133 = (uint64_t *)&p_ptr[24 * v113];
          uint64_t *v133 = v120;
          v133[1] = v119;
          v133[2] = v111;
          ++v113;
          uint64_t v115 = v122;
          uint64_t v85 = a4;
        }

        uint64_t v86 = v154;
LABEL_256:
        if (++v112 == v86)
        {
LABEL_257:
          CFRange v134 = p_ptr;
          uint64_t v51 = v152;
          int v53 = v148;
          if (v113 >= 1)
          {
            unint64_t v135 = v113 + 1;
            unsigned int v136 = &p_ptr[24 * v113 - 8];
            do
            {
              size_t v137 = *((void *)v136 - 1);
              if (*(void *)v136) {
                BOOL v138 = v137 == 0;
              }
              else {
                BOOL v138 = 1;
              }
              if (!v138) {
                memmove( (void *)(v52 + *((void *)v136 - 2) + *(void *)v136),  (const void *)(v52 + *((void *)v136 - 2)),  v137);
              }
              --v135;
              v136 -= 24;
            }

            while (v135 > 1);
          }

          if (v142) {
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v134);
          }
          break;
        }
      }
    }

LABEL_180:
    if (v49)
    {
      unint64_t v92 = atomic_load(v5);
      while (1)
      {
        unint64_t v93 = __ldaxr(v5);
        if (v93 != v92) {
          break;
        }
        if (__stlxr(v92 & 0xFFFFFFFFFFFFFFFBLL, v5)) {
          goto LABEL_186;
        }
        int v94 = 1;
LABEL_187:
        unint64_t v92 = v93;
        if (v94)
        {
          unint64_t v95 = atomic_load(v5);
          while (1)
          {
            unint64_t v96 = __ldaxr(v5);
            if (v96 != v95) {
              break;
            }
            if (__stlxr(v95 & 0xFFFFFFFFFFFFFFF7LL, v5)) {
              goto LABEL_193;
            }
            int v97 = 1;
LABEL_194:
            unint64_t v95 = v96;
            if (v97) {
              goto LABEL_222;
            }
          }

          __clrex();
LABEL_193:
          int v97 = 0;
          goto LABEL_194;
        }
      }

      __clrex();
LABEL_186:
      int v94 = 0;
      goto LABEL_187;
    }

    goto LABEL_222;
  }

  *(_BYTE *)(v52 + v13) = 0;
  if (v13 <= 255) {
    char v98 = v13;
  }
  else {
    char v98 = 0;
  }
  *uint64_t result = v98;
  uint64_t v88 = (unint64_t *)v155;
  if (!v49)
  {
    unint64_t v99 = atomic_load(v5);
    while (1)
    {
      unint64_t v100 = __ldaxr(v5);
      if (v100 != v99) {
        break;
      }
      if (__stlxr(v99 | 4, v5)) {
        goto LABEL_205;
      }
      int v101 = 1;
LABEL_206:
      unint64_t v99 = v100;
      if (v101)
      {
        unint64_t v102 = atomic_load(v5);
        while (1)
        {
          unint64_t v103 = __ldaxr(v5);
          if (v103 != v102) {
            break;
          }
          if (__stlxr(v102 | 8, v5)) {
            goto LABEL_212;
          }
          int v104 = 1;
LABEL_213:
          unint64_t v102 = v103;
          if (v104) {
            goto LABEL_214;
          }
        }

        __clrex();
LABEL_212:
        int v104 = 0;
        goto LABEL_213;
      }
    }

    __clrex();
LABEL_205:
    int v101 = 0;
    goto LABEL_206;
  }

LABEL_214:
  if (v53)
  {
    unint64_t v105 = atomic_load(v5);
    while (1)
    {
      unint64_t v106 = __ldaxr(v5);
      if (v106 != v105) {
        break;
      }
      if (__stlxr(v105 & 0xFFFFFFFFFFFFFFEFLL, v5)) {
        goto LABEL_220;
      }
      char v107 = 1;
LABEL_221:
      unint64_t v105 = v106;
      if ((v107 & 1) != 0) {
        goto LABEL_222;
      }
    }

    __clrex();
LABEL_220:
    char v107 = 0;
    goto LABEL_221;
  }

LABEL_222:
  char v108 = atomic_load(v88 + 1);
  BOOL v25 = (v108 & 0x60) == 0LL;
  uint64_t v109 = 3LL;
  if (v25) {
    uint64_t v109 = 2LL;
  }
  v88[v109] = v13;
  if (v47)
  {
    unint64_t v110 = v88[5] & 0xFFFFFFFFFFFFFFF7LL;
    v88[4] = v29;
    v88[5] = v110;
    v88[2] = (unint64_t)result;
  }

  return result;
}

void *__CFStrAllocateMutableContents(uint64_t a1, CFIndex a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      char v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }

    else
    {
      char v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0) {
        char v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }
      else {
        char v3 = (CFAllocatorRef *)(a1 - 16);
      }
    }
  }

  else
  {
    char v3 = (CFAllocatorRef *)(a1 + 48);
  }

  int64_t v5 = CFAllocatorAllocate(*v3, a2, 0LL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v5;
}

unsigned __int8 *copyBlocks( unsigned __int8 *result, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v22 = result;
  char v10 = a4 != 0;
  if (a7 < 1)
  {
    uint64_t v13 = 0LL;
    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v11 = a7;
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    uint64_t v14 = a8 << (a5 != 0);
    char v15 = a4 != a5;
    uint64_t v16 = (uint64_t *)(a6 + 8);
    do
    {
      uint64_t v17 = *(v16 - 1);
      uint64_t v18 = (v17 << v10) - v12;
      if (v18 >= 1)
      {
        if (a4 == a5) {
          uint64_t result = (unsigned __int8 *)memmove((void *)(a2 + v13), &v22[v12], (v17 << v10) - v12);
        }
        else {
          uint64_t result = __CFStrConvertBytesToUnicode(&v22[v12], (_WORD *)(a2 + v13), v18);
        }
      }

      uint64_t v19 = *v16;
      v16 += 2;
      uint64_t v12 = (v19 + v17) << v10;
      v13 += v14 + (v18 << v15);
      --v11;
    }

    while (v11);
  }

  size_t v20 = (a3 << v10) - v12;
  if (a3 << v10 > v12)
  {
    if (a4 == a5) {
      return (unsigned __int8 *)memmove((void *)(a2 + v13), &v22[v12], v20);
    }
    else {
      return __CFStrConvertBytesToUnicode(&v22[v12], (_WORD *)(a2 + v13), v20);
    }
  }

  return result;
}

void __CFStringSetUpFormatAndSpecBuffers( uint64_t a1, CFIndex a2, unsigned __int8 **a3, UniChar **a4, UniChar **a5, UniChar *a6, void *a7, void *a8, void *a9, void *a10)
{
  uint64_t v18 = _CFGetTSD(1u);
  uint64_t v19 = &__kCFAllocatorSystemDefault;
  if (v18) {
    uint64_t v19 = (__objc2_class **)v18;
  }
  allocator = (const __CFAllocator *)v19;
  if (!CF_IS_OBJC(7uLL, (__objc2_class **)a1))
  {
    char v20 = atomic_load((unint64_t *)(a1 + 8));
    char v21 = atomic_load((unint64_t *)(a1 + 8));
    uint64_t v22 = v21 & 0x60;
    uint64_t v23 = (UniChar **)(a1 + 16);
    if ((v20 & 0x10) == 0)
    {
      if (v22)
      {
        uint64_t v24 = *v23;
      }

      else
      {
        uint64_t v26 = atomic_load((unint64_t *)(a1 + 8));
        uint64_t v24 = (UniChar *)&v23[(v26 & 5) != 4];
      }

      *a3 = (unsigned __int8 *)v24;
      if (v24)
      {
        unint64_t v27 = atomic_load((unint64_t *)(a1 + 8));
        int64_t v28 = &(*a3)[(v27 >> 2) & 1];
        *a3 = v28;
        if (v28) {
          goto LABEL_16;
        }
      }

      goto LABEL_22;
    }

    if (v22)
    {
      BOOL v25 = *v23;
    }

    else
    {
      uint64_t v29 = atomic_load((unint64_t *)(a1 + 8));
      BOOL v25 = (UniChar *)&v23[(v29 & 5) != 4];
    }

    *a4 = v25;
  }

  int64_t v28 = *a3;
  if (*a3) {
    goto LABEL_16;
  }
LABEL_22:
  if (*a4) {
    goto LABEL_23;
  }
  if (a2 <= 400)
  {
    *a5 = a6;
  }

  else
  {
    unint64_t v39 = (UniChar *)CFAllocatorAllocate(allocator, 2 * a2, 0LL);
    *a5 = v39;
    if (v39 == a6 || __CFOASafe == 0)
    {
      a6 = v39;
    }

    else
    {
      __CFSetLastAllocationEventName();
      a6 = *a5;
    }
  }

  v42.CFIndex location = 0LL;
  v42.uint64_t length = a2;
  CFStringGetCharacters((CFStringRef)a1, v42, a6);
  *a4 = *a5;
  int64_t v28 = *a3;
  if (!*a3)
  {
LABEL_23:
    if (a2 >= 1)
    {
      int v30 = 0;
      CFIndex v32 = *a4;
      do
      {
        int v33 = *v32++;
        if (v33 == 37) {
          ++v30;
        }
        --a2;
      }

      while (a2);
      goto LABEL_28;
    }

uint64_t __CFStringValidateFormatSpecBuffers( unsigned __int16 *a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  if (a3 > a6 || (uint64_t v7 = a2, a5 - a7 < a2))
  {
    if (a2) {
      return 0LL;
    }
  }

  else if (a2 >= 1)
  {
    while (1)
    {
      int v8 = *((unsigned __int8 *)a1 + 24);
      if (v8 == 255) {
        LOBYTE(v_Block_object_dispose(va, 8) = a7;
      }
      if (a5 <= (char)v8
        || a1[1] != *(unsigned __int16 *)(a4 + 32LL * (char)v8 + 2)
        || *a1 != *(unsigned __int16 *)(a4 + 32LL * (char)v8))
      {
        break;
      }

      LOBYTE(a7) = a7 + 1;
      a1 += 16;
      if (!--v7) {
        return 1LL;
      }
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t __CFStringValidateFormatSpec(const __CFString *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = _CFGetTSD(1u);
  if (v6) {
    uint64_t v7 = (const __CFAllocator *)v6;
  }
  else {
    uint64_t v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  char v21 = 0LL;
  uint64_t v22 = 0LL;
  char ptr = 0LL;
  char v20 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  CFIndex Length = CFStringGetLength(a1);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)a1, Length, &v21, &v20, (UniChar **)&ptr, v25, &v18, v24, &v17, v23);
  char v9 = v17;
  char v10 = v18;
  int FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString( (uint64_t)v21,  (uint64_t)v20,  Length,  (uint64_t)v18,  (uint64_t)v17,  &v22);
  int v12 = __CFStringValidateFormatSpecBuffers(a2, 1, 1LL, (uint64_t)v10, FormatSpecifiersInString, v22, a3);
  if (ptr && ptr != v25) {
    CFAllocatorDeallocate(v7, ptr);
  }
  if (v10 != v24) {
    CFAllocatorDeallocate(v7, v10);
  }
  uint64_t v13 = v22;
  if (v22 >= 1)
  {
    uint64_t v14 = 0LL;
    do
    {
      char v15 = (const void *)v9[v14];
      if (v15)
      {
        CFRelease(v15);
        uint64_t v13 = v22;
      }

      ++v14;
    }

    while (v14 < v13);
  }

  if (v9 != (void *)v23) {
    CFAllocatorDeallocate(v7, v9);
  }
  if (v12) {
    return a3 + 1;
  }
  else {
    return -1LL;
  }
}

uint64_t __CFStringFormatLocalizedNumber( __CFString *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  *(void *)&length[1] = *MEMORY[0x1895F89C0];
  length[0] = a5;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting != -1)
  {
    if (!__CFStringFormatLocalizedNumber_disableLocalizedFormatting) {
      goto LABEL_5;
    }
    return 0LL;
  }

  __CFStringFormatLocalizedNumber_disableLocalizedFormatting = getenv("CFStringDisableLocalizedNumberFormatting") != 0LL;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting) {
    return 0LL;
  }
LABEL_5:
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
  switch(*(_BYTE *)(a4 + 28))
  {
    case 1:
    case 4:
      if (!__CFStringFormatLocalizedNumber_decimalFormatter) {
        goto LABEL_17;
      }
      CFLocaleRef Locale = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_decimalFormatter);
      if (CFEqual(Locale, a2))
      {
        uint64_t v14 = &__CFStringFormatLocalizedNumber_decimalFormatter;
        goto LABEL_27;
      }

      if (__CFStringFormatLocalizedNumber_decimalFormatter) {
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_decimalFormatter);
      }
LABEL_17:
      uint64_t v17 = CFNumberFormatterCreate(0LL, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
      __CFStringFormatLocalizedNumber_decimalFormatter = (uint64_t)v17;
      if (!v17) {
        goto LABEL_46;
      }
      goto LABEL_28;
    case 2:
      if (!__CFStringFormatLocalizedNumber_scientificFormatter) {
        goto LABEL_21;
      }
      CFLocaleRef v15 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter);
      if (CFEqual(v15, a2))
      {
        uint64_t v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
        goto LABEL_27;
      }

      if (__CFStringFormatLocalizedNumber_scientificFormatter) {
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_scientificFormatter);
      }
LABEL_21:
      uint64_t v18 = CFNumberFormatterCreate(0LL, (CFLocaleRef)a2, kCFNumberFormatterScientificStyle);
      __CFStringFormatLocalizedNumber_scientificFormatter = (uint64_t)v18;
      if (!v18) {
        goto LABEL_46;
      }
      uint64_t v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
      CFNumberFormatterSetFormat(v18, @"#E+00");
      CFNumberFormatterSetProperty( (CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter,  @"kCFNumberFormatterUseSignificantDigitsKey",  &__kCFBooleanTrue);
      goto LABEL_27;
    case 3:
      if (!__CFStringFormatLocalizedNumber_gFormatter) {
        goto LABEL_25;
      }
      CFLocaleRef v16 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter);
      if (CFEqual(v16, a2))
      {
        uint64_t v14 = &__CFStringFormatLocalizedNumber_gFormatter;
      }

      else
      {
        if (__CFStringFormatLocalizedNumber_gFormatter) {
          CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_gFormatter);
        }
LABEL_25:
        uint64_t v19 = CFNumberFormatterCreate(0LL, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
        __CFStringFormatLocalizedNumber_gFormatter = (uint64_t)v19;
        if (!v19) {
          goto LABEL_46;
        }
        uint64_t v14 = &__CFStringFormatLocalizedNumber_gFormatter;
        char v20 = (const __CFNumber *)CFNumberFormatterCopyProperty(v19, @"kCFNumberFormatterGroupingSizeKey");
        CFNumberGetValue(v20, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_groupingSize);
        CFRelease(v20);
        char v21 = (const __CFNumber *)CFNumberFormatterCopyProperty( (CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter,  @"kCFNumberFormatterSecondaryGroupingSizeKey");
        CFNumberGetValue(v21, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_secondaryGroupingSize);
        CFRelease(v21);
      }

void _CFStringFormatAppendMetadata( CFMutableArrayRef *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v15 = *(unsigned __int16 *)(a5 + 2);
    if ((v15 - 43) >= 2)
    {
      if (v15 == 32)
      {
        if ((*(_BYTE *)(a5 + 20) & 0x80) == 0) {
          return;
        }
      }

      else
      {
      }
    }

    if (!*a1) {
      *a1 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, &kCFTypeArrayCallBacks);
    }
    CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    BOOL v17 = a8 == 0;
    BOOL v18 = a8 != 0;
    int v19 = *(_DWORD *)(a5 + 4);
    if (v17) {
      char v20 = (void *)a6;
    }
    else {
      char v20 = (void *)(a6 + 1);
    }
    int v31 = *(_DWORD *)(a5 + 8);
    int valuePtr = v19;
    value[0] = v20;
    CFNumberRef v21 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(Mutable, @"SpecLocation", v21);
    CFRelease(v21);
    CFNumberRef v22 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &v31);
    CFDictionarySetValue(Mutable, @"SpecLength", v22);
    CFRelease(v22);
    CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, @"ReplacementLocation", v23);
    CFRelease(v23);
    unint64_t v30 = (a7 - v18 - (unint64_t)value[0]) & ~((int64_t)(a7 - v18 - (unint64_t)value[0]) >> 63);
    CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, &v30);
    CFDictionarySetValue(Mutable, @"ReplacementLength", v24);
    CFRelease(v24);
    uint64_t v25 = *(char *)(a5 + 24);
    if (v25 < 0) {
      goto LABEL_26;
    }
    if (v25 < a4 && *(_WORD *)(a5 + 2) != 32)
    {
      value[0] = (void *)(v25 + 1);
      CFNumberRef v26 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
      CFDictionarySetValue(Mutable, @"Index", v26);
      CFRelease(v26);
      LODWORD(v25) = *(char *)(a5 + 24);
      if ((v25 & 0x80000000) != 0) {
        goto LABEL_26;
      }
    }

    *(_OWORD *)value = *(_OWORD *)(a3 + 16LL * v25);
    if (SLOWORD(value[0]) == 33)
    {
      CFNumberType v27 = kCFNumberSInt64Type;
    }

    else
    {
      if (SLOWORD(value[0]) != 34)
      {
        if (SLOWORD(value[0]) == 37)
        {
          if (value[1]) {
            CFDictionarySetValue(Mutable, @"Object", value[1]);
          }
        }

        goto LABEL_26;
      }

      CFNumberType v27 = kCFNumberDoubleType;
    }

    CFNumberRef v28 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, &value[1]);
    CFDictionarySetValue(Mutable, @"Number", v28);
    CFRelease(v28);
LABEL_26:
    value[0] = (void *)v18;
    CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, @"AddedIsolates", v29);
    CFRelease(v29);
    CFArrayAppendValue(*a1, Mutable);
    CFRelease(Mutable);
  }

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__( uint64_t (*a1)(uint64_t, uint64_t, const __CFString *), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3, @"%@NSCONTEXT");
}

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

CFStringRef __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(const void *a1)
{
  return CFCopyDescription(a1);
}

uint64_t _CFStringHasStrongRTL(__CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x66u, 0);
  CFStringRef theString = a1;
  uint64_t v26 = a2;
  int64_t v27 = a3;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  if (CharactersPtr) {
    uint64_t CStringPtrInternal = 0LL;
  }
  else {
    uint64_t CStringPtrInternal = _CFStringGetCStringPtrInternal((unint64_t *)a1, 0x600u, 1, 1);
  }
  int64_t v28 = 0LL;
  int64_t v29 = 0LL;
  uint64_t v25 = CStringPtrInternal;
  if (a3 < 1) {
    return 0LL;
  }
  int64_t v8 = 0LL;
  while (1)
  {
    if (v8 < 0 || (int64_t v9 = v27, v27 <= v8))
    {
      LOWORD(v11) = 0;
      goto LABEL_11;
    }

    if (CharactersPtr)
    {
      UniChar v10 = CharactersPtr[v26 + v8];
    }

    else if (v25)
    {
      UniChar v10 = *(char *)(v25 + v26 + v8);
    }

    else
    {
      if (v29 <= v8 || (int64_t v14 = v28, v28 > v8))
      {
        int64_t v15 = v8 - 4;
        if (v15 + 64 < v27) {
          int64_t v9 = v15 + 64;
        }
        int64_t v28 = v15;
        int64_t v29 = v9;
        v31.CFIndex location = v26 + v15;
        v31.uint64_t length = v9 - v15;
        CFStringGetCharacters(theString, v31, v22);
        int64_t v14 = v28;
      }

      UniChar v10 = v22[v8 - v14];
    }

    unsigned int v11 = v10;
    if (v10 >> 10 == 54) {
      break;
    }
LABEL_11:
    uint64_t v12 = BitmapPtrForPlane;
    if (BitmapPtrForPlane) {
      goto LABEL_12;
    }
LABEL_13:
    int64_t v13 = v8 + 1;
LABEL_14:
    int64_t v8 = v13;
    if (v13 >= a3) {
      return 0LL;
    }
  }

  int64_t v13 = v8 + 1;
  int64_t v16 = v27;
  if (v27 <= v8 + 1) {
    goto LABEL_14;
  }
  if (CharactersPtr)
  {
    UniChar v17 = CharactersPtr[v26 + v13];
  }

  else if (v25)
  {
    UniChar v17 = *(char *)(v25 + v26 + v13);
  }

  else
  {
    if (v29 <= v13 || (int64_t v18 = v28, v28 > v13))
    {
      int64_t v19 = v8 - 3;
      if (v19 + 64 < v27) {
        int64_t v16 = v19 + 64;
      }
      int64_t v28 = v19;
      int64_t v29 = v16;
      v32.CFIndex location = v26 + v19;
      v32.uint64_t length = v16 - v19;
      CFStringGetCharacters(theString, v32, v22);
      int64_t v18 = v28;
    }

    UniChar v17 = v22[v13 - v18];
  }

  if (v17 >> 10 != 55) {
    goto LABEL_14;
  }
  unsigned int v11 = (v11 << 10) + v17 - 56613888;
  unsigned int v20 = HIWORD(v11) & 0x1F;
  if (v20) {
    uint64_t v12 = CFUniCharGetBitmapPtrForPlane(0x66u, v20);
  }
  else {
    uint64_t v12 = BitmapPtrForPlane;
  }
  ++v8;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_12:
  return 1LL;
}

void OUTLINED_FUNCTION_0_12( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t __CFSearchStringROM(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 > 80) {
    return 0LL;
  }
  unsigned __int16 v4 = __CFStrHashEightBit2(a1, a2);
  unint64_t v5 = CFStringROMTableHashData[v4];
  if ((v5 & 7) == 0) {
    return 0LL;
  }
  unint64_t v6 = v5 >> 3;
  unint64_t v7 = (CFStringROMTableHashData[v4] >> 3) + (CFStringROMTableHashData[v4] & 7);
  while (1)
  {
    uint64_t v8 = *((void *)&CFStringROMTable + v6);
    if (++v6 >= v7) {
      return 0LL;
    }
  }

  return v8;
}

uint64_t (**__CFStringEncodingGetKoreanConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_0)
  {
    __CFStringEncodingIsDecomposableCharacter_0 = (_UNKNOWN *)a2(1LL);
    __CFStringEncodingDecomposeCharacter_0 = (_UNKNOWN *)a2(2LL);
  }

  if (a1 > 2111)
  {
    if (a1 != 2112)
    {
      if (a1 == 2368) {
        return __CFConverterEUC_KR;
      }
      return 0LL;
    }

    return &__CFConverterISO_2022_KR;
  }

  else
  {
    if (a1 != 3)
    {
      if (a1 == 1058) {
        return __CFConverterDOSKorean;
      }
      return 0LL;
    }

    return __CFConverterMacKorean;
  }

uint64_t __CFToDOSKorean(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
    goto LABEL_97;
  }

  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0xF73Eu;
  int v50 = 1;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        break;
      }
      unsigned int v14 = *a2;
      BOOL v15 = v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0;
      if (v15 && v14 - 12441 >= 2) {
        break;
      }
    }

    else
    {
      unsigned int v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5) {
          *a4++ = v14;
        }
        ++v11;
        ++a2;
        ++v12;
        int v50 = 1;
        continue;
      }
    }

    if (v14 - 4352 > 0xFE)
    {
LABEL_35:
      if (v14 < 0xA1) {
        goto LABEL_55;
      }
    }

    else if (a3 - v12 >= 2 && ((v14 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
    {
      unsigned int v17 = a2[1] - 4449;
      if (v17 <= 0x15)
      {
        if ((unint64_t)(a3 - v12) < 3)
        {
          unsigned __int16 v18 = 0;
        }

        else
        {
          unsigned __int16 v18 = a2[2] - 4519;
          if (v18 > 0x1Cu) {
            unsigned __int16 v18 = 0;
          }
        }

        unsigned int v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
        if (v19 >= 0xA1)
        {
          unsigned int v20 = (unsigned __int16 *)&KSX1001_from_uni;
          CFNumberRef v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
          while (1)
          {
            uint64_t v22 = (0xF83E0F83E0F83E1LL * (v21 - v20)) >> 1;
            CFNumberRef v23 = &v20[33 * v22];
            unsigned int v24 = *v23;
            if (v24 <= v19)
            {
              if (v24 + 32 > v19)
              {
                int v40 = v20[33 * v22 + 1 + (int)(v19 - v24)];
                if (v40)
                {
                  BOOL v47 = (__int16)v18 <= 0;
                  uint64_t v41 = 2LL;
                  if (!v47) {
                    uint64_t v41 = 3LL;
                  }
                  goto LABEL_72;
                }

                goto LABEL_35;
              }

              unsigned int v20 = v23 + 33;
            }

            else
            {
              CFNumberRef v21 = v23 - 33;
            }

            if (v20 > v21) {
              goto LABEL_35;
            }
          }
        }
      }
    }

    uint64_t v25 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      uint64_t v27 = (0xF83E0F83E0F83E1LL * (v26 - v25)) >> 1;
      int64_t v28 = &v25[33 * v27];
      unsigned int v29 = *v28;
      if (v29 <= v14) {
        break;
      }
      uint64_t v26 = v28 - 33;
LABEL_41:
      if (v25 > v26) {
        goto LABEL_42;
      }
    }

    if (v29 + 32 <= v14)
    {
      uint64_t v25 = v28 + 33;
      goto LABEL_41;
    }

    uint64_t v39 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
    int v40 = *(unsigned __int16 *)(v39 + 2);
    if (*(_WORD *)(v39 + 2))
    {
      uint64_t v41 = 1LL;
LABEL_72:
      if (v40 != 65533)
      {
        if (a5)
        {
          if (v11 + 2 > a5) {
            break;
          }
          *a4 = BYTE1(v40);
          a4[1] = v40;
          a4 += 2;
        }

        int v50 = 0;
        v12 += v41;
        v11 += 2LL;
        a2 += v41;
        continue;
      }
    }

uint64_t __CFFromDOSKorean( unsigned int a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  unsigned int v11 = a1;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v14 = a1 & 0xC0;
  uint64_t v15 = 0x9F74u;
  int64_t v16 = &unk_18C539000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5) {
      return v13;
    }
    int v17 = *a2;
    if ((*a2 & 0x80000000) == 0)
    {
      *a4++ = v17;
LABEL_8:
      uint64_t v18 = 1LL;
LABEL_32:
      *a6 = ++v12;
      goto LABEL_33;
    }
  }

  else
  {
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    int v17 = *a2;
  }

  if (v9 < 2) {
    return v13;
  }
  unsigned int v19 = a2[1] | (v17 << 8);
  if ((unsigned __int16)(v19 + 478) >= 0x831Fu)
  {
    unsigned int v20 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    CFNumberRef v21 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      uint64_t v22 = (0xFC0FC0FC0FC0FC1LL * (v20 - v21)) >> 1;
      CFNumberRef v23 = &v21[65 * v22];
      unsigned int v24 = *v23;
      if (v24 <= v19)
      {
        if (v24 + 64 > v19)
        {
          unsigned __int16 v25 = v21[65 * v22 + 1 + (int)(v19 - v24)];
          if (v25) {
            BOOL v26 = v25 == 65533;
          }
          else {
            BOOL v26 = 1;
          }
          if (v26)
          {
LABEL_24:
            if (a5)
            {
              unsigned __int16 v27 = v19 + 5727;
              goto LABEL_30;
            }

            goto LABEL_31;
          }

          if (!v14
            || (int v36 = v14,
                unsigned int v37 = v11,
                v29 = (*((uint64_t (**)(void, void))v16 + 415))( v21[65 * v22 + 1 + (int)(v19 - v24)],  (v11 >> 7) & 1),  v16 = &unk_18C539000,  v15 = 40820LL,  v14 = v36,  unsigned int v11 = v37,  !v29))
          {
            if (a5) {
              *a4++ = v25;
            }
            uint64_t v12 = *a6;
            goto LABEL_31;
          }

          uint64_t v30 = __CFStringEncodingDecomposeCharacter_0( v37,  v25,  v38,  13919LL,  5727LL,  65533LL,  0x18C539000LL,  &KSX1001_to_uni);
          uint64_t v31 = *a6;
          uint64_t v12 = *a6 + v30;
          *a6 = v12;
          if (!a5)
          {
            uint64_t v18 = 2LL;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820LL;
            int64_t v16 = &unk_18C539000;
            goto LABEL_33;
          }

          int64_t v16 = &unk_18C539000;
          if (v12 > a5)
          {
            *a6 = v31;
            return v13;
          }

          if (v30 < 1)
          {
            uint64_t v18 = 2LL;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820LL;
          }

          else
          {
            unint64_t v32 = v30 + 1;
            unsigned int v33 = (__int16 *)v38;
            int v14 = v36;
            unsigned int v11 = v37;
            uint64_t v15 = 40820LL;
            do
            {
              unsigned __int16 v34 = *v33++;
              *a4++ = v34;
              --v32;
            }

            while (v32 > 1);
            uint64_t v18 = 2LL;
          }

uint64_t __CFToDOSKoreanLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1LL;
    }
    else {
      uint64_t v5 = 2LL;
    }
    result += v5;
  }

  return result;
}

uint64_t __CFFromDOSKoreanLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1LL;
    }
    else {
      uint64_t v7 = 2LL;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2LL;
    }
    else {
      uint64_t v8 = -1LL;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }

  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFFromDOSKoreanFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1LL;
  if (*a1 > -1 || a2 < 2) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

uint64_t __CFToKSX1001(unsigned __int16 *a1, uint64_t a2, uint64_t *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a1;
  if (v4 - 4352 > 0xFE) {
    goto LABEL_17;
  }
  if (a2 >= 2 && ((v4 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
  {
    unsigned int v5 = a1[1] - 4449;
    if (v5 <= 0x15)
    {
      if ((unint64_t)a2 < 3)
      {
        __int16 v6 = 0;
      }

      else
      {
        __int16 v6 = a1[2] - 4519;
      }

      unsigned __int16 v7 = v6 + 28 * (v5 + 21 * (char)v4) - 21504;
      if (v7 >= 0xA1u)
      {
        uint64_t v8 = (unsigned __int16 *)&KSX1001_from_uni;
        BOOL v9 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
        while (1)
        {
          uint64_t v10 = (0xF83E0F83E0F83E1LL * (v9 - v8)) >> 1;
          unsigned int v11 = &v8[33 * v10];
          unsigned int v12 = *v11;
          if (v12 <= v7)
          {
            if (v12 + 32 > v7)
            {
              uint64_t v21 = (uint64_t)&v8[33 * v10 + (int)(v7 - v12)];
              uint64_t result = *(unsigned __int16 *)(v21 + 2);
              if (*(_WORD *)(v21 + 2))
              {
                if (a4) {
                  *a4 = v7;
                }
                uint64_t v20 = 2LL;
                if (v6 > 0) {
                  uint64_t v20 = 3LL;
                }
LABEL_27:
                *a3 = v20;
                return result;
              }

uint64_t __CFPrecomposeCharKorean(unsigned __int16 *a1)
{
  int v1 = *a1;
  unsigned int v2 = a1[1];
  if (v2 <= 0x337)
  {
    if (v2 != 774)
    {
      if (v2 != 776) {
        return 0;
      }
      if (v1 == 1077) {
        unsigned __int16 v3 = 1105;
      }
      else {
        unsigned __int16 v3 = 0;
      }
      if (v1 == 1045) {
        return 1025;
      }
      return v3;
    }

    if ((v1 & 0xFFFFFFDF) != 0x418) {
      return 0;
    }
    return (unsigned __int16)(v1 + 1);
  }

  if (v2 == 824)
  {
    unsigned __int16 v3 = 8800;
    if (*a1 > 0x2260u)
    {
      char v4 = v1 - 100;
      if ((v1 - 8804) <= 0x1F)
      {
        if (((1 << v4) & 0xC0080000) != 0) {
          return (unsigned __int16)(v1 + 2);
        }
        if (((1 << v4) & 3) != 0) {
          return (unsigned __int16)(v1 + 12);
        }
        if (((1 << v4) & 0xC00000) != 0) {
          return (unsigned __int16)(v1 + 6);
        }
      }

      if (v1 != 8801) {
        return 0;
      }
    }

    else
    {
      if (*a1 <= 0x2207u)
      {
        if (v1 == 60) {
          return 8814;
        }
        if (v1 != 61)
        {
          if (v1 == 62) {
            return 8815;
          }
          return 0;
        }

        return v3;
      }
    }

    return (unsigned __int16)(v1 + 1);
  }

  if (v2 != 12441)
  {
    if (v2 == 12442) {
      return (unsigned __int16)(v1 + 2);
    }
    return 0;
  }

  if (v1 == 12454) {
    return 12532;
  }
  else {
    return (unsigned __int16)(v1 + 1);
  }
}

uint64_t __CFFromKSX1001(unsigned int a1)
{
  int v1 = (unsigned __int16 *)&KSX1001_to_uni;
  unsigned int v2 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
  while (1)
  {
    uint64_t v3 = (0xFC0FC0FC0FC0FC1LL * (v2 - v1)) >> 1;
    char v4 = &v1[65 * v3];
    unsigned int v5 = *v4;
    if (v5 <= a1) {
      break;
    }
    unsigned int v2 = v4 - 65;
LABEL_7:
    if (v1 > v2) {
      return (unsigned __int16)-3;
    }
  }

  if (v5 + 64 <= a1)
  {
    int v1 = v4 + 65;
    goto LABEL_7;
  }

  unsigned __int16 v6 = v1[65 * v3 + 1 + (int)(a1 - v5)];
  if (!v6) {
    return (unsigned __int16)-3;
  }
  return v6;
}

uint64_t __CFToEUC_KR(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
    goto LABEL_103;
  }

  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0xF73Eu;
  int v48 = 1;
  while (2)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_103;
      }
      unsigned int v14 = *a2;
      BOOL v15 = v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0;
      if (v15 && v14 - 12441 >= 2) {
        goto LABEL_103;
      }
    }

    else
    {
      unsigned int v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5) {
          *a4++ = v14;
        }
        ++v11;
        ++a2;
        ++v12;
        int v48 = 1;
        goto LABEL_58;
      }
    }

    if (v14 - 4352 > 0xFE) {
      goto LABEL_35;
    }
    if (a3 - v12 < 2) {
      goto LABEL_36;
    }
    unsigned int v17 = a2[1] - 4449;
    if (v17 > 0x15) {
      goto LABEL_36;
    }
    if ((unint64_t)(a3 - v12) < 3)
    {
      unsigned __int16 v18 = 0;
    }

    else
    {
      unsigned __int16 v18 = a2[2] - 4519;
      if (v18 > 0x1Cu) {
        unsigned __int16 v18 = 0;
      }
    }

    unsigned int v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
    if (v19 < 0xA1) {
      goto LABEL_36;
    }
    uint64_t v20 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      uint64_t v22 = (0xF83E0F83E0F83E1LL * (v21 - v20)) >> 1;
      CFNumberRef v23 = &v20[33 * v22];
      unsigned int v24 = *v23;
      if (v24 <= v19) {
        break;
      }
      uint64_t v21 = v23 - 33;
LABEL_34:
      if (v20 > v21) {
        goto LABEL_35;
      }
    }

    if (v24 + 32 <= v19)
    {
      uint64_t v20 = v23 + 33;
      goto LABEL_34;
    }

    unsigned int v33 = v20[33 * v22 + 1 + (int)(v19 - v24)];
    if (!v33)
    {
LABEL_35:
      if (v14 < 0xA1) {
        goto LABEL_55;
      }
LABEL_36:
      unsigned __int16 v25 = (unsigned __int16 *)&KSX1001_from_uni;
      BOOL v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
      while (1)
      {
        uint64_t v27 = (0xF83E0F83E0F83E1LL * (v26 - v25)) >> 1;
        BOOL v28 = &v25[33 * v27];
        unsigned int v29 = *v28;
        if (v29 <= v14)
        {
          if (v29 + 32 > v14)
          {
            uint64_t v32 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
            unsigned int v33 = *(unsigned __int16 *)(v32 + 2);
            if (*(_WORD *)(v32 + 2))
            {
              uint64_t v34 = 1LL;
              goto LABEL_62;
            }

            goto LABEL_42;
          }

          unsigned __int16 v25 = v28 + 33;
        }

        else
        {
          BOOL v26 = v28 - 33;
        }

        if (v25 > v26) {
          goto LABEL_42;
        }
      }
    }

    BOOL v46 = (__int16)v18 <= 0;
    uint64_t v34 = 2LL;
    if (!v46) {
      uint64_t v34 = 3LL;
    }
LABEL_62:
    if (v33 != 65533
      && v33 >> 8 >= 0xA1
      && v33 >> 8 != 255
      && v33 >= 0xA1u
      && v33 != 255)
    {
      v11 += 2LL;
      if (a5)
      {
        if (v11 > a5) {
          goto LABEL_103;
        }
        *a4 = BYTE1(v33);
        a4[1] = v33;
        a4 += 2;
      }

      int v48 = 0;
      a2 += v34;
      v12 += v34;
      goto LABEL_58;
    }

uint64_t __CFFromEUC_KR( unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  unsigned int v11 = a1;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v14 = a1 & 0xC0;
  uint64_t v15 = 0x9F74u;
  int64_t v16 = &unk_18C539000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5) {
      return v13;
    }
    int v17 = (char)*a2;
    int v18 = *a2;
    if ((v17 & 0x80000000) == 0)
    {
      *a4++ = v18;
LABEL_8:
      uint64_t v19 = 1LL;
LABEL_34:
      *a6 = ++v12;
      goto LABEL_35;
    }
  }

  else
  {
    int v17 = (char)*a2;
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    int v18 = *a2;
  }

  if (v9 < 2) {
    return v13;
  }
  int v20 = a2[1];
  unsigned int v21 = v20 | (v18 << 8);
  if ((unsigned __int16)(v21 + 478) >= 0x831Fu)
  {
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    CFNumberRef v23 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      uint64_t v24 = (0xFC0FC0FC0FC0FC1LL * (v22 - v23)) >> 1;
      unsigned __int16 v25 = &v23[65 * v24];
      unsigned int v26 = *v25;
      if (v26 <= v21)
      {
        if (v26 + 64 > v21)
        {
          unsigned __int16 v27 = v23[65 * v24 + 1 + (int)(v21 - v26)];
          if (v27) {
            BOOL v28 = v27 == 65533;
          }
          else {
            BOOL v28 = 1;
          }
          if (v28)
          {
LABEL_26:
            if (a5)
            {
              unsigned __int16 v29 = v21 + 5727;
              goto LABEL_32;
            }

            goto LABEL_33;
          }

          if (!v14
            || (int v38 = v14,
                unsigned int v39 = v11,
                v31 = (*((uint64_t (**)(void, void))v16 + 415))( v23[65 * v24 + 1 + (int)(v21 - v26)],  (v11 >> 7) & 1),  v16 = &unk_18C539000,  v15 = 40820LL,  v14 = v38,  unsigned int v11 = v39,  !v31))
          {
            if (a5) {
              *a4++ = v27;
            }
            uint64_t v12 = *a6;
            goto LABEL_33;
          }

          uint64_t v32 = __CFStringEncodingDecomposeCharacter_0( v39,  v27,  v40,  13919LL,  5727LL,  65533LL,  0x18C539000LL,  &KSX1001_to_uni);
          uint64_t v33 = *a6;
          uint64_t v12 = *a6 + v32;
          *a6 = v12;
          if (!a5)
          {
            uint64_t v19 = 2LL;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820LL;
            int64_t v16 = &unk_18C539000;
            goto LABEL_35;
          }

          int64_t v16 = &unk_18C539000;
          if (v12 > a5)
          {
            *a6 = v33;
            return v13;
          }

          if (v32 < 1)
          {
            uint64_t v19 = 2LL;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820LL;
          }

          else
          {
            unint64_t v34 = v32 + 1;
            uint64_t v35 = (__int16 *)v40;
            int v14 = v38;
            unsigned int v11 = v39;
            uint64_t v15 = 40820LL;
            do
            {
              unsigned __int16 v36 = *v35++;
              *a4++ = v36;
              --v34;
            }

            while (v34 > 1);
            uint64_t v19 = 2LL;
          }

uint64_t __CFToISO_2022_KR(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, uint64_t *a6)
{
  if ((a1 & 0x100) != 0)
  {
    if (a5)
    {
      if (a5 < 4) {
        return 0LL;
      }
      *(_DWORD *)a4 = 1126769691;
      a4 += 4;
    }

    uint64_t v8 = 4LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  if (a3 < 1)
  {
    uint64_t v9 = 0LL;
    goto LABEL_134;
  }

  BOOL v10 = 0;
  uint64_t v9 = 0LL;
  uint64_t v11 = 0xF73Eu;
  int v12 = 1;
  uint64_t v13 = v8;
LABEL_10:
  if (a5 && v13 >= a5)
  {
    if ((a1 & 0x10) == 0) {
      goto LABEL_132;
    }
    unsigned int v14 = *a2;
    BOOL v15 = v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0;
    if (v15 && v14 - 12441 >= 2) {
      goto LABEL_132;
    }
    goto LABEL_32;
  }

  unsigned int v14 = *a2;
  if (v14 > 0x7F)
  {
LABEL_32:
    if (v14 - 4352 > 0xFE)
    {
LABEL_49:
      if (v14 < 0xA1) {
        goto LABEL_75;
      }
LABEL_50:
      unsigned int v26 = (unsigned __int16 *)&KSX1001_from_uni;
      unsigned __int16 v27 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
      while (1)
      {
        uint64_t v28 = (0xF83E0F83E0F83E1LL * (v27 - v26)) >> 1;
        unsigned __int16 v29 = &v26[33 * v28];
        unsigned int v30 = *v29;
        if (v30 <= v14)
        {
          if (v30 + 32 > v14)
          {
            uint64_t v45 = (uint64_t)&v26[33 * v28 + (int)(v14 - v30)];
            unsigned int v46 = *(unsigned __int16 *)(v45 + 2);
            if (*(_WORD *)(v45 + 2))
            {
              uint64_t v47 = 1LL;
              goto LABEL_92;
            }

            goto LABEL_56;
          }

          unsigned int v26 = v29 + 33;
        }

        else
        {
          unsigned __int16 v27 = v29 - 33;
        }

        if (v26 > v27) {
          goto LABEL_56;
        }
      }
    }

    if (a3 - v9 < 2) {
      goto LABEL_50;
    }
    unsigned int v18 = a2[1] - 4449;
    if (v18 > 0x15) {
      goto LABEL_50;
    }
    if ((unint64_t)(a3 - v9) < 3)
    {
      unsigned __int16 v19 = 0;
    }

    else
    {
      unsigned __int16 v19 = a2[2] - 4519;
      if (v19 > 0x1Cu) {
        unsigned __int16 v19 = 0;
      }
    }

    unsigned int v20 = (unsigned __int16)(v19 + 28 * (v18 + 21 * (char)v14) - 21504);
    if (v20 < 0xA1) {
      goto LABEL_50;
    }
    unsigned int v21 = (unsigned __int16 *)&KSX1001_from_uni;
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
    while (1)
    {
      uint64_t v23 = (0xF83E0F83E0F83E1LL * (v22 - v21)) >> 1;
      uint64_t v24 = &v21[33 * v23];
      unsigned int v25 = *v24;
      if (v25 <= v20)
      {
        if (v25 + 32 > v20)
        {
          unsigned int v46 = v21[33 * v23 + 1 + (int)(v20 - v25)];
          if (!v46) {
            goto LABEL_49;
          }
          BOOL v64 = (__int16)v19 <= 0;
          uint64_t v47 = 2LL;
          if (!v64) {
            uint64_t v47 = 3LL;
          }
LABEL_92:
          if (v46 != 65533
            && v46 >> 8 >= 0xA1
            && v46 >> 8 != 255
            && v46 >= 0xA1u
            && v46 != 255)
          {
            BOOL v10 = v12 != 0;
            if (v12) {
              uint64_t v48 = v13 + 1;
            }
            else {
              uint64_t v48 = v13;
            }
            uint64_t v13 = v48 + 2;
            if (!a5)
            {
LABEL_105:
              int v12 = 0;
              a2 += v47;
              v9 += v47;
              goto LABEL_73;
            }

            if (v13 <= a5)
            {
              if (v12) {
                *a4++ = 14;
              }
              *a4 = BYTE1(v46) & 0x7F;
              a4[1] = v46 & 0x7F;
              a4 += 2;
              goto LABEL_105;
            }

LABEL_141:
            uint64_t v8 = v13 + 1;
            if (!a5) {
              goto LABEL_134;
            }
LABEL_142:
            if (v13 < a5)
            {
              *a4 = 15;
              goto LABEL_134;
            }

            CFIndex v56 = a2 - 1;
            while (1)
            {
              unsigned int v58 = *v56--;
              unsigned int v57 = v58;
              uint64_t v59 = (1LL << (v58 - 6)) & 0x4000000000005LL;
              if ((v58 - 774 > 0x32 || v59 == 0) && v57 - 12441 >= 2)
              {
                unsigned int v62 = v57 >> 5;
                unsigned int v63 = v57 >> 9;
                BOOL v64 = v62 < 0x8B || v63 > 8;
                if (v64 || v9 < 2)
                {
LABEL_162:
                  --v9;
                  if (v10)
                  {
                    uint64_t v8 = v13 - 3;
                  }

                  else
                  {
                    *(a4 - 2) = 15;
                    uint64_t v8 = v13 - 1;
                  }

                  goto LABEL_134;
                }
              }

              else if (v9 <= 1)
              {
                goto LABEL_162;
              }

              --v9;
            }
          }

          goto LABEL_10;
        }

        unsigned int v21 = v24 + 33;
      }

      else
      {
        uint64_t v22 = v24 - 33;
      }

      if (v21 > v22) {
        goto LABEL_49;
      }
    }
  }

  BOOL v10 = v12 == 0;
  if (v12) {
    uint64_t v17 = v13;
  }
  else {
    uint64_t v17 = v13 + 1;
  }
  uint64_t v13 = v17 + 1;
  if (!a5)
  {
LABEL_31:
    ++a2;
    ++v9;
    int v12 = 1;
    goto LABEL_73;
  }

  if (v17 < a5)
  {
    if (!v12) {
      *a4++ = 15;
    }
    *a4++ = v14;
    goto LABEL_31;
  }

  uint64_t v55 = -2LL;
  if (v12) {
    uint64_t v55 = -1LL;
  }
  uint64_t v8 = v13 + v55;
LABEL_134:
  *a6 = v8;
  return v9;
}

  a6 = v53;
LABEL_142:
  *a6 = v46;
  return v8;
}

uint64_t __CFFromISO_2022_KR( uint64_t a1, char *__s1, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v41 = a1 & 0xC0;
  int v14 = 1;
  while (2)
  {
    if (a5 && v12 >= a5) {
      goto LABEL_67;
    }
    int v15 = *__s1;
    if (v9 >= 4 && v15 == 27)
    {
      if (!strncmp(__s1, "\x1B$)C", 4uLL))
      {
        uint64_t v17 = 4LL;
        goto LABEL_36;
      }

      int v16 = 27;
    }

    else
    {
      if (v15 == 14)
      {
        int v14 = 0;
        uint64_t v17 = 1LL;
        goto LABEL_36;
      }

      int v16 = *__s1;
      if (v15 == 15) {
        goto LABEL_15;
      }
    }

    if (v14)
    {
      if (a5) {
        *a4++ = v15;
      }
      *a6 = ++v12;
LABEL_15:
      uint64_t v17 = 1LL;
      int v14 = 1;
      goto LABEL_36;
    }

    if (v9 < 2
      || (v16 | 0x80u) < 0xA1
      || (v16 | 0x80) == 0xFF
      || (int v18 = __s1[1], (v18 | 0x80u) < 0xA1)
      || (v18 | 0x80) == 0xFF)
    {
      if ((a1 & 1) != 0)
      {
        if (a5) {
          *a4++ = 63;
        }
        int v14 = 0;
        *a6 = ++v12;
        uint64_t v17 = 1LL;
        if (v9 > 1) {
          uint64_t v17 = 2LL;
        }
        goto LABEL_36;
      }

      goto LABEL_66;
    }

    unsigned __int16 v19 = v18 | ((_WORD)v16 << 8) | 0x8080;
    unsigned int v20 = v19;
    unsigned int v21 = (unsigned __int16 *)&KSX1001_to_uni;
    uint64_t v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
    while (1)
    {
      uint64_t v23 = (0xFC0FC0FC0FC0FC1LL * (v22 - v21)) >> 1;
      uint64_t v24 = &v21[65 * v23];
      unsigned int v25 = *v24;
      if (v25 <= v20) {
        break;
      }
      uint64_t v22 = v24 - 65;
LABEL_28:
      if (v21 > v22) {
        goto LABEL_44;
      }
    }

    if (v25 + 64 <= v20)
    {
      unsigned int v21 = v24 + 65;
      goto LABEL_28;
    }

    unsigned __int16 v27 = v21[65 * v23 + 1 + (int)(v20 - v25)];
    if (v27) {
      BOOL v28 = v21[65 * v23 + 1 + (int)(v20 - v25)] == 65533;
    }
    else {
      BOOL v28 = 1;
    }
    if (!v28)
    {
      if (!v41
        || !__CFStringEncodingIsDecomposableCharacter_0( v21[65 * v23 + 1 + (int)(v20 - v25)],  (a1 >> 7) & 1))
      {
        if (a5) {
          *a4++ = v27;
        }
        int v14 = 0;
        uint64_t v12 = *a6 + 1;
        goto LABEL_52;
      }

      uint64_t v35 = __CFStringEncodingDecomposeCharacter_0(a1, v27, v42, v30, v31, v32, v33, v34);
      uint64_t v36 = *a6;
      uint64_t v12 = *a6 + v35;
      *a6 = v12;
      if (!a5) {
        goto LABEL_61;
      }
      if (v12 > a5)
      {
        int v14 = 0;
        *a6 = v36;
        uint64_t v12 = v36;
        goto LABEL_68;
      }

      if (v35 >= 1)
      {
        unint64_t v37 = v35 + 1;
        int v38 = (__int16 *)v42;
        do
        {
          unsigned __int16 v39 = *v38++;
          *a4++ = v39;
          --v37;
        }

        while (v37 > 1);
      }

uint64_t __CFToISO_2022_KRLen(unsigned int a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = (a1 >> 6) & 4;
  if (a3)
  {
    BOOL v4 = 1;
    do
    {
      unsigned int v6 = *a2++;
      unsigned int v5 = v6;
      if (v4) {
        uint64_t v7 = 1LL;
      }
      else {
        uint64_t v7 = 2LL;
      }
      if (v4) {
        uint64_t v8 = 3LL;
      }
      else {
        uint64_t v8 = 2LL;
      }
      BOOL v4 = v5 < 0x80;
      if (v5 >= 0x80) {
        uint64_t v7 = v8;
      }
      v3 += v7;
      --a3;
    }

    while (a3);
    BOOL v9 = v5 > 0x7F;
  }

  else
  {
    BOOL v9 = 0LL;
  }

  return v3 + v9;
}

uint64_t __CFFromISO_2022_KRLen(int a1, char *__s1, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v5 = 0LL;
    char v6 = 1;
    while (1)
    {
      int v7 = *__s1;
      if ((unint64_t)v3 >= 4 && v7 == 27)
      {
        if (strncmp(__s1, "\x1B$)C", 4uLL)) {
          goto LABEL_10;
        }
        uint64_t v8 = -4LL;
        uint64_t v9 = 4LL;
      }

      else if (v7 == 14)
      {
        char v6 = 0;
        uint64_t v8 = -1LL;
        uint64_t v9 = 1LL;
      }

      else
      {
        if (v7 != 15)
        {
LABEL_10:
          if (v6) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = (unint64_t)v3 >= 2;
          }
          int v11 = !v10;
          ++v5;
          BOOL v12 = v11 == 0;
          if (v11) {
            uint64_t v9 = 1LL;
          }
          else {
            uint64_t v9 = 2LL;
          }
          if (v11) {
            uint64_t v8 = -1LL;
          }
          else {
            uint64_t v8 = -2LL;
          }
          if (v12) {
            char v6 = 0;
          }
          goto LABEL_26;
        }

        uint64_t v9 = 1LL;
        uint64_t v8 = -1LL;
        char v6 = 1;
      }

uint64_t __CFToMacKorean(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  v166[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    goto LABEL_452;
  }

  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  BOOL v12 = 1;
LABEL_3:
  if (a5 && v10 >= a5)
  {
    if ((a1 & 0x10) == 0) {
      goto LABEL_452;
    }
    unsigned int v13 = *a2;
    if (v13 - 774 <= 0x32 && ((1LL << (v13 - 6)) & 0x4000000000005LL) != 0 || v13 - 12441 < 2)
    {
LABEL_13:
      unsigned __int16 v165 = *a2;
      goto LABEL_16;
    }

    int v26 = v13 & 0xFFF0;
    if (v26 != 8400 && v26 != 8416 && v26 != 63600)
    {
      if (v13 != 839 && v13 != 822) {
        goto LABEL_452;
      }
      goto LABEL_13;
    }
  }

  else
  {
    unsigned int v13 = *a2;
  }

  unsigned __int16 v165 = v13;
  if (v13 < 0x80) {
    goto LABEL_18;
  }
LABEL_16:
  if ((a1 & 0x80) != 0 && (unsigned __int16)(v13 - 133) <= 0x1Au)
  {
LABEL_18:
    if (a5) {
      *a4++ = v13;
    }
    ++v10;
    ++a2;
    uint64_t v16 = v11 + 1;
    BOOL v12 = 1;
    goto LABEL_110;
  }

  uint64_t v16 = v11 + 1;
  if (v11 + 1 < a3 && (__int16)a2[1] == -1921 && (v13 == 8211 || v13 == 65343 || v13 == 8230))
  {
    if (a5)
    {
      if (v13 != 65343)
      {
        if (v13 != 8230) {
          *a4++ = -126;
        }
        *a4++ = -1;
      }

      *a4++ = -124;
    }

    BOOL v12 = 0;
    ++v10;
    uint64_t v16 = v11 + 2;
    a2 += 2;
    goto LABEL_110;
  }

  uint64_t v17 = (unsigned __int16 *)&MacKorean_from_uni_one_char;
  int v18 = (unsigned __int16 *)&unk_180CA0112;
  while (1)
  {
    uint64_t v19 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v18 - v17)) >> 1;
    unsigned int v20 = &v17[5 * v19];
    unsigned int v21 = *v20;
    if (v21 <= v13) {
      break;
    }
    int v18 = v20 - 5;
LABEL_39:
    if (v17 > v18) {
      goto LABEL_40;
    }
  }

  if (v21 + 4 <= v13)
  {
    uint64_t v17 = v20 + 5;
    goto LABEL_39;
  }

  uint64_t v27 = (uint64_t)&v17[5 * v19 + (int)(v13 - v21)];
  unsigned int v28 = *(unsigned __int16 *)(v27 + 2);
  if (*(_WORD *)(v27 + 2))
  {
    BOOL v12 = v28 < 0x100;
    if (v28 < 0x100) {
      uint64_t v29 = 1LL;
    }
    else {
      uint64_t v29 = 2LL;
    }
    uint64_t v30 = v29 + v10;
    if (a5)
    {
      if (v30 > a5) {
        goto LABEL_452;
      }
      if (v28 >= 0x100) {
        *a4++ = BYTE1(v28);
      }
      *a4++ = v28;
    }

    goto LABEL_108;
  }

LABEL_210:
            BOOL v12 = 0;
            ++a2;
            goto LABEL_110;
          }

LABEL_282:
          switch(v13)
          {
            case 0x20DDu:
              int v95 = v162;
              if (v22 < 2
                || (__int16)a2[1] != -1926
                || (unsigned __int16)((unsigned __int16)v95 >> 10) < 0x2Bu
                || (unsigned __int16)v95 > 0xD574u)
              {
                goto LABEL_295;
              }

              unint64_t v96 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD_0xF87A;
              int v97 = (unsigned __int16 *)&unk_180CA01A8;
              while (1)
              {
                uint64_t v98 = ((char *)v97 - (char *)v96) >> 3;
                unint64_t v99 = &v96[2 * v98];
                unsigned int v100 = *v99;
                if (v100 <= (unsigned __int16)v95)
                {
                  if (v100 >= (unsigned __int16)v95)
                  {
                    uint64_t v130 = &v96[2 * v98 + 1];
                    uint64_t v131 = 2LL;
LABEL_404:
                    if (v164) {
                      uint64_t v138 = v10 + 1;
                    }
                    else {
                      uint64_t v138 = v10;
                    }
                    int v162 = v95;
                    if (!a5)
                    {
LABEL_412:
                      BOOL v12 = 0;
                      uint64_t v16 = v131 + v11;
                      uint64_t v10 = v138;
                      a2 += v131;
                      goto LABEL_110;
                    }

                    if (v138 <= a5)
                    {
                      unsigned int v139 = *v130;
                      uint64_t v140 = -2LL;
                      if (v164) {
                        uint64_t v140 = -1LL;
                      }
                      int v141 = &a4[v140];
                      *(_WORD *)int v141 = __rev16(v139);
                      a4 = v141 + 2;
                      goto LABEL_412;
                    }

                    uint64_t v158 = v138 - 1;
                    BOOL v159 = !v164;
LABEL_458:
                    if (!v159) {
                      uint64_t v10 = v158;
                    }
                    goto LABEL_452;
                  }

                  unint64_t v96 = v99 + 2;
                }

                else
                {
                  int v97 = v99 - 2;
                }

                if (v96 > v97)
                {
LABEL_295:
                  int v101 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD;
                  unint64_t v102 = (unsigned __int16 *)&unk_180CA033C;
                  while (1)
                  {
                    uint64_t v103 = ((char *)v102 - (char *)v101) >> 3;
                    int v104 = &v101[2 * v103];
                    unsigned int v105 = *v104;
                    if (v105 <= (unsigned __int16)v95)
                    {
                      if (v105 >= (unsigned __int16)v95)
                      {
                        uint64_t v130 = &v101[2 * v103 + 1];
                        uint64_t v131 = 1LL;
                        goto LABEL_404;
                      }

                      int v101 = v104 + 2;
                    }

                    else
                    {
                      unint64_t v102 = v104 - 2;
                    }

                    if (v101 > v102) {
                      goto LABEL_452;
                    }
                  }
                }
              }

            case 0x20DEu:
              int v113 = v162;
              if (v22 < 2) {
                goto LABEL_426;
              }
              int v114 = a2[1];
              if ((v114 & 0xFFF0) == 0xF870)
              {
                unsigned __int16 v165 = v113;
                if ((unsigned __int16)(v113 - 49) <= 8u)
                {
                  uint64_t v47 = 2LL;
                  switch(v114)
                  {
                    case 63605:
                      LOBYTE(v43) = v113 - 111;
                      LOBYTE(v42) = -84;
                      goto LABEL_441;
                    case 63610:
                      LOBYTE(v43) = v113 + 36;
                      goto LABEL_440;
                    case 63611:
                      LOBYTE(v43) = v113 + 16;
                      LOBYTE(v42) = -93;
                      goto LABEL_441;
                    case 63612:
                      LOBYTE(v43) = v113 - 75;
                      LOBYTE(v42) = -94;
                      goto LABEL_441;
                    case 63615:
                      LOBYTE(v43) = v113 + 16;
LABEL_440:
                      LOBYTE(v42) = -92;
                      goto LABEL_441;
                    default:
                      goto LABEL_442;
                  }
                }
              }

              if (v114 != 63612)
              {
                if (v114 == 63610)
                {
                  char v125 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                  uint64_t v126 = (unsigned __int16 *)&unk_180CA0490;
                  while (1)
                  {
                    uint64_t v127 = ((char *)v126 - (char *)v125) >> 3;
                    unint64_t v128 = &v125[2 * v127];
                    unsigned int v129 = *v128;
                    if (v129 <= (unsigned __int16)v113)
                    {
                      if (v129 >= (unsigned __int16)v113)
                      {
                        unsigned __int16 v142 = v125[2 * v127 + 1];
                        if ((unsigned __int16)(v142 + 21163) > 9u)
                        {
LABEL_415:
                          int64_t v143 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE_F87A;
                          uint64_t v144 = (unsigned __int16 *)&unk_180CA04BC;
                          while (1)
                          {
                            uint64_t v145 = ((char *)v144 - (char *)v143) >> 3;
                            uint64_t v146 = &v143[2 * v145];
                            unsigned int v147 = *v146;
                            if (v147 <= (unsigned __int16)v113)
                            {
                              if (v147 >= (unsigned __int16)v113)
                              {
                                LODWORD(v43) = v143[2 * v145 + 1];
                                LODWORD(v42) = v43 >> 8;
                                goto LABEL_441;
                              }

                              int64_t v143 = v146 + 2;
                            }

                            else
                            {
                              uint64_t v144 = v146 - 2;
                            }

                            if (v143 > v144) {
                              goto LABEL_452;
                            }
                          }
                        }

                        LOBYTE(v43) = v142 - 20;
LABEL_425:
                        LOBYTE(v42) = -83;
LABEL_441:
                        uint64_t v47 = 2LL;
LABEL_442:
                        if (v164) {
                          uint64_t v154 = v10 + 1;
                        }
                        else {
                          uint64_t v154 = v10;
                        }
                        int v162 = v113;
                        if (a5)
                        {
                          if (v154 > a5)
                          {
                            uint64_t v158 = v154 - 1;
                            BOOL v159 = !v164;
                            goto LABEL_458;
                          }

                          uint64_t v155 = -2LL;
                          if (v164) {
                            uint64_t v155 = -1LL;
                          }
                          uint64_t v156 = &a4[v155];
                          char *v156 = v42;
                          a4 = v156 + 2;
                          v156[1] = v43;
                        }

                        BOOL v12 = 0;
                        uint64_t v16 = v47 + v11;
                        uint64_t v10 = v154;
LABEL_106:
                        a2 += v47;
                        goto LABEL_110;
                      }

                      char v125 = v128 + 2;
                    }

                    else
                    {
                      uint64_t v126 = v128 - 2;
                    }

                    if (v125 > v126) {
                      goto LABEL_415;
                    }
                  }
                }

LABEL_426:
                uint64_t v149 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                uint64_t v150 = (unsigned __int16 *)&unk_180CA0490;
                while (1)
                {
                  uint64_t v151 = ((char *)v150 - (char *)v149) >> 3;
                  unsigned int v152 = &v149[2 * v151];
                  unsigned int v153 = *v152;
                  if (v153 <= (unsigned __int16)v113)
                  {
                    if (v153 >= (unsigned __int16)v113)
                    {
                      LODWORD(v43) = v149[2 * v151 + 1];
                      LODWORD(v42) = v43 >> 8;
                      uint64_t v47 = 1LL;
                      goto LABEL_442;
                    }

                    uint64_t v149 = v152 + 2;
                  }

                  else
                  {
                    uint64_t v150 = v152 - 2;
                  }

                  if (v149 > v150) {
                    goto LABEL_452;
                  }
                }
              }

              BOOL v132 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
              char v133 = (unsigned __int16 *)&unk_180CA0490;
              while (1)
              {
                uint64_t v134 = ((char *)v133 - (char *)v132) >> 3;
                unint64_t v135 = &v132[2 * v134];
                unsigned int v136 = *v135;
                if (v136 <= (unsigned __int16)v113)
                {
                  if (v136 >= (unsigned __int16)v113)
                  {
                    unsigned __int16 v148 = v132[2 * v134 + 1];
                    if ((unsigned __int16)(v148 + 21143) <= 6u)
                    {
                      LOBYTE(v43) = v148 + 14;
                      goto LABEL_425;
                    }

                    goto LABEL_426;
                  }

                  BOOL v132 = v135 + 2;
                }

                else
                {
                  char v133 = v135 - 2;
                }

                if (v132 > v133) {
                  goto LABEL_426;
                }
              }

            case 0x20DFu:
              unsigned int v115 = *(a2 - 1);
              if (v115 > 0x25C6)
              {
                if (v115 == 9671)
                {
                  if (v16 < a3 && a2[1] == 8415)
                  {
                    char v116 = 97;
                    ++a2;
                    ++v11;
                  }

                  else
                  {
                    char v116 = 87;
                  }
                }

                else
                {
                  if (v115 != 63494) {
                    goto LABEL_452;
                  }
                  char v116 = 96;
                }
              }

              else if (v115 == 9632)
              {
                char v116 = 86;
              }

              else
              {
                if (v115 != 9633) {
                  goto LABEL_452;
                }
                char v116 = 89;
              }

              if (a5)
              {
                *(a4 - 2) = -90;
                *(a4 - 1) = v116;
              }

              BOOL v12 = 0;
              ++a2;
              uint64_t v16 = v11 + 1;
              goto LABEL_110;
            case 0x20E0u:
            case 0x20E1u:
            case 0x20E2u:
            case 0x20E3u:
              goto LABEL_309;
            case 0x20E4u:
              if (*(a2 - 1) != 35036) {
                goto LABEL_452;
              }
              if (a5) {
                *((_WORD *)a4 - 1) = 31911;
              }
              goto LABEL_372;
            case 0x20E5u:
              int v117 = *(a2 - 1);
              if (v117 == 8801)
              {
                if (!a5) {
                  goto LABEL_368;
                }
                __int16 v124 = 25511;
                goto LABEL_367;
              }

              if (v117 != 61) {
                goto LABEL_452;
              }
              uint64_t v30 = v10 + 1;
              if (a5)
              {
                if (v10 >= a5) {
                  goto LABEL_452;
                }
                __int16 v107 = 25255;
                goto LABEL_337;
              }

              goto LABEL_107;
            default:
              if (v13 != 8402) {
                goto LABEL_309;
              }
              int v106 = *(a2 - 1);
              if (v106 == 8801)
              {
                if (a5)
                {
                  __int16 v124 = 28327;
LABEL_367:
                  *((_WORD *)a4 - 1) = v124;
                }

LABEL_368:
                uint64_t v30 = v10;
              }

              else
              {
                if (v106 != 61) {
                  goto LABEL_452;
                }
                uint64_t v30 = v10 + 1;
                if (a5)
                {
                  if (v10 >= a5) {
                    goto LABEL_452;
                  }
                  __int16 v107 = 26023;
LABEL_337:
                  *(_WORD *)(a4++ - 1) = v107;
                }
              }

              goto LABEL_107;
          }
        }

        if (*(a2 - 1) == 8869)
        {
          if (a5) {
            *((_WORD *)a4 - 1) = 28071;
          }
          BOOL v12 = 0;
          ++a2;
          goto LABEL_110;
        }
      }
    }

    else if (v13 != 774)
    {
      if (v13 != 776)
      {
        if (v13 == 822)
        {
          if (*(a2 - 1) != 8765)
          {
LABEL_309:
            if ((v13 & 0xFFF0) != 0xF870) {
              goto LABEL_452;
            }
            unsigned int v108 = v13 | (*(a2 - 1) << 16);
            if (v108 + 12584832 < 0xE1FFF7) {
              goto LABEL_452;
            }
            uint64_t v109 = (unsigned int *)&MacKorean_from_uni_0xF870;
            unint64_t v110 = (unsigned int *)&unk_180CA14E0;
            while (1)
            {
              uint64_t v111 = ((char *)v110 - (char *)v109) >> 4;
              uint64_t v112 = &v109[2 * v111];
              if (*v112 <= v108)
              {
                if (*v112 >= v108)
                {
                  unsigned int v118 = LOWORD(v109[2 * v111 + 1]);
                  if (v118 >= 0x100) {
                    uint64_t v119 = 0LL;
                  }
                  else {
                    uint64_t v119 = -1LL;
                  }
                  if (v164) {
                    uint64_t v119 = 1LL;
                  }
                  v10 += v119;
                  if (a5)
                  {
                    if (v10 <= a5)
                    {
                      uint64_t v120 = -2LL;
                      if (v164) {
                        uint64_t v120 = -1LL;
                      }
                      uint64_t v121 = &a4[v120];
                      if (v118 < 0x100)
                      {
                        uint64_t v123 = 1LL;
                        uint64_t v122 = v121;
                      }

                      else
                      {
                        *uint64_t v121 = BYTE1(v118);
                        uint64_t v122 = v121 + 1;
                        uint64_t v123 = 2LL;
                      }

                      a4 = &v121[v123];
                      char *v122 = v118;
                      goto LABEL_372;
                    }

                    if (v164)
                    {
                      --v10;
                    }

                    else if (v118 < 0x100)
                    {
                      ++v10;
                    }

LABEL_463:
                    a6 = v163;
                    goto LABEL_452;
                  }

LABEL_372:
                  BOOL v12 = 0;
LABEL_373:
                  ++a2;
LABEL_110:
                  uint64_t v11 = v16;
                  if (v16 >= a3) {
                    goto LABEL_452;
                  }
                  goto LABEL_3;
                }

                uint64_t v109 = v112 + 2;
              }

              else
              {
                unint64_t v110 = v112 - 2;
              }

              if (v109 > v110) {
                goto LABEL_452;
              }
            }
          }

          if (a5)
          {
            __int16 v73 = 31143;
LABEL_209:
            *((_WORD *)a4 - 1) = v73;
            goto LABEL_210;
          }

          goto LABEL_210;
        }

        goto LABEL_282;
      }

      if (*(a2 - 1) == 45)
      {
        if (a5)
        {
          if (v10 >= a5) {
            goto LABEL_452;
          }
          *(_WORD *)(a4++ - 1) = 26535;
        }

        BOOL v12 = 0;
        ++v10;
        goto LABEL_373;
      }
    }

    BOOL v160 = a4;
    int v161 = a1;
    unsigned int v92 = __CFPrecomposeCharKorean(a2 - 1);
    unsigned __int16 v165 = v92;
    if (!v92) {
      goto LABEL_463;
    }
    unsigned int v13 = v92;
    LODWORD(v43) = __CFToKSX1001(&v165, 1LL, v166, 0LL);
    LODWORD(v42) = v43 >> 8;
    if ((_DWORD)v43 == 65533)
    {
      a6 = v163;
      a1 = v161;
      a4 = v160;
    }

    else
    {
      a6 = v163;
      a1 = v161;
      a4 = v160;
      if (v42 >= 0xA1
        && (v43 & 0xFF00) != 0xFF00
        && v43 >= 0xA1u
        && v43 != 255)
      {
        if (v164) {
          uint64_t v93 = v10 + 1;
        }
        else {
          uint64_t v93 = v10;
        }
        if (a5)
        {
          if (v93 > a5)
          {
            uint64_t v158 = v93 - 1;
            BOOL v159 = !v164;
            goto LABEL_458;
          }

          uint64_t v94 = -2LL;
          if (v164) {
            uint64_t v94 = -1LL;
          }
          *(_WORD *)&v160[v94] = __rev16(v43);
          a4 = &v160[v94 + 2];
        }

        BOOL v12 = 0;
        ++a2;
        uint64_t v10 = v93;
        goto LABEL_110;
      }
    }

    goto LABEL_282;
  }

  unsigned int v50 = a2[1];
  if (v50 == 8225)
  {
    if (a2[2] == 8225)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 69;
      goto LABEL_199;
    }

    goto LABEL_452;
  }

  if (v50 == 8224)
  {
    if (a2[2] == 8224)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 68;
      goto LABEL_199;
    }

    goto LABEL_452;
  }

  if (v50 > 0x7F) {
    goto LABEL_452;
  }
  unsigned int v58 = a2[2];
  if (v58 > 0x7F) {
    goto LABEL_452;
  }
  unsigned int v59 = (v50 << 8) | (v13 << 16) | v58;
  if (v59 + 127325910 < 0xFFF6F815) {
    goto LABEL_452;
  }
  int v60 = (unsigned int *)&MacKorean_from_uni_0xF860;
  int v61 = (unsigned int *)&unk_180CA0858;
  while (2)
  {
    uint64_t v62 = ((char *)v61 - (char *)v60) >> 4;
    unsigned int v63 = &v60[2 * v62];
    if (*v63 > v59)
    {
      int v61 = v63 - 2;
      goto LABEL_156;
    }

    if (*v63 < v59)
    {
      int v60 = v63 + 2;
LABEL_156:
      if (v60 > v61) {
        goto LABEL_452;
      }
      continue;
    }

    break;
  }

  unsigned int v52 = LOWORD(v60[2 * v62 + 1]);
  unsigned int v51 = v52 >> 8;
LABEL_199:
  if (!a5)
  {
LABEL_202:
    BOOL v12 = 0;
    a2 += 3;
    uint64_t v16 = v11 + 3;
    v10 += 2LL;
    goto LABEL_110;
  }

  if (v10 + 2 <= a5)
  {
    *a4 = v51;
    a4[1] = v52;
    a4 += 2;
    goto LABEL_202;
  }

LABEL_452:
  *a6 = v10;
  return v11;
}

uint64_t __CFFromMacKorean(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v118 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = (a1 & 0x200) == 0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = 2LL;
  }
  uint64_t v16 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v17 = 3LL;
  }
  else {
    uint64_t v17 = 4LL;
  }
LABEL_8:
  if (!a5 || v12 < a5)
  {
    int v18 = *a2;
    if (*a2 < 0 && ((a1 & 0x80) == 0 || (v18 + 123) > 0x1Au))
    {
      switch(*a2)
      {
        case -128:
          if (a5) {
            *a4++ = 160;
          }
          goto LABEL_15;
        case -127:
          if (a5) {
            *a4++ = 8361;
          }
          goto LABEL_15;
        case -126:
          v12 += v15;
          if (!a5) {
            break;
          }
          if (v12 > a5) {
            return v13;
          }
          *a4 = 8211;
          unsigned int v21 = a4 + 1;
          if ((a1 & 0x200) != 0) {
            goto LABEL_34;
          }
          goto LABEL_40;
        case -125:
          if (a5) {
            *a4++ = 169;
          }
          goto LABEL_15;
        case -124:
          v12 += v15;
          if (!a5) {
            break;
          }
          if (v12 > a5) {
            return v13;
          }
          *a4 = -193;
          unsigned int v21 = a4 + 1;
          if ((a1 & 0x200) == 0) {
            goto LABEL_40;
          }
          goto LABEL_34;
        default:
          if (v18 != 255)
          {
            if (v9 < 2) {
              return v13;
            }
            uint64_t v22 = v17;
            uint64_t v23 = v16;
            int v24 = a2[1];
            unsigned int v25 = v24 | (v18 << 8);
            if ((unsigned __int16)((v24 | ((_WORD)v18 << 8)) + 21070) >= 0xF39Bu)
            {
              int v26 = (unsigned __int16 *)&MacKorean_to_uni_one_char;
              uint64_t v27 = (unsigned __int16 *)&unk_180CA195E;
              do
              {
                uint64_t v28 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v27 - v26)) >> 1;
                uint64_t v29 = &v26[5 * v28];
                unsigned int v30 = *v29;
                if (v30 <= v25)
                {
                  if (v30 + 4 > v25)
                  {
                    uint64_t v56 = (uint64_t)&v26[5 * v28 + (int)(v25 - v30)];
                    uint64_t v57 = *(unsigned __int16 *)(v56 + 2);
                    if (*(_WORD *)(v56 + 2))
                    {
                      uint64_t v16 = v23;
                      uint64_t v17 = v22;
                      if ((_DWORD)v16)
                      {
                        uint64_t v58 = v14;
                        uint64_t v115 = v15;
                        unsigned int v112 = v16;
                        int IsDecomposableCharacter_0 = __CFStringEncodingIsDecomposableCharacter_0( *(unsigned __int16 *)(v56 + 2),  (a1 >> 7) & 1);
                        uint64_t v17 = v22;
                        uint64_t v16 = v112;
                        uint64_t v15 = v115;
                        uint64_t v14 = v58;
                        if (IsDecomposableCharacter_0)
                        {
                          uint64_t v61 = __CFStringEncodingDecomposeCharacter_0(a1, v57, v117, v60, 63615LL, v58, v22, 8230LL);
                          uint64_t v52 = *a6;
                          uint64_t v12 = *a6 + v61;
                          *a6 = v12;
                          if (a5)
                          {
                            if (v12 > a5) {
                              goto LABEL_197;
                            }
                            if (v61 >= 1)
                            {
                              unint64_t v62 = v61 + 1;
                              unsigned int v63 = (__int16 *)v117;
                              uint64_t v14 = v58;
                              uint64_t v15 = v115;
                              uint64_t v16 = v112;
                              uint64_t v17 = v22;
                              do
                              {
                                __int16 v64 = *v63++;
                                *a4++ = v64;
                                --v62;
                              }

                              while (v62 > 1);
                              uint64_t v19 = 2LL;
                              goto LABEL_18;
                            }
                          }

                          uint64_t v19 = 2LL;
                          uint64_t v14 = v58;
                          uint64_t v15 = v115;
                          uint64_t v16 = v112;
                          uint64_t v17 = v22;
                          goto LABEL_18;
                        }
                      }

                      if (a5) {
                        *a4++ = v57;
                      }
LABEL_122:
                      uint64_t v12 = *a6 + 1;
                      uint64_t v19 = 2LL;
                      goto LABEL_17;
                    }

                    break;
                  }

                  int v26 = v29 + 5;
                }

                else
                {
                  uint64_t v27 = v29 - 5;
                }
              }

              while (v26 <= v27);
            }

            int v31 = (unsigned __int16 *)&MacKorean_to_uni_two_char;
            uint64_t v32 = (unsigned __int16 *)&unk_180CA329E;
            while (1)
            {
              uint64_t v33 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v32 - v31)) >> 1;
              uint64_t v34 = &v31[17 * v33];
              unsigned int v35 = *v34;
              if (v35 <= v25)
              {
                if (v35 + 16 > v25)
                {
                  unsigned __int16 v65 = v31[17 * v33 + 1 + (int)(v25 - v35)];
                  if (v65)
                  {
                    unsigned int v66 = (char *)&__CFTwoCharDecompSeqTable + 4 * (v65 & 0x7FFF);
                    unsigned int v69 = *((unsigned __int16 *)v66 - 2);
                    uint64_t v67 = v66 - 4;
                    uint64_t v68 = v69;
                    uint64_t v16 = v23;
                    uint64_t v17 = v22;
                    if ((_DWORD)v16)
                    {
                      unsigned int v105 = v67;
                      uint64_t v110 = v22;
                      unsigned int v113 = v16;
                      uint64_t v116 = v15;
                      unsigned int v108 = v14;
                      if ((__CFStringEncodingIsDecomposableCharacter_0(v68, (a1 >> 7) & 1) & 1) != 0)
                      {
                        uint64_t v75 = __CFStringEncodingDecomposeCharacter_0(a1, v68, v117, v70, v71, v72, v73, v74);
                        uint64_t v12 = v75 + !(((v65 & 0x8000u) != 0) & (a1 >> 9)) + *a6;
                        if (a5)
                        {
                          uint64_t v14 = v108;
                          uint64_t v15 = v116;
                          uint64_t v16 = v113;
                          uint64_t v17 = v22;
                          if (v12 <= a5)
                          {
                            if (v75 >= 1)
                            {
                              unint64_t v76 = v75 + 1;
                              int v77 = (__int16 *)v117;
                              do
                              {
                                __int16 v78 = *v77++;
                                *a4++ = v78;
                                --v76;
                              }

                              while (v76 > 1);
                            }

                            goto LABEL_194;
                          }

                          return v13;
                        }

                        uint64_t v19 = 2LL;
                        uint64_t v14 = v108;
LABEL_187:
                        uint64_t v15 = v116;
                        uint64_t v16 = v113;
                        uint64_t v17 = v110;
                        goto LABEL_17;
                      }

                      uint64_t v12 = *a6;
                      uint64_t v14 = v108;
                      uint64_t v15 = v116;
                      uint64_t v16 = v113;
                      uint64_t v17 = v22;
                      uint64_t v67 = v105;
                    }

                    else {
                      uint64_t v92 = 2LL;
                    }
                    v12 += v92;
                    if (a5)
                    {
                      if (v12 > a5) {
                        return v13;
                      }
                      *a4 = v68;
                      if ((((v65 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                      {
                        ++a4;
                      }

                      else
                      {
                        a4[1] = *((_WORD *)v67 + 1);
                        a4 += 2;
                      }

                      goto LABEL_160;
                    }

LABEL_168:
                    uint64_t v19 = 2LL;
                    goto LABEL_17;
                  }

LABEL_70:
                                uint64_t v16 = v23;
                                uint64_t v17 = v22;
                                unsigned int v107 = v14;
                                uint64_t v114 = v15;
                                unsigned int v111 = v16;
                                uint64_t v46 = __CFFromKSX1001(v25);
                                uint64_t v17 = v22;
                                uint64_t v16 = v111;
                                uint64_t v15 = v114;
                                uint64_t v14 = v107;
                                uint64_t v47 = v46;
                                if ((_DWORD)v46 == 65533)
                                {
LABEL_73:
                                  if ((unsigned __int16)(v25 + 13919) <= 0x5Du)
                                  {
                                    if (a5)
                                    {
                                      __int16 v48 = v25 + 5727;
                                      goto LABEL_79;
                                    }

                                    goto LABEL_80;
                                  }

                                  if ((unsigned __int16)(v25 + 351) <= 0x5Du)
                                  {
                                    if (a5)
                                    {
                                      __int16 v48 = v25 - 3907;
LABEL_79:
                                      *a4++ = v48;
                                    }

        uint64_t v68 = v13;
        uint64_t v32 = a5;
        uint64_t v33 = a1;
        uint64_t v34 = a3;
        unsigned int v35 = (char *)v9;
        unsigned int v36 = a6;
        unint64_t v37 = __CFPrecomposeCharJapanese(v11 - 1, 1);
        uint64_t v38 = __CFToJIS(v37, 0);
        if ((v38 & 0x8000) != 0)
        {
          a6 = v36;
          uint64_t v13 = v68;
          goto LABEL_238;
        }

        if (v32)
        {
          uint64_t v39 = -2LL;
          if (*(a4 - 1) == 61) {
            uint64_t v39 = -1LL;
          }
          JIS0208ToShiftJIS(v38, &a4[v39]);
        }

        a5 = v32;
        int v7 = v12;
        a6 = v36;
        unint64_t v9 = (unsigned __int16 *)v35;
        a3 = v34;
        a1 = v33;
        uint64_t v13 = v68;
        uint64_t v10 = 20043LL;
        goto LABEL_232;
      }

      if (v14 - 12441 < 2) {
        goto LABEL_70;
      }
      if (v14 != 63610)
      {
        if (v14 == 63614)
        {
          unsigned int v30 = *(v11 - 1);
          if (v30 <= 0x30A0)
          {
            if (*(v11 - 1) <= 0x3040u)
            {
              if (*(v11 - 1) > 0x3000u)
              {
                switch(v30)
                {
                  case 0x3001u:
                    int v31 = 60225;
                    break;
                  case 0x3002u:
                    int v31 = 60226;
                    break;
                  case 0x301Cu:
                    int v31 = 60256;
                    break;
                  default:
                    goto LABEL_238;
                }
              }

              else
              {
                switch(v30)
                {
                  case 0x2010u:
                    int v31 = 60253;
                    break;
                  case 0x2016u:
                    int v31 = 60257;
                    break;
                  case 0x2026u:
                    int v31 = 60259;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }

            else
            {
              if (*(v11 - 1) <= 0x3062u)
              {
                switch(*(v11 - 1))
                {
                  case 0x3041u:
                    int v31 = 60575;
                    goto LABEL_229;
                  case 0x3043u:
                    int v31 = 60577;
                    goto LABEL_229;
                  case 0x3045u:
                    int v31 = 60579;
                    goto LABEL_229;
                  case 0x3047u:
                    int v31 = 60581;
                    goto LABEL_229;
                  case 0x3049u:
                    int v31 = 60583;
                    goto LABEL_229;
                  default:
                    goto LABEL_238;
                }

                goto LABEL_238;
              }

              if (*(v11 - 1) <= 0x3084u)
              {
                if (v30 == 12387)
                {
                  int v31 = 60609;
                }

                else
                {
                  if (v30 != 12419) {
                    goto LABEL_238;
                  }
                  int v31 = 60641;
                }
              }

              else
              {
                switch(v30)
                {
                  case 0x3085u:
                    int v31 = 60643;
                    break;
                  case 0x3087u:
                    int v31 = 60645;
                    break;
                  case 0x308Eu:
                    int v31 = 60652;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }
          }

          else if (*(v11 - 1) > 0x30EDu)
          {
            if (*(v11 - 1) <= 0xFF1Cu)
            {
              if (*(v11 - 1) > 0x30F5u)
              {
                if (v30 == 12534)
                {
                  int v31 = 60822;
                }

                else
                {
                  if (v30 != 12540) {
                    goto LABEL_238;
                  }
                  int v31 = 60251;
                }
              }

              else if (v30 == 12526)
              {
                int v31 = 60814;
              }

              else
              {
                if (v30 != 12533) {
                  goto LABEL_238;
                }
                int v31 = 60821;
              }
            }

            else if (*(v11 - 1) <= 0xFF3Cu)
            {
              if (v30 == 65309)
              {
                int v31 = 60289;
              }

              else
              {
                if (v30 != 65339) {
                  goto LABEL_238;
                }
                int v31 = 60269;
              }
            }

            else
            {
              switch(v30)
              {
                case 0xFF3Du:
                  int v31 = 60270;
                  break;
                case 0xFF5Cu:
                  int v31 = 60258;
                  break;
                case 0xFFE3u:
                  int v31 = 60240;
                  break;
                default:
                  goto LABEL_238;
              }
            }
          }

          else
          {
            if (*(v11 - 1) <= 0x30C2u)
            {
              switch(*(v11 - 1))
              {
                case 0x30A1u:
                  int v31 = 60736;
                  goto LABEL_229;
                case 0x30A3u:
                  int v31 = 60738;
                  goto LABEL_229;
                case 0x30A5u:
                  int v31 = 60740;
                  goto LABEL_229;
                case 0x30A7u:
                  int v31 = 60742;
                  goto LABEL_229;
                case 0x30A9u:
                  int v31 = 60744;
                  goto LABEL_229;
                default:
                  goto LABEL_238;
              }

              goto LABEL_238;
            }

            if (*(v11 - 1) > 0x30E4u)
            {
              if (v30 == 12517)
              {
                int v31 = 60805;
              }

              else
              {
                if (v30 != 12519) {
                  goto LABEL_238;
                }
                int v31 = 60807;
              }
            }

            else if (v30 == 12483)
            {
              int v31 = 60770;
            }

            else
            {
              if (v30 != 12515) {
                goto LABEL_238;
              }
              int v31 = 60803;
            }
          }

LABEL_197:
                                    *a6 = v52;
                                    return v13;
                                  }
                                }

                                if (a5) {
                                  *a4++ = v47;
                                }
                                goto LABEL_122;
                              }

                              unsigned int v41 = v44 + 17;
                            }

                            else
                            {
                              unint64_t v42 = v44 - 17;
                            }

                            if (v41 > v42) {
                              goto LABEL_70;
                            }
                          }
                        }

                        int v106 = (unsigned __int16 *)((char *)&__CFThreeCharDecompSeqTable
                                                  + 6 * (v36[17 * v38 + 1 + (int)(v25 - v40)] & 0x7FFF));
                        uint64_t v81 = *v106;
                        uint64_t v16 = v23;
                        uint64_t v17 = v22;
                        if ((_DWORD)v16)
                        {
                          uint64_t v110 = v22;
                          unsigned int v113 = v16;
                          uint64_t v116 = v15;
                          unsigned int v109 = v14;
                          if ((__CFStringEncodingIsDecomposableCharacter_0(v81, (a1 >> 7) & 1) & 1) != 0)
                          {
                            uint64_t v87 = __CFStringEncodingDecomposeCharacter_0(a1, v81, v117, v82, v83, v84, v85, v86);
                            else {
                              uint64_t v88 = 2LL;
                            }
                            uint64_t v12 = v87 + v88 + *a6;
                            if (a5)
                            {
                              uint64_t v14 = v109;
                              uint64_t v15 = v116;
                              uint64_t v16 = v113;
                              uint64_t v17 = v22;
                              if (v12 <= a5)
                              {
                                if (v87 >= 1)
                                {
                                  unint64_t v89 = v87 + 1;
                                  uint64_t v90 = (__int16 *)v117;
                                  do
                                  {
                                    __int16 v91 = *v90++;
                                    *a4++ = v91;
                                    --v89;
                                  }

                                  while (v89 > 1);
                                }

                                *a4 = v106[1];
                                char v103 = v109 ^ 1;
                                if ((v80 & 0x8000u) != 0) {
                                  char v103 = 0;
                                }
                                if ((v103 & 1) != 0)
                                {
                                  ++a4;
                                }

                                else
                                {
                                  a4[1] = v106[2];
                                  a4 += 2;
                                }

LABEL_194:
                                uint64_t v19 = 2LL;
                                goto LABEL_17;
                              }

                              return v13;
                            }

                            uint64_t v19 = 2LL;
                            uint64_t v14 = v109;
                            goto LABEL_187;
                          }

                          uint64_t v12 = *a6;
                          uint64_t v14 = v109;
                          uint64_t v15 = v116;
                          uint64_t v16 = v113;
                          uint64_t v17 = v22;
                        }

                        uint64_t v96 = 2LL;
                        v12 += v96;
                        if (a5)
                        {
                          if (v12 > a5) {
                            return v13;
                          }
                          if ((((v80 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                          {
                            int v97 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v80 & 0x7FFF);
                            *a4 = v106[1];
                            uint64_t v98 = a4 + 1;
                          }

                          else
                          {
                            int v97 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v80 & 0x7FFF);
                            a4[1] = v106[1];
                            unint64_t v99 = a4 + 1;
                            *a4 = v81;
                            a4 += 2;
                            uint64_t v98 = a4;
                            char v100 = v14 ^ 1;
                            if ((v80 & 0x8000u) != 0) {
                              char v100 = 0;
                            }
                            if ((v100 & 1) != 0) {
                              goto LABEL_160;
                            }
                            a4 = v99;
                          }

                          a4 += 2;
                          *uint64_t v98 = *((_WORD *)v97 + 2);
                          goto LABEL_81;
                        }

                        goto LABEL_168;
                      }

                      unsigned int v36 = v39 + 17;
                    }

                    else
                    {
                      unint64_t v37 = v39 - 17;
                    }

                    if (v36 > v37) {
                      goto LABEL_63;
                    }
                  }
                }

                int v31 = v34 + 17;
              }

              else
              {
                uint64_t v32 = v34 - 17;
              }

              if (v31 > v32) {
                goto LABEL_56;
              }
            }
          }

          v12 += v15;
          if (a5)
          {
            if (v12 > a5) {
              return v13;
            }
            *a4 = 8230;
            unsigned int v21 = a4 + 1;
            if ((a1 & 0x200) != 0)
            {
LABEL_34:
              a4 = v21;
            }

            else
            {
LABEL_40:
              a4[1] = -1921;
              a4 += 2;
            }
          }

          break;
      }
    }

    else
    {
      if (a5) {
        *a4++ = v18;
      }
LABEL_15:
      ++v12;
    }

    uint64_t v19 = 1LL;
    goto LABEL_17;
  }

  return v13;
}

uint64_t __CFFromMacKoreanLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    unsigned int v4 = *a2;
    BOOL v5 = v4 >= 0x85 && (unint64_t)a3 >= 2;
    if (!v5 || v4 == 255)
    {
      ++a2;
      --a3;
    }

    else
    {
      a2 += 2;
      a3 -= 2LL;
    }

    ++result;
  }

  while (a3 > 0);
  return result;
}

uint64_t CFStringEncodingUnicodeToBytes( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t *a5, unsigned int *a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v10 = (uint64_t)a6;
  unint64_t v13 = (unint64_t)a3;
  uint64_t v14 = a2;
  v76[1] = *MEMORY[0x1895F89C0];
  if ((_DWORD)a1 == 134217984)
  {
    if ((a2 & 0xC0) != 0)
    {
      CFUniCharDecompose(a3, a4, v76, a6, a7, &v75, 1, 2, (a2 & 0x80) != 0);
      if (!a5)
      {
LABEL_5:
        if (a8) {
          *a8 = v75;
        }
        if (a4 == v76[0]) {
          return 0LL;
        }
        if (a7 < 1) {
          return 1LL;
        }
        if (a7 - v75 > 9) {
          return 1LL;
        }
        int v20 = *(_WORD *)(v13 + 2LL * v76[0]) & 0xFC00;
        if (v20 == 56320
          || v20 == 55296
          && (a4 - v76[0] == 1
           || (unsigned __int16)((unsigned __int16)(*(_WORD *)(v13 + 2LL * v76[0] + 2) + 0x2000) >> 10) < 0x3Fu))
        {
          return 1LL;
        }

        return 2LL;
      }
    }

    else
    {
      unsigned int v21 = CFStringEncodingUnicodeToBytes___CFToUTF8;
      if (!CFStringEncodingUnicodeToBytes___CFToUTF8)
      {
        unsigned int v21 = **(void ***)__CFGetConverter(134217984LL);
        CFStringEncodingUnicodeToBytes___CFToUTF8 = v21;
      }

      v76[0] = ((uint64_t (*)(void, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))v21)( 0LL,  v13,  a4,  v10,  a7,  &v75);
      if (!a5) {
        goto LABEL_5;
      }
    }

    *a5 = v76[0];
    goto LABEL_5;
  }

  uint64_t v16 = (uint64_t *)__CFGetConverter(a1);
  if (!v16) {
    return 3LL;
  }
  uint64_t v17 = v16;
  if ((v14 & 8) != 0)
  {
    uint64_t v18 = *v16;
    uint64_t v19 = 0LL;
    if ((v14 & 1) != 0) {
      uint64_t v74 = 0LL;
    }
    else {
      uint64_t v74 = *(uint64_t (**)(void))(v18 + 64);
    }
  }

  else
  {
    uint64_t v18 = *v16;
    uint64_t v74 = *(uint64_t (**)(void))(*v16 + 64);
    if ((v14 & 0x20) != 0)
    {
      uint64_t v19 = 0LL;
    }

    else
    {
      uint64_t v19 = *(uint64_t (**)(void, uint64_t, uint64_t))(v18 + 56);
      uint64_t v14 = v14 | 0x10;
    }
  }

  int v22 = *(unsigned __int8 *)(v18 + 20);
  if (v22 == 4) {
    return __CFStringEncodingPlatformUnicodeToBytes();
  }
  if (v22 == 5) {
    return __CFStringEncodingICUToBytes(v16[1], v14, v13, a4, a5, v10, a7, a8);
  }
  if (a4 < 1)
  {
    uint64_t result = 0LL;
    uint64_t v24 = 0LL;
    uint64_t v23 = 0LL;
    goto LABEL_130;
  }

  unsigned int v69 = v19;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  unsigned int v71 = BYTE3(v14);
  unsigned int v73 = v14;
  uint64_t v72 = v10;
  while (1)
  {
    if (a7 && a7 <= v24)
    {
LABEL_111:
      uint64_t result = 0LL;
      goto LABEL_130;
    }

    unsigned int v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[1];
    if (v25)
    {
      uint64_t v26 = a7 ? a7 - v24 : 0LL;
      uint64_t v27 = v25(v17, v14, v13 + 2 * v23, a4 - v23, v10 + v24, v26, v76);
    }

    else
    {
      uint64_t v28 = a7 ? a7 - v24 : 0LL;
      uint64_t v27 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))*v17)( v14,  v13 + 2 * v23,  a4 - v23,  v10 + v24,  v28,  v76);
    }

    uint64_t v29 = v27 + v23;
    uint64_t v30 = a4 - (v27 + v23);
    if (a4 > v27 + v23) {
      break;
    }
    v23 += v27;
    uint64_t v14 = v73;
LABEL_74:
    v24 += v76[0];
    uint64_t v10 = v72;
    if (v23 >= a4) {
      goto LABEL_111;
    }
  }

  uint64_t v70 = v27;
  if (v74)
  {
    if (v29 >= 1)
    {
      uint64_t v67 = (unsigned __int16 *)(v13 + 2 * v29);
      if (v74(*v67))
      {
        if (v69)
        {
          unint64_t v66 = v13;
          uint64_t v68 = (void (**)(void))v17;
          __int16 v64 = a5;
          unsigned __int16 v65 = a8;
          uint64_t v31 = 0LL;
          uint64_t v32 = 0LL;
          uint64_t v33 = v29;
          unint64_t v34 = v13 + 2 * v29;
          do
          {
            uint64_t v35 = v33;
            unint64_t v36 = v29 + v31;
            char v37 = v74(*(unsigned __int16 *)(v34 + 2 * v31 - 2));
            v32 += 2LL;
            --v31;
            if (v36 < 2) {
              break;
            }
            uint64_t v33 = v35 - 1;
          }

          while ((v37 & 1) != 0);
          unint64_t v13 = v66;
          uint64_t v38 = v66 + 2 * v29 - v32;
          uint64_t v39 = v76[0] + v24;
          if (*((unsigned __int16 *)*v68 + 8) < 2u)
          {
            uint64_t v24 = v39 - 1;
            uint64_t v48 = v70;
          }

          else
          {
            unsigned int v40 = v68[1];
            if (v40) {
              v40();
            }
            else {
              (*(void (**)(void, unint64_t, uint64_t, void, void, void *))*v68)( v73,  v66 + 2 * v29 - v32,  -v31,  0LL,  0LL,  v76);
            }
            uint64_t v24 = v39 - v76[0];
            uint64_t v48 = v70;
            uint64_t v38 = v66 + 2 * v29 - v32;
          }

          uint64_t v62 = a4 - v48 - v23;
          if (a7) {
            uint64_t v49 = a7 - v24;
          }
          else {
            uint64_t v49 = 0LL;
          }
          uint64_t v60 = v49;
          uint64_t v61 = (_BYTE *)(v72 + v24);
          uint64_t v50 = v69(v73, v38, v62 - v31);
          if (v50 < 1)
          {
            if ((v73 & 1) == 0)
            {
              uint64_t v29 = v70 + v23 + v31;
              uint64_t result = 1LL;
              a5 = v64;
              a8 = v65;
              uint64_t v17 = (uint64_t *)v68;
              goto LABEL_128;
            }

            if (v71)
            {
              do
              {
                uint64_t v42 = v35;
                if (v35 >= a4) {
                  break;
                }
                char v51 = v74(*(unsigned __int16 *)(v66 + 2 * v35++));
              }

              while ((v51 & 1) != 0);
              v76[0] = 1LL;
              a8 = v65;
              uint64_t v14 = v73;
              if (a7) {
                *uint64_t v61 = v71;
              }
              a5 = v64;
              uint64_t v17 = (uint64_t *)v68;
              goto LABEL_73;
            }

            uint64_t v17 = (uint64_t *)v68;
            uint64_t v42 = ((uint64_t (*)(unint64_t, uint64_t, _BYTE *, uint64_t, void *))v68[4])( v66 + 2 * v29 - v32 + 2,  ~v31 + v62,  v61,  v60,  v76)
                + v29
                + v31
                + 1;
            a5 = v64;
            a8 = v65;
          }

          else
          {
            uint64_t v42 = v50 + v29 + v31;
            if (v42 >= a4)
            {
              a5 = v64;
              a8 = v65;
              uint64_t v17 = (uint64_t *)v68;
            }

            else
            {
              uint64_t v63 = v50;
              a5 = v64;
              a8 = v65;
              uint64_t v17 = (uint64_t *)v68;
              if (v74(*(unsigned __int16 *)(v66 + 2 * v42)))
              {
                v24 += v76[0];
                uint64_t v29 = v70 + v23 + v63 + v31;
LABEL_127:
                uint64_t result = 1LL;
                goto LABEL_128;
              }
            }
          }

          goto LABEL_72;
        }

        if (a7)
        {
          if (v76[0] + v24 == a7) {
            goto LABEL_125;
          }
          uint64_t v47 = (uint64_t (*)(uint64_t *, void, unsigned __int16 *, uint64_t, void, void, uint64_t *))v17[1];
          if (v47)
          {
            if (v47(v17, v73, v67, v30, 0LL, 0LL, &v75)) {
              goto LABEL_125;
            }
          }

          else if ((*(uint64_t (**)(void, unsigned __int16 *, uint64_t, void, void, uint64_t *))*v17)( v73,  v67,  v30,  0LL,  0LL,  &v75))
          {
LABEL_125:
            v24 += v76[0];
            uint64_t result = 2LL;
LABEL_128:
            LODWORD(v14) = v73;
            goto LABEL_129;
          }
        }

        if ((v73 & 0x20) != 0)
        {
          uint64_t v52 = v70 + v23 + 1;
          uint64_t v14 = v73;
          do
          {
            uint64_t v42 = v52;
            if (v52 >= a4) {
              break;
            }
            char v53 = v74(*(unsigned __int16 *)(v13 + 2 * v52));
            uint64_t v52 = v42 + 1;
          }

          while ((v53 & 1) != 0);
          goto LABEL_73;
        }

        v24 += v76[0];
        if (!v71)
        {
          uint64_t v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[4];
          uint64_t v45 = v72 + v24;
          if (a7) {
            uint64_t v46 = a7 - v24;
          }
          else {
            uint64_t v46 = 0LL;
          }
          unint64_t v44 = v13 + 2 * v29;
          goto LABEL_71;
        }

        goto LABEL_66;
      }
    }
  }

  if (!a7)
  {
LABEL_64:
    v24 += v76[0];
    if ((v73 & 1) == 0) {
      goto LABEL_127;
    }
    if (!v71)
    {
      uint64_t v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v17[4];
      unint64_t v44 = v13 + 2 * v29;
      uint64_t v45 = v72 + v24;
      if (a7) {
        uint64_t v46 = a7 - v24;
      }
      else {
        uint64_t v46 = 0LL;
      }
LABEL_71:
      uint64_t v42 = v43(v44, v30, v45, v46, v76) + v29;
LABEL_72:
      uint64_t v14 = v73;
LABEL_73:
      uint64_t v23 = v42;
      goto LABEL_74;
    }

_OWORD *CFStringEncodingGetConverter(uint64_t a1)
{
  uint64_t result = __CFGetConverter(a1);
  if (result) {
    return *(_OWORD **)result;
  }
  return result;
}

_OWORD *__CFGetConverter(uint64_t a1)
{
  switch((_DWORD)a1)
  {
    case 0xFFFFFFFF:
      return 0LL;
    case 0x8000100:
      unsigned int v2 = &__CFGetConverter_commonConverters;
      goto LABEL_6;
    case 0:
      unsigned int v2 = &qword_18C45D098;
LABEL_6:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
LABEL_9:
      int v4 = 0;
      CFTypeRef Value = (_OWORD *)*v2;
      goto LABEL_10;
  }

  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (SystemEncoding == (_DWORD)a1)
  {
    unsigned int v2 = &qword_18C45D0A0;
    goto LABEL_9;
  }

  if (!__CFGetConverter_mappingTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
    unsigned int v2 = 0LL;
    int v4 = 1;
    goto LABEL_11;
  }

  CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)__CFGetConverter_mappingTable, (const void *)a1);
  unsigned int v2 = 0LL;
  int v4 = 1;
LABEL_10:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (!Value)
  {
LABEL_11:
    if ((int)a1 > 1535)
    {
      switch((_DWORD)a1)
      {
        case 0x600:
          Externaluint64_t Converter = __CFConverterASCII;
          goto LABEL_28;
        case 0xB01:
          Externaluint64_t Converter = __CFConverterNextStepLatin;
          goto LABEL_28;
        case 0x8000100:
          Externaluint64_t Converter = __CFConverterUTF8;
          goto LABEL_28;
      }
    }

    else
    {
      switch((_DWORD)a1)
      {
        case 0:
          Externaluint64_t Converter = __CFConverterMacRoman;
          goto LABEL_28;
        case 0x201:
          Externaluint64_t Converter = __CFConverterISOLatin1;
          goto LABEL_28;
        case 0x500:
          Externaluint64_t Converter = __CFConverterWinLatin1;
          goto LABEL_28;
      }
    }

    Externaluint64_t Converter = __CFStringEncodingGetExternalConverter(a1);
    if (ExternalConverter)
    {
LABEL_28:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
      if (v4)
      {
        if (!__CFGetConverter_mappingTable
          || (CFTypeRef Value = CFDictionaryGetValue( (CFDictionaryRef)__CFGetConverter_mappingTable,  (const void *)a1)) == 0LL)
        {
LABEL_34:
          if ((__CFEncodingConverterFromDefinition__currentIndex - 9) > 0xFFFFFFF5)
          {
            int v7 = (int8x16_t *)__CFEncodingConverterFromDefinition__allocatedEntries;
            if (__CFEncodingConverterFromDefinition__allocatedEntries)
            {
              unsigned int v8 = ++__CFEncodingConverterFromDefinition__currentIndex;
              goto LABEL_39;
            }
          }

          else
          {
            __CFEncodingConverterFromDefinition__currentIndex = 0;
            __CFEncodingConverterFromDefinition__allocatedEntries = 0LL;
          }

          int v7 = (int8x16_t *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 480LL, 0LL);
          __CFEncodingConverterFromDefinition__allocatedEntries = (uint64_t)v7;
          unsigned int v8 = __CFEncodingConverterFromDefinition__currentIndex;
LABEL_39:
          CFTypeRef Value = v7[3 * v8].i8;
          Value[1] = 0u;
          Value[2] = 0u;
          _OWORD *Value = 0u;
          *(void *)CFTypeRef Value = ExternalConverter;
          unsigned int v9 = v8;
          switch(*((_BYTE *)ExternalConverter + 20))
          {
            case 0:
              uint64_t v10 = &v7[3 * v8];
              v10->i64[1] = 0LL;
              v10[1].i64[0] = 0LL;
              v10[1].i64[1] = 0LL;
              goto LABEL_48;
            case 1:
              uint64_t v11 = &v7[3 * v8];
              v11->i64[1] = (uint64_t)__CFToBytesCheapEightBitWrapper;
              v11[1].i64[0] = (uint64_t)__CFToUnicodeCheapEightBitWrapper;
              uint64_t v12 = __CFToCanonicalUnicodeCheapEightBitWrapper;
              goto LABEL_46;
            case 2:
              uint64_t v11 = &v7[3 * v8];
              v11->i64[1] = (uint64_t)__CFToBytesStandardEightBitWrapper;
              v11[1].i64[0] = (uint64_t)__CFToUnicodeStandardEightBitWrapper;
              uint64_t v12 = __CFToCanonicalUnicodeStandardEightBitWrapper;
              goto LABEL_46;
            case 3:
              uint64_t v11 = &v7[3 * v8];
              v11->i64[1] = (uint64_t)__CFToBytesCheapMultiByteWrapper;
              v11[1].i64[0] = (uint64_t)__CFToUnicodeCheapMultiByteWrapper;
              uint64_t v12 = __CFToCanonicalUnicodeCheapMultiByteWrapper;
LABEL_46:
              v11[1].i64[1] = (uint64_t)v12;
              goto LABEL_48;
            case 4:
              goto LABEL_48;
            case 5:
              v7[3 * v8].i64[1] = (uint64_t)__CFStringEncodingGetICUName(a1);
LABEL_48:
              v13.i64[0] = (uint64_t)__CFDefaultToBytesFallbackProc;
              v13.i64[1] = (uint64_t)__CFDefaultToUnicodeFallbackProc;
              v7[3 * v9 + 2] = vbslq_s8( (int8x16_t)vceqzq_s64(*(int64x2_t *)(ExternalConverter + 5)),  v13,  *(int8x16_t *)(ExternalConverter + 5));
              if (v4) {
                goto LABEL_49;
              }
              goto LABEL_42;
            default:
              CFTypeRef Value = 0LL;
              if (v4)
              {
LABEL_49:
                CFMutableStringRef Mutable = (__CFDictionary *)__CFGetConverter_mappingTable;
                if (!__CFGetConverter_mappingTable)
                {
                  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, 0LL, 0LL);
                  __CFGetConverter_mappingTable = (uint64_t)Mutable;
                }

                CFDictionarySetValue(Mutable, (const void *)a1, Value);
              }

              else
              {
LABEL_42:
                *unsigned int v2 = (uint64_t)Value;
              }

              break;
          }
        }
      }

      else
      {
        CFTypeRef Value = (_OWORD *)*v2;
        if (!*v2) {
          goto LABEL_34;
        }
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
      return Value;
    }

    return 0LL;
  }

  return Value;
}

uint64_t CFStringEncodingBytesToUnicode( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  v35[1] = *MEMORY[0x1895F89C0];
  uint64_t v15 = (uint64_t *)__CFGetConverter(a1);
  if (!v15) {
    return 3LL;
  }
  uint64_t v16 = v15;
  int v17 = *(unsigned __int8 *)(*v15 + 20);
  if (v17 == 4) {
    return __CFStringEncodingPlatformBytesToUnicode();
  }
  if (v17 == 5) {
    return __CFStringEncodingICUToUnicode(v15[1], a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v33 = a5;
  if (a4 < 1)
  {
    uint64_t v20 = 0LL;
    uint64_t v19 = 0LL;
    unsigned int v29 = 0;
    goto LABEL_50;
  }

  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  while (1)
  {
    if (a7 && a7 <= v19)
    {
LABEL_43:
      unsigned int v29 = 0;
      goto LABEL_50;
    }

    unsigned int v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[2];
    if (v21)
    {
      if ((a2 & 0xC0) != 0) {
        unsigned int v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[3];
      }
      uint64_t v22 = a7 ? a7 - v19 : 0LL;
      uint64_t v23 = v21(v16, a2, a3 + v20, a4 - v20, a6 + 2 * v19, v22, v35);
    }

    else
    {
      uint64_t v24 = a7 ? a7 - v19 : 0LL;
      uint64_t v23 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, void *))(*v16 + 8))( a2,  a3 + v20,  a4 - v20,  a6 + 2 * v19,  v24,  v35);
    }

    v20 += v23;
    if (a4 > v20) {
      break;
    }
LABEL_42:
    v19 += v35[0];
    if (v20 >= a4) {
      goto LABEL_43;
    }
  }

  if (!a7) {
    goto LABEL_27;
  }
  if (v35[0] + v19 == a7)
  {
    unsigned int v29 = 2;
    goto LABEL_49;
  }

  if ((a2 & 0xC0) == 0 && v35[0] + v19 + 1 != a7)
  {
LABEL_27:
    if ((a2 & 1) == 0)
    {
      unsigned int v29 = 1;
      goto LABEL_49;
    }

    goto LABEL_38;
  }

  unsigned int v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, char *))v16[2];
  if (v25)
  {
    int v32 = a2 & 1;
    if ((a2 & 0xC0) != 0) {
      uint64_t v26 = ((uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, char *))v16[3])( v16,  a2,  a3 + v20,  a4 - v20,  0LL,  0LL,  v34);
    }
    else {
      uint64_t v26 = v25(v16, a2, a3 + v20, a4 - v20, 0LL, 0LL, v34);
    }
  }

  else
  {
    int v32 = a2 & 1;
    uint64_t v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void, void, char *))(*v16 + 8))( a2,  a3 + v20,  a4 - v20,  0LL,  0LL,  v34);
  }

  if (v26) {
    BOOL v27 = 1;
  }
  else {
    BOOL v27 = v32 == 0;
  }
  if (!v27)
  {
LABEL_38:
    v19 += v35[0];
    if (a7) {
      uint64_t v28 = a7 - v19;
    }
    else {
      uint64_t v28 = 0LL;
    }
    v20 += ((uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))v16[5])( a3 + v20,  a4 - v20,  a6 + 2 * v19,  v28,  v35);
    goto LABEL_42;
  }

  if (v26) {
    unsigned int v29 = 2;
  }
  else {
    unsigned int v29 = 1;
  }
LABEL_49:
  v19 += v35[0];
LABEL_50:
  if (v29) {
    BOOL v30 = 0;
  }
  else {
    BOOL v30 = v20 < a4;
  }
  if (!v30 || a7 == 0) {
    uint64_t result = v29;
  }
  else {
    uint64_t result = 2LL;
  }
  if (a8) {
    *a8 = v19;
  }
  if (v33) {
    uint64_t *v33 = v20;
  }
  return result;
}

_OWORD *CFStringEncodingIsValidEncoding(uint64_t a1)
{
  uint64_t result = __CFGetConverter(a1);
  if (result) {
    return (_OWORD *)(*(void *)result != 0LL);
  }
  return result;
}

uint64_t CFStringEncodingCharLengthForBytes(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  v21[1] = *MEMORY[0x1895F89C0];
  int v7 = (uint64_t *)__CFGetConverter(a1);
  if (!v7) {
    return 0LL;
  }
  unsigned int v8 = v7;
  uint64_t v9 = *v7;
  int v10 = *(unsigned __int8 *)(*v7 + 20);
  if (v10 == 4) {
    return __CFStringEncodingPlatformCharLengthForBytes();
  }
  if (v10 == 5) {
    return __CFStringEncodingICUCharLength(v7[1], a2, a3, a4);
  }
  if (*(_WORD *)(v9 + 16) != 1)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v9 + 32);
    if (v12) {
      return v12(a2, a3, a4);
    }
    if (a4 < 1) {
      return 0LL;
    }
    uint64_t v13 = 0LL;
    while (1)
    {
      uint64_t v14 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, void *))v8[2];
      if (v14)
      {
        if ((a2 & 0xC0) != 0) {
          uint64_t v14 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, void, void, void *))v8[3];
        }
        uint64_t v15 = v14(v8, a2, a3, a4, 0LL, 0LL, v21);
      }

      else
      {
        uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void, void, void *))(*v8 + 8))( a2,  a3,  a4,  0LL,  0LL,  v21);
      }

      uint64_t v16 = a4 - v15;
      v13 += v21[0];
      if (v16 < 1 || (a2 & 1) == 0) {
        break;
      }
      unint64_t v18 = a3 + v15;
      uint64_t v19 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v8[5])( v18,  v16,  0LL,  0LL,  v21);
      a3 = v18 + v19;
      v13 += v21[0];
      BOOL v20 = v16 <= v19;
      a4 = v16 - v19;
      if (v20) {
        return v13;
      }
    }

    if (v16 >= 1) {
      return 0LL;
    }
    return v13;
  }

  return a4;
}

uint64_t CFStringEncodingByteLengthForCharacters(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  v13[1] = *MEMORY[0x1895F89C0];
  unsigned int v8 = (uint64_t *)__CFGetConverter(a1);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = *v8;
  int v10 = *(unsigned __int8 *)(*v8 + 20);
  if (v10 == 4) {
    return __CFStringEncodingPlatformByteLengthForCharacters();
  }
  if (v10 == 5) {
    return __CFStringEncodingICUByteLength(v8[1], a2, (unint64_t)a3, a4);
  }
  if (*(_WORD *)(v9 + 16) != 1)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, unsigned __int16 *, uint64_t))(v9 + 24);
    if (v12) {
      return v12(a2, a3, a4);
    }
    else {
      return v13[0];
    }
  }

  return a4;
}

_OWORD *CFStringEncodingRegisterFallbackProcedures( uint64_t a1, uint64_t (*a2)(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5), uint64_t (*a3)(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5))
{
  uint64_t result = __CFGetConverter(a1);
  if (result)
  {
    int v7 = result;
    uint64_t result = __CFGetConverter(a1);
    if (result)
    {
      uint64_t v8 = *(void *)result;
      if (!a2)
      {
        if (v8) {
          a2 = *(uint64_t (**)(unsigned __int16 *, uint64_t, char *, uint64_t, uint64_t *))(v8 + 40);
        }
        else {
          a2 = __CFDefaultToBytesFallbackProc;
        }
      }
    }

    else
    {
      uint64_t v8 = 0LL;
      if (!a2) {
        a2 = __CFDefaultToBytesFallbackProc;
      }
    }

    *((void *)v7 + 4) = a2;
    if (!a3)
    {
      if (v8) {
        a3 = *(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, void *))(v8 + 48);
      }
      else {
        a3 = __CFDefaultToUnicodeFallbackProc;
      }
    }

    *((void *)v7 + 5) = a3;
  }

  return result;
}

uint64_t __CFDefaultToBytesFallbackProc(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unint64_t v8 = *a1;
  if (v8 <= 0x9F)
  {
    char v9 = v8 ^ 0x80;
LABEL_3:
    uint64_t result = 1LL;
LABEL_4:
    if (a4) {
      *a3 = v9;
    }
    uint64_t v11 = 1LL;
    goto LABEL_7;
  }

  if (v8 <= 0xFF)
  {
    if (a4 >= 4 || a4 == 0) {
      uint64_t v13 = 4LL;
    }
    else {
      uint64_t v13 = a4;
    }
    if (v13 < 1)
    {
      uint64_t v14 = 0LL;
    }

    else
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = (char *)&_toLossyASCIITable + 4 * v8 - 640;
      while (v15[v14])
      {
        if (a4) {
          a3[v14] = v15[v14];
        }
        if (v13 == ++v14)
        {
          uint64_t v14 = v13;
          break;
        }
      }
    }

    *a5 = v14;
    return 1LL;
  }

  if (v8 >> 11 == 27)
  {
    char v9 = 63;
    uint64_t result = 1LL;
    if (a2 >= 2 && v8 <= 0xDC00)
    {
      unsigned int v17 = a1[1];
      unsigned int v18 = v17 >> 10;
      BOOL v19 = v17 >= 0xE000;
      uint64_t v20 = 1LL;
      if (!v19) {
        uint64_t v20 = 2LL;
      }
      if (v18 >= 0x37) {
        uint64_t result = v20;
      }
      else {
        uint64_t result = 1LL;
      }
      char v9 = 63;
    }

    goto LABEL_4;
  }

  if ((CFUniCharIsMemberOf(*a1, 2u) & 1) != 0)
  {
    char v9 = 32;
    goto LABEL_3;
  }

  if ((CFUniCharIsMemberOf(*a1, 3u) & 1) != 0)
  {
    char v9 = 10;
    goto LABEL_3;
  }

  int v21 = *a1;
  if (v21 == 8230)
  {
    if (!a4)
    {
      uint64_t result = 1LL;
      uint64_t v11 = 3LL;
LABEL_7:
      *a5 = v11;
      return result;
    }

    if (a4 >= 3)
    {
      a3[2] = 46;
      *(_WORD *)a3 = 11822;
      *a5 = 3LL;
      return 1LL;
    }

uint64_t __CFDefaultToUnicodeFallbackProc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1LL;
  return 1LL;
}

uint64_t CFStringEncodingListOfAvailableEncodings()
{
  v19[1] = *MEMORY[0x1895F89C0];
  uint64_t result = CFStringEncodingListOfAvailableEncodings_encodings;
  if (!CFStringEncodingListOfAvailableEncodings_encodings)
  {
    uint64_t v18 = 0LL;
    v19[0] = 0LL;
    unint64_t ICUEncodings = (unint64_t)__CFStringEncodingCreateICUEncodings(0LL, v19);
    unint64_t v2 = (unint64_t)__CFStringEncodingCreateListOfAvailablePlatformConverters(0LL, &v18);
    if (ICUEncodings | v2)
    {
      uint64_t v3 = (void *)v2;
      uint64_t v4 = v19[0] + v18 + 14;
      BOOL v5 = (__int128 *)CFAllocatorAllocate(0LL, 4 * v4, 0LL);
      char v9 = v5;
      *((void *)v5 + 6) = -3825204992LL;
      __int128 *v5 = __CFBuiltinEncodings;
      v5[1] = unk_180CA37E4;
      v5[2] = xmmword_180CA37F4;
      if (ICUEncodings)
      {
        memcpy((char *)v5 + 56, (const void *)ICUEncodings, 4LL * v19[0]);
        CFAllocatorDeallocate(0LL, (void *)ICUEncodings);
      }

      if (v3)
      {
        memcpy((char *)v9 + 4 * v19[0] + 56, v3, 4 * v18);
        CFAllocatorDeallocate(0LL, v3);
      }

      CFQSortArray(v9, v4, 4LL, (uint64_t)__CFStringEncodingComparator, 0LL, v6, v7, v8);
      if (v4 >= 1)
      {
        int v10 = (int *)v9 + v4;
        int v11 = -1;
        uint64_t v12 = (int *)v9;
        do
        {
          uint64_t v13 = v12 + 1;
          int v14 = *v12;
          if (v11 == *v12)
          {
            if (v13 < v10) {
              memmove(v12, v13, (char *)v10 - (char *)v12 - 4);
            }
            --v10;
          }

          else
          {
            ++v12;
            int v11 = v14;
          }
        }

        while (v12 < v10);
      }

      while (!__ldaxr((unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
      {
        if (!__stlxr((unint64_t)v9, (unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
        {
          char v16 = 1;
          goto LABEL_22;
        }
      }

      char v16 = 0;
      __clrex();
LABEL_22:
      if (v9 != &__CFBuiltinEncodings && (v16 & 1) == 0) {
        CFAllocatorDeallocate(0LL, v9);
      }
    }

    else
    {
      while (!__ldaxr((unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
      {
        if (!__stlxr( (unint64_t)&__CFBuiltinEncodings,  (unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings)) {
          return CFStringEncodingListOfAvailableEncodings_encodings;
        }
      }

      __clrex();
    }

    return CFStringEncodingListOfAvailableEncodings_encodings;
  }

  return result;
}

uint64_t __CFStringEncodingComparator(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2 = (unsigned __int16)*a1;
  uint64_t v3 = *a2;
  uint64_t v4 = *a1 - v3;
  uint64_t v5 = v2 - (unsigned __int16)v3;
  else {
    return v5;
  }
}

uint64_t __CFToBytesCheapEightBitWrapper( unsigned int (***a1)(uint64_t, void, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a6 >= a4 || a6 == 0) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a6;
  }
  if (v9 < 1)
  {
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = 0LL;
    while ((**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), &v17))
    {
      if (a6) {
        *(_BYTE *)(a5 + v15) = v17;
      }
      if (v9 == ++v15)
      {
        uint64_t v15 = v9;
        break;
      }
    }
  }

  *a7 = v15;
  return v15;
}

uint64_t __CFToUnicodeCheapEightBitWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a6 >= a4 || a6 == 0) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a6;
  }
  if (v9 < 1)
  {
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = 0LL;
    while ((*(unsigned int (**)(uint64_t, void, __int16 *))(*(void *)a1 + 8LL))( a2,  *(unsigned __int8 *)(a3 + v15),  &v17))
    {
      if (a6) {
        *(_WORD *)(a5 + 2 * v15) = v17;
      }
      if (v9 == ++v15)
      {
        uint64_t v15 = v9;
        break;
      }
    }
  }

  *a7 = v15;
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapEightBitWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a4 < 1)
  {
    uint64_t v15 = 0LL;
    uint64_t v14 = 0LL;
  }

  else
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    while ((!a6 || v14 < a6)
         && (*(unsigned int (**)(uint64_t, void, unsigned __int16 *))(*(void *)a1 + 8LL))( a2,  *(unsigned __int8 *)(a3 + v15),  &v21))
    {
      if (v21 >= 0x80u && CFUniCharIsMemberOf(v21, 0x65u))
      {
        uint64_t v16 = CFUniCharDecomposeCharacter(v21, v22, 10LL);
        *a7 = v14;
        if (v16 >= 1)
        {
          __int16 v17 = v22;
          do
          {
            unsigned int v18 = *v17;
            unsigned int v19 = *v17 - 0x10000;
            if (*v17 < 0x10000)
            {
              if (v14 >= a6) {
                return v15;
              }
              ++v14;
              *a5++ = v18;
            }

            else
            {
              v14 += 2LL;
              if (v14 > a6) {
                return v15;
              }
              if (a6)
              {
                *__int16 v17 = v19;
                *a5 = (v19 >> 10) - 10240;
                a5[1] = v18 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }

            ++v17;
            --v16;
          }

          while (v16);
        }
      }

      else
      {
        if (a6) {
          *a5++ = v21;
        }
        ++v14;
      }

      if (++v15 == a4)
      {
        uint64_t v15 = a4;
        break;
      }
    }
  }

  *a7 = v14;
  return v15;
}

uint64_t __CFToBytesStandardEightBitWrapper( uint64_t (***a1)(uint64_t, uint64_t, uint64_t, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  *a7 = 0LL;
  if (!a4) {
    return 0LL;
  }
  uint64_t v10 = a4;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  do
  {
    if (a6 && v14 >= a6) {
      break;
    }
    unsigned int v16 = (**a1)(a2, a3, v10, &v18);
    if (!v16) {
      break;
    }
    if (a6) {
      *(_BYTE *)(a5 + *a7) = v18;
    }
    uint64_t v14 = *a7 + 1;
    *a7 = v14;
    a3 += 2LL * v16;
    v15 += v16;
    v10 -= v16;
  }

  while (v10);
  return v15;
}

uint64_t __CFToUnicodeStandardEightBitWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  v18[5] = *MEMORY[0x1895F89C0];
  *a7 = 0LL;
  if (a4 < 1) {
    return 0LL;
  }
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  while (!a6 || v14 < a6)
  {
    unsigned int v16 = (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a1 + 8LL))( a2,  *(unsigned __int8 *)(a3 + v15),  v18);
    if (!v16) {
      break;
    }
    uint64_t v14 = *a7 + v16;
    if (a6)
    {
      if (v14 > a6) {
        return v15;
      }
      memcpy((void *)(a5 + 2LL * *a7), v18, 2LL * v16);
    }

    *a7 = v14;
    if (a4 == ++v15) {
      return a4;
    }
  }

  return v15;
}

uint64_t __CFToCanonicalUnicodeStandardEightBitWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, void *a7)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a4 < 1)
  {
    uint64_t v13 = 0LL;
    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v10 = a3;
    uint64_t v11 = a2;
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    unsigned int v23 = a2;
    while (!a6 || v12 < a6)
    {
      uint64_t v14 = a1;
      unsigned int v15 = (*(uint64_t (**)(uint64_t, void, _WORD *))(*(void *)a1 + 8LL))( v11,  *(unsigned __int8 *)(v10 + v13),  v26);
      if (!v15) {
        break;
      }
      uint64_t v16 = 0LL;
      uint64_t v17 = v15;
      do
      {
        unsigned int v18 = (unsigned __int16)v26[v16];
        if (v18 >= 0x80 && CFUniCharIsMemberOf(v18, 0x65u))
        {
          uint64_t v19 = CFUniCharDecomposeCharacter((unsigned __int16)v26[v16], v27, 10LL);
          *a7 = v12;
          if (v19 >= 1)
          {
            uint64_t v20 = v27;
            do
            {
              unsigned int v21 = *v20++;
              if (v21 < 0x10000)
              {
                if (v12 >= a6) {
                  return v13;
                }
                ++v12;
                *a5++ = v26[v16];
              }

              else
              {
                v12 += 2LL;
                if (v12 > a6) {
                  return v13;
                }
                if (a6)
                {
                  *a5 = (v26[v16] >> 10) | 0xD800;
                  a5[1] = v26[v16] & 0x3FF | 0xDC00;
                  a5 += 2;
                }
              }

              --v19;
            }

            while (v19);
          }
        }

        else
        {
          if (a6) {
            *a5++ = v26[v16];
          }
          ++v12;
        }

        ++v16;
      }

      while (v16 != v17);
      ++v13;
      uint64_t v10 = a3;
      uint64_t v11 = v23;
      a1 = v14;
      if (v13 == a4)
      {
        uint64_t v13 = a4;
        break;
      }
    }
  }

  *a7 = v12;
  return v13;
}

uint64_t __CFToBytesCheapMultiByteWrapper( uint64_t (***a1)(uint64_t, void, _BYTE *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6, int64_t *a7)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  *a7 = 0LL;
  if (a4 < 1) {
    return 0LL;
  }
  int64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  while (!a6 || v14 < a6)
  {
    unsigned int v16 = (**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), v22);
    if (!v16) {
      break;
    }
    if (a6)
    {
      if (*a7 + v16 > a6) {
        return v15;
      }
      uint64_t v17 = v22;
      uint64_t v18 = a5;
      uint64_t v19 = v16;
      do
      {
        char v20 = *v17++;
        *(_BYTE *)(v18 + *a7) = v20;
        ++v18;
        --v19;
      }

      while (v19);
    }

    int64_t v14 = *a7 + v16;
    *a7 = v14;
    if (++v15 == a4) {
      return a4;
    }
  }

  return v15;
}

uint64_t __CFToUnicodeCheapMultiByteWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  *a7 = 0LL;
  if (!a4) {
    return 0LL;
  }
  uint64_t v10 = a4;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  do
  {
    if (a6 && v14 >= a6) {
      break;
    }
    unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)a1 + 8LL))(a2, a3, v10, &v18);
    if (!v16) {
      break;
    }
    if (a6) {
      *a5++ = v18;
    }
    uint64_t v14 = *a7 + 1;
    *a7 = v14;
    v15 += v16;
    a3 += v16;
    v10 -= v16;
  }

  while (v10);
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapMultiByteWrapper( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a4)
  {
    uint64_t v10 = a4;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    do
    {
      if (a6 && v14 >= a6) {
        break;
      }
      unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*(void *)a1 + 8LL))( a2,  a3,  v10,  &v23);
      if (!v16) {
        break;
      }
      unsigned int v17 = v16;
      if (v23 >= 0x80u && CFUniCharIsMemberOf(v23, 0x65u))
      {
        uint64_t v18 = CFUniCharDecomposeCharacter(v23, v24, 10LL);
        *a7 = v14;
        if (v18 >= 1)
        {
          uint64_t v19 = v24;
          do
          {
            unsigned int v20 = *v19;
            unsigned int v21 = *v19 - 0x10000;
            if (*v19 < 0x10000)
            {
              if (v14 >= a6) {
                return v15;
              }
              ++v14;
              *a5++ = v20;
            }

            else
            {
              v14 += 2LL;
              if (v14 > a6) {
                return v15;
              }
              if (a6)
              {
                unsigned int *v19 = v21;
                *a5 = (v21 >> 10) - 10240;
                a5[1] = v20 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }

            ++v19;
            --v18;
          }

          while (v18);
        }
      }

      else
      {
        if (a6) {
          *a5++ = v23;
        }
        ++v14;
      }

      v15 += v17;
      a3 += v17;
      v10 -= v17;
    }

    while (v10);
  }

  else
  {
    uint64_t v15 = 0LL;
    uint64_t v14 = 0LL;
  }

  *a7 = v14;
  return v15;
}

uint64_t _CFStringEncodingSetForceASCIICompatibility(uint64_t result)
{
  __CFWantsToUseASCIICompatibleConversion = (_DWORD)result != 0;
  return result;
}

uint64_t __CFSetCharToUniCharFunc(uint64_t result)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (__CFCharToUniCharFunc != result)
  {
    int v1 = (uint64_t (*)(void, void, __int16 *))result;
    if (result)
    {
      uint64_t result = CFStringEncodingGetConverter(0LL);
      if (result && *(uint64_t (**)(void, void, __int16 *))(result + 8) == v1)
      {
        __CFCharToUniCharTable = (uint64_t)__CFMacRomanCharToUnicharTable;
      }

      else
      {
        __CFCharToUniCharTable = (uint64_t)__CFMutableCharToUniCharTable;
        for (uint64_t i = 128LL; i != 256; ++i)
        {
          uint64_t result = v1(0LL, i, &v4);
          if ((_DWORD)result) {
            __int16 v3 = v4;
          }
          else {
            __int16 v3 = -3;
          }
          __CFMutableCharToUniCharTable[i] = v3;
        }
      }

      __CFCharToUniCharFunc = (uint64_t)v1;
    }

    else
    {
      __CFCharToUniCharTable = (uint64_t)&__CFIdempotentCharToUniCharTable;
    }
  }

  return result;
}

unsigned __int8 *__CFStrConvertBytesToUnicode(unsigned __int8 *result, _WORD *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = __CFCharToUniCharTable;
    do
    {
      unsigned int v4 = *result++;
      *a2++ = *(_WORD *)(v3 + 2LL * v4);
      --a3;
    }

    while (a3);
  }

  return result;
}

uint64_t __CFStringDecodeByteStream2(char *a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, _BYTE *a6)
{
  return __CFStringDecodeByteStream3(a1, a2, a3, a4, a5, a6, 0LL);
}

uint64_t __CFStringDecodeByteStream3( char *a1, CFIndex size, uint64_t a3, int a4, uint64_t a5, _BYTE *a6, uint64_t a7)
{
  CFIndex v12 = size;
  v109[1] = *MEMORY[0x1895F89C0];
  if (a6) {
    *a6 = 0;
  }
  *(void *)(a5 + 24) = 0LL;
  uint64_t v14 = (void *)(a5 + 24);
  BOOL v15 = a4 == 0;
  *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = a4 == 0;
  *(_BYTE *)(a5 + 9) = 0;
  if (!size) {
    return 1LL;
  }
  unsigned int v16 = *(const __CFAllocator **)(a5 + 16);
  if (!v16)
  {
    unsigned int v16 = (const __CFAllocator *)_CFGetTSD(1u);
    if (!v16) {
      unsigned int v16 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  *(void *)(a5 + 16) = v16;
  if ((int)a3 <= 268435711)
  {
    unsigned int v17 = &a1[v12];
    if ((int)a3 <= 134217983)
    {
      if ((_DWORD)a3 != 256)
      {
        if ((_DWORD)a3 == 3071)
        {
          *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = 0;
          uint64_t v18 = *(_WORD **)a5;
          BOOL v20 = (unint64_t)v12 > 0x1F8 || v18 != 0LL;
          *(_BYTE *)(a5 + 9) = v20;
          if (!v18)
          {
            if ((unint64_t)v12 > 0x1F8)
            {
              unsigned int v21 = CFAllocatorAllocate(v16, 2 * v12, 0LL);
              *(void *)a5 = v21;
              if (!v21) {
                goto LABEL_204;
              }
              goto LABEL_105;
            }

            uint64_t v18 = (_WORD *)(a5 + 32);
          }

          *(void *)a5 = v18;
LABEL_105:
          *uint64_t v14 = 0LL;
          if (v12 < 1)
          {
            LOBYTE(v54) = 0;
            goto LABEL_138;
          }

          uint64_t v53 = 0LL;
          int v54 = 0;
          int v55 = 0;
          while (1)
          {
            unsigned int v57 = *a1++;
            unsigned int v56 = v57;
            if (v54 == 1)
            {
              if ((v56 & 0xFFFFFFDF) == 0x55)
              {
                int v55 = 0;
                int v54 = 2;
              }

              else
              {
                int v55 = v56 - 48;
                if (v56 - 48 > 9)
                {
                  if (v56 != 92) {
                    goto LABEL_137;
                  }
                  int v55 = 92;
LABEL_133:
                  int v54 = 0;
                  unsigned int v59 = *(_WORD **)a5;
                  *(void *)(a5 + 24) = v53 + 1;
                  v59[v53++] = v55;
                  goto LABEL_134;
                }

                int v54 = 7;
              }
            }

            else
            {
              if ((_BYTE)v54)
              {
                unsigned int v58 = v56 - 48;
                if ((char)v54 > 5)
                {
                  int v55 = v58 | (8 * v55);
                }

                else
                {
                  if ((v56 - 48) > 9u)
                  {
                    if (v56 > 0x60) {
                      LOBYTE(v56) = v56 - 32;
                    }
                    if ((v56 - 65) > 5u)
                    {
LABEL_137:
                      LOBYTE(v54) = 1;
LABEL_138:
                      BOOL v60 = v54 == 0;
LABEL_139:
                      if (!v60)
                      {
LABEL_204:
                        if (*(_BYTE *)(a5 + 9))
                        {
                          if (*(void *)a5) {
                            CFAllocatorDeallocate(*(CFAllocatorRef *)(a5 + 16), *(void **)a5);
                          }
                        }

                        uint64_t result = 0LL;
                        *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = v15;
                        *(_BYTE *)(a5 + 9) = 0;
                        *(void *)a5 = 0LL;
                        *(void *)(a5 + 24) = 0LL;
                        return result;
                      }

                      return 1LL;
                    }

                    int v55 = (v56 - 55) | (16 * v55);
                  }

                  else
                  {
                    int v55 = v58 | (16 * v55);
                  }
                }
              }

              else
              {
                if (v56 == 92)
                {
                  int v54 = 1;
                  goto LABEL_134;
                }

                int v55 = v56;
                if ((v56 & 0x80) != 0) {
                  goto LABEL_137;
                }
              }

              if (!(_BYTE)v54) {
                goto LABEL_133;
              }
            }

LABEL_203:
            if (!v76) {
              goto LABEL_204;
            }
            return 1LL;
          }

LABEL_202:
          int v76 = 1;
          goto LABEL_203;
        }

        uint64_t v49 = (void *)(a5 + 32);
      }

      *(void *)a5 = v49;
      goto LABEL_186;
    }

    if (v12 >= 1)
    {
      uint64_t v28 = a1;
      CFIndex v29 = v12;
      while (1)
      {
        int v30 = *v28++;
        if (v30 < 0) {
          break;
        }
        if (!--v29) {
          goto LABEL_50;
        }
      }

      *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = 0;
      goto LABEL_91;
    }

LABEL_248:
        *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = 0;
        char v83 = 1;
      }

LABEL_249:
      if (*(_BYTE *)(result + 20) != 1)
      {
        if ((v83 & 1) == 0) {
          goto LABEL_272;
        }
        unint64_t v95 = CFStringEncodingCharLengthForBytes(a3, 0LL, (unint64_t)a1, v12);
        unint64_t v96 = v95;
        int v97 = *(void **)a5;
        if (*(void *)a5) {
          BOOL v98 = 1;
        }
        else {
          BOOL v98 = v95 > 0x1F8;
        }
        char v99 = v98;
        *(_BYTE *)(a5 + 9) = v99;
        if (!v97)
        {
          if (v95 > 0x1F8)
          {
            int v97 = CFAllocatorAllocate(*(CFAllocatorRef *)(a5 + 16), 2 * v95, 0LL);
            *(void *)a5 = v97;
            if (!v97) {
              goto LABEL_204;
            }
LABEL_306:
            if ((__CFStringDecodeByteStream3_lossyFlag & 1) == 0) {
              __CFStringDecodeByteStream3_lossyFlag = 1;
            }
            if (v96 <= 0x1F8) {
              uint64_t v108 = 504LL;
            }
            else {
              uint64_t v108 = v96;
            }
            BOOL v60 = CFStringEncodingBytesToUnicode( a3,  __CFWantsToUseASCIICompatibleConversion,  (unint64_t)a1,  v12,  0LL,  (uint64_t)v97,  v108,  (uint64_t *)(a5 + 24)) == 0;
            goto LABEL_139;
          }

          int v97 = (void *)(a5 + 32);
        }

        *(void *)a5 = v97;
        goto LABEL_306;
      }

      if ((v83 & 1) == 0)
      {
LABEL_272:
        *(void *)(a5 + 24) = v12;
        unsigned int v71 = *(void **)a5;
        BOOL v101 = (unint64_t)v12 > 0x3F0 || v71 != 0LL;
        *(_BYTE *)(a5 + 9) = v101;
        if (!v71)
        {
          if ((unint64_t)v12 > 0x3F0)
          {
            unsigned int v71 = CFAllocatorAllocate(*(CFAllocatorRef *)(a5 + 16), v12, 0LL);
            *(void *)a5 = v71;
            if (!v71) {
              goto LABEL_204;
            }
            goto LABEL_284;
          }

          unsigned int v71 = (void *)(a5 + 32);
        }

        *(void *)a5 = v71;
LABEL_284:
        uint64_t v72 = a1;
        size_t v70 = v12;
        goto LABEL_285;
      }

      __int16 v91 = *(void **)a5;
      BOOL v93 = (unint64_t)v12 > 0x1F8 || v91 != 0LL;
      *(_BYTE *)(a5 + 9) = v93;
      if (v91) {
        goto LABEL_289;
      }
      if ((unint64_t)v12 <= 0x1F8)
      {
        __int16 v91 = (void *)(a5 + 32);
LABEL_289:
        *(void *)a5 = v91;
        goto LABEL_290;
      }

      unsigned int v94 = CFAllocatorAllocate(*(CFAllocatorRef *)(a5 + 16), 2 * v12, 0LL);
      *(void *)a5 = v94;
      if (!v94) {
        goto LABEL_204;
      }
LABEL_290:
      *uint64_t v14 = v12;
      if ((_DWORD)a3 == 513 || (_DWORD)a3 == 1536)
      {
        if (v12 >= 1)
        {
          uint64_t v102 = 0LL;
          uint64_t result = 1LL;
          do
          {
            *(_WORD *)(*(void *)a5 + 2 * v102) = a1[v102];
            ++v102;
          }

          while (v12 != v102);
          return result;
        }

        return 1LL;
      }

      if (v12 < 1) {
        return 1LL;
      }
      uint64_t v103 = 0LL;
      do
      {
        int v105 = *a1++;
        int v104 = v105;
        uint64_t v106 = v105;
        unsigned int v107 = (_WORD *)(*(void *)a5 + v103);
        if (!v82 || v104 < 0)
        {
        }

        else
        {
          *unsigned int v107 = v106;
        }

        v103 += 2LL;
        uint64_t result = 1LL;
        --v12;
      }

      while (v12);
      return result;
  }

    uint64_t v13 = v108;
    goto LABEL_250;
  }

  unsigned int v17 = CFStringGetCharactersPtr(theString);
  if (v17)
  {
    if (v9) {
      uint64_t v18 = v8;
    }
    else {
      uint64_t v18 = 0LL;
    }
    uint64_t v110 = __CFToUTF8(0, (unsigned __int16 *)&v17[location], length, v9, v18, &v111);
LABEL_250:
    if (v13) {
      *uint64_t v13 = v111;
    }
    return v110;
  }

  uint64_t v108 = a8;
LABEL_24:
  __int16 v22 = (_DWORD)a4 == 134217984;
LABEL_25:
  int v23 = v22;
LABEL_28:
  if ((CFStringEncodingIsValidEncoding(a4) & 1) != 0)
  {
    if (v23)
    {
      BOOL v24 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        BOOL v24 = __CFDefaultEightBitStringEncoding;
      }

      int v25 = CFStringGetCStringPtr(theString, v24);
      if (v25)
      {
        uint64_t v26 = (const unsigned __int8 *)&v25[location];
        uint64_t v27 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          int v104 = v23;
          uint64_t v28 = &v25[location];
          __CFStringComputeEightBitStringEncoding();
          uint64_t v26 = (const unsigned __int8 *)v28;
          int v23 = v104;
          uint64_t v27 = __CFDefaultEightBitStringEncoding;
        }

        if (v27 != (_DWORD)a4)
        {
          if (v8 >= length) {
            CFIndex v29 = length;
          }
          else {
            CFIndex v29 = v8;
          }
          int v30 = length - v29;
          if (v9) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = 0LL;
          }
          if ((*(char *)v26 & 0x80000000) == 0 && v31 < length)
          {
            int v32 = v26;
            do
            {
              BOOL v33 = *(char *)++v32;
              --length;
            }

            while ((v33 & 0x80000000) == 0 && length > v31);
            goto LABEL_188;
          }

            format = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'";
            unint64_t v37 = v10 + 1;
            goto LABEL_250;
          }

          uint64_t v144 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'; exceeded maximum nesting depth %d";
          unint64_t v37 = v10 + 1;
        }

        else
        {
          uint64_t v5 = v149;
          if (v36 != 63) {
            goto LABEL_75;
          }
          *((_WORD *)v8 + 17) |= 0x8000u;
          unint64_t v37 = v10 + 2;
          uint64_t v157 = (unint64_t)(v10 + 2);
          uint64_t v154 = v34 + 2;
          v34[1] = *v13;
          uint64_t v5 = v149;
          if (*v37 != 60) {
            goto LABEL_75;
          }
          int v38 = v10 + 3;
          uint64_t v157 = (unint64_t)(v10 + 3);
          uint64_t v39 = v34 + 3;
          v34[2] = 60;
          if (a4 <= 0x3FF)
          {
            int v40 = *v38;
            if (*v38)
            {
              unsigned int v41 = 0LL;
              uint64_t v42 = 0LL;
              do
              {
                if (v40 == 62)
                {
                  if (!v42)
                  {
                    char v99 = v39;
                    if ((unint64_t)(v41 + 3) >= 4)
                    {
                      char v100 = 0LL;
                      BOOL v101 = 0LL;
                      char v99 = v39;
                      while (1)
                      {
                        __NSGetSizeAndAlignment(v38, v161, &v160, (uint64_t)v38, 1LL, 0LL, 1uLL);
                        uint64_t v102 = v160;
                        if (!v160)
                        {
                          BOOL v160 = 1LL;
                          uint64_t v102 = 1LL;
                        }

                        uint64_t v103 = (v102 + v100 - 1) / v102 * v102;
                        int v104 = parseFrameArgumentInfo(&v157, v103 + a2, 1LL, v152);
                        unsigned int v111 = v104;
                        if (!v104) {
                          break;
                        }
                        unsigned int v112 = v161[0];
                        if (v161[0] != *(_DWORD *)(v104 + 16))
                        {
                          unsigned __int16 v142 = v104 + 37;
                          int64_t v143 = *(unsigned int *)(v104 + 16);
                          CFLog( 4LL,  (uint64_t)@"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)",  v105,  v106,  v107,  v108,  v109,  v110,  v161[0]);
                          unsigned int v112 = *(unsigned int *)(v111 + 16);
                        }

                        LOBYTE(v113) = *(_BYTE *)(v111 + 37);
                        if ((_BYTE)v113)
                        {
                          uint64_t v114 = 0LL;
                          do
                          {
                            v99[v114] = v113;
                            unsigned int v113 = *(unsigned __int8 *)(v111 + v114++ + 38);
                          }

                          while (v113);
                          v99 += v114;
                        }

                        if (!*v8) {
                          uint64_t *v8 = v111;
                        }
                        if (v101) {
                          *(void *)(v101 + _Block_object_dispose(va, 8) = v111;
                        }
                        char v100 = v112 + v103;
                        int v38 = (_BYTE *)v157;
                        BOOL v101 = v111;
                      }

CFIndex __CFStringEncodeByteStream( CFStringRef theString, CFRange range, int a3, uint64_t a4, unsigned int a5, UniChar *buffer, uint64_t a7, int64_t *a8)
{
  uint64_t v8 = a7;
  uint64_t v9 = buffer;
  uint64_t length = range.length;
  CFIndex location = range.location;
  uint64_t v13 = a8;
  uint64_t v121 = *MEMORY[0x1895F89C0];
  CFIndex v110 = 0LL;
  uint64_t v111 = 0LL;
  if ((_DWORD)a4 == 3071)
  {
    CFStringRef theStringa = theString;
    CFRange v117 = range;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    uint64_t v108 = a8;
    if (CharactersPtr) {
      CStringPtr = 0LL;
    }
    else {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    CFIndex v118 = 0LL;
    CFIndex v119 = 0LL;
    uint64_t v116 = CStringPtr;
    if (length < 1) {
      goto LABEL_249;
    }
    uint64_t v34 = 0LL;
    CFIndex v35 = 0LL;
    CFIndex v105 = 0LL;
    CFIndex v36 = 0LL;
    uint64_t v37 = 64LL;
    while (1)
    {
      else {
        uint64_t v38 = v36;
      }
      CFIndex v39 = v117.length;
      if (v117.length <= v36)
      {
        unsigned int v41 = 0;
        LOBYTE(v42) = 0;
      }

      else
      {
        if (CharactersPtr)
        {
          UniChar v40 = CharactersPtr[v36 + v117.location];
        }

        else if (v116)
        {
          UniChar v40 = v116[v117.location + v36];
        }

        else
        {
          BOOL v44 = v119 > v36 && v105 <= v36;
          if (!v44)
          {
            uint64_t v45 = -v38;
            uint64_t v46 = v38 + v34;
            CFIndex v47 = v37 - v38;
            CFIndex v48 = v36 + v45;
            CFIndex v49 = v48 + 64;
            if (v48 + 64 >= v117.length) {
              CFIndex v49 = v117.length;
            }
            CFIndex v118 = v48;
            CFIndex v119 = v49;
            if (v117.length >= v47) {
              CFIndex v39 = v47;
            }
            v122.uint64_t length = v39 + v46;
            v122.CFIndex location = v48 + v117.location;
            CFStringGetCharacters(theStringa, v122, buffera);
            CFIndex v35 = v118;
          }

          UniChar v40 = buffera[v36 - v35];
          CFIndex v105 = v35;
        }

        unsigned int v41 = v40;
        BOOL v50 = (unsigned __int16)(v40 - 32) >= 0x5Fu || v40 == 92;
        if (!v50 || (v40 <= 0xDu ? (BOOL v51 = ((1 << v40) & 0x2600) == 0) : (BOOL v51 = 1), !v51))
        {
          size_t v43 = 1LL;
          goto LABEL_81;
        }

        if (v40 == 92)
        {
          LOBYTE(v41) = 92;
          BYTE1(__src) = 92;
          size_t v43 = 2LL;
          goto LABEL_81;
        }

        if (v40 > 0xFFu)
        {
          BYTE2(__src) = a0123456789abcd[(unint64_t)v40 >> 12];
          char v53 = a0123456789abcd[((unint64_t)v40 >> 8) & 0xF];
          BYTE1(__src) = 117;
          BYTE3(__src) = v53;
          BYTE4(__src) = a0123456789abcd[v41 >> 4];
          BYTE5(__src) = a0123456789abcd[v41 & 0xF];
          LOBYTE(v41) = 92;
          size_t v43 = 6LL;
          goto LABEL_81;
        }

        int v42 = v40 >> 6;
      }

      BYTE1(__src) = v42 + 48;
      BYTE2(__src) = (v41 >> 3) & 7 | 0x30;
      BYTE3(__src) = v41 & 7 | 0x30;
      LOBYTE(v41) = 92;
      size_t v43 = 4LL;
LABEL_81:
      LOBYTE(__src) = v41;
      uint64_t v52 = v111 + v43;
      if (v9)
      {
        if (v52 > v8) {
          goto LABEL_249;
        }
        memcpy((char *)v9 + v111, &__src, v43);
      }

      CFIndex v110 = ++v36;
      uint64_t v111 = v52;
      --v34;
      ++v37;
      if (v36 >= length) {
        goto LABEL_249;
      }
    }
  }

  if ((_DWORD)a4 != 134217984)
  {
    if ((_DWORD)a4 == 256 || (_DWORD)a4 == 335544576 || (_DWORD)a4 == 268435712)
    {
      uint64_t v20 = 2LL;
      if (a3 == 0 || (_DWORD)a4 != 256) {
        uint64_t v20 = 0LL;
      }
      CFIndex v110 = range.length;
      uint64_t v21 = v20 + 2 * range.length;
      if (buffer)
      {
        if (v21 > a7)
        {
          if (a7 <= v20) {
            uint64_t length = 0LL;
          }
          else {
            uint64_t length = (unint64_t)(a7 - v20) >> 1;
          }
          CFIndex v110 = length;
          uint64_t v21 = v20 + 2 * length;
        }

        uint64_t v111 = v21;
        if (a3 != 0 && (_DWORD)a4 == 256)
        {
          *UniChar buffer = -257;
          range.uint64_t length = length;
          CFStringGetCharacters(theString, range, buffer + 1);
        }

        else
        {
          range.uint64_t length = length;
          CFStringGetCharacters(theString, range, buffer);
          if ((_DWORD)a4 == 268435712 && length >= 1)
          {
            int v54 = &v9[length];
            do
            {
              *uint64_t v9 = bswap32(*v9) >> 16;
              ++v9;
            }

            while (v9 < v54);
          }
        }
      }

      else
      {
        uint64_t v111 = v20 + 2 * range.length;
      }

      goto LABEL_250;
    }

    uint64_t v108 = a8;
    if ((_DWORD)a4 != 201326848 && (_DWORD)a4 != 469762304 && (_DWORD)a4 != 402653440)
    {
      unsigned int v23 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          unsigned int v23 = 0;
          goto LABEL_28;
        case 1:
          goto LABEL_24;
        case 2:
          unsigned int v23 = a4 != 518;
          goto LABEL_28;
        case 6:
          BOOL v22 = (_DWORD)a4 == 1536;
          goto LABEL_25;
        case 8:
        case 0xC:
          goto LABEL_28;
        case 0xA:
          if ((a4 - 2561) >= 0x10) {
LABEL_263:
          }
            unsigned int v23 = 1;
          else {
            unsigned int v23 = (0x7FEEu >> (a4 - 1)) & 1;
          }
          goto LABEL_28;
        case 0xB:
          BOOL v100 = __CFADD__(a4 - 3061, 2);
          goto LABEL_260;
        default:
          BOOL v100 = ((unsigned __int16)a4 & 0xFF00u) >= 0xC01;
LABEL_260:
          unsigned int v23 = !v100;
          break;
      }

      goto LABEL_28;
    }

    if (a3)
    {
      if ((_DWORD)a4 == 201326848)
      {
        uint64_t v111 = 4LL;
        if (buffer)
        {
          if (a7 > 3)
          {
            *(_DWORD *)UniChar buffer = 65279;
            uint64_t v9 = buffer + 2;
          }

          else
          {
            uint64_t v111 = 0LL;
          }
        }
      }
    }

    CFStringRef theStringa = theString;
    CFRange v117 = range;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    if (CharactersPtr) {
      unint64_t v62 = 0LL;
    }
    else {
      unint64_t v62 = CFStringGetCStringPtr(theString, 0x600u);
    }
    CFIndex v118 = 0LL;
    CFIndex v119 = 0LL;
    uint64_t v116 = v62;
    if (length >= 1)
    {
      for (CFIndex i = 0LL; i < length; v110 = i)
      {
        CFIndex v64 = v117.length;
        if (v117.length <= i)
        {
          unsigned int v66 = 0;
        }

        else
        {
          if (CharactersPtr)
          {
            UniChar v65 = CharactersPtr[v117.location + i];
          }

          else if (v116)
          {
            UniChar v65 = v116[v117.location + i];
          }

          else
          {
            CFIndex v67 = v118;
            if (v119 <= i || v118 > i)
            {
              CFIndex v69 = i - 4;
              if (v69 + 64 < v117.length) {
                CFIndex v64 = v69 + 64;
              }
              CFIndex v118 = v69;
              CFIndex v119 = v64;
              v123.CFIndex location = v117.location + v69;
              v123.uint64_t length = v64 - v69;
              CFStringGetCharacters(theStringa, v123, buffera);
              CFIndex v67 = v118;
            }

            UniChar v65 = buffera[i - v67];
          }

          if ((v65 & 0xFC00) == 0xDC00)
          {
LABEL_169:
            unsigned int v66 = a5;
            if (!a5) {
              break;
            }
            goto LABEL_170;
          }

          unsigned int v66 = v65;
          if ((v65 & 0xFC00) == 0xD800)
          {
            CFIndex v70 = i + 1;
            if (i + 1 >= length) {
              goto LABEL_169;
            }
            CFIndex v71 = v117.length;
            if (v117.length <= v70) {
              goto LABEL_169;
            }
            if (CharactersPtr)
            {
              UniChar v72 = CharactersPtr[v117.location + v70];
            }

            else if (v116)
            {
              UniChar v72 = v116[v117.location + v70];
            }

            else
            {
              if (v119 <= v70 || (CFIndex v73 = v118, v118 > v70))
              {
                CFIndex v74 = i - 3;
                if (v74 + 64 < v117.length) {
                  CFIndex v71 = v74 + 64;
                }
                CFIndex v118 = v74;
                CFIndex v119 = v71;
                v124.CFIndex location = v117.location + v74;
                v124.uint64_t length = v71 - v74;
                CFStringGetCharacters(theStringa, v124, buffera);
                CFIndex v73 = v118;
              }

              UniChar v72 = buffera[v70 - v73];
            }

            if (v72 >> 10 != 55) {
              goto LABEL_169;
            }
            unsigned int v66 = (v66 << 10) + v72 - 56613888;
          }
        }

LABEL_126:
  int64_t v60 = 0LL;
LABEL_127:
  if (v108) {
    *uint64_t v108 = v60;
  }
  return v60;
}

                    int v42 = (unint64_t)&v10[v15 + 1];
                    size_t v43 = v38 * a7;
                    BOOL v44 = (_BYTE *)__NSGetSizeAndAlignment(result, v74, &v73, a4, a5, a6 + 1, v38 * a7);
                    uint64_t v45 = v74[0];
                    if (v74[0])
                    {
                      if (v44 && (unint64_t)v44 <= v42 && *v44 == 93)
                      {
                        uint64_t v46 = v73;
                        if (a3) {
                          *a3 = v73;
                        }
                        uint64_t result = v44 + 1;
                        if (!v46)
                        {
                          uint64_t v46 = 1LL;
                          CFIndex v73 = 1LL;
                        }

                        if (!a2) {
                          goto LABEL_46;
                        }
                        if (__CFADD__(v46, v45)
                          || (CFIndex v47 = (v46 + v45 - 1) / v46 * v46, v38 > 0xFFFFFFFFFFFFFFFFLL / v47))
                        {
                          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): array too large at '%s' in '%s'",  v9,  a4);
                          CFIndex v67 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                          objc_exception_throw(v67);
                        }

                        else
                        {
                          if (v43 <= 0xFFFFFFFFFFFFFFFFLL / v47)
                          {
                            uint64_t v13 = v47 * v38;
LABEL_45:
                            *a2 = v13;
                            goto LABEL_46;
                          }

                          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): cumulative nested array has reached ridiculous size at '%s' in '%s'",  v9,  a4);
                          uint64_t v68 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                          objc_exception_throw(v68);
                        }
                      }

                      else
                      {
                        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'",  v9,  a4);
                        CFIndex v64 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                        objc_exception_throw(v64);
                      }
                    }

                    else
                    {
                      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed array spec or array too large at '%s' in '%s'",  v9,  a4);
                      unsigned int v66 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                      objc_exception_throw(v66);
                    }

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  CFStringEncoding v4 = CFStringFileSystemEncoding();
  return CFStringCreateWithCString(alloc, buffer, v4);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  CFIndex Length = CFStringGetLength(string);
  CFStringEncoding FastestEncoding = CFStringGetFastestEncoding(string);
  if (FastestEncoding != 1536 && FastestEncoding)
  {
    BOOL v4 = Length <= 0xE38E38E38E38E38LL;
    uint64_t v5 = 9 * Length;
  }

  else
  {
    BOOL v4 = Length <= 0x2AAAAAAAAAAAAAAALL;
    uint64_t v5 = 3 * Length;
  }

  if (v4) {
    return v5 + 1;
  }
  else {
    return -1LL;
  }
}

uint64_t _CFStringGetUserDefaultEncoding(_DWORD *a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v4 = _CFGetEUID();
  uint64_t v5 = __CFgetenv("__CF_USER_TEXT_ENCODING");
  uint64_t v9 = v5;
  if (v5)
  {
    if (strtol_l(v5, &v9, 0, 0LL) == v4 && *v9 == 58)
    {
      uint64_t v6 = ++v9;
      goto LABEL_8;
    }

    uint64_t v9 = 0LL;
  }

  if (v4 < 1) {
    goto LABEL_14;
  }
  snprintf(__str, 0x20uLL, "0x%X:0:0", v4);
  setenv("__CF_USER_TEXT_ENCODING", __str, 1);
  uint64_t v6 = v9;
  if (!v9) {
    goto LABEL_14;
  }
LABEL_8:
  uint64_t result = strtol_l(v6, &v9, 0, 0LL);
  if ((result & 0xFFFFFFFE) == 4) {
    int v8 = 0;
  }
  else {
    int v8 = result;
  }
  *a1 = v8;
  if (*v9 != 58)
  {
LABEL_14:
    uint64_t result = 0LL;
    *a1 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_15;
  }

  if (!a2) {
    return result;
  }
  uint64_t result = strtol_l(++v9, 0LL, 0, 0LL);
LABEL_15:
  *a2 = result;
  return result;
}

uint64_t _CFStringGetInstallationEncodingAndRegion(_DWORD *a1, _DWORD *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  *a1 = 0;
  *a2 = 0;
  uint64_t result = (uint64_t)getpwuid(0);
  if (result)
  {
    __strlcpy_chk();
    __strlcat_chk();
    if (__CFProphylacticAutofsAccess) {
      int v5 = open("/dev/autofs_nowait", 0);
    }
    else {
      int v5 = -1;
    }
    uint64_t result = open(v10, 0, 0LL);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v7 = 0LL;
    }

    else
    {
      int v6 = result;
      uint64_t v7 = v11;
      ssize_t v8 = read(result, v11, 0x3FuLL);
      v11[v8 & ~(v8 >> 63)] = 0;
      uint64_t result = close(v6);
      uint64_t v9 = v11;
    }

    if (v5 != -1) {
      uint64_t result = close(v5);
    }
    if (v7)
    {
      uint64_t result = strtol_l(v7, &v9, 0, 0LL);
      *a1 = result;
      if (*v9 == 58)
      {
        uint64_t result = strtol_l(++v9, 0LL, 0, 0LL);
        *a2 = result;
      }
    }
  }

  return result;
}

BOOL _CFStringSaveUserDefaultEncoding(int a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uid_t v4 = getuid();
  if (!getpwuid(v4)) {
    return 0LL;
  }
  if (!issetugid()) {
    __CFgetenv("CFFIXED_USER_HOME");
  }
  __strlcpy_chk();
  __strlcat_chk();
  if (__CFProphylacticAutofsAccess) {
    int v5 = open("/dev/autofs_nowait", 0);
  }
  else {
    int v5 = -1;
  }
  unlink(v15);
  int v7 = open(v15, 513, 256LL);
  if (v7 < 0)
  {
    BOOL v6 = 0LL;
  }

  else
  {
    int v8 = v7;
    if ((a1 & 0xFFFFFFFE) == 4) {
      int v9 = 0;
    }
    else {
      int v9 = a1;
    }
    unsigned int v10 = snprintf(__str, 0x40uLL, "0x%X:0x%X", v9, a2);
    BOOL v6 = 0LL;
    if (v10 <= 0x40) {
      BOOL v6 = v10 <= (unint64_t)(int)write(v8, __str, v10);
    }
    int v11 = *__error();
    close(v8);
    *__error() = v11;
  }

  int v12 = *__error();
  if (v5 != -1) {
    close(v5);
  }
  *__error() = v12;
  return v6;
}

uint64_t __CFStringScanInteger(UniChar *buffer, uint64_t a2, int *a3, int a4, uint64_t *a5)
{
  int v9 = *a3;
  if ((*a3 & 0x80000000) == 0) {
    goto LABEL_4;
  }
LABEL_17:
  UniChar v13 = -1;
  while (v13 == 12288
       || (unsigned __int16)(v13 - 0x2000) < 0xCu
       || v13 < 0x21u
       || (unsigned __int16)(v13 - 127) <= 0x21u)
  {
    int v9 = *a3 + 1;
    *a3 = v9;
    if (v9 < 0) {
      goto LABEL_17;
    }
LABEL_4:
    uint64_t v10 = v9;
    uint64_t v11 = *((void *)buffer + 20);
    if (v11 <= v10) {
      goto LABEL_17;
    }
    uint64_t v12 = *((void *)buffer + 17);
    if (v12)
    {
      UniChar v13 = *(_WORD *)(v12 + 2 * (*((void *)buffer + 19) + v10));
    }

    else
    {
      uint64_t v14 = *((void *)buffer + 18);
      if (v14)
      {
        UniChar v13 = *(char *)(v14 + *((void *)buffer + 19) + v10);
      }

      else
      {
        if (*((void *)buffer + 22) <= v10 || (uint64_t v15 = *((void *)buffer + 21), v15 > v10))
        {
          uint64_t v16 = v10 - 4;
          if (v16 + 64 < v11) {
            uint64_t v11 = v16 + 64;
          }
          *((void *)buffer + 21) = v16;
          *((void *)buffer + 22) = v11;
          v66.CFIndex location = *((void *)buffer + 19) + v16;
          v66.uint64_t length = v11 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v66, buffer);
          uint64_t v15 = *((void *)buffer + 21);
        }

        UniChar v13 = buffer[v10 - v15];
      }
    }
  }

  if (v13 == 45 || v13 == 43)
  {
    do
    {
      uint64_t v23 = *a3;
      uint64_t v24 = v23 + 1;
      *a3 = v23 + 1;
      if ((int)v23 < -1 || (uint64_t v22 = *((void *)buffer + 20), v22 <= v24))
      {
        UniChar v19 = -1;
      }

      else
      {
        uint64_t v25 = *((void *)buffer + 17);
        if (v25)
        {
          UniChar v19 = *(_WORD *)(v25 + 2 * (*((void *)buffer + 19) + v24));
        }

        else
        {
          uint64_t v18 = *((void *)buffer + 18);
          if (v18)
          {
            UniChar v19 = *(char *)(v18 + *((void *)buffer + 19) + v24);
          }

          else
          {
            if (*((void *)buffer + 22) <= v24 || (uint64_t v20 = *((void *)buffer + 21), v20 > v24))
            {
              uint64_t v21 = v24 - 4;
              if (v21 + 64 < v22) {
                uint64_t v22 = v21 + 64;
              }
              *((void *)buffer + 21) = v21;
              *((void *)buffer + 22) = v22;
              v67.CFIndex location = *((void *)buffer + 19) + v21;
              v67.uint64_t length = v22 - v21;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v67, buffer);
              uint64_t v20 = *((void *)buffer + 21);
            }

            UniChar v19 = buffer[v24 - v20];
          }
        }
      }
    }

    while (v19 == 12288
         || (unsigned __int16)(v19 - 0x2000) < 0xCu
         || v19 < 0x21u
         || (unsigned __int16)(v19 - 127) < 0x22u);
    BOOL v17 = v13 == 45;
    UniChar v13 = v19;
  }

  else
  {
    BOOL v17 = 0;
  }

  int v65 = a4;
  int v27 = 0;
  int v28 = 0;
  uint64_t v29 = 0LL;
  while (1)
  {
    if (v27)
    {
      if (v29 > 0xCCCCCCCCCCCCCCBLL && (v29 != 0xCCCCCCCCCCCCCCCLL || v13 - v17 - 48 >= 7))
      {
        if (v17) {
          uint64_t v29 = 0x8000000000000000LL;
        }
        else {
          uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
        }
        while (1)
        {
          uint64_t v30 = *a3;
          uint64_t v31 = v30 + 1;
          *a3 = v30 + 1;
          uint64_t v32 = *((void *)buffer + 20);
          if (v32 <= v31) {
            break;
          }
          uint64_t v33 = *((void *)buffer + 17);
          if (v33)
          {
            UniChar v13 = *(_WORD *)(v33 + 2 * (*((void *)buffer + 19) + v31));
          }

          else
          {
            uint64_t v34 = *((void *)buffer + 18);
            if (v34)
            {
              UniChar v13 = *(char *)(v34 + *((void *)buffer + 19) + v31);
            }

            else
            {
              if (*((void *)buffer + 22) <= v31 || (uint64_t v35 = *((void *)buffer + 21), v35 > v31))
              {
                uint64_t v36 = v31 - 4;
                if (v36 + 64 < v32) {
                  uint64_t v32 = v36 + 64;
                }
                *((void *)buffer + 21) = v36;
                *((void *)buffer + 22) = v32;
                v68.CFIndex location = *((void *)buffer + 19) + v36;
                v68.uint64_t length = v32 - v36;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v68, buffer);
                uint64_t v35 = *((void *)buffer + 21);
              }

              UniChar v13 = buffer[v31 - v35];
            }
          }

          if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
          {
            int v37 = 0;
            BOOL v17 = 0;
            goto LABEL_122;
          }
        }

        BOOL v17 = 0;
LABEL_135:
        int v37 = 0;
LABEL_136:
        if (!a5) {
          return 1LL;
        }
        goto LABEL_137;
      }

      uint64_t v29 = 10 * v29 + v13 - 48;
      uint64_t v38 = *a3;
      uint64_t v39 = v38 + 1;
      *a3 = v38 + 1;
      uint64_t v40 = *((void *)buffer + 20);
      if (v40 <= v39) {
        goto LABEL_135;
      }
      uint64_t v41 = *((void *)buffer + 17);
      if (v41)
      {
        int v37 = 0;
        UniChar v13 = *(_WORD *)(v41 + 2 * (*((void *)buffer + 19) + v39));
      }

      else
      {
        uint64_t v50 = *((void *)buffer + 18);
        if (v50)
        {
          int v37 = 0;
          UniChar v13 = *(char *)(v50 + *((void *)buffer + 19) + v39);
        }

        else
        {
          if (*((void *)buffer + 22) <= v39 || (uint64_t v59 = *((void *)buffer + 21), v59 > v39))
          {
            uint64_t v60 = v39 - 4;
            if (v60 + 64 < v40) {
              uint64_t v40 = v60 + 64;
            }
            *((void *)buffer + 21) = v60;
            *((void *)buffer + 22) = v40;
            v70.CFIndex location = *((void *)buffer + 19) + v60;
            v70.uint64_t length = v40 - v60;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v70, buffer);
            uint64_t v59 = *((void *)buffer + 21);
          }

          int v37 = 0;
          UniChar v13 = buffer[v39 - v59];
        }
      }

      goto LABEL_122;
    }

    if (v28 > 214748363) {
      break;
    }
    unsigned __int16 v42 = v13 - 48;
    int v43 = v13 - 48;
LABEL_84:
    if (v42 >= 0xAu) {
      int v45 = -1;
    }
    else {
      int v45 = v43;
    }
    int v28 = v45 + 10 * v28;
    uint64_t v46 = *a3;
    uint64_t v47 = v46 + 1;
    *a3 = v46 + 1;
    uint64_t v48 = *((void *)buffer + 20);
    if (v48 <= v47) {
      goto LABEL_149;
    }
    uint64_t v49 = *((void *)buffer + 17);
    if (v49)
    {
      int v27 = 0;
      UniChar v13 = *(_WORD *)(v49 + 2 * (*((void *)buffer + 19) + v47));
    }

    else
    {
      uint64_t v51 = *((void *)buffer + 18);
      if (v51)
      {
        int v27 = 0;
        UniChar v13 = *(char *)(v51 + *((void *)buffer + 19) + v47);
      }

      else
      {
        if (*((void *)buffer + 22) <= v47 || (uint64_t v61 = *((void *)buffer + 21), v61 > v47))
        {
          uint64_t v62 = v47 - 4;
          if (v62 + 64 < v48) {
            uint64_t v48 = v62 + 64;
          }
          *((void *)buffer + 21) = v62;
          *((void *)buffer + 22) = v48;
          v71.CFIndex location = *((void *)buffer + 19) + v62;
          v71.uint64_t length = v48 - v62;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v71, buffer);
          uint64_t v61 = *((void *)buffer + 21);
        }

        int v27 = 0;
        UniChar v13 = buffer[v47 - v61];
      }
    }

    int v37 = 1;
LABEL_132:
  }

  if (v28 == 214748364)
  {
    unsigned __int16 v42 = v13 - 48;
    int v43 = v13 - 48;
    int v44 = (unsigned __int16)(v13 - 48) >= 0xAu ? -1 : v13 - 48;
    if (v44 - v17 < 7) {
      goto LABEL_84;
    }
  }

  if (v65)
  {
    int v37 = 0;
    uint64_t v29 = v28;
LABEL_122:
    int v27 = 1;
    goto LABEL_132;
  }

  if (v17) {
    int v28 = 0x80000000;
  }
  else {
    int v28 = 0x7FFFFFFF;
  }
  while (1)
  {
    uint64_t v52 = *a3;
    uint64_t v53 = v52 + 1;
    *a3 = v52 + 1;
    uint64_t v54 = *((void *)buffer + 20);
    if (v54 <= v53) {
      break;
    }
    uint64_t v55 = *((void *)buffer + 17);
    if (v55)
    {
      UniChar v13 = *(_WORD *)(v55 + 2 * (*((void *)buffer + 19) + v53));
    }

    else
    {
      uint64_t v56 = *((void *)buffer + 18);
      if (v56)
      {
        UniChar v13 = *(char *)(v56 + *((void *)buffer + 19) + v53);
      }

      else
      {
        if (*((void *)buffer + 22) <= v53 || (uint64_t v57 = *((void *)buffer + 21), v57 > v53))
        {
          uint64_t v58 = v53 - 4;
          if (v58 + 64 < v54) {
            uint64_t v54 = v58 + 64;
          }
          *((void *)buffer + 21) = v58;
          *((void *)buffer + 22) = v54;
          v69.CFIndex location = *((void *)buffer + 19) + v58;
          v69.uint64_t length = v54 - v58;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v69, buffer);
          uint64_t v57 = *((void *)buffer + 21);
        }

        UniChar v13 = buffer[v53 - v57];
      }
    }

    int v37 = 1;
    if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
    {
      int v27 = 0;
      BOOL v17 = 0;
      goto LABEL_132;
    }
  }

  BOOL v17 = 0;
LABEL_149:
  int v37 = 1;
  if (!a5) {
    return 1LL;
  }
LABEL_137:
  if (v65)
  {
    if (v37) {
      uint64_t v63 = v28;
    }
    else {
      uint64_t v63 = v29;
    }
    if (v17) {
      uint64_t v63 = -v63;
    }
    *a5 = v63;
  }

  else
  {
    if (v17) {
      int v64 = -v28;
    }
    else {
      int v64 = v28;
    }
    *(_DWORD *)a5 = v64;
  }

  return 1LL;
}

uint64_t __CFStringScanHex(UniChar *buffer, int *a2, unsigned int *a3)
{
  int v6 = *a2;
  if (*a2 < 0) {
    goto LABEL_5;
  }
LABEL_2:
  uint64_t v7 = v6;
  uint64_t v8 = *((void *)buffer + 20);
  if (v8 > v7)
  {
    uint64_t v9 = *((void *)buffer + 17);
    if (v9)
    {
      UniChar v10 = *(_WORD *)(v9 + 2 * (*((void *)buffer + 19) + v7));
    }

    else
    {
      uint64_t v11 = *((void *)buffer + 18);
      if (v11)
      {
        UniChar v10 = *(char *)(v11 + *((void *)buffer + 19) + v7);
      }

      else
      {
        if (*((void *)buffer + 22) <= v7 || (uint64_t v12 = *((void *)buffer + 21), v12 > v7))
        {
          uint64_t v13 = v7 - 4;
          if (v13 + 64 < v8) {
            uint64_t v8 = v13 + 64;
          }
          *((void *)buffer + 21) = v13;
          *((void *)buffer + 22) = v8;
          v41.CFIndex location = *((void *)buffer + 19) + v13;
          v41.uint64_t length = v8 - v13;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v41, buffer);
          uint64_t v12 = *((void *)buffer + 21);
        }

        UniChar v10 = buffer[v7 - v12];
      }
    }

    goto LABEL_6;
  }

LABEL_93:
  --*a2;
  if (a3)
  {
    unsigned int v20 = 0;
LABEL_95:
    *a3 = v20;
  }

  return 1LL;
}

uint64_t __CFStringScanDouble(UniChar *buffer, uint64_t a2, int *a3, double *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  int v7 = *a3;
  if (*a3 < 0) {
    goto LABEL_5;
  }
LABEL_2:
  uint64_t v8 = v7;
  uint64_t v9 = *((void *)buffer + 20);
  if (v9 > v8)
  {
    uint64_t v10 = *((void *)buffer + 17);
    if (v10)
    {
      UniChar v11 = *(_WORD *)(v10 + 2 * (*((void *)buffer + 19) + v8));
    }

    else
    {
      uint64_t v12 = *((void *)buffer + 18);
      if (v12)
      {
        UniChar v11 = *(char *)(v12 + *((void *)buffer + 19) + v8);
      }

      else
      {
        if (*((void *)buffer + 22) <= v8 || (uint64_t v13 = *((void *)buffer + 21), v13 > v8))
        {
          uint64_t v14 = v8 - 4;
          if (v14 + 64 < v9) {
            uint64_t v9 = v14 + 64;
          }
          *((void *)buffer + 21) = v14;
          *((void *)buffer + 22) = v9;
          v34.CFIndex location = *((void *)buffer + 19) + v14;
          v34.uint64_t length = v9 - v14;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
          uint64_t v13 = *((void *)buffer + 21);
        }

        UniChar v11 = buffer[v8 - v13];
      }
    }

    goto LABEL_6;
  }

void __CFStringTokenizerDeallocate(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(const void **)(a1 + 16);
    if (v1) {
      CFRelease(v1);
    }
  }

CFTypeID CFStringTokenizerGetTypeID(void)
{
  return 40LL;
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return (CFStringRef)__NLStringTokenizerCopyBestStringLanguage(string, location, length);
  }
  else {
    return 0LL;
  }
}

CFStringTokenizerRef CFStringTokenizerCreate( CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return 0LL;
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance(alloc, 0x28uLL, 8LL, 0LL, options, (uint64_t)locale, v5, v6);
  if (Instance)
  {
    uint64_t v14 = __NLStringTokenizerCreate(alloc, string, location, length, options, locale);
    Instance[2] = v14;
    if (!v14)
    {
      CFRelease(Instance);
      return 0LL;
    }
  }

  return (CFStringTokenizerRef)Instance;
}

void CFStringTokenizerSetString(CFStringTokenizerRef tokenizer, CFStringRef string, CFRange range)
{
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return __NLStringTokenizerGoToTokenAtIndex(*((void *)tokenizer + 2), index);
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return __NLStringTokenizerAdvanceToNextToken(*((void *)tokenizer + 2));
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex CurrentTokenRange = __NLStringTokenizerGetCurrentTokenRange(*((void *)tokenizer + 2));
  result.CFIndex length = v2;
  result.CFIndex location = CurrentTokenRange;
  return result;
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)__NLStringTokenizerCopyCurrentTokenAttribute(*((void *)tokenizer + 2), attribute);
}

CFIndex CFStringTokenizerGetCurrentSubTokens( CFStringTokenizerRef tokenizer, CFRange *ranges, CFIndex maxRangeLength, CFMutableArrayRef derivedSubTokens)
{
  return __NLStringTokenizerGetCurrentSubTokens(*((void *)tokenizer + 2), ranges, maxRangeLength, derivedSubTokens);
}

uint64_t CFStringTokenizerCopyBestStringLanguageWithHints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return __NLStringTokenizerCopyBestStringLanguageWithHints(a1, a2, a3, a4);
  }
  else {
    return 0LL;
  }
}

uint64_t _CFStringTokenizerCopyPossibleStringLanguages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (__CFSTLoadCoreNLP_once != -1) {
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  }
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable) {
    return ___NLStringTokenizerCopyPossibleStringLanguages(a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t _CFStringTokenizerTokenize(uint64_t a1)
{
  return ___NLStringTokenizerTokenize(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeWithTranscriptions(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeWithTranscriptions(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeCompoundWord(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeCompoundWord(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetDerivedTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetDerivedTokens(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetNextBestTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetNextBestTokens(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithString(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithString(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetCurrentTokenPartOfSpeech(uint64_t a1)
{
  return ___NLStringTokenizerGetCurrentTokenPartOfSpeech(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetLocale(uint64_t a1)
{
  return ___NLStringTokenizerSetLocale(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerSetTokenizerAttribute(*(void *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerGetTokenizerAttribute(*(void *)(a1 + 16));
}

uint64_t CFStringTokenizerSetStringWithOptions(uint64_t a1)
{
  return __NLStringTokenizerSetStringWithOptions(*(void *)(a1 + 16));
}

uint64_t (**__CFStringEncodingGetSymbolConverterDefinition(int a1))()
{
  int v1 = __CFConverterMacSymbol;
  if (a1 != 33) {
    int v1 = 0LL;
  }
  if (a1 == 34) {
    return __CFConverterMacDingbats;
  }
  else {
    return v1;
  }
}

uint64_t __CFToMacDingbats(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4 = *a2;
  if (v4 > 0x1F)
  {
    if (v4 <= 0x3015)
    {
      uint64_t v6 = MacDingbats_from_uni;
      int v7 = (const __int16 *)&unk_180CA40F8;
      do
      {
        uint64_t v8 = ((char *)v7 - (char *)v6) >> 3;
        uint64_t v9 = &v6[2 * v8];
        unsigned int v10 = *(unsigned __int16 *)v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }

          uint64_t v6 = v9 + 2;
        }

        else
        {
          int v7 = v9 - 2;
        }
      }

      while (v6 <= v7);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a4 = v4;
    return 1LL;
  }

BOOL __CFFromMacDingbats(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0x1F)
  {
    if (a2 > 0x8F)
    {
      unsigned int v3 = a2 - 160;
      if (a2 < 0xA0) {
        return 0LL;
      }
      unsigned int v4 = (unsigned __int16 *)&MacDingbats_to_uni_FF;
    }

    else
    {
      unsigned int v3 = a2 - 32;
      unsigned int v4 = (unsigned __int16 *)&MacDingbats_to_uni_8F;
    }

    a2 = v4[v3];
  }

  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacDingbatsLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    __int16 v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870) {
      ++result;
    }
  }

  return result;
}

uint64_t __CFFromMacDingbatsLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  unint64_t v4 = a3 + 1;
  do
  {
    char v5 = *a2++;
    char v6 = v5 + 126;
    else {
      uint64_t v7 = qword_180CA46D8[v6];
    }
    result += v7;
    --v4;
  }

  while (v4 > 1);
  return result;
}

uint64_t __CFToMacSymbol(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4)
{
  unsigned int v4 = *a2;
  if (v4 <= 0x1F)
  {
LABEL_2:
    *a4 = v4;
    return 1LL;
  }

  if (a3 < 2 || (int v6 = a2[1], (v6 & 0xFFF0) != 0xF870))
  {
LABEL_10:
    if (v4 >> 8 > 0xF8) {
      return 0LL;
    }
    goto LABEL_11;
  }

  if (v4 == 169)
  {
    if (v6 == 63615)
    {
      char v7 = -29;
      goto LABEL_23;
    }

uint64_t __CFFromMacSymbol(__int16 a1, unsigned int a2, __int16 *a3)
{
  if (a2 <= 0x3F)
  {
    switch(a2)
    {
      case '""':
        __int16 v3 = 8704;
        goto LABEL_15;
      case '$':
        __int16 v3 = 8707;
        goto LABEL_15;
      case '\'':
        __int16 v3 = 8717;
        goto LABEL_15;
      case '*':
        __int16 v3 = 8727;
        goto LABEL_15;
      case '-':
        __int16 v3 = 8722;
        goto LABEL_15;
      default:
        *a3 = a2;
        break;
    }

    return 1;
  }

  if (a2 <= 0x7E)
  {
    unsigned int v4 = a2 - 64;
    char v5 = &MacSymbol_to_uni_to7E;
    goto LABEL_9;
  }

  unsigned int v4 = a2 - 160;
  if (a2 < 0xA0) {
    return 0;
  }
  if (a2 <= 0xDF)
  {
    char v5 = &MacSymbol_to_uni_toDF;
LABEL_9:
    __int16 v3 = v5[v4];
LABEL_15:
    *a3 = v3;
    return 1;
  }

  uint64_t v8 = a2 - 224;
  uint64_t v9 = MacSymbol_to_uni_toFF[v8];
  *a3 = v9;
  if (a2 == 255) {
    return 0;
  }
  unint64_t v10 = v8 - 2;
  unsigned __int16 v6 = 1;
  if (v10 <= 2)
  {
    *(_DWORD *)a3 = __CFMacSymbolTwoCharDecompSeqTable[v9];
    if ((a1 & 0x200) != 0) {
      return 1;
    }
    else {
      return 2;
    }
  }

  return v6;
}

uint64_t __CFToMacSymbolLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    __int16 v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870) {
      ++result;
    }
  }

  return result;
}

uint64_t __CFFromMacSymbolLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  unint64_t v4 = a3 + 1;
  do
  {
    unsigned int v5 = *a2++;
    if (v5 < 0xE0) {
      uint64_t v6 = 1LL;
    }
    else {
      uint64_t v6 = 2LL;
    }
    result += v6;
    --v4;
  }

  while (v4 > 1);
  return result;
}

uint64_t __CFPrecomposeCharMacSymbol( uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 2 || a2[1] != 824) {
    return 0LL;
  }
  if (a5)
  {
    int v6 = *a2;
    switch(v6)
    {
      case 61:
        char v7 = -71;
        goto LABEL_11;
      case 8834:
        char v7 = -53;
        goto LABEL_11;
      case 8712:
        char v7 = -49;
LABEL_11:
        *a4 = v7;
        break;
    }
  }

  *a6 = 1LL;
  return 2LL;
}

BOOL __CFIsValidCombiningCharMacSymbol(int a1)
{
  return a1 == 824;
}

BOOL CFDateComponentsIsLeapMonthSet(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0x7FFFFFFFFFFFFFFFLL;
}

BOOL CFDateComponentsIsLeapMonth(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  return v1 != 0x7FFFFFFFFFFFFFFFLL && v1 != 0;
}

__CFString *_CFDateComponentsCopyDescriptionInner(void *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFStringAppend(Mutable, @"{");
  if (a1[2]) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Calendar: %@", a1[2]);
  }
  if (a1[3]) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    TimeZone: %@", a1[3]);
  }
  if (a1[4] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Era: %ld", a1[4]);
  }
  if (a1[5] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Calendar Year: %ld", a1[5]);
  }
  if (a1[20] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Day of Year: %ld", a1[20]);
  }
  if (a1[6] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Month: %ld", a1[6]);
  }
  if (a1[7] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Leap Month: %ld", a1[7]);
  }
  if (a1[8] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Day: %ld", a1[8]);
  }
  if (a1[9] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Hour: %ld", a1[9]);
  }
  if (a1[10] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Minute: %ld", a1[10]);
  }
  if (a1[11] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Second: %ld", a1[11]);
  }
  if (a1[19] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Nanosecond: %ld", a1[19]);
  }
  if (a1[15] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Quarter: %ld", a1[15]);
  }
  if (a1[18] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Year for Week of Year: %ld", a1[18]);
  }
  if (a1[17] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Week of Year: %ld", a1[17]);
  }
  if (a1[16] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Week of Month: %ld", a1[16]);
  }
  if (a1[12] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Week (obsolete): %ld", a1[12]);
  }
  if (a1[13] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Weekday: %ld", a1[13]);
  }
  if (a1[14] != 0x7FFFFFFFFFFFFFFFLL) {
    CFStringAppendFormat(Mutable, 0LL, @"\n    Weekday Ordinal: %ld", a1[14]);
  }
  return Mutable;
}

void __CFDateComponentsDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFDateComponentsDeallocate_cold_1();
  }
  CFIndex v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  __int16 v3 = *(const void **)(a1 + 24);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t __CFDateComponentsEqual(void *a1, void *a2)
{
  if (!a1) {
    __CFDateComponentsEqual_cold_1();
  }
  if (!a2) {
    __CFDateComponentsEqual_cold_2();
  }
  if (a1[4] != a2[4]
    || a1[5] != a2[5]
    || a1[15] != a2[15]
    || a1[6] != a2[6]
    || a1[8] != a2[8]
    || a1[9] != a2[9]
    || a1[10] != a2[10]
    || a1[11] != a2[11]
    || a1[19] != a2[19]
    || a1[12] != a2[12]
    || a1[17] != a2[17]
    || a1[20] != a2[20]
    || a1[16] != a2[16]
    || a1[18] != a2[18]
    || a1[13] != a2[13]
    || a1[14] != a2[14])
  {
    return 0LL;
  }

  uint64_t v2 = a1[7];
  if (v2)
  {
    if (v2 == 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v3 = a2[7];
      if (!v3) {
        goto LABEL_29;
      }
    }

    else
    {
      uint64_t v3 = a2[7];
    }
  }

  else
  {
    uint64_t v3 = a2[7];
    if (v3 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_29;
    }
  }

  if (v2 != v3) {
    return 0LL;
  }
LABEL_29:
  unint64_t v4 = (const void *)a1[2];
  unsigned int v5 = (const void *)a2[2];
  if (v4)
  {
    if (!v5) {
      return 0LL;
    }
    uint64_t result = CFEqual(v4, v5);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v5)
  {
    return 0LL;
  }

  char v7 = (const void *)a1[3];
  uint64_t v8 = (const void *)a2[3];
  if (!v7) {
    return !v8;
  }
  if (!v8) {
    return 0LL;
  }
  uint64_t result = CFEqual(v7, v8);
  if ((_DWORD)result) {
    return 1LL;
  }
  return result;
}

uint64_t __CFDateComponentsHash(void *a1)
{
  if (!a1) {
    __CFDateComponentsHash_cold_1();
  }
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFHashCode v3 = CFHash(v2);
  }
  else {
    CFHashCode v3 = 0LL;
  }
  CFHashCode v4 = a1[3];
  if (v4) {
    CFHashCode v4 = CFHash((CFTypeRef)v4);
  }
  CFHashCode v5 = v4 ^ v3;
  uint64_t v6 = a1[5];
  uint64_t v7 = a1[6];
  if (v6 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v6 = 0LL;
  }
  uint64_t v8 = 2678437 * v7;
  uint64_t v9 = a1[8];
  uint64_t v10 = a1[9];
  if (v9 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v9 = 0LL;
  }
  uint64_t v12 = a1[10];
  uint64_t v11 = a1[11];
  if (v11 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v11 = 0LL;
  }
  uint64_t v13 = a1[18];
  if (v13 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v13 = 0LL;
  }
  uint64_t v14 = v13 + v6;
  uint64_t v15 = a1[20];
  if (v15 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v15 = 0LL;
  }
  if (v7 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v8 = 0LL;
  }
  uint64_t v16 = v15 + v9;
  if (v10 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v17 = 0LL;
  }
  else {
    uint64_t v17 = 3607 * v10;
  }
  if (v12 == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = 61 * v12;
  }
  return v8
       + v5
       + v17
       + v18
       + v11
       + 32832013 * v14
       + 86413 * v16
       + 32 * (41LL * a1[17] + 11LL * a1[16] - a1[13] + 8LL * a1[13] + 3LL * a1[14] + a1[15]);
}

CFStringRef __CFDateComponentsCopyDescription(void *a1)
{
  if (!a1) {
    __CFDateComponentsCopyDescription_cold_1();
  }
  uint64_t v2 = _CFDateComponentsCopyDescriptionInner(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFStringRef v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFDateComponents %p [%p]>%@",  a1,  v3,  v2);
  CFRelease(v2);
  return v4;
}

uint64_t CFDateComponentsGetTypeID()
{
  return 66LL;
}

int64x2_t CFDateComponentsCreate( const __CFAllocator *Default, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!Default) {
    Default = CFAllocatorGetDefault();
  }
  uint64_t Instance = (int64x2_t *)_CFRuntimeCreateInstance(Default, 0x42uLL, 152LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    Instance[1].i64[0] = 0LL;
    Instance[1].i64[1] = 0LL;
    int64x2_t result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    Instance[2] = result;
    Instance[3] = result;
    Instance[4] = result;
    Instance[5] = result;
    Instance[6] = result;
    Instance[7] = result;
    Instance[10].i64[0] = 0x7FFFFFFFFFFFFFFFLL;
    Instance[8] = result;
    Instance[9] = result;
  }

  return result;
}

uint64_t CFDateComponentsCreateCopy( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!v9) {
    CFDateComponentsCreateCopy_cold_1();
  }
  uint64_t v10 = v9;
  uint64_t v11 = (void *)CFDateComponentsCopyCalendar(a2);
  if (v11)
  {
    uint64_t v12 = v11;
    CFDateComponentsSetCalendar(v10, v11);
    CFRelease(v12);
  }

  CFTypeRef v13 = CFDateComponentsCopyTimeZone(a2);
  if (v13)
  {
    uint64_t v14 = v13;
    CFDateComponentsSetTimeZone(v10, v13);
    CFRelease(v14);
  }

  *(_OWORD *)(v10 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v10 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v10 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v10 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v10 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v10 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v10 + 12_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 128);
  *(void *)(v10 + 160) = *(void *)(a2 + 160);
  *(_OWORD *)(v10 + 144) = *(_OWORD *)(a2 + 144);
  return v10;
}

CFTypeRef CFDateComponentsCopyCalendar(uint64_t a1)
{
  if (!a1) {
    CFDateComponentsCopyCalendar_cold_1();
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void CFDateComponentsSetCalendar(uint64_t a1, void *cf2)
{
  if (!a1) {
    CFDateComponentsSetCalendar_cold_1();
  }
  CFStringRef v4 = *(const void **)(a1 + 16);
  if (cf2 && v4)
  {
    if (CFEqual(v4, cf2)) {
      return;
    }
    CFStringRef v4 = *(const void **)(a1 + 16);
  }

  else if (!v4)
  {
    goto LABEL_8;
  }

  CFRelease(v4);
  *(void *)(a1 + 16) = 0LL;
LABEL_8:
  if (cf2)
  {
    CFStringRef Copy = (__CFCalendar *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, cf2);
    uint64_t v6 = Copy;
    uint64_t v7 = *(const __CFTimeZone **)(a1 + 24);
    if (v7) {
      CFCalendarSetTimeZone(Copy, v7);
    }
    *(void *)(a1 + 16) = v6;
  }

CFTypeRef CFDateComponentsCopyTimeZone(uint64_t a1)
{
  if (!a1) {
    CFDateComponentsCopyTimeZone_cold_1();
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 24);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void CFDateComponentsSetTimeZone(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    CFDateComponentsSetTimeZone_cold_1();
  }
  CFStringRef v4 = *(const void **)(a1 + 24);
  if (cf && v4)
  {
    if (CFEqual(v4, cf)) {
      return;
    }
    CFStringRef v4 = *(const void **)(a1 + 24);
  }

  else if (!v4)
  {
    goto LABEL_8;
  }

  CFRelease(v4);
  *(void *)(a1 + 24) = 0LL;
LABEL_8:
  if (cf)
  {
    *(void *)(a1 + 24) = CFRetain(cf);
    CFHashCode v5 = *(__CFCalendar **)(a1 + 16);
    if (v5) {
      CFCalendarSetTimeZone(v5, (CFTimeZoneRef)cf);
    }
  }

uint64_t CFDateComponentsGetValue(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    CFDateComponentsGetValue_cold_1();
  }
  uint64_t v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          uint64_t v3 = a1 + 88;
          return *(void *)v3;
        }

        if (a2 == 256)
        {
          uint64_t v3 = a1 + 96;
          return *(void *)v3;
        }
      }

      else
      {
        if (a2 == 32)
        {
          uint64_t v3 = a1 + 72;
          return *(void *)v3;
        }

        if (a2 == 64)
        {
          uint64_t v3 = a1 + 80;
          return *(void *)v3;
        }
      }
    }

    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        uint64_t v3 = a1 + 48;
        return *(void *)v3;
      }

      if (a2 == 16)
      {
        uint64_t v3 = a1 + 64;
        return *(void *)v3;
      }
    }

    else
    {
      if (a2 == 2)
      {
        uint64_t v3 = a1 + 32;
        return *(void *)v3;
      }

      if (a2 == 4)
      {
        uint64_t v3 = a1 + 40;
        return *(void *)v3;
      }
    }
  }

  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        uint64_t v3 = a1 + 120;
        return *(void *)v3;
      }

      if (a2 == 4096)
      {
        uint64_t v3 = a1 + 128;
        return *(void *)v3;
      }
    }

    else
    {
      if (a2 == 512)
      {
        uint64_t v3 = a1 + 104;
        return *(void *)v3;
      }

      if (a2 == 1024)
      {
        uint64_t v3 = a1 + 112;
        return *(void *)v3;
      }
    }
  }

  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      uint64_t v3 = a1 + 136;
      return *(void *)v3;
    }

    if (a2 == 0x4000)
    {
      uint64_t v3 = a1 + 144;
      return *(void *)v3;
    }
  }

  else
  {
    switch(a2)
    {
      case 0x8000LL:
        uint64_t v3 = a1 + 152;
        return *(void *)v3;
      case 0x10000LL:
        uint64_t v3 = a1 + 160;
        return *(void *)v3;
      case 0x40000000LL:
        uint64_t v3 = a1 + 56;
        return *(void *)v3;
    }
  }

  return v2;
}

void *CFDateComponentsSetValue(void *result, uint64_t a2, uint64_t a3)
{
  if (!result) {
    CFDateComponentsSetValue_cold_1();
  }
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          uint64_t v3 = result + 11;
        }

        else
        {
          if (a2 != 256) {
            return result;
          }
          uint64_t v3 = result + 12;
        }
      }

      else if (a2 == 32)
      {
        uint64_t v3 = result + 9;
      }

      else
      {
        if (a2 != 64) {
          return result;
        }
        uint64_t v3 = result + 10;
      }
    }

    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        uint64_t v3 = result + 6;
      }

      else
      {
        if (a2 != 16) {
          return result;
        }
        uint64_t v3 = result + 8;
      }
    }

    else if (a2 == 2)
    {
      uint64_t v3 = result + 4;
    }

    else
    {
      if (a2 != 4) {
        return result;
      }
      uint64_t v3 = result + 5;
    }
  }

  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        uint64_t v3 = result + 15;
      }

      else
      {
        if (a2 != 4096) {
          return result;
        }
        uint64_t v3 = result + 16;
      }
    }

    else if (a2 == 512)
    {
      uint64_t v3 = result + 13;
    }

    else
    {
      if (a2 != 1024) {
        return result;
      }
      uint64_t v3 = result + 14;
    }
  }

  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      uint64_t v3 = result + 17;
    }

    else
    {
      if (a2 != 0x4000) {
        return result;
      }
      uint64_t v3 = result + 18;
    }
  }

  else
  {
    switch(a2)
    {
      case 0x8000LL:
        uint64_t v3 = result + 19;
        break;
      case 0x10000LL:
        uint64_t v3 = result + 20;
        break;
      case 0x40000000LL:
        uint64_t v3 = result + 7;
        break;
      default:
        return result;
    }
  }

  void *v3 = a3;
  return result;
}

BOOL CFDateComponentsIsValidDate(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  return v1 && CFDateComponentsIsValidDateInCalendar(a1, v1);
}

BOOL CFDateComponentsIsValidDateInCalendar(void *a1, void *a2)
{
  if (!a1) {
    CFDateComponentsIsValidDateInCalendar_cold_1();
  }
  if (!a2) {
    CFDateComponentsIsValidDateInCalendar_cold_2();
  }
  unint64_t v3 = a1[19];
  if (v3 == 0x7FFFFFFFFFFFFFFFLL || v3 <= 0x3B9AC9FF)
  {
    CFStringRef Copy = (void *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    if (v3 - 1 >= 0x7FFFFFFFFFFFFFFELL)
    {
      id DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      if (DateFromComponents) {
        goto LABEL_9;
      }
    }

    else
    {
      a1[19] = 0LL;
      id DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      a1[19] = v3;
      if (DateFromComponents)
      {
LABEL_9:
        DateComponentsFromDate = CFCalendarCreateDateComponentsFromDate((uint64_t)&__kCFAllocatorSystemDefault, Copy);
        uint64_t v8 = DateComponentsFromDate;
        uint64_t v9 = a1[4];
        if (v9 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[4] != v9) {
          goto LABEL_40;
        }
        uint64_t v10 = a1[5];
        if (v10 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[5] != v10) {
          goto LABEL_40;
        }
        uint64_t v11 = a1[6];
        if (v11 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[6] != v11) {
          goto LABEL_40;
        }
        uint64_t v12 = a1[7];
        if (v12 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[7] != v12) {
          goto LABEL_40;
        }
        uint64_t v13 = a1[8];
        if (v13 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[8] != v13) {
          goto LABEL_40;
        }
        uint64_t v14 = a1[9];
        if (v14 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[9] != v14) {
          goto LABEL_40;
        }
        uint64_t v15 = a1[10];
        if (v15 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[10] != v15) {
          goto LABEL_40;
        }
        if (((uint64_t v16 = a1[11], v16 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[11] == v16)
          && ((uint64_t v17 = a1[13], v17 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[13] == v17)
          && ((uint64_t v18 = a1[14], v18 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[14] == v18)
          && ((uint64_t v19 = a1[15], v19 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[15] == v19)
          && ((uint64_t v20 = a1[16], v20 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[16] == v20)
          && ((uint64_t v21 = a1[17], v21 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[17] == v21)
          && ((uint64_t v22 = a1[20], v22 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[20] == v22))
        {
          uint64_t v23 = a1[18];
          BOOL v24 = v23 == 0x7FFFFFFFFFFFFFFFLL || DateComponentsFromDate[18] == v23;
        }

        else
        {
LABEL_40:
          BOOL v24 = 0LL;
        }

        CFRelease(DateFromComponents);
        CFRelease(v8);
        goto LABEL_44;
      }
    }

    BOOL v24 = 1LL;
LABEL_44:
    CFRelease(Copy);
    return v24;
  }

  return 0LL;
}

uint64_t CFDateComponentsDateMatchesComponents()
{
  return 0LL;
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  int v4 = reverse;
  uint64_t v41 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID && __CFStringTransformCacheRev == (v4 != 0))
  {
    CFStringRef v8 = transform;
    if ((CFStringRef)__CFStringTransformCacheID == transform)
    {
LABEL_6:
      CFRelease(v8);
      __CFStringTransformCacheID = 0LL;
      uint64_t v9 = __CFStringTransformCacheTL;
      __CFStringTransformCacheTL = 0LL;
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
      goto LABEL_30;
    }

    if (CFEqual(transform, (CFTypeRef)__CFStringTransformCacheID))
    {
      CFStringRef v8 = (CFStringRef)__CFStringTransformCacheID;
      goto LABEL_6;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  LODWORD(v30[0]) = 0;
  if (CFStringGetLength(transform) >= 1 && CFStringGetCharacterAtIndex(transform, 0LL) == 41)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = &kCFStringTransformStripCombiningMarks;
    uint64_t v12 = &off_1899E9408;
    while (*(CFStringRef *)v11 != transform)
    {
      ++v10;
      uint64_t v13 = *v12;
      v12 += 2;
      uint64_t v11 = (const NSStringTransform *)v13;
      if (v10 == 16)
      {
        uint64_t v10 = 0LL;
        p_isa = (CFTypeRef *)&kCFStringTransformStripCombiningMarks;
        uint64_t v15 = &off_1899E9408;
        while (!CFEqual(*p_isa, transform))
        {
          ++v10;
          uint64_t v16 = *v15;
          v15 += 2;
          p_isa = (CFTypeRef *)&v16->isa;
          if (v10 == 16) {
            goto LABEL_17;
          }
        }

        break;
      }
    }

    uint64_t v20 = (const char *)*(&__CFStringTransformNameMap + 2 * v10 + 1);
    int64_t v21 = strlen(v20);
    if (v21 >= 1)
    {
      uint64_t v22 = buffer;
      int64_t v23 = v21;
      do
      {
        UniChar v24 = *v20++;
        *v22++ = v24;
        --v23;
      }

      while (v23);
    }

    goto LABEL_25;
  }

uint64_t __CFStringReplaceableLength(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t __CFStringReplaceableCharAt(uint64_t a1, signed int a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    return (unsigned __int16)-1;
  }

  else
  {
    if (a2 < 0) {
      return 0;
    }
    uint64_t v3 = a2;
    uint64_t v4 = *(void *)(a1 + 176);
    if (v4 <= a2)
    {
      return 0;
    }

    else
    {
      uint64_t v5 = *(void *)(a1 + 152);
      if (v5)
      {
        return *(unsigned __int16 *)(v5 + 2 * (*(void *)(a1 + 168) + a2));
      }

      else
      {
        uint64_t v8 = *(void *)(a1 + 160);
        if (v8)
        {
          return (unsigned __int16)*(char *)(v8 + *(void *)(a1 + 168) + a2);
        }

        else
        {
          if (*(void *)(a1 + 192) <= a2 || (uint64_t v9 = *(void *)(a1 + 184), v9 > a2))
          {
            uint64_t v10 = a2 - 4LL;
            if (v10 + 64 < v4) {
              uint64_t v4 = v10 + 64;
            }
            *(void *)(a1 + 184) = v10;
            *(void *)(a1 + 192) = v4;
            v11.CFIndex location = *(void *)(a1 + 168) + v10;
            v11.CFIndex length = v4 - v10;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v11, (UniChar *)(a1 + 16));
            uint64_t v9 = *(void *)(a1 + 184);
          }

          return *(unsigned __int16 *)(a1 + 16 + 2 * (v3 - v9));
        }
      }
    }
  }

uint64_t __CFStringReplaceableChar32At(uint64_t a1, signed int a2)
{
  if (*(void *)(a1 + 8) <= a2) {
    return 0xFFFFLL;
  }
  if (a2 < 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 176);
  if (v4 <= a2) {
    return 0;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = *(void *)(a1 + 152);
  if (v6)
  {
    unsigned __int16 v7 = *(_WORD *)(v6 + 2 * (*(void *)(a1 + 168) + a2));
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 160);
    if (v10)
    {
      unsigned __int16 v7 = *(char *)(v10 + *(void *)(a1 + 168) + a2);
    }

    else
    {
      if (*(void *)(a1 + 192) <= a2 || (uint64_t v11 = *(void *)(a1 + 184), v11 > a2))
      {
        uint64_t v12 = a2 - 4LL;
        if (v12 + 64 < v4) {
          uint64_t v4 = v12 + 64;
        }
        *(void *)(a1 + 184) = v12;
        *(void *)(a1 + 192) = v4;
        v20.CFIndex location = *(void *)(a1 + 168) + v12;
        v20.CFIndex length = v4 - v12;
        CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v20, (UniChar *)(a1 + 16));
        uint64_t v11 = *(void *)(a1 + 184);
      }

      unsigned __int16 v7 = *(_WORD *)(v5 + 2 * (a2 - v11));
    }
  }

  if (v7 >> 10 != 54 || *(void *)(a1 + 8) - 1LL <= a2) {
    return v7;
  }
  uint64_t v8 = v7;
  uint64_t v13 = a2 + 1LL;
  uint64_t v14 = *(void *)(a1 + 176);
  if (v14 > v13)
  {
    uint64_t v15 = *(void *)(a1 + 152);
    if (v15)
    {
      unsigned __int16 v16 = *(_WORD *)(v15 + 2 * (*(void *)(a1 + 168) + v13));
    }

    else
    {
      uint64_t v17 = *(void *)(a1 + 160);
      if (v17)
      {
        unsigned __int16 v16 = *(char *)(v17 + *(void *)(a1 + 168) + v13);
      }

      else
      {
        if (*(void *)(a1 + 192) <= v13 || (uint64_t v18 = *(void *)(a1 + 184), v18 > v13))
        {
          uint64_t v19 = a2 - 3LL;
          if (v19 + 64 < v14) {
            uint64_t v14 = v19 + 64;
          }
          *(void *)(a1 + 184) = v19;
          *(void *)(a1 + 192) = v14;
          v21.CFIndex location = *(void *)(a1 + 168) + v19;
          v21.CFIndex length = v14 - v19;
          CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v21, (UniChar *)(a1 + 16));
          uint64_t v18 = *(void *)(a1 + 184);
        }

        unsigned __int16 v16 = *(_WORD *)(v5 + 2 * (v13 - v18));
      }
    }

    if (v16 >> 10 == 55) {
      return ((_DWORD)v8 << 10) + v16 - 56613888;
    }
  }

  return v8;
}

const char *__CFStringReplaceableReplace(uint64_t a1, int a2, int a3, UniChar *chars, int a5)
{
  uint64_t v8 = *(__CFString **)(a1 + 200);
  if (v8)
  {
    CFStringSetExternalCharactersNoCopy(v8, chars, a5, a5);
    MutableWithExternalCharactersNoCFStringRef Copy = *(const __CFString **)(a1 + 200);
  }

  else
  {
    MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  chars,  a5,  a5,  (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 200) = MutableWithExternalCharactersNoCopy;
  }

  v14.CFIndex location = a2;
  v14.CFIndex length = a3 - a2;
  CFStringReplace(*(CFMutableStringRef *)a1, v14, MutableWithExternalCharactersNoCopy);
  CFIndex Length = CFStringGetLength(*(CFStringRef *)a1);
  *(void *)(a1 + _Block_object_dispose(va, 8) = Length;
  uint64_t v11 = *(const __CFString **)a1;
  *(void *)(a1 + 144) = *(void *)a1;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 176) = Length;
  CharactersPtr = CFStringGetCharactersPtr(v11);
  CFTypeRef result = 0LL;
  *(void *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr) {
    CFTypeRef result = CFStringGetCStringPtr(v11, 0x600u);
  }
  *(void *)(a1 + 160) = result;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 192) = 0LL;
  return result;
}

void __CFStringReplaceableExtract(uint64_t a1, int a2, int a3, UniChar *__dst)
{
  uint64_t v4 = __dst;
  uint64_t v6 = a2;
  CFIndex v7 = a3 - a2;
  uint64_t v8 = *(void *)(a1 + 152);
  if (v8)
  {
    memmove(__dst, (const void *)(v8 + 2LL * *(void *)(a1 + 168) + 2LL * a2), 2 * v7);
  }

  else
  {
    uint64_t v9 = (char *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 184);
    CFIndex v11 = v10 - v6;
    if (v10 > v6 || (uint64_t v12 = *(void *)(a1 + 192), v13 = v12 <= v6, v14 = v12 - v6, v13))
    {
      BOOL v16 = __OFSUB__(v7 + v6, v10);
      uint64_t v17 = v7 + v6 - v10;
      if (!((v17 < 0) ^ v16 | (v17 == 0)) && v7 + v6 < *(void *)(a1 + 192))
      {
        memmove(&__dst[v11], v9, 2 * v17);
        CFIndex v7 = v11;
      }
    }

    else
    {
      if (v14 >= v7) {
        CFIndex v15 = v7;
      }
      else {
        CFIndex v15 = v14;
      }
      memmove(__dst, &v9[2 * (v6 - v10)], 2 * v15);
      v4 += v15;
      v6 += v15;
      v7 -= v15;
    }

    if (v7 >= 1)
    {
      uint64_t v18 = *(void *)(a1 + 160);
      v19.CFIndex location = *(void *)(a1 + 168) + v6;
      if (v18)
      {
        CFRange v20 = (char *)(v18 + v19.location);
        do
        {
          UniChar v21 = *v20++;
          *v4++ = v21;
          --v7;
        }

        while (v7);
      }

      else
      {
        v19.CFIndex length = v7;
        CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v19, v4);
      }
    }
  }

const char *__CFStringReplaceableCopy(uint64_t a1, int a2, int a3, int a4)
{
  v11.CFIndex length = a3 - a2;
  v11.CFIndex location = a2;
  uint64_t v6 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)a1, v11);
  CFStringInsert(*(CFMutableStringRef *)a1, a4, v6);
  CFRelease(v6);
  CFIndex Length = CFStringGetLength(*(CFStringRef *)a1);
  *(void *)(a1 + _Block_object_dispose(va, 8) = Length;
  uint64_t v8 = *(const __CFString **)a1;
  *(void *)(a1 + 144) = *(void *)a1;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 176) = Length;
  CharactersPtr = CFStringGetCharactersPtr(v8);
  CFTypeRef result = 0LL;
  *(void *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr) {
    CFTypeRef result = CFStringGetCStringPtr(v8, 0x600u);
  }
  *(void *)(a1 + 160) = result;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 192) = 0LL;
  return result;
}

__objc2_class **_CFPredicatePolicyRestrictedClasses()
{
  return &off_189B3FFE8;
}

__objc2_class **_CFPredicatePolicyRestrictedSelectors()
{
  return &off_189B40010;
}

void *_CFPredicatePolicyData()
{
  return &_CFPredicatePolicyData__cfpredicateelements;
}

uint64_t _CFPredicatePolicyData_getFlags()
{
  return _cfprediacateelements_flags;
}

uint64_t _CFPredicatePolicyData_setFlags(uint64_t result)
{
  _cfprediacateelements_flags = result;
  return result;
}

uint64_t (**__CFStringEncodingGetHebrewConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_4)
  {
    __CFStringEncodingPrecomposeLatinCharacter_4 = a2(4LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_2 = a2(3LL);
  }

  uint64_t v4 = __CFConverterISOLatinHebrew;
  uint64_t v5 = __CFConverterMacHebrew;
  if (a1 != 5) {
    uint64_t v5 = 0LL;
  }
  if (a1 != 520) {
    uint64_t v4 = v5;
  }
  if (a1 == 1285) {
    return __CFConverterWindowsHebrew;
  }
  else {
    return v4;
  }
}

uint64_t __CFToISOLatinHebrew(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  uint64_t result = 0LL;
  if (a2 != 161 && a2 <= 0x203E)
  {
    uint64_t v5 = (unsigned __int16 *)&ISOLatinHebrew_from_uni;
    uint64_t v6 = (unsigned __int16 *)&unk_180CA47F8;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      uint64_t v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1LL;
        }

        uint64_t v5 = v8 + 2;
      }

      else
      {
        uint64_t v6 = v8 - 2;
      }

      if (v5 > v6) {
        return 0LL;
      }
    }
  }

  return result;
}

BOOL __CFFromISOLatinHebrew(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
  {
    if (a2 <= 0xBE)
    {
      unsigned int v3 = a2 - 161;
      uint64_t v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni;
LABEL_7:
      a2 = v4[v3];
      goto LABEL_8;
    }

    if ((a2 + 5) >= 0xE4u)
    {
      unsigned int v3 = a2 - 223;
      uint64_t v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni2;
      goto LABEL_7;
    }

    a2 = 65533;
  }

uint64_t __CFToMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a5;
  }
  if (v7 < 1)
  {
    uint64_t result = 0LL;
    goto LABEL_24;
  }

  uint64_t result = 0LL;
  while (1)
  {
    unsigned int v9 = *(unsigned __int16 *)(a2 + 2 * result);
    if (v9 <= 0x7F) {
      goto LABEL_19;
    }
    uint64_t v10 = (unsigned __int16 *)&unk_180CA49D4;
    CFRange v11 = (unsigned __int16 *)&MacHebrew_from_uni;
    while (1)
    {
      uint64_t v12 = ((char *)v10 - (char *)v11) >> 3;
      BOOL v13 = &v11[2 * v12];
      unsigned int v14 = *v13;
      if (v14 <= v9) {
        break;
      }
      uint64_t v10 = v13 - 2;
LABEL_16:
      if (v11 > v10) {
        goto LABEL_24;
      }
    }

    if (v14 < v9)
    {
      CFRange v11 = v13 + 2;
      goto LABEL_16;
    }

    LOBYTE(v9) = v11[2 * v12 + 1];
LABEL_19:
    if (a5) {
      *(_BYTE *)(a4 + result) = v9;
    }
    if (++result == v7)
    {
      uint64_t result = v7;
      break;
    }
  }

uint64_t __CFFromMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a5;
  }
  if (v7 < 1)
  {
    uint64_t result = 0LL;
    goto LABEL_19;
  }

  for (uint64_t result = 0LL; result != v7; ++result)
  {
    unsigned int v9 = *(unsigned __int8 *)(a2 + result);
    if ((*(char *)(a2 + result) & 0x80000000) == 0)
    {
      if (!a5) {
        continue;
      }
LABEL_11:
      *(_WORD *)(a4 + 2 * result) = v9;
      continue;
    }

    v9 -= 128;
    if (v9 == 64 || v9 == 94) {
      goto LABEL_19;
    }
    LOWORD(v9) = MacHebrew_to_uni[v9];
    if (a5) {
      goto LABEL_11;
    }
  }

  uint64_t result = v7;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWindowsHebrew(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA3)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  uint64_t result = 0LL;
  if (a2 != 164 && a2 <= 0x2122)
  {
    uint64_t v5 = (unsigned __int16 *)&WindowsHebrew_from_uni;
    uint64_t v6 = (unsigned __int16 *)&unk_180CA4C68;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      uint64_t v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1LL;
        }

        uint64_t v5 = v8 + 2;
      }

      else
      {
        uint64_t v6 = v8 - 2;
      }

      if (v5 > v6) {
        return 0LL;
      }
    }
  }

  return result;
}

BOOL __CFFromWindowsHebrew(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsHebrew_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

void __CFUUIDDeallocate(uint64_t a1)
{
  if (_uniquedUUIDs) {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_uniquedUUIDs, (const void *)(a1 + 16));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
}

CFStringRef __CFUUIDCopyFormattingDescription(const void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  return CFUUIDCreateString(v2, (CFUUIDRef)a1);
}

CFStringRef __CFUUIDCopyDescription(const void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  CFStringRef v3 = CFUUIDCreateString(v2, (CFUUIDRef)a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"<CFUUID %p> %@", a1, v3);
  CFRelease(v3);
  return v4;
}

CFTypeID CFUUIDGetTypeID(void)
{
  return 34LL;
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2800000000LL;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = __CFUUIDCreate_block_invoke;
  v4[3] = &unk_1899E9678;
  v4[4] = &v5;
  os_unfair_lock_lock_with_options();
  __CFUUIDCreate_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  uint64_t v2 = (const __CFUUID *)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v6[3], v6[4], 0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_180B18AFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

double __CFUUIDCreate_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  int v2 = __CFUUIDClass_block_invoke_useV1UUIDs;
  if (__CFUUIDClass_block_invoke_useV1UUIDs == 255)
  {
    CFStringRef v3 = getenv("CFUUIDVersionNumber");
    if (!v3)
    {
LABEL_6:
      uuid_generate_random(out);
      goto LABEL_7;
    }

    int v2 = strtoul_l(v3, 0LL, 0, 0LL) == 1;
    __CFUUIDClass_block_invoke_useV1UUIDs = v2;
  }

  if (v2 != 1) {
    goto LABEL_6;
  }
  uuid_generate_time(out);
LABEL_7:
  double result = *(double *)out;
  *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_OWORD *)out;
  return result;
}

uint64_t __CFUUIDCreateWithBytesPrimitive(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v15 = 0LL;
  BOOL v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  uint64_t v18 = 0LL;
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 0x40000000LL;
  uint64_t v13[2] = ____CFUUIDCreateWithBytesPrimitive_block_invoke;
  v13[3] = &unk_1899E96A0;
  v13[6] = a2;
  v13[7] = a3;
  v13[4] = &v15;
  v13[5] = a1;
  char v14 = a4;
  os_unfair_lock_lock_with_options();
  ____CFUUIDCreateWithBytesPrimitive_block_invoke((uint64_t)v13, v4, v5, v6, v7, v8, v9, v10);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  uint64_t v11 = v16[3];
  _Block_object_dispose(&v15, 8);
  return v11;
}

void sub_180B18CA4(_Unwind_Exception *a1)
{
}

CFUUIDRef CFUUIDCreateWithBytes( CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive( (uint64_t)alloc,  byte0 | ((unint64_t)byte1 << 8) | ((unint64_t)byte2 << 16) | ((unint64_t)byte3 << 24) | (byte4 << 32) | (byte5 << 40) | (byte6 << 48) | ((unint64_t)byte7 << 56),  byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56),  0);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  uint64_t v127 = *MEMORY[0x1895F89C0];
  if (!uuidStr) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(uuidStr);
  if (Length <= 100)
  {
    CFIndex v5 = Length;
    if (Length) {
      goto LABEL_5;
    }
    return 0LL;
  }

  CFIndex v5 = 100LL;
LABEL_5:
  v128.CFIndex location = 0LL;
  v128.CFIndex length = v5;
  CFStringGetCharacters(uuidStr, v128, v126);
  CFIndex v6 = 0LL;
  int v7 = v126[0];
  if (v126[0] - 48 >= 0xA && v126[0] - 97 >= 6)
  {
    CFIndex v9 = 0LL;
    while (v9 < v5 && (v7 - 71) <= 0xFFFFFFF9)
    {
      int v7 = v126[v9 + 1];
      CFIndex v6 = v9 + 1;
      BOOL v10 = (v7 - 48) >= 0xA && (v7 - 97) > 5;
      ++v9;
      if (!v10) {
        goto LABEL_20;
      }
    }

    CFIndex v6 = v9;
  }

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v4 != 34) {
    _CFAssertMismatchedTypeID(0x22uLL, v4);
  }
  CFMutableStringRef Mutable = CFStringCreateMutable(alloc, 0LL);
  unint64_t v6 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 16)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v7 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v6),  (int8x8_t)(v6 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v6, (int32x2_t)0x3700000037LL));
  unint64_t v8 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 17)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v9 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v8),  (int8x8_t)(v8 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v8, (int32x2_t)0x3700000037LL));
  unint64_t v10 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 18)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v11 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v10),  (int8x8_t)(v10 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v10, (int32x2_t)0x3700000037LL));
  unint64_t v12 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 19)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v13 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v12),  (int8x8_t)(v12 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v12, (int32x2_t)0x3700000037LL));
  __int16 v46 = v7.i16[2];
  UniChar v45 = v7.i16[0];
  __int16 v48 = v9.i16[2];
  __int16 v47 = v9.i16[0];
  __int16 v50 = v11.i16[2];
  __int16 v49 = v11.i16[0];
  __int16 v52 = v13.i16[2];
  __int16 v51 = v13.i16[0];
  __int16 v53 = 45;
  CFStringAppendCharacters(Mutable, &v45, 9LL);
  unint64_t v14 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 20)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v15 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v14),  (int8x8_t)(v14 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v14, (int32x2_t)0x3700000037LL));
  __int16 v46 = v15.i16[2];
  UniChar v45 = v15.i16[0];
  unint64_t v16 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 21)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v17 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v16),  (int8x8_t)(v16 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v16, (int32x2_t)0x3700000037LL));
  __int16 v48 = v17.i16[2];
  __int16 v47 = v17.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5LL);
  unint64_t v18 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 22)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v19 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v18),  (int8x8_t)(v18 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v18, (int32x2_t)0x3700000037LL));
  __int16 v46 = v19.i16[2];
  UniChar v45 = v19.i16[0];
  unint64_t v20 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 23)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v21 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v20),  (int8x8_t)(v20 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v20, (int32x2_t)0x3700000037LL));
  __int16 v48 = v21.i16[2];
  __int16 v47 = v21.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5LL);
  unint64_t v22 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 24)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v23 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v22),  (int8x8_t)(v22 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v22, (int32x2_t)0x3700000037LL));
  __int16 v46 = v23.i16[2];
  UniChar v45 = v23.i16[0];
  unint64_t v24 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 25)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v25 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v24),  (int8x8_t)(v24 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v24, (int32x2_t)0x3700000037LL));
  __int16 v48 = v25.i16[2];
  __int16 v47 = v25.i16[0];
  __int16 v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5LL);
  unint64_t v26 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 26)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v27 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v26),  (int8x8_t)(v26 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v26, (int32x2_t)0x3700000037LL));
  __int16 v46 = v27.i16[2];
  UniChar v28 = v27.i16[0];
  unint64_t v29 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 27)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v30 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v29),  (int8x8_t)(v29 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v29, (int32x2_t)0x3700000037LL));
  UniChar v45 = v28;
  __int16 v48 = v30.i16[2];
  __int16 v31 = v30.i16[0];
  uint32x2_t v32 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 28));
  __int16 v47 = v31;
  unint64_t v33 = *(void *)&vshl_u32(v32, (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v34 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v33),  (int8x8_t)(v33 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v33, (int32x2_t)0x3700000037LL));
  __int16 v50 = v34.i16[2];
  __int16 v49 = v34.i16[0];
  unint64_t v35 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 29)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v36 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v35),  (int8x8_t)(v35 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v35, (int32x2_t)0x3700000037LL));
  __int16 v52 = v36.i16[2];
  __int16 v37 = v36.i16[0];
  unint64_t v38 = *(void *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 30)), (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v39 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v38),  (int8x8_t)(v38 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v38, (int32x2_t)0x3700000037LL));
  __int16 v51 = v37;
  __int16 v54 = v39.i16[2];
  __int16 v40 = v39.i16[0];
  uint32x2_t v41 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 31));
  __int16 v53 = v40;
  unint64_t v42 = *(void *)&vshl_u32(v41, (uint32x2_t)4294967292LL) & 0xFFFFFF0FFFFFFF0FLL;
  int8x8_t v43 = vbsl_s8( (int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v42),  (int8x8_t)(v42 | 0x3000000030LL),  (int8x8_t)vadd_s32((int32x2_t)v42, (int32x2_t)0x3700000037LL));
  __int16 v56 = v43.i16[2];
  __int16 v55 = v43.i16[0];
  CFStringAppendCharacters(Mutable, &v45, 12LL);
  return Mutable;
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes( CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive( (uint64_t)alloc,  byte0 | ((unint64_t)byte1 << 8) | ((unint64_t)byte2 << 16) | ((unint64_t)byte3 << 24) | (byte4 << 32) | (byte5 << 40) | (byte6 << 48) | ((unint64_t)byte7 << 56),  byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56),  1);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v2 != 34) {
    _CFAssertMismatchedTypeID(0x22uLL, v2);
  }
  uint64_t v3 = *((void *)uuid + 2);
  uint64_t v4 = *((void *)uuid + 3);
  result.byte8 = v4;
  result.byte9 = BYTE1(v4);
  result.byte10 = BYTE2(v4);
  result.byte11 = BYTE3(v4);
  result.byte12 = BYTE4(v4);
  result.byte13 = BYTE5(v4);
  result.byte14 = BYTE6(v4);
  result.byte15 = HIBYTE(v4);
  result.byte0 = v3;
  result.byte1 = BYTE1(v3);
  result.byte2 = BYTE2(v3);
  result.byte3 = BYTE3(v3);
  result.byte4 = BYTE4(v3);
  result.byte5 = BYTE5(v3);
  result.byte6 = BYTE6(v3);
  result.byte7 = HIBYTE(v3);
  return result;
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive( (uint64_t)alloc,  *(uint64_t *)&bytes.byte0,  *(uint64_t *)&bytes.byte8,  0);
}

BOOL __CFisEqualUUIDBytes(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

uint64_t __CFhashUUIDBytes(uint64_t a1)
{
  return CFHashBytes(a1, 16LL);
}

UText *CFStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 0, a2);
}

UText *__CFStringUTextInit(UText *a1, int32_t a2, const void *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  UErrorCode status = U_ZERO_ERROR;
  if (!a3) {
    return 0LL;
  }
  CFUUIDBytes result = utext_setup(a1, 0, &status);
  if (status > U_ZERO_ERROR) {
    return 0LL;
  }
  result->providerProperties = a2;
  unint64_t v6 = (const UTextFuncs *)&__CFAttributedStringFuncs;
  result->CFRunLoopSourceContext context = a3;
  if ((a2 & 0x10) == 0) {
    unint64_t v6 = (const UTextFuncs *)&__CFStringFuncs;
  }
  result->pFuncs = v6;
  return result;
}

UText *CFMutableStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 8, a2);
}

UText *CFAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 16, a2);
}

UText *CFMutableAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 24, a2);
}

UText *__CFStringClone(UText *a1, uint64_t a2, int a3, UErrorCode *status)
{
  uint64_t v8 = utext_setup(a1, 0, status);
  uint64_t v4 = v8;
  if (*(int *)status <= 0)
  {
    v8->providerProperties = *(_DWORD *)(a2 + 8);
    v8->chunkNativeStart = *(void *)(a2 + 32);
    int64_t v9 = *(void *)(a2 + 32);
    v8->chunkNativeLimit = v9;
    v8->nativeIndexingLimit = v9;
    v8->chunkOffset = 0;
    unint64_t v10 = (const UTextFuncs *)&__CFAttributedStringFuncs;
    int v11 = *(_DWORD *)(a2 + 8);
    if ((v11 & 0x10) == 0) {
      unint64_t v10 = (const UTextFuncs *)&__CFStringFuncs;
    }
    v8->pFuncs = v10;
    if (*(int *)status <= 0)
    {
      if (a3)
      {
        unint64_t v12 = *(const __CFAttributedString **)(a2 + 72);
        if ((v11 & 0x10) != 0) {
          MutableCFStringRef Copy = CFAttributedStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v12);
        }
        else {
          MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (CFStringRef)v12);
        }
        v4->CFRunLoopSourceContext context = MutableCopy;
        v4->providerProperties |= 0x28u;
      }

      else
      {
        v8->CFRunLoopSourceContext context = *(const void **)(a2 + 72);
      }
    }
  }

  return v4;
}

CFIndex __CFAttributedStringLength(uint64_t a1)
{
  return CFAttributedStringGetLength(*(CFAttributedStringRef *)(a1 + 72));
}

uint64_t __CFAttributedStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));
  return doAccess(a1, a2, a3, String);
}

uint64_t __CFAttributedStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));
  return doExtract(a2, a3, a4, a5, a6, String);
}

CFIndex __CFAttributedStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  unint64_t v12 = *(const __CFAttributedString **)(a1 + 72);
  String = CFAttributedStringGetString(v12);
  CFIndex Length = CFAttributedStringGetLength(v12);
  if (*a6 > 0) {
    return 0LL;
  }
  CFIndex v16 = Length;
  if (!a4 && a5)
  {
    CFIndex v15 = 0LL;
    int v17 = 1;
LABEL_8:
    *a6 = v17;
    return v15;
  }

  if (a2 > a3)
  {
    CFIndex v15 = 0LL;
    int v17 = 8;
    goto LABEL_8;
  }

  CFIndex v18 = __pinIndex(a2, Length, String, 1, 1);
  CFIndex v19 = __pinIndex(a3, v16, String, 0, 1);
  MutableWithExternalCharactersNoCFStringRef Copy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }

  else
  {
    MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a4,  a5,  a5,  (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }

  v23.CFIndex length = v19 - v18;
  v23.CFIndex location = v18;
  CFAttributedStringReplaceString(v12, v23, MutableWithExternalCharactersNoCopy);
  if (*(void *)(a1 + 16) > v18 || *(void *)(a1 + 48) != *(void *)(a1 + 88))
  {
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
    *(void *)(a1 + 44) = 0LL;
    *(void *)(a1 + 36) = 0LL;
    *(_DWORD *)(a1 + 52) = 0;
  }

  CFIndex v15 = CFAttributedStringGetLength(v12) - v16;
  int8x8_t v21 = CFAttributedStringGetString(v12);
  doAccess(a1, v15 + v19, 1, v21);
  return v15;
}

uint64_t __CFAttributedStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  unint64_t v12 = *(const __CFAttributedString **)(a1 + 72);
  String = CFAttributedStringGetString(v12);
  uint64_t result = CFAttributedStringGetLength(v12);
  if (*a6 <= 0)
  {
    if (a2 > a3 || (CFIndex v15 = result, a2 < a4) && a4 < a3)
    {
      *a6 = 8;
      return result;
    }

    CFIndex v16 = __pinIndex(a2, result, String, 1, 1);
    CFIndex v17 = __pinIndex(a3, v15, String, 0, 1);
    CFIndex v18 = v17 - v16;
    v26.CFIndex location = v16;
    v26.CFIndex length = v17 - v16;
    CFIndex v19 = CFAttributedStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v26);
    CFAttributedStringBeginEditing(v12);
    v24.CFIndex location = a4;
    v24.CFIndex length = 0LL;
    CFAttributedStringReplaceAttributedString(v12, v24, v19);
    CFRelease(v19);
    if (a5)
    {
      if (v16 > a4) {
        CFIndex v16 = v17;
      }
      v25.CFIndex location = v16;
      v25.CFIndex length = v18;
      CFAttributedStringReplaceString(v12, v25, &stru_1899EF170);
    }

    CFAttributedStringEndEditing(v12);
    if (v16 >= a4 || a5 == 0) {
      CFIndex v21 = a4;
    }
    else {
      CFIndex v21 = v16;
    }
    if (*(void *)(a1 + 48) == *(void *)(a1 + 88))
    {
      CFIndex v23 = *(void *)(a1 + 16);
      if (a5)
      {
        if (v23 <= v21) {
          goto LABEL_19;
        }
      }

      else if (v23 <= a4)
      {
        goto LABEL_19;
      }
    }

    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
    *(void *)(a1 + 44) = 0LL;
    *(void *)(a1 + 36) = 0LL;
    *(_DWORD *)(a1 + 52) = 0;
LABEL_19:
    unint64_t v22 = CFAttributedStringGetString(v12);
    return doAccess(a1, v18 + a4, 1, v22);
  }

  return result;
}

void __CFStringClose(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 80) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
  }

  if ((*(_BYTE *)(a1 + 8) & 0x20) != 0)
  {
    CFRelease(*(CFTypeRef *)(a1 + 72));
    *(void *)(a1 + 72) = 0LL;
  }

uint64_t doAccess(uint64_t a1, uint64_t a2, int a3, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v9 = Length;
  if (Length >= a2) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = Length;
  }
  if (a2 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0LL;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  if (a3)
  {
    if (v11 >= v12 || (uint64_t v13 = *(void *)(a1 + 32), v11 < v13))
    {
      if (v11 >= Length && v12 == Length)
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
        return result;
      }

      goto LABEL_21;
    }

    int v17 = v11 - v13;
LABEL_30:
    *(_DWORD *)(a1 + 40) = v17;
    return 1LL;
  }

  if (v11 <= v12)
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (v11 > v16)
    {
      int v17 = v11 - v16;
      goto LABEL_30;
    }
  }

  if (!v11 && !*(void *)(a1 + 32))
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 40) = 0;
    return result;
  }

CFIndex __pinIndex(CFIndex idx, CFIndex a2, CFStringRef theString, int a4, int a5)
{
  if (idx < 0) {
    return 0LL;
  }
  if (idx <= a2)
  {
    if (idx < a2 && idx && a5 && (CFStringGetCharacterAtIndex(theString, idx) & 0xFC00) == 0xDC00)
    {
      int v8 = CFStringGetCharacterAtIndex(theString, idx - 1) & 0xFC00;
      if (a4) {
        CFIndex v9 = idx - 1;
      }
      else {
        CFIndex v9 = idx + 1;
      }
      if (v8 == 55296) {
        return v9;
      }
      else {
        return idx;
      }
    }

    else
    {
      return idx;
    }
  }

  return a2;
}

uint64_t doExtract(CFIndex a1, CFIndex a2, UniChar *a3, int a4, int *a5, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (*a5 > 0) {
    return 0LL;
  }
  if (a4 < 0 || (CFIndex v14 = Length, !a3) && a4)
  {
    uint64_t v13 = 0LL;
    int v15 = 1;
LABEL_7:
    *a5 = v15;
    return v13;
  }

  if (a1 < 0 || a2 < a1 || a2 - a1 >= 0x80000000LL)
  {
    uint64_t v13 = 0LL;
    int v15 = 8;
    goto LABEL_7;
  }

  CFIndex v17 = __pinIndex(a1, Length, theString, 1, 1);
  uint64_t v13 = __pinIndex(a2, v14, theString, 1, 1) - v17;
  if (a3 && a4)
  {
    else {
      int v18 = v13;
    }
    v19.CFIndex length = v18;
    v19.CFIndex location = v17;
    CFStringGetCharacters(theString, v19, a3);
  }

  if (*a5 <= 0)
  {
    if (v13 < 1 || v13 >= a4)
    {
      if (v13 == a4) {
        int v15 = -124;
      }
      else {
        int v15 = 15;
      }
    }

    else
    {
      int v15 = 0;
      a3[v13] = 0;
      if (*a5 != -124) {
        return v13;
      }
    }

    goto LABEL_7;
  }

  return v13;
}

CFIndex __CFStringLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 72));
}

uint64_t __CFStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  return doAccess(a1, a2, a3, *(CFStringRef *)(a1 + 72));
}

uint64_t __CFStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  return doExtract(a2, a3, a4, a5, a6, *(CFStringRef *)(a1 + 72));
}

CFIndex __CFStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  uint64_t v12 = *(__CFString **)(a1 + 72);
  CFIndex Length = CFStringGetLength(v12);
  if (*a6 > 0) {
    return 0LL;
  }
  CFIndex v15 = Length;
  if (!a4 && a5)
  {
    CFIndex v14 = 0LL;
    int v16 = 1;
LABEL_8:
    *a6 = v16;
    return v14;
  }

  if (a2 > a3)
  {
    CFIndex v14 = 0LL;
    int v16 = 8;
    goto LABEL_8;
  }

  CFIndex v17 = __pinIndex(a2, Length, v12, 1, 1);
  CFIndex v18 = __pinIndex(a3, v15, v12, 0, 1);
  MutableWithExternalCharactersNoCFStringRef Copy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }

  else
  {
    MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a4,  a5,  a5,  (CFAllocatorRef)&__kCFAllocatorNull);
    *(void *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }

  v21.CFIndex length = v18 - v17;
  v21.CFIndex location = v17;
  CFStringReplace(v12, v21, MutableWithExternalCharactersNoCopy);
  if (*(void *)(a1 + 16) > v17 || *(void *)(a1 + 48) != *(void *)(a1 + 88))
  {
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
    *(void *)(a1 + 44) = 0LL;
    *(void *)(a1 + 36) = 0LL;
    *(_DWORD *)(a1 + 52) = 0;
  }

  CFIndex v14 = CFStringGetLength(v12) - v15;
  doAccess(a1, v14 + v18, 1, v12);
  return v14;
}

CFIndex __CFStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  uint64_t v12 = *(__CFString **)(a1 + 72);
  CFIndex result = CFStringGetLength(v12);
  if (*a6 <= 0)
  {
    if (a2 > a3 || (CFIndex v14 = result, a2 < a4) && a4 < a3)
    {
      *a6 = 8;
      return result;
    }

    CFIndex v15 = __pinIndex(a2, result, v12, 1, 1);
    CFIndex v16 = __pinIndex(a3, v14, v12, 0, 1);
    v21.CFIndex location = v15;
    v21.CFIndex length = v16 - v15;
    CFIndex v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v21);
    CFStringInsert(v12, a4, v17);
    CFRelease(v17);
    if (a5)
    {
      if (v15 <= a4) {
        CFIndex v18 = v15;
      }
      else {
        CFIndex v18 = v16;
      }
      v20.CFIndex location = v18;
      v20.CFIndex length = v16 - v15;
      CFStringDelete(v12, v20);
      if (*(void *)(a1 + 48) == *(void *)(a1 + 88))
      {
        CFIndex v19 = v18 >= a4 ? a4 : v18;
        if (*(void *)(a1 + 16) <= v19) {
          return doAccess(a1, v16 - v15 + a4, 1, v12);
        }
      }
    }

    else if (*(void *)(a1 + 48) == *(void *)(a1 + 88) && *(void *)(a1 + 16) <= a4)
    {
      return doAccess(a1, v16 - v15 + a4, 1, v12);
    }

    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 36) = 0LL;
    *(void *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
    *(_DWORD *)(a1 + 44) = 0;
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 56), 8) = 0LL;
    return doAccess(a1, v16 - v15 + a4, 1, v12);
  }

  return result;
}

Boolean CFStringIsEncodingAvailable(CFStringEncoding encoding)
{
  uint64_t v1 = *(void *)&encoding;
  Boolean result = 1;
  if ((int)v1 > 134217983)
  {
    if ((int)v1 > 335544575)
    {
      if ((_DWORD)v1 == 335544576 || (_DWORD)v1 == 402653440) {
        return result;
      }
      int v3 = 469762304;
    }

    else
    {
      if ((_DWORD)v1 == 134217984 || (_DWORD)v1 == 201326848) {
        return result;
      }
      int v3 = 268435712;
    }

    if ((_DWORD)v1 == v3) {
      return result;
    }
    return CFStringEncodingIsValidEncoding(v1);
  }

  if ((int)v1 <= 1535)
  {
    if (!(_DWORD)v1 || (_DWORD)v1 == 256 || (_DWORD)v1 == 1280) {
      return result;
    }
    return CFStringEncodingIsValidEncoding(v1);
  }

  if ((_DWORD)v1 != 1536 && (_DWORD)v1 != 2817 && (_DWORD)v1 != 3071) {
    return CFStringEncodingIsValidEncoding(v1);
  }
  return result;
}

CFStringRef CFStringGetNameOfEncoding(CFStringEncoding encoding)
{
  LODWORD(v1) = encoding;
  os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  if (CFStringGetNameOfEncoding_mappingTable)
  {
    CFTypeRef Value = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable,  (const void *)v1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
    if (Value) {
      return Value;
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  }

  Name = __CFStringEncodingGetName(v1);
  if (Name)
  {
    CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, Name, 0x600u);
    if (v4)
    {
      CFStringRef v5 = v4;
      os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
      if (CFStringGetNameOfEncoding_mappingTable)
      {
        unint64_t v1 = v1;
        CFTypeRef Value = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable,  (const void *)v1);
        if (Value)
        {
LABEL_13:
          os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
          CFRelease(v5);
          return Value;
        }

        CFMutableStringRef Mutable = (__CFDictionary *)CFStringGetNameOfEncoding_mappingTable;
      }

      else
      {
        CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
        CFStringGetNameOfEncoding_mappingTable = (uint64_t)Mutable;
        unint64_t v1 = v1;
      }

      CFDictionaryAddValue(Mutable, (const void *)v1, v5);
      CFTypeRef Value = v5;
      goto LABEL_13;
    }
  }

  return 0LL;
}

CFStringEncoding CFStringConvertIANACharSetNameToEncoding(CFStringRef theString)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  CFStringEncoding v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    CFStringEncoding v2 = __CFDefaultEightBitStringEncoding;
  }

  CStringPtr = CFStringGetCStringPtr(theString, v2);
  if (!CStringPtr)
  {
    CFStringEncoding v4 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      CFStringEncoding v4 = __CFDefaultEightBitStringEncoding;
    }

    CStringPtr = buffer;
    if (!CFStringGetCString(theString, buffer, 100LL, v4)) {
      return -1;
    }
  }

  CFStringEncoding result = __CFStringEncodingGetFromCanonicalName(CStringPtr);
  if (result == -1)
  {
    CFStringEncoding result = __CFStringEncodingGetFromICUName(CStringPtr);
    if (result == -1)
    {
      if (!strncasecmp(CStringPtr, "ms950", 5uLL)) {
        return __CFStringEncodingGetFromCanonicalName("cp950");
      }
      return -1;
    }
  }

  return result;
}

CFStringRef CFStringConvertEncodingToIANACharSetName(CFStringEncoding encoding)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  CFStringEncoding v2 = (const void *)encoding;
  os_unfair_lock_lock_with_options();
  if (!CFStringConvertEncodingToIANACharSetName_mappingTable
    || (CFTypeRef Value = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)CFStringConvertEncodingToIANACharSetName_mappingTable,  v2)) == 0LL)
  {
    if (__CFStringEncodingGetCanonicalName(encoding, cStr, 100LL))
    {
      CFTypeRef Value = CFStringCreateWithCString(0LL, cStr, 0x600u);
      if (Value)
      {
        CFMutableStringRef Mutable = (__CFDictionary *)CFStringConvertEncodingToIANACharSetName_mappingTable;
        if (!CFStringConvertEncodingToIANACharSetName_mappingTable)
        {
          CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, 0LL, &kCFTypeDictionaryValueCallBacks);
          CFStringConvertEncodingToIANACharSetName_mappingTable = (uint64_t)Mutable;
        }

        CFDictionaryAddValue(Mutable, v2, Value);
        CFRelease(Value);
      }
    }

    else
    {
      CFTypeRef Value = 0LL;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CFStringConvertEncodingToIANACharSetName_lock);
  return Value;
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  if (encoding == 134217984)
  {
    *(void *)&encoding = 4LL;
    goto LABEL_36;
  }

  if (encoding == 1536)
  {
    *(void *)&encoding = 1LL;
    goto LABEL_36;
  }

  CFStringEncoding v1 = encoding & 0xFFF;
  if (v1 <= 0x4FF)
  {
    if ((encoding & 0xFFF) > 0x200)
    {
      switch(v1)
      {
        case 0x201u:
          *(void *)&encoding = 5LL;
          goto LABEL_36;
        case 0x202u:
          *(void *)&encoding = 9LL;
          goto LABEL_36;
        case 0x420u:
          *(void *)&encoding = 8LL;
          goto LABEL_36;
      }
    }

    else
    {
      if ((encoding & 0xFFF) == 0)
      {
        *(void *)&encoding = 30LL;
        goto LABEL_36;
      }

      if (v1 == 33)
      {
        *(void *)&encoding = 6LL;
        goto LABEL_36;
      }

      if (v1 == 256 && encoding == 256)
      {
        *(void *)&encoding = 10LL;
        goto LABEL_36;
      }
    }

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  if (encoding == 4) {
    return 134217984;
  }
  if (encoding - 1 <= 0xE) {
    return word_180CA4D92[encoding - 1];
  }
  CFStringEncoding v2 = encoding & 0x7FFFFFFF;
  if ((encoding & 0x80000000) == 0LL) {
    CFStringEncoding v2 = -1;
  }
  if (encoding == 21) {
    CFStringEncoding v2 = 2080;
  }
  if (encoding == 30) {
    return 0;
  }
  else {
    return v2;
  }
}

UInt32 CFStringConvertEncodingToWindowsCodepage(CFStringEncoding encoding)
{
  UInt32 result = __CFStringEncodingGetWindowsCodePage(encoding);
  if (!result) {
    return -1;
  }
  return result;
}

CFStringEncoding CFStringConvertWindowsCodepageToEncoding(UInt32 codepage)
{
  return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)codepage);
}

uint64_t _CFCompareStringsWithLocale( UniChar *buffer, int64_t a2, int64_t a3, UniChar *a4, int64_t a5, int64_t a6, unint64_t a7, const __CFLocale *a8)
{
  uint64_t v136 = *MEMORY[0x1895F89C0];
  if (!_CFCompareStringsWithLocale_alnumBMP)
  {
    _CFCompareStringsWithLocale_alnumBMP = CFUniCharGetBitmapPtrForPlane(0xAu, 0);
    _CFCompareStringsWithLocale_nonBaseBMP = CFUniCharGetBitmapPtrForPlane(8u, 0);
    _CFCompareStringsWithLocale_punctBMP = CFUniCharGetBitmapPtrForPlane(0xBu, 0);
    _CFCompareStringsWithLocale_controlBMP = CFUniCharGetBitmapPtrForPlane(0x6Cu, 0);
  }

  uint64_t v15 = a2;
  if (a2 >= 1) {
    uint64_t v15 = __extendLocationBackward( a2 - 1,  buffer,  _CFCompareStringsWithLocale_nonBaseBMP,  _CFCompareStringsWithLocale_punctBMP);
  }
  uint64_t v16 = a5;
  if (a5 >= 1) {
    uint64_t v16 = __extendLocationBackward( a5 - 1,  a4,  _CFCompareStringsWithLocale_nonBaseBMP,  _CFCompareStringsWithLocale_punctBMP);
  }
  uint64_t v17 = _CFGetTSD(9u);
  uint64_t v116 = _CFGetTSD(8u);
  uint64_t v117 = v17;
  CFTypeRef cf = a8;
  uint64_t v119 = buffer;
  if ((const __CFLocale *)v116 == a8)
  {
    int v126 = 1;
    uint64_t Collator = v17;
    if (v15 < 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  os_unfair_lock_lock_with_options();
  if ((const __CFLocale *)__CFDefaultCollatorLocale == a8)
  {
    CFIndex v19 = 0LL;
    BOOL v20 = 1;
    goto LABEL_23;
  }

  CFLocaleRef v18 = CFLocaleCopyCurrent();
  if (v18 == a8)
  {
    CFRange v21 = a8;
    BOOL v20 = a8 == 0LL;
    if (v21)
    {
      uint64_t v22 = (const void *)__CFDefaultCollatorLocale;
      CFIndex v19 = v21;
      if ((const __CFLocale *)__CFDefaultCollatorLocale != v21)
      {
        uint64_t v23 = __CFDefaultCollatorsCount;
        if (__CFDefaultCollatorsCount >= 1)
        {
          do
          {
            __CFDefaultCollatorsCFIndex Count = v23 - 1;
            ucol_close();
            uint64_t v23 = __CFDefaultCollatorsCount;
          }

          while (__CFDefaultCollatorsCount > 0);
          uint64_t v22 = (const void *)__CFDefaultCollatorLocale;
        }

        CFIndex v19 = cf;
        if (v22) {
          CFRelease(v22);
        }
        BOOL v20 = 0;
        __CFDefaultCollatorCFLocaleRef Locale = (uint64_t)CFRetain(cf);
      }
    }

    else
    {
      CFIndex v19 = 0LL;
    }

uint64_t __extendLocationBackward(uint64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1;
  if (a1 >= 1)
  {
    uint64_t v8 = -a1;
    for (uint64_t i = a1 + 64; ; --i)
    {
      else {
        uint64_t v10 = v4;
      }
      else {
        uint64_t v11 = v4;
      }
      uint64_t v12 = *((void *)buffer + 20);
      if (v12 <= v4)
      {
        UniChar v14 = 0;
      }

      else
      {
        uint64_t v13 = *((void *)buffer + 17);
        if (v13)
        {
          UniChar v14 = *(_WORD *)(v13 + 2 * (v4 + *((void *)buffer + 19)));
        }

        else
        {
          uint64_t v15 = *((void *)buffer + 18);
          if (v15)
          {
            UniChar v14 = *(char *)(v15 + *((void *)buffer + 19) + v4);
          }

          else
          {
            if (*((void *)buffer + 22) <= v4 || (uint64_t v16 = *((void *)buffer + 21), v16 > v4))
            {
              uint64_t v17 = -v11;
              uint64_t v18 = v11 + v8;
              uint64_t v19 = i - v11;
              uint64_t v20 = v4 + v17;
              uint64_t v21 = v20 + 64;
              if (v20 + 64 >= v12) {
                uint64_t v21 = *((void *)buffer + 20);
              }
              *((void *)buffer + 21) = v20;
              *((void *)buffer + 22) = v21;
              if (v12 >= v19) {
                uint64_t v12 = v19;
              }
              v32.CFIndex length = v12 + v18;
              v32.CFIndex location = v20 + *((void *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              uint64_t v16 = *((void *)buffer + 21);
            }

            UniChar v14 = buffer[v4 - v16];
          }
        }

        if (v14 >> 10 == 55)
        {
          uint64_t v22 = *((void *)buffer + 20);
          if (v22 >= v4)
          {
            uint64_t v23 = *((void *)buffer + 17);
            if (v23)
            {
              uint64_t v24 = (UniChar *)(v23 + 2 * (v4 + *((void *)buffer + 19)));
              goto LABEL_27;
            }

            uint64_t v26 = *((void *)buffer + 18);
            if (v26)
            {
              unsigned __int16 v25 = *(char *)(v26 + *((void *)buffer + 19) + v4 - 1);
            }

            else
            {
              if (*((void *)buffer + 22) < v4 || (uint64_t v28 = *((void *)buffer + 21), v28 >= v4))
              {
                uint64_t v29 = v4 - v10;
                uint64_t v30 = v4 - v10 + 64;
                if (v30 >= v22) {
                  uint64_t v30 = *((void *)buffer + 20);
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v30;
                if (v22 >= i - v10) {
                  uint64_t v22 = i - v10;
                }
                v33.CFIndex length = v22 + v10 + v8;
                v33.CFIndex location = v29 + *((void *)buffer + 19);
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                uint64_t v28 = *((void *)buffer + 21);
              }

              uint64_t v24 = &buffer[v4 - v28];
LABEL_27:
              unsigned __int16 v25 = *(v24 - 1);
            }

            if (v25 >> 10 == 54) {
              return v4;
            }
          }
        }
      }

      if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
      {
      }

      else if (!a4 {
             || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
      }
             || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a4 + (v14 >> 3))) == 0)
      {
        return v4;
      }

      ++v8;
      if (v4-- <= 1) {
        return 0LL;
      }
    }
  }

  return v4;
}

uint64_t __CFStringCreateCollator(const __CFLocale *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  CFTypeRef Value = (const __CFString *)CFLocaleGetValue(a1, @"locale:collator id");
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)UniChar buffer = 0u;
  __int128 v5 = 0u;
  CFStringGetCString(Value, buffer, 128LL, 0x600u);
  uint64_t v2 = ucol_open();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  return v2;
}

uint64_t __CompareTextDefault( uint64_t a1, int a2, unsigned int a3, unsigned __int16 *a4, unint64_t a5, unsigned __int16 *a6, unint64_t a7, BOOL *a8, int *a9)
{
  char v14 = a3;
  *a8 = 1;
  *a9 = 0;
  int v15 = ucol_strcoll();
  if (v15)
  {
    if (v15 == -1) {
      int v16 = -2;
    }
    else {
      int v16 = 2;
    }
LABEL_8:
    *a9 = v16;
    goto LABEL_10;
  }

  int v16 = *a9;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    int v20 = ucol_strcoll();
    if (v20)
    {
      if (v20 == -1) {
        int v21 = -1;
      }
      else {
        int v21 = 1;
      }
      *a9 = v21;
    }

    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    int v16 = *a9;
    if ((v14 & 0x10) == 0 && !v16)
    {
      ucol_openElements();
      uint64_t v25 = ucol_openElements();
      unint64_t v42 = a7;
      unsigned int v26 = ucol_next();
      int v27 = ucol_next();
      uint64_t v44 = v25;
      int v43 = 0;
      if (v26 == -1)
      {
        int v16 = 0;
        goto LABEL_72;
      }

      int v28 = v27;
      int v16 = 0;
      if (v27 == -1)
      {
LABEL_72:
        ucol_closeElements();
        ucol_closeElements();
        a7 = v42;
        if (!v16) {
          int v16 = v43;
        }
        goto LABEL_8;
      }

      unint64_t v41 = a5;
      int v43 = 0;
      int v29 = 0;
      int v30 = 0;
      uint64_t v31 = v44;
      while (1)
      {
        int v46 = MEMORY[0x186E0481C]();
        int v32 = MEMORY[0x186E0481C](v31);
        int v45 = v32;
        if ((v28 ^ v26) <= 0xFF)
        {
          if (v26 < 0x10000)
          {
            int v33 = v46 - v29;
            int v29 = v46;
            BOOL v34 = v33 == v32 - v30;
            if (v33 > v32 - v30) {
              int v35 = -1;
            }
            else {
              int v35 = 1;
            }
            if (v34) {
              int v35 = 0;
            }
            int v36 = v43;
            if (v43) {
              int v35 = v43;
            }
            if ((v26 & 0xFF00) != 0) {
              int v36 = v35;
            }
            int v43 = v36;
            goto LABEL_61;
          }

          int v37 = v26;
          int v38 = v28;
          if (v37 != v38)
          {
            if (v37 < v38) {
              int v16 = -1;
            }
            else {
              int v16 = 1;
            }
LABEL_71:
            a5 = v41;
            goto LABEL_72;
          }
        }

        int v29 = v46;
LABEL_61:
        unsigned int v26 = ucol_next();
        uint64_t v31 = v44;
        int v39 = ucol_next();
        int v28 = v39;
        BOOL v40 = v26 == -1 || v39 == -1;
        int v30 = v45;
        if (v40)
        {
          int v16 = 0;
          goto LABEL_71;
        }
      }
    }
  }

uint64_t __extendLocationForward( int64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6)
{
  while (1)
  {
    if (a1 < 0 || (int64_t v12 = *((void *)buffer + 20), v12 <= a1))
    {
      UniChar v14 = 0;
      goto LABEL_6;
    }

    uint64_t v13 = *((void *)buffer + 17);
    if (v13)
    {
      UniChar v14 = *(_WORD *)(v13 + 2 * (*((void *)buffer + 19) + a1));
    }

    else
    {
      uint64_t v15 = *((void *)buffer + 18);
      if (v15)
      {
        UniChar v14 = *(char *)(v15 + *((void *)buffer + 19) + a1);
      }

      else
      {
        if (*((void *)buffer + 22) <= a1 || (int64_t v16 = *((void *)buffer + 21), v16 > a1))
        {
          int64_t v17 = a1 - 4;
          if (v17 + 64 < v12) {
            int64_t v12 = v17 + 64;
          }
          *((void *)buffer + 21) = v17;
          *((void *)buffer + 22) = v12;
          v31.CFIndex location = *((void *)buffer + 19) + v17;
          v31.CFIndex length = v12 - v17;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v31, buffer);
          int64_t v16 = *((void *)buffer + 21);
        }

        UniChar v14 = buffer[a1 - v16];
      }
    }

    if (v14 >> 10 == 54)
    {
      int64_t v18 = a1 + 1;
      int64_t v19 = *((void *)buffer + 20);
      if (v19 > a1 + 1)
      {
        uint64_t v20 = *((void *)buffer + 17);
        if (v20)
        {
          UniChar v21 = *(_WORD *)(v20 + 2 * (*((void *)buffer + 19) + v18));
        }

        else
        {
          uint64_t v22 = *((void *)buffer + 18);
          if (v22)
          {
            UniChar v21 = *(char *)(v22 + *((void *)buffer + 19) + v18);
          }

          else
          {
            if (*((void *)buffer + 22) <= v18 || (int64_t v23 = *((void *)buffer + 21), v23 > v18))
            {
              int64_t v24 = a1 - 3;
              if (v24 + 64 < v19) {
                int64_t v19 = v24 + 64;
              }
              *((void *)buffer + 21) = v24;
              *((void *)buffer + 22) = v19;
              v32.CFIndex location = *((void *)buffer + 19) + v24;
              v32.CFIndex length = v19 - v24;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              int64_t v23 = *((void *)buffer + 21);
            }

            UniChar v21 = buffer[v18 - v23];
          }
        }

        if (v21 >> 10 == 55) {
          break;
        }
      }
    }

void __collatorFinalize(uint64_t a1)
{
  uint64_t v2 = (const void *)_CFGetTSD(8u);
  _CFSetTSD(9u, 0LL, 0LL);
  _CFSetTSD(8u, 0LL, 0LL);
  _CFSetTSD(0x11u, 0LL, 0LL);
  os_unfair_lock_lock_with_options();
  uint64_t v3 = __CFDefaultCollatorsCount;
  if ((const void *)__CFDefaultCollatorLocale == v2 && __CFDefaultCollatorsCount <= 7)
  {
    ++__CFDefaultCollatorsCount;
    __CFDefaultCollators[v3] = a1;
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    if (v2) {
LABEL_8:
    }
      CFRelease(v2);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    if (a1) {
      ucol_close();
    }
    if (v2) {
      goto LABEL_8;
    }
  }

uint64_t __CFStartSearchPathEnumeration()
{
  return sysdir_start_search_path_enumeration_private();
}

uint64_t __CFGetNextSearchPathEnumeration(uint64_t a1, char *a2, int64_t a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a3 > 1023)
  {
    return MEMORY[0x186E04540](a1, a2);
  }

  else
  {
    unsigned int v5 = MEMORY[0x186E04540](a1, __source);
    strlcpy(a2, __source, a3);
  }

  return v5;
}

__CFArray *CFCopySearchPathForDirectoriesInDomains(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t started = sysdir_start_search_path_enumeration_private();
  uint64_t v6 = MEMORY[0x186E04540](started, __s);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    size_t v8 = -1LL;
    do
    {
      __int128 v9 = __s;
      if (a3 && __s[0] == 126)
      {
        if ((v8 & 0x8000000000000000LL) != 0)
        {
          __int128 v10 = CFCopyHomeDirectoryURLForUser(0LL);
          if (v10)
          {
            __int128 v11 = v10;
            CFURLGetFileSystemRepresentation((CFURLRef)v10, 1u, buffer, 1026LL);
            size_t v8 = strlen((const char *)buffer);
            CFRelease(v11);
          }
        }

        if (strlen(__s) + v8 > 0x401) {
          goto LABEL_12;
        }
        __int128 v9 = (const char *)buffer;
        buffer[v8] = 0;
        __strlcat_chk();
      }

      size_t v12 = strlen(v9);
      CFURLRef v13 = CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)v9,  v12,  1u);
      if (v13)
      {
        CFURLRef v14 = v13;
        CFArrayAppendValue(Mutable, v13);
        CFRelease(v14);
      }

CFURLRef _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser( const __CFString *a1, const void *a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  bzero(buffer, 0x400uLL);
  if (a1)
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    if (!CStringPtr)
    {
      CFStringEncoding FastestEncoding = CFStringGetFastestEncoding(a1);
      CStringPtr = buffer;
      if (!CFStringGetCString(a1, buffer, 1024LL, FastestEncoding)) {
        CStringPtr = 0LL;
      }
    }
  }

  else
  {
    CStringPtr = 0LL;
  }

  uint64_t v15 = 0LL;
  int64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  xpc_object_t v18 = xpc_dictionary_create(0LL, 0LL, 0LL);
  int current_persona = voucher_get_current_persona();
  uint64_t v42 = 0LL;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v37 = 0u;
  __int128 v36 = 0u;
  __int128 v35 = 0u;
  __int128 v34 = 0u;
  __int128 v33 = 0u;
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  __int128 v30 = 0u;
  __int128 v29 = 0u;
  __int128 v28 = 0u;
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  __int128 v21 = 0u;
  int v20 = 2;
  if (current_persona != -1) {
    kpersona_info();
  }
  container_query_create();
  container_query_set_class();
  if (CStringPtr)
  {
    xpc_object_t v7 = xpc_string_create(CStringPtr);
    container_query_set_identifiers();
    xpc_release(v7);
  }

  container_query_set_persona_unique_string();
  container_query_operation_set_flags();
  container_query_set_uid();
  if ((container_query_iterate_results_sync() & 1) == 0)
  {
    container_query_get_last_error();
    size_t v8 = (void *)container_error_copy_unlocalized_description();
    __int128 v9 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1( (uint64_t)CStringPtr,  (uint64_t)v8,  v9);
    }
    free(v8);
    xpc_release((xpc_object_t)v16[3]);
    v16[3] = 0LL;
  }

  container_query_free();
  __int128 v10 = (const __CFArray *)v16[3];
  _Block_object_dispose(&v15, 8);
  if (!v10) {
    return 0LL;
  }
  __int128 v11 = _CFXPCCreateCFObjectFromXPCObject(v10);
  xpc_release(v10);
  if (!v11) {
    return 0LL;
  }
  CFTypeRef Value = (const __CFString *)CFDictionaryGetValue(v11, a2);
  if (Value) {
    CFURLRef v13 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value, kCFURLPOSIXPathStyle, 1u);
  }
  else {
    CFURLRef v13 = 0LL;
  }
  CFRelease(v11);
  return v13;
}

void sub_180B1CDE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

CFURLRef _CFCreateContainerURLForSecurityApplicationGroupIdentifier(const void *a1)
{
  return _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser(0LL, a1);
}

unint64_t *__NSOrderedSetM_new(id *a1, unint64_t a2, char a3)
{
  v16[1] = *MEMORY[0x1895F89C0];
  UInt32 result = (unint64_t *)CFBasicHashCreate((uint64_t)&__kCFAllocatorSystemDefault, 0x7000u, __NSOrderedSetMCB);
  if (result)
  {
    xpc_object_t v7 = result;
    v16[0] = 0LL;
    size_t v8 = _CFCreateArrayStorage(a2, 0, v16);
    if (v8)
    {
      __int128 v9 = v8;
      uint64_t v10 = 0LL;
      if (a1 && a2)
      {
        uint64_t v10 = 0LL;
        do
        {
          if (CFBasicHashAddValue((uint64_t)v7, (unint64_t)*a1, (uint64_t)*a1))
          {
            if ((a3 & 1) == 0) {
              id v11 = *a1;
            }
            v9[v10++] = *a1;
          }

          ++a1;
          --a2;
        }

        while (a2);
      }

      size_t v12 = objc_alloc(&OBJC_CLASS___NSMutableArray);
      uint64_t v13 = -[NSArray _initByAdoptingBuffer:count:size:](v12, "_initByAdoptingBuffer:count:size:", v9, v10, v16[0]);
      if (v13)
      {
        CFURLRef v14 = (void *)v13;
        uint64_t v15 = (objc_class *)objc_opt_self();
        UInt32 result = (unint64_t *)__CFAllocateObject(v15, 0LL);
        if (result)
        {
          result[2] = (unint64_t)v7;
          result[3] = (unint64_t)v14;
          atomic_store(0LL, result + 1);
          return result;
        }

        CFRelease(v7);

        return 0LL;
      }

      if ((a3 & 1) == 0 && ((v10 - 1) & 0x8000000000000000LL) == 0)
      {
        do

        while (v10);
      }

      free(v9);
    }

    CFRelease(v7);
    return 0LL;
  }

  return result;
}

void __RELEASE_OBJECTS_IN_THE_ORDEREDSET__(uint64_t a1, int a2)
{
  uint64_t v2 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  if (a2 == 1) {
    uint64_t v2 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  uint64_t v3 = a1 + *v2;
  uint64_t v4 = *(void **)(v3 + 8);
  if (*(void *)v3)
  {
    unsigned int v5 = *(void **)(v3 + 8);
    CFRelease(*(CFTypeRef *)v3);
    uint64_t v4 = v5;
  }
}

__n128 cow_copy_instance_0(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  if (a2 == 1) {
    unsigned int v5 = &OBJC_IVAR_____NSOrderedSetM_cow;
  }
  else {
    unsigned int v5 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  }
  if (a2 == 1) {
    uint64_t v6 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  else {
    uint64_t v6 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  uint64_t v8 = *v6;
  if (a4 == 1)
  {
    uint64_t v4 = &OBJC_IVAR_____NSOrderedSetM_cow;
    __int128 v9 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }

  else
  {
    __int128 v9 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  }

  atomic_store(v7, (unint64_t *)(a3 + *v4));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = [*(id *)(a1 + 24) mutableCopyWithZone:0];
  if (result)
  {
    uint64_t v10 = result;
    uint64_t result = CFBasicHashCreateCopy(0LL, v2, v4, v5, v6, v7, v8, v9);
    if (result)
    {
      *(void *)(a1 + 16) = result;
      *(void *)(a1 + 24) = v10;
      return 1LL;
    }
  }

  return result;
}

uint64_t cow_set_cow_0(uint64_t result, unint64_t a2)
{
  return result;
}

uint64_t __NSOrderedSetEquateKeys(void *a1, uint64_t a2)
{
  return [a1 isEqual:a2];
}

void __CFTreeDeallocate(CFTypeRef cf)
{
  char v2 = atomic_load((unint64_t *)cf + 1);
  int v3 = v2 & 3;
  if (v3)
  {
    if (v3 == 1) {
      uint64_t v4 = (__int128 *)&__kCFTypeTreeCallBacks;
    }
    else {
      uint64_t v4 = (__int128 *)*((void *)cf + 7);
    }
  }

  else
  {
    uint64_t v4 = &__kCFNullTreeCallBacks;
  }

  uint64_t v5 = (void (*)(void))*((void *)v4 + 1);
  if (v5) {
    v5(*((void *)cf + 6));
  }
  char v6 = atomic_load((unint64_t *)cf + 1);
  if ((~v6 & 3) == 0)
  {
    uint64_t v7 = CFGetAllocator(cf);
    CFAllocatorDeallocate(v7, *((void **)cf + 7));
  }

__CFString *__CFTreeCopyDescription(unint64_t *a1)
{
  char v2 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0LL);
  char v4 = atomic_load(a1 + 1);
  int v5 = v4 & 3;
  if (v5)
  {
    if (v5 == 1) {
      char v6 = (__int128 *)&__kCFTypeTreeCallBacks;
    }
    else {
      char v6 = (__int128 *)a1[7];
    }
  }

  else
  {
    char v6 = &__kCFNullTreeCallBacks;
  }

  uint64_t v7 = (uint64_t (*)(unint64_t))*((void *)v6 + 2);
  if (!v7 || (CFStringRef v8 = (CFStringRef)v7(a1[6])) == 0LL) {
    CFStringRef v8 = CFStringCreateWithFormat(v2, 0LL, @"<CFTree context %p>", a1[6]);
  }
  ChildCFIndex Count = CFTreeGetChildCount((CFTreeRef)a1);
  CFStringAppendFormat(Mutable, 0LL, @"<CFTree %p [%p]>{children = %lu, CFRunLoopSourceContext context = %@}", a1, v2, ChildCount, v8);
  if (v8) {
    CFRelease(v8);
  }
  return Mutable;
}

CFTypeID CFTreeGetTypeID(void)
{
  return 28LL;
}

CFTreeRef CFTreeCreate(CFAllocatorRef allocator, const CFTreeContext *context)
{
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(allocator, 0x1CuLL, 48LL, 0LL, v2, v3, v4, v5);
  CFStringRef v8 = (__CFTree *)Instance;
  if (Instance)
  {
    uint64_t v9 = Instance + 1;
    unint64_t v10 = atomic_load(Instance + 1);
    while (1)
    {
      unint64_t v11 = __ldaxr(v9);
      if (v11 != v10) {
        break;
      }
      if (__stlxr(v10 & 0xFFFFFFFFFFFFFFFCLL, v9)) {
        goto LABEL_7;
      }
      int v12 = 1;
LABEL_8:
      unint64_t v10 = v11;
      if (v12)
      {
        CFTreeSetContext((CFTreeRef)Instance, context);
        return v8;
      }
    }

    __clrex();
LABEL_7:
    int v12 = 0;
    goto LABEL_8;
  }

  return v8;
}

void CFTreeSetContext(CFTreeRef tree, const CFTreeContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  uint64_t v5 = (unint64_t *)((char *)tree + 8);
  char v6 = atomic_load((unint64_t *)tree + 1);
  char v7 = atomic_load((unint64_t *)tree + 1);
  int v8 = v7 & 3;
  if (v8)
  {
    if (v8 == 1) {
      uint64_t v9 = (__int128 *)&__kCFTypeTreeCallBacks;
    }
    else {
      uint64_t v9 = (__int128 *)*((void *)tree + 7);
    }
  }

  else
  {
    uint64_t v9 = &__kCFNullTreeCallBacks;
  }

  uint64_t v10 = *((void *)tree + 6);
  unint64_t v11 = CFGetAllocator(tree);
  int v12 = v11;
  if (!context)
  {
    uint64_t copyDescription = 0LL;
    goto LABEL_19;
  }

  retain = context->retain;
  if (!retain)
  {
    if (!context->release)
    {
      uint64_t copyDescription = (uint64_t)context->copyDescription;
      if (!copyDescription) {
        goto LABEL_19;
      }
    }

CFIndex CFTreeGetChildCount(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = *((void *)tree + 4);
  if (!v3) {
    return 0LL;
  }
  CFIndex result = 0LL;
  do
  {
    uint64_t v3 = *(void *)(v3 + 24);
    ++result;
  }

  while (v3);
  return result;
}

CFTreeRef CFTreeGetParent(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 2);
}

CFTreeRef CFTreeGetNextSibling(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 3);
}

CFTreeRef CFTreeGetFirstChild(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  return (CFTreeRef)*((void *)tree + 4);
}

CFTreeRef CFTreeFindRoot(CFTreeRef tree)
{
  CFTreeRef v1 = tree;
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  do
  {
    CFTreeRef result = v1;
    CFTreeRef v1 = (CFTreeRef)*((void *)v1 + 2);
  }

  while (v1);
  return result;
}

void CFTreeGetContext(CFTreeRef tree, CFTreeContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  char v5 = atomic_load((unint64_t *)tree + 1);
  int v6 = v5 & 3;
  if (v6)
  {
    if (v6 == 1) {
      char v7 = (__int128 *)&__kCFTypeTreeCallBacks;
    }
    else {
      char v7 = (__int128 *)*((void *)tree + 7);
    }
  }

  else
  {
    char v7 = &__kCFNullTreeCallBacks;
  }

  int v8 = (void *)*((void *)tree + 6);
  context->version = 0LL;
  context->unint64_t info = v8;
  *(_OWORD *)&context->retain = *v7;
  context->uint64_t copyDescription = (CFTreeCopyDescriptionCallBack)*((void *)v7 + 2);
}

CFTreeRef CFTreeGetChildAtIndex(CFTreeRef tree, CFIndex idx)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  CFTreeRef result = (CFTreeRef)*((void *)tree + 4);
  if (result) {
    BOOL v6 = idx == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    CFIndex v7 = idx - 1;
    do
    {
      CFTreeRef result = (CFTreeRef)*((void *)result + 3);
      if (result) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      --v7;
    }

    while (!v8);
  }

  return result;
}

void CFTreeGetChildren(CFTreeRef tree, CFTreeRef *children)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  for (uint64_t i = (__CFTree *)*((void *)tree + 4); i; uint64_t i = (__CFTree *)*((void *)i + 3))
    *children++ = i;
}

void CFTreeApplyFunctionToChildren(CFTreeRef tree, CFTreeApplierFunction applier, void *context)
{
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  }
  for (uint64_t i = *((void *)tree + 4); i; uint64_t i = *(void *)(i + 24))
    ((void (*)(uint64_t, void *))applier)(i, context);
}

void CFTreePrependChild(CFTreeRef tree, CFTreeRef newChild)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  }
  CFRetain(newChild);
  *((void *)newChild + 2) = tree;
  *((void *)newChild + 3) = *((void *)tree + 4);
  if (!*((void *)tree + 4)) {
    *((void *)tree + 5) = newChild;
  }
  *((void *)tree + 4) = newChild;
}

void CFTreeAppendChild(CFTreeRef tree, CFTreeRef newChild)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (*((void *)newChild + 2))
  {
    __break(1u);
  }

  else
  {
    CFRetain(newChild);
    CFGetAllocator(tree);
    *((void *)newChild + 2) = tree;
    *((void *)newChild + 3) = 0LL;
    char v5 = (CFTreeRef *)((char *)tree + 32);
    if (*((void *)tree + 4)) {
      char v5 = (CFTreeRef *)(*((void *)tree + 5) + 24LL);
    }
    CFTreeRef *v5 = newChild;
    *((void *)tree + 5) = newChild;
  }

void CFTreeInsertSibling(CFTreeRef tree, CFTreeRef newSibling)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  CFRetain(newSibling);
  CFGetAllocator(tree);
  *((void *)newSibling + 2) = *((void *)tree + 2);
  *((void *)newSibling + 3) = *((void *)tree + 3);
  *((void *)tree + 3) = newSibling;
  uint64_t v5 = *((void *)tree + 2);
  if (v5)
  {
    if (*(CFTreeRef *)(v5 + 40) == tree) {
      *(void *)(v5 + 40) = newSibling;
    }
  }

void CFTreeRemove(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = (char *)tree + 16;
  uint64_t v4 = *((void *)tree + 2);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 32);
    if (v5 == (void *)tree)
    {
      *(void *)(v4 + 32) = *((void *)tree + 3);
      if (!*((void *)tree + 3)) {
        *(void *)(*(void *)v3 + 4CFNotificationCenterRemoveObserver(center, observer, 0LL, 0LL) = 0LL;
      }
    }

    else
    {
      while (v5)
      {
        unint64_t v6 = v5;
        uint64_t v5 = (void *)v5[3];
        if (v5 == (void *)tree)
        {
          v6[3] = *((void *)tree + 3);
          uint64_t v7 = *((void *)tree + 2);
          if (*(CFTreeRef *)(v7 + 40) == tree) {
            *(void *)(v7 + 40) = v6;
          }
          break;
        }
      }
    }

    *(void *)uint64_t v3 = 0LL;
    *((void *)tree + 3) = 0LL;
    CFRelease(tree);
  }

void CFTreeRemoveAllChildren(CFTreeRef tree)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  }
  uint64_t v3 = (void *)*((void *)tree + 4);
  *((void *)tree + 4) = 0LL;
  *((void *)tree + 5) = 0LL;
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[3];
      void v3[2] = 0LL;
      v3[3] = 0LL;
      CFRelease(v3);
      uint64_t v3 = v4;
    }

    while (v4);
  }

void CFTreeSortChildren(CFTreeRef tree, CFComparatorFunction comparator, void *context)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28) {
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  }
  ChildCFIndex Count = CFTreeGetChildCount(tree);
  if (ChildCount >= 2)
  {
    uint64_t v11 = ChildCount;
    if ((unint64_t)ChildCount >= 0x80)
    {
      uint64_t v13 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * ChildCount, 0LL);
      BOOL v12 = v13 != (void *)v19;
      if (__CFOASafe) {
        BOOL v14 = v13 == (void *)v19;
      }
      else {
        BOOL v14 = 1;
      }
      if (!v14)
      {
        __CFSetLastAllocationEventName();
        BOOL v12 = 1;
      }
    }

    else
    {
      BOOL v12 = 0;
      uint64_t v13 = v19;
    }

    uint64_t v15 = *((void *)tree + 4);
    if (v15)
    {
      unint64_t v16 = v13;
      do
      {
        *v16++ = v15;
        uint64_t v15 = *(void *)(v15 + 24);
      }

      while (v15);
    }

    v18[0] = comparator;
    v18[1] = context;
    CFQSortArray(v13, v11, 8LL, (uint64_t)__CFTreeCompareValues, (uint64_t)v18, v8, v9, v10);
    uint64_t v17 = 0LL;
    *((void *)tree + 4) = *v13;
    do
    {
      *(void *)(v13[v17] + 24LL) = v13[v17 + 1];
      ++v17;
    }

    while (v11 - 1 != v17);
    *(void *)(v13[v17] + 24LL) = 0LL;
    *((void *)tree + 5) = v13[v11 - 1];
    if (v12) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
    }
  }

uint64_t __CFTreeCompareValues(void *a1, void *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, void))a3)(*a1, *a2, *(void *)(a3 + 8));
}

const char *_CFURLCStringIsPromiseName(const char *__s)
{
  if (__s)
  {
    CFTreeRef v1 = __s;
    if (*__s == 46 && (size_t v2 = strlen(__s), v2 >= 7)) {
      return (const char *)(*(_DWORD *)&v1[v2 - 7] == 1818454318 && *(_DWORD *)&v1[v2 - 4] == 1685417836);
    }
    else {
      return 0LL;
    }
  }

  return __s;
}

uint64_t _CFURLIsPromiseName(const __CFString *a1)
{
  if (a1 && CFStringGetLength(a1) >= 1 && CFStringGetCharacterAtIndex(a1, 0LL) == 46) {
    return CFStringHasSuffix(a1, @".icloud");
  }
  else {
    return 0LL;
  }
}

CFURLRef _CFURLIsItemPromiseAtURL(__objc2_class **a1)
{
  CFTreeRef v1 = (const __CFURL *)a1;
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (a1)
  {
    if (_CFURLIsFileURL(a1))
    {
      cf[0] = 0LL;
      if (CFURLIsFileReferenceURL(v1)
        && _CFURLCopyResourcePropertyForKeyFromCache( (__objc2_class **)v1,  (uint64_t)@"NSURLNameKey",  cf))
      {
        CFStringRef PathComponent = (CFStringRef)cf[0];
        if (!cf[0]) {
          return 0LL;
        }
      }

      else
      {
        CFStringRef PathComponent = CFURLCopyLastPathComponent(v1);
        cf[0] = PathComponent;
        if (!PathComponent) {
          return 0LL;
        }
      }

      CFTreeRef v1 = (const __CFURL *)_CFURLIsPromiseName(PathComponent);
      CFRelease(cf[0]);
      return v1;
    }

    return 0LL;
  }

  return v1;
}

__objc2_class **_CFURLPromiseCopyPhysicalURL(__objc2_class **result)
{
  v2[1] = *MEMORY[0x1895F89C0];
  v2[0] = 0LL;
  if (result)
  {
    CFTreeRef v1 = (const __CFURL *)result;
    if (_CFURLIsFileURL(result))
    {
      CFURLCopyResourcePropertyForKey(v1, @"_NSURLPromisePhysicalURLKey", v2, 0LL);
      CFTreeRef result = (__objc2_class **)v2[0];
      if ((__objc2_class **)v2[0] == &__kCFNull) {
        return (__objc2_class **)CFRetain(v1);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void _CFURLPromiseSetPhysicalURL(const __CFURL *a1, const __CFURL *a2)
{
  if (a1 && _CFURLIsFileURL((__objc2_class **)a1))
  {
    if (a2 == a1)
    {
      uint64_t v5 = &__kCFNull;
      uint64_t v4 = a1;
      goto LABEL_8;
    }

    uint64_t v4 = a1;
    if (a2)
    {
      uint64_t v5 = (__objc2_class **)a2;
LABEL_8:
      _CFURLSetPermanentResourcePropertyForKey(v4, @"_NSURLPromisePhysicalURLKey", v5);
      return;
    }

    CFURLClearResourcePropertyCacheForKey(a1, @"_NSURLPromisePhysicalURLKey");
  }

CFDictionaryRef _CFURLPromiseCreateProperties(void *a1, void *a2, int a3)
{
  keys[3] = *(void **)MEMORY[0x1895F89C0];
  keys[0] = @"NSURLNameKey";
  keys[1] = @"NSURLFileSizeKey";
  keys[2] = @"NSURLFileResourceTypeKey";
  values[0] = a1;
  values[1] = a2;
  uint64_t v3 = &kCFURLFileResourceTypeRegular;
  if (a3) {
    uint64_t v3 = &kCFURLFileResourceTypeDirectory;
  }
  values[2] = *(void **)v3;
  return CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
}

void *_CFURLCopyPropertiesOfPromiseAtURL(CFURLRef fileURL, __CFError **a2)
{
  error[1] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  uint64_t v3 = CFReadStreamCreateWithFile(0LL, fileURL);
  error[0] = 0LL;
  if (v3)
  {
    uint64_t v4 = v3;
    if (!CFReadStreamOpen(v3))
    {
      values = CFReadStreamCopyError(v4);
      uint64_t v10 = CFDictionaryCreate( 0LL,  (const void **)&kCFErrorUnderlyingErrorKey,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (values && (CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)values), CFEqual(Domain, @"NSPOSIXErrorDomain")))
      {
        if (CFErrorGetCode((CFErrorRef)values) == 2) {
          CFIndex v12 = 4LL;
        }
        else {
          CFIndex v12 = 256LL;
        }
      }

      else
      {
        CFIndex v12 = 256LL;
      }

      error[0] = CFErrorCreate(0LL, @"NSCocoaErrorDomain", v12, v10);
      if (values) {
        CFRelease(values);
      }
      if (v10) {
        CFRelease(v10);
      }
      uint64_t v5 = 0LL;
LABEL_29:
      uint64_t v13 = error[0];
      if (!error[0]) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }

    uint64_t v5 = (void *)CFPropertyListCreateWithStream(0LL, v4, 0LL, 1uLL, 0LL, error);
    CFReadStreamClose(v4);
    if (v5)
    {
      if (CFGetTypeID(v5) != 18)
      {
        CFRelease(v5);
        uint64_t v13 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 259LL, 0LL);
        error[0] = v13;
        if (v13) {
          goto LABEL_25;
        }
        goto LABEL_21;
      }

      CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"NSURLFileResourceTypeKey");
      if (Value)
      {
        uint64_t v7 = Value;
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsSymbolicLinkKey", &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsAliasFileKey", &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsVolumeKey", &__kCFBooleanFalse);
        if (CFEqual(v7, @"NSURLFileResourceTypeRegular"))
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsPackageKey", &__kCFBooleanFalse);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsDirectoryKey", &__kCFBooleanFalse);
          uint64_t v8 = &__kCFBooleanTrue;
          uint64_t v9 = (__CFDictionary *)v5;
        }

        else
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsPackageKey", &__kCFBooleanTrue);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, @"NSURLIsDirectoryKey", &__kCFBooleanTrue);
          uint64_t v9 = (__CFDictionary *)v5;
          uint64_t v8 = &__kCFBooleanFalse;
        }

        CFDictionarySetValue(v9, @"NSURLIsRegularFileKey", v8);
        goto LABEL_29;
      }

      CFRelease(v5);
    }

    uint64_t v13 = error[0];
    if (error[0])
    {
LABEL_25:
      uint64_t v5 = 0LL;
      if (a2)
      {
LABEL_31:
        *a2 = v13;
        goto LABEL_32;
      }

      goto LABEL_26;
    }

CFStringRef _CFURLCopyLogicalNameOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026LL)
    && (ssize_t v3 = getxattr((const char *)buffer, "com.apple.icloud.itemName", value, 0x2FCuLL, 0, 1), v3 >= 1))
  {
    CFIndex v4 = v3;
    CFStringEncoding v5 = CFStringFileSystemEncoding();
    CFStringRef v6 = CFStringCreateWithBytes(0LL, value, v4, v5, 0);
    if (!a2) {
      return v6;
    }
  }

  else
  {
    CFStringRef v6 = 0LL;
    if (!a2) {
      return v6;
    }
  }

  if (!v6) {
    *a2 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 256LL, 0LL);
  }
  return v6;
}

CFURLRef _CFURLCopyLogicalURLOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  CFStringRef v4 = _CFURLCopyLogicalNameOfPromiseAtURL(a1, a2);
  if (!v4) {
    return 0LL;
  }
  CFStringEncoding v5 = v4;
  CFStringRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0LL, a1);
  if (!PathComponent)
  {
    uint64_t v8 = 0LL;
    if (!a2) {
      goto LABEL_9;
    }
LABEL_7:
    if (!v8)
    {
      *a2 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 256LL, 0LL);
      CFRelease(v5);
      return v8;
    }

    goto LABEL_9;
  }

  uint64_t v7 = PathComponent;
  uint64_t v8 = CFURLCreateCopyAppendingPathComponent(0LL, PathComponent, v5, 0);
  CFRelease(v7);
  if (a2) {
    goto LABEL_7;
  }
LABEL_9:
  CFRelease(v5);
  if (v8) {
    _CFURLPromiseSetPhysicalURL(v8, a1);
  }
  return v8;
}

CFStringRef _CFURLCopyPromiseNameOfLogicalURL(const __CFURL *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (_CFURLIsFileURL((__objc2_class **)a1))
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(a1);
    if (PathComponent)
    {
      ssize_t v3 = PathComponent;
      if (CFStringGetLength(PathComponent) < 1)
      {
        CFStringRef v7 = 0LL;
LABEL_27:
        CFRelease(v3);
        return v7;
      }

      _CFGetPathExtensionRangesFromPathComponent(v3, &range.location, &v16);
      uint64_t location = range.location;
      if (range.location == -1 || (CFIndex v5 = range.length, range.length > 50))
      {
        CFIndex Length = CFStringGetLength(v3);
        CFIndex v5 = 0LL;
        uint64_t location = -1LL;
      }

      else
      {
        if (v16 != -1 && v17 + range.length <= 49)
        {
          uint64_t v6 = 0LL;
          while (CFStringCompareWithOptions( v3,  _CFURLCopyPromiseNameOfLogicalURL_compressionExtensions[v6],  range,  0LL))
          {
            if (++v6 == 4)
            {
              uint64_t location = range.location;
              CFIndex v5 = range.length;
              goto LABEL_16;
            }
          }

          uint64_t location = v16;
          CFIndex v5 = v17 + range.length + 1;
        }

CFURLRef _CFURLCopyPromiseURLOfLogicalURL(const __CFURL *a1)
{
  CFTreeRef v1 = a1;
  if (a1)
  {
    CFStringRef v2 = _CFURLCopyPromiseNameOfLogicalURL(a1);
    if (v2)
    {
      ssize_t v3 = v2;
      CFStringRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
      if (PathComponent)
      {
        CFIndex v5 = PathComponent;
        CFTreeRef v1 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, PathComponent, v3, 0);
        CFRelease(v5);
      }

      else
      {
        CFTreeRef v1 = 0LL;
      }

      CFRelease(v3);
    }

    else
    {
      return 0LL;
    }
  }

  return v1;
}

uint64_t _CFURLPromiseCopyResourcePropertyForKey( const __CFURL *a1, CFTypeRef cf1, void *a3, CFErrorRef *a4)
{
  if (CFEqual(cf1, @"_NSURLPromiseLogicalNameKey")
    || CFEqual(cf1, @"_NSURLCloudDocsPlaceholderLogicalNameKey"))
  {
    if (_CFURLIsItemPromiseAtURL((__objc2_class **)a1))
    {
      uint64_t result = (uint64_t)_CFURLCopyLogicalNameOfPromiseAtURL(a1, a4);
      if (!result) {
        return result;
      }
      goto LABEL_12;
    }

    goto LABEL_11;
  }

  if (!CFEqual(cf1, @"_NSURLPromisePropertiesKey")
    && !CFEqual(cf1, @"_NSURLCloudDocsPlaceholderDictionaryKey"))
  {
    return 1LL;
  }

  if (!_CFURLIsItemPromiseAtURL((__objc2_class **)a1))
  {
LABEL_11:
    uint64_t result = 0LL;
    goto LABEL_12;
  }

  uint64_t result = (uint64_t)_CFURLCopyPropertiesOfPromiseAtURL(a1, a4);
  if (result)
  {
LABEL_12:
    *a3 = result;
    return 1LL;
  }

  return result;
}

uint64_t _CFURLPromiseSetResourcePropertyForKey()
{
  return 1LL;
}

double _CFAuditTokenForSelf@<D0>(_OWORD *a1@<X8>)
{
  if (_CFAuditTokenForSelf_onceToken != -1) {
    dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
  }
  double result = *(double *)&_CFAuditTokenForSelf_auditToken;
  __int128 v3 = unk_18C45C968;
  *a1 = _CFAuditTokenForSelf_auditToken;
  a1[1] = v3;
  return result;
}

CFStringRef _CFPrefsCopyUserForContainer(const __CFString *cf1, CFStringRef theString)
{
  if (theString && CFStringHasPrefix(theString, @"/private/var/containers/Shared/SystemGroup/")) {
    return @"kCFPreferencesAnyUser";
  }
  if (CFEqual(cf1, @"kCFPreferencesCurrentUser")) {
    return @"kCFPreferencesCurrentUser";
  }
  __int128 v3 = @"kCFPreferencesAnyUser";
  if (!CFEqual(cf1, @"kCFPreferencesAnyUser"))
  {
    CFStringRef v4 = CFCopyUserName();
    int v5 = CFEqual(cf1, v4);
    CFRelease(v4);
    BOOL v6 = !@"kCFPreferencesCurrentUser" || v5 == 0;
    __int128 v3 = @"kCFPreferencesCurrentUser";
    if (v6) {
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf1);
    }
  }

  return v3;
}

void _CFPrefsExtractQuadrupleFromPathIfPossible( const __CFString *a1, CFStringRef *a2, CFStringRef *a3, CFTypeRef *a4, _BYTE *a5, _BYTE *a6, _BYTE *a7)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  *a7 = 0;
  if (!a1) {
    return;
  }
  uint64_t v13 = a1;
  if (CFStringGetCharacterAtIndex(a1, 0LL) != 47 && CFStringFind(v13, @"..", 0LL).location == -1) {
    return;
  }
  if (CFStringHasSuffix(v13, @".plist")) {
    CFRetain(v13);
  }
  else {
    uint64_t v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@.plist", v13);
  }
  uint64_t v64 = a6;
  uint64_t v65 = a3;
  uint64_t v63 = a7;
  if (CFStringFind(v13, @"/containers/Shared/SystemGroup/", 0LL).location == -1
    || (CFRange v14 = CFStringFind(v13, @"/Library/Preferences/", 4uLL), v14.location == -1))
  {
    CFStringRef v17 = 0LL;
    CFStringRef v16 = 0LL;
    uint64_t v15 = 0LL;
  }

  else
  {
    v72.CFIndex length = CFStringGetLength(v13) - (v14.location + v14.length);
    v72.CFIndex location = v14.location + v14.length;
    uint64_t v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v72);
    v73.CFIndex length = v14.location + 1;
    v73.CFIndex location = 0LL;
    CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v73);
    CFStringRef v17 = @"kCFPreferencesAnyUser";
  }

  CFIndex location = CFStringFind(v13, @"/Containers/Shared/AppGroup/", 0LL).location;
  if (location >= 1)
  {
    CFIndex v19 = location;
    CFRange v20 = CFStringFind(v13, @"/Library/Preferences/", 4uLL);
    if (v20.location != -1)
    {
      UniChar v62 = a4;
      CFRange v21 = a5;
      CFIndex v22 = CFStringGetLength(v13) - (v20.location + v20.length);
      if (v15) {
        CFRelease(v15);
      }
      v74.CFIndex location = v20.location + v20.length;
      v74.CFIndex length = v22;
      uint64_t v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v74);
      if (v16) {
        CFRelease(v16);
      }
      v75.CFIndex length = v20.location + 1;
      v75.CFIndex location = 0LL;
      CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v75);
      v76.CFIndex location = 0LL;
      v76.CFIndex length = v19;
      if (!CFStringFindWithOptions(v13, @"/", v76, 4uLL, &result)) {
        _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1();
      }
      a5 = v21;
      v77.CFIndex location = result.location + 1;
      v77.CFIndex length = v19 - (result.location + 1);
      CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v77);
      a4 = v62;
    }
  }

  if (v15)
  {
    CFRelease(v13);
    goto LABEL_42;
  }

  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v13);
  CFRelease(v13);
  CFRange v24 = CFStringFind(MutableCopy, @"/private/var/preferences/", 8uLL);
  if (v24.location == -1)
  {
    CFRange v28 = CFStringFind(MutableCopy, @"/private/var/", 8uLL);
    if (v28.location == -1) {
      goto LABEL_26;
    }
    CFIndex v25 = v28.location;
    v26.CFIndex length = v28.length;
    __int128 v27 = @"/var/";
  }

  else
  {
    CFIndex v25 = v24.location;
    v26.CFIndex length = v24.length;
    __int128 v27 = @"/Library/Preferences/";
  }

  v26.CFIndex location = v25;
  CFStringReplace(MutableCopy, v26, v27);
LABEL_26:
  CFRange v31 = CFStringFind(MutableCopy, @"/Containers/Data/Application/", 0LL);
  CFIndex length = v31.length;
  CFIndex v29 = v31.location;
  if (v31.location != -1
    || (CFRange v32 = CFStringFind(MutableCopy, @"/Applications/", 0LL),
        CFIndex length = v32.length,
        CFIndex v29 = v32.location,
        v32.location != -1))
  {
    uint64_t v33 = length + v29 + 1;
    v78.CFIndex length = CFStringGetLength(MutableCopy) - v33;
    v78.CFIndex location = v33;
    if (CFStringFindWithOptions(MutableCopy, @"/", v78, 0LL, &result))
    {
      if (v16) {
        CFRelease(v16);
      }
      v79.CFIndex length = result.location;
      v79.CFIndex location = 0LL;
      CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v79);
      CFIndex v34 = result.location;
      CFIndex v35 = CFStringGetLength(MutableCopy);
      v80.CFIndex length = v35 - result.location;
      v80.CFIndex location = v34;
      CFStringRef v36 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v80);
      CFRelease(MutableCopy);
      MutableCFStringRef Copy = (CFMutableStringRef)v36;
    }
  }

  CFRange v38 = CFStringFind(MutableCopy, @"/var/Managed Preferences/", 8uLL);
  CFIndex v37 = v38.length;
  if (v38.location != -1
    || (CFRange v39 = CFStringFind(MutableCopy, @"/Library/Managed Preferences/", 8uLL),
        CFIndex v37 = v39.length,
        v39.location != -1))
  {
    CFIndex v40 = v37;
    *uint64_t v64 = 1;
    v81.CFIndex length = CFStringGetLength(MutableCopy) - v37;
    v81.CFIndex location = v40;
    __int128 v41 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v81);
    CFRelease(MutableCopy);
    CFIndex v42 = CFStringFind(v41, @"/", 0LL).location;
    if (v42 == -1)
    {
      uint64_t v15 = (const __CFString *)CFRetain(v41);
      if (v17) {
        CFRelease(v17);
      }
      CFStringRef v17 = @"kCFPreferencesAnyUser";
    }

    else
    {
      CFIndex v43 = v42;
      if (v17) {
        CFRelease(v17);
      }
      v82.CFIndex location = 0LL;
      v82.CFIndex length = v43;
      CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v82);
      CFIndex v44 = v43 + 1;
      v83.CFIndex length = CFStringGetLength(v41) - v44;
      v83.CFIndex location = v44;
      uint64_t v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v83);
    }

    goto LABEL_41;
  }

  int64_t v55 = a5;
  *uint64_t v64 = 0;
  __int16 v56 = (const char *)_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser();
  uint64_t v57 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v56);
  CFRange v58 = CFStringFind(MutableCopy, @"/Library/Preferences/", 0LL);
  if (v58.location == -1)
  {
LABEL_90:
    if (!v57) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }

  if (!v58.location)
  {
    if (v17) {
      CFRelease(v17);
    }
    uint64_t v59 = &kCFPreferencesCurrentUser;
    if (!v16) {
      uint64_t v59 = &kCFPreferencesAnyUser;
    }
    CFStringRef v17 = *v59;
    goto LABEL_90;
  }

  if (CFStringHasPrefix(MutableCopy, @"/var/db/"))
  {
    if (v17) {
      CFRelease(v17);
    }
    v61.CFIndex length = v58.location - 8;
    CFRange v60 = MutableCopy;
    v61.CFIndex location = 8LL;
LABEL_89:
    CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v60, v61);
    goto LABEL_90;
  }

  if (CFStringHasPrefix(MutableCopy, @"/var/"))
  {
    if (v17) {
      CFRelease(v17);
    }
    v61.CFIndex length = v58.location - 5;
    CFRange v60 = MutableCopy;
    v61.CFIndex location = 5LL;
    goto LABEL_89;
  }

  if (v57)
  {
    if (CFStringHasPrefix(MutableCopy, v57))
    {
      if (v17) {
        CFRelease(v17);
      }
      CFStringRef v17 = @"kCFPreferencesCurrentUser";
    }

LABEL_96:
  *uint64_t v63 = 1;
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
}

  CFStringRef v50 = CFGetTypeID(a1);
  if (v50 == CFStringGetTypeID() && !v33)
  {
    CFStringRef v51 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatClassInfoKey");
    value[0] = 0LL;
    else {
      uint64_t v52 = CFDictionaryGetValue(v28, @"NSStringFormatRuleInfoKey");
    }
    v77[0] = v52;
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v52);
    int64_t v55 = Count;
    if (Count >> 60)
    {
      __int128 v68 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  Count);
      __int128 v69 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v68,  0LL);
      CFRelease(v68);
      objc_exception_throw(v69);
      __break(1u);
      return;
    }

    if (Count <= 1) {
      CFIndex Count = 1LL;
    }
    __int16 v56 = MEMORY[0x1895F8858](Count, v54);
    CFRange v58 = (const void **)((char *)v70 - v57);
    if (v55 >= 0x101)
    {
      CFRange v58 = (const void **)_CFCreateArrayStorage(v56, 0, &v76);
      uint64_t v59 = v58;
    }

    else
    {
      uint64_t v59 = 0LL;
    }

    CFDictionaryGetKeysAndValues((CFDictionaryRef)v77[0], v58, 0LL);
    if (v55)
    {
      while (1)
      {
        CFRange v60 = (const __CFString *)*v58;
        if (CFStringCompare((CFStringRef)*v58, @"default", 0LL))
        {
          CFRange v61 = (const __CFCharacterSet *)CFDictionaryGetValue(v25, v60);
          if ((_CFStringContentsInCharacterSet(a1, v61) & 1) != 0) {
            break;
          }
        }

        ++v58;
        if (!--v55) {
          goto LABEL_111;
        }
      }
    }

    else
    {
LABEL_111:
      CFRange v60 = 0LL;
    }

    if (v60) {
      UniChar v62 = v60;
    }
    else {
      UniChar v62 = @"default";
    }
    uint64_t v33 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], v62);
    free(v59);
  }

  if (v28) {
    CFRelease(v28);
  }
  if (v33) {
    CFRetain(v33);
  }
}

void _CFPreferencesAlwaysUseVolatileUserDomains()
{
  __overrideUseVolatileDomainsForUser = 1;
}

CFStringRef _CFPrefsCreateCacheKeyForQuintuplet( __CFString *a1, const __CFString *a2, int a3, const __CFString *a4, char a5)
{
  v47[1] = *MEMORY[0x1895F89C0];
  CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  uint64_t v10 = (const void *)_CFPrefsGetCacheStringForBundleID(@"kCFPreferencesCurrentApplication");
  if (CFEqual(CacheStringForBundleID, v10))
  {
    CFIndex v11 = @"C";
  }

  else if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication"))
  {
    CFIndex v11 = @"A";
  }

  else
  {
    CFIndex v11 = CacheStringForBundleID;
  }

  if (CFEqual(a2, @"kCFPreferencesCurrentUser"))
  {
LABEL_7:
    CFStringRef Copy = @"C";
    uint64_t v13 = @"kCFPreferencesCurrentUser";
    if (!@"kCFPreferencesCurrentUser") {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  uint64_t v13 = @"kCFPreferencesAnyUser";
  CFStringRef Copy = @"kCFPreferencesAnyUser";
  if (!CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    CFStringRef v17 = CFCopyUserName();
    int v18 = CFEqual(a2, v17);
    CFRelease(v17);
    if (@"kCFPreferencesCurrentUser") {
      BOOL v19 = v18 == 0;
    }
    else {
      BOOL v19 = 1;
    }
    if (!v19)
    {
      CFStringRef Copy = @"C";
      uint64_t v13 = @"kCFPreferencesCurrentUser";
LABEL_8:
      CFRelease(v13);
      goto LABEL_9;
    }

    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  }

  if (Copy == @"kCFPreferencesCurrentUser") {
    goto LABEL_7;
  }
  if (Copy == @"kCFPreferencesAnyUser")
  {
    CFStringRef Copy = @"A";
    if (@"kCFPreferencesAnyUser") {
      goto LABEL_8;
    }
  }

  else if (!Copy)
  {
    return 0LL;
  }

uint64_t _CFPrefsValidateValueForKey(const void *a1, uint64_t a2)
{
  if (!a1 || CFPropertyListIsValid(a1, kCFPropertyListBinaryFormat_v1_0)) {
    return 1LL;
  }
  _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
  int v5 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
    _CFPrefsValidateValueForKey_cold_2();
  }
  _CFSetTSD(0xFu, 0LL, 0LL);
  _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
  uint64_t result = _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"Attempt to insert non-property list object %@ for key %@",  a1,  a2);
  __break(1u);
  return result;
}

void sub_180B226C4(_Unwind_Exception *a1)
{
}

void sub_180B228E8(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_180B22900(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x180B2290CLL);
}

void sub_180B22C48(_Unwind_Exception *a1)
{
}

void sub_180B22CAC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180B22CB0LL);
  }
  objc_terminate();
  if (v4)
  {
    objc_begin_catch(v3);
    if (!v2) {
      JUMPOUT(0x180B22B00LL);
    }
    JUMPOUT(0x180B22AE8LL);
  }

  JUMPOUT(0x180B22CA4LL);
}

CFStringRef createDeepCopyOfValueForKey(CFStringRef cf, uint64_t a2)
{
  uint64_t v2 = cf;
  if (((unint64_t)cf & 0x8000000000000000LL) == 0
    && &__kCFBooleanFalse != (__objc2_class **)cf
    && &__kCFBooleanTrue != (__objc2_class **)cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
    }

    else
    {
      CFTypeRef cf = (CFStringRef)CFPropertyListCreateDeepCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2, 0LL);
      if (!cf)
      {
        _CFPrefsValidateValueForKey(v2, a2);
        return 0LL;
      }
    }
  }

  return cf;
}

void sub_180B23288(_Unwind_Exception *a1)
{
}

void sub_180B232F4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180B232F8LL);
  }
  objc_terminate();
  if (v3)
  {
    objc_begin_catch(v2);
    JUMPOUT(0x180B23144LL);
  }

  JUMPOUT(0x180B232ECLL);
}

void sub_180B2352C(_Unwind_Exception *a1)
{
}

void sub_180B2412C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void sub_180B24658(_Unwind_Exception *a1)
{
}

void sub_180B24874( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void _addBackstopValuesForIdentifierAndSource(const void *a1, os_unfair_lock_s *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (CFEqual(a1, @"NSRegistrationDomain"))
  {
    values = @"en-001";
    CFArrayRef v5 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&values,  1LL,  &kCFTypeArrayCallBacks);
    v28[0] = xmmword_1899E9AD0;
    v28[1] = *(_OWORD *)off_1899E9AE0;
    v27[0] = (size_t)v5;
    v27[1] = (size_t)@"en_001";
    v27[2] = (size_t)v5;
    v27[3] = (size_t)@"macintosh";
    if (a2) {
      -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:]( a2,  (uint64_t)v27,  (uint64_t)v28,  4uLL,  1,  0LL,  0LL,  0LL);
    }
    CFRelease(v5);
  }

  else if (CFEqual(a1, @"NSArgumentDomain"))
  {
    if (getDefaultArguments_onceToken != -1) {
      dispatch_once(&getDefaultArguments_onceToken, &__block_literal_global_211);
    }
    BOOL v6 = (void *)getDefaultArguments___NSDefaultArguments;
    if (getDefaultArguments___NSDefaultArguments)
    {
      unint64_t v7 = [(id)getDefaultArguments___NSDefaultArguments count];
      unint64_t v9 = v7;
      if (v7 >> 60)
      {
        CFStringRef v20 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v7);
        CFRange v21 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v20,  0LL);
        CFRelease(v20);
        objc_exception_throw(v21);
        CFRange v23 = v22;
        free(v2);
        _Unwind_Resume(v23);
      }

      if (v7 <= 1) {
        unint64_t v10 = 1LL;
      }
      else {
        unint64_t v10 = v7;
      }
      uint64_t v11 = MEMORY[0x1895F8858](v7, v8);
      CFRange v14 = (char *)&v25 - v13;
      if (v9 > 0x100)
      {
        CFStringRef v17 = (char *)_CFCreateArrayStorage(v10, 0, (size_t *)v28);
        MEMORY[0x1895F8858](v17, v19);
        CFStringRef v16 = (char *)&v24;
        int v18 = (char *)_CFCreateArrayStorage(v10, 0, v27);
        CFRange v14 = v17;
      }

      else
      {
        MEMORY[0x1895F8858](v11, v12);
        CFStringRef v16 = (char *)&v25 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        CFStringRef v17 = 0LL;
        int v18 = 0LL;
      }

      if (v9 >= 0x101) {
        CFStringRef v16 = v18;
      }
      [v6 getObjects:v14 andKeys:v16 count:v9];
      if (a2) {
        -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:]( a2,  (uint64_t)v14,  (uint64_t)v16,  v9,  0,  0LL,  0LL,  0LL);
      }
      free(v18);
      free(v17);
    }
  }

void sub_180B25064(_Unwind_Exception *a1)
{
}

void __getDefaultArguments_block_invoke()
{
  v13[1] = *(id *)MEMORY[0x1895F89C0];
  if (!issetugid())
  {
    getDefaultArguments___NSDefaultArguments = objc_opt_new();
    unint64_t v0 = (void *)objc_msgSend((id)unk_18C5470F0(&off_18C547E98, "processInfo"), "arguments");
    uint64_t v1 = [v0 count] - 1;
    if (v1 >= 2)
    {
      uint64_t v2 = 1LL;
      do
      {
        int v3 = (void *)[v0 objectAtIndex:v2];
        uint64_t v4 = v2 + 1;
        CFArrayRef v5 = (__CFString *)[v0 objectAtIndex:v2 + 1];
        if ((-[__CFString hasPrefix:](v5, "hasPrefix:", @"-") & 1) != 0) {
          goto LABEL_20;
        }
        uint64_t v6 = -[__CFString rangeOfCharacterFromSet:options:range:]( v5,  "rangeOfCharacterFromSet:options:range:",  objc_msgSend((id)unk_18C54839C(&off_18C548AC8, "whitespaceAndNewlineCharacterSet"), "invertedSet"),  0,  0,  -[__CFString length](v5, "length"));
        if (!v7)
        {
          CFArrayRef v5 = &stru_1899EF170;
LABEL_18:
          objc_msgSend( (id)getDefaultArguments___NSDefaultArguments,  "setObject:forKeyedSubscript:",  v5,  objc_msgSend(v3, "substringFromIndex:", 1));
          goto LABEL_19;
        }

        int v8 = -[__CFString characterAtIndex:](v5, "characterAtIndex:", v6);
        if (((v8 - 34) > 0x39 || ((1LL << (v8 - 34)) & 0x200000004000041LL) == 0)
          && v8 != 123)
        {
          goto LABEL_18;
        }

        v13[0] = 0LL;
        unint64_t v9 = (__CFString *)(id)_CFPropertyListCreateFromXMLString( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  v5,  0,  (CFStringRef *)v13,  1,  0LL);
        if (v13[0])
        {
          id v10 = v13[0];
          uint64_t v11 = (const __CFData *)-[__CFString dataUsingEncoding:allowLossyConversion:]( v5,  "dataUsingEncoding:allowLossyConversion:",  4LL,  0LL);
          CFErrorRef error = 0LL;
          CFArrayRef v5 = (id)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v11,  0LL,  0LL,  &error);
          if (!v5 && error)
          {
            CFRelease(error);
            goto LABEL_19;
          }
        }

        else
        {
          CFArrayRef v5 = v9;
        }

        if (v5) {
          goto LABEL_18;
        }
LABEL_19:
        uint64_t v4 = v2 + 2;
LABEL_20:
        uint64_t v2 = v4;
      }

      while (v4 < v1);
    }
  }

CFStringRef CFURLCreateStringByReplacingPercentEscapes( CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  uint64_t v3 = MEMORY[0x1895F8858](allocator, originalString);
  uint64_t v6 = v5;
  uint64_t v7 = v4;
  int v8 = (const __CFAllocator *)v3;
  uint64_t v75 = *MEMORY[0x1895F89C0];
  if (v5)
  {
    BOOL v9 = CFStringGetLength(v5) == 0;
    if (!v7) {
      return 0LL;
    }
  }

  else
  {
    BOOL v9 = 0;
    if (!v4) {
      return 0LL;
    }
  }

  CFIndex Length = CFStringGetLength(v7);
  if (!v6) {
    return CFStringCreateCopy(v8, v7);
  }
  CFIndex v11 = Length;
  if (!Length) {
    return CFStringCreateCopy(v8, v7);
  }
  if (v9)
  {
    uint64_t v12 = v8;
    unint64_t v13 = CFStringGetLength(v7);
    CFIndex v14 = v13;
    if (v13 <= 1) {
      unint64_t v13 = 1LL;
    }
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u);
    CFIndex v16 = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding < 2097)
    {
      CFStringRef v17 = (UInt8 *)v74;
LABEL_89:
      v77.CFIndex location = 0LL;
      v77.CFIndex length = v14;
      if (CFStringGetBytes(v7, v77, 0x8000100u, 0, 0, v17, v16, &v73))
      {
        CFIndex v56 = v73;
        uint64_t v57 = &v17[v16];
        if (v73 >= 1)
        {
          CFIndex v58 = 0LL;
          uint64_t v59 = v17;
          uint64_t v57 = &v17[v16];
          do
          {
            int v60 = *v59;
            if (v60 == 37)
            {
              v58 += 2LL;
              if (v58 >= v56) {
                goto LABEL_103;
              }
              int v61 = UnescapeAllWithUTF8_hexvalues[v59[1]];
              int v60 = UnescapeAllWithUTF8_hexvalues[v59[2]];
              if (((v60 | v61) & 0x80) != 0) {
                goto LABEL_103;
              }
              v59 += 3;
              LOBYTE(v60) = v60 + 16 * v61;
            }

            else
            {
              ++v59;
            }

            *v57++ = v60;
            ++v58;
            CFIndex v56 = v73;
          }

          while (v58 < v73);
        }

        CFIndex v22 = (__CFString *)CFStringCreateWithBytes(v12, &v17[v16], v57 - &v17[v16], 0x8000100u, 0);
      }

      else
      {
LABEL_103:
        CFIndex v22 = 0LL;
      }

      if (v17 != (UInt8 *)v74) {
        free(v17);
      }
      return v22;
    }

    CFStringRef v17 = (UInt8 *)malloc(2 * MaximumSizeForEncoding);
    if (v17) {
      goto LABEL_89;
    }
    return 0LL;
  }

  v78.CFIndex location = 0LL;
  v78.CFIndex length = Length;
  int v19 = CFStringFindWithOptions(v7, @"%", v78, 0LL, v74);
  BOOL v20 = v19 == 0;
  if (v19)
  {
    CFStringRef v69 = v6;
    CFMutableStringRef v21 = 0LL;
    CFIndex v67 = 0LL;
    CFIndex v22 = 0LL;
    CFAllocatorRef v63 = (CFAllocatorRef)&__kCFAllocatorNull;
    CFAllocatorRef v64 = v8;
    CFIndex v71 = v11;
    while (1)
    {
      LODWORD(v70) = v20;
      if (v11 - v74[0].location < 3) {
        break;
      }
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v7, v74[0].location + 1);
      int v24 = CFStringGetCharacterAtIndex(v7, v74[0].location + 2);
      if ((CharacterAtIndex - 48) >= 0xA)
      {
        if ((CharacterAtIndex - 97) >= 6)
        {
          char v25 = -55;
        }

        else
        {
          char v25 = -87;
        }
      }

      else
      {
        char v25 = -48;
      }

      char v26 = 16 * (v25 + CharacterAtIndex);
      if ((v24 - 48) > 9)
      {
        if ((v24 - 97) > 5)
        {
          unsigned __int8 v27 = v24 + v26 - 55;
        }

        else
        {
          unsigned __int8 v27 = v24 + v26 - 87;
        }
      }

      else
      {
        unsigned __int8 v27 = v24 + v26 - 48;
      }

      LOBYTE(v73) = v27;
      CFIndex v11 = v71;
      if ((v27 & 0x80) != 0)
      {
        if ((v27 & 0x10) != 0) {
          unsigned int v30 = 4;
        }
        else {
          unsigned int v30 = 3;
        }
        if ((v27 & 0x20) != 0) {
          uint64_t v31 = v30;
        }
        else {
          uint64_t v31 = 2LL;
        }
        __int128 v68 = v21;
        uint64_t v65 = v31;
        int64_t v66 = v22;
        unint64_t v32 = v31;
        if (CFStringGetCharacterAtIndex(v7, v74[0].location + 3) == 37)
        {
          uint64_t v33 = 0LL;
          BOOL v34 = 1;
          uint64_t v35 = 4LL;
          do
          {
            int v36 = CFStringGetCharacterAtIndex(v7, v35 + v74[0].location);
            int v37 = CFStringGetCharacterAtIndex(v7, v35 + v74[0].location + 1);
            *((_BYTE *)&v73 + v33 + 1) = 0;
            if ((v36 - 48) >= 0xA)
            {
              if ((v36 - 97) >= 6)
              {
                char v38 = -55;
              }

              else
              {
                char v38 = -87;
              }
            }

            else
            {
              char v38 = -48;
            }

            char v39 = 16 * (v38 + v36);
            *((_BYTE *)&v73 + v33 + 1) = v39;
            if ((v37 - 48) >= 0xA)
            {
              if ((v37 - 97) >= 6)
              {
                char v40 = -55;
              }

              else
              {
                char v40 = -87;
              }
            }

            else
            {
              char v40 = -48;
            }

            *((_BYTE *)&v73 + v33 + 1) = v40 + v37 + v39;
            BOOL v34 = v33 + 2 < v32;
            if (v32 - 2 == v33) {
              break;
            }
            int v41 = CFStringGetCharacterAtIndex(v7, v35 + v74[0].location + 2);
            v35 += 3LL;
            ++v33;
          }

          while (v41 == 37);
        }

        else
        {
          BOOL v34 = 1;
        }

        int v8 = v64;
        CFStringRef v42 = CFStringCreateWithBytes(v64, (const UInt8 *)&v73, v32, 0x8000100u, 0);
        int v29 = v65;
        CFIndex v22 = v66;
        CFMutableStringRef v21 = v68;
        if (!v42) {
          break;
        }
        CFIndex v28 = v42;
        CFIndex v43 = CFStringGetLength(v42);
        if ((v27 & 0x30) == 0x20)
        {
          CFMutableStringRef v21 = v68;
          if (!v43 && v73 == 239 && BYTE1(v73) == 187 && BYTE2(v73) == 191)
          {
            UniChar v72 = -257;
            if (!v68) {
              CFMutableStringRef v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1LL, 1LL, v63);
            }
            CFRelease(v28);
            CFIndex v28 = (const __CFString *)CFRetain(v21);
          }

          if (v34)
          {
LABEL_79:
            if (v28) {
              CFRelease(v28);
            }
            break;
          }
        }

        else
        {
          CFMutableStringRef v21 = v68;
          if (v34) {
            goto LABEL_79;
          }
        }

        CFIndex v11 = v71;
      }

      else
      {
        UniChar v72 = v27;
        if (!v21) {
          CFMutableStringRef v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1LL, 1LL, v63);
        }
        CFIndex v28 = (const __CFString *)CFRetain(v21);
        int v29 = 1;
      }

      CFIndex v44 = v74[0].location + (3 * v29);
      CFIndex location = CFStringFind(v69, v28, 0LL).location;
      if (location == -1)
      {
        if (!v22)
        {
          CFIndex location = (CFIndex)CFStringCreateMutable(v8, v11);
          CFIndex v22 = (__CFString *)location;
        }

        int v46 = v22;
        CFIndex v47 = v74[0].location - v67;
        if (v74[0].location - v67 >= 1)
        {
          CFRange v70 = &v62;
          MEMORY[0x1895F8858](location, v67);
          CFRange v49 = v8;
          CFRange v50 = v21;
          CFStringRef v51 = (UniChar *)((char *)&v62 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0LL));
          v76.CFIndex length = v47;
          CFStringGetCharacters(v7, v76, v51);
          uint64_t v52 = v51;
          CFMutableStringRef v21 = v50;
          int v8 = v49;
          CFStringAppendCharacters(v46, v52, v47);
          CFIndex v11 = v71;
        }

        CFStringAppend(v46, v28);
        CFIndex v67 = v44;
        CFIndex v22 = v46;
      }

      if (v28) {
        CFRelease(v28);
      }
      v79.CFIndex length = v11 - v44;
      v79.CFIndex location = v44;
      int v53 = CFStringFindWithOptions(v7, @"%", v79, 0LL, v74);
      BOOL v20 = v53 == 0;
      if (!v53) {
        goto LABEL_82;
      }
    }

    CFIndex v11 = v71;
    LOBYTE(v20) = (_BYTE)v70;
LABEL_82:
    if (v21) {
      CFRelease(v21);
    }
  }

  else
  {
    CFIndex v22 = 0LL;
    CFIndex v67 = 0LL;
  }

  if (v20)
  {
    if (!v22) {
      return CFStringCreateCopy(v8, v7);
    }
    v54.CFIndex location = v67;
    if (v11 > v67)
    {
      v54.CFIndex length = v11 - v67;
      int64_t v55 = CFStringCreateWithSubstring(v8, v7, v54);
      CFStringAppend(v22, v55);
      CFRelease(v55);
    }

    return v22;
  }

  if (v22)
  {
    CFRelease(v22);
    return 0LL;
  }

  return v22;
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding( CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  uint64_t v6 = allocator;
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (encoding == 134217984) {
    return CFURLCreateStringByReplacingPercentEscapes(allocator, origString, charsToLeaveEscaped);
  }
  if (!charsToLeaveEscaped)
  {
    if (origString) {
      return CFStringCreateCopy(allocator, origString);
    }
    return 0LL;
  }

  CFIndex Length = CFStringGetLength(charsToLeaveEscaped);
  if (!origString) {
    return 0LL;
  }
  CFIndex v9 = Length;
  CFIndex v10 = CFStringGetLength(origString);
  v47.CFIndex location = 0LL;
  v47.CFIndex length = v10;
  if (CFStringFindWithOptions(origString, @"%", v47, 0LL, &result))
  {
    CFIndex v37 = v9;
    alloc = v6;
    CFRange range_8 = charsToLeaveEscaped;
    CFTypeRef cf = 0LL;
    CFMutableStringRef Mutable = 0LL;
    CFIndex v12 = 0LL;
    int v13 = 8;
    CFIndex v14 = &v45;
LABEL_7:
    uint64_t v15 = 0LL;
    CFIndex range = v12;
    CFIndex v16 = result.location + 3;
    CFIndex v17 = -result.location;
    while (1)
    {
      uint64_t v18 = v15;
      if (v10 + v17 < 3) {
        break;
      }
      CFIndex v12 = v16;
      if (v15 == v13)
      {
        if (v14 == &v45)
        {
          CFIndex v14 = (char *)malloc(0x10uLL);
          __memmove_chk();
          int v13 = 16;
        }

        else
        {
          int v19 = malloc(2 * v13);
          memmove(v19, v14, v13);
          free(v14);
          v13 *= 2;
          CFIndex v14 = (char *)v19;
        }
      }

      UniChar chars = CFStringGetCharacterAtIndex(origString, v12 - 2);
      int CharacterAtIndex = CFStringGetCharacterAtIndex(origString, v12 - 1);
      int v21 = chars;
      v14[v18] = 0;
      if ((v21 - 48) >= 0xA)
      {
        if ((v21 - 97) >= 6)
        {
          char v22 = -55;
        }

        else
        {
          char v22 = -87;
        }
      }

      else
      {
        char v22 = -48;
      }

      char v23 = 16 * (v22 + v21);
      v14[v18] = v23;
      if ((CharacterAtIndex - 48) >= 0xA)
      {
        if ((CharacterAtIndex - 97) >= 6)
        {
          char v24 = -55;
        }

        else
        {
          char v24 = -87;
        }
      }

      else
      {
        char v24 = -48;
      }

      v14[v18] = v24 + CharacterAtIndex + v23;
      if (v10 > v12)
      {
        int v25 = CFStringGetCharacterAtIndex(origString, v12);
        CFIndex v16 = v12 + 3;
        v17 -= 3LL;
        uint64_t v15 = v18 + 1;
        if (v25 == 37) {
          continue;
        }
      }

      uint64_t v6 = alloc;
      CFStringRef v26 = CFStringCreateWithBytes(alloc, (const UInt8 *)v14, (v18 + 1), encoding, 0);
      if (!v26) {
        goto LABEL_48;
      }
      unsigned __int8 v27 = v26;
      if (!Mutable) {
        CFMutableStringRef Mutable = CFStringCreateMutable(alloc, v10);
      }
      v28.CFIndex location = range;
      if (result.location - range >= 1)
      {
        v28.CFIndex length = result.location - range;
        int v29 = CFStringCreateWithSubstring(alloc, origString, v28);
        CFStringAppend(Mutable, v29);
        CFRelease(v29);
      }

      if (v37)
      {
        CFIndex v30 = CFStringGetLength(v27);
        CFMutableStringRef v31 = (CFMutableStringRef)cf;
        if (!cf) {
          CFMutableStringRef v31 = CFStringCreateMutableWithExternalCharactersNoCopy( alloc,  &chars,  1LL,  1LL,  (CFAllocatorRef)&__kCFAllocatorNull);
        }
        CFTypeRef cf = v31;
        if (v30 >= 1)
        {
          for (CFIndex i = 0LL; i != v30; ++i)
          {
            UniChar chars = CFStringGetCharacterAtIndex(v27, i);
            if (CFStringFind(range_8, cf, 0LL).location == -1) {
              CFStringAppendCharacters(Mutable, &chars, 1LL);
            }
            else {
              _appendPercentEscapesForCharacter(&chars, 0, encoding, Mutable);
            }
          }
        }
      }

      else
      {
        CFStringAppend(Mutable, v27);
      }

      CFRelease(v27);
      v48.CFIndex location = v12;
      v48.CFIndex length = v10 - v12;
      if (!CFStringFindWithOptions(origString, @"%", v48, 0LL, &result))
      {
        char v33 = 1;
        CFIndex range = v12;
        uint64_t v6 = alloc;
        BOOL v34 = cf;
        goto LABEL_49;
      }

      goto LABEL_7;
    }

    uint64_t v6 = alloc;
LABEL_48:
    BOOL v34 = cf;
    char v33 = 0;
LABEL_49:
    if (v34) {
      CFRelease(v34);
    }
    if (v14 != &v45) {
      free(v14);
    }
    if ((v33 & 1) != 0)
    {
      if (Mutable)
      {
        v35.CFIndex location = range;
        if (v10 > range)
        {
          v35.CFIndex length = v10 - range;
          int v36 = CFStringCreateWithSubstring(v6, origString, v35);
          CFStringAppend(Mutable, v36);
          CFRelease(v36);
        }

        return Mutable;
      }

      return CFStringCreateCopy(v6, origString);
    }

    if (!Mutable) {
      return Mutable;
    }
    CFRelease(Mutable);
    return 0LL;
  }

  return CFStringCreateCopy(v6, origString);
}

uint64_t _appendPercentEscapesForCharacter(unsigned __int16 *a1, int a2, uint64_t a3, __CFString *a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a2) {
    uint64_t v5 = 2LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  int v6 = CFStringEncodingUnicodeToBytes(a3, 0LL, a1, v5, 0LL, v15, 8LL, &v13);
  uint64_t result = 0LL;
  if (!v6)
  {
    if (v13 < 1)
    {
      CFIndex v8 = 0LL;
    }

    else
    {
      CFIndex v8 = 0LL;
      CFIndex v9 = (unsigned int *)((char *)v15 + v13);
      CFIndex v10 = v15;
      do
      {
        CFIndex v11 = &chars[v8];
        *CFIndex v11 = 37;
        unsigned int v12 = *(unsigned __int8 *)v10;
        CFIndex v10 = (unsigned int *)((char *)v10 + 1);
        v11[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v12 >> 4];
        v8 += 3LL;
        void v11[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v12 & 0xF];
      }

      while (v10 < v9);
    }

    CFStringAppendCharacters(a4, chars, v8);
    return 1LL;
  }

  return result;
}

CFStringRef CFURLCreateStringByAddingPercentEscapes( CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (!originalString) {
    return 0LL;
  }
  uint64_t v5 = *(void *)&encoding;
  CFIndex v8 = originalString;
  CFIndex Length = CFStringGetLength(originalString);
  if (!Length) {
    return CFStringCreateCopy(allocator, v8);
  }
  uint64_t v11 = Length;
  CFStringRef theString = v8;
  uint64_t v55 = 0LL;
  CFIndex v56 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v8);
  CStringPtr = 0LL;
  int v53 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v8, 0x600u);
  }
  CFIndex v58 = 0LL;
  CFRange v54 = CStringPtr;
  CFIndex v57 = 0LL;
  if (v11 < 1)
  {
LABEL_83:
    CFIndex v44 = CFGetAllocator(v8);
    return CFStringCreateCopy(v44, v8);
  }

  MutableCFStringRef Copy = 0LL;
  CFIndex v15 = 0LL;
  CFIndex v16 = 0LL;
  CFTypeRef cf = v8;
  do
  {
    if (v53)
    {
      UniChar v17 = v53[v55 + v15];
    }

    else if (v54)
    {
      UniChar v17 = v54[v55 + v15];
    }

    else
    {
      CFIndex v18 = v57;
      if (v58 <= v15 || v57 > v15)
      {
        CFIndex v20 = v15 - 4;
        if (v15 < 4) {
          CFIndex v20 = 0LL;
        }
        CFIndex v21 = v20 + 64;
        if (v20 + 64 >= v56) {
          CFIndex v21 = v56;
        }
        CFIndex v57 = v20;
        CFIndex v58 = v21;
        v60.CFIndex location = v55 + v20;
        v60.CFIndex length = v21 - v20;
        CFStringGetCharacters(theString, v60, buffer);
        CFIndex v18 = v57;
      }

      UniChar v17 = buffer[v15 - v18];
    }

    UniChar v47 = v17;
    if (v17 <= 0x7Fu && (sURLValidCharacters[v17] & 1) != 0)
    {
      if (!legalURLCharactersToBeEscaped || !_stringContainsCharacter(legalURLCharactersToBeEscaped, v17))
      {
LABEL_38:
        if (MutableCopy)
        {
          chars[v16] = v47;
          if (v16 == 1023)
          {
            CFStringAppendCharacters(MutableCopy, chars, 1024LL);
            CFIndex v16 = 0LL;
          }

          else
          {
            ++v16;
          }
        }

        goto LABEL_74;
      }
    }

    else if (charactersToLeaveUnescaped && _stringContainsCharacter(charactersToLeaveUnescaped, v17))
    {
      goto LABEL_38;
    }

    if (!MutableCopy)
    {
      char v22 = CFGetAllocator(cf);
      MutableCFStringRef Copy = CFStringCreateMutableCopy(v22, 0LL, cf);
      v61.CFIndex length = v11 - v15;
      v61.CFIndex location = v15;
      CFStringDelete(MutableCopy, v61);
    }

    if (v16 >= 1000)
    {
      CFStringAppendCharacters(MutableCopy, chars, v16);
      CFIndex v16 = 0LL;
    }

    if (!CFStringEncodingUnicodeToBytes(v5, 0LL, &v47, 1LL, 0LL, v49, 8LL, &v46))
    {
      if (v46 >= 1)
      {
        CFRange v28 = (unsigned int *)((char *)v49 + v46);
        int v29 = &chars[v16 + 2];
        CFIndex v30 = v49;
        do
        {
          unsigned int v31 = *(unsigned __int8 *)v30;
          CFIndex v30 = (unsigned int *)((char *)v30 + 1);
          *(v29 - 2) = 37;
          *(v29 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v31 >> 4];
          v16 += 3LL;
          *int v29 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v31 & 0xF];
          v29 += 3;
        }

        while (v30 < v28);
      }

      goto LABEL_74;
    }

    if ((_DWORD)v5 != 134217984) {
      break;
    }
    char v23 = charactersToLeaveUnescaped;
    uint64_t v24 = v5;
    if ((v47 & 0xFC00) != 0xD800) {
      break;
    }
    int v25 = legalURLCharactersToBeEscaped;
    CFIndex v26 = v15 + 1;
    if (v15 + 1 >= v11) {
      break;
    }
    if (v53)
    {
      UniChar v27 = v53[v55 + v26];
    }

    else if (v54)
    {
      UniChar v27 = v54[v55 + v26];
    }

    else
    {
      if (v58 <= v26 || (CFIndex v32 = v57, v57 > v26))
      {
        CFIndex v33 = v15 - 3;
        if (v15 < 3) {
          CFIndex v33 = 0LL;
        }
        CFIndex v34 = v33 + 64;
        if (v33 + 64 >= v56) {
          CFIndex v34 = v56;
        }
        CFIndex v57 = v33;
        CFIndex v58 = v34;
        v62.CFIndex location = v55 + v33;
        v62.CFIndex length = v34 - v33;
        CFStringGetCharacters(theString, v62, buffer);
        CFIndex v32 = v57;
      }

      UniChar v27 = buffer[v26 - v32];
    }

    if (v27 >> 10 != 55) {
      break;
    }
    v48[0] = v47;
    if (v53)
    {
      unsigned __int16 v35 = v53[v55 + v26];
    }

    else if (v54)
    {
      unsigned __int16 v35 = v54[v55 + v26];
    }

    else
    {
      if (v58 <= v26 || (CFIndex v36 = v57, v57 > v26))
      {
        CFIndex v37 = v15 - 3;
        if (v15 < 3) {
          CFIndex v37 = 0LL;
        }
        CFIndex v38 = v37 + 64;
        if (v37 + 64 >= v56) {
          CFIndex v38 = v56;
        }
        CFIndex v57 = v37;
        CFIndex v58 = v38;
        v63.CFIndex location = v55 + v37;
        v63.CFIndex length = v38 - v37;
        CFStringGetCharacters(theString, v63, buffer);
        CFIndex v36 = v57;
      }

      unsigned __int16 v35 = buffer[v26 - v36];
    }

    v48[1] = v35;
    if (v46 >= 1)
    {
      char v39 = (unsigned int *)((char *)v49 + v46);
      char v40 = &chars[v16 + 2];
      int v41 = v49;
      do
      {
        unsigned int v42 = *(unsigned __int8 *)v41;
        int v41 = (unsigned int *)((char *)v41 + 1);
        *(v40 - 2) = 37;
        *(v40 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v42 >> 4];
        v16 += 3LL;
        UniChar *v40 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v42 & 0xF];
        v40 += 3;
      }

      while (v41 < v39);
    }

    ++v15;
    legalURLCharactersToBeEscaped = v25;
    uint64_t v5 = v24;
    charactersToLeaveUnescaped = v23;
LABEL_74:
    ++v15;
  }

  while (v15 < v11);
  if (v15 >= v11)
  {
    CFIndex v8 = cf;
    if (MutableCopy)
    {
      if (v16) {
        CFStringAppendCharacters(MutableCopy, chars, v16);
      }
      return MutableCopy;
    }

    goto LABEL_83;
  }

  if (MutableCopy)
  {
    CFRelease(MutableCopy);
    return 0LL;
  }

  return MutableCopy;
}

uint64_t _stringContainsCharacter(const __CFString *a1, int a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v26 = 0LL;
  CFIndex v27 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  uint64_t v24 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  int v25 = CStringPtr;
  if (Length < 1) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  for (uint64_t i = 64LL; ; ++i)
  {
    uint64_t v11 = (unint64_t)v9 >= 4 ? 4LL : v9;
    if (v24)
    {
      UniChar v12 = v24[v9 + v26];
    }

    else if (v25)
    {
      UniChar v12 = v25[v26 + v9];
    }

    else
    {
      if (v29 <= v9 || v8 > v9)
      {
        uint64_t v14 = -v11;
        uint64_t v15 = v11 + v7;
        uint64_t v16 = i - v11;
        uint64_t v17 = v9 + v14;
        CFIndex v18 = v17 + 64;
        if (v17 + 64 >= v27) {
          CFIndex v18 = v27;
        }
        uint64_t v28 = v17;
        uint64_t v29 = v18;
        v19.CFIndex location = v17 + v26;
        if (v27 >= v16) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v27;
        }
        v19.CFIndex length = v20 + v15;
        CFStringGetCharacters(theString, v19, v22);
        uint64_t v8 = v28;
      }

      UniChar v12 = v22[v9 - v8];
    }

    if (a2 == v12) {
      break;
    }
    ++v9;
    --v7;
    if (Length == v9) {
      return 0LL;
    }
  }

  return 1LL;
}

void __CFURLDeallocate(unint64_t *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  uint64_t v3 = a1 + 3;
  if (atomic_load(a1 + 3))
  {
    uint64_t v5 = (const void *)atomic_load(v3);
    CFRelease(v5);
  }

  atomic_store(0xDEADBEEFuLL, v3);
  int v6 = (const void *)a1[4];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (void *)a1[5];
  if (v7)
  {
    uint64_t v8 = (const void *)v7[1];
    if (!v8 || (CFRelease(v8), (uint64_t v7 = (void *)a1[5]) != 0LL)) {
      CFAllocatorDeallocate(v2, v7);
    }
  }

  uint64_t v9 = a1 + 6;
  CFIndex v10 = (const void *)atomic_load(v9);
  if (v10) {
    CFRelease(v10);
  }
  atomic_store(0xDEADBEEFuLL, v9);
}

uint64_t __CFURLEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (((*(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16)) & 0xE0006DFF) != 0) {
    return 0LL;
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  int v6 = *(const void **)(a2 + 32);
  if (!v5)
  {
    if (v6) {
      return 0LL;
    }
LABEL_10:
    CFStringRef v7 = CFURLGetString((CFURLRef)a1);
    CFStringRef v8 = CFURLGetString((CFURLRef)a2);
    return CFEqual(v7, v8);
  }

  if (!v6) {
    return 0LL;
  }
  uint64_t result = CFEqual(v5, v6);
  if ((_DWORD)result) {
    goto LABEL_10;
  }
  return result;
}

CFURLRef __CFURLHash(const __CFURL *result)
{
  if (result)
  {
    CFStringRef v1 = CFURLGetString(result);
    return (const __CFURL *)CFHash(v1);
  }

  return result;
}

CFStringRef __CFURLCopyFormattingDescription(uint64_t a1)
{
  uint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (uint64_t v4 = v3, v5 = CFStringCompare(v3, @"data", 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    CFIndex v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFStringRef TruncatedURLString = CreateTruncatedURLString(v2, v10);
    CFStringRef v12 = TruncatedURLString;
    if (!v9) {
      return TruncatedURLString;
    }
    uint64_t v13 = CFURLGetString(*(CFURLRef *)(a1 + 32));
    CFStringRef v14 = CreateTruncatedURLString(v2, v13);
    CFStringRef v15 = CFStringCreateWithFormat(v2, 0LL, @"%@ -- %@", v12, v14);
    if (v12) {
      CFRelease(v12);
    }
    if (v14) {
      CFRelease(v14);
    }
    return v15;
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 32);
    CFStringRef v7 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    if (v6) {
      return CFStringCreateWithFormat(v2, 0LL, @"%@ -- %@", v7, *(void *)(a1 + 32));
    }
    else {
      return CFStringCreateCopy(v2, v7);
    }
  }

CFStringRef __CFURLCopyDescription(uint64_t a1)
{
  uint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (uint64_t v4 = v3, v5 = CFStringCompare(v3, @"data", 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    uint64_t v13 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFStringRef TruncatedURLString = CreateTruncatedURLString(v2, v13);
    CFStringRef v14 = *(const void **)(a1 + 32);
    if (v14)
    {
      CFStringRef v15 = CFCopyDescription(v14);
      CFStringRef v10 = CFStringCreateWithFormat( v2,  0LL,  @"<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}",  a1,  v2,  TruncatedURLString,  *(unsigned int *)(a1 + 20),  v15);
      CFRelease(v15);
      goto LABEL_9;
    }

    CFStringRef v9 = CFStringCreateWithFormat( v2,  0LL,  @"<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}",  a1,  v2,  TruncatedURLString,  *(unsigned int *)(a1 + 20));
  }

  else
  {
    uint64_t v6 = *(const void **)(a1 + 32);
    if (!v6)
    {
      unint64_t v11 = atomic_load((unint64_t *)(a1 + 24));
      return CFStringCreateWithFormat( v2,  0LL,  @"<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}",  a1,  v2,  v11,  *(unsigned int *)(a1 + 20));
    }

    CFStringRef TruncatedURLString = CFCopyDescription(v6);
    unint64_t v8 = atomic_load((unint64_t *)(a1 + 24));
    CFStringRef v9 = CFStringCreateWithFormat( v2,  0LL,  @"<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}",  a1,  v2,  v8,  *(unsigned int *)(a1 + 20),  TruncatedURLString);
  }

  CFStringRef v10 = v9;
LABEL_9:
  CFRelease(TruncatedURLString);
  return v10;
}

CFTypeID CFURLGetTypeID(void)
{
  return 29LL;
}

size_t CFShowURL(uint64_t a1)
{
  CFStringRef v1 = (FILE **)MEMORY[0x1895F89E0];
  uint64_t v2 = (FILE *)*MEMORY[0x1895F89E0];
  if (!a1)
  {
    CFComparisonResult v5 = "(null)\n";
    size_t v6 = 7LL;
    return fwrite(v5, v6, 1uLL, v2);
  }

  fprintf(v2, "<CFURL %p>{", (const void *)a1);
  int v4 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1);
  uint64_t v2 = *v1;
  if (v4)
  {
    CFComparisonResult v5 = "ObjC bridged object}\n";
    size_t v6 = 21LL;
    return fwrite(v5, v6, 1uLL, v2);
  }

  fwrite("\n\tRelative string: ", 0x13uLL, 1uLL, v2);
  unint64_t v8 = (const void *)atomic_load((unint64_t *)(a1 + 24));
  CFShow(v8);
  fwrite("\tBase URL: ", 0xBuLL, 1uLL, *v1);
  CFStringRef v9 = *v1;
  if (*(void *)(a1 + 32))
  {
    fprintf(v9, "<%p> ", *(const void **)(a1 + 32));
    CFShow(*(CFTypeRef *)(a1 + 32));
  }

  else
  {
    fwrite("(null)\n", 7uLL, 1uLL, v9);
  }

  return fprintf(*v1, "\tFlags: 0x%x\n}\n", *(_DWORD *)(a1 + 16));
}

unint64_t *_CFURLCreateWithRangesAndFlags( CFStringRef theString, void *a2, unsigned int a3, unsigned int a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a4;
  if ((a4 & 1) == 0) {
    goto LABEL_14;
  }
  uint64_t v13 = a2[1];
  switch(v13)
  {
    case 5LL:
      int HasPrefix = CFStringHasPrefix(theString, @"https");
      unsigned int v15 = 0x40000000;
      break;
    case 4LL:
      if (CFStringHasPrefix(theString, @"http"))
      {
        int v17 = 0x20000000;
LABEL_13:
        unsigned int v9 = v17 & 0xE0000000 | v9 & 0x1FFFFFFF;
        goto LABEL_14;
      }

      if (CFStringHasPrefix(theString, @"file"))
      {
        int v17 = 1610612736;
        goto LABEL_13;
      }

      int HasPrefix = CFStringHasPrefix(theString, @"data");
      unsigned int v15 = 0x80000000;
      break;
    case 3LL:
      int HasPrefix = CFStringHasPrefix(theString, @"ftp");
      unsigned int v15 = -1610612736;
      break;
    default:
      goto LABEL_14;
  }

  unsigned int v16 = v15 & 0xE0000000 | v9 & 0x1FFFFFFF;
  if (HasPrefix) {
    unsigned int v9 = v16;
  }
LABEL_14:
  size_t v18 = 16LL * a3;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(0LL, 0x1DuLL, v18 + 40, 0LL, (uint64_t)a5, a6, a7, a8);
  uint64_t v20 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v9;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, a2, v18);
    atomic_store((unint64_t)CFStringCreateCopy(0LL, theString), v20 + 3);
    if (a5) {
      CFTypeRef v21 = CFRetain(a5);
    }
    else {
      CFTypeRef v21 = 0LL;
    }
    _DWORD v20[4] = (unint64_t)v21;
  }

  return v20;
}

unint64_t *_CFURLInitWithURLString( unint64_t *a1, const __CFString *a2, int a3, const __CFURL *a4)
{
  uint64_t result = _CFURLCreateWithURLString((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, a3, a4);
  if (result)
  {
    size_t v6 = result;
    a1[2] = result[2];
    unint64_t v7 = atomic_load(result + 3);
    atomic_store(v7, a1 + 3);
    a1[5] = result[5];
    unint64_t v8 = atomic_load(result + 6);
    atomic_store(v8, a1 + 6);
    a1[4] = result[4];
    LODWORD(v7) = *((_DWORD *)result + 4);
    unint64_t v9 = *(void *)&vshl_u16( (uint16x4_t)(*(void *)&vdup_n_s16(v7) & 0xFF00FF00FF00FFLL),  (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01LL;
    LOWORD(v9) = vaddv_s16((int16x4_t)v9);
    int v10 = v9
        + (v7 & 1)
        + ((v7 >> 5) & 1)
        + ((v7 >> 6) & 1)
    if ((_BYTE)v10) {
      memcpy(a1 + 7, result + 7, 16LL * v10);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6);
    return (unint64_t *)1;
  }

  return result;
}

unint64_t *_CFURLCreateWithURLString( const __CFAllocator *a1, CFStringRef theString, int a3, const __CFURL *a4)
{
  size_t v6 = a1;
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    if (!theString) {
      return 0LL;
    }
    CFIndex Length = CFStringGetLength(theString);
    CFStringRef v87 = theString;
    CFIndex v90 = 0LL;
    uint64_t v91 = Length;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    CStringPtr = 0LL;
    UniChar v88 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    int64_t v89 = CStringPtr;
    CFIndex v92 = 0LL;
    CFIndex v93 = 0LL;
    if (Length >= 1)
    {
      CFIndex v10 = 0LL;
      int v11 = 0;
      CFIndex v12 = 0LL;
      uint64_t v13 = 0LL;
      do
      {
        CFIndex v14 = v12 + 64;
        if (v12 + 64 <= Length) {
          uint64_t v15 = 64LL;
        }
        else {
          uint64_t v15 = Length - v12;
        }
        if (v12 < 0 || (CFIndex v16 = v91, v15 + v12 > v91))
        {
          int v17 = 0LL;
        }

        else if (v88)
        {
          int v17 = (UniChar *)&v88[v90 + v12];
        }

        else
        {
          if (v15 > 64)
          {
            int v17 = 0LL;
LABEL_30:
            if (Length >= v14) {
              CFIndex v24 = v12 + 64;
            }
            else {
              CFIndex v24 = Length;
            }
            CFIndex v25 = v12;
            while (2)
            {
              uint64_t v26 = *v17;
              if (v13)
              {
                --v13;
                goto LABEL_38;
              }

              if (*v17 > 0x5Au)
              {
                uint64_t v13 = 0LL;
                if ((_DWORD)v26 == 91 || (_DWORD)v26 == 93)
                {
LABEL_38:
                  ++v17;
                  if (v24 == ++v25) {
                    goto LABEL_52;
                  }
                  continue;
                }
              }

              else
              {
                if ((_DWORD)v26 == 35)
                {
                  if (v11) {
                    return 0LL;
                  }
                  uint64_t v13 = 0LL;
                  int v11 = 1;
                  goto LABEL_38;
                }

                if ((_DWORD)v26 == 37)
                {
                  if (v25 + 2 >= Length) {
                    return 0LL;
                  }
                  uint64_t v13 = 2LL;
                  goto LABEL_38;
                }
              }

              break;
            }

            uint64_t v13 = 0LL;
            goto LABEL_38;
          }

          if (v15 + v12 > v93 || v12 < v10)
          {
            if (v14 < v91) {
              CFIndex v16 = v12 + 64;
            }
            CFIndex v92 = v12;
            CFIndex v93 = v16;
            v18.CFIndex location = v90 + v12;
            v18.CFIndex length = v16 - v12;
            if (v89)
            {
              if (v18.length)
              {
                CFRange v19 = &v89[v18.location];
                CFIndex v20 = v12 - v16;
                CFTypeRef v21 = buffer;
                do
                {
                  UniChar v22 = *v19++;
                  *v21++ = v22;
                  BOOL v23 = __CFADD__(v20++, 1LL);
                }

                while (!v23);
              }
            }

            else
            {
              CFStringGetCharacters(v87, v18, buffer);
            }
          }

          CFIndex v10 = v92;
          int v17 = &buffer[v12 - v92];
        }

        if (v15 >= 1) {
          goto LABEL_30;
        }
LABEL_52:
        v12 += v15;
      }

      while (v12 < Length);
    }

    size_t v6 = a1;
  }

  CFIndex v27 = CFStringGetLength(theString);
  CFStringRef v87 = theString;
  CFIndex v90 = 0LL;
  uint64_t v91 = v27;
  uint64_t v28 = CFStringGetCharactersPtr(theString);
  uint64_t v29 = 0LL;
  UniChar v88 = v28;
  if (!v28) {
    uint64_t v29 = CFStringGetCStringPtr(theString, 0x600u);
  }
  int64_t v89 = v29;
  CFIndex v92 = 0LL;
  CFIndex v93 = 0LL;
  if (v27 < 1) {
    goto LABEL_100;
  }
  if (v88)
  {
    CFIndex v30 = 0LL;
    UniChar v31 = v88[v90];
  }

  else if (v29)
  {
    CFIndex v30 = 0LL;
    UniChar v31 = v29[v90];
  }

  else
  {
    v33.CFIndex location = v90;
    v33.CFIndex length = v91 >= 64 ? 64LL : v91;
    CFIndex v93 = v33.length;
    CFStringGetCharacters(v87, v33, buffer);
    CFIndex v30 = v92;
    UniChar v31 = buffer[-v92];
  }

  if (v31 > 0x7Fu || (sURLValidCharacters[v31] & 2) == 0) {
    goto LABEL_100;
  }
  CFIndex v34 = 0LL;
  while (1)
  {
    CFIndex v35 = v34 + 64;
    if (v34 + 64 <= v27) {
      uint64_t v36 = 64LL;
    }
    else {
      uint64_t v36 = v27 - v34;
    }
    if (v34 < 0 || v36 + v34 > v91)
    {
      CFIndex v37 = 0LL;
      goto LABEL_91;
    }

    if (v88)
    {
      CFIndex v37 = (UniChar *)&v88[v90 + v34];
      goto LABEL_91;
    }

    if (v36 > 64) {
      break;
    }
    if (v36 + v34 > v93 || v34 < v30)
    {
      if (v35 >= v91) {
        CFIndex v35 = v91;
      }
      CFIndex v92 = v34;
      CFIndex v93 = v35;
      v38.CFIndex location = v90 + v34;
      v38.CFIndex length = v35 - v34;
      if (v89)
      {
        if (v38.length)
        {
          char v39 = &v89[v38.location];
          CFIndex v40 = v34 - v35;
          int v41 = buffer;
          do
          {
            UniChar v42 = *v39++;
            *v41++ = v42;
            BOOL v23 = __CFADD__(v40++, 1LL);
          }

          while (!v23);
        }
      }

      else
      {
        CFStringGetCharacters(v87, v38, buffer);
      }
    }

    CFIndex v30 = v92;
    CFIndex v37 = &buffer[v34 - v92];
LABEL_91:
    if (v36 >= 1) {
      goto LABEL_92;
    }
LABEL_97:
    v34 += v36;
    if (v34 >= v27) {
      goto LABEL_100;
    }
  }

  CFIndex v37 = 0LL;
LABEL_92:
  uint64_t v43 = 0LL;
  while (1)
  {
    uint64_t v44 = v37[v43];
    if ((_DWORD)v44 == 58) {
      break;
    }
    if (++v43 >= v36) {
      goto LABEL_97;
    }
  }

  a4 = 0LL;
LABEL_100:
  LODWORD(v82) = 0;
  _parseComponents(theString, a4, (unsigned int *)&v82, __src, (char *)&v81);
  size_t v45 = 16LL * v81;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(v6, 0x1DuLL, v45 + 40, 0LL, v46, v47, v48, v49);
  CFIndex v32 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v82;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, __src, v45);
    CFStringRef Copy = CFStringCreateCopy(v6, theString);
    uint64_t v52 = v32 + 3;
    atomic_store((unint64_t)Copy, v32 + 3);
    if (a4) {
      CFURLRef v53 = CFURLCopyAbsoluteURL(a4);
    }
    else {
      CFURLRef v53 = 0LL;
    }
    v32[4] = (unint64_t)v53;
    CFRange v54 = CFGetAllocator(v32);
    uint64_t v55 = (const __CFString *)atomic_load(v52);
    CFIndex v56 = CFStringGetLength(v55);
    __src[0] = 0LL;
    uint64_t v82 = 0LL;
    CFMutableStringRef theStringa = 0LL;
    int v79 = 0;
    CFIndex v57 = (const __CFString *)atomic_load(v52);
    constructBuffers(v57, (UInt8 *)buffer, __src, &v82, (char *)&v84, &v83);
    int v58 = *((_DWORD *)v32 + 4);
    if ((v58 & 0x4000) != 0)
    {
      uint64_t v81 = 0LL;
      uint64_t v60 = __src[0];
      uint64_t v61 = v82;
      uint64_t v62 = 2LL;
      int v63 = v84;
      do
      {
        unsigned int v64 = *((_DWORD *)v32 + 4);
        if ((v64 & v62) != 0)
        {
          unsigned int v65 = 0;
          unsigned int v66 = v62;
          do
          {
            char v67 = v66;
            v66 >>= 1;
            v65 += v64 & 1;
            v64 >>= 1;
          }

          while ((v67 & 2) == 0);
          __int128 v68 = (uint64_t *)&v32[2 * v65 + 7];
          if (*v68 != -1) {
            scanCharacters(v54, &theStringa, &v79, v60, v61, v63, *v68, v68[1] + *v68, &v81, v62, *((_DWORD *)v32 + 5));
          }
        }

        v62 *= 2LL;
      }

      while (v62 < 512);
      CFStringRef v69 = (unint64_t *)theStringa;
      if (theStringa)
      {
LABEL_120:
        int v70 = v79;
        unint64_t v71 = v32[5];
        if (v79 && !v71)
        {
          _CFURLAllocateExtraDataspace(v32);
          unint64_t v71 = v32[5];
        }

        if (v71) {
          *(_DWORD *)(v71 + 16) = v70;
        }
        unint64_t v72 = v56 - v81;
        if (v56 > v81)
        {
          if (v63) {
            __CFStringAppendBytes(v69, (unsigned __int8 *)(v60 + v81), v72, 513LL);
          }
          else {
            CFStringAppendCharacters((CFMutableStringRef)v69, (const UniChar *)(v61 + 2 * v81), v72);
          }
        }

        unint64_t v73 = v32[5];
        if (v73 || (_CFURLAllocateExtraDataspace(v32), (unint64_t v73 = v32[5]) != 0))
        {
          CFRange v74 = *(const void **)(v73 + 8);
          if (v74) {
            CFRelease(v74);
          }
          uint64_t v75 = CFGetAllocator(v32);
          *(void *)(v32[5] + _Block_object_dispose((const void *)(v1 - 160), 8) = CFStringCreateCopy(v75, (CFStringRef)v69);
        }

        CFRelease(v69);
      }

      else
      {
        *((_DWORD *)v32 + 4) |= 0x10000u;
      }
    }

    else
    {
      if ((v58 & 1) != 0) {
        uint64_t v59 = v32[8] + 1;
      }
      else {
        uint64_t v59 = 1LL;
      }
      uint64_t v81 = 0LL;
      uint64_t v60 = __src[0];
      uint64_t v61 = v82;
      int v63 = v84;
      if (!scanCharacters( v54,  &theStringa,  &v79,  __src[0],  v82,  v84,  v59,  v56,  &v81,  0,  *((_DWORD *)v32 + 5))) {
        *((_DWORD *)v32 + 4) |= 0x10000u;
      }
      CFStringRef v69 = (unint64_t *)theStringa;
      if (theStringa) {
        goto LABEL_120;
      }
    }

    if (v83)
    {
      CFRange v76 = __src;
      if (!v84) {
        CFRange v76 = &v82;
      }
      free((void *)*v76);
    }
  }

  return v32;
}