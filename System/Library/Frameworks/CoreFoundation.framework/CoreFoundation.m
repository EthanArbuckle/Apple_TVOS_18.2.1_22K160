const CFArrayCallBacks *__CFArrayGetCallBacks(uint64_t a1)
{
  unsigned int v1;
  int v2;
  char v4;
  int v5;
  uint64_t v6;
  v1 = atomic_load((unint64_t *)(a1 + 8));
  v2 = (v1 >> 2) & 3;
  if (!v2) {
    return (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v2 == 1) {
    return &kCFTypeArrayCallBacks;
  }
  v4 = atomic_load((unint64_t *)(a1 + 8));
  v5 = v4 & 3;
  if (v5) {
    v6 = 0LL;
  }
  else {
    v6 = a1 + 48;
  }
  if (v5 == 2) {
    return (const CFArrayCallBacks *)(a1 + 48);
  }
  else {
    return (const CFArrayCallBacks *)v6;
  }
}

void __CFArrayDeallocate(unint64_t a1)
{
}

uint64_t __CFArrayEqual(unint64_t *a1, unint64_t *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t v4 = a1[2];
  if (v4 != a2[2]) {
    return 0LL;
  }
  unsigned int v5 = atomic_load(a1 + 1);
  int v6 = (v5 >> 2) & 3;
  if (v6)
  {
    if (v6 == 1)
    {
      v7 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v9 = atomic_load(a1 + 1);
      int v10 = v9 & 3;
      uint64_t v11 = v10 ? 0LL : (uint64_t)(a1 + 6);
      v7 = v10 == 2 ? (const CFArrayCallBacks *)(a1 + 6) : (const CFArrayCallBacks *)v11;
    }
  }

  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  unsigned int v12 = atomic_load(a2 + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      v14 = &kCFTypeArrayCallBacks;
    }

    else
    {
      atomic_load(a2 + 1);
      v14 = (const CFArrayCallBacks *)(a2 + 6);
    }
  }

  else
  {
    v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  if (v7->equal != v14->equal) {
    return 0LL;
  }
  if (v4 < 1) {
    return 1LL;
  }
  uint64_t v15 = 0LL;
  while (1)
  {
    atomic_load(a1 + 1);
    char v16 = atomic_load(a1 + 1);
    if ((v16 & 3) != 0)
    {
      uint64_t v17 = a1[5] + 8LL * *(void *)a1[5] + 16;
    }

    else
    {
      char v18 = atomic_load(a1 + 1);
      uint64_t v19 = (~v18 & 0xC) != 0 ? 48LL : 88LL;
      uint64_t v17 = (uint64_t)a1 + v19;
    }

    uint64_t v20 = *(void *)(v17 + 8 * v15);
    atomic_load(a2 + 1);
    char v21 = atomic_load(a2 + 1);
    if ((v21 & 3) != 0)
    {
      uint64_t v22 = a2[5] + 8LL * *(void *)a2[5] + 16;
    }

    else
    {
      char v23 = atomic_load(a2 + 1);
      uint64_t v24 = (~v23 & 0xC) != 0 ? 48LL : 88LL;
      uint64_t v22 = (uint64_t)a2 + v24;
    }

    if (v20 != *(void *)(v22 + 8 * v15))
    {
      equal = (uint64_t (*)(void))v7->equal;
      if (!equal) {
        return 0LL;
      }
      uint64_t result = equal();
      if (!(_DWORD)result) {
        break;
      }
    }

    if (v4 == ++v15) {
      return 1LL;
    }
  }

  return result;
}

uint64_t __CFArrayHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFArrayCopyDescription(unint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if ((a1 & 0x8000000000000000LL) != 0)
  {
    v3 = &kCFAllocatorSystemDefault;
  }

  else
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    if (v4 < 0) {
      v3 = &kCFAllocatorSystemDefault;
    }
    else {
      v3 = (const CFAllocatorRef *)(a1 - 16);
    }
  }

  CFAllocatorRef v5 = *v3;
  Mutable = CFStringCreateMutable(*v3, 0LL);
  v7 = Mutable;
  char v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = v8 & 3;
  if (v9)
  {
    if (v9 != 2) {
      goto LABEL_13;
    }
    int v10 = CFSTR("<CFArray %p [%p]>{type = mutable-small, count = %lu, values = (%s");
  }

  else
  {
    int v10 = CFSTR("<CFArray %p [%p]>{type = immutable, count = %lu, values = (%s");
  }

  uint64_t v11 = "\n";
  if (!v2) {
    uint64_t v11 = "";
  }
  CFStringAppendFormat(Mutable, 0LL, v10, a1, v5, v2, v11);
LABEL_13:
  unsigned int v12 = atomic_load((unint64_t *)(a1 + 8));
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      v14 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v15 = atomic_load((unint64_t *)(a1 + 8));
      int v16 = v15 & 3;
      if (v16 != 2 && v16) {
        v14 = 0LL;
      }
      else {
        v14 = (const CFArrayCallBacks *)(a1 + 48);
      }
    }
  }

  else
  {
    v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  if (v2 >= 1)
  {
    for (uint64_t i = 0LL; i != v2; ++i)
    {
      atomic_load((unint64_t *)(a1 + 8));
      char v18 = atomic_load((unint64_t *)(a1 + 8));
      if ((v18 & 3) != 0)
      {
        uint64_t v19 = *(void *)(a1 + 40) + 8LL * **(void **)(a1 + 40) + 16;
      }

      else
      {
        char v20 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v21 = (~v20 & 0xC) == 0LL;
        uint64_t v22 = 48LL;
        if (v21) {
          uint64_t v22 = 88LL;
        }
        uint64_t v19 = a1 + v22;
      }

      uint64_t v23 = *(void *)(v19 + 8 * i);
      copyDescription = (uint64_t (*)(uint64_t))v14->copyDescription;
      if (copyDescription && (uint64_t v25 = copyDescription(v23)) != 0)
      {
        v26 = (const void *)v25;
        CFStringAppendFormat(v7, 0LL, @"\t%lu : %@\n", i, v25);
        CFRelease(v26);
      }

      else
      {
        CFStringAppendFormat(v7, 0LL, @"\t%lu : <%p>\n", i, v23);
      }
    }
  }

  CFStringAppend(v7, @"}"));
  return v7;
}

CFTypeID CFArrayGetTypeID(void)
{
  return 19LL;
}

unint64_t *__CFArrayCreateTransfer( const __CFAllocator *a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10 = 8 * a3;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(a1, 0x13uLL, (8 * a3 + 32), 0LL, a5, a6, a7, a8);
  unsigned int v12 = Instance;
  if (!Instance) {
    return v12;
  }
  int v13 = Instance + 1;
  unint64_t v14 = atomic_load(Instance + 1);
  do
  {
    unint64_t v15 = __ldaxr(v13);
    if (v15 == v14)
    {
      if (!__stlxr(v14 & 0xFFFFFFFFFFFFFF80LL | 4, v13))
      {
        int v16 = 1;
        goto LABEL_8;
      }
    }

    else
    {
      __clrex();
    }

    int v16 = 0;
LABEL_8:
    unint64_t v14 = v15;
  }

  while (!v16);
  Instance[2] = a3;
  char v17 = atomic_load(Instance + 1);
  int v18 = v17 & 3;
  if (v18 == 2)
  {
    uint64_t v22 = (unint64_t *)(Instance[5] + 8LL * *(void *)Instance[5] + 16);
  }

  else if (v18)
  {
    uint64_t v22 = 0LL;
  }

  else
  {
    char v19 = atomic_load(Instance + 1);
    BOOL v20 = (~v19 & 0xC) == 0LL;
    uint64_t v21 = 6LL;
    if (v20) {
      uint64_t v21 = 11LL;
    }
    uint64_t v22 = &Instance[v21];
  }

  memmove(v22, a2, v10);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v12;
}

uint64_t __CFArrayCreate0( const __CFAllocator *a1, uint64_t *a2, uint64_t a3, const CFArrayCallBacks *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Init = __CFArrayCreateInit(a1, 0, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = Init;
  unsigned int v13 = atomic_load((unint64_t *)(Init + 8));
  int v14 = (v13 >> 2) & 3;
  if (v14)
  {
    if (v14 == 1)
    {
      unint64_t v15 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v16 = atomic_load((unint64_t *)(Init + 8));
      int v17 = v16 & 3;
      if (v17) {
        int v18 = 0LL;
      }
      else {
        int v18 = (const CFArrayCallBacks *)(Init + 48);
      }
      if (v17 == 2) {
        unint64_t v15 = (const CFArrayCallBacks *)(Init + 48);
      }
      else {
        unint64_t v15 = v18;
      }
    }
  }

  else
  {
    unint64_t v15 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  char v19 = atomic_load((unint64_t *)(Init + 8));
  int v20 = v19 & 3;
  if (v20 == 2)
  {
    uint64_t v24 = (void *)(*(void *)(Init + 40) + 8LL * **(void **)(Init + 40) + 16);
  }

  else if (v20)
  {
    uint64_t v24 = 0LL;
  }

  else
  {
    char v21 = atomic_load((unint64_t *)(Init + 8));
    BOOL v22 = (~v21 & 0xC) == 0LL;
    uint64_t v23 = 48LL;
    if (v22) {
      uint64_t v23 = 88LL;
    }
    uint64_t v24 = (void *)(Init + v23);
  }

  if (v15->retain)
  {
    if (a3 >= 1)
    {
      uint64_t v25 = a3;
      do
      {
        uint64_t v26 = *a2++;
        *v24++ = ((uint64_t (*)(const __CFAllocator *, uint64_t))v15->retain)(a1, v26);
        --v25;
      }

      while (v25);
    }
  }

  else if (a3 >= 1)
  {
    uint64_t v27 = a3;
    do
    {
      uint64_t v28 = *a2++;
      *v24++ = v28;
      --v27;
    }

    while (v27);
  }

  *(void *)(v12 + 16) = a3;
  return v12;
}

uint64_t __CFArrayCreateInit( const __CFAllocator *a1, char a2, int a3, const CFArrayCallBacks *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2 & 3;
  unsigned int v10 = v9;
  if (a4)
  {
    retain = (CFTypeRef (*)(int, CFTypeRef))a4->retain;
    if (retain || a4->release || a4->copyDescription || (unsigned int v10 = a2 & 3, a4->equal))
    {
      if (a4 == &kCFTypeArrayCallBacks
        || retain == __CFTypeCollectionRetain
        && (void (*)(int, CFTypeRef))a4->release == __CFTypeCollectionRelease
        && a4->copyDescription == CFCopyDescription
        && a4->equal == CFEqual)
      {
        unsigned int v10 = v9 | 4;
      }

      else
      {
        unsigned int v10 = v9 | 0xC;
      }
    }
  }

  int v12 = v10 & 0xC;
  int v13 = 8 * a3;
  if ((a2 & 3) != 0) {
    int v13 = 0;
  }
  if (v12 == 12) {
    int v14 = 72;
  }
  else {
    int v14 = 32;
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x13uLL, (v14 + v13), 0LL, a5, a6, a7, a8);
  uint64_t v16 = Instance;
  if (Instance)
  {
    int v17 = (unint64_t *)(Instance + 8);
    unint64_t v18 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v19 = __ldaxr(v17);
      if (v19 != v18) {
        break;
      }
      if (__stlxr(v18 & 0xFFFFFFFFFFFFFF80LL | v10, v17)) {
        goto LABEL_24;
      }
      int v20 = 1;
LABEL_25:
      unint64_t v18 = v19;
      if (v20)
      {
        *(void *)(Instance + 16) = 0LL;
        if (v9 == 2)
        {
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          *(void *)(v16 + 24) = 1LL;
          *(_DWORD *)(v16 + 32) = 0;
          *(void *)(v16 + 40) = 0LL;
        }

        else if (!v9 && __CFOASafe)
        {
          __CFSetLastAllocationEventName();
        }

        if (v12 == 12)
        {
          unsigned int v21 = atomic_load(v17);
          int v22 = (v21 >> 2) & 3;
          if (v22)
          {
            if (v22 == 1)
            {
              uint64_t v23 = (CFArrayCallBacks *)&kCFTypeArrayCallBacks;
            }

            else
            {
              atomic_load((unint64_t *)(v16 + 8));
              uint64_t v23 = (CFArrayCallBacks *)(v16 + 48);
            }
          }

          else
          {
            uint64_t v23 = (CFArrayCallBacks *)&__kCFNullArrayCallBacks;
          }

          __int128 v24 = *(_OWORD *)&a4->version;
          __int128 v25 = *(_OWORD *)&a4->release;
          v23->equal = a4->equal;
          *(_OWORD *)&v23->version = v24;
          *(_OWORD *)&v23->release = v25;
        }

        return v16;
      }
    }

    __clrex();
LABEL_24:
    int v20 = 0;
    goto LABEL_25;
  }

  return v16;
}

uint64_t __CFArrayCreateMutable0( const __CFAllocator *a1, int a2, const CFArrayCallBacks *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __CFArrayCreateInit(a1, 2, a2, a3, a5, a6, a7, a8);
}

uint64_t __CFArrayCreateCopy0(const __CFAllocator *a1, unint64_t *a2)
{
  else {
    uint64_t v4 = a2[2];
  }
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a2))
  {
LABEL_5:
    int v9 = &kCFTypeArrayCallBacks;
    goto LABEL_6;
  }

  unsigned int v15 = atomic_load(a2 + 1);
  int v16 = (v15 >> 2) & 3;
  if (v16)
  {
    if (v16 != 1)
    {
      char v17 = atomic_load(a2 + 1);
      int v18 = v17 & 3;
      if (v18) {
        unint64_t v19 = 0LL;
      }
      else {
        unint64_t v19 = (const CFArrayCallBacks *)(a2 + 6);
      }
      if (v18 == 2) {
        int v9 = (const CFArrayCallBacks *)(a2 + 6);
      }
      else {
        int v9 = v19;
      }
      goto LABEL_6;
    }

    goto LABEL_5;
  }

  int v9 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
LABEL_6:
  uint64_t Init = __CFArrayCreateInit(a1, 0, v4, v9, v5, v6, v7, v8);
  uint64_t v11 = Init;
  unsigned int v12 = atomic_load((unint64_t *)(Init + 8));
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      int v14 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v20 = atomic_load((unint64_t *)(Init + 8));
      int v21 = v20 & 3;
      if (v21 != 2 && v21) {
        int v14 = 0LL;
      }
      else {
        int v14 = (const CFArrayCallBacks *)(Init + 48);
      }
    }
  }

  else
  {
    int v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  char v22 = atomic_load((unint64_t *)(Init + 8));
  int v23 = v22 & 3;
  if (v23 == 2)
  {
    uint64_t v27 = *(void *)(Init + 40) + 8LL * **(void **)(Init + 40) + 16;
  }

  else if (v23)
  {
    uint64_t v27 = 0LL;
  }

  else
  {
    char v24 = atomic_load((unint64_t *)(Init + 8));
    BOOL v25 = (~v24 & 0xC) == 0LL;
    uint64_t v26 = 48LL;
    if (v25) {
      uint64_t v26 = 88LL;
    }
    uint64_t v27 = Init + v26;
  }

  if (v4 >= 1)
  {
    for (uint64_t i = 0LL; i != v4; ++i)
    {
      uint64_t v29 = [a2 objectAtIndex:i];
      retain = (uint64_t (*)(const __CFAllocator *, uint64_t))v14->retain;
      if (retain) {
        uint64_t v29 = retain(a1, v29);
      }
      *(void *)(v27 + 8 * i) = v29;
    }
  }

  *(void *)(v11 + 16) = v4;
  return v11;
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  else {
    return *((void *)theArray + 2);
  }
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", idx);
}

__CFArray *__CFArrayCreateMutableCopy0(const __CFAllocator *a1, uint64_t a2, unint64_t *a3)
{
  else {
    uint64_t v6 = a3[2];
  }
  unsigned int v16 = atomic_load(a3 + 1);
  int v17 = (v16 >> 2) & 3;
  if (v17)
  {
    if (v17 == 1)
    {
LABEL_5:
      uint64_t v11 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }

    char v18 = atomic_load(a3 + 1);
    int v19 = v18 & 3;
    if (v19 != 2 && v19) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = (const CFArrayCallBacks *)(a3 + 6);
    }
  }

  else
  {
    uint64_t v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

LABEL_6:
  uint64_t Init = __CFArrayCreateInit(a1, 2, a2, v11, v7, v8, v9, v10);
  int v13 = (__CFArray *)Init;
  if (!a2) {
    _CFArraySetCapacity(Init, v6);
  }
  if (v6 >= 1)
  {
    for (uint64_t i = 0LL; i != v6; ++i)
      CFArrayAppendValue(v13, (const void *)[a3 objectAtIndex:i]);
  }

  return v13;
}

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_9;
  }
  retain = v11->retain;
  release = v11->release;
  if (retain)
  {
    if (release) {
      goto LABEL_9;
    }
  }

  else if (!release)
  {
LABEL_9:
    if (length >= 2)
    {
      else {
        int v14 = (const void **)values;
      }
      v26.location = location;
      v26.length = length;
      CFArrayGetValues(theArray, v26, v14);
      v24[0] = comparator;
      v24[1] = context;
      CFQSortArray(v14, length, 8LL, (uint64_t)__CFArrayCompareValues, (uint64_t)v24, v19, v20, v21);
      if ((isKindOfClass & 1) != 0)
      {
        v27.location = location;
        v27.length = length;
        CFArrayReplaceValues(theArray, v27, v14, length);
      }
    }

    return;
  }

  if (length >= 2)
  {
    do
    {
      if (location < location - 1 + length)
      {
        char v22 = 0LL;
        do
        {
          if (((uint64_t (*)(uint64_t, uint64_t, void *))comparator)( -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v22 + 1),  -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v22),  context) < 0) {
            CFArrayExchangeValuesAtIndices(theArray, location + v22, location + v22 + 1);
          }
          ++v22;
        }

        while (length - 1 != v22);
      }
    }

    while (length-- > 2);
  }

  if (a4) {
    *a4 = v11;
  }
  return 1LL;
}

    ++a1;
    if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0
      || a4 && ((*(unsigned __int8 *)(a4 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
    {
    }

    else if (!a5 {
           || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
    }
           || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a5 + (v14 >> 3))) == 0)
    {
      return a1;
    }

  uint64_t result = a2;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  return result;
}

  uint64_t v8 = 0LL;
  uint64_t v9 = 1;
LABEL_9:
  uint64_t v10 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)v5);
  if (a3 || v10 || (*(_BYTE *)(v5 + 17) & 0x80) == 0 || (uint64_t v11 = _retainedComponentString(v5, 32, 1, 1)) == 0LL)
  {
    int v13 = CFURLCopyPath((CFURLRef)v5);
    int v14 = *(_DWORD *)(v5 + 20);
    if (v9 && CFURLIsFileReferenceURL((CFURLRef)v5))
    {
      unsigned int v15 = FileReferenceURLPathToFullURLPath(v13, a1);
      CFRelease(v13);
      int v13 = v15;
    }

    if (!v13) {
      return v8;
    }
    if (a3 == 2)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v13, @"/");
      Count = CFArrayGetCount(ArrayBySeparatingStrings);
      MutableCopy = CFArrayCreateMutableCopy(a1, Count, ArrayBySeparatingStrings);
      CFRelease(ArrayBySeparatingStrings);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      if (!CFStringGetLength(ValueAtIndex)) {
        CFArrayRemoveValueAtIndex(MutableCopy, --Count);
      }
      if (Count >= 2)
      {
        int v21 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0LL);
        if (!CFStringGetLength(v21))
        {
          char v22 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 1LL);
          int v23 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v22, @"\\"", v14);
          if (v23)
          {
            char v24 = v23;
            if (CFStringGetLength(v23) == 2)
            {
              CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 1LL);
              uint64_t v26 = CharacterAtIndex;
              if (CharacterAtIndex == 124 || CharacterAtIndex == 58)
              {
                CFArrayRemoveValueAtIndex(MutableCopy, 0LL);
                if (v26 == 124)
                {
                  uint64_t v27 = CFStringGetCharacterAtIndex(v24, 0LL);
                  uint64_t v28 = CFStringCreateWithFormat(a1, 0LL, @"%c:", v27);
                  CFArraySetValueAtIndex(MutableCopy, 0LL, v28);
                  CFRelease(v28);
                }
              }
            }

            CFRelease(v24);
          }
        }
      }

      uint64_t v29 = CFStringCreateByCombiningStrings(a1, MutableCopy, @"\\"");
      CFRelease(MutableCopy);
      unsigned int v12 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v29, @"\\"", v14);
      CFRelease(v29);
    }

    else
    {
      if (a3)
      {
        unsigned int v12 = v8;
LABEL_65:
        CFRelease(v13);
        return v12;
      }

      unsigned int v16 = _CFURLHasFileURLScheme((__objc2_class **)v5, 0LL);
      unsigned int v12 = URLPathToPOSIXPath(v13, a1, v14, v16);
    }

    CFRelease(v13);
    if (!v12) {
      return v8;
    }
  }

  else
  {
    unsigned int v12 = v11;
  }

  if (!CFURLHasDirectoryPath((CFURLRef)v5)
    || CFStringGetLength(v12) < 2
    || (v30 = CFStringGetLength(v12), CFStringGetCharacterAtIndex(v12, v30 - 1) != 47)
    || (v49.length = CFStringGetLength(v12) - 1,
        v49.location = 0LL,
        v31 = CFStringCreateWithSubstring(a1, v12, v49),
        CFRelease(v12),
        (unsigned int v12 = v31) != 0LL))
  {
    Length = CFStringGetLength(v12);
    if (a3 != 2)
    {
      if (Length >= 1)
      {
        v33 = CFStringGetCharacterAtIndex(v12, 0LL) != 47;
LABEL_53:
        if (v8 && v33)
        {
          v34 = CFURLHasDirectoryPath(v7);
          v35 = CFStringGetLength(v8);
          v36 = CFStringGetLength(v12);
          v37 = _CFGetSlash();
          v38 = (UniChar *)CFAllocatorAllocate(a1, 2 * (v36 + v35) + 4, 0LL);
          v47.location = 0LL;
          v47.length = v35;
          CFStringGetCharacters(v8, v47, v38);
          if (v34)
          {
            if (v38[v35 - 1] != v37) {
              v38[v35++] = v37;
            }
          }

          else
          {
            v39 = 2 * v35 - 2;
            do
            {
              v40 = v39;
              v41 = (UniChar *)((char *)v38 + v39);
              if (v41 <= v38) {
                break;
              }
              v42 = *v41;
              v39 = v40 - 2;
            }

            while (v42 != v37);
            v35 = (v40 >> 1) + 1;
          }

          v43 = &v38[v35 - (a3 == 1)];
          v48.location = 0LL;
          v48.length = v36;
          CFStringGetCharacters(v12, v48, v43);
          v44 = &v43[v36];
          *v44 = 0;
          v45 = _resolvedPath((char *)v38, (unint64_t)v44, v37, 0, 1, a1);
          CFRelease(v8);
          int v13 = v12;
          unsigned int v12 = v45;
          goto LABEL_65;
        }

    LOBYTE(v12) = 0;
    return v12;
  }

  if (a1 == 12)
  {
    if (a2 > 0xE)
    {
      if (a2 - 15 <= 1)
      {
        for (uint64_t i = 2049; i > 1; --i)
        {
          *(_DWORD *)a3 = a4 << 31 >> 31;
          a3 += 4;
        }

        LOBYTE(v12) = 0;
        if (a4) {
          int v19 = 63;
        }
        else {
          int v19 = -64;
        }
        *(a3 - 5) = v19;
        return v12;
      }
    }

    else
    {
      int v13 = (char *)*(&__CFUniCharLegalCharacterSetBitmap + a2);
      if (v13)
      {
        int v14 = 8193;
        if ((a4 & 1) != 0)
        {
          do
          {
            LOBYTE(v12) = 0;
            unsigned int v15 = *v13++;
            *a3++ = v15;
            --v14;
          }

          while (v14 > 1);
        }

        else
        {
          do
          {
            LOBYTE(v12) = 0;
            unsigned int v16 = *v13++;
            *a3++ = ~v16;
            --v14;
          }

          while (v14 > 1);
        }

        return v12;
      }

      if (a2 == 14)
      {
        uint64_t v29 = 0LL;
        *a3 = 2;
        v30 = (uint64x2_t)vdupq_n_s64(0x1FFFuLL);
        do
        {
          v31 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v29), (int8x16_t)xmmword_180CA51F0);
          LOBYTE(v12) = 0;
          v29 += 2LL;
        }

        while (v29 != 0x2000);
        return v12;
      }
    }

    int v17 = a4 == 0;
    unsigned int v12 = -1;
  }

  else
  {
    if ((a1 < 4 || a1 == 15) && !a2)
    {
      memset(a3, a4 << 31 >> 31, 0x2000uLL);
      if (a1 != 15 && a1 != 3) {
        goto LABEL_33;
      }
      for (j = 0LL; j != 7; ++j)
      {
        int v21 = (unsigned __int16)word_180CA5204[j];
        char v22 = 1 << (v21 & 7);
        int v23 = v21 >> 3;
        char v24 = a3[v23];
        BOOL v25 = v24 & ~(_BYTE)v22;
        uint64_t v26 = v24 | v22;
        if (a4) {
          uint64_t v26 = v25;
        }
        a3[v23] = v26;
      }

      if (a1 != 15)
      {
LABEL_33:
        uint64_t v27 = a3[1];
        if (a4)
        {
          a3[1] = v27 & 0xFD;
          a3[4] &= ~1u;
          a3[20] &= ~1u;
          a3[720] &= ~1u;
          a3[1029] &= ~0x80u;
          a3[1035] &= ~0x80u;
          uint64_t v28 = a3[1536] & 0xFE;
        }

        else
        {
          a3[1] = v27 | 2;
          a3[4] |= 1u;
          a3[20] |= 1u;
          a3[720] |= 1u;
          a3[1029] |= 0x80u;
          a3[1035] |= 0x80u;
          uint64_t v28 = a3[1536] | 1;
        }

        a3[1536] = v28;
        for (k = 0x2000LL; k != 8204; ++k)
        {
          v34 = 1 << (k & 7);
          v35 = (unsigned __int16)k >> 3;
          v36 = a3[v35];
          v37 = v36 & ~(_BYTE)v34;
          v38 = v36 | v34;
          if (a4) {
            v38 = v37;
          }
          a3[v35] = v38;
        }
      }

      goto LABEL_6;
    }

    int v17 = a4 == 0;
    unsigned int v12 = 1;
  }

  if (v17) {
    return -v12;
  }
  return v12;
}

    --v3;
  }

  while (v3 != a1);
  if ((v4 & 0x80000000) != 0) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
LABEL_18:
  uint64_t v8 = _safe_recursive_mkdir_chown(v7, v4);
  uint64_t v9 = *__error();
  close(v4);
  *__error() = v9;
  return v8 == 0;
}

      uint64_t v2 = v3;
      goto LABEL_7;
    }

    if (v6 != 47) {
      break;
    }
    for (v2 += 2; (unint64_t)v2 < v1; ++v2)
    {
      uint64_t v7 = *v2;
      uint64_t v8 = (v7 - 8232) < 2 || v7 == 10;
      if (v8 || v7 == 13) {
        break;
      }
    }

void _CFArraySetCapacity(uint64_t a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x13uLL, (__objc2_class **)a1))
  {
    char v4 = atomic_load((unint64_t *)(a1 + 8));
    if ((v4 & 3) == 2LL)
    {
      uint64_t v5 = *(void **)(a1 + 40);
      if (a2 >= 4)
      {
        if (flsl(a2) == 31) {
          uint64_t v6 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v6 = 1 << flsl(a2);
        }
      }

      else
      {
        uint64_t v6 = 4LL;
      }

      if (a1 < 0)
      {
        uint64_t v7 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v8 = atomic_load((unint64_t *)(a1 + 8));
        if (v8 < 0) {
          uint64_t v7 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v7 = (const CFAllocatorRef *)(a1 - 16);
        }
      }

      uint64_t v9 = *v7;
      if (v5)
      {
        uint64_t v10 = v5[1];
        uint64_t v11 = (uint64_t *)CFAllocatorAllocate(*v7, 8 * v6 + 16, 0LL);
        if (v11)
        {
          unsigned int v12 = v11;
          memmove(v11, v5, 8 * v10 + 16);
          CFAllocatorDeallocate(v9, v5);
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
LABEL_24:
          v12[1] = v6;
          *(void *)(a1 + 40) = v12;
          return;
        }
      }

      else
      {
        int v13 = (uint64_t *)CFAllocatorAllocate(*v7, 8 * v6 + 16, 0LL);
        if (v13)
        {
          unsigned int v12 = v13;
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          if (v6 >= 0) {
            uint64_t v14 = v6;
          }
          else {
            uint64_t v14 = v6 + 1;
          }
          *unsigned int v12 = v14 >> 1;
          goto LABEL_24;
        }
      }

      __CFArrayHandleOutOfMemory(8 * v6 + 16);
    }
  }
}

  ;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  v4[1] = *MEMORY[0x1895F89C0];
  v4[0] = value;
  else {
    _CFArrayReplaceValues((unint64_t)theArray, *((void *)theArray + 2), 0LL, v4, 1LL);
  }
}

uint64_t _CFNonObjCArrayGetCount(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

CFIndex CFArrayGetCountOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  unsigned int v11 = atomic_load((unint64_t *)theArray + 1);
  int v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      uint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }

    char v13 = atomic_load((unint64_t *)theArray + 1);
    int v14 = v13 & 3;
    if (v14) {
      unsigned int v15 = 0LL;
    }
    else {
      unsigned int v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v14 == 2) {
      uint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      uint64_t v7 = v15;
    }
  }

  else
  {
    uint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

LABEL_3:
  if (length < 1) {
    return 0LL;
  }
  CFIndex v8 = 0LL;
  do
  {
    uint64_t v9 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location);
    if (v9 == value
      || (equal = (unsigned int (*)(const void *, const void *))v7->equal) != 0LL && equal(value, v9))
    {
      ++v8;
    }

    ++location;
    --length;
  }

  while (length);
  return v8;
}

  if (length < 1) {
    return 0;
  }
  while (1)
  {
    CFIndex v8 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location);
    if (v8 == value) {
      break;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v8)) {
        break;
      }
    }

    ++location;
    if (!--length) {
      return 0;
    }
  }

  return 1;
}

  if (length < 1) {
    return -1LL;
  }
  CFIndex v8 = 0LL;
  for (uint64_t i = location; ; ++i)
  {
    uint64_t v10 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", i);
    if (v10 == value) {
      break;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal && equal(value, v10)) {
      return i;
    }
    ++v8;
    if (!--length) {
      return -1LL;
    }
  }

  return v8 + location;
}

  if (!length) {
    return -1LL;
  }
  while (1)
  {
    CFIndex v8 = length - 1;
    uint64_t v9 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location - 1 + length);
    if (v9 == value) {
      return v8 + location;
    }
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v9)) {
        break;
      }
    }

    --length;
    if (!v8) {
      return -1LL;
    }
  }

  return location + length - 1;
}

    unsigned int v15 = 0;
    unsigned int v16 = 0;
    int v17 = 0;
    char v18 = 0;
    int v19 = 0LL;
    char v20 = 1;
    goto LABEL_4;
  }

  if (a3 < 0x3C) {
    goto LABEL_3;
  }
  int v23 = 60LL;
LABEL_36:
  uint64_t v29 = a2[1];
  if (v23 > v29) {
    goto LABEL_3;
  }
  if (a2[5] != 1128680784)
  {
    if (a2[11] == -252513032)
    {
      int v19 = 0LL;
      goto LABEL_54;
    }

    v34 = 11LL;
LABEL_53:
    int v19 = a2[v34] != -118164752;
LABEL_54:
    int v17 = 0;
    if (a2[5] == 1128680784) {
      goto LABEL_55;
    }
LABEL_56:
    v35 = 4060;
    goto LABEL_57;
  }

  if (a2[10] != -252513032)
  {
    v34 = 10LL;
    goto LABEL_53;
  }

  int v17 = 0;
  int v19 = 0LL;
LABEL_55:
  v35 = 4056;
LABEL_57:
  char v18 = v35 < v29;
  if (v17 || v35 < v29)
  {
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    if (v22 < 0) {
      goto LABEL_76;
    }
    goto LABEL_74;
  }

  if (v22 < 0)
  {
    unsigned int v15 = a2[14];
    v37 = (v15 - 1610612737) < 0x9FFFFFFE || a2[10] != v15;
    unsigned int v16 = v37;
    goto LABEL_76;
  }

  if (a2[5] == 1128680784)
  {
    unsigned int v15 = a2[13];
    if ((v15 - 1610612737) >= 0x9FFFFFFE)
    {
      v36 = -56;
LABEL_72:
      v38 = v36 + (int)v29 < v15;
      goto LABEL_73;
    }
  }

  else
  {
    unsigned int v15 = a2[14];
    if ((v15 - 1610612737) >= 0x9FFFFFFE)
    {
      v36 = -60;
      goto LABEL_72;
    }
  }

  v38 = 1;
LABEL_73:
  unsigned int v16 = v38;
LABEL_74:
  if (a2[5] == 1128680784)
  {
    v39 = 10LL;
    goto LABEL_77;
  }

  uint64_t v10 = *(_DWORD *)(a1 + 24);
  if (v10 == -1) {
    unsigned int v11 = *(void *)(a1 + 16) * a2;
  }
  else {
    unsigned int v11 = a2 << v10;
  }
  Byte = __CFStorageFindByte((void *)a1, a1 + 144, v11, 0LL, v40, &v38, 1);
  char v13 = v40[0];
  int v14 = v38;
  if (v40[0])
  {
    unsigned int v15 = *(void *)v40[0];
    unsigned int v16 = *(_DWORD *)(a1 + 24);
    if (v16 == -1)
    {
      BOOL v25 = *(void *)(a1 + 16);
      int v17 = v38 / v25;
      char v18 = v15 / v25;
    }

    else
    {
      int v17 = v38 >> v16;
      char v18 = v15 >> v16;
    }
  }

  else
  {
    int v17 = 0LL;
    char v18 = 0LL;
  }

  os_unfair_lock_lock_with_options();
  *(void *)(a1 + 104) = v13;
  *(void *)(a1 + 112) = v17;
  *(void *)(a1 + 120) = v18;
  os_unfair_lock_unlock(v6);
  uint64_t v26 = *(_DWORD *)(a1 + 24);
  if (v26 != -1)
  {
    uint64_t v27 = v14 >> v26;
    uint64_t v28 = v39 >> v26;
    if (!a3) {
      return Byte;
    }
    goto LABEL_23;
  }

  uint64_t v29 = *(void *)(a1 + 16);
  uint64_t v27 = v14 / v29;
  uint64_t v28 = v39 / v29;
  if (a3)
  {
LABEL_23:
    *a3 = v27;
    a3[1] = v28;
  }

  return Byte;
}

  char v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0LL);
  if (v4) {
    goto LABEL_4;
  }
LABEL_23:
  CFRelease(v2);
}

  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)ValueWithKeyPath;
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  unsigned int v11 = atomic_load((unint64_t *)theArray + 1);
  int v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      uint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }

    char v13 = atomic_load((unint64_t *)theArray + 1);
    int v14 = v13 & 3;
    if (v14) {
      unsigned int v15 = 0LL;
    }
    else {
      unsigned int v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v14 == 2) {
      uint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      uint64_t v7 = v15;
    }
  }

  else
  {
    uint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

uint64_t _CFArrayCheckAndGetValueAtIndex(unint64_t *a1, int64_t a2, _BYTE *a3)
{
  if (a2 < 0 || (uint64_t)a1[2] <= a2)
  {
    if (a3) {
      *a3 = 1;
    }
    return -1LL;
  }

  else
  {
    atomic_load(a1 + 1);
    char v3 = atomic_load(a1 + 1);
    if ((v3 & 3) != 0)
    {
      uint64_t v4 = a1[5] + 8LL * *(void *)a1[5] + 16;
    }

    else
    {
      char v6 = atomic_load(a1 + 1);
      BOOL v7 = (~v6 & 0xC) == 0LL;
      uint64_t v8 = 6LL;
      if (v7) {
        uint64_t v8 = 11LL;
      }
      uint64_t v4 = (uint64_t)&a1[v8];
    }

    return *(void *)(v4 + 8 * a2);
  }

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray getObjects:range:](theArray, "getObjects:range:", values, location, length);
    return;
  }

  if (length >= 1)
  {
    char v7 = atomic_load((unint64_t *)theArray + 1);
    int v8 = v7 & 3;
    if (v8 == 2)
    {
      int v12 = (char *)(*((void *)theArray + 5) + 8LL * **((void **)theArray + 5) + 16);
LABEL_11:
      memmove(values, &v12[8 * location], 8 * length);
      return;
    }

    if (!v8)
    {
      char v9 = atomic_load((unint64_t *)theArray + 1);
      BOOL v10 = (~v9 & 0xC) == 0LL;
      uint64_t v11 = 48LL;
      if (v10) {
        uint64_t v11 = 88LL;
      }
      int v12 = (char *)theArray + v11;
      goto LABEL_11;
    }
  }

unint64_t _CFArrayFastEnumeration(unint64_t *a1, void *a2)
{
  if (!a1[2]) {
    return 0LL;
  }
  char v2 = atomic_load(a1 + 1);
  int v3 = v2 & 3;
  if (v3 != 2)
  {
    if (!v3 && !*a2)
    {
      *a2 = 1LL;
      a2[2] = &_CFArrayFastEnumeration_const_mu;
      char v4 = atomic_load(a1 + 1);
      int v5 = v4 & 3;
      if (v5 != 2)
      {
        if (!v5)
        {
LABEL_7:
          char v6 = atomic_load(a1 + 1);
          BOOL v7 = (~v6 & 0xC) == 0LL;
          uint64_t v8 = 6LL;
          if (v7) {
            uint64_t v8 = 11LL;
          }
          uint64_t v9 = (uint64_t)&a1[v8];
          goto LABEL_16;
        }

        goto LABEL_14;
      }

LABEL_15:
      uint64_t v9 = a1[5] + 8LL * *(void *)a1[5] + 16;
      goto LABEL_16;
    }

    return 0LL;
  }

  if (*a2) {
    return 0LL;
  }
  *a2 = 1LL;
  a2[2] = a1 + 3;
  char v11 = atomic_load(a1 + 1);
  int v12 = v11 & 3;
  if (v12 == 2) {
    goto LABEL_15;
  }
  if (!v12) {
    goto LABEL_7;
  }
LABEL_14:
  uint64_t v9 = 0LL;
LABEL_16:
  a2[1] = v9;
  return a1[2];
}

    unsigned int v16 = v9;
    BOOL v10 = _os_log_pack_size();
    char v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v17 = _os_log_pack_fill();
    char v18 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v17,  (uint64_t)"-[NSMutableSet removeObjectsInArray:range:]",  location,  length,  --v16);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v18,  "-[NSMutableSet removeObjectsInArray:range:]",  location,  length,  v16);
    goto LABEL_16;
  }

  for (; length; --length)
    -[NSMutableSet removeObject:](self, "removeObject:", [a3 objectAtIndex:location++]);
}

    unsigned int v16 = v9;
    BOOL v10 = _os_log_pack_size();
    char v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v17 = _os_log_pack_fill();
    char v18 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v17,  (uint64_t)"-[NSMutableSet removeObjectsInOrderedSet:range:]",  location,  length,  --v16);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v18,  "-[NSMutableSet removeObjectsInOrderedSet:range:]",  location,  length,  v16);
    goto LABEL_16;
  }

  for (; length; --length)
    -[NSMutableSet removeObject:](self, "removeObject:", [a3 objectAtIndex:location++]);
}

  int v19 = 0LL;
  v70 = 0LL;
  v71 = 0LL;
  char v20 = 0LL;
  int v21 = 0;
  char v22 = 0;
  int v23 = 0;
  char v24 = MEMORY[0x1895F8770];
  BOOL v25 = (char *)a1;
  while (1)
  {
    uint64_t v26 = (char *)&a1[v19];
    uint64_t v27 = a1[v19];
    if ((v27 & 0x80000000) != 0) {
      break;
    }
    if ((*(_DWORD *)(v24 + 4LL * v27 + 60) & 0x100) == 0) {
      goto LABEL_21;
    }
LABEL_18:
    if (v23) {
      uint64_t v28 = __toupper(v27);
    }
    else {
      uint64_t v28 = __tolower(v27);
    }
    const void *v26 = v28;
LABEL_25:
    ++v19;
  }

  if (__maskrune(a1[v19], 0x100uLL)) {
    goto LABEL_18;
  }
LABEL_21:
  if (v27 - 48 < 0xA)
  {
    int v21 = 1;
    goto LABEL_25;
  }

  if (v22)
  {
    if (v23)
    {
      int v23 = 1;
      char v20 = v25;
      goto LABEL_51;
    }

    uint64_t v29 = (_DWORD)v25 - (_DWORD)a1;
    if ((_DWORD)v25 - (_DWORD)a1 + 3 != (_DWORD)v19 || v21)
    {
      if (v29 + 4 == (_DWORD)v19 && v21)
      {
        if (*v25 == 95) {
          goto LABEL_38;
        }
        v30 = v71;
        if (!v71) {
          v30 = v25;
        }
        v71 = v30;
      }

      else if (v29 + 5 != (_DWORD)v19 || v21)
      {
        if (v29 + 1 == (_DWORD)v19 && *v25 == 95)
        {
          int v23 = 1;
          goto LABEL_51;
        }
      }

      else
      {
        v25[1] = __toupper(v25[1]);
      }
    }

    else
    {
      if (*v25 == 95)
      {
        v25[1] = __toupper(v25[1]);
        v25[2] = __toupper(v25[2]);
LABEL_38:
        int v23 = 1;
        v70 = v25;
        goto LABEL_51;
      }

      if (!v71)
      {
        v25[1] = __toupper(v25[1]);
        v25[2] = __toupper(v25[2]);
        v71 = v25;
      }
    }

    int v23 = 0;
    *BOOL v25 = 45;
    goto LABEL_51;
  }

  if (v21) {
    goto LABEL_53;
  }
LABEL_51:
  int v21 = 0;
  v31 = *v26;
  char v22 = 1;
  BOOL v25 = (char *)&a1[v19];
  if (v31 == 95 || v31 == 45) {
    goto LABEL_25;
  }
LABEL_53:
  v32 = a4;
  *a4 = 0;
  if (v20)
  {
    v33 = uloc_canonicalize();
    if (v33 >= 256) {
      v34 = 256;
    }
    else {
      v34 = v33;
    }
    a4[v34] = 0;
    for (uint64_t i = a4 + 1; *(i - 1); ++i)
    {
      if (*(i - 1) == 64)
      {
        do
        {
          *char v20 = 0;
          v36 = *--v20;
        }

        while (v36 == 95);
        LOBYTE(v37) = *(i - 1);
        if ((_BYTE)v37)
        {
          v38 = 0LL;
          do
          {
            a4[v38] = v37;
            v37 = i[v38++];
          }

          while (v37);
          v32 = &a4[v38];
        }

        break;
      }
    }

    *v32 = 0;
  }

  v39 = &specialCases;
  v40 = "-UK";
  while (2)
  {
    if (*v39)
    {
      uint64_t result = _CheckForTag((uint64_t)a1, (const char *)*v39);
      if (!(_DWORD)result) {
        goto LABEL_107;
      }
    }

    v42 = (char *)v39[2];
    v43 = *v42;
    if ((v43 & 0x80000000) != 0)
    {
      if (!__maskrune(v43, 0x8000uLL)) {
        goto LABEL_77;
      }
LABEL_72:
      uint64_t result = (unint64_t)strstr(a1, v40);
      if (!result) {
        goto LABEL_92;
      }
      v44 = (char *)result;
      v45 = *(char *)(result + 3);
      if ((v45 & 0x80000000) != 0)
      {
        uint64_t result = __maskrune(v45, 0x500uLL);
        if (!(_DWORD)result) {
          goto LABEL_89;
        }
      }

      else
      {
        uint64_t result = *(_DWORD *)(v24 + 4LL * v45 + 60) & 0x500;
        if (!(_DWORD)result)
        {
LABEL_89:
          v50 = *v42;
          if (*v42)
          {
            v51 = (unsigned __int8 *)(v42 + 1);
            v52 = v44 + 1;
            do
            {
              *v52++ = v50;
              v53 = *v51++;
              v50 = v53;
            }

            while (v53);
          }
        }
      }

    uint64_t v9 = 0LL;
    while (v5 != *(unsigned __int8 *)(v6 + v9))
    {
      if (++v9 == 7) {
        goto LABEL_25;
      }
    }

    if (v9 == 3)
    {
      BOOL v10 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        BOOL v10 = 0xFFFFFFFFFFFFFLL;
      }
      char v11 = v10 & (v4 >> 3);
      goto LABEL_26;
    }

    goto LABEL_25;
  }

  if (!CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
  {
LABEL_25:
    LOBYTE(v11) = atomic_load((unint64_t *)number + 1);
LABEL_26:
    uint64_t result = __CFNumberCanonicalTypes[v11 & 7];
    goto LABEL_27;
  }

    BOOL v7 = 0LL;
    while (v5 != *(unsigned __int8 *)(v6 + v7))
    {
      if (++v7 == 7) {
        goto LABEL_25;
      }
    }

  BOOL v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    uint64_t result = (ConstStringPtr)*p_data;
  }

  else
  {
    char v13 = atomic_load((unint64_t *)&theString->info);
    uint64_t result = (ConstStringPtr)&p_data[(v13 & 5) != 4LL];
  }

  int v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) != 4LL)
  {
    unsigned int v15 = atomic_load((unint64_t *)&theString->info);
    if ((v15 & 5) == 4LL)
    {
      unsigned int v16 = *result;
    }

    else
    {
      int v17 = atomic_load((unint64_t *)&theString->info);
      unsigned int v16 = (v17 & 0x60) != 0 ? theString->length : (uint64_t)*p_data;
    }

    if (v16 != *result) {
      return 0LL;
    }
  }

  return result;
}

    if (a1 >= a6) {
      return a1;
    }
  }

  BOOL v25 = v21;
  uint64_t v26 = (v14 << 10) + v21 - 56613888;
  a1 += 2LL;
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0xAu, HIWORD(v26));
  if (BitmapPtrForPlane
    && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v26 >> 3)) >> (v25 & 7)) & 1) != 0)
  {
    goto LABEL_15;
  }

  uint64_t v28 = CFUniCharGetBitmapPtrForPlane(0xBu, HIWORD(v26));
  if (v28)
  {
  }

  uint64_t v29 = CFUniCharGetBitmapPtrForPlane(0x6Cu, HIWORD(v26));
  if (v29)
  {
  }

  return a1;
}

  char v20 = v15[4];
  if (a5)
  {
    char v20 = bswap32(v20);
    int v21 = bswap32(v15[5]);
  }

  else
  {
    int v21 = v15[5];
  }

  int v19 = 0LL;
  if (v21 <= 0xFE0) {
    char v22 = v21 + 32LL;
  }
  else {
    char v22 = 4096LL;
  }
  if (v20 && v22 >= 0x21)
  {
    int v23 = (int *)(v15 + 8);
    char v24 = 1;
    BOOL v25 = 32LL;
    while (1)
    {
      uint64_t v26 = *v23;
      if (a5) {
        break;
      }
      if (v26 == 12)
      {
        uint64_t v27 = v23[2];
LABEL_29:
        uint64_t v28 = (char *)v15 + v25 + v27;
        int v19 = v28 + 20 <= (const char *)v15 + v22 && strncmp(v28, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        uint64_t v29 = v23[1];
        if (a5) {
          goto LABEL_34;
        }
        goto LABEL_35;
      }

      int v19 = 0LL;
      uint64_t v29 = v23[1];
LABEL_36:
      if (v24 < v20)
      {
        v25 += v29;
        int v23 = (int *)((char *)v15 + v25);
        ++v24;
        if (v25 < v22) {
          continue;
        }
      }

      goto LABEL_50;
    }

    if (v26 == 201326592)
    {
      uint64_t v27 = bswap32(v23[2]);
      goto LABEL_29;
    }

    int v19 = 0LL;
    uint64_t v29 = v23[1];
LABEL_34:
    uint64_t v29 = bswap32(v29);
LABEL_35:
    if (v19) {
      goto LABEL_50;
    }
    goto LABEL_36;
  }

  if ((v20 & 0x80000000) != 0)
  {
LABEL_21:
    char v24 = *__error();
    BOOL v25 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      _CFPrefsTemporaryFDToWriteTo_cold_4(v24, (uint64_t)v29, v25);
    }
    *__error() = v24;
LABEL_24:
    CFRelease(v19);
    CFRelease(PathComponent);
    CFRelease(v16);
    return 0xFFFFFFFFLL;
  }

  fchown(v20, v12, v11);
  fchmod(v20, v10);
  CFRelease(v19);
  CFRelease(PathComponent);
  CFRelease(v16);
  return v20;
}

    int v14 = -[NSOrderedSet initWithObjects:count:](self, "initWithObjects:count:");
    free(v11);
    return v14;
  }

  unsigned int v16 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v5);
  int v17 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v16,  0LL);
  CFRelease(v16);
  objc_exception_throw(v17);
  __break(1u);
  return result;
}

    int v14 = (NSOrderedSet *)(id)[objc_alloc((Class)a1) initWithObjects:v10 count:v5];
    free(v11);
    return v14;
  }

  unsigned int v16 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v5);
  int v17 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v16,  0LL);
  CFRelease(v16);
  objc_exception_throw(v17);
  __break(1u);
  return result;
}

    LOBYTE(v7) = 1;
  }

  return v7;
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  if (range.length >= 1)
  {
    uint64_t v17 = v9;
    uint64_t v18 = v8;
    uint64_t v19 = v7;
    uint64_t v20 = v6;
    uint64_t v21 = v5;
    uint64_t v22 = v4;
    uint64_t v23 = v10;
    uint64_t v24 = v11;
    CFIndex length = range.length;
    CFIndex location = range.location;
    do
    {
      ((void (*)(uint64_t, void *))applier)( -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location++, v17, v18, v19, v20, v21, v22, v23, v24),  context);
      --length;
    }

    while (length);
  }

uint64_t CFArrayApply(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3 - 1;
  if (a3 >= 1)
  {
    uint64_t v7 = (void *)result;
    do
    {
      uint64_t v8 = [v7 objectAtIndex:a2];
      char v10 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a4 + 16))(a4, v8, &v10);
      if (v10) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v4 == 0;
      }
      --v4;
      ++a2;
    }

    while (!v9);
  }

  return result;
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  unsigned int v12 = atomic_load((unint64_t *)theArray + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      uint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }

    char v14 = atomic_load((unint64_t *)theArray + 1);
    int v15 = v14 & 3;
    if (v15) {
      unsigned int v16 = 0LL;
    }
    else {
      unsigned int v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v15 == 2) {
      uint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      uint64_t v7 = v16;
    }
  }

  else
  {
    uint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  unsigned int v12 = atomic_load((unint64_t *)theArray + 1);
  int v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      uint64_t v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }

    char v14 = atomic_load((unint64_t *)theArray + 1);
    int v15 = v14 & 3;
    if (v15) {
      unsigned int v16 = 0LL;
    }
    else {
      unsigned int v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    if (v15 == 2) {
      uint64_t v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
    else {
      uint64_t v7 = v16;
    }
  }

  else
  {
    uint64_t v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

void _CFArrayReplaceValues(unint64_t a1, uint64_t a2, uint64_t a3, void *__src, uint64_t a5)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
  int v11 = (v10 >> 2) & 3;
  if (v11)
  {
    if (v11 == 1)
    {
      unsigned int v12 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v13 = atomic_load((unint64_t *)(a1 + 8));
      int v14 = v13 & 3;
      if (v14 == 2)
      {
        unsigned int v12 = (const CFArrayCallBacks *)(a1 + 48);
      }

      else if (v14)
      {
        unsigned int v12 = 0LL;
      }

      else
      {
        unsigned int v12 = (const CFArrayCallBacks *)(a1 + 48);
      }
    }
  }

  else
  {
    unsigned int v12 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  int v15 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000LL) == 0)
  {
    char v16 = atomic_load((unint64_t *)(a1 + 8));
    if (v16 < 0) {
      int v15 = &kCFAllocatorSystemDefault;
    }
    else {
      int v15 = (const CFAllocatorRef *)(a1 - 16);
    }
  }

  unint64_t v17 = *(void *)(a1 + 16) - a3;
  uint64_t v18 = *v15;
  uint64_t v19 = __src;
  if (v12->retain)
  {
    if (a5 >= 257)
    {
      uint64_t v19 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * a5, 0LL);
      if (v19 != v67 && __CFOASafe != 0) {
        __CFSetLastAllocationEventName();
      }
    }

    else
    {
      uint64_t v19 = v67;
      if (a5 < 1) {
        goto LABEL_25;
      }
    }

    uint64_t v21 = 0LL;
    do
    {
      *(void *)&v19[8 * v21] = ((uint64_t (*)(const __CFAllocator *, void))v12->retain)(v18, __src[v21]);
      ++v21;
    }

    while (a5 != v21);
  }

LABEL_25:
  ++*(void *)(a1 + 24);
  if (a3 >= 1) {
    __CFArrayReleaseValues(a1, a2, a3, 0);
  }
  uint64_t v22 = *(uint64_t **)(a1 + 40);
  unint64_t v66 = v17 + a5;
  if (v22)
  {
    uint64_t v23 = a5 - a3;
    if (a5 == a3) {
      goto LABEL_92;
    }
    int64_t v24 = *(void *)(a1 + 16);
    uint64_t v25 = v24 - a3 + a5;
    v63 = v22 + 2;
    uint64_t v64 = v24 - a3 - a2;
    uint64_t v27 = *v22;
    unint64_t v26 = v22[1];
    uint64_t v28 = v26 >> 17;
    if (v26 >> 17 <= 4) {
      uint64_t v28 = 4LL;
    }
    if (v26 < v25 || (uint64_t v29 = v26 - v24, v24 < v25) && v29 < v28)
    {
      uint64_t v30 = v28 + v25;
      uint64_t v62 = *v22;
      if (v28 + v25 >= 4)
      {
        if (flsl(v28 + v25) == 31) {
          uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v31 = 1 << flsl(v30);
        }
      }

      else
      {
        uint64_t v31 = 4LL;
      }

      uint64_t v65 = a2;
      if ((a1 & 0x8000000000000000LL) != 0)
      {
        v50 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v51 = atomic_load((unint64_t *)(a1 + 8));
        if (v51 < 0) {
          v50 = &kCFAllocatorSystemDefault;
        }
        else {
          v50 = (const CFAllocatorRef *)(a1 - 16);
        }
      }

      allocator = *v50;
      v52 = CFAllocatorAllocate(*v50, 8 * v31 + 16, 0LL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      v53 = v52 + 2;
      if (v31 >= v25) {
        uint64_t v54 = v31 - v25;
      }
      else {
        uint64_t v54 = v31 - v25 + 1;
      }
      void *v52 = v54 >> 1;
      v52[1] = v31;
      if (v65 >= 1) {
        memmove(&v53[v54 >> 1], &v63[v62], 8 * v65);
      }
      if (v64 >= 1) {
        memmove(&v53[v65 + a5 + (v54 >> 1)], &v63[a3 + v65 + v62], 8 * v64);
      }
      *(void *)(a1 + 40) = v52;
      CFAllocatorDeallocate(allocator, v22);
      a2 = v65;
      goto LABEL_92;
    }

    BOOL v33 = v23 <= v29 - v27 || v23 < 0;
    uint64_t v34 = v24 - a3 - a2;
    if (v33 && v64 < a2)
    {
      uint64_t v58 = v27 + a2 + a3;
      uint64_t v59 = v27 + a2 + a5;
      if (v64 >= 1)
      {
        memmove(&v63[v59], &v63[v58], 8 * v64);
        uint64_t v34 = v64;
      }

      if (a5 < a3)
      {
        v49 = &v63[v59 + v34];
        uint64_t v48 = v58 - v59;
        goto LABEL_103;
      }
    }

    else
    {
      uint64_t v36 = v27 - v23;
      BOOL v38 = v27 < v23 || v64 < a2;
      if (v23 < 0 || !v38)
      {
        *uint64_t v22 = v36;
        if (a2 >= 1) {
          memmove(&v22[v36 + 2], &v22[v27 + 2], 8 * a2);
        }
        if (v23 < 0)
        {
          v49 = &v63[v27];
          size_t v60 = -8 * v23;
          goto LABEL_114;
        }
      }

      else
      {
        BOOL v39 = v29 < v23;
        uint64_t v40 = v29 - v23;
        if (v39) {
          uint64_t v41 = v40 + 1;
        }
        else {
          uint64_t v41 = v40;
        }
        uint64_t v42 = v41 >> 1;
        if (v39) {
          v40 += 3LL;
        }
        uint64_t v43 = *v22;
        uint64_t v44 = v42 - (v40 >> 2);
        uint64_t v45 = a3 + a2 + *v22;
        uint64_t v46 = a2 + a5 + v44;
        *uint64_t v22 = v44;
        uint64_t v47 = v43;
        if (v44 >= v43)
        {
          if (v64 >= 1) {
            memmove(&v63[v46], &v63[v45], 8 * v64);
          }
          if (a2 >= 1) {
            memmove(&v63[v44], &v63[v47], 8 * a2);
          }
          if (v44 > v47)
          {
            size_t v60 = 8 * (v44 - v47);
            v49 = &v63[v47];
            goto LABEL_114;
          }
        }

        else
        {
          if (a2 >= 1)
          {
            memmove(&v63[v44], &v63[v43], 8 * a2);
            uint64_t v34 = v64;
          }

          if (v34 >= 1)
          {
            memmove(&v63[v46], &v63[v45], 8 * v34);
            uint64_t v34 = v64;
          }

          uint64_t v48 = v45 - v46;
          if (v45 > v46)
          {
            v49 = &v63[v46 + v34];
LABEL_103:
            size_t v60 = 8 * v48;
LABEL_114:
            bzero(v49, v60);
          }
        }
      }
    }
  }

  else if (((v17 + a5) & 0x8000000000000000LL) == 0)
  {
    if (v66 >= 4)
    {
      if (flsl(v66) == 31) {
        uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v32 = 1 << flsl(v66);
      }
    }

    else
    {
      uint64_t v32 = 4LL;
    }

    v55 = CFAllocatorAllocate(v18, 8 * v32 + 16, 0LL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    uint64_t v56 = v32 - a5;
    if (v32 < a5) {
      ++v56;
    }
    void *v55 = v56 >> 1;
    v55[1] = v32;
    *(void *)(a1 + 40) = v55;
  }

  *a6 = 0LL;
  return v12;
}

  if (v24)
  {
    uint64_t v32 = 2 * v24 * *(unsigned __int8 *)(a6 + 7);
    v69 = v24;
  }

  else
  {
    v69 = 0LL;
    uint64_t v32 = 0LL;
  }

  if (__CFADD__(v32, v23) || a3 + v20 < (unint64_t)v23 + v32 - 1)
  {
LABEL_36:
    CFRelease(theSet);
    if (cf) {
      CFRelease(cf);
    }
    return 0LL;
  }

  v70 = *(unsigned __int8 *)(a6 + 7);
  v74 = 0LL;
  v75 = &v74;
  v76 = 0x2020000000LL;
  Count = CFSetGetCount(theSet);
  v73[0] = MEMORY[0x1895F87A8];
  v73[1] = 3221225472LL;
  v73[2] = ____CFPropertyListCreateFilteredDictionary_block_invoke;
  v73[3] = &unk_189995A70;
  v73[4] = &v74;
  CFSetApply(theSet, (uint64_t)v73);
  *(void *)buffer = 0LL;
  v84 = 0LL;
  if (CFSetGetCount(theSet) == 1)
  {
    values[0] = 0LL;
    CFSetGetValues(theSet, (const void **)values);
    CStringPtr = CFStringGetCStringPtr((CFStringRef)values[0], 0);
    if (CStringPtr)
    {
LABEL_35:
      v67 = CStringPtr;
      unint64_t v66 = (void *)strlen(CStringPtr);
      goto LABEL_41;
    }

    if (CFStringGetCString((CFStringRef)values[0], buffer, 16LL, 0))
    {
      CStringPtr = buffer;
      goto LABEL_35;
    }
  }

  unint64_t v66 = 0LL;
  v67 = 0LL;
LABEL_41:
  Mutable = CFDictionaryCreateMutable(a1, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v24)
  {
    uint64_t v65 = v24 * v70;
    v71 = a3 + 8;
    v72 = 0LL;
    if (v66) {
      uint64_t v36 = v67 == 0LL;
    }
    else {
      uint64_t v36 = 1;
    }
    v37 = v36;
    uint64_t v68 = v37;
    BOOL v38 = values;
    if (a7) {
      BOOL v38 = 0LL;
    }
    uint64_t v64 = (uint64_t)v38;
    while (1)
    {
      if (!v75[3]) {
        goto LABEL_122;
      }
      BOOL v39 = *(void *)(a6 + 24);
      uint64_t v40 = *(unsigned __int8 *)(a6 + 7);
      uint64_t v41 = *(unsigned __int8 *)(a6 + 7);
      switch(*(_BYTE *)(a6 + 7))
      {
        case 0:
          break;
        case 1:
          uint64_t v41 = *(unsigned __int8 *)v23;
          break;
        case 2:
          uint64_t v41 = __rev16(*(unsigned __int16 *)v23);
          break;
        case 4:
          uint64_t v41 = bswap32(*v23);
          break;
        case 8:
          uint64_t v41 = bswap64(*(void *)v23);
          break;
        default:
          uint64_t v41 = 0LL;
          uint64_t v42 = v23;
          do
          {
            uint64_t v43 = *(unsigned __int8 *)v42;
            uint64_t v42 = (unsigned int *)((char *)v42 + 1);
            uint64_t v41 = v43 | (v41 << 8);
            --v40;
          }

          while (v40);
          break;
      }

      if (*(void *)(a6 + 8) <= v41)
      {
LABEL_119:
        CFRelease(Mutable);
LABEL_121:
        Mutable = 0LL;
        goto LABEL_122;
      }

      uint64_t v44 = *(unsigned __int8 *)(a6 + 6);
      uint64_t v45 = (unsigned int *)(a3 + v39 + v41 * v44);
      switch(*(_BYTE *)(a6 + 6))
      {
        case 0:
          break;
        case 1:
          uint64_t v44 = *(unsigned __int8 *)v45;
          break;
        case 2:
          uint64_t v44 = __rev16(*(unsigned __int16 *)v45);
          break;
        case 4:
          uint64_t v44 = bswap32(*v45);
          break;
        case 8:
          uint64_t v44 = bswap64(*(void *)v45);
          break;
        default:
          uint64_t v46 = *(unsigned __int8 *)(a6 + 6);
          uint64_t v44 = 0LL;
          do
          {
            uint64_t v47 = *(unsigned __int8 *)v45;
            uint64_t v45 = (unsigned int *)((char *)v45 + 1);
            uint64_t v44 = v47 | (v44 << 8);
            --v46;
          }

          while (v46);
          break;
      }

      uint64_t v48 = theSet;
      Copy = 0LL;
      if ((v68 & 1) == 0 && (*(_BYTE *)(a3 + v44) & 0xF0) == 0x50) {
        break;
      }
      values[0] = 0LL;
      v80 = 0LL;
      if (__CFBinaryPlistCreateObjectFiltered( a3,  a4,  v44,  a6,  (int)&__kCFAllocatorSystemDefault,  0x80000000,  a9,  a11,  a12,  0LL,  0LL,  (uint64_t)values,  (uint64_t)&v80))
      {
        if ((unint64_t)(v80 - 17) >= 3 && v80 != 0)
        {
          if (values[0]) {
            CFRelease(values[0]);
          }
          v49 = 0;
LABEL_87:
          char v51 = Copy;
          if (Copy) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }
      }

      char v51 = 0LL;
      v49 = 1;
LABEL_88:
      if (v49) {
        goto LABEL_119;
      }
LABEL_89:
      if (v51)
      {
        v52 = (unsigned int *)((char *)v23 + v65);
        v53 = a3 + *(void *)(a6 + 24);
        uint64_t v54 = *(unsigned __int8 *)(a6 + 7);
        v55 = *(unsigned __int8 *)(a6 + 7);
        switch(*(_BYTE *)(a6 + 7))
        {
          case 0:
            break;
          case 1:
            v55 = *(unsigned __int8 *)v52;
            break;
          case 2:
            v55 = __rev16(*(unsigned __int16 *)v52);
            break;
          case 4:
            v55 = bswap32(*v52);
            break;
          case 8:
            v55 = bswap64(*(void *)v52);
            break;
          default:
            v55 = 0LL;
            do
            {
              uint64_t v56 = *(unsigned __int8 *)v52;
              v52 = (unsigned int *)((char *)v52 + 1);
              v55 = v56 | (v55 << 8);
              --v54;
            }

            while (v54);
            break;
        }

        if (*(void *)(a6 + 8) <= v55) {
          goto LABEL_120;
        }
        v57 = *(unsigned __int8 *)(a6 + 6);
        uint64_t v58 = (unsigned int *)(v53 + v55 * v57);
        switch(*(_BYTE *)(a6 + 6))
        {
          case 0:
            break;
          case 1:
            LODWORD(v57) = *(unsigned __int8 *)v58;
            break;
          case 2:
            LODWORD(v57) = __rev16(*(unsigned __int16 *)v58);
            break;
          case 4:
            LODWORD(v57) = bswap32(*v58);
            break;
          case 8:
            LODWORD(v57) = bswap64(*(void *)v58);
            break;
          default:
            uint64_t v59 = *(unsigned __int8 *)(a6 + 6);
            LODWORD(v57) = 0;
            do
            {
              size_t v60 = *(unsigned __int8 *)v58;
              uint64_t v58 = (unsigned int *)((char *)v58 + 1);
              LODWORD(v57) = v60 | ((_DWORD)v57 << 8);
              --v59;
            }

            while (v59);
            break;
        }

        values[0] = 0LL;
        if (!__CFBinaryPlistCreateObjectFiltered( a3,  a4,  v57,  a6,  (int)a1,  a8,  a9,  a11,  a12,  a13 + 1,  (uint64_t)cf,  v64,  0LL))
        {
LABEL_120:
          CFRelease(v51);
          CFRelease(Mutable);
          goto LABEL_121;
        }

        v61 = v75[3];
        uint64_t v62 = v61 < 1;
        v63 = v61 - 1;
        if (!v62) {
          v75[3] = v63;
        }
        if (values[0])
        {
          CFDictionarySetValue(Mutable, v51, values[0]);
          CFRelease(values[0]);
        }

        CFRelease(v51);
      }

      uint64_t v23 = (unsigned int *)((char *)v23 + *(unsigned __int8 *)(a6 + 7));
      if (++v72 == v69) {
        goto LABEL_122;
      }
    }

    Copy = 0LL;
    values[0] = (void *)MEMORY[0x1895F87A8];
    values[1] = (void *)3221225472LL;
    values[2] = ____CFPropertyListTryFilteredDictionaryASCIIFastPath_block_invoke;
    values[3] = &__block_descriptor_64_e12_B24__0r_8q16l;
    values[4] = (void *)v67;
    values[5] = v66;
    values[6] = &Copy;
    values[7] = a1;
    v49 = __CFBinaryPlistParseASCIIString(a3, v39 - 1, (_BYTE *)(a3 + v44), (uint64_t)values) ^ 1;
    goto LABEL_87;
  }

  if (a6)
  {
    a1[5] = (unint64_t)a4;
    a1[2] = a5;
    goto LABEL_42;
  }

  uint64_t v20 = 0;
  if ((a2 & 2) == 0 && (a2 & 1) != 0) {
    uint64_t v20 = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
  }
  uint64_t v21 = __CFDataAllocate((uint64_t)a1, a1[3], v20);
  a1[5] = (unint64_t)v21;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
    uint64_t v21 = (void *)a1[5];
  }

  if (v21)
  {
    uint64_t v22 = atomic_load(v10);
    uint64_t v23 = 64LL;
    if (v20) {
      uint64_t v23 = 0LL;
    }
    while (1)
    {
      int64_t v24 = __ldaxr(v10);
      if (v24 != v22) {
        break;
      }
      if (__stlxr(v22 & 0xFFFFFFFFFFFFFFBFLL | v23, v10)) {
        goto LABEL_39;
      }
      uint64_t v25 = 1;
LABEL_40:
      uint64_t v22 = v24;
      if (v25)
      {
        v29.CFIndex location = 0LL;
        v29.CFIndex length = 0LL;
        CFDataReplaceBytes((CFMutableDataRef)a1, v29, a4, a5);
LABEL_42:
        unint64_t v26 = atomic_load(v10);
        while (2)
        {
          uint64_t v27 = __ldaxr(v10);
          if (v27 == v26)
          {
            if (!__stlxr(v26 & 0xFFFFFFFFFFFFFFFCLL | v8 & 3, v10))
            {
              uint64_t v28 = 1;
              goto LABEL_48;
            }
          }

          else
          {
            __clrex();
          }

          uint64_t v28 = 0;
LABEL_48:
          unint64_t v26 = v27;
          if (v28) {
            return;
          }
          continue;
        }
      }
    }

    __clrex();
LABEL_39:
    uint64_t v25 = 0;
    goto LABEL_40;
  }

  else {
    unsigned int v12 = *((void *)theData + 2);
  }
  BytePtr = CFDataGetBytePtr(theData);
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, v12, BytePtr, v12, 0LL);
}

        uint64_t v27 = (unint64_t *)(Instance + 8);
        uint64_t v28 = atomic_load((unint64_t *)(Instance + 8));
        while (2)
        {
          uint64_t v29 = __ldaxr(v27);
          if (v29 == v28)
          {
            if (!__stlxr(v28 & 0xFFFFFFFFFFFFFFF7LL, v27))
            {
              uint64_t v30 = 1;
              goto LABEL_31;
            }
          }

          else
          {
            __clrex();
          }

          uint64_t v30 = 0;
LABEL_31:
          uint64_t v28 = v29;
          if (v30)
          {
            else {
              uint64_t v31 = 2LL;
            }
            CFXNotificationRegistrarCreate( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  v31,  v11,  v12,  v13,  v14,  v15,  v16);
            *(void *)(v17 + 16) = v32;
            if (*a2 == 1)
            {
              BOOL v33 = _CFProcessPath();
              if (v33)
              {
                if (!strcmp("/usr/sbin/distnoted", v33)) {
                  __CFIsDistNoteDaemon = 1;
                }
              }
            }

            *(void *)(v17 + 24) = 0LL;
            if (*a2 == 1 && (__CFIsDistNoteDaemon & 1) == 0)
            {
              uint64_t v34 = (_xpc_endpoint_s *)*((void *)a2 + 4);
              v35 = (const char *)*((void *)a2 + 2);
              uint64_t v36 = *((unsigned __int8 *)a2 + 9);
              v37 = qos_class_main();
              BOOL v38 = dispatch_queue_attr_make_with_qos_class(0LL, v37, 0);
              BOOL v39 = dispatch_queue_create("com.apple.notification_center.server_conn", v38);
              if (v34)
              {
                uint64_t v40 = xpc_connection_create_from_endpoint(v34);
                *(void *)(v17 + 24) = v40;
                xpc_connection_set_target_queue(v40, v39);
              }

              else
              {
                *(void *)(v17 + 24) = xpc_connection_create_mach_service(v35, v39, 2LL * (v36 != 0));
              }

              dispatch_release(v39);
              uint64_t v41 = *(_xpc_connection_s **)(v17 + 24);
              v43[0] = MEMORY[0x1895F87A8];
              v43[1] = 3221225472LL;
              v43[2] = ____CFXNotificationCenterSetupConnection_block_invoke;
              v43[3] = &__block_descriptor_40_e33_v16__0__NSObject_OS_xpc_object__8l;
              v43[4] = v17;
              xpc_connection_set_event_handler(v41, v43);
              xpc_connection_activate(*(xpc_connection_t *)(v17 + 24));
            }

            return v17;
          }

          continue;
        }
      }
    }

    __clrex();
LABEL_14:
    uint64_t v22 = 0;
    goto LABEL_15;
  }

  return v17;
}

  LOBYTE(v10) = atomic_load(a1 + 1);
  return __CFNumberCanonicalTypes[v10 & 7];
}

  Length = CFStringGetLength(v4);
  uint64_t v19 = v4;
  uint64_t v22 = 0LL;
  uint64_t v23 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v4);
  CStringPtr = 0LL;
  uint64_t v20 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v4, 0x600u);
  }
  int64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v21 = CStringPtr;
  char v16 = 0;
  if (__CFStringScanDouble(buffer, 0LL, &v16, &valuePtr) && Length == v16)
  {
    uint64_t v5 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 32), kCFNumberDoubleType, &valuePtr);
    if (!v4) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  if (v4) {
    CFRelease(v4);
  }
  int v14 = lineNumber((unint64_t *)a1);
  Error = __CFPropertyListCreateError(3840LL, @"Encountered misformatted real on line %u", v14);
LABEL_34:
  unsigned int v12 = Error;
  uint64_t result = 0LL;
  *(void *)(a1 + 24) = v12;
  return result;
}

        Error = __CFPropertyListCreateError(3840LL, @"Encountered unexpected EOF");
        goto LABEL_26;
      case '?':
        skipXMLProcessingInstruction(a1);
        goto LABEL_23;
      case '/':
        a1[1] = (unint64_t)v9;
        return 0LL;
    }
  }

  return parseXMLElement(a1, a2, a3, a4);
}

  if (!CFArrayGetCount(v3))
  {
    if (_defaultLocalization) {
      int v11 = (const __CFString *)_defaultLocalization;
    }
    else {
      int v11 = @"en";
    }
    CFArrayAppendValue(v3, v11);
  }

  os_unfair_lock_lock_with_options();
  if (*(void *)(a1 + 40))
  {
    CFRelease(v3);
    int v3 = *(__CFArray **)(a1 + 40);
  }

  else
  {
    *(void *)(a1 + 40) = v3;
  }

          if (v18 == -1) {
            uint64_t v18 = v17;
          }
          LOWORD(v19) = v15[v20];
          char v16 = v20;
        }

        v15[v17++] = v19;
        ++v16;
      }

      while (v16 < v11);
      CFIndex v8 = CFStringCreateWithCharacters(a1, v15, v17);
      int v11 = CFStringGetLength(v8);
      free(v15);
    }

    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v8, @":");
    MutableCopy = CFArrayCreateMutableCopy(a1, 0LL, ArrayBySeparatingStrings);
    uint64_t v28 = CFStringGetCharacterAtIndex(v8, 0LL);
    CFRelease(ArrayBySeparatingStrings);
    v78 = v11;
    if (v28 == 58)
    {
      CFArrayRemoveValueAtIndex(MutableCopy, 0LL);
    }

    else
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0LL);
      if (CFStringGetLength(ValueAtIndex) == 1 && CFStringGetCharacterAtIndex(ValueAtIndex, 0LL) == 47) {
        CFArrayRemoveValueAtIndex(MutableCopy, 0LL);
      }
      CFArrayInsertValueAtIndex(MutableCopy, 0LL, &stru_1899EF170);
    }

    v76 = a5;
    Count = CFArrayGetCount(MutableCopy);
    v35 = Count;
    cf = v8;
    if (Count)
    {
      v72 = Count;
      v73 = a4;
      uint64_t v36 = 0LL;
      do
      {
        v37 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v36);
        BOOL v38 = CFStringGetLength(v37);
        v84.CFIndex location = 0LL;
        v84.CFIndex length = v38;
        if (CFStringFindWithOptions(v37, @"/", v84, 0LL, &result))
        {
          BOOL v39 = 0LL;
          uint64_t v40 = 0LL;
          do
          {
            uint64_t v41 = v38 + v39;
            if (!v40) {
              uint64_t v40 = CFStringCreateMutableCopy(a1, v41, v37);
            }
            CFStringReplace(v40, result, @":");
            BOOL v38 = v41 + ~result.location;
            BOOL v39 = result.location + 1;
            v85.CFIndex location = result.location + 1;
            v85.CFIndex length = v38;
          }

          while (CFStringFindWithOptions(v37, @"/", v85, 0LL, &result));
          if (v40)
          {
            CFArraySetValueAtIndex(MutableCopy, v36, v40);
            CFRelease(v40);
          }
        }

        ++v36;
      }

      while (v36 != v35);
      a4 = v73;
      if (v73)
      {
        uint64_t v42 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v72 - 1);
        if (CFStringGetLength(v42)) {
          CFArrayAppendValue(MutableCopy, &stru_1899EF170);
        }
      }
    }

    if (!MutableCopy)
    {
      v52 = 0LL;
      goto LABEL_95;
    }

    uint64_t v43 = a4;
    uint64_t v44 = CFGetAllocator(MutableCopy);
    uint64_t v45 = CFArrayGetCount(MutableCopy);
    uint64_t v46 = v45;
    if (v45 >= 1)
    {
      uint64_t v47 = 0LL;
      uint64_t v48 = 0LL;
      while (1)
      {
        v49 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v48);
        v50 = CFURLCreateStringByAddingPercentEscapes(v44, v49, 0LL, @";?/", 0x8000100u);
        if (!v50) {
          break;
        }
        char v51 = v50;
        if (v50 != v49)
        {
          if (!v47) {
            uint64_t v47 = CFArrayCreateMutableCopy(v44, v46, MutableCopy);
          }
          CFArraySetValueAtIndex(v47, v48, v51);
        }

        CFRelease(v51);
        if (v46 == ++v48) {
          goto LABEL_83;
        }
      }

      if (v46 == v48)
      {
LABEL_83:
        v55 = v47;
        if (v47) {
          goto LABEL_85;
        }
        goto LABEL_84;
      }

      uint64_t v58 = 0LL;
      v52 = 0LL;
      a5 = v76;
      unsigned int v12 = CharacterAtIndex != 58;
      if (!v47) {
        goto LABEL_94;
      }
      goto LABEL_93;
    }

    if (v45)
    {
      v52 = 0LL;
      a5 = v76;
      unsigned int v12 = CharacterAtIndex != 58;
    }

    else
    {
LABEL_84:
      CFRetain(MutableCopy);
      v55 = MutableCopy;
LABEL_85:
      CFRelease(MutableCopy);
      unsigned int v12 = CharacterAtIndex != 58;
      if (CFArrayGetCount(v55) == 1
        && (uint64_t v56 = (const __CFString *)CFArrayGetValueAtIndex(v55, 0LL), !CFStringGetLength(v56)))
      {
        v57 = (__CFArray *)CFRetain(@"/");
      }

      else
      {
        v57 = (__CFArray *)CFStringCreateByCombiningStrings(a1, v55, @"/");
      }

      uint64_t v47 = v57;
      a5 = v76;
      if (CharacterAtIndex != 58 && v57)
      {
        uint64_t v58 = CFStringCreateWithFormat(a1, 0LL, @"file://%@", v57);
        MutableCopy = v55;
LABEL_93:
        CFRelease(v47);
        v52 = v58;
        goto LABEL_94;
      }

      MutableCopy = v55;
      v52 = (const __CFString *)v57;
    }

  if (a3)
  {
    uint64_t v25 = CFArrayGetCount(v10);
    unint64_t v26 = (const __CFString *)CFArrayGetValueAtIndex(v10, v25 - 1);
    if (CFStringGetLength(v26)) {
      CFArrayAppendValue(v10, &stru_1899EF170);
    }
  }

  if (a4) {
    CFArrayInsertValueAtIndex(v10, 0LL, @"file://");
  }
  if (!v10) {
    return CFStringCreateWithCString(a2, "", 0x600u);
  }
  uint64_t v27 = CFStringCreateByCombiningStrings(a2, v10, @"/");
  CFRelease(v10);
  return v27;
}

    __break(1u);
    return result;
  }

  if (v3 == 3)
  {
    ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v4);
    return *((void *)&v5 + 1);
  }

  if (v3 == 2)
  {
    ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v4);
    return *((void *)&v5 + 1);
  }

  if (v3 != 1) {
    goto LABEL_25;
  }
  ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v4);
  return *((void *)&v5 + 1);
}

  uint64_t v30 = openat(v27, __s1, 0);
  unint64_t v17 = 0;
  if (v30 != -1 || !v10) {
    goto LABEL_39;
  }
  if (*__error() != 2) {
    goto LABEL_32;
  }
  if ((*(_BYTE *)(v11 + 142) & 0x10) != 0)
  {
    uint64_t v31 = 384LL;
  }

  else if (CFEqual(*(CFTypeRef *)(v11 + 40), @"kCFPreferencesAnyUser"))
  {
    uint64_t v31 = 420LL;
  }

  else
  {
    uint64_t v31 = 384LL;
  }

  uint64_t v30 = openat(v57, __s1, 512, v31);
  unint64_t v17 = 1;
LABEL_39:
  if (v30 < 0) {
    uint64_t v34 = v10;
  }
  else {
    uint64_t v34 = 0;
  }
  if (v34 != 1) {
    goto LABEL_65;
  }
  if (*__error() != 2 && *__error() != 20) {
    goto LABEL_69;
  }
  if (v65 == 0x7972617262694C2FLL
    && v66[0] == 0x657265666572502FLL
    && *(void *)((char *)v66 + 5) == 0x7365636E657265LL)
  {
    if ((*(_BYTE *)(v11 + 142) & 0x10) != 0)
    {
      uint64_t v41 = 384LL;
    }

    else if (CFEqual(*(CFTypeRef *)(v11 + 40), @"kCFPreferencesAnyUser"))
    {
      uint64_t v41 = 420LL;
    }

    else
    {
      uint64_t v41 = 384LL;
    }

    uint64_t v30 = openat(v57, __s1, 512, v41);
    unint64_t v17 = 1;
LABEL_65:
    if ((v30 & 0x80000000) == 0)
    {
      bzero(buf, 0x402uLL);
      if (fcntl(v30, 50, buf) == -1)
      {
        if ((v57 & 0x80000000) == 0) {
          close(v57);
        }
        close(v30);
        uint64_t v47 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
          -[CFPDSource cacheFileInfoForWriting:euid:egid:didCreate:].cold.2((uint64_t)__s2, v47);
        }
      }

      else
      {
        *(_DWORD *)(v11 + 128) = v57;
        *(void *)(v11 + 64) = strdup(__s1);
        *(void *)(v11 + 56) = strdup((const char *)buf);
        else {
          close(v30);
        }
        if (!strcmp((const char *)buf, __s2))
        {
          char v51 = *(_BYTE *)(v11 + 143) & 0xFD;
        }

        else
        {
          uint64_t v48 = lstat(__s2, &out_token);
          if ((out_token.st_mode & 0xF000) == 0xA000 && v48 == 0) {
            v50 = 2;
          }
          else {
            v50 = 0;
          }
          char v51 = v50 | *(_BYTE *)(v11 + 143) & 0xFD;
        }

        *(_BYTE *)(v11 + 143) = v51;
        if (((v34 | v10 ^ 1) & 1) != 0 || !sandbox_passthrough_access())
        {
          char v16 = 0;
          if (!v17) {
            return v16;
          }
          goto LABEL_102;
        }

        v52 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
          -[CFPDSource cacheFileInfoForWriting:euid:egid:didCreate:].cold.3();
        }
      }

      char v16 = 7;
      if (!v17) {
        return v16;
      }
LABEL_102:
      *CFIndex v8 = 1;
      return v16;
    }

LABEL_92:
  if (a5 >= 1)
  {
    v57 = *(void **)(a1 + 40);
    if (!v57) {
      _CFArrayReplaceValues_cold_1();
    }
    memmove(&v57[*v57 + 2 + a2], v19, 8 * a5);
  }

  *(void *)(a1 + 16) = v66;
  if (v19 != v67 && v19 != (_BYTE *)__src) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v19);
  }
}

      if (v70)
      {
        uint64_t result = _CheckForTag((uint64_t)(v70 + 1), v40 + 1);
        if ((_DWORD)result)
        {
          uint64_t v54 = *v42;
          if (*v42)
          {
            v55 = (unsigned __int8 *)(v42 + 1);
            uint64_t v56 = v70 + 1;
            do
            {
              *v56++ = v54;
              v57 = *v55++;
              uint64_t v54 = v57;
            }

            while (v57);
          }
        }
      }

      goto LABEL_107;
    }

    if ((*(_DWORD *)(v24 + 4LL * v43 + 60) & 0x8000) != 0) {
      goto LABEL_72;
    }
LABEL_77:
    if (v70)
    {
      uint64_t result = _CheckForTag((uint64_t)(v70 + 1), v40 + 1);
      if ((_DWORD)result) {
        goto LABEL_99;
      }
    }

    uint64_t v46 = strstr(a1, v40);
    if (v46)
    {
      uint64_t v47 = v46[3];
      if ((v47 & 0x80000000) != 0)
      {
        uint64_t result = __maskrune(v47, 0x500uLL);
        if ((_DWORD)result) {
          goto LABEL_82;
        }
      }

      else
      {
        uint64_t result = *(_DWORD *)(v24 + 4LL * v47 + 60) & 0x500;
        if ((_DWORD)result) {
          goto LABEL_82;
        }
      }

      if (v67 == v68)
      {
        uint64_t v54 = v61;
        v57 = v60;
        uint64_t v22 = v59;
LABEL_310:
        CFIndex length = v315;
        char v13 = v294;
LABEL_311:
        if (v51 == v53 && v53 > 0) {
          v53 = 0LL;
        }
        if (v52 == v54 && v54 > 0) {
          uint64_t v54 = 0LL;
        }
        v163 = v329;
        if (v53) {
          v163 = 0LL;
        }
        v22 += v163;
        v164 = v328;
        if (v54) {
          v164 = 0LL;
        }
        v57 += v164;
        if (!(v53 | v54))
        {
          uint64_t v58 = v57;
          uint64_t v47 = v22;
        }

        if (v22 >= length || v57 >= v13)
        {
LABEL_407:
          v201 = cf;
          uint64_t v59 = v22;
          size_t v60 = v57;
          if ((v49 | v313) == 1)
          {
LABEL_438:
            v212 = v48;
            v213 = v50;
            while (v59 < length)
            {
              if (v59 < 0 || (v214 = v343, v343 <= v59))
              {
                v217 = 0;
              }

              else
              {
                v215 = (UniChar *)v340;
                if (v340)
                {
                  v216 = v342 + v59;
LABEL_443:
                  v217 = v215[v216];
                  goto LABEL_445;
                }

                if (!v341)
                {
                  if (v345 <= v59 || (v233 = v344, v344 > v59))
                  {
                    v234 = v59 - 4;
                    if (v234 + 64 < v343) {
                      v214 = v234 + 64;
                    }
                    v344 = v234;
                    v345 = v214;
                    v355.CFIndex location = v342 + v234;
                    v355.CFIndex length = v214 - v234;
                    CFStringGetCharacters(v339, v355, v338);
                    v50 = v213;
                    v49 = v317;
                    uint64_t v48 = v212;
                    v233 = v344;
                  }

                  v216 = v59 - v233;
                  v215 = v338;
                  goto LABEL_443;
                }

                v217 = *(char *)(v341 + v342 + v59);
              }

  if (v58.location == -1 || !v17)
  {
    CFRelease(MutableCopy);
    goto LABEL_96;
  }

  v85.CFIndex length = CFStringGetLength(MutableCopy) - (v58.location + v58.length);
  v85.CFIndex location = v58.location + v58.length;
  int v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v85);
  uint64_t v41 = MutableCopy;
  a5 = v55;
LABEL_41:
  CFRelease(v41);
  if (v15)
  {
LABEL_42:
    if (CFStringHasSuffix(v15, @".plist"))
    {
      v84.CFIndex length = CFStringGetLength(v15) - 6;
      v84.CFIndex location = 0LL;
      uint64_t v45 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v84);
      CFRelease(v15);
      int v15 = v45;
    }

    *a2 = v15;
    uint64_t v46 = @"kCFPreferencesNoContainer";
    if (v16) {
      uint64_t v46 = v16;
    }
    *a4 = v46;
    bzero(&result, 0x400uLL);
    if (!_CFPrefsGetImpersonatedApplicationAuditToken(&v68))
    {
      if (_CFAuditTokenForSelf_onceToken != -1) {
        dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
      }
      uint64_t v68 = _CFAuditTokenForSelf_auditToken;
      v69 = unk_18C45C968;
    }

    *(_OWORD *)buffer = v68;
    v67 = v69;
    uint64_t v47 = sandbox_container_path_for_audit_token();
    uint64_t v48 = CFEqual(*a4, @"kCFPreferencesNoContainer");
    if (v47)
    {
      if (v48)
      {
        *a4 = 0LL;
LABEL_63:
        if (CFEqual(v17, @"wireless"))
        {
          CFRelease(v17);
          unint64_t v17 = @"_wireless";
        }

        if (CFEqual(v17, @"kCFPreferencesCurrentUser"))
        {
          Copy = @"kCFPreferencesCurrentUser";
        }

        else
        {
          Copy = @"kCFPreferencesAnyUser";
          if (!CFEqual(v17, @"kCFPreferencesAnyUser"))
          {
            v53 = CFCopyUserName();
            uint64_t v54 = CFEqual(v17, v53);
            CFRelease(v53);
            if (!@"kCFPreferencesCurrentUser" || (Copy = @"kCFPreferencesCurrentUser", !v54)) {
              Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
            }
          }
        }

        CFRelease(v17);
        *uint64_t v65 = Copy;
        if (CFEqual(Copy, @"kCFPreferencesAnyUser")) {
          *a5 = 1;
        }
        return;
      }
    }

    else if (v48)
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString(*a2, buffer, 1024LL, 0x8000100u)
        && (!sandbox_check_by_audit_token() || !sandbox_check_by_audit_token()))
      {
        *a4 = 0LL;
      }
    }

    else
    {
      SystemEncoding = CFStringGetSystemEncoding();
      v50 = CFStringCreateWithCStringNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const char *)&result,  SystemEncoding,  (CFAllocatorRef)&__kCFAllocatorNull);
      if (CFEqual(*a4, v50))
      {
        CFRelease(*a4);
        *a4 = 0LL;
      }

      CFRelease(v50);
    }

    if (*a4)
    {
      char v51 = _CFPrefsCopyUserForContainer(v17, (CFStringRef)*a4);
      CFRelease(v17);
      unint64_t v17 = v51;
    }

    goto LABEL_63;
  }

      v12 += 2LL;
      if (!a5) {
        goto LABEL_160;
      }
      if (v12 <= a5)
      {
        HIDWORD(v37) = v21;
        LODWORD(v37) = v21;
        *(_DWORD *)a4 = v37 >> 16;
        a4 += 2;
        goto LABEL_160;
      }

      return v13;
    }

    if (a2[1] <= 0xCAu)
    {
      if (v20 == 195)
      {
        if ((a1 & 0x200) == 0)
        {
          uint64_t v21 = 540997756;
          goto LABEL_92;
        }

        uint64_t v22 = 8254;
        goto LABEL_157;
      }

      if (v20 == 197)
      {
        if ((a1 & 0x200) == 0)
        {
          uint64_t v21 = -12584836;
          goto LABEL_92;
        }

          uint64_t v7 = v12 + 2;
          if (a5 && v7 > a5) {
            goto LABEL_238;
          }
          if (v14 == 63586)
          {
            if (v13 + 5 > a3) {
              goto LABEL_238;
            }
            v52 = 34219;
            v53 = (unsigned __int16 *)&__CFF862SeqTable;
LABEL_129:
            uint64_t v54 = 1LL;
            do
            {
              if (v11[v54] != v53[v54])
              {
                v55 = v53[5];
                v53 += 5;
                v52 = v55;
                if (v55) {
                  goto LABEL_129;
                }
                goto LABEL_238;
              }

              ++v54;
            }

            while ((_DWORD)(v54 * 2) != 10);
            if (!v52) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v52);
              a4[1] = v52;
              a4 += 2;
            }

            v11 += 4;
            v13 += 4LL;
          }

          else if (v14 == 63585)
          {
            if (v13 + 4 > a3) {
              goto LABEL_238;
            }
            uint64_t v56 = 34220;
            v57 = (unsigned __int16 *)&__CFF861SeqTable;
LABEL_137:
            uint64_t v58 = 1LL;
            do
            {
              if (v11[v58] != v57[v58])
              {
                uint64_t v59 = v57[5];
                v57 += 5;
                uint64_t v56 = v59;
                if (v59) {
                  goto LABEL_137;
                }
                goto LABEL_238;
              }

              ++v58;
            }

            while ((_DWORD)(v58 * 2) != 8);
            if (!v56) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v56);
              a4[1] = v56;
              a4 += 2;
            }

            v11 += 3;
            v13 += 3LL;
          }

          else
          {
            if (v14 != 63584 || v13 + 3 > a3) {
              goto LABEL_238;
            }
            uint64_t v46 = 34193;
            uint64_t v47 = (unsigned __int16 *)&__CFF860SeqTable;
LABEL_99:
            uint64_t v48 = 1LL;
            do
            {
              if (v11[v48] != v47[v48])
              {
                v49 = v47[5];
                v47 += 5;
                uint64_t v46 = v49;
                if (v49) {
                  goto LABEL_99;
                }
                goto LABEL_238;
              }

              ++v48;
            }

            while ((_DWORD)(v48 * 2) != 6);
            if (!v46) {
              goto LABEL_238;
            }
            if (a5)
            {
              *a4 = BYTE1(v46);
              a4[1] = v46;
              a4 += 2;
            }

            v11 += 2;
            v13 += 2LL;
          }

          goto LABEL_232;
        }

  v50 = __CFFromMacJapanese(0LL, (unsigned __int8 *)a2, a3, 0LL, 0LL, a6);
  char v51 = v50;
  if (v9 > v50)
  {
    *a6 = 0LL;
    if (v9 >= 1)
    {
      uint64_t v58 = v11;
      v52 = 0;
      v53 = 1LL;
      uint64_t v54 = v10;
      v55 = v9;
      do
      {
        v50 = __CFFromDOSJapanese(v50, v54, v55, (__int16 *)&v59);
        if (!(_DWORD)v50) {
          break;
        }
        *a6 = v53;
        v52 += v50;
        v54 += v50;
        v55 -= v50;
        ++v53;
      }

      while (v55 > 0);
      int v11 = v58;
      if (v52 > v51)
      {
        *a6 = 0LL;
        uint64_t v30 = 0LL;
        uint64_t v56 = 1LL;
        while (1)
        {
          if (a5)
          {
            if (v56 - 1 >= a5) {
              return v30;
            }
            v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!(_DWORD)v50) {
              return v30;
            }
            v57 = v50;
            *v8++ = v59;
          }

          else
          {
            v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!(_DWORD)v50) {
              return v30;
            }
            v57 = v50;
          }

          *a6 = v56;
          v30 += v57;
          v10 += v57;
          ++v56;
          int v14 = v9 <= v57;
          v9 -= v57;
          if (v14) {
            return v30;
          }
        }
      }
    }
  }

  return __CFFromMacJapanese(v11, v10, v9, v8, a5, a6);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  v26[1] = *MEMORY[0x1895F89C0];
  v26[0] = value;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray setObject:atIndex:](theArray, "setObject:atIndex:", value, idx);
    return;
  }

  if (*((void *)theArray + 2) == idx)
  {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0LL, v26, 1LL);
    return;
  }

  unsigned int v6 = atomic_load((unint64_t *)theArray + 1);
  int v7 = (v6 >> 2) & 3;
  if (v7)
  {
    if (v7 == 1)
    {
      CFIndex v8 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v9 = atomic_load((unint64_t *)theArray + 1);
      int v10 = v9 & 3;
      if (v10 == 2)
      {
        CFIndex v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
      }

      else
      {
        if (v10) {
          CFIndex v8 = 0LL;
        }
        else {
          CFIndex v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
        }
      }
    }
  }

  else
  {
    CFIndex v8 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
    if (((unint64_t)theArray & 0x8000000000000000LL) == 0)
    {
LABEL_18:
      char v12 = atomic_load((unint64_t *)theArray + 1);
      if (v12 < 0) {
        int v11 = &kCFAllocatorSystemDefault;
      }
      else {
        int v11 = (const CFAllocatorRef *)((char *)theArray - 16);
      }
      goto LABEL_21;
    }
  }

  int v11 = &kCFAllocatorSystemDefault;
LABEL_21:
  CFAllocatorRef v13 = *v11;
  char v14 = atomic_load((unint64_t *)theArray + 1);
  if ((v14 & 1 | 2) == 2)
  {
    char v15 = atomic_load((unint64_t *)theArray + 1);
    int v16 = v15 & 3;
    if (v16 == 2)
    {
      uint64_t v20 = (char *)(*((void *)theArray + 5) + 8LL * **((void **)theArray + 5) + 16);
    }

    else if (v16)
    {
      uint64_t v20 = 0LL;
    }

    else
    {
      char v17 = atomic_load((unint64_t *)theArray + 1);
      BOOL v18 = (~v17 & 0xC) == 0LL;
      uint64_t v19 = 48LL;
      if (v18) {
        uint64_t v19 = 88LL;
      }
      uint64_t v20 = (char *)theArray + v19;
    }

    uint64_t v21 = (uint64_t *)&v20[8 * idx];
  }

  else
  {
    uint64_t v21 = 0LL;
  }

  retain = (uint64_t (*)(void, void))v8->retain;
  uint64_t v23 = v26[0];
  if (retain) {
    uint64_t v23 = retain(v13, v26[0]);
  }
  uint64_t v24 = *v21;
  *uint64_t v21 = v23;
  release = (void (*)(CFAllocatorRef, uint64_t))v8->release;
  if (release) {
    release(v13, v24);
  }
  ++*((void *)theArray + 3);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  v6[1] = *MEMORY[0x1895F89C0];
  v6[0] = value;
  else {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0LL, v6, 1LL);
  }
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray exchangeObjectAtIndex:withObjectAtIndex:]( theArray,  "exchangeObjectAtIndex:withObjectAtIndex:",  idx1,  idx2);
  }

  else
  {
    unsigned int v6 = (unint64_t *)((char *)theArray + 8);
    char v7 = atomic_load((unint64_t *)theArray + 1);
    if ((v7 & 1 | 2) == 2)
    {
      char v8 = atomic_load(v6);
      int v9 = v8 & 3;
      if (v9 == 2)
      {
        CFAllocatorRef v13 = (char *)(*((void *)theArray + 5) + 8LL * **((void **)theArray + 5) + 16);
      }

      else if (v9)
      {
        CFAllocatorRef v13 = 0LL;
      }

      else
      {
        char v10 = atomic_load((unint64_t *)theArray + 1);
        BOOL v11 = (~v10 & 0xC) == 0LL;
        uint64_t v12 = 48LL;
        if (v11) {
          uint64_t v12 = 88LL;
        }
        CFAllocatorRef v13 = (char *)theArray + v12;
      }

      char v14 = &v13[8 * idx1];
    }

    else
    {
      char v14 = 0LL;
    }

    atomic_load(v6);
    char v15 = atomic_load(v6);
    if ((v15 & 3) != 0)
    {
      int v16 = (char *)(*((void *)theArray + 5) + 8LL * **((void **)theArray + 5) + 16);
    }

    else
    {
      char v17 = atomic_load((unint64_t *)theArray + 1);
      BOOL v11 = (~v17 & 0xC) == 0LL;
      uint64_t v18 = 48LL;
      if (v11) {
        uint64_t v18 = 88LL;
      }
      int v16 = (char *)theArray + v18;
    }

    uint64_t v19 = *(void *)v14;
    *(void *)char v14 = *(void *)&v16[8 * idx2];
    *(void *)&v16[8 * idx2] = v19;
    ++*((void *)theArray + 3);
  }

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  else {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 1LL, 0LL, 0LL);
  }
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray removeAllObjects](theArray, "removeAllObjects");
  }

  else
  {
    __CFArrayReleaseValues((unint64_t)theArray, 0LL, *((void *)theArray + 2), 1);
    uint64_t v2 = *((void *)theArray + 3) + 1LL;
    *((void *)theArray + 2) = 0LL;
    *((void *)theArray + 3) = v2;
  }

void __CFArrayReleaseValues(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = (v8 >> 2) & 3;
  if (v9)
  {
    if (v9 == 1)
    {
      char v10 = &kCFTypeArrayCallBacks;
    }

    else
    {
      char v11 = atomic_load((unint64_t *)(a1 + 8));
      int v12 = v11 & 3;
      if (v12) {
        CFAllocatorRef v13 = 0LL;
      }
      else {
        CFAllocatorRef v13 = (const CFArrayCallBacks *)(a1 + 48);
      }
      if (v12 == 2) {
        char v10 = (const CFArrayCallBacks *)(a1 + 48);
      }
      else {
        char v10 = v13;
      }
    }
  }

  else
  {
    char v10 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

  char v14 = atomic_load((unint64_t *)(a1 + 8));
  int v15 = v14 & 3;
  if (v15 == 2)
  {
    uint64_t v23 = *(void **)(a1 + 40);
    if (a3 >= 1 && v23)
    {
      char v24 = atomic_load((unint64_t *)(a1 + 8));
      int v25 = v24 & 3;
      if (v25 == 2)
      {
        uint64_t v28 = *(void *)(a1 + 40) + 8LL * **(void **)(a1 + 40) + 16;
      }

      else if (v25)
      {
        uint64_t v28 = 0LL;
      }

      else
      {
        char v26 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v20 = (~v26 & 0xC) == 0LL;
        uint64_t v27 = 48LL;
        if (v20) {
          uint64_t v27 = 88LL;
        }
        uint64_t v28 = a1 + v27;
      }

      if (v10->release)
      {
        if ((a1 & 0x8000000000000000LL) != 0)
        {
          v35 = &kCFAllocatorSystemDefault;
        }

        else
        {
          char v36 = atomic_load((unint64_t *)(a1 + 8));
          if (v36 < 0) {
            v35 = &kCFAllocatorSystemDefault;
          }
          else {
            v35 = (const CFAllocatorRef *)(a1 - 16);
          }
        }

        CFAllocatorRef v37 = *v35;
        BOOL v38 = (uint64_t *)(v28 + 8 * a2);
        uint64_t v39 = a3;
        do
        {
          uint64_t v40 = *v38++;
          ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v37, v40);
          --v39;
        }

        while (v39);
      }

      bzero((void *)(v28 + 8 * a2), 8 * a3);
    }

    if (a4 && !a2 && *(void *)(a1 + 16) == a3)
    {
      if ((a1 & 0x8000000000000000LL) != 0)
      {
        uint64_t v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }

      else
      {
        char v42 = atomic_load((unint64_t *)(a1 + 8));
        if (v42 < 0) {
          uint64_t v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v41 = (CFAllocatorRef *)(a1 - 16);
        }
      }

      if (v23) {
        CFAllocatorDeallocate(*v41, v23);
      }
      *(void *)(a1 + 16) = 0LL;
      *(void *)(a1 + 40) = 0LL;
    }
  }

  else if (!v15 && v10->release && a3 >= 1)
  {
    char v17 = atomic_load((unint64_t *)(a1 + 8));
    int v18 = v17 & 3;
    if (v18 == 2)
    {
      uint64_t v22 = *(void *)(a1 + 40) + 8LL * **(void **)(a1 + 40) + 16;
      if ((a1 & 0x8000000000000000LL) == 0) {
        goto LABEL_31;
      }
    }

    else
    {
      if (!v18)
      {
        char v19 = atomic_load((unint64_t *)(a1 + 8));
        BOOL v20 = (~v19 & 0xC) == 0LL;
        uint64_t v21 = 48LL;
        if (v20) {
          uint64_t v21 = 88LL;
        }
        uint64_t v22 = a1 + v21;
        if ((a1 & 0x8000000000000000LL) != 0) {
          goto LABEL_35;
        }
LABEL_31:
        char v29 = atomic_load((unint64_t *)(a1 + 8));
        if (v29 < 0) {
          uint64_t v30 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v30 = (const CFAllocatorRef *)(a1 - 16);
        }
        goto LABEL_36;
      }

      uint64_t v22 = 0LL;
      if ((a1 & 0x8000000000000000LL) == 0) {
        goto LABEL_31;
      }
    }

LABEL_35:
    uint64_t v30 = &kCFAllocatorSystemDefault;
LABEL_36:
    CFAllocatorRef v31 = *v30;
    uint64_t v32 = (uint64_t *)(v22 + 8 * a2);
    uint64_t v33 = a3;
    do
    {
      uint64_t v34 = *v32++;
      ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v31, v34);
      --v33;
    }

    while (v33);
    bzero((void *)(v22 + 8 * a2), 8 * a3);
  }

  v35 = 0LL;
LABEL_45:
  char v36 = *(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t))(a4 + 96);
  if (v36) {
    CFAllocatorRef v37 = (const __CFData *)v36(a4, v26, v35, v11);
  }
  else {
    CFAllocatorRef v37 = (const __CFData *)(*(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t, unint64_t, void))(a4 + 104))( a4,  v26,  v35,  v11,  ((unint64_t)a1 + a1[1] + 3) & 0xFFFFFFFFFFFFFFFCLL,  0LL);
  }
  BOOL v38 = v37;
  if (v37)
  {
    Length = CFDataGetLength(v37);
    if (Length < 1610612737)
    {
      uint64_t v46 = Length;
      if (Length > 3999)
      {
        address[0] = 0LL;
        if (vm_allocate(*MEMORY[0x1895FBBE0], address, Length, 335544321))
        {
          LODWORD(v46) = 0;
        }

        else
        {
          uint64_t v47 = (void *)address[0];
          BytePtr = CFDataGetBytePtr(v38);
          memmove(v47, BytePtr, v46);
        }
      }

      else
      {
        address[0] = (vm_address_t)CFDataGetBytePtr(v38);
      }
    }

    else
    {
      CFLog( 4LL,  (uint64_t)@"*** CFMessagePort reply: CFMessagePort cannot send more than %lu bytes of data",  v40,  v41,  v42,  v43,  v44,  v45,  1610612736LL);
      CFRelease(v38);
      LODWORD(v46) = 0;
      BOOL v38 = 0LL;
    }
  }

  else
  {
    LODWORD(v46) = -1;
  }

  if (*a1 < 0 || a1[5] != 1128680784) {
    v49 = 11LL;
  }
  else {
    v49 = 10LL;
  }
  Message = __CFMessagePortCreateMessage(1, a1[2], 0, -a1[v49 + 2], v26, (const void *)address[0], v46);
  char v51 = Message;
  if ((*(_DWORD *)Message & 0x80000000) != 0) {
    Message[36] = 1;
  }
  if (v35) {
    CFRelease(v35);
  }
  if (*a1 < 0) {
    mach_vm_deallocate(*MEMORY[0x1895FBBE0], *(void *)(a1 + 7), a1[10]);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v12) {
    v12(v11);
  }
  return v51;
}

  uint64_t v21 = *(const void **)(v30[0] + 24LL);
  if (v21)
  {
    if (!pw_dir)
    {
      uint64_t v22 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        _CFCopyHomeDirURLForUser_cold_1((uint64_t)v30, v22);
      }
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)"/var/empty",  10LL,  1u);
      uint64_t v21 = *(const void **)(v30[0] + 24LL);
    }

    CFRelease(v21);
  }

  _Block_object_dispose(&v29, 8);
  return pw_dir;
}

                CFStringAppendCharacters(v6, p_chars, 1LL);
LABEL_18:
                CFAllocatorRef v31 = CFRetain(v6);
                CFRelease(v6);
                if (v31) {
                  return v31;
                }
                return CFRetain(theString);
              }

              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.CFIndex location = Length - 2;
                char v24 = @"";
                goto LABEL_45;
              }
            }

  if (Copy) {
    CFRelease(Copy);
  }
}

  if (Copy) {
    CFRelease(Copy);
  }
}

          v13 += v19;
          a2 += v19;
          uint64_t v30 = (uint64_t)v9 <= v19;
          v9 -= v19;
          if (v30) {
            return v13;
          }
          goto LABEL_3;
        }

        uint64_t v23 = v25 + 65;
      }

      else
      {
        uint64_t v22 = v25 - 65;
      }

      if (v23 > v22) {
        goto LABEL_26;
      }
    }
  }

  if ((unsigned __int16)(v21 + 351) <= 0x5Du)
  {
    if (a5)
    {
      char v29 = v21 - 3907;
LABEL_32:
      *a4++ = v29;
    }

BOOL _CFArrayIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 3) != 0LL;
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray)) {
    -[__CFArray replaceObjectsInRange:withObjects:count:]( theArray,  "replaceObjectsInRange:withObjects:count:",  location,  length,  newValues,  newCount);
  }
  else {
    _CFArrayReplaceValues((unint64_t)theArray, location, length, newValues, newCount);
  }
}

void _CFArraySortValues(void *a1, uint64_t a2, uint64_t a3)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  else {
    CFIndex v6 = a1[2];
  }
  if (v6 >= 2)
  {
    char v7 = (const void **)values;
    v13.CFIndex location = 0LL;
    v13.CFIndex length = v6;
    CFArrayGetValues((CFArrayRef)a1, v13, v7);
    v11[0] = a2;
    v11[1] = a3;
    CFQSortArray(v7, v6, 8LL, (uint64_t)__CFArrayCompareValues, (uint64_t)v11, v8, v9, v10);
    v14.CFIndex location = 0LL;
    v14.CFIndex length = v6;
    CFArrayReplaceValues((CFMutableArrayRef)a1, v14, v7, v6);
  }

uint64_t __CFArrayCompareValues(void *a1, void *a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, void))a3)(*a1, *a2, *(void *)(a3 + 8));
}

void CFArraySortValues( CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  uint64_t length = range.length;
  CFIndex location = range.location;
  values[256] = *(void **)MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theArray + 1);
    char isKindOfClass = (v10 & 3) != 0LL;
  }

  unsigned int v15 = atomic_load((unint64_t *)theArray + 1);
  int v16 = (v15 >> 2) & 3;
  if (v16)
  {
    if (v16 == 1)
    {
LABEL_5:
      char v11 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }

    char v17 = atomic_load((unint64_t *)theArray + 1);
    int v18 = v17 & 3;
    if (v18 != 2 && v18) {
      char v11 = 0LL;
    }
    else {
      char v11 = (const CFArrayCallBacks *)((char *)theArray + 48);
    }
  }

  else
  {
    char v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }

CFIndex CFArrayBSearchValues( CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  CFIndex location = range.location;
  if (range.length >= 1)
  {
    CFIndex length = range.length;
    CFIndex v11 = range.location + range.length;
    if (((uint64_t (*)(uint64_t, const void *, void *))comparator)( -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", range.location + range.length - 1),  value,  context) < 0)
    {
      return v11;
    }

    else if ((((uint64_t (*)(const void *, uint64_t, void *))comparator)( value,  -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location),  context) & 0x8000000000000000LL) == 0)
    {
      int v12 = flsl(length);
      int v13 = 1 << (v12 - 1);
      if (((uint64_t (*)(uint64_t, const void *, void *))comparator)( -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v13 - 1),  value,  context) >= 0) {
        uint64_t v14 = -1LL;
      }
      else {
        uint64_t v14 = length - v13;
      }
      if (v12 != 1)
      {
        int v15 = v12 - 2;
        do
        {
          v14 += (1 << v15) & (unint64_t)(((uint64_t (*)(uint64_t, const void *, void *))comparator)( -[__CFArray objectAtIndex:]( theArray,  "objectAtIndex:",  v14 + location + (1 << v15)),  value,  context) >> 63);
          --v15;
        }

        while (v15 != -1);
      }

      location += v14 + 1;
    }
  }

  return location;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  if (otherRange.length >= 1)
  {
    uint64_t v13 = v6;
    uint64_t v14 = v5;
    uint64_t v15 = v4;
    uint64_t v16 = v3;
    uint64_t v17 = v7;
    uint64_t v18 = v8;
    CFIndex location = otherRange.location;
    CFIndex v12 = otherRange.location + otherRange.length;
    do
      CFArrayAppendValue( theArray,  (const void *)-[__CFArray objectAtIndex:]( otherArray,  "objectAtIndex:",  location++,  v13,  v14,  v15,  v16,  v17,  v18));
    while (location < v12);
  }

void __CFAttributedStringDeallocate(uint64_t a1)
{
}

uint64_t __CFAttributedStringEqual(CFStringRef *a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  CFStringRef v4 = a1[2];
  else {
    uint64_t v5 = (const void *)a2[2];
  }
  uint64_t result = CFEqual(v4, v5);
  if ((_DWORD)result)
  {
    CFIndex Length = CFStringGetLength(a1[2]);
    effectiveRange.CFIndex location = 0LL;
    effectiveRange.CFIndex length = 0LL;
    v16.CFIndex location = 0LL;
    v16.CFIndex length = 0LL;
    if (Length < 1)
    {
      return 1LL;
    }

    else
    {
      CFIndex v8 = Length;
      CFIndex location = 0LL;
      CFIndex v10 = 0LL;
      CFIndex v11 = 0LL;
      CFIndex v12 = 0LL;
      CFDictionaryRef v13 = 0LL;
      CFDictionaryRef Attributes = 0LL;
      CFIndex v15 = 0LL;
      while (1)
      {
        if (v15 >= v11 + v12)
        {
          CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a1, v15, &effectiveRange);
          CFIndex location = v16.location;
          CFIndex v10 = v16.length;
        }

        if (v15 >= location + v10) {
          CFDictionaryRef v13 = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v15, &v16);
        }
        uint64_t result = CFEqual(Attributes, v13);
        if (!(_DWORD)result) {
          break;
        }
        CFIndex location = v16.location;
        CFIndex v10 = v16.length;
        CFIndex v11 = effectiveRange.location;
        CFIndex v12 = effectiveRange.length;
        if (effectiveRange.location + effectiveRange.length >= v16.location + v16.length) {
          CFIndex v15 = v16.location + v16.length;
        }
        else {
          CFIndex v15 = effectiveRange.location + effectiveRange.length;
        }
        if (v15 >= v8) {
          return 1LL;
        }
      }
    }
  }

  return result;
}

CFHashCode __CFAttributedStringHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__CFAttributedStringCopyDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (CFStringRef *)MEMORY[0x1895F8858](a1, a2);
  keys[256] = *(void **)MEMORY[0x1895F89C0];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFIndex Length = CFStringGetLength(v2[2]);
  effectiveRange.CFIndex location = 0LL;
  effectiveRange.CFIndex length = 0LL;
  if (Length >= 1)
  {
    CFIndex v5 = Length;
    CFIndex v6 = 0LL;
    while (1)
    {
      CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)v2, v6, &effectiveRange);
      CFIndex v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2[2], effectiveRange);
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
      CFStringAppendFormat(Mutable, 0LL, @" %p {", Attributes);
      unint64_t Count = CFDictionaryGetCount(Attributes);
      if (Count >= 0xFFFFFFFFFFFFFFFLL) {
        __CFAttributedStringCopyDescription_cold_1();
      }
      unint64_t v10 = Count;
      if (Count >= 0x101) {
        break;
      }
      CFIndex v11 = keys;
      CFIndex v12 = values;
      CFDictionaryGetKeysAndValues(Attributes, (const void **)keys, (const void **)values);
      if (v10) {
        goto LABEL_8;
      }
LABEL_13:
      CFStringAppendFormat(Mutable, 0LL, @"} Len %ld\n", effectiveRange.length);
      CFIndex v6 = effectiveRange.location + effectiveRange.length;
      effectiveRange.location += effectiveRange.length;
      if (v11 != keys) {
        free(v11);
      }
      if (v12 != values) {
        free(v12);
      }
      if (v6 >= v5) {
        return Mutable;
      }
    }

    CFIndex v11 = (void **)malloc(8 * Count);
    CFIndex v12 = (void **)malloc(8 * v10);
    CFDictionaryGetKeysAndValues(Attributes, (const void **)v11, (const void **)v12);
LABEL_8:
    unint64_t v13 = v10 - 1;
    do
    {
      if (v13) {
        uint64_t v14 = ", ";
      }
      else {
        uint64_t v14 = "";
      }
      CFStringAppendFormat(Mutable, 0LL, @"%@=%@%s", v11[v13], v12[v13], v14);
      --v13;
    }

    while (v13 != -1LL);
    goto LABEL_13;
  }

  return Mutable;
}

CFTypeID CFAttributedStringGetTypeID(void)
{
  return 62LL;
}

__CFAttributedString *__CFAttributedStringCreateMutableWithSubstring( const __CFAllocator *a1, CFStringRef *a2, CFIndex a3, CFIndex a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  Mutable = CFAttributedStringCreateMutable(a1, 0LL);
  v19.CFIndex location = a3;
  v19.CFIndex length = a4;
  uint64_t v9 = CFStringCreateWithSubstring(a1, a2[2], v19);
  v18.CFIndex location = 0LL;
  v18.CFIndex length = 0LL;
  CFAttributedStringReplaceString(Mutable, v18, v9);
  CFRelease(v9);
  if (a4 >= 1)
  {
    CFIndex v10 = a3 + a4;
    CFIndex v11 = a3;
    do
    {
      CFDictionaryRef Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v11, &effectiveRange);
      if (effectiveRange.location + effectiveRange.length <= v10) {
        v13.CFIndex length = effectiveRange.location - v11 + effectiveRange.length;
      }
      else {
        v13.CFIndex length = v10 - v11;
      }
      if (effectiveRange.location != v11 || effectiveRange.location + effectiveRange.length > v10) {
        effectiveRange.CFIndex length = v13.length;
      }
      v13.CFIndex location = v11 - a3;
      CFAttributedStringSetAttributes(Mutable, v13, Attributes, 1u);
      v11 += effectiveRange.length;
    }

    while (v11 < v10);
  }

  return Mutable;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  uint64_t Instance = (__CFAttributedString *)_CFRuntimeCreateInstance(alloc, 0x3EuLL, 16LL, 0LL, v2, v3, v4, v5);
  if (Instance)
  {
    *((void *)Instance + 2) = CFStringCreateMutable(alloc, maxLength);
    *((void *)Instance + 3) = CFRunArrayCreate(alloc, v9, v10, v11, v12, v13, v14, v15);
  }

  return Instance;
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withString:]( aStr,  "replaceCharactersInRange:withString:",  location,  length,  replacement);
    return;
  }

  CFIndex v7 = CFStringGetLength(replacement);
  uint64_t v8 = v7;
  if (v7 >= 1)
  {
    if (length >= 1)
    {
      ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, 0LL, 0LL);
      CFRetain(ValueAtIndex);
      goto LABEL_8;
    }

    uint64_t v10 = location - 1;
    if (location < 1)
    {
      if (CFStringGetLength(*((CFStringRef *)aStr + 2)) < 1)
      {
        uint64_t v12 = CFGetAllocator(aStr);
        ValueAtIndex = CFDictionaryCreateMutable( v12,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
LABEL_17:
        CFRunArrayInsert(*((CFTypeRef *)aStr + 3), location, v8, ValueAtIndex);
        if (ValueAtIndex)
        {
LABEL_18:
          CFRelease(ValueAtIndex);
          goto LABEL_19;
        }

        goto LABEL_19;
      }

      uint64_t v11 = *((void *)aStr + 3);
      uint64_t v10 = 0LL;
    }

    else
    {
      uint64_t v11 = *((void *)aStr + 3);
    }

    ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(v11, v10, 0LL, 0LL);
    CFRetain(ValueAtIndex);
    goto LABEL_17;
  }

  if (length >= 1)
  {
    ValueAtIndex = 0LL;
LABEL_8:
    CFRunArrayReplace(*((void **)aStr + 3), location, length, ValueAtIndex, v8);
    if (!ValueAtIndex) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v7)
  {
    ValueAtIndex = 0LL;
    goto LABEL_17;
  }

LABEL_19:
  v13.CFIndex location = location;
  v13.CFIndex length = length;
  CFStringReplace(*((CFMutableStringRef *)aStr + 2), v13, replacement);
}

  uint64_t v15 = atomic_load((unint64_t *)(v2 + 8));
  CFRange v16 = atomic_load((unint64_t *)(v3 + 8));
  if (((v16 ^ v15) & 0x70) == 0)
  {
    uint64_t v17 = atomic_load((unint64_t *)(v2 + 8));
    if ((v17 & 0x70) != 0x40LL)
    {
      uint64_t v20 = atomic_load((unint64_t *)(v2 + 8));
      switch((v20 >> 4) & 7)
      {
        case 0u:
        case 1u:
          return;
        case 2u:
          if ((v10 & 8) == 0)
          {
            v109 = *(void *)(v2 + 32);
          }

          break;
        case 3u:
          break;
        default:
LABEL_205:
          __CFCSetIsEqualAnnex(v5, v4);
          break;
      }

      return;
    }
  }

  CFRange v18 = *(void *)(v2 + 40);
  if (!v18 || !*(_DWORD *)(v18 + 8) && !*(_BYTE *)(v18 + 13))
  {
    CFRange v19 = atomic_load((unint64_t *)(v2 + 8));
    switch((v19 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v2 + 32)) {
          goto LABEL_29;
        }
        break;
      case 3u:
      case 4u:
        if (*(void *)(v2 + 24)) {
          goto LABEL_29;
        }
        break;
      default:
        goto LABEL_29;
    }

  if (newLength < 0) {
    CFDataReplaceBytes_cold_2();
  }
  int v25 = v9 - length + newLength;
  if (v25 < 0) {
    CFDataReplaceBytes_cold_3();
  }
  if (!newBytes && newLength) {
    CFDataReplaceBytes_cold_4();
  }
  CFRange v26 = atomic_load(v8 + 1);
  if ((v26 & 4) != 0) {
    CFRange v27 = ((unint64_t)v8 + 63) & 0xFFFFFFFFFFFFFFF0LL;
  }
  else {
    CFRange v27 = v8[5];
  }
  uint64_t v28 = atomic_load(v8 + 1);
  char v29 = v28 & 3;
  if (v29 == 1)
  {
    uint64_t v30 = (UInt8 *)newBytes;
    if (v25 > v10) {
      CFDataReplaceBytes_cold_5();
    }
  }

  else if (v29 == 3 && v10 < v25)
  {
    uint64_t v30 = (UInt8 *)newBytes;
    if (newLength)
    {
      uint64_t v30 = (UInt8 *)newBytes;
      if (newBytes)
      {
        uint64_t v30 = (UInt8 *)newBytes;
        if (v27)
        {
          uint64_t v30 = (UInt8 *)newBytes;
          if (v27 + v10 > (unint64_t)newBytes)
          {
            CFAllocatorRef v31 = (UInt8 *)malloc(newLength);
            if (!v31) {
              __CFDataHandleOutOfMemory(newLength);
            }
            uint64_t v30 = v31;
            memmove(v31, newBytes, newLength);
          }
        }
      }
    }

    __CFDataGrow(v8, newLength - length, 0);
    uint64_t v32 = atomic_load(v8 + 1);
    if ((v32 & 4) != 0) {
      CFRange v27 = ((unint64_t)v8 + 63) & 0xFFFFFFFFFFFFFFF0LL;
    }
    else {
      CFRange v27 = v8[5];
    }
  }

  else
  {
    uint64_t v30 = (UInt8 *)newBytes;
  }

  if (newLength) {
    uint64_t v33 = v30 == 0LL;
  }
  else {
    uint64_t v33 = 1;
  }
  uint64_t v34 = !v33;
  if (length != newLength)
  {
    v35 = v9 - (location + length);
    if (v35 >= 1) {
      memmove((void *)(v27 + location + newLength), (const void *)(v27 + location + length), v35);
    }
  }

  if (v34) {
    memmove((void *)(v27 + location), v30, newLength);
  }
  if (v30 != newBytes) {
    free(v30);
  }
  v8[2] = v25;
}

      *a2 = v8;
      a1[v7] = 47;
      CFIndex v7 = v8;
      goto LABEL_20;
    }

    uint64_t v11 = a1[1];
    uint64_t v12 = *a1;
    if (v11 == 58)
    {
      if ((v12 & 0xFFFFFFDF) - 65 >= 0x1A) {
        goto LABEL_19;
      }
    }

    else if (v11 != 92 || v12 != 92)
    {
      goto LABEL_19;
    }

    CFIndex v7 = 2LL;
  }

  *a2 = v4;
  return v3 != v4;
}

  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
}

    os_unfair_recursive_lock_unlock();
    return 1LL;
  }

  if (a3) {
    *a3 = v18;
  }
  os_unfair_recursive_lock_unlock();
  return 0LL;
}

      CFRelease(v4);
      goto LABEL_20;
    }

    goto LABEL_25;
  }

  if (CFStringCompare(v4, @"infinity", 1uLL) == kCFCompareEqualTo)
  {
LABEL_14:
    CFIndex v7 = (CFTypeRef *)&kCFNumberPositiveInfinity;
    goto LABEL_17;
  }

  if (CFStringCompare(v4, @"-inf", 1uLL) == kCFCompareEqualTo) {
    goto LABEL_16;
  }
  if (CFStringCompare(v4, @"inf", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v4, @"+inf", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_14;
  }

    *(void *)(a1 + 8) = v7++;
    --v8;
    if (!(v4 + v8))
    {
      uint64_t v5 = v4;
      goto LABEL_23;
    }
  }

  CFIndex v6 = v7 - 1;
  uint64_t v5 = -v8;
LABEL_23:
  uint64_t v12 = *v6;
  if (v12 == 60)
  {
    uint64_t v43 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840LL, @"Encountered empty <integer> on line %u", v43);
    goto LABEL_99;
  }

  uint64_t v14 = v12 == 45;
  if (v12 == 45 || v12 == 43)
  {
    uint64_t v15 = v6 + 1;
    *(void *)(a1 + 8) = v6 + 1;
    if ((unint64_t)(v6 + 1) >= v4)
    {
LABEL_48:
      CFIndex v6 = v15;
    }

    else
    {
      CFRange v16 = &v6[v4 - v5];
      uint64_t v17 = v4 - 1 - v5;
      CFRange v18 = v4 - 1 - (void)v6;
      do
      {
        CFRange v19 = *v15;
        if (v19 >= 0x21 && v19 - 127 >= 0x22)
        {
          if (v18 < 3 || (v19 & 0xFE) != 0xE2) {
            goto LABEL_48;
          }
          uint64_t v20 = v15[1];
          uint64_t v21 = v15[2];
          if (v19 == 226 && v20 == 128)
          {
          }

          else if (v19 == 226 && v20 == 129)
          {
            if (v21 != 159) {
              goto LABEL_48;
            }
          }

          else if (v19 != 227 || v20 != 128 || v21 != 128)
          {
            goto LABEL_48;
          }
        }

        *(void *)(a1 + 8) = ++v15;
        --v18;
        --v17;
      }

      while (v17);
      CFIndex v6 = v16;
    }
  }

  else
  {
    uint64_t v14 = 0;
  }

  if (*v6 == 48)
  {
    if ((unint64_t)(v6 + 1) >= v4)
    {
      uint64_t v23 = 0;
      char v24 = 1;
    }

    else
    {
      uint64_t v22 = (v6[1] | 0x20) == 120;
      if ((v6[1] | 0x20) == 0x78)
      {
        ++v6;
        uint64_t v23 = 1;
      }

      else
      {
        uint64_t v23 = 0;
      }

      char v24 = !v22;
    }

    *(void *)(a1 + 8) = ++v6;
  }

  else
  {
    uint64_t v23 = 0;
    char v24 = 0;
  }

  if (v6 == (unsigned __int8 *)v4)
  {
LABEL_98:
    uint64_t v45 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840LL, @"Premature end of file after <integer> on line %u", v45);
    goto LABEL_99;
  }

  int v25 = *v6;
  if (v25 == 48)
  {
    CFRange v26 = v6 + 1;
    while (1)
    {
      *(void *)(a1 + 8) = v26;
      CFRange v27 = *v26++;
      int v25 = v27;
      if (v27 != 48)
      {
        CFIndex v6 = v26 - 1;
        char v24 = 1;
        break;
      }
    }
  }

  if (!v24 || v25 != 60)
  {
    if (v25 != 60)
    {
      uint64_t v30 = 0LL;
      CFAllocatorRef v31 = 0x1999999999999999LL;
      if (v23) {
        CFAllocatorRef v31 = 0xFFFFFFFFFFFFFFFLL;
      }
      uint64_t v32 = 10LL;
      if (v23) {
        uint64_t v32 = 16LL;
      }
      uint64_t v33 = v6 + 1;
      do
      {
        uint64_t v34 = (char)v25;
        v35 = v34 - 48;
        if ((v34 - 48) > 0x36)
        {
LABEL_114:
          v49 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError( 3840LL,  @"Unknown character '%c' (0x%x) in <integer> on line %u",  v34,  v34,  v49);
          goto LABEL_99;
        }

        if (((1LL << v35) & 0x3FF) == 0)
        {
          if (((1LL << v35) & 0x7E0000) != 0)
          {
            char v36 = -55;
          }

          else
          {
            if (((1LL << v35) & 0x7E000000000000LL) == 0) {
              goto LABEL_114;
            }
            char v36 = -87;
          }

          if ((v23 & 1) == 0)
          {
            uint64_t v48 = lineNumber((unint64_t *)a1);
            Error = __CFPropertyListCreateError(3840LL, @"Hex digit in non-hex <integer> on line %u", v48);
            goto LABEL_99;
          }

          v35 = v36 + v34;
        }

        if (v31 < v30 || __CFADD__(v30 * v32, v35))
        {
          uint64_t v46 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840LL, @"Integer overflow in <integer> on line %u", v46);
          goto LABEL_99;
        }

        uint64_t v30 = v30 * v32 + v35;
        CFAllocatorRef v37 = v14 ^ 1;
        if ((v37 & 1) == 0)
        {
          uint64_t v47 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840LL, @"Integer underflow in <integer> on line %u", v47);
          goto LABEL_99;
        }

        *(void *)(a1 + 8) = v33;
        BOOL v38 = *v33++;
        LOBYTE(v25) = v38;
      }

      while (v38 != 60);
      uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
      if (!(_DWORD)result) {
        return result;
      }
      if (*(_BYTE *)(a1 + 80))
      {
        *a2 = 0LL;
        return 1LL;
      }

      if (((v30 < 0) & ~v14) != 0)
      {
        valuePtr[0] = 0LL;
        valuePtr[1] = v30;
        uint64_t v40 = *(const __CFAllocator **)(a1 + 32);
        uint64_t v41 = kCFNumberMaxType|kCFNumberSInt8Type;
      }

      else
      {
        if (v14) {
          char v42 = -v30;
        }
        else {
          char v42 = v30;
        }
        valuePtr[0] = v42;
        uint64_t v40 = *(const __CFAllocator **)(a1 + 32);
        uint64_t v41 = kCFNumberSInt64Type;
      }

      goto LABEL_102;
    }

    uint64_t v44 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840LL, @"Incomplete <integer> on line %u", v44);
LABEL_99:
    uint64_t v39 = Error;
    uint64_t result = 0LL;
    *(void *)(a1 + 24) = v39;
    return result;
  }

  LODWORD(valuePtr[0]) = 0;
  uint64_t result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
  if (!(_DWORD)result) {
    return result;
  }
  if (!*(_BYTE *)(a1 + 80))
  {
    uint64_t v40 = *(const __CFAllocator **)(a1 + 32);
    uint64_t v41 = kCFNumberSInt32Type;
LABEL_102:
    char v29 = CFNumberCreate(v40, v41, valuePtr);
    goto LABEL_103;
  }

  char v29 = 0LL;
LABEL_103:
  *a2 = v29;
  return 1LL;
}

    CFRelease(cf[0]);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  }

  else
  {
    CFIndex v7 = 0LL;
  }

  kdebug_trace();
  return v7;
}

        uint64_t v8 = [a1 _cfTypeID];
        break;
    }
  }

  else
  {
    uint64_t v9 = atomic_load(a1 + 1);
    uint64_t v8 = (v9 >> 8) & 0x3FF;
  }

  if (v8 <= 0x47) {
LABEL_21:
  }
    uint64_t v10 = &__CFRuntimeBuiltinClassTable + v8;
  else {
    uint64_t v10 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v8 - 72) >> 6] + 8LL * (((_DWORD)v8 - 72) & 0x3F));
  }
  uint64_t v11 = (uint64_t (*)(unint64_t *))*((void *)*v10 + 6);
  if (v11) {
    return v11(a1);
  }
  else {
    return (uint64_t)a1;
  }
}

      a5 = _os_log_pack_size();
      uint64_t v11 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v11 = 136315394;
      *(void *)(v11 + 4) = "-[NSMutableDictionary addObjects:forKeys:count:]";
      *(_WORD *)(v11 + 12) = 2048;
      *(void *)(v11 + 14) = v10;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableDictionary addObjects:forKeys:count:]",  v10);
      uint64_t v12 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v22 - ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a5);
      objc_exception_throw(v12);
      goto LABEL_20;
    }

    CFRange v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    goto LABEL_23;
  }

  if ((*(_BYTE *)(a1 + 16) & 0x20) == 0) {
    CFAllocatorDeallocate(v3, *(void **)(a1 + 48));
  }
  uint64_t v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 120) = 0LL;
  }

  uint64_t v10 = *(dispatch_object_s **)(a1 + 128);
  if (v10)
  {
    dispatch_release(v10);
    *(void *)(a1 + 128) = 0LL;
  }

  uint64_t v20 = 0;
  v104 = (v12 >> 3) & 1;
  v109 = 0;
  if ((_DWORD)a4 != 256)
  {
    uint64_t v21 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      uint64_t v21 = __CFDefaultEightBitStringEncoding;
    }

    if ((_DWORD)a4 == 1536 || v21 != (_DWORD)a4)
    {
      uint64_t v20 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          uint64_t v20 = 0;
          goto LABEL_51;
        case 1:
          if ((_DWORD)a4 == 134217984) {
            goto LABEL_47;
          }
          goto LABEL_50;
        case 2:
          if ((_DWORD)a4 == 518) {
            goto LABEL_50;
          }
          goto LABEL_47;
        case 6:
          if ((_DWORD)a4 != 1536) {
            goto LABEL_50;
          }
          goto LABEL_47;
        case 8:
        case 0xC:
          goto LABEL_51;
        case 0xA:
          uint64_t v23 = 1 << (a4 - 1);
          char v24 = 32785;
          break;
        case 0xB:
          uint64_t v23 = 1 << (a4 + 13);
          char v24 = 4099;
          break;
        default:
          goto LABEL_47;
      }

      if ((v23 & v24) != 0)
      {
LABEL_50:
        uint64_t v20 = 0;
      }

      else
      {
LABEL_47:
        int v25 = v14;
        CFRange v26 = ptr;
        while (v25 > 0x1F)
        {
          uint64_t v28 = *v26;
          CFRange v27 = v26[1];
          v26 += 2;
          char v29 = vorrq_s8(v28, v27);
          v25 -= 32LL;
        }

        while (v25 > 0xF)
        {
          uint64_t v20 = 0;
          BOOL v38 = v26->i64[0];
          uint64_t v39 = v26->i64[1];
          ++v26;
          v25 -= 16LL;
          if (((v39 | v38) & 0x8080808080808080LL) != 0) {
            goto LABEL_51;
          }
        }

        while (v25 > 7)
        {
          uint64_t v20 = 0;
          uint64_t v40 = v26->i64[0];
          CFRange v26 = (int8x16_t *)((char *)v26 + 8);
          v25 -= 8LL;
          if ((v40 & 0x8080808080808080LL) != 0) {
            goto LABEL_51;
          }
        }

        while (v25 > 3)
        {
          uint64_t v20 = 0;
          uint64_t v41 = v26->i32[0];
          CFRange v26 = (int8x16_t *)((char *)v26 + 4);
          v25 -= 4LL;
          if ((v41 & 0x80808080) != 0) {
            goto LABEL_51;
          }
        }

        char v42 = 0LL;
        do
        {
          uint64_t v20 = v25 == v42;
          if (v25 == v42) {
            break;
          }
          uint64_t v43 = v26->i8[v42++];
        }

        while ((v43 & 0x80000000) == 0);
      }
    }

    else
    {
      uint64_t v20 = 1;
    }
  }

    uint64_t v23 = *a6;
    if (v23 <= 0x746B)
    {
      if (v23 == 27758)
      {
        if (v58 == 74)
        {
          if ((a5 & 8) != 0) {
            uint64_t v41 = 74;
          }
          else {
            uint64_t v41 = 106;
          }
          else {
            uint64_t v32 = 74;
          }
          goto LABEL_77;
        }

        goto LABEL_51;
      }

      if (v23 != 29300) {
        goto LABEL_51;
      }
LABEL_31:
      if ((int)a1 <= 304)
      {
        if (a1 == 73) {
          goto LABEL_103;
        }
        if (a1 == 105 || a1 == 304)
        {
          CFAllocatorRef v31 = (_DWORD)v8 == 3 || (_DWORD)v8 == 0;
          uint64_t v32 = 304;
          uint64_t v33 = 105;
          goto LABEL_75;
        }
      }

      else if (a1 == 775)
      {
        if ((a5 & 2) != 0)
        {
          if (!(_DWORD)v8) {
            return 0LL;
          }
          uint64_t v32 = 775;
LABEL_77:
          *a2 = v32;
          return 1LL;
        }
      }

      else if (a1 == 305)
      {
LABEL_103:
        if ((_DWORD)v8 != 3 && (_DWORD)v8)
        {
          uint64_t v32 = 73;
          goto LABEL_77;
        }

        CFAllocatorRef v31 = (a5 & 4) == 0;
        uint64_t v32 = 105;
        uint64_t v33 = 305;
LABEL_75:
        if (v31) {
          uint64_t v32 = v33;
        }
        goto LABEL_77;
      }

      goto LABEL_51;
    }

    if (v23 == 31329) {
      goto LABEL_31;
    }
    if (v23 != 29804) {
      goto LABEL_51;
    }
    if (!v13) {
      return 0LL;
    }
    if ((_DWORD)v8) {
      goto LABEL_51;
    }
    if ((a5 & 4) != 0)
    {
      if ((int)a1 > 204)
      {
        switch(a1)
        {
          case 0xCDu:
            goto LABEL_126;
          case 0x128u:
LABEL_127:
            uint64_t v46 = a2;
            *(_DWORD *)a2 = 50790505;
            uint64_t v47 = 771;
            goto LABEL_128;
          case 0x12Eu:
            uint64_t v48 = 303;
            goto LABEL_137;
        }

        goto LABEL_51;
      }

      if (a1 == 73)
      {
        uint64_t v48 = 105;
LABEL_137:
        *(_DWORD *)a2 = v48 | 0x3070000;
        return 2LL;
      }

      if (a1 == 74)
      {
        uint64_t v48 = 106;
        goto LABEL_137;
      }
    }

    else
    {
      if (a1 == 296) {
        goto LABEL_127;
      }
      if (a1 == 205)
      {
LABEL_126:
        uint64_t v46 = a2;
        *(_DWORD *)a2 = 50790505;
        uint64_t v47 = 769;
        goto LABEL_128;
      }
    }

    if (a1 == 204)
    {
      uint64_t v46 = a2;
      *(_DWORD *)a2 = 50790505;
      uint64_t v47 = 768;
LABEL_128:
      v46[2] = v47;
      return 3LL;
    }

          uint64_t v20 = &v10[v18];
          uint64_t v21 = &v10[v18 + v15];
          if (!strncasecmp_l(v21 - 4, ".opf", 4uLL, 0LL))
          {
            CFRange v16 = 0;
            HIDWORD(v58) = 1;
            goto LABEL_78;
          }

          if (!strncasecmp_l(v21 - 4, ".sml", 4uLL, 0LL)) {
            goto LABEL_60;
          }
          if (!strncasecmp_l(v21 - 5, ".smil", 5uLL, 0LL))
          {
LABEL_60:
            CFRange v16 = 0;
            HIDWORD(v57) = 1;
            goto LABEL_78;
          }

          if (strncasecmp_l(v20, "xl/", 3uLL, 0LL) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0LL))
          {
            if (!strncasecmp_l(v20, "ppt/", 4uLL, 0LL) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0LL))
            {
              CFRange v16 = 0;
              uint64_t v23 = 1;
LABEL_107:
              HIDWORD(v56) = v23;
              goto LABEL_78;
            }

            if (!strncasecmp_l(v20, "word/", 5uLL, 0LL) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0LL))
            {
              CFRange v16 = 0;
              LODWORD(v58) = 1;
              goto LABEL_78;
            }

            if (v15 < 0xB)
            {
LABEL_75:
              CFRange v16 = 0;
              goto LABEL_78;
            }

            if (strncasecmp_l(v20, "excel/", 6uLL, 0LL) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0LL))
            {
              if (v15 >= 0x10 && !strncasecmp_l(v20, "powerpoint/", 0xBuLL, 0LL))
              {
                uint64_t v22 = strncasecmp_l(v21 - 4, ".xml", 4uLL, 0LL);
                CFRange v16 = 0;
                uint64_t v23 = HIDWORD(v56);
                if (!v22) {
                  uint64_t v23 = 1;
                }
                goto LABEL_107;
              }

              goto LABEL_75;
            }
          }

          CFRange v16 = 0;
          LODWORD(v57) = 1;
          goto LABEL_78;
      }
    }

    goto LABEL_19;
  }

  if (strncasecmp_l(&v10[v13], "mimetype", 8uLL, 0LL)) {
    goto LABEL_19;
  }
  char v24 = &v10[*((unsigned __int16 *)v10 + 13) + *((unsigned __int16 *)v10 + 14)];
  int v25 = (unint64_t)(v24 + 30);
  if (v24 + 30 <= v10
    || (unint64_t)(v24 + 86) > v53
    || *((_WORD *)v10 + 4)
    || strncasecmp_l((const char *)v25, "application/vnd.", 0x10uLL, 0LL)
    && strncasecmp_l((const char *)v25, "application/x-vnd.", 0x12uLL, 0LL))
  {
    if (v25 > (unint64_t)v10
      && v25 + 41 <= v53
      && *((_WORD *)v10 + 4) == 8
      && *(_DWORD *)v25 == -936891317
      && *(_DWORD *)(v25 + 4) == 743328969)
    {
      CFRange v26 = -1;
      uint64_t v9 = "odt";
      goto LABEL_77;
    }

    if (v25 <= (unint64_t)v10
      || v25 + 29 > v53
      || strncasecmp_l((const char *)v25, "application/oebps-package+xml", 0x1DuLL, 0LL))
    {
      CFRange v26 = -1;
    }

    CFRange v26 = 0;
    uint64_t v9 = "epub";
    goto LABEL_77;
  }

  CFRange v27 = 16LL;
  if (*(_BYTE *)(v25 + 15) != 46) {
    CFRange v27 = 18LL;
  }
  uint64_t v28 = (const char *)(v25 + v27);
  if (!strncasecmp_l(v28, "sun.xml.", 8uLL, 0LL))
  {
    uint64_t v30 = v28 + 8;
    if (strncasecmp_l(v30, "calc", 4uLL, 0LL))
    {
      if (strncasecmp_l(v30, "draw", 4uLL, 0LL))
      {
        if (strncasecmp_l(v30, "writer.global", 0xDuLL, 0LL))
        {
          if (strncasecmp_l(v30, "impress", 7uLL, 0LL))
          {
            CFRange v26 = 4;
            if (strncasecmp_l(v30, "math", 4uLL, 0LL))
            {
              if (strncasecmp_l(v30, "writer", 6uLL, 0LL)) {
                goto LABEL_67;
              }
              CFRange v26 = 5;
            }
          }

          else
          {
            CFRange v26 = 3;
          }
        }

        else
        {
          CFRange v26 = 2;
        }
      }

      else
      {
        CFRange v26 = 1;
      }
    }

    else
    {
      CFRange v26 = 0;
    }

    CFAllocatorRef v31 = (5 * v26);
    uint64_t v32 = "sxc";
    goto LABEL_122;
  }

  if (strncasecmp_l(v28, "oasis.opendocument.", 0x13uLL, 0LL)) {
    goto LABEL_67;
  }
  char v29 = v28 + 19;
  if (!strncasecmp_l(v29, "chart", 5uLL, 0LL))
  {
    CFRange v26 = 0;
LABEL_121:
    CFAllocatorRef v31 = (5 * v26);
    uint64_t v32 = (const char *)&unk_180D68824;
LABEL_122:
    uint64_t v9 = &v32[v31];
    goto LABEL_77;
  }

  if (!strncasecmp_l(v29, "formula", 7uLL, 0LL))
  {
    CFRange v26 = 1;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "graphics", 8uLL, 0LL))
  {
    CFRange v26 = 2;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "text-web", 8uLL, 0LL))
  {
    CFRange v26 = 3;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "image", 5uLL, 0LL))
  {
    CFRange v26 = 4;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "text-master", 0xBuLL, 0LL))
  {
    CFRange v26 = 5;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "presentation", 0xCuLL, 0LL))
  {
    CFRange v26 = 6;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "spreadsheet", 0xBuLL, 0LL))
  {
    CFRange v26 = 7;
    goto LABEL_121;
  }

  if (!strncasecmp_l(v29, "text", 4uLL, 0LL))
  {
    CFRange v26 = 8;
    goto LABEL_121;
  }

  if ((a2 - 57344) % 0xBC <= 0x3E) {
    uint64_t v14 = a2 + 68 * ((a2 - 57344) / 0xBC);
  }
  else {
    uint64_t v14 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  }
  *(_WORD *)a3 = bswap32(v14 + 4160) >> 16;
  return 2LL;
}

  uint64_t v17 = -[NSArray initWithObjects:count:](self, "initWithObjects:count:");
  free(v14);
  return v17;
}

  CFRange v16 = (NSArray *)[objc_alloc((Class)v4) initWithObjects:v12 count:v6];
  free(v13);
LABEL_21:
  uint64_t v17 = v16;
  return v16;
}

  CFRange v18 = (NSSet *)objc_msgSend(v4, "initWithObjects:count:", v20);
  free(v15);
  return v18;
}

      CFRange v16 = (void *)[[v4 alloc] initWithObjects:v12 count:v6];
      free(v13);
      return (NSSet *)v16;
    }

    uint64_t v8 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v6);
    uint64_t v4 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v8,  0LL);
    CFRelease(v8);
    objc_exception_throw(v4);
    __break(1u);
  }

  if (v5 != (__objc2_class *)v4)
  {
    CFIndex v6 = 0LL;
    goto LABEL_9;
  }

  return (NSSet *)__NSSet0__;
}

        if (v3 == ++v4) {
          goto LABEL_22;
        }
      }
    }

    uint64_t v5 = -1LL;
LABEL_22:
    __CFBasicHashRemoveValue(a1, v5);
  }

  else {
    uint64_t v20 = "kCFPreferencesAnyHost";
  }
  uint64_t v21 = (const __CFString *)[a3 copyUncanonicalizedPath];
  uint64_t v22 = toCString(v21, &v35, "no uncanonicalized path");
  if (v9) {
    p_buffer = (const char *)&buffer;
  }
  else {
    p_buffer = "unknown process name";
  }
  (*(void (**)(uint64_t, uint64_t, const char *, void *, char *, void *, const char *, void *, _BYTE))(a4 + 16))( a4,  v10,  p_buffer,  v14,  string_ptr,  v15,  v20,  v22,  [a3 managed]);
  if (v21) {
    CFRelease(v21);
  }
  if (v37) {
    free(v14);
  }
  if (v36) {
    free(v15);
  }
  if (v35) {
    free(v22);
  }
  if (v17) {
    free(string_ptr);
  }
}

  *(void *)(a1 + 8) = v5;
  return result;
}

CFDictionaryRef CFAttributedStringGetAttributes( CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr)) {
    return (CFDictionaryRef)-[__CFAttributedString attributesAtIndex:effectiveRange:]( aStr,  "attributesAtIndex:effectiveRange:",  loc,  effectiveRange);
  }
  else {
    return (CFDictionaryRef)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), loc, &effectiveRange->location, 0LL);
  }
}

void CFAttributedStringSetAttributes( CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
  uint64_t v4 = (__objc2_class **)MEMORY[0x1895F8858](aStr, range.location);
  int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  CFRange v13 = (uint64_t *)v4;
  keys[256] = *(void **)MEMORY[0x1895F89C0];
  int v14 = CF_IS_OBJC(0x3EuLL, v4);
  if (v6)
  {
    if (v14)
    {
      objc_msgSend(v13, "setAttributes:range:", v8, v12, v10);
    }

    else if (v10)
    {
      uint64_t v15 = CFGetAllocator(v13);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v15, v8);
      CFRunArrayReplace((void *)v13[3], v12, v10, AttributesDictionary, v10);
      CFRelease(AttributesDictionary);
    }

    return;
  }

  if (v14)
  {
    objc_msgSend(v13, "addAttributes:range:", v8, v12, v10);
    return;
  }

  unint64_t Count = CFDictionaryGetCount(v8);
  if (Count)
  {
    unint64_t v18 = Count;
    if (Count >= 0xFFFFFFFFFFFFFFFLL) {
      CFAttributedStringSetAttributes_cold_1();
    }
    if (Count > 0x100)
    {
      uint64_t v20 = (const void **)malloc(8 * Count);
      CFRange v19 = (const void **)malloc(8 * v18);
    }

    else
    {
      CFRange v19 = (const void **)values;
      uint64_t v20 = (const void **)keys;
    }

    CFDictionaryGetKeysAndValues(v8, v20, v19);
    if (v10)
    {
      while (1)
      {
        ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(v13[3], v12, &v41, 0LL);
        uint64_t v22 = ValueAtIndex;
        uint64_t v24 = v41;
        uint64_t v23 = v42;
        BOOL v25 = v41 == v12 && v42 <= v10;
        if (!v25) {
          goto LABEL_23;
        }
        CFRange v26 = v20;
        CFRange v27 = v19;
        unint64_t v28 = v18;
        if (CFGetRetainCount(ValueAtIndex) != 1) {
          break;
        }
        do
        {
          uint64_t v30 = *v26++;
          char v29 = v30;
          CFAllocatorRef v31 = *v27++;
          CFDictionarySetValue(v22, v29, v31);
          --v28;
        }

        while (v28);
LABEL_31:
        v12 += v42;
        v10 -= v42;
        if (!v10) {
          goto LABEL_32;
        }
      }

      uint64_t v24 = v41;
      uint64_t v23 = v42;
LABEL_23:
      BOOL v25 = v24 < v12;
      uint64_t v32 = v24 - v12;
      if (v25)
      {
        v23 += v32;
        uint64_t v41 = v12;
        uint64_t v42 = v23;
      }

      if (v23 > v10) {
        uint64_t v42 = v10;
      }
      uint64_t v33 = CFGetAllocator(v13);
      uint64_t v34 = __CFAttributedStringCreateAttributesDictionary(v33, v22);
      v35 = v20;
      char v36 = v19;
      unint64_t v37 = v18;
      do
      {
        uint64_t v39 = *v35++;
        BOOL v38 = v39;
        uint64_t v40 = *v36++;
        CFDictionarySetValue(v34, v38, v40);
        --v37;
      }

      while (v37);
      CFRunArrayReplace((void *)v13[3], v41, v42, v34, v42);
      CFRelease(v34);
      goto LABEL_31;
    }

LABEL_32:
  }

    CFRelease(v29);
  }

    CFRelease(v29);
  }

      if (++v9 == 17) {
        return 1LL;
      }
    }
  }

  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
  if (v7)
  {
    BOOL v25 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(v7 + 128);
    if (v25) {
      return v25(v6, a2, a3, *(void *)(v6 + 40));
    }
  }

  return result;
}

      MEMORY[0x1895F8858](Length, v16);
      uint64_t v30 = &v31;
      __strlcpy_chk();
      __strlcat_chk();
      goto LABEL_33;
    }

    if (CFStringHasSuffix(v7, @""))
    {
      unint64_t v28 = __CFStringApproximateSyllableCount_el_GR(v7);
      if (v28 == 2)
      {
LABEL_6:
        CFStringReplaceAll(v7, theString1);
        CFIndex Length = CFStringGetLength(v7);
        if (Length > 0)
        {
          v36.CFIndex location = Length - 1;
          v36.CFIndex length = 1LL;
          CFStringDelete(v7, v36);
          goto LABEL_16;
        }

        goto LABEL_32;
      }

      if (v28 >= 3)
      {
LABEL_10:
        CFStringReplaceAll(v7, theString1);
        CFIndex Length = CFStringGetLength(v7);
        if (Length > 1)
        {
          v18.CFIndex location = Length - 2;
          CFRange v19 = @"";
LABEL_15:
          v18.CFIndex length = 2LL;
          CFStringReplace(v7, v18, v19);
          goto LABEL_16;
        }

        goto LABEL_32;
      }
    }

    else
    {
      uint64_t v33 = @"";
      uint64_t v34 = 0LL;
      if (__CFStringHasOneOfSuffixes(v7, v21, v22, v23, v24, v25, v26, v27, (uint64_t)@""))
      {
        char v29 = __CFStringApproximateSyllableCount_el_GR(v7);
        switch(v29)
        {
          case 4LL:
            goto LABEL_26;
          case 3LL:
            CFStringReplaceAll(v7, theString1);
            CFStringAppend(v7, @"");
LABEL_16:
            uint64_t v20 = CFRetain(v7);
            CFRelease(v7);
            if (v20) {
              return v20;
            }
            return CFRetain(theString1);
          case 2LL:
LABEL_26:
            CFStringReplaceAll(v7, theString1);
            CFIndex Length = CFStringGetLength(v7);
            if (Length > 1)
            {
              v18.CFIndex location = Length - 2;
              CFRange v19 = @"";
              goto LABEL_15;
            }

            goto LABEL_32;
        }
      }
    }

    CFRelease(v7);
    return CFRetain(theString1);
  }

  MEMORY[0x1895F8858](0LL, v6);
  uint64_t v30 = v32;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_33:
  uint64_t result = (CFTypeRef)__strlcat_chk();
  qword_18C539A70 = (uint64_t)v30;
  __break(1u);
  return result;
}

  p_dst = 0LL;
  if (v16 < 0) {
    goto LABEL_53;
  }
LABEL_52:
  uint64_t v34 = *((void *)a4 + 20);
  if (v16 + a6 <= v34)
  {
    v104 = *((void *)a4 + 17);
    if (v104)
    {
      v35 = (UniChar *)(v104 + 2LL * *((void *)a4 + 19) + 2 * v16);
      if (!p_dst) {
        goto LABEL_54;
      }
    }

    else
    {
      if (a6 > 64) {
        goto LABEL_53;
      }
      if (v16 + a6 > *((void *)a4 + 22) || (v105 = *((void *)a4 + 21), v16 < v105))
      {
        if (v16 + 64 < v34) {
          uint64_t v34 = v16 + 64;
        }
        *((void *)a4 + 21) = v16;
        *((void *)a4 + 22) = v34;
        v106.CFIndex length = v34 - v16;
        v108 = *((void *)a4 + 18);
        v107 = *((void *)a4 + 19);
        if (v108)
        {
          v105 = v16;
          if (v106.length)
          {
            v109 = v108 + v107;
            v110 = a4;
            do
            {
              *v110++ = *(char *)(v109 + v16);
              ++v109;
              --v34;
            }

            while (v16 != v34);
            v105 = v16;
          }
        }

        else
        {
          v106.CFIndex location = v107 + v16;
          CFStringGetCharacters(*((CFStringRef *)a4 + 16), v106, a4);
          v105 = *((void *)a4 + 21);
        }
      }

      v35 = &a4[v16 - v105];
      if (!p_dst) {
        goto LABEL_54;
      }
    }

    if (v35)
    {
      v111 = a2 + a3 - v15;
      v112 = a5 + a6 - v16;
      v100 = Collator;
      if (Collator && !__CompareTextDefault(Collator, v126, a7, p_dst, v111, v35, v112, &v132, &v133))
      {
        v114 = (a7 >> 9) & 1;
        if (!v132) {
          LODWORD(v114) = 1;
        }
        v115 = 1LL;
        if (v133 < 0) {
          v115 = -1LL;
        }
        if ((_DWORD)v114) {
          v97 = v115;
        }
        else {
          v97 = 0LL;
        }
      }

      else
      {
        if (v111 >= v112) {
          v113 = v112;
        }
        else {
          v113 = v111;
        }
        if (memcmp(p_dst, v35, 2 * v113) >= 0) {
          v97 = 1LL;
        }
        else {
          v97 = -1LL;
        }
      }

      v99 = v117;
      v98 = cf;
      goto LABEL_189;
    }

    goto LABEL_54;
  }

          switch(*a1)
          {
            case 0x30EFu:
              CFIndex v7 = a2 == 0;
              uint64_t v8 = 12535;
              goto LABEL_41;
            case 0x30F0u:
              CFIndex v7 = a2 == 0;
              uint64_t v8 = 12536;
              goto LABEL_41;
            case 0x30F1u:
              CFIndex v7 = a2 == 0;
              uint64_t v8 = 12537;
              goto LABEL_41;
            case 0x30F2u:
              CFIndex v7 = a2 == 0;
              uint64_t v8 = 12538;
              goto LABEL_41;
            default:
              if (v2 != 12541) {
                return (unsigned __int16)-3;
              }
              CFIndex v7 = a2 == 0;
              uint64_t v8 = 12542;
              break;
          }

          goto LABEL_41;
        }

        return (unsigned __int16)(v2 + 1);
      }

      if ((v2 - 12358) <= 0x35)
      {
        if (v2 == 12358)
        {
          CFIndex v7 = a2 == 0;
          uint64_t v8 = 12436;
LABEL_41:
          if (v7) {
            return (unsigned __int16)-3;
          }
          else {
            return v8;
          }
        }
      }
    }

    return (unsigned __int16)-3;
  }

  if (v3 == 774)
  {
    if ((v2 & 0xFFFFFFDF) == 0x418) {
      return (unsigned __int16)(v2 + 1);
    }
    return (unsigned __int16)-3;
  }

  if (v3 != 776) {
    return (unsigned __int16)-3;
  }
  if (v2 == 1077) {
    uint64_t v4 = 1105;
  }
  else {
    uint64_t v4 = -3;
  }
  if (v2 == 1045) {
    return 1025;
  }
  else {
    return v4;
  }
}

CFAttributedStringRef CFAttributedStringCreate( CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  uint64_t Instance = _CFRuntimeCreateInstance(alloc, 0x3EuLL, 16LL, 0LL, v3, v4, v5, v6);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFStringCreateCopy(alloc, str);
    *(void *)(Instance + 24) = CFRunArrayCreate(alloc, v11, v12, v13, v14, v15, v16, v17);
    CFIndex Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      uint64_t v19 = Length;
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(alloc, attributes);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0LL, v19, AttributesDictionary);
      CFRelease(AttributesDictionary);
    }

    uint64_t v21 = (unint64_t *)(Instance + 8);
    unint64_t v22 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v23 = __ldaxr(v21);
      if (v23 != v22) {
        break;
      }
      if (__stlxr(v22 | 1, v21)) {
        goto LABEL_9;
      }
      int v24 = 1;
LABEL_10:
      unint64_t v22 = v23;
      if (v24) {
        return (CFAttributedStringRef)Instance;
      }
    }

    __clrex();
LABEL_9:
    int v24 = 0;
    goto LABEL_10;
  }

  return (CFAttributedStringRef)Instance;
}

CFMutableDictionaryRef __CFAttributedStringCreateAttributesDictionary( const __CFAllocator *a1, CFDictionaryRef theDict)
{
  if (theDict) {
    return CFDictionaryCreateMutableCopy(a1, 0LL, theDict);
  }
  else {
    return CFDictionaryCreateMutable(a1, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

CFAttributedStringRef CFAttributedStringCreateWithSubstring( CFAllocatorRef alloc, CFAttributedStringRef aStr, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr)) {
    return (CFAttributedStringRef)-[__CFAttributedString _createAttributedSubstringWithRange:]( aStr,  "_createAttributedSubstringWithRange:",  location,  length);
  }
  CFIndex v8 = CFAttributedStringGetLength(aStr);
  if (location || length != v8)
  {
    CFAttributedStringRef result = __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, location, length);
    uint64_t v9 = (unint64_t *)((char *)result + 8);
    unint64_t v10 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      unint64_t v11 = __ldaxr(v9);
      if (v11 != v10) {
        break;
      }
      if (__stlxr(v10 | 1, v9)) {
        goto LABEL_11;
      }
      int v12 = 1;
LABEL_12:
      unint64_t v10 = v11;
      if (v12) {
        return result;
      }
    }

    __clrex();
LABEL_11:
    int v12 = 0;
    goto LABEL_12;
  }

  return CFAttributedStringCreateCopy(alloc, aStr);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  else {
    return CFStringGetLength(*((CFStringRef *)aStr + 2));
  }
}

CFAttributedStringRef CFAttributedStringCreateCopy(CFAllocatorRef alloc, CFAttributedStringRef aStr)
{
  MutableWithSubstring = (unint64_t *)aStr;
  char v5 = atomic_load(MutableWithSubstring + 1);
  if ((v5 & 1) == 0) {
    goto LABEL_14;
  }
  CFAllocatorRef v6 = alloc;
  if (alloc)
  {
    if (((unint64_t)MutableWithSubstring & 0x8000000000000000LL) != 0)
    {
LABEL_6:
      CFIndex v7 = &kCFAllocatorSystemDefault;
      goto LABEL_13;
    }
  }

  else
  {
    uint64_t v8 = _CFGetTSD(1u);
    CFAllocatorRef v6 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    if (v8) {
      CFAllocatorRef v6 = (CFAllocatorRef)v8;
    }
  }

  char v9 = atomic_load(MutableWithSubstring + 1);
  if (v9 < 0) {
    CFIndex v7 = &kCFAllocatorSystemDefault;
  }
  else {
    CFIndex v7 = (const CFAllocatorRef *)(MutableWithSubstring - 2);
  }
LABEL_13:
  if (v6 != *v7)
  {
LABEL_14:
    CFIndex Length = CFAttributedStringGetLength((CFAttributedStringRef)MutableWithSubstring);
    MutableWithSubstring = (unint64_t *)__CFAttributedStringCreateMutableWithSubstring( alloc,  (CFStringRef *)MutableWithSubstring,  0LL,  Length);
    unint64_t v11 = MutableWithSubstring + 1;
    unint64_t v12 = atomic_load(MutableWithSubstring + 1);
    while (1)
    {
      unint64_t v13 = __ldaxr(v11);
      if (v13 != v12) {
        break;
      }
      if (__stlxr(v12 | 1, v11)) {
        goto LABEL_19;
      }
      int v14 = 1;
LABEL_20:
      unint64_t v12 = v13;
      if (v14) {
        return (CFAttributedStringRef)MutableWithSubstring;
      }
    }

    __clrex();
LABEL_19:
    int v14 = 0;
    goto LABEL_20;
  }

  CFRetain(MutableWithSubstring);
  return (CFAttributedStringRef)MutableWithSubstring;
}

uint64_t _CFAttributedStringCreateWithRuns( const __CFAllocator *a1, const __CFString *a2, const __CFDictionary **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a5;
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x3EuLL, 16LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    *(void *)(Instance + 16) = CFStringCreateCopy(a1, a2);
    *(void *)(Instance + 24) = CFRunArrayCreate(a1, v14, v15, v16, v17, v18, v19, v20);
    CFIndex Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      uint64_t v22 = Length;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( a1,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0LL, v22, Mutable);
      CFRelease(Mutable);
    }

    if (v8 >= 1)
    {
      int v24 = (uint64_t *)(a4 + 8);
      do
      {
        BOOL v25 = *a3++;
        CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(a1, v25);
        CFRunArrayReplace(*(void **)(Instance + 24), *(v24 - 1), *v24, AttributesDictionary, *v24);
        CFRelease(AttributesDictionary);
        v24 += 2;
        --v8;
      }

      while (v8);
    }

    CFRange v27 = (unint64_t *)(Instance + 8);
    unint64_t v28 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      unint64_t v29 = __ldaxr(v27);
      if (v29 != v28) {
        break;
      }
      if (__stlxr(v28 | 1, v27)) {
        goto LABEL_12;
      }
      int v30 = 1;
LABEL_13:
      unint64_t v28 = v29;
      if (v30) {
        return Instance;
      }
    }

    __clrex();
LABEL_12:
    int v30 = 0;
    goto LABEL_13;
  }

  return Instance;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy( CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  CFIndex Length = CFStringGetLength(*((CFStringRef *)aStr + 2));
  return __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, 0LL, Length);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  else {
    return (CFStringRef)*((void *)aStr + 2);
  }
}

CFTypeRef CFAttributedStringGetAttribute( CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr)) {
    return (CFTypeRef)-[__CFAttributedString attribute:atIndex:effectiveRange:]( aStr,  "attribute:atIndex:effectiveRange:",  attrName,  loc,  effectiveRange);
  }
  ValueAtIndex = (const __CFDictionary *)CFRunArrayGetValueAtIndex( *((void *)aStr + 3),  loc,  &effectiveRange->location,  0LL);
  return CFDictionaryGetValue(ValueAtIndex, attrName);
}

CFDictionaryRef CFAttributedStringGetAttributesAndLongestEffectiveRange( CFAttributedStringRef aStr, CFIndex loc, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length = inRange.length;
  CFIndex location = inRange.location;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr)) {
    return (CFDictionaryRef)-[__CFAttributedString attributesAtIndex:longestEffectiveRange:inRange:]( aStr,  "attributesAtIndex:longestEffectiveRange:inRange:",  loc,  longestEffectiveRange,  location,  length);
  }
  CFDictionaryRef Attributes = CFAttributedStringGetAttributes(aStr, loc, longestEffectiveRange);
  if (longestEffectiveRange)
  {
    CFRange v18 = *longestEffectiveRange;
    CFIndex v11 = location + length;
    do
    {
      CFIndex v12 = v18.length + v18.location;
      if (v18.length + v18.location >= v11) {
        break;
      }
      CFDictionaryRef v13 = CFAttributedStringGetAttributes(aStr, v18.length + v18.location, &v18);
    }

    while (CFEqual(v13, Attributes));
    CFRange v18 = *longestEffectiveRange;
    do
    {
      CFIndex v14 = v18.location;
      if (v18.location <= location) {
        break;
      }
      CFDictionaryRef v15 = CFAttributedStringGetAttributes(aStr, v18.location - 1, &v18);
    }

    while (CFEqual(v15, Attributes));
    if (v14 <= location) {
      CFIndex v16 = location;
    }
    else {
      CFIndex v16 = v14;
    }
    if (v11 >= v12) {
      CFIndex v17 = v12;
    }
    else {
      CFIndex v17 = v11;
    }
    longestEffectiveRange->CFIndex location = v16;
    longestEffectiveRange->CFIndex length = v17 - v16;
  }

  return Attributes;
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange( CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length = inRange.length;
  CFIndex location = inRange.location;
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr)) {
    return (CFTypeRef)-[__CFAttributedString attribute:atIndex:longestEffectiveRange:inRange:]( aStr,  "attribute:atIndex:longestEffectiveRange:inRange:",  attrName,  loc,  longestEffectiveRange,  location,  length);
  }
  CFTypeRef Attribute = CFAttributedStringGetAttribute(aStr, loc, attrName, longestEffectiveRange);
  if (longestEffectiveRange)
  {
    CFRange v20 = *longestEffectiveRange;
    CFIndex v13 = location + length;
    do
    {
      CFIndex v14 = v20.length + v20.location;
      if (v20.length + v20.location >= v13) {
        break;
      }
      CFTypeRef v15 = CFAttributedStringGetAttribute(aStr, v20.length + v20.location, attrName, &v20);
    }

    while (v15 == Attribute || v15 && Attribute && CFEqual(v15, Attribute));
    CFRange v20 = *longestEffectiveRange;
    do
    {
      CFIndex v16 = v20.location;
      if (v20.location <= location) {
        break;
      }
      CFTypeRef v17 = CFAttributedStringGetAttribute(aStr, v20.location - 1, attrName, &v20);
    }

    while (v17 == Attribute || v17 && Attribute && CFEqual(v17, Attribute));
    if (v16 <= location) {
      CFIndex v18 = location;
    }
    else {
      CFIndex v18 = v16;
    }
    if (v13 >= v14) {
      CFIndex v19 = v14;
    }
    else {
      CFIndex v19 = v13;
    }
    longestEffectiveRange->CFIndex location = v18;
    longestEffectiveRange->CFIndex length = v19 - v18;
  }

  return Attribute;
}

uint64_t _CFAttributedStringGetNumberOfRuns(const __CFAttributedString *a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFAttributedStringGetLength(a1);
  if (Length < 1) {
    return 0LL;
  }
  CFIndex v5 = Length;
  uint64_t v6 = 0LL;
  CFIndex v7 = 0LL;
  do
  {
    v13.CFIndex location = v7;
    v13.CFIndex length = v5;
    AttributesAndLongestEffectiveRange = CFAttributedStringGetAttributesAndLongestEffectiveRange( a1,  v7,  v13,  &longestEffectiveRange);
    if (a2 || CFDictionaryGetCount(AttributesAndLongestEffectiveRange) >= 1) {
      ++v6;
    }
    v7 += longestEffectiveRange.length;
    BOOL v9 = v5 <= longestEffectiveRange.length;
    v5 -= longestEffectiveRange.length;
  }

  while (!v9);
  return v6;
}

uint64_t _CFAttributedStringGetRuns(const __CFAttributedString *a1, int a2, uint64_t *a3, CFRange *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t result = CFAttributedStringGetLength(a1);
  if (result >= 1)
  {
    CFIndex v9 = result;
    CFIndex v10 = 0LL;
    do
    {
      v15.CFIndex location = v10;
      v15.CFIndex length = v9;
      uint64_t result = (uint64_t)CFAttributedStringGetAttributesAndLongestEffectiveRange(a1, v10, v15, &longestEffectiveRange);
      uint64_t v11 = result;
      if (a2 || (uint64_t result = CFDictionaryGetCount((CFDictionaryRef)result), result >= 1))
      {
        if (a3) {
          *a3++ = v11;
        }
        if (a4) {
          *a4++ = longestEffectiveRange;
        }
      }

      v10 += longestEffectiveRange.length;
      BOOL v12 = v9 <= longestEffectiveRange.length;
      v9 -= longestEffectiveRange.length;
    }

    while (!v12);
  }

  return result;
}

CFMutableStringRef CFAttributedStringGetMutableString(CFMutableAttributedStringRef aStr)
{
  else {
    return 0LL;
  }
}

void CFAttributedStringSetAttribute( CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString addAttribute:value:range:]( aStr,  "addAttribute:value:range:",  attrName,  value,  location,  length);
    return;
  }

  if (length)
  {
    while (1)
    {
      ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, &v18, 0LL);
      CFIndex v10 = ValueAtIndex;
      uint64_t v12 = v18;
      uint64_t v11 = v19;
      BOOL v13 = v18 == location && v19 <= length;
      if (!v13) {
        goto LABEL_12;
      }
      if (CFGetRetainCount(ValueAtIndex) != 1) {
        break;
      }
      CFDictionarySetValue(v10, attrName, value);
LABEL_20:
      location += v19;
      length -= v19;
      if (!length) {
        return;
      }
    }

    uint64_t v12 = v18;
    uint64_t v11 = v19;
LABEL_12:
    BOOL v13 = v12 < location;
    uint64_t v14 = v12 - location;
    if (v13)
    {
      v11 += v14;
      CFIndex v18 = location;
      CFIndex v19 = v11;
    }

    if (v11 > length) {
      CFIndex v19 = length;
    }
    CFRange v15 = CFDictionaryGetValue(v10, attrName);
    if (!v15 || !CFEqual(v15, value))
    {
      CFIndex v16 = CFGetAllocator(aStr);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v16, v10);
      CFDictionarySetValue(AttributesDictionary, attrName, value);
      CFRunArrayReplace(*((void **)aStr + 3), v18, v19, AttributesDictionary, v19);
      CFRelease(AttributesDictionary);
    }

    goto LABEL_20;
  }

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString removeAttribute:range:](aStr, "removeAttribute:range:", attrName, location, length);
    return;
  }

  if (length)
  {
    while (1)
    {
      ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((void *)aStr + 3), location, &v15, 0LL);
      uint64_t v8 = ValueAtIndex;
      uint64_t v10 = v15;
      uint64_t v9 = v16;
      BOOL v11 = v15 == location && v16 <= length;
      if (!v11) {
        goto LABEL_12;
      }
      if (CFGetRetainCount(ValueAtIndex) != 1) {
        break;
      }
      CFDictionaryRemoveValue(v8, attrName);
LABEL_19:
      location += v16;
      length -= v16;
      if (!length) {
        return;
      }
    }

    uint64_t v10 = v15;
    uint64_t v9 = v16;
LABEL_12:
    BOOL v11 = v10 < location;
    uint64_t v12 = v10 - location;
    if (v11)
    {
      v9 += v12;
      CFIndex v15 = location;
      CFIndex v16 = v9;
    }

    if (v9 > length) {
      CFIndex v16 = length;
    }
    if (CFDictionaryContainsKey(v8, attrName))
    {
      BOOL v13 = CFGetAllocator(aStr);
      CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v13, v8);
      CFDictionaryRemoveValue(AttributesDictionary, attrName);
      CFRunArrayReplace(*((void **)aStr + 3), v15, v16, AttributesDictionary, v16);
      CFRelease(AttributesDictionary);
    }

    goto LABEL_19;
  }

void CFAttributedStringReplaceAttributedString( CFMutableAttributedStringRef aStr, CFRange range, CFAttributedStringRef replacement)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withAttributedString:]( aStr,  "replaceCharactersInRange:withAttributedString:",  location,  length,  replacement);
  }

  else
  {
    else {
      CFIndex v7 = (const __CFString *)*((void *)replacement + 2);
    }
    CFIndex v8 = CFStringGetLength(v7);
    if (v8 >= 1)
    {
      uint64_t v9 = CFGetAllocator(aStr);
      CFIndex v10 = 0LL;
      effectiveRange.CFIndex location = 0LL;
      effectiveRange.CFIndex length = 0LL;
      do
      {
        CFDictionaryRef Attributes = CFAttributedStringGetAttributes(replacement, v10, &effectiveRange);
        CFMutableDictionaryRef AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v9, Attributes);
        CFRunArrayInsert( *((CFTypeRef *)aStr + 3),  effectiveRange.location + location,  effectiveRange.length,  AttributesDictionary);
        CFRelease(AttributesDictionary);
        CFIndex v10 = effectiveRange.location + effectiveRange.length;
        effectiveRange.CFIndex location = v10;
      }

      while (v10 < v8);
    }

    if (length >= 1) {
      CFRunArrayDelete(*((void **)aStr + 3), v8 + location, length);
    }
    v15.CFIndex location = location;
    v15.CFIndex length = length;
    CFStringReplace(*((CFMutableStringRef *)aStr + 2), v15, v7);
  }

void CFAttributedStringBeginEditing(CFMutableAttributedStringRef aStr)
{
}

void CFAttributedStringEndEditing(CFMutableAttributedStringRef aStr)
{
}

BOOL _CFAttributedStringIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

BOOL __CFAttributedStringMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

CFIndex _CFAttributedStringGetLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 16));
}

uint64_t _CFAttributedStringCheckAndReplace(uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3LL;
  }
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 1) != 0) {
    return 1LL;
  }
  v12.CFIndex location = a2;
  v12.CFIndex length = a3;
  CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, a4);
  return 0LL;
}

uint64_t _CFAttributedStringCheckAndReplaceAttributed( uint64_t a1, CFIndex a2, CFIndex a3, const __CFAttributedString *a4)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3LL;
  }
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 1) != 0) {
    return 1LL;
  }
  v12.CFIndex location = a2;
  v12.CFIndex length = a3;
  if (a4) {
    CFAttributedStringReplaceAttributedString((CFMutableAttributedStringRef)a1, v12, a4);
  }
  else {
    CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, &stru_1899EF170);
  }
  return 0LL;
}

uint64_t _CFAttributedStringCheckAndSetAttributes( uint64_t a1, CFIndex a2, CFIndex a3, const __CFDictionary *a4, Boolean a5)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3LL;
  }
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  if ((v13 & 1) != 0) {
    return 1LL;
  }
  v14.CFIndex location = a2;
  v14.CFIndex length = a3;
  CFAttributedStringSetAttributes((CFMutableAttributedStringRef)a1, v14, a4, a5);
  return 0LL;
}

uint64_t _CFAttributedStringCheckAndSetAttribute( uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4, const void *a5)
{
  CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length) {
    return 3LL;
  }
  char v13 = atomic_load((unint64_t *)(a1 + 8));
  if ((v13 & 1) != 0) {
    return 1LL;
  }
  if (!a4) {
    return 2LL;
  }
  v14.CFIndex location = a2;
  v14.CFIndex length = a3;
  if (a5) {
    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)a1, v14, a4, a5);
  }
  else {
    CFAttributedStringRemoveAttribute((CFMutableAttributedStringRef)a1, v14, a4);
  }
  return 0LL;
}

CFTypeID CFBagGetTypeID(void)
{
  return 4LL;
}

uint64_t __CFBagCreateTransfer(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  v12[10] = *MEMORY[0x1895F89C0];
  v12[6] = (uint64_t)CFHash;
  v12[7] = 0LL;
  v12[0] = (uint64_t)__CFTypeCollectionRetain;
  v12[1] = (uint64_t)__CFTypeCollectionRetain;
  v12[2] = (uint64_t)__CFTypeCollectionRelease;
  v12[3] = (uint64_t)__CFTypeCollectionRelease;
  v12[4] = (uint64_t)CFEqual;
  v12[5] = (uint64_t)CFEqual;
  v12[8] = (uint64_t)CFCopyDescription;
  v12[9] = (uint64_t)CFCopyDescription;
  uint64_t v5 = CFBasicHashCreate(a1, 0x2002u, v12);
  CFBasicHashSuppressRC(v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity(v5, a3);
    do
    {
      unint64_t v6 = *a2++;
      CFBasicHashAddValue(v5, v6, v6);
      --a3;
    }

    while (a3);
  }

  CFBasicHashUnsuppressRC(v5);
  CFIndex v7 = (unint64_t *)(v5 + 8);
  unint64_t v8 = atomic_load((unint64_t *)(v5 + 8));
  do
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        int v10 = 1;
        goto LABEL_10;
      }
    }

    else
    {
      __clrex();
    }

    int v10 = 0;
LABEL_10:
    unint64_t v8 = v9;
  }

  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v5, 4uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v5;
}

CFBagRef CFBagCreate( CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFBagCallBacks *callBacks)
{
  uint64_t Generic = __CFBagCreateGeneric((uint64_t)allocator, (uint64_t)callBacks);
  CFIndex v7 = (unint64_t *)Generic;
  if (!Generic) {
    return (CFBagRef)v7;
  }
  if (numValues >= 1)
  {
    CFBasicHashSetCapacity(Generic, numValues);
    do
    {
      unint64_t v8 = (unint64_t)*values++;
      CFBasicHashAddValue((uint64_t)v7, v8, v8);
      --numValues;
    }

    while (numValues);
  }

  unint64_t v9 = v7 + 1;
  unint64_t v10 = atomic_load(v7 + 1);
  do
  {
    unint64_t v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 | 0x40, v9))
      {
        int v12 = 1;
        goto LABEL_11;
      }
    }

    else
    {
      __clrex();
    }

    int v12 = 0;
LABEL_11:
    unint64_t v10 = v11;
  }

  while (!v12);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v7, 4uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return (CFBagRef)v7;
}

uint64_t __CFBagCreateGeneric(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 16);
    __int128 v4 = *(_OWORD *)(a2 + 32);
    uint64_t v5 = *(void *)(a2 + 24);
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 0LL;
    uint64_t v5 = 0LL;
    __int128 v4 = 0uLL;
  }

  __int128 v8 = v4;
  uint64_t v10 = v5;
  uint64_t v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  uint64_t v9 = 0LL;
  return CFBasicHashCreate(a1, 0x2002u, v7);
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  uint64_t Generic = (objc_class **)__CFBagCreateGeneric((uint64_t)allocator, (uint64_t)callBacks);
  __int128 v4 = (__CFBag *)Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return v4;
}

CFBagRef CFBagCreateCopy(CFAllocatorRef allocator, CFBagRef theBag)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(4uLL, (__objc2_class **)theBag))
  {
    uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);
    if (Count >= 257) {
      uint64_t v11 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    }
    else {
      uint64_t v11 = &v21;
    }
    uint64_t v13 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v13, 0LL, (uint64_t)v11);
    uint64_t Generic = __CFBagCreateGeneric((uint64_t)allocator, (uint64_t)&kCFTypeBagCallBacks);
    uint64_t Copy = Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (uint64_t i = 0LL; i < Count; ++i)
        CFBasicHashAddValue(Copy, *(void *)&v11[8 * i], *(void *)&v11[8 * i]);
    }

    if (Count >= 257) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11);
    }
  }

  else
  {
    uint64_t Copy = CFBasicHashCreateCopy(allocator, (uint64_t)theBag, v4, v5, v6, v7, v8, v9);
  }

  if (Copy)
  {
    CFIndex v16 = (unint64_t *)(Copy + 8);
    unint64_t v17 = atomic_load((unint64_t *)(Copy + 8));
    while (1)
    {
      unint64_t v18 = __ldaxr(v16);
      if (v18 != v17) {
        break;
      }
      if (__stlxr(v17 | 0x40, v16)) {
        goto LABEL_18;
      }
      int v19 = 1;
LABEL_19:
      unint64_t v17 = v18;
      if (v19)
      {
        _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 4uLL);
        if (__CFOASafe) {
          __CFSetLastAllocationEventName();
        }
        return (CFBagRef)Copy;
      }
    }

    __clrex();
LABEL_18:
    int v19 = 0;
    goto LABEL_19;
  }

  return (CFBagRef)Copy;
}

void CFBagGetValues(CFBagRef theBag, const void **values)
{
  uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);
  CFBasicHashGetElements((uint64_t)theBag, Count, 0LL, (uint64_t)values);
}

CFMutableBagRef CFBagCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBagRef theBag)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(4uLL, (__objc2_class **)theBag))
  {
    uint64_t Count = CFBasicHashGetCount((uint64_t)theBag);
    if (Count >= 257) {
      uint64_t v12 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    }
    else {
      uint64_t v12 = &v18;
    }
    uint64_t v14 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v14, 0LL, (uint64_t)v12);
    uint64_t Generic = __CFBagCreateGeneric((uint64_t)allocator, (uint64_t)&kCFTypeBagCallBacks);
    uint64_t Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (uint64_t i = 0LL; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, *(void *)&v12[8 * i], *(void *)&v12[8 * i]);
    }

    if (Count >= 257) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    }
  }

  else
  {
    uint64_t Copy = (objc_class **)CFBasicHashCreateCopy(allocator, (uint64_t)theBag, v5, v6, v7, v8, v9, v10);
  }

  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 4uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return (CFMutableBagRef)Copy;
}

Boolean CFBagContainsValue(CFBagRef theBag, const void *value)
{
  return CFBasicHashGetCountOfKey((uint64_t)theBag, (unint64_t)value) > 0;
}

const void *__cdecl CFBagGetValue(CFBagRef theBag, const void *value)
{
  v3[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)value, v3);
  if (v3[3]) {
    return (const void *)v3[2];
  }
  else {
    return 0LL;
  }
}

Boolean CFBagGetValueIfPresent(CFBagRef theBag, const void *candidate, const void **value)
{
  v5[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)candidate, v5);
  if (!v5[3]) {
    return 0;
  }
  if (value) {
    *value = (const void *)v5[2];
  }
  return 1;
}

void CFBagApplyFunction(CFBagRef theBag, CFBagApplierFunction applier, void *context)
{
  v3[6] = *MEMORY[0x1895F89C0];
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = __CFBagApplyFunction_block_invoke;
  v3[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
  v3[4] = applier;
  uint64_t v3[5] = context;
  CFBasicHashApply((uint64_t)theBag, (uint64_t)v3);
}

uint64_t __CFBagApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a2 + 24); i; --i)
    (*(void (**)(void, void))(a1 + 32))(*(void *)(a2 + 16), *(void *)(a1 + 40));
  return 1LL;
}

uint64_t _CFBagFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  else {
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
  }
}

BOOL _CFBagIsMutable(uint64_t a1)
{
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

void _CFBagSetCapacity(__objc2_class **a1, uint64_t a2)
{
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFBagAddValue(CFMutableBagRef, const void *)");
  }
  CFBasicHashAddValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void CFBagReplaceValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFBagReplaceValue(CFMutableBagRef, const void *)");
  }
  CFBasicHashReplaceValue((unint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void CFBagSetValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFBagSetValue(CFMutableBagRef, const void *)");
  }
  CFBasicHashSetValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void CFBagRemoveValue(CFMutableBagRef theBag, const void *value)
{
  char v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0) {
    CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFBagRemoveValue(CFMutableBagRef, const void *)");
  }
  CFBasicHashRemoveValue((uint64_t)theBag, (unint64_t)value);
}

void CFBagRemoveAllValues(CFMutableBagRef theBag)
{
  char v8 = atomic_load((unint64_t *)theBag + 1);
  if ((v8 & 0x40) != 0) {
    CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v1,  v2,  v3,  v4,  v5,  v6,  (uint64_t)"void CFBagRemoveAllValues(CFMutableBagRef)");
  }
  CFBasicHashRemoveAllValues((uint64_t)theBag);
}

uint64_t __CFAllocatorGetAllocator(uint64_t result)
{
  if (*(void *)(result + 128) != 939LL) {
    return *(void *)(result + 128);
  }
  return result;
}

void __CFAllocatorDeallocate(void *ptr)
{
  uint64_t v2 = (const __CFAllocator *)ptr[16];
  uint64_t v3 = (void (*)(uint64_t))ptr[20];
  if (v2 == (const __CFAllocator *)939)
  {
    uint64_t v4 = (void (*)(void *, uint64_t))ptr[24];
    uint64_t v5 = ptr[18];
    if (v4)
    {
      uint64_t v6 = (void (*)(uint64_t))ptr[20];
      v4(ptr, v5);
      uint64_t v3 = v6;
    }

    if (v3) {
      v3(v5);
    }
  }

  else
  {
    if (v3) {
      v3(ptr[18]);
    }
    CFAllocatorDeallocate(v2, ptr);
  }

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  uint64_t v3 = (malloc_zone_t *)allocator;
  if (!allocator)
  {
    uint64_t v4 = _CFGetTSD(1u);
    if (v4) {
      uint64_t v3 = (malloc_zone_t *)v4;
    }
    else {
      uint64_t v3 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
  }

  if (ptr)
  {
    free = v3[1].free;
    if (free) {
      ((void (*)(void *, void *))free)(ptr, v3[1].reserved1);
    }
  }

CFStringRef __CFAllocatorCopyDescription(uint64_t a1)
{
  uint64_t v1 = *(const __CFAllocator **)(a1 + 128);
  if (v1 == (const __CFAllocator *)939) {
    uint64_t v1 = (const __CFAllocator *)a1;
  }
  return CFStringCreateWithFormat(v1, 0LL, @"<CFAllocator %p [%p]>{info = %p}", a1, v1, *(void *)(a1 + 144));
}

CFTypeID CFAllocatorGetTypeID(void)
{
  return 2LL;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  CFAllocatorRef result = (CFAllocatorRef)_CFGetTSD(1u);
  if (!result) {
    return (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  return result;
}

void CFAllocatorSetDefault(CFAllocatorRef allocator)
{
  CFAllocatorRef v2 = (CFAllocatorRef)_CFGetTSD(1u);
  if (!v2) {
    CFAllocatorRef v2 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  if (allocator)
  {
    if (*(void *)allocator == qword_18C45D2C0 && v2 != allocator)
    {
      CFRelease(v2);
      CFRetain(allocator);
      CFRetain(allocator);
      _CFSetTSD(1u, (uint64_t)allocator, 0LL);
    }
  }

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  uint64_t v3 = (uint64_t)allocator;
  if (allocator && allocator != (CFAllocatorRef)939 && *(void *)allocator != qword_18C45D2C0) {
    return 0LL;
  }
  CFAllocatorAllocateCallBack allocate = context->allocate;
  info = context->info;
  CFAllocatorRetainCallBack retain = context->retain;
  if (retain) {
    info = (void *)((uint64_t (*)(void *))retain)(context->info);
  }
  if (v3)
  {
    if (v3 == 939)
    {
      if (allocate)
      {
        Impl = (char *)((uint64_t (*)(uint64_t, void, void *))allocate)(208LL, 0LL, info);
        if (Impl)
        {
          uint64_t v3 = 939LL;
LABEL_17:
          *(void *)Impl = 0LL;
          *((void *)Impl + 1) = 0LL;
          __CFRuntimeSetRC((uint64_t)Impl, 1u);
          _CFRuntimeSetInstanceTypeID((uint64_t)Impl, 2uLL);
          *(void *)Impl = qword_18C45D2C0;
          *((void *)Impl + 2) = __CFAllocatorCustomSize;
          *((void *)Impl + 3) = __CFAllocatorCustomMalloc;
          *((void *)Impl + 4) = __CFAllocatorCustomCalloc;
          *((void *)Impl + 5) = __CFAllocatorCustomValloc;
          *((void *)Impl + 6) = __CFAllocatorCustomFree;
          *((void *)Impl + 7) = __CFAllocatorCustomRealloc;
          *((void *)Impl + 8) = __CFAllocatorCustomDestroy;
          *((void *)Impl + 9) = "Custom CFAllocator";
          *((void *)Impl + 10) = 0LL;
          *((void *)Impl + 11) = 0LL;
          *((void *)Impl + 12) = __CFAllocatorZoneIntrospect;
          *((_DWORD *)Impl + 26) = 6;
          *((void *)Impl + 14) = 0LL;
          *((void *)Impl + 15) = 0LL;
          CFIndex version = context->version;
          *((void *)Impl + 16) = v3;
          *((void *)Impl + 17) = version;
          *((void *)Impl + 18) = info;
          *((void *)Impl + 19) = retain;
          *((_OWORD *)Impl + 10) = *(_OWORD *)&context->release;
          *((void *)Impl + 22) = allocate;
          *(_OWORD *)(Impl + 184) = *(_OWORD *)&context->reallocate;
          *((void *)Impl + 25) = context->preferredSize;
          return (CFAllocatorRef)Impl;
        }

        return (CFAllocatorRef)Impl;
      }

      return 0LL;
    }
  }

  else
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      uint64_t v3 = v8;
    }
    else {
      uint64_t v3 = (uint64_t)&__kCFAllocatorSystemDefault;
    }
  }

  Impl = (char *)_CFAllocatorAllocateImpl((malloc_zone_t *)v3, 0xD0uLL, 0LL);
  if (Impl)
  {
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
    goto LABEL_17;
  }

  return (CFAllocatorRef)Impl;
}

void *_CFAllocatorAllocateImpl(malloc_zone_t *a1, size_t size, uint64_t a3)
{
  if (a1)
  {
    if (!size) {
      return 0LL;
    }
  }

  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
    if (!size) {
      return 0LL;
    }
  }

  if (a1->reserved1 == (void *)qword_18C45D2C0)
  {
    calloc = a1[1].calloc;
    if (calloc) {
      return (void *)((uint64_t (*)(size_t, uint64_t, void *))calloc)(size, a3, a1[1].reserved1);
    }
    return 0LL;
  }

  return malloc_zone_malloc(a1, size);
}

void *CFAllocatorReallocateImpl(malloc_zone_t *a1, void *ptr, int64_t size, uint64_t a4)
{
  if (a1)
  {
    if (ptr) {
      goto LABEL_11;
    }
  }

  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    }
    if (ptr) {
      goto LABEL_11;
    }
  }

  if (size >= 1)
  {
    calloc = a1[1].calloc;
    if (calloc) {
      return (void *)((uint64_t (*)(int64_t, uint64_t, void *))calloc)(size, a4, a1[1].reserved1);
    }
    return 0LL;
  }

LABEL_11:
  if (ptr && !size)
  {
    if (a1->reserved1 == (void *)qword_18C45D2C0)
    {
      free = a1[1].free;
      if (free) {
        ((void (*)(void *, void *))free)(ptr, a1[1].reserved1);
      }
    }

    else
    {
      malloc_zone_free(a1, ptr);
    }

    return 0LL;
  }

  if (!ptr && !size) {
    return 0LL;
  }
  if (a1->reserved1 == (void *)qword_18C45D2C0)
  {
    valloc = a1[1].valloc;
    if (valloc) {
      return (void *)((uint64_t (*)(void *, int64_t, uint64_t, void *))valloc)( ptr,  size,  a4,  a1[1].reserved1);
    }
    return 0LL;
  }

  return malloc_zone_realloc(a1, ptr, size);
}

  uint64_t v4 = 0LL;
  if (v7) {
LABEL_17:
  }
    CFRelease(v7);
  if (v8) {
    CFRelease(v8);
  }
  return v4;
}

  uint64_t v12 = _CFBundleCopyResourcesDirectoryURLInDirectory(a1, v18);
  uint64_t v13 = (const __CFArray *)_CFBundleCopyLProjDirectoriesForURL((uint64_t)&__kCFAllocatorSystemDefault, v12);
  CFRelease(v12);
  if (v10 && v13)
  {
    Mutableuint64_t Copy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (CFArrayRef)v10);
    v21.CFIndex length = CFArrayGetCount(v13);
    v21.CFIndex location = 0LL;
    CFArrayAppendArray(MutableCopy, v13, v21);
    CFRelease(v13);
    uint64_t v13 = MutableCopy;
LABEL_16:
    CFRelease(v10);
    goto LABEL_17;
  }

  if (v10)
  {
    uint64_t v13 = (const __CFArray *)CFRetain(v10);
    goto LABEL_16;
  }

  if (!v13) {
    uint64_t v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
LABEL_17:
  CFRange v15 = (const __CFArray *)_CFBundleCopyUserLanguages();
  CFIndex v16 = _CFBundleCopyPreferredLanguagesInList(v13, v7, v15, 1, (unint64_t)a1, 0LL);
  if (v15) {
    CFRelease(v15);
  }
  CFRelease(v13);
  if (v7)
  {
    v20.CFIndex length = CFArrayGetCount(v16);
    v20.CFIndex location = 0LL;
    if (CFArrayGetFirstIndexOfValue(v16, v20, v7) < 0) {
      CFArrayAppendValue(v16, v7);
    }
  }

  if (!CFArrayGetCount(v16)) {
    CFArrayAppendValue(v16, @"en");
  }
  if (v5) {
    CFRelease(v5);
  }
  if (a2) {
    *a2 = v18;
  }
  return v16;
}

    uint64_t v8 = MacSymbol_from_uni;
    uint64_t v9 = (const __int16 *)&unk_180CA4588;
    while (1)
    {
      char v10 = ((char *)v9 - (char *)v8) >> 3;
      uint64_t v11 = &v8[2 * v10];
      uint64_t v12 = *(unsigned __int16 *)v11;
      if (v12 <= v4)
      {
        if (v12 >= v4)
        {
          LOBYTE(v4) = v8[2 * v10 + 1];
          goto LABEL_2;
        }

        uint64_t v8 = v11 + 2;
      }

      else
      {
        uint64_t v9 = v11 - 2;
      }

      if (v8 > v9) {
        return 0LL;
      }
    }
  }

  if (v4 == 8482)
  {
    if (v6 == 63615)
    {
      uint64_t v7 = -28;
      goto LABEL_23;
    }

    goto LABEL_11;
  }

  if (v4 != 174) {
    goto LABEL_10;
  }
  if (v6 != 63615) {
    goto LABEL_11;
  }
  uint64_t v7 = -30;
LABEL_23:
  *a4 = v7;
  return 2LL;
}

    uint64_t v22 = 0;
    unint64_t v23 = 0;
    int v24 = 0;
    goto LABEL_114;
  }

  char v18 = (unsigned int *)malloc(0x1000uLL);
  if (!v18) {
    goto LABEL_11;
  }
  uint64_t v19 = v18;
  if (read(a1, v18, 0x1000uLL) <= 4095)
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    int v24 = 0;
    goto LABEL_113;
  }

  uint64_t v20 = v19;
LABEL_12:
  v78 = a5;
  v81 = v20;
  if (!a6)
  {
    CFRange v27 = v20[4];
    if (a5)
    {
      CFRange v27 = bswap32(v27);
      unint64_t v28 = bswap32(v20[5]);
    }

    else
    {
      unint64_t v28 = v20[5];
    }

    uint64_t v45 = v28 + 28LL;
    uint64_t v46 = v28 > 0xFE4;
    uint64_t v47 = 4096LL;
    if (!v46) {
      uint64_t v47 = v45;
    }
    v80 = v47;
    if (v27) {
      uint64_t v48 = v47 >= 0x1D;
    }
    else {
      uint64_t v48 = 0;
    }
    if (!v48)
    {
      int v24 = 0;
      goto LABEL_106;
    }

    v73 = a1;
    v74 = 0;
    v69 = a4;
    v67 = a3;
    uint64_t v68 = v17;
    unint64_t v66 = a2;
    v70 = v19;
    v71 = a7;
    v72 = a8;
    LODWORD(v75) = 0;
    v49 = 0;
    int v24 = 0;
    v50 = (int *)(v20 + 7);
    char v51 = 28LL;
    v77 = v27;
    while (1)
    {
      v52 = *v50;
      if (a5) {
        break;
      }
      if (v52 == 1)
      {
        v53 = v50[12];
        if (!v53) {
          goto LABEL_87;
        }
        goto LABEL_73;
      }

      v61 = v50[1];
LABEL_90:
      if (++v49 < v27)
      {
        v51 += v61;
        v50 = (int *)((char *)v20 + v51);
        if (v51 >= 0x1C && v51 < v80) {
          continue;
        }
      }

      goto LABEL_98;
    }

    if (v52 == 0x1000000)
    {
      v53 = bswap32(v50[12]);
      if (!v53)
      {
LABEL_87:
        size_t v60 = 0;
        uint64_t v62 = 0;
        v61 = v50[1];
        CFRange v27 = v77;
        a5 = v78;
        if (!v78) {
          goto LABEL_89;
        }
        goto LABEL_88;
      }

  uint64_t v8 = *((_WORD *)a2 + 17);
  uint64_t v9 = "isSigned";
  if ((v8 & 0x100) == 0) {
    uint64_t v9 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7E00) == 0 || (v8 & 0x100) == 0) {
    uint64_t v11 = "";
  }
  else {
    uint64_t v11 = ", ";
  }
  uint64_t v12 = "isFloat";
  if ((*((_WORD *)a2 + 17) & 0x200) == 0) {
    uint64_t v12 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7C00) == 0 || (v8 & 0x200) == 0) {
    uint64_t v14 = "";
  }
  else {
    uint64_t v14 = ", ";
  }
  CFRange v15 = "isStruct";
  if ((*((_WORD *)a2 + 17) & 0x400) == 0) {
    CFRange v15 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7800) == 0 || (v8 & 0x400) == 0) {
    unint64_t v17 = "";
  }
  else {
    unint64_t v17 = ", ";
  }
  char v18 = "isArray";
  if ((*((_WORD *)a2 + 17) & 0x800) == 0) {
    char v18 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x7000) == 0 || (v8 & 0x800) == 0) {
    uint64_t v20 = "";
  }
  else {
    uint64_t v20 = ", ";
  }
  char v21 = "isPointer";
  if ((*((_WORD *)a2 + 17) & 0x1000) == 0) {
    char v21 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x6000) == 0 || (v8 & 0x1000) == 0) {
    unint64_t v23 = "";
  }
  else {
    unint64_t v23 = ", ";
  }
  if (v8 < 0) {
    int v24 = "isObject, isBlock";
  }
  else {
    int v24 = "isObject";
  }
  if ((*((_WORD *)a2 + 17) & 0x2000) == 0) {
    int v24 = "";
  }
  if ((v8 & 0x6000) == 0x6000) {
    BOOL v25 = ", ";
  }
  else {
    BOOL v25 = "";
  }
  if ((*((_WORD *)a2 + 17) & 0x4000) != 0) {
    CFRange v26 = "isCString";
  }
  else {
    CFRange v26 = "";
  }
  CFStringAppendFormat( a1,  0LL,  @"flags {%s%s%s%s%s%s%s%s%s%s%s%s%s}\n",  v9,  v11,  v12,  v14,  v15,  v17,  v18,  v20,  v21,  v23,  v24,  v25,  v26);
  CFRange v27 = "out";
  unint64_t v28 = *((unsigned __int16 *)a2 + 17);
  if ((v28 & 2) == 0) {
    CFRange v27 = 0LL;
  }
  if ((v28 & 1) != 0) {
    CFRange v27 = "in";
  }
  if ((~v28 & 3) != 0) {
    unint64_t v29 = v27;
  }
  else {
    unint64_t v29 = "inout";
  }
  if (a3)
  {
    int v30 = a3;
    do
    {
      CFStringAppendFormat(a1, 0LL, @"    ");
      --v30;
    }

    while (v30);
    unint64_t v28 = *((unsigned __int16 *)a2 + 17);
  }

  if (v29) {
    CFAllocatorRef v31 = v29;
  }
  else {
    CFAllocatorRef v31 = "";
  }
  if (v29)
  {
    uint64_t v32 = ", ";
    if ((v28 & 0x1C) == 0 && (v28 & 0x20) == 0) {
      uint64_t v32 = "";
    }
  }

  else
  {
    uint64_t v32 = "";
  }

  uint64_t v33 = "bycopy";
  if ((v28 & 4) == 0) {
    uint64_t v33 = "";
  }
  uint64_t v34 = "";
  if ((v28 & 4) != 0)
  {
    uint64_t v34 = ", ";
    if ((v28 & 0x18) == 0 && (v28 & 0x20) == 0) {
      uint64_t v34 = "";
    }
  }

  v35 = "byref";
  if ((v28 & 8) != 0)
  {
    char v36 = ", ";
    if ((v28 & 0x10) != 0)
    {
LABEL_97:
      unint64_t v37 = "const";
      goto LABEL_98;
    }

    if ((v28 & 0x20) == 0) {
      char v36 = "";
    }
  }

  else
  {
    v35 = "";
    char v36 = "";
    if ((v28 & 0x10) != 0) {
      goto LABEL_97;
    }
  }

  unint64_t v37 = "";
LABEL_98:
  if ((~v28 & 0x30) != 0) {
    BOOL v38 = "";
  }
  else {
    BOOL v38 = ", ";
  }
  if ((v28 & 0x20) != 0) {
    uint64_t v39 = "oneway";
  }
  else {
    uint64_t v39 = "";
  }
  CFStringAppendFormat(a1, 0LL, @"modifiers {%s%s%s%s%s%s%s%s%s}\n", v31, v32, v33, v34, v35, v36, v37, v38, v39);
  if (a3)
  {
    uint64_t v40 = a3;
    do
    {
      CFStringAppendFormat(a1, 0LL, @"    ");
      --v40;
    }

    while (v40);
  }

  CFStringAppendFormat( a1,  0LL,  @"frame {offset = %d, offset adjust = %d, size = %d, size adjust = %d}\n",  *((unsigned int *)a2 + 7),  *((unsigned __int8 *)a2 + 32),  *((unsigned int *)a2 + 6),  *((char *)a2 + 33));
  if (a3)
  {
    uint64_t v41 = a3;
    do
    {
      CFStringAppendFormat(a1, 0LL, @"    ");
      --v41;
    }

    while (v41);
  }

  CFStringAppendFormat( a1,  0LL,  @"memory {offset = %d, size = %d}\n",  *((unsigned int *)a2 + 5),  *((unsigned int *)a2 + 4));
LABEL_112:
  uint64_t v42 = *a2;
  if (v42)
  {
    uint64_t v43 = a3 + 1;
    do
    {
      __NSMS7(a1, v42, v43);
      uint64_t v42 = *(void *)(v42 + 8);
    }

    while (v42);
  }

  if (v11)
  {
    unint64_t v17 = v11;
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)&v25[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    char v18 = _os_log_pack_fill();
    uint64_t v19 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v18,  (uint64_t)"-[NSMutableArray sortUsingFunction:context:range:]",  location,  length,  --v17);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v19,  "-[NSMutableArray sortUsingFunction:context:range:]",  location,  length,  v17);
  }

  else
  {
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)&v25[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFRange v15 = _os_log_pack_fill();
    CFIndex v16 = __os_log_helper_1_2_3_8_32_8_0_8_0( v15,  (uint64_t)"-[NSMutableArray sortUsingFunction:context:range:]",  location,  length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v16,  "-[NSMutableArray sortUsingFunction:context:range:]",  location,  length);
  }

  uint64_t v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v14,  v13);
  objc_exception_throw(v20);
  __50__NSMutableArray_sortUsingFunction_context_range___block_invoke(v21, v22, v23);
}

    char v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"<%p>", a2[1]);
    goto LABEL_12;
  }

  uint64_t v6 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"<%p>", a2[2]);
  if ((*(_WORD *)(*(void *)(a1 + 32) + 18LL) & 4) != 0) {
    goto LABEL_11;
  }
LABEL_8:
  uint64_t v8 = 0LL;
LABEL_13:
  uint64_t v11 = *(__CFString **)(a1 + 40);
  uint64_t v12 = *(_WORD *)(*(void *)(a1 + 32) + 18LL);
  uint64_t v13 = *(void *)(a1 + 48);
  uint64_t v14 = *a2;
  if ((v12 & 4) != 0 && (v12 & 0x18) != 0)
  {
    CFStringAppendFormat(v11, 0LL, @"%@%ld : %@ = %@ (%ld)\n", v13, v14, v8, v6, a2[3]);
  }

  else if ((v12 & 4) != 0)
  {
    CFStringAppendFormat(v11, 0LL, @"%@%ld : %@ = %@\n", v13, v14, v8, v6);
  }

  else if ((v12 & 0x18) != 0)
  {
    CFStringAppendFormat(v11, 0LL, @"%@%ld : %@ (%ld)\n", v13, v14, v6, a2[3]);
  }

  else
  {
    CFStringAppendFormat(v11, 0LL, @"%@%ld : %@\n", v13, *a2, v6);
  }

  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  return 1LL;
}

  -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:]( *(os_unfair_lock_s **)(a1 + 32),  a3,  a2,  a4,  1,  (uint64_t)v14,  v11,  0LL);
  CFIndex v16 = *(void **)(a1 + 32);
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  v21[2] = __89___CFXPreferences_setValuesForKeys_removingValuesForKeys_identifier_user_host_container___block_invoke_3;
  v21[3] = &unk_1899EE2A0;
  v21[4] = v16;
  v21[5] = a3;
  v21[6] = a2;
  v21[7] = a4;
  v21[8] = v14;
  v21[9] = v11;
  [v16 transitionIntoDirectModeIfNeededWithRetryBlock:v21];
  free(v15);
}

void *CFAllocatorAllocateTyped(malloc_zone_t *a1, size_t a2, uint64_t a3, uint64_t a4)
{
  return _CFAllocatorAllocateImpl(a1, a2, a4);
}

void *CFAllocatorReallocateTyped(malloc_zone_t *a1, void *a2, int64_t a3, uint64_t a4, uint64_t a5)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, a5);
}

CFIndex CFAllocatorGetPreferredSizeForSize(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  if (!allocator)
  {
    allocator = (CFAllocatorRef)_CFGetTSD(1u);
    if (!allocator) {
      allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  if (*(void *)allocator != qword_18C45D2C0) {
    return malloc_good_size(size);
  }
  uint64_t v5 = 0LL;
  if (size >= 1)
  {
    uint64_t v6 = (uint64_t (*)(CFIndex, CFOptionFlags, void))*((void *)allocator + 25);
    if (v6) {
      uint64_t v5 = v6(size, hint, *((void *)allocator + 18));
    }
  }

  if (v5 <= size) {
    return size;
  }
  else {
    return v5;
  }
}

void CFAllocatorGetContext(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  CFAllocatorRef v3 = allocator;
  if (!allocator)
  {
    uint64_t v4 = _CFGetTSD(1u);
    if (v4) {
      CFAllocatorRef v3 = (CFAllocatorRef)v4;
    }
    else {
      CFAllocatorRef v3 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  if (*(void *)v3 == qword_18C45D2C0)
  {
    context->CFIndex version = 0LL;
    uint64_t v5 = (malloc_zone_t *)*((void *)v3 + 18);
    if (v5 == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
      uint64_t v5 = malloc_default_zone();
    }
    context->info = v5;
    *(_OWORD *)&context->CFAllocatorRetainCallBack retain = *(_OWORD *)((char *)v3 + 152);
    *(_OWORD *)&context->copyDescription = *(_OWORD *)((char *)v3 + 168);
    *(_OWORD *)&context->reCFAllocatorAllocateCallBack allocate = *(_OWORD *)((char *)v3 + 184);
    context->preferredSize = (CFAllocatorPreferredSizeCallBack)*((void *)v3 + 25);
  }

uint64_t _CFGetOutOfMemoryErrorCallBack()
{
  return 0LL;
}

void *__CFSafelyReallocate(void *a1, size_t a2, uint64_t a3)
{
  uint64_t v6 = realloc(a1, a2);
  if (!v6) {
    __CFReallocationFailed((uint64_t)a1, a2, a3);
  }
  return v6;
}

void *__CFSafelyReallocateWithAllocator( malloc_zone_t *a1, void *a2, int64_t a3, uint64_t a4, uint64_t a5)
{
  CFAllocatorRef result = CFAllocatorReallocateImpl(a1, a2, a3, a4);
  if (!result && (a2 || a3))
  {
    __CFReallocationFailed((uint64_t)a2, a3, a5);
    return 0LL;
  }

  return result;
}

BOOL __CFAllocatorRespectsHintZeroWhenAllocating(__objc2_class **a1)
{
  return a1 == &__kCFAllocatorSystemDefault || a1 == &__kCFAllocatorMallocZone;
}

CFTypeRef __CFNullCopyFormattingDescription()
{
  return CFRetain(@"null");
}

CFStringRef __CFNullCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"<CFNull %p [%p]>", a1, v2);
}

CFTypeID CFNullGetTypeID(void)
{
  return 16LL;
}

uint64_t __CFAllocatorCustomSize()
{
  return 0LL;
}

void *__CFAllocatorCustomMalloc(malloc_zone_t *a1, size_t a2)
{
  return _CFAllocatorAllocateImpl(a1, a2, 0LL);
}

void *__CFAllocatorCustomCalloc(malloc_zone_t *a1, int a2, size_t size)
{
  Impl = _CFAllocatorAllocateImpl(a1, size, 0LL);
  uint64_t v5 = Impl;
  if (Impl) {
    bzero(Impl, size);
  }
  return v5;
}

unint64_t __CFAllocatorCustomValloc(malloc_zone_t *a1, unint64_t a2)
{
  CFAllocatorRef v2 = (void *)MEMORY[0x1895FD590];
  if (~(2LL * *MEMORY[0x1895FD590]) <= a2) {
    return 0LL;
  }
  else {
    return ((unint64_t)_CFAllocatorAllocateImpl(a1, *MEMORY[0x1895FD590] + a2, 0LL) + *v2 - 1) & -*v2;
  }
}

void *__CFAllocatorCustomRealloc(malloc_zone_t *a1, void *a2, int64_t a3)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, 0LL);
}

void *__CFAllocatorSystemAllocate(size_t size, uint64_t a2, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }
  if (a2 == 1) {
    return malloc_zone_calloc(zone, 1uLL, size);
  }
  else {
    return malloc_zone_malloc(zone, size);
  }
}

void *__CFAllocatorSystemReallocate(void *ptr, size_t size, int a3, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }
  return malloc_zone_realloc(zone, ptr, size);
}

void __CFAllocatorSystemDeallocate(void *ptr, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder) {
    zone = malloc_default_zone();
  }
  malloc_zone_free(zone, ptr);
}

uint64_t __CFAllocatorZoneIntrospectNoOp()
{
  return 0LL;
}

CFIndex __CFAllocatorCustomGoodSize(const __CFAllocator *a1, CFIndex a2)
{
  return CFAllocatorGetPreferredSizeForSize(a1, a2, 0LL);
}

uint64_t __CFAllocatorZoneIntrospectTrue()
{
  return 1LL;
}

uint64_t __CFAllocatorNullSize()
{
  return 0LL;
}

uint64_t __CFAllocatorNullMalloc()
{
  return 0LL;
}

uint64_t __CFAllocatorNullCalloc()
{
  return 0LL;
}

uint64_t __CFAllocatorNullValloc()
{
  return 0LL;
}

uint64_t __CFAllocatorNullRealloc()
{
  return 0LL;
}

uint64_t __CFAllocatorNullAllocate()
{
  return 0LL;
}

uint64_t __CFAllocatorNullReallocate()
{
  return 0LL;
}

uint64_t __CFAllocatorNullGoodSize(uint64_t a1, uint64_t a2)
{
  return a2;
}

double __os_log_helper_1_2_3_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)&double result = 136315650LL;
  *(_DWORD *)a1 = 136315650;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  return result;
}

double __os_log_helper_1_2_4_8_32_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&double result = 136315906LL;
  *(_DWORD *)a1 = 136315906;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(void *)(a1 + 34) = a5;
  return result;
}

uint64_t __NSOrderedSetI_new(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = 1LL;
  uint64_t v6 = 2LL;
  uint64_t v7 = 4LL;
  if (a2 < 0xFFFFFFFF)
  {
    int v8 = 2;
  }

  else
  {
    uint64_t v7 = 8LL;
    int v8 = 8;
  }

  if (a2 >= 0xFFFF) {
    int v9 = v8;
  }
  else {
    int v9 = 1;
  }
  if (a2 >= 0xFFFF) {
    uint64_t v6 = v7;
  }
  if (a2 >= 0xFF) {
    int v10 = v9;
  }
  else {
    int v10 = 0;
  }
  if (a2 >= 0xFF) {
    uint64_t v5 = v6;
  }
  while (__NSOrderedSetCapacities[v4] < a2)
  {
    if (++v4 == 64)
    {
      __break(1u);
      break;
    }
  }

  if (!a2)
  {
    unint64_t v28 = (objc_class *)objc_opt_self();
    uint64_t v27 = __CFAllocateObject(v28, 0LL);
    *(_BYTE *)(v27 + 14) = 0;
    *(_WORD *)(v27 + 12) = 0;
    *(_DWORD *)(v27 + 8) = 0;
    *(_BYTE *)(v27 + 15) &= 3u;
    *(_BYTE *)(v27 + 15) &= 0xFCu;
    return v27;
  }

  unint64_t v11 = __NSOrderedSetSizes[v4];
  size_t v30 = v11 * v5;
  uint64_t v12 = (char *)calloc(1uLL, v11 * v5 + 8 * a2);
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v34 = &v12[8 * a2];
  __src = v12;
  if (v11 <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = v11;
  }
  uint64_t v31 = v15;
LABEL_22:
  CFIndex v16 = *(void **)(a1 + 8 * v13);
  unint64_t v17 = objc_msgSend(v16, "hash", v30);
  unint64_t v18 = v11;
  if (!v4) {
    goto LABEL_24;
  }
  unint64_t v18 = v11;
  if (v4 == 63) {
    goto LABEL_24;
  }
  unint64_t v18 = v17 % v11;
  uint64_t v21 = v31;
  unint64_t v22 = v17 % v11;
  while (2)
  {
    switch(v10)
    {
      case 0:
        uint64_t v23 = v34[v22];
        if (!v34[v22]) {
          goto LABEL_50;
        }
        goto LABEL_38;
      case 1:
        uint64_t v23 = *(unsigned __int16 *)&v34[2 * v22];
        if (!*(_WORD *)&v34[2 * v22]) {
          goto LABEL_50;
        }
        goto LABEL_38;
      case 2:
        uint64_t v23 = *(unsigned int *)&v34[4 * v22];
        if (!*(_DWORD *)&v34[4 * v22]) {
          goto LABEL_50;
        }
        goto LABEL_38;
      case 8:
        uint64_t v23 = *(void *)&v34[8 * v22];
        if (v23)
        {
LABEL_38:
          int v24 = (void *)__src[v23 - 1];
          if (v24 == v16 || ([v24 isEqual:v16] & 1) != 0) {
            goto LABEL_48;
          }
          if (v22 + 1 >= v11) {
            unint64_t v25 = v11;
          }
          else {
            unint64_t v25 = 0LL;
          }
          unint64_t v22 = v22 + 1 - v25;
          if (!--v21)
          {
            unint64_t v18 = v11;
            goto LABEL_24;
          }

          continue;
        }

LABEL_50:
        unint64_t v18 = v22;
LABEL_24:
        uint64_t v19 = *(void *)(a1 + 8 * v13);
        __src[v14] = v19;
        if ((a3 & 1) == 0 && v19 >= 1) {
          id v20 = (id)v19;
        }
        ++v14;
        switch(v10)
        {
          case 0:
            v34[v18] = v14;
            break;
          case 1:
            *(_WORD *)&v34[2 * v18] = v14;
            break;
          case 2:
            *(_DWORD *)&v34[4 * v18] = v14;
            break;
          case 8:
            *(void *)&v34[8 * v18] = v14;
            break;
          default:
            break;
        }

        if (&v14[-v16] == p_buffer) {
          uint64_t v21 = 45;
        }
        else {
          uint64_t v21 = 0;
        }
        *j = v21;
        j = v14;
        break;
      }

      ++p_buffer;
    }

    *j = 0;
  }

  _AppendKeyValueString((uint64_t)&buffer, v25);
  _AppendKeyValueString((uint64_t)&buffer, v26);
  return CFStringCreateWithCString(allocator, (const char *)&buffer, 0x600u);
}

    *(void *)(a5 + 24) = v12;
    uint64_t v31 = *(void **)a5;
    uint64_t v33 = (unint64_t)v12 > 0x3F0 || v31 != 0LL;
    *(_BYTE *)(a5 + 9) = v33;
    if (!v31)
    {
      if ((unint64_t)v12 > 0x3F0)
      {
        uint64_t v31 = CFAllocatorAllocate(v16, v12, 0LL);
        *(void *)a5 = v31;
        if (!v31) {
          goto LABEL_204;
        }
        goto LABEL_211;
      }

      uint64_t v31 = (void *)(a5 + 32);
    }

    *(void *)a5 = v31;
LABEL_211:
    v71 = v31;
    goto LABEL_284;
  }

  if ((int)a3 <= 402653439)
  {
    if ((_DWORD)a3 == 268435712 || (_DWORD)a3 == 335544576)
    {
LABEL_24:
      unint64_t v22 = (unsigned __int16 *)&a1[v12 & 0xFFFFFFFFFFFFFFFELL];
      if ((_DWORD)a3 == 268435712) {
        goto LABEL_66;
      }
      if ((_DWORD)a3 != 256)
      {
        char v36 = v12 & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v37 = (uint64_t)(v12 & 0xFFFFFFFFFFFFFFFELL) >> 1;
        const char *v14 = v37;
        if (a6)
        {
          double result = 1LL;
          *a6 = 1;
          *(void *)a5 = a1;
          *(_BYTE *)(a5 + 8) = 0;
          return result;
        }

        int v24 = 0;
        goto LABEL_68;
      }

      uint64_t v23 = *(unsigned __int16 *)a1;
      if (v23 == 65534 || v23 == 65279)
      {
        a1 += 2;
        int v24 = v23 != 65279;
      }

      else
      {
LABEL_66:
        int v24 = 1;
      }

      char v36 = (char *)v22 - a1;
      unint64_t v37 = ((char *)v22 - a1) >> 1;
      const char *v14 = v37;
LABEL_68:
      if (*(_BYTE *)(a5 + 8))
      {
        if (v24) {
          BOOL v38 = 33023;
        }
        else {
          BOOL v38 = 65408;
        }
        uint64_t v39 = (unsigned __int16 *)a1;
        do
        {
          if (v39 >= v22)
          {
            uint64_t v47 = *(_BYTE **)a5;
            if (!*(void *)a5)
            {
              if (v37 < 0x3F1)
              {
                uint64_t v47 = (_BYTE *)(a5 + 32);
                *(void *)a5 = a5 + 32;
              }

              else
              {
                uint64_t v48 = CFAllocatorAllocate(v16, v37, 0LL);
                *(void *)a5 = v48;
                if (!v48) {
                  goto LABEL_204;
                }
                uint64_t v47 = v48;
                *(_BYTE *)(a5 + 9) = 1;
              }
            }

            if (v24)
            {
              if (a1 < (char *)v22)
              {
                double result = 1LL;
                do
                {
                  *v47++ = a1[1];
                  a1 += 2;
                }

                while (a1 < (char *)v22);
                return result;
              }
            }

            else if (a1 < (char *)v22)
            {
              double result = 1LL;
              do
              {
                v81 = *a1;
                a1 += 2;
                *v47++ = v81;
              }

              while (a1 < (char *)v22);
              return result;
            }

            return 1LL;
          }

          uint64_t v40 = *v39++;
        }

        while ((v38 & v40) == 0);
        *(_BYTE *)(a5 + 8) = 0;
      }

      uint64_t v41 = *(_WORD **)a5;
      if (!*(void *)a5)
      {
        if (v37 < 0x1F9)
        {
          uint64_t v41 = (_WORD *)(a5 + 32);
          *(void *)a5 = a5 + 32;
        }

        else
        {
          uint64_t v42 = CFAllocatorAllocate(v16, v36, 0LL);
          *(void *)a5 = v42;
          if (!v42) {
            goto LABEL_204;
          }
          uint64_t v41 = v42;
          *(_BYTE *)(a5 + 9) = 1;
        }
      }

      if (v24)
      {
        if (a1 < (char *)v22)
        {
          double result = 1LL;
          do
          {
            v69 = *(unsigned __int16 *)a1;
            a1 += 2;
            *v41++ = bswap32(v69) >> 16;
          }

          while (a1 < (char *)v22);
          return result;
        }

        return 1LL;
      }

      v70 = 2LL * *v14;
      v71 = v41;
      v72 = a1;
LABEL_285:
      memmove(v71, v72, v70);
      return 1LL;
    }

    goto LABEL_60;
  }

  if ((_DWORD)a3 == 402653440) {
    goto LABEL_35;
  }
  unint64_t v25 = 469762304;
LABEL_34:
  if ((_DWORD)a3 == v25)
  {
LABEL_35:
    CFRange v26 = (unsigned int *)&a1[v12 & 0xFFFFFFFFFFFFFFFCLL];
    if ((_DWORD)a3 == 201326848)
    {
      uint64_t v43 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 == -131072 || v43 == 65279)
      {
        a1 += 4;
        uint64_t v27 = (uint64_t)((v12 & 0xFFFFFFFFFFFFFFFCLL) - 4) >> 2;
        const char *v14 = v27;
        if (v43 == 65279) {
          goto LABEL_85;
        }
LABEL_147:
        uint64_t v45 = 0xFFFF;
        uint64_t v44 = 1;
        uint64_t v46 = -2130706433;
        goto LABEL_148;
      }

      uint64_t v27 = v12 >> 2;
    }

    else
    {
      uint64_t v27 = v12 >> 2;
      if ((_DWORD)a3 != 402653440)
      {
        const char *v14 = v27;
LABEL_85:
        uint64_t v44 = 0;
        uint64_t v45 = -65536;
        uint64_t v46 = -128;
LABEL_148:
        uint64_t v62 = v27;
        if (a1 < (char *)v26)
        {
          uint64_t v62 = v27;
          v63 = (unsigned int *)a1;
          do
          {
            uint64_t v64 = *v63;
            if ((*v63 & v46) != 0)
            {
              *(_BYTE *)(a5 + 8) = 0;
              if ((v64 & v45) != 0)
              {
                uint64_t v65 = bswap32(v64);
                if (v44) {
                  uint64_t v64 = v65;
                }
                if (HIWORD(v64) > 0x10u) {
                  return 0LL;
                }
                const char *v14 = ++v62;
              }
            }

            ++v63;
          }

          while (v63 < v26);
        }

        unint64_t v66 = *(_BYTE **)a5;
        if (*(_BYTE *)(a5 + 8))
        {
          if (!v66)
          {
            if (v62 < 0x3F1)
            {
              unint64_t v66 = (_BYTE *)(a5 + 32);
              *(void *)a5 = a5 + 32;
            }

            else
            {
              v67 = CFAllocatorAllocate(v16, v62, 0LL);
              *(void *)a5 = v67;
              if (!v67) {
                goto LABEL_204;
              }
              unint64_t v66 = v67;
              *(_BYTE *)(a5 + 9) = 1;
            }
          }

          if ((v44 & 1) != 0)
          {
            if (a1 < (char *)v26)
            {
              double result = 1LL;
              do
              {
                *v66++ = a1[3];
                a1 += 4;
              }

              while (a1 < (char *)v26);
              return result;
            }
          }

          else if (a1 < (char *)v26)
          {
            double result = 1LL;
            do
            {
              v73 = *(_DWORD *)a1;
              a1 += 4;
              *v66++ = v73;
            }

            while (a1 < (char *)v26);
            return result;
          }

          return 1LL;
        }

        if (!v66)
        {
          if (v62 < 0x1F9)
          {
            unint64_t v66 = (_BYTE *)(a5 + 32);
            *(void *)a5 = a5 + 32;
          }

          else
          {
            uint64_t v68 = CFAllocatorAllocate(v16, 2 * v62, 0LL);
            *(void *)a5 = v68;
            if (!v68) {
              goto LABEL_204;
            }
            unint64_t v66 = v68;
            *(_BYTE *)(a5 + 9) = 1;
          }
        }

        if (v27 >= 1)
        {
          v77 = &a1[4 * v27];
          do
          {
            v79 = *(_DWORD *)a1;
            a1 += 4;
            v78 = v79;
            v80 = bswap32(v79);
            if (v44) {
              v78 = v80;
            }
            if (HIWORD(v78))
            {
              if (HIWORD(v78) > 0x10u) {
                goto LABEL_204;
              }
              *(_WORD *)unint64_t v66 = ((v78 + 67043328) >> 10) - 10240;
              v66 += 2;
              LOWORD(v78) = v78 & 0x3FF | 0xDC00;
            }

            else if ((v78 & 0xF800 | 0x400) == 0xDC00)
            {
              goto LABEL_204;
            }

            *(_WORD *)unint64_t v66 = v78;
            v66 += 2;
          }

          while (a1 < v77);
        }

        goto LABEL_202;
      }
    }

    const char *v14 = v27;
    goto LABEL_147;
  }

    unint64_t v22 = v12++ >= 3;
    if (v22)
    {
      unint64_t v11 = "ole";
      if (v9) {
        goto LABEL_60;
      }
      return v11;
    }
  }

  if (v16 != 26) {
    goto LABEL_50;
  }
  uint64_t v23 = v15 - 1;
  if (v23)
  {
    int v24 = 0LL;
    unint64_t v25 = 0LL;
    do
    {
      CFRange v26 = v10[v13 + (v24 & 0xFFFFFFFE)];
      uint64_t v27 = aWorddocument[v25++];
      v24 += 2LL;
    }

    while (v26 == v27 && v25 < v23);
    if (v26 != v27) {
      goto LABEL_50;
    }
  }

  unint64_t v11 = "doc";
  if (!v9) {
    return v11;
  }
LABEL_60:
  free(v9);
  return v11;
}

  uint64_t v14 = v40;
  if (v40) {
    goto LABEL_51;
  }
  return v19;
}

    uint64_t v31 = (unsigned __int16 *)&unk_180D7BBEA;
    uint64_t v32 = (unsigned __int16 *)&__CFSMPUnicodeOnlyEmojiList;
    double result = -1LL;
    while (1)
    {
      uint64_t v33 = (char *)&v32[((char *)v31 - (char *)v32) >> 2];
      uint64_t v34 = *(unsigned __int16 *)v33;
      if (v34 == v25) {
        break;
      }
      v35 = (unsigned __int16 *)(v33 - 2);
      char v36 = (unsigned __int16 *)(v33 + 2);
      if (v34 > v25) {
        uint64_t v31 = v35;
      }
      else {
        uint64_t v32 = v36;
      }
      if (v32 > v31) {
        return result;
      }
    }

    if (v33 - (char *)&__CFSMPUnicodeOnlyEmojiList != -2)
    {
      *a3 = 2LL;
      return 724LL;
    }

    return -1LL;
  }

  if ((a1[2] & 0xFC00) != 0xD800) {
    return -1LL;
  }
  int v9 = a1[3];
  if (v9 >> 10 != 55) {
    return -1LL;
  }
  int v10 = 0LL;
  __s1[0] = v7 + 91;
  __s1[1] = v9 + 91;
  while (strncmp(__s1, __CFRegionSequences[v10], 2uLL))
  {
    if (++v10 == 10) {
      return -1LL;
    }
  }

  double result = v10 + 712;
  uint64_t v23 = 4LL;
LABEL_41:
  *a3 = v23;
  return result;
}

LABEL_48:
        if (++v13 != a2) {
          goto LABEL_22;
        }
        CFRange v26 = (objc_class *)objc_opt_self();
        uint64_t v27 = __CFAllocateObject(v26, v30 + 8 * v14);
        *(_BYTE *)(v27 + 14) = BYTE6(v14);
        *(_WORD *)(v27 + 12) = WORD2(v14);
        *(_DWORD *)(v27 + 8) = v14;
        *(_BYTE *)(v27 + 15) = *(_BYTE *)(v27 + 15) & 3 | (4 * v4);
        *(_BYTE *)(v27 + 15) = *(_BYTE *)(v27 + 15) & 0xFC | v10 & 3;
        memmove((void *)(v27 + 16), __src, 8 * v14);
        memmove((void *)(v27 + 16 + 8 * v14), v34, v30);
        free(__src);
        return v27;
      default:
        goto LABEL_24;
    }
  }

      if (v25) {
        goto LABEL_49;
      }
LABEL_54:
      v49 = a6;
      int v24 = 256;
      goto LABEL_55;
    }

    if (!*BytePtr)
    {
      if (!BytePtr[1] && BytePtr[2] == 254 && BytePtr[3] == 255)
      {
        v49 = a6;
        int v24 = 402653440;
LABEL_90:
        unint64_t v28 = 4LL;
LABEL_56:
        unint64_t v29 = v24;
        size_t v30 = &CFDataGetBytePtr(theData)[v28];
        uint64_t v31 = CFDataGetLength(theData);
        uint64_t v32 = CFStringCreateWithBytes((CFAllocatorRef)a1, v30, v31 - v28, v29, 0);
        if (v32)
        {
          uint64_t v33 = v32;
          UTF8DataFromString = _createUTF8DataFromString((const __CFAllocator *)a1, v32);
          unint64_t v18 = _CFPropertyListCreateFromUTF8Data( (const __CFAllocator *)a1,  UTF8DataFromString,  0LL,  v33,  0,  a3,  a4,  v50,  v49,  a7,  a8,  v11,  v12);
          CFRelease(v33);
          if (UTF8DataFromString) {
            CFRelease(UTF8DataFromString);
          }
          return v18;
        }

        if (a4)
        {
          Error = __CFPropertyListCreateError( 3840LL,  @"Could not determine the encoding of the XML data (string creation failed)");
          goto LABEL_17;
        }

        return 0LL;
      }

      goto LABEL_54;
    }
  }

  if (v23 != 239) {
    goto LABEL_36;
  }
  unint64_t v25 = BytePtr[1];
  if (v25 != 187) {
    goto LABEL_48;
  }
  if (BytePtr[2] == 191)
  {
    CFRange v26 = 3LL;
LABEL_52:
    uint64_t v27 = v50;
    return _CFPropertyListCreateFromUTF8Data( (const __CFAllocator *)a1,  theData,  v26,  0LL,  0x8000100u,  a3,  a4,  v27,  a6,  a7,  a8,  v11,  v12);
  }

  if (!alloc)
  {
    uint64_t v32 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v32) {
      alloc = v32;
    }
    else {
      alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  if ((v5 & 0xFFF) == 0x100 && ((_DWORD)v5 == 256 || (v5 - 134217985) >> 26 <= 4))
  {
    char v36 = 1;
    if ((v5 & 0x8000000) != 0) {
      char v36 = 2;
    }
    size[0] = (data + 1) << v36;
  }

  else
  {
    size[0] = CFStringGetMaximumSizeForEncoding(data, v5);
    if (size[0] > data && !CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    {
      uint64_t v33 = atomic_load((unint64_t *)&theString->info);
      if ((v33 & 0x10) != 0)
      {
        uint64_t v39 = atomic_load((unint64_t *)&theString->info);
        uint64_t v40 = &theString->data;
        if ((v39 & 0x60) != 0)
        {
          uint64_t v41 = (unsigned __int16 *)*v40;
        }

        else
        {
          uint64_t v42 = atomic_load((unint64_t *)&theString->info);
          uint64_t v41 = (unsigned __int16 *)&v40[(v42 & 5) != 4LL];
        }

        uint64_t v43 = atomic_load((unint64_t *)&theString->info);
        uint64_t v44 = atomic_load((unint64_t *)&theString->info);
        uint64_t v45 = v44 & 0x60;
        if ((v43 & 5) == 4LL)
        {
          if (v45)
          {
            uint64_t v46 = *v40;
          }

          else
          {
            uint64_t v48 = atomic_load((unint64_t *)&theString->info);
            uint64_t v46 = (char *)&v40[(v48 & 5) != 4];
          }

          uint64_t v47 = *v46;
        }

        else if (v45)
        {
          uint64_t v47 = theString->length;
        }

        else
        {
          uint64_t v47 = (uint64_t)*v40;
        }

        v49 = CFStringEncodingByteLengthForCharacters(v5, 256LL, v41, v47);
        if (v49 >= 1) {
          size[0] = v49;
        }
      }

      else
      {
        v67.CFIndex location = 0LL;
        v67.CFIndex length = data;
        uint64_t v34 = __CFStringEncodeByteStream(theString, v67, 1, v5, v4, 0LL, 0x7FFFFFFFFFFFFFFFLL, size);
        if (data != v34)
        {
          double result = 0LL;
          if (!v4 || !v34) {
            return result;
          }
        }

        if (size[0] == data)
        {
          v35 = atomic_load((unint64_t *)&theString->info);
          if ((v35 & 0x10) == 0)
          {
            switch(BYTE1(v5))
            {
              case 0:
                goto LABEL_105;
              case 1:
                if ((_DWORD)v5 != 134217984) {
                  goto LABEL_71;
                }
                goto LABEL_105;
              case 2:
                if ((_DWORD)v5 == 518) {
                  goto LABEL_71;
                }
                goto LABEL_105;
              case 6:
                if ((_DWORD)v5 != 1536) {
                  goto LABEL_71;
                }
                goto LABEL_105;
              case 8:
              case 0xC:
                goto LABEL_71;
              case 0xA:
                v50 = 1 << (v5 - 1);
                char v51 = 32785;
                break;
              case 0xB:
                v50 = 1 << (v5 + 13);
                char v51 = 4099;
                break;
              default:
                goto LABEL_105;
            }

            if ((v50 & v51) == 0)
            {
LABEL_105:
              v52 = atomic_load((unint64_t *)&theString->info);
              v53 = &theString->data;
              if ((v52 & 0x60) != 0)
              {
                uint64_t v54 = *v53;
              }

              else
              {
                v55 = atomic_load((unint64_t *)&theString->info);
                uint64_t v54 = (char *)&v53[(v55 & 5) != 4LL];
              }

              uint64_t v56 = atomic_load((unint64_t *)&theString->info);
              v57 = (const UInt8 *)&v54[(v56 >> 2) & 1];
              uint64_t v58 = atomic_load((unint64_t *)&theString->info);
              uint64_t v59 = v58 & 5;
              size_t v60 = atomic_load((unint64_t *)&theString->info);
              v61 = v60 & 0x60;
              if (v59 == 4)
              {
                if (v61)
                {
                  uint64_t v62 = *v53;
                }

                else
                {
                  uint64_t v64 = atomic_load((unint64_t *)&theString->info);
                  uint64_t v62 = (char *)&v53[(v64 & 5) != 4];
                }

                v63 = *v62;
              }

              else if (v61)
              {
                v63 = theString->length;
              }

              else
              {
                v63 = (CFIndex)*v53;
              }

              return CFDataCreate(alloc, v57, v63);
            }
          }
        }
      }
    }
  }

  unint64_t v29 = *(a2 - 1);
  if ((int)v15 <= 823)
  {
    if ((_DWORD)v15 != 774)
    {
      if ((_DWORD)v15 == 776)
      {
        if (v29 == 1077) {
          uint64_t v31 = 1105;
        }
        else {
          uint64_t v31 = -3;
        }
        if (v29 == 1045) {
          size_t v30 = 1025;
        }
        else {
          size_t v30 = v31;
        }
        goto LABEL_83;
      }

      goto LABEL_71;
    }

    if ((v29 & 0xFFFFFFDF) == 0x418)
    {
      size_t v30 = v29 + 1;
      goto LABEL_83;
    }

    goto LABEL_71;
  }

  if ((_DWORD)v15 == 824)
  {
    if (v29 == 61)
    {
      size_t v30 = 8800;
      goto LABEL_83;
    }

LABEL_4:
  if (a4 >> 61)
  {
    uint64_t v12 = _os_log_pack_size();
    uint64_t v13 = (char *)v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)(v15 + 4) = "-[NSMutableSet addObjects:count:]";
    *(_WORD *)(v15 + 12) = 2048;
    *(void *)(v15 + 14) = a4;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableSet addObjects:count:]",  a4);
LABEL_16:
    CFIndex v16 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v13,  v12);
    objc_exception_throw(v16);
  }

  if (!a4) {
    return;
  }
  int v8 = 0LL;
  do
  {
    if (!a3[v8])
    {
      a4 = _os_log_pack_size();
      int v10 = _os_log_pack_fill();
      *(_DWORD *)int v10 = 136315394;
      *(void *)(v10 + 4) = "-[NSMutableSet addObjects:count:]";
      *(_WORD *)(v10 + 12) = 2048;
      *(void *)(v10 + 14) = v8;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableSet addObjects:count:]",  v8);
      unint64_t v11 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v17 - ((a4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a4);
      objc_exception_throw(v11);
      goto LABEL_14;
    }

    ++v8;
  }

  while (a4 != v8);
  do
  {
    int v9 = (uint64_t)*a3++;
    -[NSMutableSet addObject:](self, "addObject:", v9);
    --a4;
  }

  while (a4);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v29 = v9;
      CFIndex v16 = _os_log_pack_size();
      unint64_t v18 = (char *)v33 - ((MEMORY[0x1895F8858](v16, v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v31 = _os_log_pack_fill();
      uint64_t v32 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v31,  (uint64_t)"-[NSMutableSet addObjectsFromArray:range:]",  location,  length,  --v29);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v32,  "-[NSMutableSet addObjectsFromArray:range:]",  location,  length,  v29);
    }

    else
    {
      CFIndex v16 = _os_log_pack_size();
      unint64_t v18 = (char *)v33 - ((MEMORY[0x1895F8858](v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = _os_log_pack_fill();
      id v20 = __os_log_helper_1_2_3_8_32_8_0_8_0( v19,  (uint64_t)"-[NSMutableSet addObjectsFromArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty set",  v20,  "-[NSMutableSet addObjectsFromArray:range:]",  location,  length);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v18,  v16);
    objc_exception_throw(v21);
    goto LABEL_23;
  }

  if (length >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (length <= 1) {
    unint64_t v11 = 1LL;
  }
  else {
    unint64_t v11 = length;
  }
  uint64_t v12 = MEMORY[0x1895F8858](v11, v10);
  uint64_t v14 = (char *)v33 - v13;
  if (length >= 0x101)
  {
    uint64_t v14 = (char *)_CFCreateArrayStorage(v12, 0, v33);
    uint64_t v15 = v14;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v14, location, length);
  -[NSMutableSet addObjects:count:](self, "addObjects:count:", v14, length);
  free(v15);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v29 = v9;
      CFIndex v16 = _os_log_pack_size();
      unint64_t v18 = (char *)v33 - ((MEMORY[0x1895F8858](v16, v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v31 = _os_log_pack_fill();
      uint64_t v32 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v31,  (uint64_t)"-[NSMutableSet addObjectsFromOrderedSet:range:]",  location,  length,  --v29);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v32,  "-[NSMutableSet addObjectsFromOrderedSet:range:]",  location,  length,  v29);
    }

    else
    {
      CFIndex v16 = _os_log_pack_size();
      unint64_t v18 = (char *)v33 - ((MEMORY[0x1895F8858](v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = _os_log_pack_fill();
      id v20 = __os_log_helper_1_2_3_8_32_8_0_8_0( v19,  (uint64_t)"-[NSMutableSet addObjectsFromOrderedSet:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty set",  v20,  "-[NSMutableSet addObjectsFromOrderedSet:range:]",  location,  length);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v18,  v16);
    objc_exception_throw(v21);
    goto LABEL_23;
  }

  if (length >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (length <= 1) {
    unint64_t v11 = 1LL;
  }
  else {
    unint64_t v11 = length;
  }
  uint64_t v12 = MEMORY[0x1895F8858](v11, v10);
  uint64_t v14 = (char *)v33 - v13;
  if (length >= 0x101)
  {
    uint64_t v14 = (char *)_CFCreateArrayStorage(v12, 0, v33);
    uint64_t v15 = v14;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v14, location, length);
  -[NSMutableSet addObjects:count:](self, "addObjects:count:", v14, length);
  free(v15);
}

  uint64_t v19 = 0u;
  id v20 = 0u;
  unint64_t v17 = 0u;
  unint64_t v18 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(a3);
        }
        -[NSMutableSet addObject:](self, "addObject:", *(void *)(*((void *)&v17 + 1) + 8 * i));
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    }

    while (v7);
  }

  uint64_t v42 = 0u;
  uint64_t v43 = 0u;
  uint64_t v40 = 0u;
  uint64_t v41 = 0u;
  uint64_t v7 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v40,  v39,  16LL);
  if (!v7)
  {
    MEMORY[0x1895F8858](0LL, v6);
    uint64_t v15 = &v31;
LABEL_18:
    uint64_t v32 = 0LL;
    goto LABEL_19;
  }

  int v8 = 0LL;
  int v9 = *(void *)v41;
  do
  {
    for (uint64_t i = 0LL; i != v7; ++i)
    {
      if (*(void *)v41 != v9) {
        objc_enumerationMutation(self);
      }
      v8 += -[NSSet countForObject:](self, "countForObject:", *(void *)(*((void *)&v40 + 1) + 8 * i));
    }

    uint64_t v7 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v40,  v39,  16LL);
  }

  while (v7);
  if (v8 >> 60)
  {
    unint64_t v29 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v8);
    size_t v30 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v29,  0LL);
    CFRelease(v29);
    objc_exception_throw(v30);
    goto LABEL_36;
  }

  if (v8 <= 1) {
    uint64_t v12 = 1LL;
  }
  else {
    uint64_t v12 = v8;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v12, v11);
  uint64_t v15 = (uint64_t *)((char *)&v32 - v14);
  if (v8 < 0x101) {
    goto LABEL_18;
  }
  uint64_t v15 = (uint64_t *)_CFCreateArrayStorage(v13, 0, &v33);
  uint64_t v32 = v15;
LABEL_19:
  unint64_t v37 = 0u;
  BOOL v38 = 0u;
  v35 = 0u;
  char v36 = 0u;
  CFIndex v16 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v35,  v34,  16LL);
  unint64_t v17 = v15;
  if (v16)
  {
    unint64_t v18 = *(void *)v36;
    unint64_t v17 = v15;
    do
    {
      for (j = 0LL; j != v16; ++j)
      {
        if (*(void *)v36 != v18) {
          objc_enumerationMutation(self);
        }
        id v20 = *(void *)(*((void *)&v35 + 1) + 8 * j);
        uint64_t v21 = [a3 countForObject:v20];
        unint64_t v22 = -[NSSet countForObject:](self, "countForObject:", v20);
        uint64_t v23 = v22 - v21;
        if (v22 > v21)
        {
          do
          {
            *v17++ = v20;
            --v23;
          }

          while (v23);
        }
      }

      CFIndex v16 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v35,  v34,  16LL);
    }

    while (v16);
  }

  while (v15 < v17)
    -[NSMutableSet removeObject:](self, "removeObject:", *v15++);
  free(v32);
}

  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  id v20 = 0u;
  uint64_t v21 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(a3);
        }
        int v10 = *(void *)(*((void *)&v20 + 1) + 8 * i);
        unint64_t v11 = [a3 countForObject:v10];
        if (v11)
        {
          uint64_t v12 = v11;
          do
          {
            --v12;
            -[NSMutableSet removeObject:](self, "removeObject:", v10);
          }

          while (v12);
        }
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
    }

    while (v7);
  }

  int v9 = [a3 count];
  if (location < 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (!v9)
    {
      int v10 = _os_log_pack_size();
      unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = _os_log_pack_fill();
      uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableSet removeObjectsInArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty set",  v13,  "-[NSMutableSet removeObjectsInArray:range:]",  location,  length);
LABEL_16:
      uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
      objc_exception_throw(v19);
      -[NSMutableSet removeObjectsInArray:](v20, v21, v22);
      return;
    }

  uint64_t v19 = 0u;
  id v20 = 0u;
  unint64_t v17 = 0u;
  unint64_t v18 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(a3);
        }
        -[NSMutableSet removeObject:](self, "removeObject:", *(void *)(*((void *)&v17 + 1) + 8 * i));
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    }

    while (v7);
  }

  int v9 = [a3 count];
  if (location < 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (!v9)
    {
      int v10 = _os_log_pack_size();
      unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = _os_log_pack_fill();
      uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableSet removeObjectsInOrderedSet:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty set",  v13,  "-[NSMutableSet removeObjectsInOrderedSet:range:]",  location,  length);
LABEL_16:
      uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
      objc_exception_throw(v19);
      -[NSMutableSet removeObjectsInOrderedSet:](v20, v21, v22);
      return;
    }

  uint64_t v19 = 0u;
  id v20 = 0u;
  unint64_t v17 = 0u;
  unint64_t v18 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(a3);
        }
        -[NSMutableSet removeObject:](self, "removeObject:", *(void *)(*((void *)&v17 + 1) + 8 * i));
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    }

    while (v7);
  }

  -[NSMutableSet removeAllObjects](self, "removeAllObjects");
  uint64_t v19 = 0u;
  id v20 = 0u;
  unint64_t v17 = 0u;
  unint64_t v18 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v18;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(a3);
        }
        -[NSMutableSet addObject:](self, "addObject:", *(void *)(*((void *)&v17 + 1) + 8 * i));
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v17 objects:v16 count:16];
    }

    while (v7);
  }

  -[NSMutableSet removeAllObjects](self, "removeAllObjects");
  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  id v20 = 0u;
  uint64_t v21 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(a3);
        }
        int v10 = *(void *)(*((void *)&v20 + 1) + 8 * i);
        unint64_t v11 = [a3 countForObject:v10];
        if (v11)
        {
          uint64_t v12 = v11;
          do
          {
            --v12;
            -[NSMutableSet addObject:](self, "addObject:", v10);
          }

          while (v12);
        }
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
    }

    while (v7);
  }

  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  id v20 = 0u;
  uint64_t v21 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(a3);
        }
        int v10 = *(void *)(*((void *)&v20 + 1) + 8 * i);
        unint64_t v11 = [a3 countForObject:v10];
        if (v11)
        {
          uint64_t v12 = v11;
          do
          {
            --v12;
            -[NSMutableSet addObject:](self, "addObject:", v10);
          }

          while (v12);
        }
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
    }

    while (v7);
  }

  if (count >> 61)
  {
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v14 = 136315394;
    *(void *)(v14 + 4) = "-[NSMutableOrderedSet addObjects:count:]";
    *(_WORD *)(v14 + 12) = 2048;
    *(void *)(v14 + 14) = count;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableOrderedSet addObjects:count:]",  count);
LABEL_15:
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v11);
    objc_exception_throw(v15);
  }

  if (count)
  {
    int v8 = 0LL;
    while (objects[v8])
    {
      if (count == ++v8) {
        goto LABEL_9;
      }
    }

    count = _os_log_pack_size();
    int v9 = _os_log_pack_fill();
    *(_DWORD *)int v9 = 136315394;
    *(void *)(v9 + 4) = "-[NSMutableOrderedSet addObjects:count:]";
    *(_WORD *)(v9 + 12) = 2048;
    *(void *)(v9 + 14) = v8;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableOrderedSet addObjects:count:]",  v8);
    int v10 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v16 - ((count + 15) & 0xFFFFFFFFFFFFFFF0LL),  count);
    objc_exception_throw(v10);
    goto LABEL_13;
  }

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]( self,  "insertObjectsFromArray:range:atIndex:",  a3,  location,  length,  -[NSOrderedSet count](self, "count"));
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = _os_log_pack_fill();
  uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableOrderedSet addObjectsFromArray:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v13,  "-[NSMutableOrderedSet addObjectsFromArray:range:]",  location,  length);
LABEL_14:
  uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
  objc_exception_throw(v19);
  -[NSMutableOrderedSet addObjectsFromArray:](v20, v21, v22);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]( self,  "insertObjectsFromOrderedSet:range:atIndex:",  a3,  location,  length,  -[NSOrderedSet count](self, "count"));
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = _os_log_pack_fill();
  uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableOrderedSet addObjectsFromOrderedSet:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v13,  "-[NSMutableOrderedSet addObjectsFromOrderedSet:range:]",  location,  length);
LABEL_14:
  uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
  objc_exception_throw(v19);
  -[NSMutableOrderedSet addObjectsFromOrderedSet:](v20, v21, v22);
}

  if (a4 >> 61)
  {
    a5 = _os_log_pack_size();
    unint64_t v17 = (char *)v32 - ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v19 = 136315394;
    *(void *)(v19 + 4) = "-[NSMutableOrderedSet insertObjects:count:atIndex:]";
    *(_WORD *)(v19 + 12) = 2048;
    *(void *)(v19 + 14) = a4;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableOrderedSet insertObjects:count:atIndex:]",  a4);
    goto LABEL_20;
  }

  if (a4)
  {
    int v10 = 0LL;
    while (a3[v10])
    {
      if (a4 == ++v10) {
        goto LABEL_9;
      }
    }

    a4 = _os_log_pack_size();
    uint64_t v15 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)(v15 + 4) = "-[NSMutableOrderedSet insertObjects:count:atIndex:]";
    *(_WORD *)(v15 + 12) = 2048;
    *(void *)(v15 + 14) = v10;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableOrderedSet insertObjects:count:atIndex:]",  v10);
    CFIndex v16 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v32 - ((a4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a4);
    objc_exception_throw(v16);
    goto LABEL_18;
  }

  unint64_t v11 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v11 < location + length)
  {
    if (v11)
    {
      unint64_t v37 = v11;
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v39 = _os_log_pack_fill();
      uint64_t v40 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v39,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  location,  length,  --v37);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v40,  "-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  location,  length,  v37);
    }

    else
    {
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v22 = _os_log_pack_fill();
      uint64_t v23 = __os_log_helper_1_2_3_8_32_8_0_8_0( v22,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v23,  "-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  location,  length);
    }

    int v24 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v21,  v19);
    objc_exception_throw(v24);
    goto LABEL_29;
  }

  uint64_t v12 = -[NSOrderedSet count](self, "count");
  if ((a5 & 0x8000000000000000LL) != 0 || v12 < a5)
  {
    if (v12)
    {
      uint64_t v41 = v12;
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = _os_log_pack_fill();
      uint64_t v44 = __os_log_helper_1_2_3_8_32_8_0_8_0( v43,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  a5,  --v41);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v44,  "-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  a5,  v41);
    }

    else
    {
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v28 = _os_log_pack_fill();
      *(_DWORD *)unint64_t v28 = 136315394;
      *(void *)(v28 + 4) = "-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]";
      *(_WORD *)(v28 + 12) = 2048;
      *(void *)(v28 + 14) = a5;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:]",  a5);
    }

    unint64_t v29 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v27,  v25);
    objc_exception_throw(v29);
    goto LABEL_29;
  }

  if (length >> 60)
  {
    size_t v30 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v30,  0LL);
    CFRelease(v30);
    objc_exception_throw(v31);
  }

  if (length <= 1) {
    uint64_t v14 = 1LL;
  }
  else {
    uint64_t v14 = length;
  }
  uint64_t v15 = MEMORY[0x1895F8858](v14, v13);
  unint64_t v17 = (char *)v45 - v16;
  if (length >= 0x101)
  {
    unint64_t v17 = (char *)_CFCreateArrayStorage(v15, 0, v45);
    unint64_t v18 = v17;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v17, location, length);
  -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v17, length, a5);
  free(v18);
}

  int v8 = -[NSOrderedSet count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0( v30,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromArray:atIndex:]",  a4,  v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableOrderedSet insertObjectsFromArray:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableOrderedSet insertObjectsFromArray:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjectsFromArray:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v15, 0, v12);
  -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  unint64_t v11 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v11 < location + length)
  {
    if (v11)
    {
      unint64_t v37 = v11;
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v39 = _os_log_pack_fill();
      uint64_t v40 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v39,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  location,  length,  --v37);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v40,  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  location,  length,  v37);
    }

    else
    {
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v22 = _os_log_pack_fill();
      uint64_t v23 = __os_log_helper_1_2_3_8_32_8_0_8_0( v22,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v23,  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  location,  length);
    }

    int v24 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v21,  v19);
    objc_exception_throw(v24);
    goto LABEL_29;
  }

  uint64_t v12 = -[NSOrderedSet count](self, "count");
  if ((a5 & 0x8000000000000000LL) != 0 || v12 < a5)
  {
    if (v12)
    {
      uint64_t v41 = v12;
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = _os_log_pack_fill();
      uint64_t v44 = __os_log_helper_1_2_3_8_32_8_0_8_0( v43,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  a5,  --v41);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v44,  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  a5,  v41);
    }

    else
    {
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v28 = _os_log_pack_fill();
      *(_DWORD *)unint64_t v28 = 136315394;
      *(void *)(v28 + 4) = "-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]";
      *(_WORD *)(v28 + 12) = 2048;
      *(void *)(v28 + 14) = a5;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:range:atIndex:]",  a5);
    }

    unint64_t v29 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v27,  v25);
    objc_exception_throw(v29);
    goto LABEL_29;
  }

  if (length >> 60)
  {
    size_t v30 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v30,  0LL);
    CFRelease(v30);
    objc_exception_throw(v31);
  }

  if (length <= 1) {
    uint64_t v14 = 1LL;
  }
  else {
    uint64_t v14 = length;
  }
  uint64_t v15 = MEMORY[0x1895F8858](v14, v13);
  unint64_t v17 = (char *)v45 - v16;
  if (length >= 0x101)
  {
    unint64_t v17 = (char *)_CFCreateArrayStorage(v15, 0, v45);
    unint64_t v18 = v17;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v17, location, length);
  -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v17, length, a5);
  free(v18);
}

  int v8 = -[NSOrderedSet count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0( v30,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromOrderedSet:atIndex:]",  a4,  v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableOrderedSet insertObjectsFromOrderedSet:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjectsFromOrderedSet:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v15, 0, v12);
  -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  int v8 = -[NSOrderedSet count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0( v30,  (uint64_t)"-[NSMutableOrderedSet insertObjectsFromSet:atIndex:]",  a4,  v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableOrderedSet insertObjectsFromSet:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableOrderedSet insertObjectsFromSet:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjectsFromSet:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  [a3 getObjects:v15 count:v12];
  -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  if (!indexes)
  {
    CFRange v26 = _os_log_pack_size();
    unint64_t v28 = (char *)v50 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v29 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v29 = 136315138;
    *(void *)(v29 + 4) = "-[NSMutableOrderedSet insertObjects:atIndexes:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set cannot be nil",  "-[NSMutableOrderedSet insertObjects:atIndexes:]");
    size_t v30 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v30);
LABEL_33:
    __break(1u);
    return;
  }

  if ((_NSIsNSIndexSet() & 1) == 0)
  {
    uint64_t v31 = _os_log_pack_size();
    uint64_t v33 = (char *)v50 - ((MEMORY[0x1895F8858](v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v34 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v34 = 136315138;
    *(void *)(v34 + 4) = "-[NSMutableOrderedSet insertObjects:atIndexes:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set argument is not an NSIndexSet",  "-[NSMutableOrderedSet insertObjects:atIndexes:]");
    v35 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v33,  v31);
    objc_exception_throw(v35);
    goto LABEL_33;
  }

  int v9 = -[NSOrderedSet count](self, "count");
  int v10 = -[NSArray count](objects, "count");
  unint64_t v11 = -[NSIndexSet lastIndex](indexes, "lastIndex");
  if ((v11 & 0x8000000000000000LL) != 0)
  {
    char v36 = v11;
    uint64_t v12 = v10 + v9;
LABEL_26:
    unint64_t v37 = _os_log_pack_size();
    uint64_t v39 = (char *)v50 - ((MEMORY[0x1895F8858](v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v40 = _os_log_pack_fill();
    if (v12)
    {
      uint64_t v42 = __os_log_helper_1_2_3_8_32_8_0_8_0( v40,  (uint64_t)"-[NSMutableOrderedSet insertObjects:atIndexes:]",  v36,  v12 - 1);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds [0 .. %lu]",  v42,  "-[NSMutableOrderedSet insertObjects:atIndexes:]",  v36,  v12 - 1);
    }

    else
    {
      *(_DWORD *)uint64_t v40 = 136315394;
      *(void *)(v40 + 4) = "-[NSMutableOrderedSet insertObjects:atIndexes:]";
      *(_WORD *)(v40 + 12) = 2048;
      *(void *)(v40 + 14) = v36;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjects:atIndexes:]",  v36);
    }

    uint64_t v41 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v39,  v37);
    objc_exception_throw(v41);
    goto LABEL_33;
  }

  if (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v12 = v10 + v9;
    if (v12 <= v11)
    {
      char v36 = v11;
      goto LABEL_26;
    }
  }

  uint64_t v13 = -[NSArray count](objects, "count");
  uint64_t v14 = -[NSIndexSet count](indexes, "count");
  if (v13 != v14)
  {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of array (%lu) differs from count of index set (%lu)",  "-[NSMutableOrderedSet insertObjects:atIndexes:]",  v13,  v14);
LABEL_31:
    uint64_t v43 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v4);
    uint64_t v44 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v43,  0LL);
    CFRelease(v43);
    objc_exception_throw(v44);
  }

  uint64_t v15 = -[NSArray count](objects, "count");
  uint64_t v4 = v15;
  if (v15 >> 60) {
    goto LABEL_31;
  }
  if (v15 <= 1) {
    uint64_t v15 = 1LL;
  }
  unint64_t v17 = MEMORY[0x1895F8858](v15, v16);
  uint64_t v19 = (char *)v50 - v18;
  if (v4 >= 0x101)
  {
    uint64_t v19 = (char *)_CFCreateArrayStorage(v17, 0, v50);
    id v20 = v19;
  }

  else
  {
    id v20 = 0LL;
  }

  -[NSArray getObjects:range:](objects, "getObjects:range:", v19, 0LL, v4);
  uint64_t v21 = 0LL;
  for (uint64_t i = 0LL; i < -[NSIndexSet rangeCount](indexes, "rangeCount"); ++i)
  {
    uint64_t v23 = -[NSIndexSet rangeAtIndex:](indexes, "rangeAtIndex:", i);
    unint64_t v25 = v24;
    -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", &v19[8 * v21], v24, v23);
    v21 += v25;
  }

  free(v20);
}

  if (self == (NSMutableOrderedSet *)other) {
    return;
  }
  uint64_t v7 = -[NSOrderedSet count](self, "count");
  int v9 = v7;
  if (v7 >> 60)
  {
LABEL_28:
    unint64_t v25 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v9);
    CFRange v26 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v25,  0LL);
    CFRelease(v25);
    objc_exception_throw(v26);
    unint64_t v28 = v27;
    free(v4);
    _Unwind_Resume(v28);
  }

  if (v7 <= 1) {
    uint64_t v7 = 1LL;
  }
  int v10 = MEMORY[0x1895F8858](v7, v8);
  uint64_t v12 = (uint64_t *)((char *)&v29 - v11);
  if (v13 >= 0x101)
  {
    uint64_t v12 = (uint64_t *)_CFCreateArrayStorage(v10, 0, &v30);
    uint64_t v14 = v12;
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  uint64_t v34 = 0u;
  v35 = 0u;
  uint64_t v32 = 0u;
  uint64_t v33 = 0u;
  uint64_t v15 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v32,  v31,  16LL);
  CFIndex v16 = v12;
  if (v15)
  {
    unint64_t v17 = *(void *)v33;
    CFIndex v16 = v12;
    do
    {
      for (uint64_t i = 0LL; i != v15; ++i)
      {
        if (*(void *)v33 != v17) {
          objc_enumerationMutation(self);
        }
        uint64_t v19 = *(void *)(*((void *)&v32 + 1) + 8 * i);
        if (!-[NSOrderedSet countForObject:](other, "countForObject:", v19)) {
          *v16++ = v19;
        }
      }

      uint64_t v15 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v32,  v31,  16LL);
    }

    while (v15);
  }

  while (v12 < v16)
    -[NSMutableOrderedSet removeObject:](self, "removeObject:", *v12++);
  free(v14);
}

  uint64_t v6 = -[NSOrderedSet count](self, "count");
  if (v6 >> 60)
  {
    unint64_t v18 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v6);
    uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v18,  0LL);
    CFRelease(v18);
    objc_exception_throw(v19);
  }

  if (v6 <= 1) {
    uint64_t v6 = 1LL;
  }
  int v8 = MEMORY[0x1895F8858](v6, v7);
  int v10 = (uint64_t *)((char *)&v25 - v9);
  if (v11 >= 0x101)
  {
    int v10 = (uint64_t *)_CFCreateArrayStorage(v8, 0, &v26);
    uint64_t v12 = v10;
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  size_t v30 = 0u;
  uint64_t v31 = 0u;
  unint64_t v28 = 0u;
  unint64_t v29 = 0u;
  uint64_t v13 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v28,  v27,  16LL);
  uint64_t v14 = v10;
  if (v13)
  {
    uint64_t v15 = *(void *)v29;
    uint64_t v14 = v10;
    do
    {
      for (uint64_t i = 0LL; i != v13; ++i)
      {
        if (*(void *)v29 != v15) {
          objc_enumerationMutation(self);
        }
        unint64_t v17 = *(void *)(*((void *)&v28 + 1) + 8 * i);
        if (!-[NSSet countForObject:](other, "countForObject:", v17)) {
          *v14++ = v17;
        }
      }

      uint64_t v13 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v28,  v27,  16LL);
    }

    while (v13);
  }

  while (v10 < v14)
    -[NSMutableOrderedSet removeObject:](self, "removeObject:", *v10++);
  free(v12);
}

  if (self == (NSMutableOrderedSet *)other)
  {
    -[NSOrderedSet removeAllObjects](other, "removeAllObjects");
  }

  else
  {
    unint64_t v22 = 0u;
    uint64_t v23 = 0u;
    id v20 = 0u;
    uint64_t v21 = 0u;
    uint64_t v6 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
    if (v6)
    {
      uint64_t v7 = v6;
      int v8 = *(void *)v21;
      do
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v21 != v8) {
            objc_enumerationMutation(other);
          }
          int v10 = *(void *)(*((void *)&v20 + 1) + 8 * i);
          unint64_t v11 = -[NSOrderedSet countForObject:](other, "countForObject:", v10);
          if (v11)
          {
            uint64_t v12 = v11;
            do
            {
              --v12;
              -[NSMutableOrderedSet removeObject:](self, "removeObject:", v10);
            }

            while (v12);
          }
        }

        uint64_t v7 = -[NSOrderedSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
      }

      while (v7);
    }
  }

  uint64_t v21 = 0u;
  unint64_t v22 = 0u;
  uint64_t v19 = 0u;
  id v20 = 0u;
  uint64_t v6 = -[NSSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v19,  v18,  16LL);
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v20;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v20 != v8) {
          objc_enumerationMutation(other);
        }
        int v10 = *(void *)(*((void *)&v19 + 1) + 8 * i);
        unint64_t v11 = -[NSSet countForObject:](other, "countForObject:", v10);
        if (v11)
        {
          uint64_t v12 = v11;
          do
          {
            --v12;
            -[NSMutableOrderedSet removeObject:](self, "removeObject:", v10);
          }

          while (v12);
        }
      }

      uint64_t v7 = -[NSSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v19,  v18,  16LL);
    }

    while (v7);
  }

  int v9 = [a3 count];
  if (location < 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (!v9)
    {
      unint64_t v11 = _os_log_pack_size();
      uint64_t v12 = (char *)v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = _os_log_pack_fill();
      uint64_t v14 = __os_log_helper_1_2_3_8_32_8_0_8_0( v13,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v14,  "-[NSMutableOrderedSet removeObjectsInArray:range:]",  location,  length);
LABEL_18:
      id v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v11);
      objc_exception_throw(v20);
      -[NSMutableOrderedSet removeObjectsInArray:](v21, v22, v23);
      return;
    }

  id v20 = 0u;
  uint64_t v21 = 0u;
  unint64_t v18 = 0u;
  uint64_t v19 = 0u;
  uint64_t v6 = -[NSArray countByEnumeratingWithState:objects:count:]( array,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v19;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v19 != v8) {
          objc_enumerationMutation(array);
        }
        int v10 = -[NSOrderedSet indexOfObject:](self, "indexOfObject:", *(void *)(*((void *)&v18 + 1) + 8 * i));
        if (v10 != 0x7FFFFFFFFFFFFFFFLL) {
          -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v10);
        }
      }

      uint64_t v7 = -[NSArray countByEnumeratingWithState:objects:count:]( array,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
    }

    while (v7);
  }

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableOrderedSet removeObjectsInRange:inOrderedSet:range:]( self,  "removeObjectsInRange:inOrderedSet:range:",  0LL,  -[NSOrderedSet count](self, "count"),  a3,  location,  length);
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  uint64_t v12 = (char *)v26 - ((MEMORY[0x1895F8858](v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = _os_log_pack_fill();
  uint64_t v14 = __os_log_helper_1_2_3_8_32_8_0_8_0( v13,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInOrderedSet:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v14,  "-[NSMutableOrderedSet removeObjectsInOrderedSet:range:]",  location,  length);
LABEL_14:
  unint64_t v22 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v10);
  objc_exception_throw(v22);
  -[NSMutableOrderedSet removeObjectsInOrderedSet:](v23, v24, v25);
}

  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  id v20 = 0u;
  uint64_t v21 = 0u;
  uint64_t v6 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(a3);
        }
        int v10 = -[NSOrderedSet indexOfObject:](self, "indexOfObject:", *(void *)(*((void *)&v20 + 1) + 8 * i));
        if (v10 != 0x7FFFFFFFFFFFFFFFLL) {
          -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v10);
        }
      }

      uint64_t v7 = [a3 countByEnumeratingWithState:&v20 objects:v19 count:16];
    }

    while (v7);
  }

  if (!indexes)
  {
    unint64_t v29 = _os_log_pack_size();
    uint64_t v31 = (char *)v52 - ((MEMORY[0x1895F8858](v29, v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v32 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v32 = 136315138;
    *(void *)(v32 + 4) = "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set cannot be nil",  "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]");
    uint64_t v33 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v31,  v29);
    objc_exception_throw(v33);
LABEL_35:
    __break(1u);
    return;
  }

  if ((_NSIsNSIndexSet() & 1) == 0)
  {
    uint64_t v34 = _os_log_pack_size();
    char v36 = (char *)v52 - ((MEMORY[0x1895F8858](v34, v35) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v37 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v37 = 136315138;
    *(void *)(v37 + 4) = "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set argument is not an NSIndexSet",  "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]");
    BOOL v38 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v36,  v34);
    objc_exception_throw(v38);
    goto LABEL_35;
  }

  int v8 = -[NSOrderedSet count](self, "count");
  int v9 = -[NSArray count](objects, "count");
  int v10 = -[NSIndexSet lastIndex](indexes, "lastIndex");
  unint64_t v11 = v10;
  if ((v10 & 0x8000000000000000LL) != 0)
  {
    uint64_t v12 = v9 + v8;
    goto LABEL_28;
  }

  if (v10 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v12 = v9 + v8;
    if (v12 <= v10)
    {
LABEL_28:
      uint64_t v39 = _os_log_pack_size();
      uint64_t v41 = (char *)v52 - ((MEMORY[0x1895F8858](v39, v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v42 = _os_log_pack_fill();
      if (v12)
      {
        uint64_t v44 = __os_log_helper_1_2_3_8_32_8_0_8_0( v42,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]",  v11,  v12 - 1);
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds [0 .. %lu]",  v44,  "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]",  v11,  v12 - 1);
      }

      else
      {
        *(_DWORD *)uint64_t v42 = 136315394;
        *(void *)(v42 + 4) = "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]";
        *(_WORD *)(v42 + 12) = 2048;
        *(void *)(v42 + 14) = v11;
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds for empty ordered set",  "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]",  v11);
      }

      uint64_t v43 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v41,  v39);
      objc_exception_throw(v43);
      goto LABEL_35;
    }
  }

  uint64_t v13 = -[NSArray count](objects, "count");
  uint64_t v14 = -[NSIndexSet count](indexes, "count");
  if (v13 != v14)
  {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of array (%lu) differs from count of index set (%lu)",  "-[NSMutableOrderedSet replaceObjectsAtIndexes:withObjects:]",  v13,  v14);
LABEL_33:
    uint64_t v45 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v9);
    uint64_t v46 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v45,  0LL);
    CFRelease(v45);
    objc_exception_throw(v46);
  }

  uint64_t v15 = -[NSArray count](objects, "count");
  int v9 = v15;
  if (v15 >> 60) {
    goto LABEL_33;
  }
  if (v15 <= 1) {
    uint64_t v15 = 1LL;
  }
  unint64_t v17 = MEMORY[0x1895F8858](v15, v16);
  uint64_t v19 = (char *)v52 - v18;
  if (v9 >= 0x101)
  {
    uint64_t v19 = (char *)_CFCreateArrayStorage(v17, 0, v52);
    id v20 = v19;
  }

  else
  {
    id v20 = 0LL;
  }

  -[NSArray getObjects:range:](objects, "getObjects:range:", v19, 0LL, v9);
  for (uint64_t i = -[NSIndexSet rangeCount](indexes, "rangeCount") - 1; i != -1; --i)
  {
    unint64_t v22 = -[NSIndexSet rangeAtIndex:](indexes, "rangeAtIndex:", i);
    -[NSMutableOrderedSet removeObjectsInRange:](self, "removeObjectsInRange:", v22, v23);
  }

  int v24 = 0LL;
  for (j = 0LL; j < -[NSIndexSet rangeCount](indexes, "rangeCount"); ++j)
  {
    CFRange v26 = -[NSIndexSet rangeAtIndex:](indexes, "rangeAtIndex:", j);
    unint64_t v28 = v27;
    -[NSMutableOrderedSet insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", &v19[8 * v24], v27, v26);
    v24 += v28;
  }

  free(v20);
}

  uint64_t v12 = [a4 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v12 < location + length)
  {
    if (v12)
    {
      uint64_t v39 = v12;
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v41 = _os_log_pack_fill();
      uint64_t v42 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v41,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length,  --v39);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v42,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length,  v39);
    }

    else
    {
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = _os_log_pack_fill();
      int v24 = __os_log_helper_1_2_3_8_32_8_0_8_0( v23,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v24,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length);
    }

    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v20);
    objc_exception_throw(v25);
    goto LABEL_30;
  }

  uint64_t v13 = -[NSOrderedSet count](self, "count");
  if ((v10 & 0x8000000000000000LL) != 0 || (v9 & 0x8000000000000000LL) != 0 || v13 < v10 + v9)
  {
    if (v13)
    {
      uint64_t v43 = v13;
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v45 = _os_log_pack_fill();
      uint64_t v46 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v45,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9,  --v43);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v46,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9,  v43);
    }

    else
    {
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v29 = _os_log_pack_fill();
      size_t v30 = __os_log_helper_1_2_3_8_32_8_0_8_0( v29,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v30,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9);
    }

    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v31);
    goto LABEL_30;
  }

  if (length >> 60)
  {
    uint64_t v32 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v33 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v32,  0LL);
    CFRelease(v32);
    objc_exception_throw(v33);
  }

  if (length <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = length;
  }
  CFIndex v16 = MEMORY[0x1895F8858](v15, v14);
  unint64_t v18 = (char *)v47 - v17;
  if (length >= 0x101)
  {
    unint64_t v18 = (char *)_CFCreateArrayStorage(v16, 0, v47);
    uint64_t v19 = v18;
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v18, location, length);
  -[NSMutableOrderedSet replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  v10,  v9,  v18,  length);
  free(v19);
}

  int v9 = -[NSOrderedSet count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v22,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromArray:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = [a4 count];
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v16, 0, v13);
  -[NSMutableOrderedSet replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  uint64_t v12 = [a4 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v12 < location + length)
  {
    if (v12)
    {
      uint64_t v39 = v12;
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v41 = _os_log_pack_fill();
      uint64_t v42 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v41,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length,  --v39);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v42,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length,  v39);
    }

    else
    {
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = _os_log_pack_fill();
      int v24 = __os_log_helper_1_2_3_8_32_8_0_8_0( v23,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v24,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length);
    }

    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v20);
    objc_exception_throw(v25);
    goto LABEL_30;
  }

  uint64_t v13 = -[NSOrderedSet count](self, "count");
  if ((v10 & 0x8000000000000000LL) != 0 || (v9 & 0x8000000000000000LL) != 0 || v13 < v10 + v9)
  {
    if (v13)
    {
      uint64_t v43 = v13;
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v45 = _os_log_pack_fill();
      uint64_t v46 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v45,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9,  --v43);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v46,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9,  v43);
    }

    else
    {
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v29 = _os_log_pack_fill();
      size_t v30 = __os_log_helper_1_2_3_8_32_8_0_8_0( v29,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v30,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9);
    }

    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v31);
    goto LABEL_30;
  }

  if (length >> 60)
  {
    uint64_t v32 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v33 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v32,  0LL);
    CFRelease(v32);
    objc_exception_throw(v33);
  }

  if (length <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = length;
  }
  CFIndex v16 = MEMORY[0x1895F8858](v15, v14);
  unint64_t v18 = (char *)v47 - v17;
  if (length >= 0x101)
  {
    unint64_t v18 = (char *)_CFCreateArrayStorage(v16, 0, v47);
    uint64_t v19 = v18;
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v18, location, length);
  -[NSMutableOrderedSet replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  v10,  v9,  v18,  length);
  free(v19);
}

  int v9 = -[NSOrderedSet count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v22,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = [a4 count];
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v16, 0, v13);
  -[NSMutableOrderedSet replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  int v9 = -[NSOrderedSet count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromSet:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromSet:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromSet:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v22,  "-[NSMutableOrderedSet replaceObjectsInRange:withObjectsFromSet:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = [a4 count];
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  [a4 getObjects:v16 count:v13];
  -[NSMutableOrderedSet replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  if (self != a3)
  {
    -[NSMutableOrderedSet removeAllObjects](self, "removeAllObjects");
    -[NSMutableOrderedSet insertObjectsFromOrderedSet:atIndex:](self, "insertObjectsFromOrderedSet:atIndex:", a3, 0LL);
  }

  uint64_t v6 = -[NSOrderedSet count](other, "count");
  int v8 = v6;
  if (v6 >> 60)
  {
    uint64_t v15 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v6);
    CFIndex v16 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v15,  0LL);
    CFRelease(v15);
    objc_exception_throw(v16);
  }

  if (v6 <= 1) {
    uint64_t v6 = 1LL;
  }
  int v9 = MEMORY[0x1895F8858](v6, v7);
  unint64_t v11 = (char *)v22 - v10;
  if (v8 >= 0x101)
  {
    unint64_t v11 = (char *)_CFCreateArrayStorage(v9, 0, v22);
    uint64_t v12 = v11;
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  -[NSOrderedSet getObjects:range:](other, "getObjects:range:", v11, 0LL, v8);
  if (v8)
  {
    for (uint64_t i = 0LL; i != v8; ++i)
    {
      uint64_t v14 = -[NSOrderedSet countForObject:](other, "countForObject:", *(void *)&v11[8 * i]) + 1;
      while (--v14)
        -[NSMutableOrderedSet addObject:](self, "addObject:", *(void *)&v11[8 * i]);
    }
  }

  free(v12);
}

  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  id v20 = 0u;
  uint64_t v21 = 0u;
  uint64_t v6 = -[NSSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(other);
        }
        int v10 = *(void *)(*((void *)&v20 + 1) + 8 * i);
        unint64_t v11 = -[NSSet countForObject:](other, "countForObject:", v10);
        if (v11)
        {
          uint64_t v12 = v11;
          do
          {
            --v12;
            -[NSMutableOrderedSet addObject:](self, "addObject:", v10);
          }

          while (v12);
        }
      }

      uint64_t v7 = -[NSSet countByEnumeratingWithState:objects:count:]( other,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
    }

    while (v7);
  }

  if (a3)
  {
    uint64_t v12 = (id)[a4 copyWithZone:0];
    CFDictionarySetValue((CFMutableDictionaryRef)self, v12, a3);

    return;
  }

  if ((v20 & 1) != 0 || v19 || v17 || v18 || v16) {
    goto LABEL_78;
  }
  if (*a2 < 0 || a2[5] != 1128680784) {
    uint64_t v21 = 11LL;
  }
  else {
    uint64_t v21 = 10LL;
  }
  int v24 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a4 + 32), (const void *)a2[v21 + 2]);
  unint64_t v25 = *a2;
  if (v24)
  {
    if (v25 < 0)
    {
      uint64_t v32 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(const UInt8 **)(a2 + 7), a2[10]);
      mach_vm_deallocate(*MEMORY[0x1895FBBE0], *(void *)(a2 + 7), a2[10]);
    }

    else
    {
      CFRange v26 = 11LL;
      if (a2[5] == 1128680784) {
        CFRange v26 = 10LL;
      }
      uint64_t v27 = (const UInt8 *)&a2[v26 + 4];
      else {
        unint64_t v28 = (const __CFData *)CFRetain(&__kCFBooleanFalse);
      }
      uint64_t v32 = v28;
    }

    if (*a2 < 0 || a2[5] != 1128680784) {
      uint64_t v33 = 11LL;
    }
    else {
      uint64_t v33 = 10LL;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 32), (const void *)a2[v33 + 2], v32);
    CFRelease(v32);
  }

  else if (v25 < 0)
  {
    mach_vm_deallocate(*MEMORY[0x1895FBBE0], *(void *)(a2 + 7), a2[10]);
  }

  _CFArrayReplaceValues((unint64_t)self, a4, 0LL, v9, 1LL);
}

  if (_CFNonObjCArrayGetCount((uint64_t)self) > a3)
  {
    CFArraySetValueAtIndex((CFMutableArrayRef)self, a3, a4);
    return;
  }

  if (self != (NSMutableDictionary *)otherDictionary)
  {
    id v20 = 0u;
    uint64_t v21 = 0u;
    unint64_t v18 = 0u;
    uint64_t v19 = 0u;
    uint64_t v6 = -[NSDictionary countByEnumeratingWithState:objects:count:]( otherDictionary,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
    if (v6)
    {
      uint64_t v7 = v6;
      int v8 = *(void *)v19;
      do
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v19 != v8) {
            objc_enumerationMutation(otherDictionary);
          }
          -[NSMutableDictionary setObject:forKey:]( self,  "setObject:forKey:",  -[NSDictionary objectForKey:](otherDictionary, "objectForKey:", *(void *)(*((void *)&v18 + 1) + 8 * i)),  *(void *)(*((void *)&v18 + 1) + 8 * i));
        }

        uint64_t v7 = -[NSDictionary countByEnumeratingWithState:objects:count:]( otherDictionary,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
      }

      while (v7);
    }
  }

  if (a5 >> 61)
  {
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)(v15 + 4) = "-[NSMutableDictionary addObjects:forKeys:count:]";
    *(_WORD *)(v15 + 12) = 2048;
    *(void *)(v15 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableDictionary addObjects:forKeys:count:]",  a5);
LABEL_24:
    unint64_t v17 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v14,  v13);
    objc_exception_throw(v17);
    -[NSMutableDictionary addObjects:forKeys:](v18, v19, v20, v21);
    return;
  }

  if (a5)
  {
    int v10 = 0LL;
    do
    {
      if (!a3[v10]) {
        goto LABEL_19;
      }
      ++v10;
    }

    while (a5 != v10);
    if (a4)
    {
      int v10 = 0LL;
      while (a4[v10])
      {
        if (a5 == ++v10)
        {
          do
          {
            if (!-[NSDictionary objectForKey:](self, "objectForKey:", *a4)) {
              -[NSMutableDictionary setObject:forKey:](self, "setObject:forKey:", *a3, *a4);
            }
            ++a3;
            ++a4;
            --a5;
          }

          while (a5);
          return;
        }
      }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFIndex v16 = _os_log_pack_fill();
    *(_DWORD *)CFIndex v16 = 136315138;
    *(void *)(v16 + 4) = "-[NSMutableDictionary addObjects:forKeys:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: keys argument is not an NSArray",  "-[NSMutableDictionary addObjects:forKeys:]");
    goto LABEL_16;
  }

  int v8 = [a3 count];
  int v9 = [a4 count];
  if (v8 != v9) {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of objects (%lu) differs from count of keys (%lu)",  "-[NSMutableDictionary addObjects:forKeys:]",  v8,  v9);
  }
  int v10 = [a3 count];
  if (v10)
  {
    unint64_t v11 = v10;
    for (uint64_t i = 0LL; i != v11; ++i)
      -[NSMutableDictionary addObject:forKey:]( self,  "addObject:forKey:",  [a3 objectAtIndex:i],  objc_msgSend(a4, "objectAtIndex:", i));
  }

  if (self == a3)
  {
    [a3 removeAllObjects];
  }

  else
  {
    id v20 = 0u;
    uint64_t v21 = 0u;
    unint64_t v18 = 0u;
    uint64_t v19 = 0u;
    uint64_t v6 = [a3 countByEnumeratingWithState:&v18 objects:v17 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      int v8 = *(void *)v19;
      do
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v19 != v8) {
            objc_enumerationMutation(a3);
          }
          -[NSMutableDictionary removeObjectForKey:]( self,  "removeObjectForKey:",  *(void *)(*((void *)&v18 + 1) + 8 * i));
        }

        uint64_t v7 = [a3 countByEnumeratingWithState:&v18 objects:v17 count:16];
      }

      while (v7);
    }
  }

  id v20 = 0u;
  uint64_t v21 = 0u;
  unint64_t v18 = 0u;
  uint64_t v19 = 0u;
  uint64_t v6 = -[NSArray countByEnumeratingWithState:objects:count:]( keyArray,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = *(void *)v19;
    do
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v19 != v8) {
          objc_enumerationMutation(keyArray);
        }
        -[NSMutableDictionary removeObjectForKey:]( self,  "removeObjectForKey:",  *(void *)(*((void *)&v18 + 1) + 8 * i));
      }

      uint64_t v7 = -[NSArray countByEnumeratingWithState:objects:count:]( keyArray,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
    }

    while (v7);
  }

  if (a5 >> 61)
  {
    CFIndex v16 = _os_log_pack_size();
    unint64_t v17 = (char *)v25 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v18 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v18 = 136315394;
    *(void *)(v18 + 4) = "-[NSMutableDictionary replaceObjects:forKeys:count:]";
    *(_WORD *)(v18 + 12) = 2048;
    *(void *)(v18 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableDictionary replaceObjects:forKeys:count:]",  a5);
LABEL_22:
    id v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v17,  v16);
    objc_exception_throw(v20);
    -[NSMutableDictionary replaceObjects:forKeys:](v21, v22, v23, v24);
    return;
  }

  if (a5)
  {
    int v10 = 0LL;
    do
    {
      if (!a3[v10]) {
        goto LABEL_17;
      }
      ++v10;
    }

    while (a5 != v10);
    if (a4)
    {
      int v10 = 0LL;
      while (a4[v10])
      {
        if (a5 == ++v10)
        {
          do
          {
            uint64_t v12 = (uint64_t)*a3++;
            unint64_t v11 = v12;
            uint64_t v13 = (uint64_t)*a4++;
            -[NSMutableDictionary replaceObject:forKey:](self, "replaceObject:forKey:", v11, v13);
            --a5;
          }

          while (a5);
          return;
        }
      }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFIndex v16 = _os_log_pack_fill();
    *(_DWORD *)CFIndex v16 = 136315138;
    *(void *)(v16 + 4) = "-[NSMutableDictionary replaceObjects:forKeys:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: keys argument is not an NSArray",  "-[NSMutableDictionary replaceObjects:forKeys:]");
    goto LABEL_16;
  }

  int v8 = [a3 count];
  int v9 = [a4 count];
  if (v8 != v9) {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of objects (%lu) differs from count of keys (%lu)",  "-[NSMutableDictionary replaceObjects:forKeys:]",  v8,  v9);
  }
  int v10 = [a3 count];
  if (v10)
  {
    unint64_t v11 = v10;
    for (uint64_t i = 0LL; i != v11; ++i)
      -[NSMutableDictionary replaceObject:forKey:]( self,  "replaceObject:forKey:",  [a3 objectAtIndex:i],  objc_msgSend(a4, "objectAtIndex:", i));
  }

  if (self != a3)
  {
    id v20 = 0u;
    uint64_t v21 = 0u;
    unint64_t v18 = 0u;
    uint64_t v19 = 0u;
    uint64_t v6 = [a3 countByEnumeratingWithState:&v18 objects:v17 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      int v8 = *(void *)v19;
      do
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v19 != v8) {
            objc_enumerationMutation(a3);
          }
          -[NSMutableDictionary setObject:forKey:]( self,  "setObject:forKey:",  [a3 objectForKey:*(void *)(*((void *)&v18 + 1) + 8 * i)],  *(void *)(*((void *)&v18 + 1) + 8 * i));
        }

        uint64_t v7 = [a3 countByEnumeratingWithState:&v18 objects:v17 count:16];
      }

      while (v7);
    }
  }

  if (a5 >> 61)
  {
    CFIndex v16 = _os_log_pack_size();
    unint64_t v17 = (char *)v25 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v18 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v18 = 136315394;
    *(void *)(v18 + 4) = "-[NSMutableDictionary setObjects:forKeys:count:]";
    *(_WORD *)(v18 + 12) = 2048;
    *(void *)(v18 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableDictionary setObjects:forKeys:count:]",  a5);
LABEL_22:
    id v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v17,  v16);
    objc_exception_throw(v20);
    -[NSMutableDictionary setObjects:forKeys:](v21, v22, v23, v24);
    return;
  }

  if (a5)
  {
    int v10 = 0LL;
    do
    {
      if (!a3[v10]) {
        goto LABEL_17;
      }
      ++v10;
    }

    while (a5 != v10);
    if (a4)
    {
      int v10 = 0LL;
      while (a4[v10])
      {
        if (a5 == ++v10)
        {
          do
          {
            uint64_t v12 = (uint64_t)*a3++;
            unint64_t v11 = v12;
            uint64_t v13 = (uint64_t)*a4++;
            -[NSMutableDictionary setObject:forKey:](self, "setObject:forKey:", v11, v13);
            --a5;
          }

          while (a5);
          return;
        }
      }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v19 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v14 = 136315138;
    *(void *)(v14 + 4) = "-[NSMutableDictionary setObjects:forKeys:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: keys argument is not an NSArray",  "-[NSMutableDictionary setObjects:forKeys:]");
    goto LABEL_16;
  }

  int v8 = [a3 count];
  int v9 = [a4 count];
  if (v8 != v9) {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of objects (%lu) differs from count of keys (%lu)",  "-[NSMutableDictionary setObjects:forKeys:]",  v8,  v9);
  }
  if (v8)
  {
    for (uint64_t i = 0LL; i != v8; ++i)
      -[NSMutableDictionary setObject:forKey:]( self,  "setObject:forKey:",  [a3 objectAtIndex:i],  objc_msgSend(a4, "objectAtIndex:", i));
  }

  if (self != (NSMutableDictionary *)otherDictionary)
  {
    -[NSMutableDictionary removeAllObjects](self, "removeAllObjects");
    id v20 = 0u;
    uint64_t v21 = 0u;
    unint64_t v18 = 0u;
    uint64_t v19 = 0u;
    uint64_t v6 = -[NSDictionary countByEnumeratingWithState:objects:count:]( otherDictionary,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
    if (v6)
    {
      uint64_t v7 = v6;
      int v8 = *(void *)v19;
      do
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v19 != v8) {
            objc_enumerationMutation(otherDictionary);
          }
          -[NSMutableDictionary setObject:forKey:]( self,  "setObject:forKey:",  -[NSDictionary objectForKey:](otherDictionary, "objectForKey:", *(void *)(*((void *)&v18 + 1) + 8 * i)),  *(void *)(*((void *)&v18 + 1) + 8 * i));
        }

        uint64_t v7 = -[NSDictionary countByEnumeratingWithState:objects:count:]( otherDictionary,  "countByEnumeratingWithState:objects:count:",  &v18,  v17,  16LL);
      }

      while (v7);
    }
  }

    uint64_t v4 = -1LL;
    goto LABEL_5;
  }

  return 0LL;
}

  uint64_t v6 = +[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", otherArray);
  id v20 = 0u;
  uint64_t v21 = 0u;
  unint64_t v22 = 0u;
  uint64_t v23 = 0u;
  uint64_t v7 = -[NSArray countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
  if (!v7) {
    return 0LL;
  }
  int v8 = v7;
  int v9 = *(void *)v21;
LABEL_6:
  int v10 = 0LL;
  while (1)
  {
    if (*(void *)v21 != v9) {
      objc_enumerationMutation(self);
    }
    unint64_t v11 = *(void **)(*((void *)&v20 + 1) + 8 * v10);
    if (-[NSSet containsObject:](v6, "containsObject:", v11)) {
      return v11;
    }
    if (v8 == ++v10)
    {
      int v8 = -[NSArray countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v20,  v19,  16LL);
      if (v8) {
        goto LABEL_6;
      }
      return 0LL;
    }
  }

  if (a4 >> 61)
  {
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v14 = 136315394;
    *(void *)(v14 + 4) = "-[NSMutableArray addObjects:count:]";
    *(_WORD *)(v14 + 12) = 2048;
    *(void *)(v14 + 14) = a4;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableArray addObjects:count:]",  a4);
LABEL_15:
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v11);
    objc_exception_throw(v15);
  }

  if (a4)
  {
    int v8 = 0LL;
    while (a3[v8])
    {
      if (a4 == ++v8) {
        goto LABEL_9;
      }
    }

    a4 = _os_log_pack_size();
    int v9 = _os_log_pack_fill();
    *(_DWORD *)int v9 = 136315394;
    *(void *)(v9 + 4) = "-[NSMutableArray addObjects:count:]";
    *(_WORD *)(v9 + 12) = 2048;
    *(void *)(v9 + 14) = v8;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableArray addObjects:count:]",  v8);
    int v10 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v16 - ((a4 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a4);
    objc_exception_throw(v10);
    goto LABEL_13;
  }

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableArray insertObjectsFromArray:range:atIndex:]( self,  "insertObjectsFromArray:range:atIndex:",  a3,  location,  length,  -[NSArray count](self, "count"));
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = _os_log_pack_fill();
  uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableArray addObjectsFromArray:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v13,  "-[NSMutableArray addObjectsFromArray:range:]",  location,  length);
LABEL_14:
  uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
  objc_exception_throw(v19);
  -[NSMutableArray addObjectsFromArray:](v20, v21, v22);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]( self,  "insertObjectsFromOrderedSet:range:atIndex:",  a3,  location,  length,  -[NSArray count](self, "count"));
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  unint64_t v11 = (char *)v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = _os_log_pack_fill();
  uint64_t v13 = __os_log_helper_1_2_3_8_32_8_0_8_0( v12,  (uint64_t)"-[NSMutableArray addObjectsFromOrderedSet:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v13,  "-[NSMutableArray addObjectsFromOrderedSet:range:]",  location,  length);
LABEL_14:
  uint64_t v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
  objc_exception_throw(v19);
  -[NSMutableArray addObjectsFromOrderedSet:](v20, v21, v22);
}

  if (a4 >> 61)
  {
    a5 = _os_log_pack_size();
    CFIndex v16 = (char *)v31 - ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v18 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v18 = 136315394;
    *(void *)(v18 + 4) = "-[NSMutableArray insertObjects:count:atIndex:]";
    *(_WORD *)(v18 + 12) = 2048;
    *(void *)(v18 + 14) = a4;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableArray insertObjects:count:atIndex:]",  a4);
    goto LABEL_19;
  }

  if (a4)
  {
    int v10 = 0LL;
    while (a3[v10])
    {
      if (a4 == ++v10) {
        goto LABEL_9;
      }
    }

    uint64_t v13 = _os_log_pack_size();
    a4 = (unint64_t)v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v14 = 136315394;
    *(void *)(v14 + 4) = "-[NSMutableArray insertObjects:count:atIndex:]";
    *(_WORD *)(v14 + 12) = 2048;
    *(void *)(v14 + 14) = v10;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableArray insertObjects:count:atIndex:]",  v10);
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  a4,  v13);
    objc_exception_throw(v15);
    goto LABEL_17;
  }

  unint64_t v11 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v11 < location + length)
  {
    if (v11)
    {
      unint64_t v37 = v11;
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v39 = _os_log_pack_fill();
      uint64_t v40 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v39,  (uint64_t)"-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  location,  length,  --v37);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v40,  "-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  location,  length,  v37);
    }

    else
    {
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v22 = _os_log_pack_fill();
      uint64_t v23 = __os_log_helper_1_2_3_8_32_8_0_8_0( v22,  (uint64_t)"-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v23,  "-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  location,  length);
    }

    int v24 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v21,  v19);
    objc_exception_throw(v24);
    goto LABEL_29;
  }

  uint64_t v12 = -[NSArray count](self, "count");
  if ((a5 & 0x8000000000000000LL) != 0 || v12 < a5)
  {
    if (v12)
    {
      uint64_t v41 = v12;
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = _os_log_pack_fill();
      uint64_t v44 = __os_log_helper_1_2_3_8_32_8_0_8_0( v43,  (uint64_t)"-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  a5,  --v41);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v44,  "-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  a5,  v41);
    }

    else
    {
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v28 = _os_log_pack_fill();
      *(_DWORD *)unint64_t v28 = 136315394;
      *(void *)(v28 + 4) = "-[NSMutableArray insertObjectsFromArray:range:atIndex:]";
      *(_WORD *)(v28 + 12) = 2048;
      *(void *)(v28 + 14) = a5;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjectsFromArray:range:atIndex:]",  a5);
    }

    unint64_t v29 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v27,  v25);
    objc_exception_throw(v29);
    goto LABEL_29;
  }

  if (length >> 60)
  {
    size_t v30 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v30,  0LL);
    CFRelease(v30);
    objc_exception_throw(v31);
  }

  if (length <= 1) {
    uint64_t v14 = 1LL;
  }
  else {
    uint64_t v14 = length;
  }
  uint64_t v15 = MEMORY[0x1895F8858](v14, v13);
  unint64_t v17 = (char *)v45 - v16;
  if (length >= 0x101)
  {
    unint64_t v17 = (char *)_CFCreateArrayStorage(v15, 0, v45);
    unint64_t v18 = v17;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v17, location, length);
  -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v17, length, a5);
  free(v18);
}

  int v8 = -[NSArray count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0( v30,  (uint64_t)"-[NSMutableArray insertObjectsFromArray:atIndex:]",  a4,  v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableArray insertObjectsFromArray:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableArray insertObjectsFromArray:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjectsFromArray:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v15, 0, v12);
  -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  unint64_t v11 = [a3 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v11 < location + length)
  {
    if (v11)
    {
      unint64_t v37 = v11;
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v39 = _os_log_pack_fill();
      uint64_t v40 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v39,  (uint64_t)"-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  location,  length,  --v37);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v40,  "-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  location,  length,  v37);
    }

    else
    {
      uint64_t v19 = _os_log_pack_size();
      uint64_t v21 = (char *)v45 - ((MEMORY[0x1895F8858](v19, v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v22 = _os_log_pack_fill();
      uint64_t v23 = __os_log_helper_1_2_3_8_32_8_0_8_0( v22,  (uint64_t)"-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v23,  "-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  location,  length);
    }

    int v24 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v21,  v19);
    objc_exception_throw(v24);
    goto LABEL_29;
  }

  uint64_t v12 = -[NSArray count](self, "count");
  if ((a5 & 0x8000000000000000LL) != 0 || v12 < a5)
  {
    if (v12)
    {
      uint64_t v41 = v12;
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = _os_log_pack_fill();
      uint64_t v44 = __os_log_helper_1_2_3_8_32_8_0_8_0( v43,  (uint64_t)"-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  a5,  --v41);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v44,  "-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  a5,  v41);
    }

    else
    {
      unint64_t v25 = _os_log_pack_size();
      uint64_t v27 = (char *)v45 - ((MEMORY[0x1895F8858](v25, v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v28 = _os_log_pack_fill();
      *(_DWORD *)unint64_t v28 = 136315394;
      *(void *)(v28 + 4) = "-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]";
      *(_WORD *)(v28 + 12) = 2048;
      *(void *)(v28 + 14) = a5;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjectsFromOrderedSet:range:atIndex:]",  a5);
    }

    unint64_t v29 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v27,  v25);
    objc_exception_throw(v29);
    goto LABEL_29;
  }

  if (length >> 60)
  {
    size_t v30 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v30,  0LL);
    CFRelease(v30);
    objc_exception_throw(v31);
  }

  if (length <= 1) {
    uint64_t v14 = 1LL;
  }
  else {
    uint64_t v14 = length;
  }
  uint64_t v15 = MEMORY[0x1895F8858](v14, v13);
  unint64_t v17 = (char *)v45 - v16;
  if (length >= 0x101)
  {
    unint64_t v17 = (char *)_CFCreateArrayStorage(v15, 0, v45);
    unint64_t v18 = v17;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v17, location, length);
  -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v17, length, a5);
  free(v18);
}

  int v8 = -[NSArray count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0( v30,  (uint64_t)"-[NSMutableArray insertObjectsFromOrderedSet:atIndex:]",  a4,  v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableArray insertObjectsFromOrderedSet:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableArray insertObjectsFromOrderedSet:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjectsFromOrderedSet:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v15, 0, v12);
  -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  int v8 = -[NSArray count](self, "count");
  int v9 = v8;
  if ((a4 & 0x8000000000000000LL) != 0 || v8 < a4)
  {
    if (v8)
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      size_t v30 = _os_log_pack_fill();
      uint64_t v31 = v9 - 1;
      uint64_t v32 = __os_log_helper_1_2_3_8_32_8_0_8_0(v30, (uint64_t)"-[NSMutableArray insertObjectsFromSet:atIndex:]", a4, v31);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v32,  "-[NSMutableArray insertObjectsFromSet:atIndex:]",  a4,  v31);
    }

    else
    {
      unint64_t v17 = _os_log_pack_size();
      uint64_t v19 = (char *)v33 - ((MEMORY[0x1895F8858](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v20 = _os_log_pack_fill();
      *(_DWORD *)id v20 = 136315394;
      *(void *)(v20 + 4) = "-[NSMutableArray insertObjectsFromSet:atIndex:]";
      *(_WORD *)(v20 + 12) = 2048;
      *(void *)(v20 + 14) = a4;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjectsFromSet:atIndex:]",  a4);
    }

    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v19,  v17);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  int v10 = [a3 count];
  uint64_t v12 = v10;
  if (v10 >> 60)
  {
    unint64_t v22 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v10);
    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v22,  0LL);
    CFRelease(v22);
    objc_exception_throw(v23);
  }

  if (v10 <= 1) {
    int v10 = 1LL;
  }
  uint64_t v13 = MEMORY[0x1895F8858](v10, v11);
  uint64_t v15 = (char *)v33 - v14;
  if (v12 >= 0x101)
  {
    uint64_t v15 = (char *)_CFCreateArrayStorage(v13, 0, v33);
    CFIndex v16 = v15;
  }

  else
  {
    CFIndex v16 = 0LL;
  }

  [a3 getObjects:v15 count:v12];
  -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", v15, v12, a4);
  free(v16);
}

  if (!indexes)
  {
    CFRange v26 = _os_log_pack_size();
    unint64_t v28 = (char *)v50 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v29 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v29 = 136315138;
    *(void *)(v29 + 4) = "-[NSMutableArray insertObjects:atIndexes:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set cannot be nil",  "-[NSMutableArray insertObjects:atIndexes:]");
    size_t v30 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v30);
LABEL_33:
    __break(1u);
    return;
  }

  if ((_NSIsNSIndexSet() & 1) == 0)
  {
    uint64_t v31 = _os_log_pack_size();
    uint64_t v33 = (char *)v50 - ((MEMORY[0x1895F8858](v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v34 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v34 = 136315138;
    *(void *)(v34 + 4) = "-[NSMutableArray insertObjects:atIndexes:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set argument is not an NSIndexSet",  "-[NSMutableArray insertObjects:atIndexes:]");
    v35 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v33,  v31);
    objc_exception_throw(v35);
    goto LABEL_33;
  }

  int v9 = -[NSArray count](self, "count");
  int v10 = -[NSArray count](objects, "count");
  unint64_t v11 = -[NSIndexSet lastIndex](indexes, "lastIndex");
  if ((v11 & 0x8000000000000000LL) != 0)
  {
    char v36 = v11;
    uint64_t v12 = v10 + v9;
LABEL_26:
    unint64_t v37 = _os_log_pack_size();
    uint64_t v39 = (char *)v50 - ((MEMORY[0x1895F8858](v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v40 = _os_log_pack_fill();
    if (v12)
    {
      uint64_t v42 = __os_log_helper_1_2_3_8_32_8_0_8_0(v40, (uint64_t)"-[NSMutableArray insertObjects:atIndexes:]", v36, v12 - 1);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds [0 .. %lu]",  v42,  "-[NSMutableArray insertObjects:atIndexes:]",  v36,  v12 - 1);
    }

    else
    {
      *(_DWORD *)uint64_t v40 = 136315394;
      *(void *)(v40 + 4) = "-[NSMutableArray insertObjects:atIndexes:]";
      *(_WORD *)(v40 + 12) = 2048;
      *(void *)(v40 + 14) = v36;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds for empty array",  "-[NSMutableArray insertObjects:atIndexes:]",  v36);
    }

    uint64_t v41 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v39,  v37);
    objc_exception_throw(v41);
    goto LABEL_33;
  }

  if (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v12 = v10 + v9;
    if (v12 <= v11)
    {
      char v36 = v11;
      goto LABEL_26;
    }
  }

  uint64_t v13 = -[NSArray count](objects, "count");
  uint64_t v14 = -[NSIndexSet count](indexes, "count");
  if (v13 != v14)
  {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of array (%lu) differs from count of index set (%lu)",  "-[NSMutableArray insertObjects:atIndexes:]",  v13,  v14);
LABEL_31:
    uint64_t v43 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v4);
    uint64_t v44 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v43,  0LL);
    CFRelease(v43);
    objc_exception_throw(v44);
  }

  uint64_t v15 = -[NSArray count](objects, "count");
  uint64_t v4 = v15;
  if (v15 >> 60) {
    goto LABEL_31;
  }
  if (v15 <= 1) {
    uint64_t v15 = 1LL;
  }
  unint64_t v17 = MEMORY[0x1895F8858](v15, v16);
  uint64_t v19 = (char *)v50 - v18;
  if (v4 >= 0x101)
  {
    uint64_t v19 = (char *)_CFCreateArrayStorage(v17, 0, v50);
    id v20 = v19;
  }

  else
  {
    id v20 = 0LL;
  }

  -[NSArray getObjects:range:](objects, "getObjects:range:", v19, 0LL, v4);
  uint64_t v21 = 0LL;
  for (uint64_t i = 0LL; i < -[NSIndexSet rangeCount](indexes, "rangeCount"); ++i)
  {
    uint64_t v23 = -[NSIndexSet rangeAtIndex:](indexes, "rangeAtIndex:", i);
    unint64_t v25 = v24;
    -[NSMutableArray insertObjects:count:atIndex:](self, "insertObjects:count:atIndex:", &v19[8 * v21], v24, v23);
    v21 += v25;
  }

  free(v20);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableArray removeObjectsInRange:inArray:range:]( self,  "removeObjectsInRange:inArray:range:",  0LL,  -[NSArray count](self, "count"),  a3,  location,  length);
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  uint64_t v12 = (char *)v26 - ((MEMORY[0x1895F8858](v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = _os_log_pack_fill();
  uint64_t v14 = __os_log_helper_1_2_3_8_32_8_0_8_0( v13,  (uint64_t)"-[NSMutableArray removeObjectsInArray:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v14,  "-[NSMutableArray removeObjectsInArray:range:]",  location,  length);
LABEL_14:
  unint64_t v22 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v10);
  objc_exception_throw(v22);
  -[NSMutableArray removeObjectsInArray:](v23, v24, v25);
}

  int v9 = [a3 count];
  if ((location & 0x8000000000000000LL) == 0 && (length & 0x8000000000000000LL) == 0 && v9 >= location + length)
  {
    -[NSMutableArray removeObjectsInRange:inOrderedSet:range:]( self,  "removeObjectsInRange:inOrderedSet:range:",  0LL,  -[NSArray count](self, "count"),  a3,  location,  length);
    return;
  }

  if (v9) {
    goto LABEL_13;
  }
  int v10 = _os_log_pack_size();
  uint64_t v12 = (char *)v26 - ((MEMORY[0x1895F8858](v10, v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = _os_log_pack_fill();
  uint64_t v14 = __os_log_helper_1_2_3_8_32_8_0_8_0( v13,  (uint64_t)"-[NSMutableArray removeObjectsInOrderedSet:range:]",  location,  length);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v14,  "-[NSMutableArray removeObjectsInOrderedSet:range:]",  location,  length);
LABEL_14:
  unint64_t v22 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v10);
  objc_exception_throw(v22);
  -[NSMutableArray removeObjectsInOrderedSet:](v23, v24, v25);
}

  if (!indexes)
  {
    CFRange v26 = _os_log_pack_size();
    unint64_t v28 = (char *)v50 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v29 = _os_log_pack_fill();
    *(_DWORD *)unint64_t v29 = 136315138;
    *(void *)(v29 + 4) = "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set cannot be nil",  "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]");
    size_t v30 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v30);
LABEL_33:
    __break(1u);
    return;
  }

  if ((_NSIsNSIndexSet() & 1) == 0)
  {
    uint64_t v31 = _os_log_pack_size();
    uint64_t v33 = (char *)v50 - ((MEMORY[0x1895F8858](v31, v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v34 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v34 = 136315138;
    *(void *)(v34 + 4) = "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index set argument is not an NSIndexSet",  "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]");
    v35 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v33,  v31);
    objc_exception_throw(v35);
    goto LABEL_33;
  }

  int v9 = -[NSArray count](self, "count");
  int v10 = -[NSArray count](objects, "count");
  unint64_t v11 = -[NSIndexSet lastIndex](indexes, "lastIndex");
  if ((v11 & 0x8000000000000000LL) != 0)
  {
    char v36 = v11;
    uint64_t v12 = v10 + v9;
LABEL_26:
    unint64_t v37 = _os_log_pack_size();
    uint64_t v39 = (char *)v50 - ((MEMORY[0x1895F8858](v37, v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v40 = _os_log_pack_fill();
    if (v12)
    {
      uint64_t v42 = __os_log_helper_1_2_3_8_32_8_0_8_0( v40,  (uint64_t)"-[NSMutableArray replaceObjectsAtIndexes:withObjects:]",  v36,  v12 - 1);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds [0 .. %lu]",  v42,  "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]",  v36,  v12 - 1);
    }

    else
    {
      *(_DWORD *)uint64_t v40 = 136315394;
      *(void *)(v40 + 4) = "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]";
      *(_WORD *)(v40 + 12) = 2048;
      *(void *)(v40 + 14) = v36;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu in index set beyond bounds for empty array",  "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]",  v36);
    }

    uint64_t v41 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v39,  v37);
    objc_exception_throw(v41);
    goto LABEL_33;
  }

  if (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v12 = v10 + v9;
    if (v12 <= v11)
    {
      char v36 = v11;
      goto LABEL_26;
    }
  }

  uint64_t v13 = -[NSArray count](objects, "count");
  uint64_t v14 = -[NSIndexSet count](indexes, "count");
  if (v13 != v14)
  {
    _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"*** %s: count of array (%lu) differs from count of index set (%lu)",  "-[NSMutableArray replaceObjectsAtIndexes:withObjects:]",  v13,  v14);
LABEL_31:
    uint64_t v43 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v4);
    uint64_t v44 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v43,  0LL);
    CFRelease(v43);
    objc_exception_throw(v44);
  }

  uint64_t v15 = -[NSArray count](objects, "count");
  uint64_t v4 = v15;
  if (v15 >> 60) {
    goto LABEL_31;
  }
  if (v15 <= 1) {
    uint64_t v15 = 1LL;
  }
  unint64_t v17 = MEMORY[0x1895F8858](v15, v16);
  uint64_t v19 = (char *)v50 - v18;
  if (v4 >= 0x101)
  {
    uint64_t v19 = (char *)_CFCreateArrayStorage(v17, 0, v50);
    id v20 = v19;
  }

  else
  {
    id v20 = 0LL;
  }

  -[NSArray getObjects:range:](objects, "getObjects:range:", v19, 0LL, v4);
  uint64_t v21 = 0LL;
  for (uint64_t i = 0LL; i < -[NSIndexSet rangeCount](indexes, "rangeCount"); ++i)
  {
    uint64_t v23 = -[NSIndexSet rangeAtIndex:](indexes, "rangeAtIndex:", i);
    unint64_t v25 = v24;
    -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  v23,  v24,  &v19[8 * v21],  v24);
    v21 += v25;
  }

  free(v20);
}

  uint64_t v12 = -[NSArray count](otherArray, "count");
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v12 < location + length)
  {
    if (v12)
    {
      uint64_t v39 = v12;
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v41 = _os_log_pack_fill();
      uint64_t v42 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v41,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length,  --v39);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v42,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length,  v39);
    }

    else
    {
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = _os_log_pack_fill();
      int v24 = __os_log_helper_1_2_3_8_32_8_0_8_0( v23,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v24,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  location,  length);
    }

    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v20);
    objc_exception_throw(v25);
    goto LABEL_30;
  }

  uint64_t v13 = -[NSArray count](self, "count");
  if ((v10 & 0x8000000000000000LL) != 0 || (v9 & 0x8000000000000000LL) != 0 || v13 < v10 + v9)
  {
    if (v13)
    {
      uint64_t v43 = v13;
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v45 = _os_log_pack_fill();
      uint64_t v46 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v45,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9,  --v43);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v46,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9,  v43);
    }

    else
    {
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v29 = _os_log_pack_fill();
      size_t v30 = __os_log_helper_1_2_3_8_32_8_0_8_0( v29,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v30,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:range:]",  v10,  v9);
    }

    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v31);
    goto LABEL_30;
  }

  if (length >> 60)
  {
    uint64_t v32 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v33 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v32,  0LL);
    CFRelease(v32);
    objc_exception_throw(v33);
  }

  if (length <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = length;
  }
  CFIndex v16 = MEMORY[0x1895F8858](v15, v14);
  unint64_t v18 = (char *)v47 - v17;
  if (length >= 0x101)
  {
    unint64_t v18 = (char *)_CFCreateArrayStorage(v16, 0, v47);
    uint64_t v19 = v18;
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  -[NSArray getObjects:range:](otherArray, "getObjects:range:", v18, location, length);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  v10,  v9,  v18,  length);
  free(v19);
}

  int v9 = -[NSArray count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v22,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromArray:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = -[NSArray count](otherArray, "count");
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  -[NSArray getObjects:range:](otherArray, "getObjects:range:", v16, 0LL, v13);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  uint64_t v12 = [a4 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v12 < location + length)
  {
    if (v12)
    {
      uint64_t v39 = v12;
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v41 = _os_log_pack_fill();
      uint64_t v42 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v41,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length,  --v39);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v42,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length,  v39);
    }

    else
    {
      id v20 = _os_log_pack_size();
      unint64_t v22 = (char *)v47 - ((MEMORY[0x1895F8858](v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = _os_log_pack_fill();
      int v24 = __os_log_helper_1_2_3_8_32_8_0_8_0( v23,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v24,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  location,  length);
    }

    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v20);
    objc_exception_throw(v25);
    goto LABEL_30;
  }

  uint64_t v13 = -[NSArray count](self, "count");
  if ((v10 & 0x8000000000000000LL) != 0 || (v9 & 0x8000000000000000LL) != 0 || v13 < v10 + v9)
  {
    if (v13)
    {
      uint64_t v43 = v13;
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v45 = _os_log_pack_fill();
      uint64_t v46 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v45,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9,  --v43);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v46,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9,  v43);
    }

    else
    {
      CFRange v26 = _os_log_pack_size();
      unint64_t v28 = (char *)v47 - ((MEMORY[0x1895F8858](v26, v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v29 = _os_log_pack_fill();
      size_t v30 = __os_log_helper_1_2_3_8_32_8_0_8_0( v29,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v30,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:range:]",  v10,  v9);
    }

    uint64_t v31 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v28,  v26);
    objc_exception_throw(v31);
    goto LABEL_30;
  }

  if (length >> 60)
  {
    uint64_t v32 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    uint64_t v33 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v32,  0LL);
    CFRelease(v32);
    objc_exception_throw(v33);
  }

  if (length <= 1) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = length;
  }
  CFIndex v16 = MEMORY[0x1895F8858](v15, v14);
  unint64_t v18 = (char *)v47 - v17;
  if (length >= 0x101)
  {
    unint64_t v18 = (char *)_CFCreateArrayStorage(v16, 0, v47);
    uint64_t v19 = v18;
  }

  else
  {
    uint64_t v19 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v18, location, length);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  v10,  v9,  v18,  length);
  free(v19);
}

  int v9 = -[NSArray count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v22,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromOrderedSet:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = [a4 count];
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  objc_msgSend(a4, "getObjects:range:", v16, 0, v13);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  int v9 = -[NSArray count](self, "count");
  int v10 = v9;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v9 < location + length)
  {
    if (v9)
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = _os_log_pack_fill();
      uint64_t v33 = v10 - 1;
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v32,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromSet:]",  location,  length,  v33);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromSet:]",  location,  length,  v33);
    }

    else
    {
      unint64_t v18 = _os_log_pack_size();
      id v20 = (char *)v35 - ((MEMORY[0x1895F8858](v18, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = _os_log_pack_fill();
      unint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableArray replaceObjectsInRange:withObjectsFromSet:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v22,  "-[NSMutableArray replaceObjectsInRange:withObjectsFromSet:]",  location,  length);
    }

    uint64_t v23 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v20,  v18);
    objc_exception_throw(v23);
    goto LABEL_22;
  }

  unint64_t v11 = [a4 count];
  uint64_t v13 = v11;
  if (v11 >> 60)
  {
    int v24 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v11);
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v24,  0LL);
    CFRelease(v24);
    objc_exception_throw(v25);
  }

  if (v11 <= 1) {
    unint64_t v11 = 1LL;
  }
  uint64_t v14 = MEMORY[0x1895F8858](v11, v12);
  CFIndex v16 = (char *)v35 - v15;
  if (v13 >= 0x101)
  {
    CFIndex v16 = (char *)_CFCreateArrayStorage(v14, 0, v35);
    unint64_t v17 = v16;
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  [a4 getObjects:v16 count:v13];
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  location,  length,  v16,  v13);
  free(v17);
}

  if (self == (NSMutableArray *)otherArray) {
    return;
  }
  uint64_t v6 = -[NSArray count](self, "count");
  uint64_t v7 = -[NSArray count](otherArray, "count");
  int v9 = (size_t *)v7;
  if (v7 >> 60)
  {
LABEL_16:
    uint64_t v19 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v9);
    id v20 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v19,  0LL);
    CFRelease(v19);
    objc_exception_throw(v20);
    _Unwind_Resume(v21);
  }

  if (v7 <= 1) {
    uint64_t v7 = 1LL;
  }
  int v10 = MEMORY[0x1895F8858](v7, v8);
  uint64_t v12 = (char *)v22 - v11;
  if ((unint64_t)v9 >= 0x101)
  {
    uint64_t v12 = (char *)_CFCreateArrayStorage(v10, 0, v22);
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  -[NSArray getObjects:range:](otherArray, "getObjects:range:", v12, 0LL, v9);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  0LL,  v6,  v12,  v9);
  free(v13);
}

  uint64_t v6 = -[NSArray count](self, "count");
  uint64_t v7 = [a3 count];
  int v9 = v7;
  if (v7 >> 60)
  {
    uint64_t v14 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v7);
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v14,  0LL);
    CFRelease(v14);
    objc_exception_throw(v15);
  }

  if (v7 <= 1) {
    uint64_t v7 = 1LL;
  }
  int v10 = MEMORY[0x1895F8858](v7, v8);
  uint64_t v12 = (char *)v21 - v11;
  if (v9 >= 0x101)
  {
    uint64_t v12 = (char *)_CFCreateArrayStorage(v10, 0, v21);
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  objc_msgSend(a3, "getObjects:range:", v12, 0, v9);
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  0LL,  v6,  v12,  v9);
  free(v13);
}

  uint64_t v6 = -[NSArray count](self, "count");
  uint64_t v7 = [a3 count];
  int v9 = v7;
  if (v7 >> 60)
  {
    uint64_t v14 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v7);
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v14,  0LL);
    CFRelease(v14);
    objc_exception_throw(v15);
  }

  if (v7 <= 1) {
    uint64_t v7 = 1LL;
  }
  int v10 = MEMORY[0x1895F8858](v7, v8);
  uint64_t v12 = (char *)v21 - v11;
  if (v9 >= 0x101)
  {
    uint64_t v12 = (char *)_CFCreateArrayStorage(v10, 0, v21);
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  [a3 getObjects:v12 count:v9];
  -[NSMutableArray replaceObjectsInRange:withObjects:count:]( self,  "replaceObjectsInRange:withObjects:count:",  0LL,  v6,  v12,  v9);
  free(v13);
}

  if (a5 >> 61)
  {
    uint64_t v15 = _os_log_pack_size();
    unint64_t v17 = (char *)v22 - ((MEMORY[0x1895F8858](v15, v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v20 = _os_log_pack_fill();
    *(_DWORD *)id v20 = 136315394;
    *(void *)(v20 + 4) = "-[__NSSetM countByEnumeratingWithState:objects:count:]";
    *(_WORD *)(v20 + 12) = 2048;
    *(void *)(v20 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[__NSSetM countByEnumeratingWithState:objects:count:]",  a5);
LABEL_23:
    uint64_t v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v17,  v15);
    objc_exception_throw(v21);
  }

  var0 = a3->var0;
  unint64_t v11 = *(unsigned int *)((char *)__NSSetSizes_0
                        + (((unint64_t)*((unsigned int *)&self->storage.var0.var0 + 1) >> 23) & 0x1F8));
  if (!a3->var0) {
    a3->var2 = &self->storage.var0.mutations;
  }
  if (var0 >= v11) {
    return 0LL;
  }
  a3->var1 = a4;
  double result = 0LL;
  if (a5)
  {
    do
    {
      uint64_t v13 = self->storage.objs[var0];
      if (v13) {
        uint64_t v14 = v13 == (state *)&___NSSetM_DeletedMarker;
      }
      else {
        uint64_t v14 = 1;
      }
      if (!v14) {
        a4[result++] = v13;
      }
      ++var0;
    }

    while (var0 < v11 && result < a5);
  }

  a3->var0 = var0;
  return result;
}

  if (a5 >> 61)
  {
    CFIndex v16 = _os_log_pack_size();
    unint64_t v18 = (char *)v23 - ((MEMORY[0x1895F8858](v16, v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v21 = 136315394;
    *(void *)(v21 + 4) = "-[__NSDictionaryM countByEnumeratingWithState:objects:count:]";
    *(_WORD *)(v21 + 12) = 2048;
    *(void *)(v21 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[__NSDictionaryM countByEnumeratingWithState:objects:count:]",  a5);
LABEL_23:
    unint64_t v22 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v18,  v16);
    objc_exception_throw(v22);
  }

  var0 = a3->var0;
  unint64_t v11 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((self->storage.var0.var0.mutations >> 55) & 0x1F8));
  if (!a3->var0) {
    a3->var2 = &self->storage.var0.var0.mutations;
  }
  if (var0 >= v11) {
    return 0LL;
  }
  buffer = self->storage.buffer;
  a3->var1 = a4;
  double result = 0LL;
  if (a5)
  {
    do
    {
      uint64_t v14 = buffer[var0];
      if (v14) {
        uint64_t v15 = v14 == (state *)&___NSDictionaryM_DeletedMarker;
      }
      else {
        uint64_t v15 = 1;
      }
      if (!v15) {
        a4[result++] = v14;
      }
      ++var0;
    }

    while (var0 < v11 && result < a5);
  }

  a3->var0 = var0;
  return result;
}

void sub_180A547F8(_Unwind_Exception *a1)
{
}

LABEL_8:
  CFRange v26 = 0u;
  uint64_t v27 = 0u;
  int v24 = 0u;
  unint64_t v25 = 0u;
  uint64_t v13 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v24,  v23,  16LL);
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v14; ++i)
      {
        if (*(void *)v25 != v15) {
          objc_enumerationMutation(v4);
        }
        -[NSMutableSet addObject:](self, "addObject:", *(void *)(*((void *)&v24 + 1) + 8 * i));
      }

      uint64_t v14 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v24,  v23,  16LL);
    }

    while (v14);
  }

  if (self == (__NSPlaceholderArray *)&___immutablePlaceholderArray)
  {
    if (a4 == 1)
    {
      return (__NSPlaceholderArray *)__NSSingleObjectArrayI_new((uint64_t)*a3, 0);
    }

    else if (a4)
    {
      return (__NSPlaceholderArray *)__NSArrayI_new((id *)a3, 0LL, a4, 0);
    }

    else
    {
      return (__NSPlaceholderArray *)&__NSArray0__struct;
    }
  }

  else if (self == (__NSPlaceholderArray *)&___mutablePlaceholderArray)
  {
    return (__NSPlaceholderArray *)__NSArrayM_new(a3, a4, 0);
  }

  else
  {
    __break(1u);
  }

  return self;
}

      ++v6;
LABEL_9:
      if (!v3) {
        return v6;
      }
    }

  uint64_t v7 = -[NSMutableOrderedSet initWithCapacity:](self, "initWithCapacity:", a4);
  -[NSMutableOrderedSet insertObjects:count:atIndex:](v7, "insertObjects:count:atIndex:", a3, v4, 0LL);
  return v7;
}

  if (self == (__NSPlaceholderSet *)&___immutablePlaceholderSet)
  {
    if (a4 == 1)
    {
      return (__NSPlaceholderSet *)__NSSingleObjectSetI_new((uint64_t)*a3, 0);
    }

    else if (a4)
    {
      return (__NSPlaceholderSet *)__NSSetI_new((uint64_t *)a3, 0LL, a4, 0);
    }

    else
    {
      return (__NSPlaceholderSet *)(id)__NSSet0__;
    }
  }

  else if (self == (__NSPlaceholderSet *)&___mutablePlaceholderSet)
  {
    return (__NSPlaceholderSet *)__NSSetM_new((uint64_t)a3, a4, 0);
  }

  else
  {
    __break(1u);
  }

  return self;
}

  uint64_t v14 = *((void *)cf + 4);
  if (v14 && (*(void *)(v14 + 48) & v13) != 0 && (*(void *)(v14 + 72) & v13) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    uint64_t v15 = *((void *)cf + 4);
    if (v15 && (CFIndex v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0LL)
    {
      CFRetain(*(CFTypeRef *)(v15 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      *(void *)(*((void *)cf + 4) + 72LL) |= v13;
      if (v8
        && (cf[16] & 0x40) == 0
        && (Current = CFRunLoopGetCurrent(), (unint64_t v18 = CFRunLoopCopyCurrentMode(Current)) != 0LL)
        && (uint64_t v19 = v18, v20 = CFRunLoopContainsSource(Current, v16, v18), CFRelease(v19), v20))
      {
        _cfstream_solo_signalEventSync((uint64_t)cf);
      }

      else
      {
        CFRunLoopSourceSignal(v16);
        _wakeUpRunLoop((uint64_t)cf);
      }

      CFRelease(v16);
    }

    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }

    CFCharacterSetInitInlineBuffer((__objc2_class **)__CFStringFillCharacterSetInlineBuffer_nonAlnumChars, a1);
  }

  return (a2 >> 16) & 1;
}

  *a3 = a2;
  return a2 != 65533;
}

  if (_CFURLCacheResourcePropertiesForKeys((__objc2_class **)v9)
    && CFURLCopyResourcePropertyForKey((CFURLRef)v9, @"NSURLIsDirectoryKey", &propertyValueTypeRefPtr, error))
  {
    if (propertyValueTypeRefPtr)
    {
      if (CFBooleanGetValue(propertyValueTypeRefPtr))
      {
        uint64_t v14 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0LL, 1, 0LL);
        if (v14)
        {
          uint64_t v15 = v14;
          if (atomic_load(v9 + 6)) {
            atomic_store(_FileCacheCreateShallowCopy(), v15 + 6);
          }
          CFRelease(v9);
          int v9 = v15;
        }
      }

      CFRelease(propertyValueTypeRefPtr);
    }
  }

  else
  {
    CFRelease(v9);
    int v9 = 0LL;
  }

  if (Copy) {
    CFRelease(Copy);
  }
  if (!v9) {
    goto LABEL_21;
  }
  return v9;
}

  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1LL;
  }

  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    uint64_t v4 = a2 + 64;
    goto LABEL_16;
  }

  uint64_t v6 = (unsigned __int16 *)&__CFToJISCharMap;
  uint64_t v7 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    int v8 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v7 - v6)) >> 1;
    int v9 = &v6[17 * v8];
    int v10 = *v9;
    if (v10 <= a2) {
      break;
    }
    uint64_t v7 = v9 - 17;
LABEL_24:
    if (v6 > v7) {
      goto LABEL_33;
    }
  }

  if (v10 + 16 <= a2)
  {
    uint64_t v6 = v9 + 17;
    goto LABEL_24;
  }

  unint64_t v11 = v6[17 * v8 + 1 + (int)(a2 - v10)];
  else {
    uint64_t v12 = 1;
  }
  if (!v12 && (unsigned __int16)(v11 - 10529) >= 0x62Eu)
  {
    JIS0208ToShiftJIS(v11, a3);
    return 2LL;
  }

  if (&OBJC_CLASS___NSArray == a1)
  {
    if (a4 == 1)
    {
      return (id)__NSSingleObjectArrayI_new((uint64_t)*a3, 1);
    }

    else if (a4)
    {
      return (id)__NSArrayI_new((id *)a3, 0LL, a4, 1);
    }

    else
    {
      return &__NSArray0__struct;
    }
  }

  else if (&OBJC_CLASS___NSMutableArray == a1)
  {
    return (id)__NSArrayM_new(a3, a4, 1);
  }

  else
  {
    uint64_t v7 = __CFLookUpClass("NSArray");
    __CFRequireConcreteImplementation(v7, (uint64_t)a1);
    return 0LL;
  }

  uint64_t v5 = (objc_class *)objc_opt_self();
  double result = (__NSPlaceholderDate *)__CFAllocateObject(v5, 0LL);
  *(double *)&result[1].super.super.isa = a3;
  return result;
}

  uint64_t v7 = -[NSMutableArray initWithCapacity:](self, "initWithCapacity:", a4);
  -[NSMutableArray insertObjects:count:atIndex:](v7, "insertObjects:count:atIndex:", a3, v4, 0LL);
  return v7;
}

  if (&OBJC_CLASS___NSSet == a1)
  {
    if (a4 == 1)
    {
      return (id)__NSSingleObjectSetI_new((uint64_t)*a3, 1);
    }

    else if (a4)
    {
      return (id)__NSSetI_new((uint64_t *)a3, 0LL, a4, 1);
    }

    else
    {
      return (id)__NSSet0__;
    }
  }

  else if (&OBJC_CLASS___NSMutableSet == a1)
  {
    return (id)__NSSetM_new((uint64_t)a3, a4, 0);
  }

  else
  {
    uint64_t v7 = __CFLookUpClass("NSSet");
    __CFRequireConcreteImplementation(v7, (uint64_t)a1);
    return 0LL;
  }

  int v8 = (objc_class *)objc_opt_self();
  int v9 = (void *)__CFAllocateObject(v8, 0LL);
  int v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  int v9 = (objc_class *)objc_opt_self();
  int v10 = (void *)__CFAllocateObject(v9, 0LL);
  unint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

  if (&OBJC_CLASS___NSOrderedSet == a1) {
    return (id)__NSOrderedSetI_new((uint64_t)a3, a4, 1);
  }
  if (&OBJC_CLASS___NSMutableOrderedSet == a1) {
    return __NSOrderedSetM_new((id *)a3, a4, 1);
  }
  uint64_t v7 = __CFLookUpClass("NSOrderedSet");
  __CFRequireConcreteImplementation(v7, (uint64_t)a1);
  return 0LL;
}

void sub_180A54EE0(_Unwind_Exception *a1)
{
}

LABEL_17:
  uint64_t v34 = 0u;
  v35 = 0u;
  uint64_t v32 = 0u;
  uint64_t v33 = 0u;
  uint64_t v19 = [a3 countByEnumeratingWithState:&v32 objects:v31 count:16];
  if (v19)
  {
    id v20 = v19;
    uint64_t v21 = *(void *)v33;
    do
    {
      for (j = 0LL; j != v20; ++j)
      {
        if (*(void *)v33 != v21) {
          objc_enumerationMutation(a3);
        }
        -[NSMutableSet addObject:](self, "addObject:", *(void *)(*((void *)&v32 + 1) + 8 * j));
      }

      id v20 = [a3 countByEnumeratingWithState:&v32 objects:v31 count:16];
    }

    while (v20);
  }

  if (otherSet == (NSSet *)self) {
    return;
  }
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  char v51 = 0u;
  unint64_t v18 = 0LL;
  id v20 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v50,  v49,  16LL);
  if (v20)
  {
    uint64_t v21 = *(void *)v51;
    do
    {
      for (j = 0LL; j != v20; ++j)
      {
        if (*(void *)v51 != v21) {
          objc_enumerationMutation(self);
        }
        v18 += -[NSSet countForObject:](self, "countForObject:", *(void *)(*((void *)&v50 + 1) + 8 * j));
      }

      id v20 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v50,  v49,  16LL);
    }

    while (v20);
    if (v18 >> 60)
    {
      uint64_t v40 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v18);
      uint64_t v41 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v40,  0LL);
      CFRelease(v40);
      objc_exception_throw(v41);
      goto LABEL_50;
    }
  }

  if (v18 <= 1) {
    uint64_t v23 = 1LL;
  }
  else {
    uint64_t v23 = v18;
  }
  int v24 = MEMORY[0x1895F8858](v23, v19);
  CFRange v26 = (uint64_t *)((char *)&v42 - v25);
  if (v18 >= 0x101)
  {
    CFRange v26 = (uint64_t *)_CFCreateArrayStorage(v24, 0, v54);
    uint64_t v43 = v26;
  }

  else
  {
    uint64_t v43 = 0LL;
  }

  uint64_t v42 = (uint64_t)&v42;
  uint64_t v47 = 0u;
  uint64_t v48 = 0u;
  uint64_t v45 = 0u;
  uint64_t v46 = 0u;
  uint64_t v27 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v45,  v44,  16LL);
  unint64_t v28 = v26;
  if (v27)
  {
    unint64_t v29 = *(void *)v46;
    unint64_t v28 = v26;
    do
    {
      for (k = 0LL; k != v27; ++k)
      {
        if (*(void *)v46 != v29) {
          objc_enumerationMutation(self);
        }
        uint64_t v31 = *(void *)(*((void *)&v45 + 1) + 8 * k);
        uint64_t v32 = -[NSSet countForObject:](otherSet, "countForObject:", v31);
        uint64_t v33 = -[NSSet countForObject:](self, "countForObject:", v31);
        uint64_t v34 = v33 - v32;
        if (v33 > v32)
        {
          do
          {
            *v28++ = v31;
            --v34;
          }

          while (v34);
        }
      }

      uint64_t v27 = -[NSSet countByEnumeratingWithState:objects:count:]( self,  "countByEnumeratingWithState:objects:count:",  &v45,  v44,  16LL);
    }

    while (v27);
  }

  while (v26 < v28)
    -[NSMutableSet removeObject:](self, "removeObject:", *v26++);
  free(v43);
}

  if (otherSet == (NSSet *)self)
  {
    -[NSMutableSet removeAllObjects](self, "removeAllObjects");
  }

  else
  {
    char v36 = 0u;
    unint64_t v37 = 0u;
    uint64_t v34 = 0u;
    v35 = 0u;
    uint64_t v19 = -[NSSet countByEnumeratingWithState:objects:count:]( otherSet,  "countByEnumeratingWithState:objects:count:",  &v34,  v33,  16LL);
    if (v19)
    {
      id v20 = v19;
      uint64_t v21 = *(void *)v35;
      do
      {
        for (j = 0LL; j != v20; ++j)
        {
          if (*(void *)v35 != v21) {
            objc_enumerationMutation(otherSet);
          }
          uint64_t v23 = *(void *)(*((void *)&v34 + 1) + 8 * j);
          int v24 = -[NSSet countForObject:](otherSet, "countForObject:", v23);
          if (v24)
          {
            unint64_t v25 = v24;
            do
            {
              --v25;
              -[NSMutableSet removeObject:](self, "removeObject:", v23);
            }

            while (v25);
          }
        }

        id v20 = -[NSSet countByEnumeratingWithState:objects:count:]( otherSet,  "countByEnumeratingWithState:objects:count:",  &v34,  v33,  16LL);
      }

      while (v20);
    }
  }

  if (a3 == self)
  {
    -[NSMutableSet removeAllObjects](self, "removeAllObjects");
  }

  else
  {
    v35 = 0u;
    char v36 = 0u;
    uint64_t v33 = 0u;
    uint64_t v34 = 0u;
    uint64_t v19 = [a3 countByEnumeratingWithState:&v33 objects:v32 count:16];
    if (v19)
    {
      id v20 = v19;
      uint64_t v21 = *(void *)v34;
      do
      {
        for (j = 0LL; j != v20; ++j)
        {
          if (*(void *)v34 != v21) {
            objc_enumerationMutation(a3);
          }
          -[NSMutableSet removeObject:](self, "removeObject:", *(void *)(*((void *)&v33 + 1) + 8 * j));
        }

        id v20 = [a3 countByEnumeratingWithState:&v33 objects:v32 count:16];
      }

      while (v20);
    }
  }

  if (otherSet != (NSSet *)self)
  {
    -[NSMutableSet removeAllObjects](self, "removeAllObjects");
    unint64_t v37 = 0u;
    BOOL v38 = 0u;
    v35 = 0u;
    char v36 = 0u;
    uint64_t v19 = -[NSSet countByEnumeratingWithState:objects:count:]( otherSet,  "countByEnumeratingWithState:objects:count:",  &v35,  v34,  16LL);
    if (v19)
    {
      id v20 = v19;
      uint64_t v21 = *(void *)v36;
      do
      {
        for (j = 0LL; j != v20; ++j)
        {
          if (*(void *)v36 != v21) {
            objc_enumerationMutation(otherSet);
          }
          uint64_t v23 = *(void *)(*((void *)&v35 + 1) + 8 * j);
          int v24 = -[NSSet countForObject:](otherSet, "countForObject:", v23);
          if (v24)
          {
            unint64_t v25 = v24;
            do
            {
              --v25;
              -[NSMutableSet addObject:](self, "addObject:", v23);
            }

            while (v25);
          }
        }

        id v20 = -[NSSet countByEnumeratingWithState:objects:count:]( otherSet,  "countByEnumeratingWithState:objects:count:",  &v35,  v34,  16LL);
      }

      while (v20);
    }
  }

  unint64_t v18 = -[NSSet count](otherSet, "count");
  id v20 = v18;
  if (v18 >> 60)
  {
    uint64_t v27 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v18);
    unint64_t v28 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v27,  0LL);
    CFRelease(v27);
    objc_exception_throw(v28);
LABEL_34:
    __break(1u);
    return;
  }

  if (v18 <= 1) {
    unint64_t v18 = 1LL;
  }
  uint64_t v21 = MEMORY[0x1895F8858](v18, v19);
  uint64_t v23 = (char *)v34 - v22;
  if (v20 >= 0x101)
  {
    uint64_t v23 = (char *)_CFCreateArrayStorage(v21, 0, v34);
    int v24 = v23;
  }

  else
  {
    int v24 = 0LL;
  }

  -[NSSet getObjects:count:](otherSet, "getObjects:count:", v23, v20);
  if (v20)
  {
    for (j = 0LL; j != v20; ++j)
    {
      CFRange v26 = -[NSSet countForObject:](otherSet, "countForObject:", *(void *)&v23[8 * j]) + 1;
      while (--v26)
        -[NSMutableSet addObject:](self, "addObject:", *(void *)&v23[8 * j]);
    }
  }

  free(v24);
}

  IsValidCombiningCharacterForLatin1 = __CFToISOArabic(IsValidCombiningCharacterForLatin1, v13, &v20);
  if ((_DWORD)IsValidCombiningCharacterForLatin1)
  {
    if (!a5) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

    int v10 = 65533;
    goto LABEL_18;
  }

  if (v9 == 1620)
  {
    unint64_t v11 = *a2;
    if (v11 > 0x6C0)
    {
      switch(v11)
      {
        case 0x6C1u:
          int v10 = 1730;
          goto LABEL_18;
        case 0x6D2u:
          int v10 = 1747;
          goto LABEL_18;
        case 0x6D5u:
          int v10 = 1728;
          goto LABEL_18;
      }
    }

    else
    {
      switch(v11)
      {
        case 0x627u:
          int v10 = 1571;
          goto LABEL_18;
        case 0x648u:
          int v10 = 1572;
          goto LABEL_18;
        case 0x64Au:
          int v10 = 1574;
          goto LABEL_18;
      }
    }

    goto LABEL_17;
  }

  if (v9 != 1619 || *a2 != 1575) {
    goto LABEL_17;
  }
  int v10 = 1570;
LABEL_18:
  uint64_t v12 = __CFToISOArabic(a1, v10, &v14);
  double result = 0LL;
  if (v12 && v14)
  {
    if (a5) {
      *a4 = v14;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

    if ((HIWORD(v21) & 0x1F) != v178)
    {
      UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v21) & 0x1F);
      v178 = BYTE2(v21) & 0x1F;
    }

    if (UnicodePropertyDataForPlane)
    {
      unint64_t v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + BYTE1(v21));
      if (v22 >= 0x13) {
        unint64_t v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + (v22 << 8) - 4864 + v21 + 256);
      }
    }

    else
    {
      unint64_t v22 = 1;
    }

    uint64_t v23 = v22 == 13;
    int v24 = v179;
    if (!v23 && v179 != v10) {
      goto LABEL_265;
    }
    unint64_t v25 = v177;
    range = v177 + 1;
    v172 = v177 + 1 - a2;
    if (v9) {
      CFRange v26 = (void *)(v9 + v172);
    }
    else {
      CFRange v26 = 0LL;
    }
    code = U_ZERO_ERROR;
    uint64_t v27 = v179;
    if (v174 == -1)
    {
      if (v26) {
        uint64_t v27 = v179;
      }
      unint64_t v25 = v177;
    }

    v173 = v26;
    v218 = 0LL;
    v181 = v27 + a2;
    v175 = v27 + a2 - 1;
    v176 = UnicodePropertyDataForPlane;
    memset(v217, 0, sizeof(v217));
    memset(v216, 0, sizeof(v216));
    v215 = -1;
    v214[0] = -1LL;
    v214[1] = -1LL;
    v213 = -1;
    v212[1] = -1LL;
    v212[0] = -1LL;
    inRange = v175 - v25;
    if (v175 - v25 < 1)
    {
      v182 = 0;
      v188 = 0;
      v120 = 0LL;
      ptrb = v217;
      v35 = (void **)v216;
      goto LABEL_187;
    }

    uint64_t v32 = 0LL;
    uint64_t v33 = 0;
    v188 = 0;
    v182 = 0;
    v193 = 0LL;
    uint64_t v34 = 0LL;
    v35 = (void **)v216;
    char v36 = v217;
    v187 = 10LL;
    unint64_t v37 = v177 + 1;
    do
    {
      range_8 = v35;
      ptr = v36;
      v210[0] = -1LL;
      v210[1] = -1LL;
      v211 = -1;
      if ((v33 & 1) != 0 && v32) {
        CFRelease(v32);
      }
      loc = v37;
      v224.CFIndex location = v177 + 1;
      v224.CFIndex length = inRange;
      AttributeAndLongestEffectiveRange = CFAttributedStringGetAttributeAndLongestEffectiveRange( a1,  v37,  @"NSLink",  v224,  &longestEffectiveRange);
      uint64_t v39 = longestEffectiveRange.length + longestEffectiveRange.location;
      if (!AttributeAndLongestEffectiveRange) {
        goto LABEL_75;
      }
      numChars = v39 - v37;
      if (v39 - v37 < 1) {
        goto LABEL_74;
      }
      uint64_t v40 = v37 - v206;
      uint64_t v41 = loc - v206 + numChars;
      uint64_t v42 = v206 - loc;
      uint64_t v43 = loc - v206 + 64;
      uint64_t v44 = loc - v206;
      while (1)
      {
        else {
          uint64_t v45 = v44;
        }
        if (v44 < 0 || (uint64_t v46 = v207, v207 <= v44))
        {
          uint64_t v48 = 0;
          uint64_t v47 = 0;
          goto LABEL_66;
        }

        if (CharactersPtr)
        {
          uint64_t v47 = CharactersPtr[v44 + v206];
        }

        else if (v205)
        {
          uint64_t v47 = v205[v206 + v44];
        }

        else
        {
          if (v209 <= v44 || (v49 = v208, v208 > v44))
          {
            v50 = v45 + v42;
            char v51 = v43 - v45;
            v52 = v44 - v45;
            v53 = v52 + 64;
            if (v52 + 64 >= v207) {
              v53 = v207;
            }
            v208 = v52;
            v209 = v53;
            if (v207 >= v51) {
              uint64_t v46 = v51;
            }
            v220.CFIndex length = v46 + v50;
            v220.CFIndex location = v52 + v206;
            CFStringGetCharacters(theString, v220, buffer);
            v49 = v208;
          }

          uint64_t v47 = buffer[v44 - v49];
        }

        uint64_t v48 = v47;
        if (v47 > 0x7Fu) {
          break;
        }
LABEL_66:
        uint64_t v54 = *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v48 + 60);
        if ((v54 & 0x4000) != 0) {
          goto LABEL_75;
        }
        if (v48 > 0x7F)
        {
          if (__maskrune(v48, 0x500uLL)) {
            goto LABEL_73;
          }
        }

        else if ((v54 & 0x500) != 0)
        {
          goto LABEL_73;
        }

        if (v47 > 0x2Eu || ((1LL << v47) & 0x680000000000LL) == 0) {
          break;
        }
LABEL_73:
        ++v44;
        --v42;
        ++v43;
        if (v44 >= v41) {
          goto LABEL_74;
        }
      }

      if ((v40 & 0x8000000000000000LL) == 0 && v41 <= v207)
      {
        if (CharactersPtr)
        {
          v84 = (UniChar *)&CharactersPtr[v206 + v40];
        }

        else
        {
          if (numChars > 64) {
            goto LABEL_131;
          }
          if (v41 > v209 || (v94 = v208, v40 < v208))
          {
            v95 = v40 + 64;
            if (v40 + 64 >= v207) {
              v95 = v207;
            }
            v208 = v40;
            v209 = v95;
            v96.CFIndex location = v206 + v40;
            v96.CFIndex length = v95 - v40;
            if (v205)
            {
              if (v96.length)
              {
                v97 = &v205[v96.location];
                v98 = buffer;
                do
                {
                  v99 = *v97++;
                  *v98++ = v99;
                  --v96.length;
                }

                while (v96.length);
              }

              v94 = v40;
            }

            else
            {
              CFStringGetCharacters(theString, v96, buffer);
              v94 = v208;
            }
          }

          v84 = &buffer[v40 - v94];
        }

        v103 = CFStringCreateWithCharactersNoCopy(0LL, v84, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
        if (!v103) {
          goto LABEL_75;
        }
        v86 = v103;
        v87 = 0;
LABEL_167:
        v104 = CFURLCreateWithString(0LL, v86, 0LL);
        if (!v104)
        {
          CFRelease(v86);
          if ((v87 & 1) != 0) {
            goto LABEL_171;
          }
          goto LABEL_75;
        }

        CFRelease(v104);
        CFRelease(v86);
        if (v87) {
          CFAllocatorDeallocate(0LL, v84);
        }
LABEL_74:
        valuePtr = 8;
        values.CFIndex location = (CFIndex)CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
        uint64_t v33 = 1;
        uint64_t v32 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
        CFRelease((CFTypeRef)values.location);
        if (!v32) {
          goto LABEL_75;
        }
        goto LABEL_78;
      }

    range = -1LL;
    uint64_t Copy = _CFCreateLastPathComponent((const __CFAllocator *)&__kCFAllocatorSystemDefault, a4, &range);
    v28.CFIndex length = range;
    if (range < 1)
    {
      unint64_t v29 = 0LL;
    }

    else
    {
      v28.CFIndex location = 0LL;
      unint64_t v29 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, v28);
      if (range >= 1 && !CFStringGetLength(Copy))
      {
        v98 = a2;
        size_t v30 = v29;
        uint64_t v31 = range;
        if (v31 == CFStringGetLength(a4) - 1)
        {
          CFRelease(Copy);
          unint64_t v29 = v30;
          uint64_t Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v30);
        }

        else
        {
          unint64_t v29 = v30;
        }

        a2 = v98;
      }
    }

    if (CFStringGetFileSystemRepresentation(Copy, buffer, 1026LL))
    {
      CFRelease(Copy);
      uint64_t Copy = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
    }

    if (Copy)
    {
      CFIndex Length = CFStringGetLength(Copy);
      if (a5 && Length >= 1 && CFStringGetLength(a5) >= 1)
      {
        Mutableuint64_t Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, Copy);
        if (CFStringGetCharacterAtIndex(a5, 0LL) != 46) {
          CFStringAppendCharacters(MutableCopy, &_CFBundleCopyFindResources_extensionSep, 1LL);
        }
        CFStringAppend(MutableCopy, a5);
      }

      else
      {
        if (CFStringGetLength(Copy) < 1)
        {
          v104 = 0;
          if (!a5) {
            goto LABEL_49;
          }
LABEL_41:
          if (CFStringGetLength(a5) >= 1)
          {
            Mutableuint64_t Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"_CFBT_");
            if (CFStringGetCharacterAtIndex(a5, 0LL) != 46) {
              CFStringAppendCharacters(MutableCopy, &_CFBundleCopyFindResources_extensionSep, 1LL);
            }
            CFStringAppend(MutableCopy, a5);
LABEL_50:
            v106 = MutableCopy;
            if (a6)
            {
              char v36 = CFStringGetLength(a6) != 0;
              if (v29)
              {
LABEL_52:
                unint64_t v37 = CFStringGetLength(v29) != 0;
LABEL_55:
                BOOL v38 = !v36;
                if (!v36 || v37)
                {
                  uint64_t v40 = !v37;
                  if (((v36 | v40) & 1) != 0)
                  {
                    uint64_t v41 = v106;
                    if (((v38 | v40) & 1) != 0)
                    {
                      uint64_t v42 = 0LL;
                      if (v15)
                      {
LABEL_64:
                        uint64_t v43 = _CFBundleLayoutVersion(v15);
                        goto LABEL_67;
                      }
                    }

                    else
                    {
                      uint64_t v42 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, a6);
                      _CFAppendPathComponent2(v42, v29);
                      if (v15) {
                        goto LABEL_64;
                      }
                    }

    unint64_t v17 = v9;
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v18 = _os_log_pack_fill();
    uint64_t v19 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v18,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInArray:range:]",  location,  length,  --v17);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v19,  "-[NSMutableOrderedSet removeObjectsInArray:range:]",  location,  length,  v17);
    goto LABEL_18;
  }

  for (; length; --length)
  {
    int v10 = -[NSOrderedSet indexOfObject:](self, "indexOfObject:", [a3 objectAtIndex:location]);
    if (v10 != 0x7FFFFFFFFFFFFFFFLL) {
      -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v10);
    }
    ++location;
  }

      uint64_t v12 = (__CFRunLoopSource *)CFRetain(v11);
      goto LABEL_18;
    }
  }

  return 0LL;
}

  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1) {
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  }
  uint64_t v13 = (os_log_s *)_CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    if (Mutable) {
      uint64_t v15 = CFArrayGetCount(Mutable);
    }
    else {
      uint64_t v15 = 0LL;
    }
    CFIndex v16 = 134349570;
    unint64_t v17 = v15;
    unint64_t v18 = 2114;
    uint64_t v19 = typeUUID;
    id v20 = 2114;
    uint64_t v21 = plugIn;
    _os_log_debug_impl( &dword_180A4C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}ld factories found for requested plugin type %{public}@ in plugin %{public}@",  (uint8_t *)&v16,  0x20u);
  }

  return Mutable;
}

      a5 = _os_log_pack_size();
      uint64_t v14 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "-[NSMutableDictionary replaceObjects:forKeys:count:]";
      *(_WORD *)(v14 + 12) = 2048;
      *(void *)(v14 + 14) = v10;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableDictionary replaceObjects:forKeys:count:]",  v10);
      uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v25 - ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a5);
      objc_exception_throw(v15);
      goto LABEL_18;
    }

    CFIndex v16 = _os_log_pack_size();
    unint64_t v17 = (char *)v25 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    goto LABEL_21;
  }

      a5 = _os_log_pack_size();
      uint64_t v14 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "-[NSMutableDictionary setObjects:forKeys:count:]";
      *(_WORD *)(v14 + 12) = 2048;
      *(void *)(v14 + 14) = v10;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableDictionary setObjects:forKeys:count:]",  v10);
      uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v25 - ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a5);
      objc_exception_throw(v15);
      goto LABEL_18;
    }

    CFIndex v16 = _os_log_pack_size();
    unint64_t v17 = (char *)v25 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    goto LABEL_21;
  }

  if (Length >= bufferSize) {
    return 0;
  }
  id v20 = atomic_load((unint64_t *)&theString->info);
  memmove(buffer + 1, &v12[(v20 >> 2) & 1], Length);
  double result = 1;
LABEL_44:
  *buffer = Length;
  return result;
}

              if (v4 < 0xA1) {
                return 65533LL;
              }
              break;
            }

            int v8 = v11 + 33;
          }

          else
          {
            int v9 = v11 - 33;
          }

          if (v8 > v9) {
            goto LABEL_17;
          }
        }
      }
    }
  }

  uint64_t v13 = (unsigned __int16 *)&KSX1001_from_uni;
  uint64_t v14 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    uint64_t v15 = (0xF83E0F83E0F83E1LL * (v14 - v13)) >> 1;
    CFIndex v16 = &v13[33 * v15];
    unint64_t v17 = *v16;
    if (v17 <= v4) {
      break;
    }
    uint64_t v14 = v16 - 33;
LABEL_23:
    if (v13 > v14) {
      return 65533LL;
    }
  }

  if (v17 + 32 <= v4)
  {
    uint64_t v13 = v16 + 33;
    goto LABEL_23;
  }

  uint64_t v19 = (uint64_t)&v13[33 * v15 + (int)(v4 - v17)];
  double result = *(unsigned __int16 *)(v19 + 2);
  if (*(_WORD *)(v19 + 2))
  {
    id v20 = 1LL;
    goto LABEL_27;
  }

  return 65533LL;
}

  CFIndex Length = CFStringGetLength(transform);
  if (CFStringGetCharactersPtr(transform))
  {
LABEL_25:
    int v9 = utrans_openU();
    goto LABEL_26;
  }

  if (Length <= 1024)
  {
    v42.CFIndex location = 0LL;
    v42.CFIndex length = Length;
    CFStringGetCharacters(transform, v42, buffer);
    goto LABEL_25;
  }

  unint64_t v18 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * Length, 0LL);
  if (!v18)
  {
LABEL_29:
    int v9 = 0LL;
    goto LABEL_30;
  }

  uint64_t v19 = v18;
  v43.CFIndex location = 0LL;
  v43.CFIndex length = Length;
  CFStringGetCharacters(transform, v43, v18);
  int v9 = utrans_openU();
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v19);
LABEL_26:
  if (SLODWORD(v30[0]) >= 1 && v9)
  {
    utrans_close();
    goto LABEL_29;
  }

  if (v14 <= v10)
  {
    if (v8 == -1)
    {
      uint64_t v7 = v13[1];
      uint64_t v12 = 1;
      int v8 = *v13;
    }

    else
    {
      uint64_t v7 = *v13 - v8 + v13[1];
      uint64_t v12 = 1;
    }

    goto LABEL_22;
  }

  CFIndex v16 = *v13;
  if (*v13 == -1) {
LABEL_25:
  }
    CFIndex v16 = v7 + v8;
  unint64_t v18 = v16 - v11;
LABEL_60:
  if (v11 != -1)
  {
    if (rangeIncludingSeparators)
    {
      unint64_t v25 = v7;
      goto LABEL_63;
    }

    if (v8 != -1)
    {
      size_t v30 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v50.CFIndex location = 0LL;
      v50.CFIndex length = v8;
      CFStringGetBytes(v30, v50, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, &v46);
      uint64_t v31 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v51.CFIndex location = v8;
      v51.CFIndex length = v7;
      CFStringGetBytes(v31, v51, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, v47);
      goto LABEL_77;
    }

    unint64_t v18 = &v14[v10];
    if (v46[0] >= 1)
    {
      uint64_t v19 = 0LL;
      unint64_t v18 = v16;
      do
      {
        id v20 = (char)v14[v19];
        if (v20 < 0 || !CFCharacterSetIsCharacterMember(a3, v14[v19]))
        {
          *unint64_t v18 = 37;
          v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[(unint64_t)v20 >> 4];
          v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v20 & 0xF];
          v18 += 3;
        }

        else
        {
          *v18++ = v20;
        }

        ++v19;
      }

      while (v19 < v46[0]);
    }

    unint64_t v17 = v9;
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v18 = _os_log_pack_fill();
    uint64_t v19 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v18,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inSet:]",  location,  length,  --v17);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v19,  "-[NSMutableArray removeObjectsInRange:inSet:]",  location,  length,  v17);
    goto LABEL_18;
  }

  if (a4 && (_NSIsNSSet((uint64_t)a4) & 1) == 0)
  {
    CFIndex location = _os_log_pack_size();
    CFIndex length = (NSUInteger)v24 - ((location + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v15 = 136315138;
    *(void *)(v15 + 4) = "-[NSMutableArray removeObjectsInRange:inSet:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: set argument is not an NSSet",  "-[NSMutableArray removeObjectsInRange:inSet:]");
    CFIndex v16 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  length,  location);
    objc_exception_throw(v16);
    goto LABEL_17;
  }

  if (length)
  {
    int v10 = length - 1;
    do
    {
      if (objc_msgSend( a4,  "containsObject:",  -[NSArray objectAtIndex:](self, "objectAtIndex:", location + v10))) {
        -[NSMutableArray removeObjectAtIndex:](self, "removeObjectAtIndex:", v10);
      }
      --v10;
    }

    while (v10 != -1LL);
  }

  *(void *)(a1 + 16) = v6;
  return result;
}

      unint64_t v17 = error;
LABEL_18:
      CFRelease(v17);
    }

    return 0LL;
  }

  int v24 = 0LL;
  if (a4) {
    int v9 = 65537LL;
  }
  else {
    int v9 = 1LL;
  }
  int v10 = CFGetAllocator(cf);
  if (!_CFPropertyListCreateFiltered(v10, a3, v9, a2, &v24, &error))
  {
    if (error)
    {
      unint64_t v18 = (os_log_s *)_CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138413058;
        uint64_t v27 = a2;
        unint64_t v28 = 2112;
        unint64_t v29 = cf;
        size_t v30 = 2112;
        uint64_t v31 = (CFErrorRef)a5;
        uint64_t v32 = 2112;
        uint64_t v33 = error;
        uint64_t v19 = "Unable to read key-paths %@ from .strings file: %@ / %@: %@";
        id v20 = v18;
        uint64_t v21 = 42;
LABEL_22:
        _os_log_error_impl(&dword_180A4C000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
        goto LABEL_17;
      }

      goto LABEL_17;
    }

    return 0LL;
  }

  return v24;
}

  uint64_t v21 = CFStringGetLength(a1);
  unint64_t v22 = v21 - 1;
  if (v21 <= 1)
  {
    unint64_t v28 = 0;
    unint64_t v29 = 3;
    goto LABEL_39;
  }

  uint64_t v23 = v21;
  theString2 = (const __CFString *)a6;
  uint64_t v41 = a8;
  uint64_t v42 = a2;
  int v24 = 0;
  unint64_t v25 = 1 - v21;
  while (1)
  {
    a4 = v22;
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v22);
    if (CharacterAtIndex == 46) {
      uint64_t v23 = a4;
    }
    if (CharacterAtIndex == 126 && !v24)
    {
      v45.CFIndex location = a4;
      v45.CFIndex length = v23 + v25;
      uint64_t v27 = CFStringCompareWithOptions(a1, a5, v45, 8uLL);
      if (v27 == kCFCompareEqualTo)
      {
        int v8 = v23 + v25;
        a6 = a4;
      }

      int v24 = v27 == kCFCompareEqualTo;
      a8 = (_DWORD *)a4;
      goto LABEL_27;
    }

    if (CharacterAtIndex == 45) {
      break;
    }
LABEL_27:
    unint64_t v22 = a4 - 1;
    ++v25;
    if ((unint64_t)(a4 + 1) <= 2)
    {
      unint64_t v28 = 0;
      goto LABEL_34;
    }
  }

  if (v24) {
    size_t v30 = a8;
  }
  else {
    size_t v30 = (_DWORD *)v23;
  }
  a5 = (const __CFString *)((char *)v30 - a4);
  v46.CFIndex location = a4;
  v46.CFIndex length = (CFIndex)v30 - a4;
  unint64_t v28 = CFStringCompareWithOptions(a1, theString2, v46, 8uLL) == kCFCompareEqualTo;
LABEL_34:
  a8 = v41;
  a2 = v42;
  if (v28 && v24) {
    unint64_t v29 = 4;
  }
  else {
    unint64_t v29 = 3;
  }
  if (v24)
  {
    uint64_t v31 = 2;
    goto LABEL_40;
  }

void sub_180A557DC(_Unwind_Exception *a1)
{
}

void sub_180A55CF4(_Unwind_Exception *a1)
{
}

void sub_180A56448(_Unwind_Exception *exception_object)
{
}

void sub_180A5861C(_Unwind_Exception *a1)
{
}

void sub_180A58BA4(_Unwind_Exception *exception_object)
{
}

void sub_180A58F54(_Unwind_Exception *a1)
{
}

NSUInteger OUTLINED_FUNCTION_0(objc_class *a1, uint64_t a2)
{
  return __CFRequireConcreteImplementation(a1, a2);
}

uint64_t (**__CFStringEncodingGetArabicConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter)
  {
    __CFStringEncodingPrecomposeLatinCharacter = (_UNKNOWN *)a2(4LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1 = (_UNKNOWN *)a2(3LL);
  }

  if (a1 > 517)
  {
    if (a1 != 518)
    {
      if (a1 == 1286) {
        return __CFConverterWindowsArabic;
      }
      return 0LL;
    }

    return __CFConverterISOLatinArabic;
  }

  else
  {
    if (a1 != 4)
    {
      if (a1 == 140) {
        return __CFConverterMacFarsi;
      }
      return 0LL;
    }

    return __CFConverterMacArabic;
  }

uint64_t __CFToMacArabic( uint64_t IsValidCombiningCharacterForLatin1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    goto LABEL_25;
  }

  char v11 = IsValidCombiningCharacterForLatin1;
  uint64_t v12 = 0LL;
  while (1)
  {
    if (a5 < 0)
    {
      if ((v11 & 0x10) == 0) {
        goto LABEL_25;
      }
      IsValidCombiningCharacterForLatin1 = *(unsigned __int16 *)(a2 + 2 * v12);
      if ((IsValidCombiningCharacterForLatin1 - 1619) >= 3)
      {
        IsValidCombiningCharacterForLatin1 = __CFStringEncodingIsValidCombiningCharacterForLatin1();
        if (!(_DWORD)IsValidCombiningCharacterForLatin1) {
          goto LABEL_25;
        }
      }
    }

    unsigned int v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      char v20 = *(_WORD *)(a2 + 2 * v12);
      if (!a5) {
        goto LABEL_20;
      }
LABEL_19:
      *(_BYTE *)(a4 + v12) = v20;
      goto LABEL_20;
    }

    uint64_t v14 = (unsigned __int16 *)&unk_180BF5D3C;
    uint64_t v15 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      uint64_t v16 = ((char *)v14 - (char *)v15) >> 3;
      unint64_t v17 = &v15[2 * v16];
      unsigned int v18 = *v17;
      if (v18 <= v13) {
        break;
      }
      uint64_t v14 = v17 - 2;
LABEL_16:
      if (v15 > v14) {
        goto LABEL_17;
      }
    }

    if (v18 < v13)
    {
      uint64_t v15 = v17 + 2;
      goto LABEL_16;
    }

    char v20 = v15[2 * v16 + 1];
    if (a5) {
      goto LABEL_19;
    }
LABEL_20:
    if (++v12 == a3)
    {
      uint64_t v12 = a3;
      goto LABEL_25;
    }
  }

uint64_t __CFFromMacArabic(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t result = a3;
  }
  else {
    uint64_t result = a5;
  }
  if (result >= 1)
  {
    uint64_t v8 = result;
    while (1)
    {
      int v9 = *a2++;
      int v10 = v9;
      if (v9 < 0) {
        break;
      }
      if (a5) {
        goto LABEL_11;
      }
LABEL_12:
      ++a4;
      if (!--v8) {
        goto LABEL_17;
      }
    }

    LOWORD(v10) = macarabic_to_uni[v10 - 128];
    if (!a5) {
      goto LABEL_12;
    }
LABEL_11:
    *a4 = v10;
    goto LABEL_12;
  }

  uint64_t result = 0LL;
LABEL_17:
  *a6 = result;
  return result;
}

uint64_t __CFIsValidCombiningCharacterForArabic(int a1)
{
  else {
    return 1LL;
  }
}

uint64_t __CFToISOArabic(uint64_t a1, int a2, _BYTE *a3)
{
  if ((a2 - 1569) <= 0x31)
  {
    LOBYTE(a2) = a2 - 96;
    goto LABEL_2;
  }

  uint64_t result = 0LL;
  if (a2 <= 1547)
  {
    if (a2 == 164 || a2 == 173) {
      goto LABEL_2;
    }
  }

  else
  {
    switch(a2)
    {
      case 1548:
        LOBYTE(a2) = -84;
        goto LABEL_2;
      case 1563:
        LOBYTE(a2) = -69;
        goto LABEL_2;
      case 1567:
        LOBYTE(a2) = -65;
LABEL_2:
        *a3 = a2;
        return 1LL;
    }
  }

  return result;
}

uint64_t __CFToMacFarsi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a5 >= a3 || a5 == 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = a5;
  }
  if (v8 < 1)
  {
    uint64_t v12 = 0LL;
    goto LABEL_28;
  }

  uint64_t v12 = 0LL;
  while (1)
  {
    unsigned int v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      char v21 = *(_WORD *)(a2 + 2 * v12);
      goto LABEL_22;
    }

    if (v13 - 1776 <= 9)
    {
      char v14 = v13 - 64;
      goto LABEL_13;
    }

    uint64_t v15 = (unsigned __int16 *)&unk_180BF5D3C;
    uint64_t v16 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      uint64_t v17 = ((char *)v15 - (char *)v16) >> 3;
      unsigned int v18 = &v16[2 * v17];
      unsigned int v19 = *v18;
      if (v19 <= v13) {
        break;
      }
      uint64_t v15 = v18 - 2;
LABEL_20:
      if (v16 > v15) {
        goto LABEL_21;
      }
    }

    if (v19 < v13)
    {
      uint64_t v16 = v18 + 2;
      goto LABEL_20;
    }

    char v14 = v16[2 * v17 + 1];
LABEL_13:
    char v21 = v14;
LABEL_22:
    if (a5) {
      *(_BYTE *)(a4 + v12) = v21;
    }
    if (++v12 == v8)
    {
      uint64_t v12 = v8;
      goto LABEL_28;
    }
  }

LABEL_21:
  a1 = __CFToISOArabic(a1, v13, &v21);
  if ((_DWORD)a1) {
    goto LABEL_22;
  }
LABEL_28:
  *a6 = v12;
  return v12;
}

  unsigned int v13 = (unint64_t)&v4[v6 - 1];
  uint64_t v15 = ~v6 >= v13;
  char v14 = v6 + v13;
  uint64_t v15 = v15 && ~v6 >= (unint64_t)v4;
  if (!v15 || a1 + a2 < v14) {
    return 0LL;
  }
  return (*(uint64_t (**)(uint64_t, unsigned __int8 *, unint64_t))(a4 + 16))(a4, v4, v6);
}

        *(_DWORD *)(a2 + 8) = v8;
LABEL_22:
        uint64_t v15 = *(void *)(v3 + 40);
        if (!v15) {
          return result;
        }
        if (*(_BYTE *)(v15 + 13)) {
          goto LABEL_24;
        }
        uint64_t v16 = *(_DWORD *)(v15 + 8);
        if (!v16) {
          return result;
        }
        uint64_t v17 = 1114112;
        unsigned int v18 = 15LL;
        break;
      default:
        return result;
    }

    while (1)
    {
      unsigned int v19 = v18 + 1;
      char v20 = (v18 + 1);
      if (v20 <= 0x10
        && ((v16 >> v19) & 1) != 0
        && *(unsigned __int8 *)(v15 + 12) >= v20
        && *(void *)(*(void *)v15 + 8 * v18))
      {
        break;
      }

      --v18;
      v17 -= 0x10000;
      if (v19 <= 1) {
        return result;
      }
    }

    *(_DWORD *)(a2 + 16) = v17;
  }

  return result;
}

        CFArrayRemoveValueAtIndex(v10, v16);
        CFArrayRemoveValueAtIndex(v10, v16);
      }
    }
  }

  else if (v10)
  {
    unsigned int v13 = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
    if (v13 >= 2)
    {
      char v14 = v13;
      uint64_t v15 = 1LL;
      while (1)
      {
        uint64_t v16 = v15 - 1;
        uint64_t v17 = CFArrayGetValueAtIndex(v10, v15 - 1);
        if (CFEqual(v17, a2))
        {
          unsigned int v18 = CFArrayGetValueAtIndex(v10, v15);
          if (CFEqual(v18, a3)) {
            break;
          }
        }

        v15 += 2LL;
        if (v15 >= v14) {
          return;
        }
      }

      goto LABEL_21;
    }
  }

  if (v11)
  {
    int v24 = v11;
    char v21 = _os_log_pack_size();
    uint64_t v22 = (char *)v32 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v25 = _os_log_pack_fill();
    CFRange v26 = __os_log_helper_1_2_3_8_32_8_0_8_0( v25,  (uint64_t)"-[NSMutableOrderedSet insertObjects:count:atIndex:]",  a5,  --v24);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v26,  "-[NSMutableOrderedSet insertObjects:count:atIndex:]",  a5,  v24);
  }

  else
  {
    char v21 = _os_log_pack_size();
    uint64_t v22 = (char *)v32 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v23 = 136315394;
    *(void *)(v23 + 4) = "-[NSMutableOrderedSet insertObjects:count:atIndex:]";
    *(_WORD *)(v23 + 12) = 2048;
    *(void *)(v23 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet insertObjects:count:atIndex:]",  a5);
  }

  uint64_t v27 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v21);
  objc_exception_throw(v27);
  -[NSMutableOrderedSet insertObjectsFromArray:range:atIndex:](v28, v29, v30, v33, v31);
}

    CFRange v26 = v12;
    uint64_t v15 = _os_log_pack_size();
    uint64_t v16 = (char *)v38 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v27 = _os_log_pack_fill();
    unint64_t v28 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v27,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  v10,  v9,  --v26);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v28,  "-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  v10,  v9,  v26);
    goto LABEL_22;
  }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    uint64_t v23 = _os_log_pack_size();
    int v10 = (NSUInteger)v38;
    int v24 = _os_log_pack_fill();
    *(_DWORD *)int v24 = 136315138;
    *(void *)(v24 + 4) = "-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: array argument is not an NSArray",  "-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]");
    unint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v23);
    objc_exception_throw(v25);
    goto LABEL_21;
  }

  unsigned int v13 = [a4 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v13 < location + length)
  {
    if (v13)
    {
      uint64_t v32 = v13;
      unsigned int v19 = _os_log_pack_size();
      char v20 = (char *)v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v33 = _os_log_pack_fill();
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v33,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  location,  length,  --v32);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  location,  length,  v32);
    }

    else
    {
      unsigned int v19 = _os_log_pack_size();
      char v20 = (char *)v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      char v21 = _os_log_pack_fill();
      uint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v22,  "-[NSMutableOrderedSet removeObjectsInRange:inArray:range:]",  location,  length);
    }

    unint64_t v29 = _CFAutoreleasePoolAddObject();
    size_t v30 = v20;
    uint64_t v31 = v19;
    goto LABEL_25;
  }

  for (; length; --length)
  {
    char v14 = -[NSOrderedSet indexOfObject:inRange:]( self,  "indexOfObject:inRange:",  [a4 objectAtIndex:location],  v10,  v9);
    if (v14 != 0x7FFFFFFFFFFFFFFFLL) {
      -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v14);
    }
    ++location;
  }

    uint64_t v16 = _os_log_pack_size();
    uint64_t v17 = &v29[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    uint64_t v22 = _os_log_pack_fill();
    uint64_t v23 = v10 - 1;
    int v24 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v22,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInRange:inArray:]",  location,  length,  v23);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v24,  "-[NSMutableOrderedSet removeObjectsInRange:inArray:]",  location,  length,  v23);
    goto LABEL_22;
  }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    CFIndex location = _os_log_pack_size();
    CFIndex length = (NSUInteger)&v29[-((location + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    char v20 = _os_log_pack_fill();
    *(_DWORD *)char v20 = 136315138;
    *(void *)(v20 + 4) = "-[NSMutableOrderedSet removeObjectsInRange:inArray:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: array argument is not an NSArray",  "-[NSMutableOrderedSet removeObjectsInRange:inArray:]");
    char v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  length,  location);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  uint64_t v32 = 0u;
  uint64_t v33 = 0u;
  size_t v30 = 0u;
  uint64_t v31 = 0u;
  char v11 = [a4 countByEnumeratingWithState:&v30 objects:v29 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    unsigned int v13 = *(void *)v31;
    do
    {
      for (uint64_t i = 0LL; i != v12; ++i)
      {
        if (*(void *)v31 != v13) {
          objc_enumerationMutation(a4);
        }
        uint64_t v15 = -[NSOrderedSet indexOfObject:inRange:]( self,  "indexOfObject:inRange:",  *(void *)(*((void *)&v30 + 1) + 8 * i),  location,  length);
        if (v15 != 0x7FFFFFFFFFFFFFFFLL) {
          -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v15);
        }
      }

      uint64_t v12 = [a4 countByEnumeratingWithState:&v30 objects:v29 count:16];
    }

    while (v12);
  }

    uint64_t v16 = _os_log_pack_size();
    uint64_t v17 = &v29[-((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    uint64_t v22 = _os_log_pack_fill();
    uint64_t v23 = v10 - 1;
    int v24 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v22,  (uint64_t)"-[NSMutableOrderedSet removeObjectsInRange:inSet:]",  location,  length,  v23);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v24,  "-[NSMutableOrderedSet removeObjectsInRange:inSet:]",  location,  length,  v23);
    goto LABEL_22;
  }

  if (a4 && (_NSIsNSSet((uint64_t)a4) & 1) == 0)
  {
    CFIndex location = _os_log_pack_size();
    CFIndex length = (NSUInteger)&v29[-((location + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    char v20 = _os_log_pack_fill();
    *(_DWORD *)char v20 = 136315138;
    *(void *)(v20 + 4) = "-[NSMutableOrderedSet removeObjectsInRange:inSet:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: set argument is not an NSSet",  "-[NSMutableOrderedSet removeObjectsInRange:inSet:]");
    char v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  length,  location);
    objc_exception_throw(v21);
    goto LABEL_21;
  }

  uint64_t v32 = 0u;
  uint64_t v33 = 0u;
  size_t v30 = 0u;
  uint64_t v31 = 0u;
  char v11 = [a4 countByEnumeratingWithState:&v30 objects:v29 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    unsigned int v13 = *(void *)v31;
    do
    {
      for (uint64_t i = 0LL; i != v12; ++i)
      {
        if (*(void *)v31 != v13) {
          objc_enumerationMutation(a4);
        }
        uint64_t v15 = -[NSOrderedSet indexOfObject:inRange:]( self,  "indexOfObject:inRange:",  *(void *)(*((void *)&v30 + 1) + 8 * i),  location,  length);
        if (v15 != 0x7FFFFFFFFFFFFFFFLL) {
          -[NSMutableOrderedSet removeObjectAtIndex:](self, "removeObjectAtIndex:", v15);
        }
      }

      uint64_t v12 = [a4 countByEnumeratingWithState:&v30 objects:v29 count:16];
    }

    while (v12);
  }

    if (v7 == 3)
    {
      int v9 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7) {
        int v9 = 0xFFFFFFFFFFFFFLL;
      }
      int v10 = v9 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v10 & 7];
    }
  }

  else if (CF_IS_OBJC(0x16uLL, (__objc2_class **)a1))
  {
    return [a1 _cfNumberType];
  }

  pthread_mutex_unlock(v8);
}

  pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));
  CFRelease(observer);
}

  CharactersPtr = CFStringGetCharactersPtr(theString);
  *(void *)(a1 + 48) = CharactersPtr;
  if (CharactersPtr)
  {
    if (v11 > 2147483646)
    {
      unsigned int v19 = v11 - 0x7FFFFFFF;
      if (a3)
      {
        unsigned int v19 = v10;
        uint64_t v32 = 0;
      }

      else
      {
        uint64_t v32 = 0x7FFFFFFF;
      }

      *(void *)(a1 + 32) = v19;
      *(_DWORD *)(a1 + 40) = v32;
      *(void *)(a1 + 48) = &CharactersPtr[v19];
    }

    else
    {
      unsigned int v19 = 0LL;
      *(void *)(a1 + 32) = 0LL;
      *(_DWORD *)(a1 + 40) = v11;
    }

    char v20 = v9 - v19;
    if (v9 - v19 > 2147483646)
    {
      char v20 = 0x7FFFFFFF;
      *(void *)(a1 + 16) = v19 + 0x7FFFFFFF;
      *(_DWORD *)(a1 + 44) = 0x7FFFFFFF;
    }

    else
    {
      *(void *)(a1 + 16) = v9;
      *(_DWORD *)(a1 + 44) = v20;
    }

    unsigned int v13 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 256LL, 0LL);
    uint64_t v5 = 0LL;
    error[0] = v13;
    if (!v13) {
      goto LABEL_32;
    }
LABEL_30:
    if (a2) {
      goto LABEL_31;
    }
LABEL_26:
    CFRelease(v13);
LABEL_32:
    CFRelease(v4);
    return v5;
  }

  return 0LL;
}

    int v9 = i;
    int v10 = _os_log_pack_size();
    char v11 = (char *)v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v12 = 136315394;
    *(void *)(v12 + 4) = "+[NSDictionary newDictionaryWithObjects:forKeys:count:]";
    *(_WORD *)(v12 + 12) = 2048;
    *(void *)(v12 + 14) = v9;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "+[NSDictionary newDictionaryWithObjects:forKeys:count:]",  v9);
    while (1)
    {
LABEL_22:
      unsigned int v13 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v11,  v10);
      objc_exception_throw(v13);
LABEL_23:
      char v14 = a5;
      int v10 = _os_log_pack_size();
      char v11 = (char *)v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
LABEL_26:
      uint64_t v17 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v17 = 136315394;
      *(void *)(v17 + 4) = "+[NSDictionary newDictionaryWithObjects:forKeys:count:]";
      *(_WORD *)(v17 + 12) = 2048;
      *(void *)(v17 + 14) = v14;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: pointer to objects array is NULL but length is %lu",  "+[NSDictionary newDictionaryWithObjects:forKeys:count:]",  v14);
    }
  }

  uint64_t v8 = *((void *)&v11 + 1);
  if (!*((void *)&v11 + 1))
  {
    __CFBasicHashAddValue(a1, v10, a2, a3);
    return 1LL;
  }

  uint64_t result = 0LL;
  ++*(_WORD *)(a1 + 16);
  if (v8 <= 0x7FFFFFFFFFFFFFFELL && (*(_WORD *)(a1 + 18) & 0x18) != 0)
  {
    __CFBasicHashIncSlotCount(a1);
    return 1LL;
  }

  return result;
}

  if (*((void *)&v9 + 1)) {
    return __CFBasicHashReplaceValue(v6, v8, a2, a3);
  }
  return result;
}

  if (*((void *)&v9 + 1)) {
    __CFBasicHashReplaceValue(a1, v8, a2, a3);
  }
  else {
    __CFBasicHashAddValue(a1, v8, a2, a3);
  }
}

    if (v6 <= v12 + 1) {
      unsigned int v19 = v6;
    }
    else {
      unsigned int v19 = 0LL;
    }
    uint64_t v12 = v12 + 1 - v19;
    if (!--v15) {
      goto LABEL_27;
    }
  }

  uint64_t v17 = a2;
LABEL_34:
  uint64_t v22 = *(void *)(*v10 + 8 * v12);
  uint64_t v23 = -1LL;
  if (v22 != 2780474809LL) {
    uint64_t v23 = *(void *)(*v10 + 8 * v12);
  }
  if (v22 == 2814029233LL) {
    int v24 = 0LL;
  }
  else {
    int v24 = v23;
  }
  char v20 = v26;
  v26[1] = v17;
  void v26[2] = v24;
  objc_class *v26 = v12;
  unint64_t v25 = *(unsigned __int16 *)(a1 + 18);
  if ((v25 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  uint64_t v16 = 1LL;
LABEL_28:
  v20[3] = v16;
  return result;
}

  CFRange v26 = v24 != 0;
  if (!v24) {
    goto LABEL_45;
  }
LABEL_22:
  if (!value)
  {
LABEL_45:
    if (v16) {
      unint64_t v37 = v26;
    }
    else {
      unint64_t v37 = 0;
    }
    if (!v37)
    {
      if (!v26) {
        goto LABEL_118;
      }
      goto LABEL_111;
    }

uint64_t __CFFromMacFarsi(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  if (a5 >= a3 || a5 == 0) {
    uint64_t result = a3;
  }
  else {
    uint64_t result = a5;
  }
  if (result >= 1)
  {
    uint64_t v8 = result;
    while (1)
    {
      int v10 = *a2++;
      unsigned __int8 v9 = v10;
      int v11 = v10;
      if (v10 < 0)
      {
        if ((v9 + 80) > 9u)
        {
          LOWORD(v11) = macarabic_to_uni[v11 - 128];
          if (!a5) {
            goto LABEL_14;
          }
LABEL_13:
          *a4 = v11;
          goto LABEL_14;
        }

        LOWORD(v11) = v9 + 1600;
      }

      if (a5) {
        goto LABEL_13;
      }
LABEL_14:
      ++a4;
      if (!--v8) {
        goto LABEL_19;
      }
    }
  }

  uint64_t result = 0LL;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWinArabic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&cp1256_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180BF601C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromWinArabic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp1256_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinArabicPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = *a2;
  if (v9 >= 0x80)
  {
    int v11 = a2[1];
    if (v11 == 1621)
    {
      if (v9 != 1575) {
        return 0LL;
      }
      unsigned int v10 = 1573;
    }

    else if (v11 == 1620)
    {
      uint64_t result = 0LL;
      if (*a2 > 0x6C0u)
      {
        switch(v9)
        {
          case 0x6C1u:
            unsigned int v10 = 1730;
            break;
          case 0x6D2u:
            unsigned int v10 = 1747;
            break;
          case 0x6D5u:
            unsigned int v10 = 1728;
            break;
          default:
            return result;
        }
      }

      else
      {
        switch(v9)
        {
          case 0x627u:
            unsigned int v10 = 1571;
            break;
          case 0x648u:
            unsigned int v10 = 1572;
            break;
          case 0x64Au:
            unsigned int v10 = 1574;
            break;
          default:
            return result;
        }
      }
    }

    else
    {
      if (v11 != 1619 || v9 != 1575) {
        return 0LL;
      }
      unsigned int v10 = 1570;
    }
  }

  else
  {
    unsigned int v10 = __CFStringEncodingPrecomposeLatinCharacter(a2, a3, 0LL);
    if (v10 <= 0x7F) {
      goto LABEL_33;
    }
  }

  unsigned int v13 = (unsigned __int16 *)&cp1256_from_uni;
  char v14 = (unsigned __int16 *)&unk_180BF601C;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    uint64_t v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v10) {
      break;
    }
    char v14 = v16 - 2;
LABEL_30:
    if (v13 > v14) {
      return 0LL;
    }
  }

  if (v17 < v10)
  {
    unsigned int v13 = v16 + 2;
    goto LABEL_30;
  }

  LOBYTE(v10) = v13[2 * v15 + 1];
LABEL_33:
  if (!(_BYTE)v10) {
    return 0LL;
  }
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFFromISOArabic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 < 0xA1) {
    goto LABEL_2;
  }
  if (a2 < 0xC1)
  {
    uint64_t result = 0LL;
    if ((int)a2 <= 172)
    {
      if (a2 == 164) {
        goto LABEL_2;
      }
      if (a2 == 172)
      {
        LOWORD(a2) = 1548;
        goto LABEL_2;
      }
    }

    else
    {
      switch(a2)
      {
        case 0xADu:
          goto LABEL_2;
        case 0xBBu:
          LOWORD(a2) = 1563;
          goto LABEL_2;
        case 0xBFu:
          LOWORD(a2) = 1567;
          goto LABEL_2;
      }
    }
  }

  else
  {
    uint64_t result = 0LL;
    if (a2 <= 0xF2 && (a2 + 37) >= 5u)
    {
      LOWORD(a2) = a2 + 1376;
LABEL_2:
      *a3 = a2;
      return 1LL;
    }
  }

  return result;
}

uint64_t __CFToISOArabicPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v9 = a2[1];
  if (v9 == 1621)
  {
    if (*a2 == 1575)
    {
      int v10 = 1573;
      goto LABEL_18;
    }

uint64_t CFUniCharGetBidiCategory(uint64_t result, uint64_t a2, _BYTE *a3)
{
  if (a2 >= 1)
  {
    uint64_t v4 = (unsigned __int16 *)result;
    uint64_t result = 0LL;
    uint64_t v5 = -1LL;
    uint64_t v6 = &v4[a2];
    do
    {
      uint64_t v7 = v4 + 1;
      unsigned int v8 = *v4;
      if ((v8 & 0xFC00) != 0xD800 || v7 >= v6)
      {
        ++v4;
      }

      else
      {
        int v10 = *v7;
        BOOL v11 = (v10 & 0xFC00) == 56320;
        int v12 = v10 + (v8 << 10) - 56613888;
        if (v11) {
          v4 += 2;
        }
        else {
          ++v4;
        }
        if (v11) {
          unsigned int v8 = v12;
        }
      }

      if (v5 != (HIWORD(v8) & 0x1F))
      {
        uint64_t result = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v8) & 0x1F);
        uint64_t v5 = HIWORD(v8) & 0x1F;
      }

      if (result)
      {
        unint64_t v13 = *(unsigned __int8 *)(result + BYTE1(v8));
        if (v13 >= 0x13) {
          LOBYTE(v13) = *(_BYTE *)(result + (((_DWORD)v13 << 8) - 4864) + v8 + 256);
        }
      }

      else
      {
        LOBYTE(v13) = 1;
      }

      *a3 = v13;
      if (v8 < 0x10000)
      {
        ++a3;
      }

      else
      {
        a3[1] = v13;
        a3 += 2;
      }
    }

    while (v4 < v6);
  }

  return result;
}

uint64_t CFUniCharGetFirstBidiParagraphLength(uint64_t a1, uint64_t a2)
{
  if (a2 < 1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  while (1)
  {
    int v3 = *(unsigned __int8 *)(a1 + v2);
    if (v3 == 13) {
      break;
    }
    if (a2 == ++v2) {
      return a2;
    }
  }

  a2 = v2 + 1;
  *(_BYTE *)(a1 + v2) = 10;
  return a2;
}

uint64_t CFUniCharApplyUnicodeBidiAlgorithm(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 < 1) {
    return result;
  }
  unint64_t v5 = a2;
  int v6 = result;
  unint64_t v7 = a2 + a4;
  if ((result & 1) != 0) {
    int v8 = 1;
  }
  else {
    int v8 = 2;
  }
  int v76 = result & 1;
  BOOL v77 = !(result & 1);
  int v78 = v8;
  int v81 = result;
  unint64_t v79 = a2 + a4;
  do
  {
    uint64_t v9 = v7 - v5;
    if (v9 < 1)
    {
      uint64_t result = resolveExplicit(v6, 0, v5, a3, 0LL, 0LL);
      int v13 = 0;
      uint64_t v12 = 0LL;
      int v14 = 0;
      int v15 = 0;
      int v16 = v76;
      int v17 = v78;
      goto LABEL_72;
    }

    uint64_t v10 = 0LL;
    while (1)
    {
      int v11 = *(unsigned __int8 *)(v5 + v10);
      if (v11 == 13) {
        break;
      }
      if (v9 == ++v10)
      {
        uint64_t result = resolveExplicit(v6, 0, v5, a3, v9, 0LL);
        uint64_t v12 = v9;
        goto LABEL_15;
      }
    }

    uint64_t v18 = v10 + 1;
    *(_BYTE *)(v5 + v10) = 10;
    uint64_t result = resolveExplicit(v6, 0, v5, a3, v10 + 1, 0LL);
    uint64_t v12 = v18;
LABEL_15:
    int v15 = 0;
    uint64_t v19 = 0LL;
    int v20 = v6;
    int v17 = v78;
    int v21 = v6;
    do
    {
      unsigned __int8 v22 = *(_BYTE *)(v5 + v19);
      if ((v22 & 0x7F) == 0xA)
      {
        *(_BYTE *)(a3 + v19) = v21;
        uint64_t v23 = v19 + 1;
        if (v19 + 1 != v12 || v21 == v81)
        {
          if (v23 >= v12 || (int v43 = *(unsigned __int8 *)(a3 + v23), v21 == v43) || *(_BYTE *)(v5 + v23) == 10)
          {
            if (v15) {
              ++v15;
            }
            else {
              int v15 = 0;
            }
            char v42 = *(_BYTE *)(v5 + v19) | 0x80;
            goto LABEL_64;
          }

          if (v21 > v43) {
            LOBYTE(v43) = v21;
          }
          *(_BYTE *)(a3 + v19) = v43;
          if ((v43 & 1) != 0) {
            unsigned __int8 v22 = 2;
          }
          else {
            unsigned __int8 v22 = 1;
          }
          *(_BYTE *)(v5 + v19) = v22;
          int v21 = *(unsigned __int8 *)(a3 + v23);
        }

        else
        {
          if ((v21 & 1) != 0) {
            unsigned __int8 v22 = 2;
          }
          else {
            unsigned __int8 v22 = 1;
          }
          *(_BYTE *)(v5 + v19) = v22;
        }

        char v24 = 0x80;
      }

      else
      {
        char v24 = 0;
      }

      uint64_t v25 = (int)v19 - 1;
      int v26 = *(unsigned __int8 *)(a3 + v19);
      if (v20 != v26)
      {
        BOOL v27 = v22 > 5u || ((1 << v22) & 0x26) == 0;
        if (v27)
        {
          if (v15 >= 1)
          {
            if (v21 <= v26) {
              char v28 = *(_BYTE *)(a3 + v19);
            }
            else {
              char v28 = v21;
            }
            BOOL v27 = (v28 & 1) == 0;
            uint64_t v29 = 2LL;
            if (v27) {
              uint64_t v29 = 1LL;
            }
            int v30 = actionWeak[10 * v17 + v29] >> 4;
            if (v30 != 15)
            {
              int v31 = v19 - v15;
              uint64_t v32 = v12;
              uint64_t result = (uint64_t)memset( (void *)(v5 + v25 - (v25 - v31)),  v30,  (v25 - v31) + 1LL);
              uint64_t v12 = v32;
              int v15 = 0;
              int v26 = *(unsigned __int8 *)(a3 + v19);
            }
          }

          if (v20 <= v26) {
            char v33 = v26;
          }
          else {
            char v33 = v20;
          }
          if ((v33 & 1) != 0) {
            int v17 = 1;
          }
          else {
            int v17 = 2;
          }
        }

        int v20 = v26;
      }

      uint64_t v34 = v22;
      unsigned int v35 = actionWeak[10 * v17 + v22];
      int v36 = v35 >> 4;
      if (v36 != 15)
      {
        if (v15 >= 1)
        {
          int v37 = v19 - v15;
          uint64_t v38 = (v25 - v37);
          uint64_t v39 = (void *)(v5 + v25 - v38);
          uint64_t v40 = v12;
          uint64_t result = (uint64_t)memset(v39, v36, v38 + 1);
          uint64_t v12 = v40;
        }

        int v15 = 0;
      }

      char v41 = v35 & 0xF;
      if ((v35 & 0xF) == 0xF) {
        char v41 = *(_BYTE *)(v5 + v19);
      }
      v15 += (v35 >> 8) & 1;
      int v17 = stateWeak[10 * v17 + v34];
      char v42 = v41 | v24;
      uint64_t v23 = v19 + 1;
LABEL_64:
      *(_BYTE *)(v5 + v19) = v42;
      uint64_t v19 = v23;
    }

    while (v23 != v12);
    int v16 = v21 & 1;
    int v13 = 1;
    int v14 = v12;
    int v6 = v81;
LABEL_72:
    BOOL v27 = v16 == 0;
    uint64_t v44 = 2LL;
    if (v27) {
      uint64_t v44 = 1LL;
    }
    int v45 = actionWeak[10 * v17 + v44] >> 4;
    BOOL v46 = v45 == 15 || v15 < 1;
    uint64_t v80 = v12;
    if (!v46)
    {
      int v47 = v14 - v15;
      int v48 = v14 - 1;
      if (v47 >= v48) {
        int v47 = v48;
      }
      uint64_t result = (uint64_t)memset((void *)(v5 - (v48 - v47) + v48), v45, (v48 - v47) + 1LL);
      uint64_t v12 = v80;
    }

    if (v13)
    {
      int v75 = v13;
      int v49 = 0;
      int v50 = 0;
      int v51 = -1;
      v52 = (char *)v5;
      v53 = (char *)a3;
      uint64_t v54 = v12;
      int v55 = v77;
      char v56 = v6;
      uint64_t v82 = a3;
      do
      {
        unsigned int v57 = *v52;
        unsigned int v58 = v57;
        if ((v57 & 0x80) != 0)
        {
          unsigned int v58 = v57 & 0x7F;
          char *v52 = v57 & 0x7F;
        }

        int v59 = v51;
        if (v58 == 10)
        {
          if (v50) {
            ++v50;
          }
          else {
            int v50 = 0;
          }
          char v60 = 10;
        }

        else
        {
          unsigned int v61 = actionNeutrals[5 * v55 + v58];
          int v62 = v61 >> 4;
          if (v61 >> 4)
          {
            if (v62 == 3)
            {
              if ((v56 & 1) != 0) {
                int v62 = 2;
              }
              else {
                int v62 = 1;
              }
            }

            if (v50 >= 1)
            {
              int v63 = v49 - v50;
              if (v51 < v63) {
                int v63 = v51;
              }
              uint64_t result = (uint64_t)memset( (void *)(v5 + v51 - (unint64_t)(v51 - v63)),  v62,  (v51 - v63) + 1LL);
              uint64_t v12 = v80;
            }

            int v50 = 0;
          }

          char v60 = v61 & 0xF;
          if ((v61 & 0xF) != 0) {
            char *v52 = v60;
          }
          else {
            char v60 = *v52;
          }
          v50 += (v61 >> 8) & 1;
          int v55 = stateNeutrals[5 * v55 + v58];
          char v56 = *v53;
          a3 = v82;
        }

        *v52++ = v60 | v57 & 0x80;
        ++v53;
        int v51 = v59 + 1;
        ++v49;
        --v54;
      }

      while (v54);
      int v64 = v56 & 1;
      int v65 = v12;
      int v6 = v81;
      unint64_t v7 = v79;
      int v13 = v75;
    }

    else
    {
      int v50 = 0;
      int v65 = 0;
      int v64 = v76;
      int v55 = v77;
      unint64_t v7 = v79;
    }

    if (v64) {
      unsigned int v66 = 2;
    }
    else {
      unsigned int v66 = 1;
    }
    if (actionNeutrals[5 * v55 + v66] >> 4)
    {
      if (v50 >= 1)
      {
        int v67 = v65 - v50;
        int v68 = v65 - 1;
        if (v67 >= v68) {
          int v67 = v68;
        }
        uint64_t result = (uint64_t)memset((void *)(v5 - (v68 - v67) + v68), v66, (v68 - v67) + 1LL);
        uint64_t v12 = v80;
      }
    }

    if (v13)
    {
      v69 = (char *)v5;
      v70 = (_BYTE *)a3;
      uint64_t v71 = v12;
      LOBYTE(v72) = v6;
      do
      {
        int v74 = *v69++;
        unsigned __int8 v73 = v74;
        if ((v74 & 0x80000000) == 0) {
          int v72 = *v70 + addLevel[4 * (*v70 & 1) - 1 + v73];
        }
        *v70++ = v72;
        --v71;
      }

      while (v71);
    }

    v5 += v12;
    a3 += v12;
  }

  while (v5 < v7);
  return result;
}

uint64_t resolveExplicit(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a5 >= 1)
  {
    uint64_t v6 = a5;
    char v10 = a1;
    uint64_t v11 = 0LL;
    if ((a1 & 1) != 0) {
      int v12 = 2;
    }
    else {
      int v12 = 1;
    }
    unsigned int v13 = v12 + a1;
    if ((a1 & 1) != 0) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    unsigned int v15 = v14 + a1;
    int v23 = a6;
    uint64_t v16 = a6;
    while (1)
    {
      int v17 = *(unsigned __int8 *)(a3 + v11);
      if ((v17 - 14) < 2)
      {
        uint64_t v18 = (v16 + 1);
        if (v13 > 0x3D)
        {
LABEL_27:
          LOBYTE(v17) = -118;
          *(_BYTE *)(a3 + v11) = -118;
LABEL_29:
          *(_BYTE *)(a4 + v11) = v10;
          if ((*(_BYTE *)(a3 + v11) & 0x7F) != 0xA)
          {
            if (a2) {
              LOBYTE(v17) = a2;
            }
            *(_BYTE *)(a3 + v11) = v17;
          }

          uint64_t v16 = v18;
          goto LABEL_34;
        }

        *(_BYTE *)(a4 + v11) = v13;
        *(_BYTE *)(a3 + v11) = -118;
        uint64_t v19 = *(unsigned __int8 *)(a4 + v11);
        uint64_t v20 = 2 * (v17 != 15);
      }

      else
      {
        if ((v17 - 16) >= 2)
        {
          if (v17 == 18)
          {
            *(_BYTE *)(a3 + v11) = -118;
            else {
              uint64_t v21 = v6;
            }
            if ((_DWORD)v16) {
              uint64_t v18 = v16 - ((int)v16 > v23);
            }
            else {
              uint64_t v18 = 0LL;
            }
            if ((_DWORD)v16) {
              uint64_t v6 = v21;
            }
            LOBYTE(v17) = -118;
          }

          else
          {
            uint64_t v18 = v16;
          }

          goto LABEL_29;
        }

        uint64_t v18 = (v16 + 1);
        if (v15 > 0x3D) {
          goto LABEL_27;
        }
        *(_BYTE *)(a4 + v11) = v15;
        *(_BYTE *)(a3 + v11) = -118;
        uint64_t v19 = *(unsigned __int8 *)(a4 + v11);
        uint64_t v20 = v17 != 17;
      }

      v11 += resolveExplicit(v19, v20, a3 + v11 + 1, a4 + v11 + 1, v6 - (v11 + 1), v18);
LABEL_34:
      if (++v11 >= v6) {
        return v11;
      }
    }
  }

  return 0LL;
}

BOOL CFAttributedStringGetBidiLevels( const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFAttributedStringGetBidiLevelsAndResolvedDirections(a1, a2, a3, a4, a5, 0LL, a7, a8);
}

BOOL CFAttributedStringGetBidiLevelsAndResolvedDirections( const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v174 = a4;
  uint64_t v219 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    int v14 = @"attributedString cannot be NULL";
LABEL_285:
    CFLog(3LL, (uint64_t)v14, a3, a4, a5, a6, a7, a8, v167);
    return 0LL;
  }

  if (!a5)
  {
    int v14 = @"bidiLevels cannot be NULL";
    goto LABEL_285;
  }

  uint64_t v9 = a6;
  uint64_t v10 = a3;
  String = CFAttributedStringGetString(a1);
  CFStringRef theString = String;
  uint64_t v206 = a2;
  int64_t v207 = v10;
  CharactersPtr = CFStringGetCharactersPtr(String);
  if (CharactersPtr) {
    CStringPtr = 0LL;
  }
  else {
    CStringPtr = CFStringGetCStringPtr(String, 0x600u);
  }
  int64_t v208 = 0LL;
  int64_t v209 = 0LL;
  v205 = CStringPtr;
  if (!ubidi_open())
  {
    int v14 = @"ubidi_open return NULL object";
    goto LABEL_285;
  }

  if (v10 <= 0)
  {
    ubidi_close();
    return 0LL;
  }

  v168 = (_BYTE *)a5;
  int64_t v15 = 0LL;
  uint64_t UnicodePropertyDataForPlane = 0LL;
  uint64_t v177 = a2 - 1;
  char v178 = -1;
  uint64_t v169 = v10;
  uint64_t v170 = a2;
  uint64_t v171 = v9;
  do
  {
    int64_t v179 = v15 + 1;
    if (v15 < 0 || (int64_t v17 = v207, v207 <= v15))
    {
      unsigned int v21 = 0;
      goto LABEL_17;
    }

    uint64_t v18 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      int64_t v19 = v206 + v15;
    }

    else
    {
      if (v205)
      {
        UniChar v20 = v205[v206 + v15];
        goto LABEL_33;
      }

      if (v209 <= v15 || (int64_t v132 = v208, v208 > v15))
      {
        int64_t v133 = v15 - 4;
        if (v133 + 64 < v207) {
          int64_t v17 = v133 + 64;
        }
        int64_t v208 = v133;
        int64_t v209 = v17;
        v221.int location = v206 + v133;
        v221.CFIndex length = v17 - v133;
        CFStringGetCharacters(theString, v221, buffer);
        int64_t v132 = v208;
      }

      int64_t v19 = v15 - v132;
      uint64_t v18 = buffer;
    }

    UniChar v20 = v18[v19];
LABEL_33:
    unsigned int v21 = v20;
    if (v20 >> 10 != 54) {
      goto LABEL_17;
    }
    int64_t v28 = v207;
    if (v207 <= v179) {
      goto LABEL_17;
    }
    uint64_t v29 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      int64_t v30 = v206 + v179;
LABEL_37:
      UniChar v31 = v29[v30];
      goto LABEL_223;
    }

    if (!v205)
    {
      if (v209 <= v179 || (int64_t v141 = v208, v208 > v179))
      {
        int64_t v142 = v15 - 3;
        if (v142 + 64 < v207) {
          int64_t v28 = v142 + 64;
        }
        int64_t v208 = v142;
        int64_t v209 = v28;
        v222.int location = v206 + v142;
        v222.CFIndex length = v28 - v142;
        CFStringGetCharacters(theString, v222, buffer);
        int64_t v141 = v208;
      }

      int64_t v30 = v179 - v141;
      uint64_t v29 = buffer;
      goto LABEL_37;
    }

    UniChar v31 = v205[v206 + v179];
LABEL_223:
    if (v31 >> 10 == 55)
    {
      int64_t v134 = v207;
      if (v207 <= v179)
      {
        UniChar v137 = 0;
      }

      else
      {
        v135 = (UniChar *)CharactersPtr;
        if (CharactersPtr)
        {
          int64_t v136 = v206 + v179;
        }

        else
        {
          if (v205)
          {
            UniChar v137 = v205[v206 + v179];
            goto LABEL_236;
          }

          if (v209 <= v179 || (int64_t v161 = v208, v208 > v179))
          {
            int64_t v162 = v15 - 3;
            if (v162 + 64 < v207) {
              int64_t v134 = v162 + 64;
            }
            int64_t v208 = v162;
            int64_t v209 = v134;
            v223.int location = v206 + v162;
            v223.CFIndex length = v134 - v162;
            CFStringGetCharacters(theString, v223, buffer);
            int64_t v161 = v208;
          }

          int64_t v136 = v179 - v161;
          v135 = buffer;
        }

        UniChar v137 = v135[v136];
      }

LABEL_236:
      int64_t v179 = v15 + 2;
      unsigned int v21 = (v21 << 10) + v137 - 56613888;
    }

LABEL_131:
      v83 = (UniChar *)CFAllocatorAllocate(0LL, 2 * numChars, 0LL);
      v84 = v83;
      if (CharactersPtr)
      {
        memmove(v83, &CharactersPtr[v206 + v40], 2 * numChars);
      }

      else
      {
        int64_t v88 = v40 - v208;
        if (v40 < v208 || v209 <= v40)
        {
          if (v41 <= v208 || v41 >= v209)
          {
            int64_t v92 = v40;
            v91 = v83;
            CFIndex v93 = numChars;
          }

          else
          {
            int64_t v92 = v40;
            CFIndex v93 = v208 - v40;
            memmove(&v83[v208 - v40], buffer, 2 * (v41 - v208));
            v91 = v84;
          }
        }

        else
        {
          int64_t v89 = v40;
          if (numChars >= v209 - v40) {
            uint64_t v90 = v209 - v40;
          }
          else {
            uint64_t v90 = numChars;
          }
          memmove(v83, &buffer[v88], 2 * v90);
          v91 = &v84[v90];
          int64_t v92 = v90 + v89;
          CFIndex v93 = numChars - v90;
        }

        if (v93 >= 1)
        {
          v100.int location = v206 + v92;
          if (v205)
          {
            v101 = &v205[v100.location];
            do
            {
              UniChar v102 = *v101++;
              *v91++ = v102;
              --v93;
            }

            while (v93);
          }

          else
          {
            v100.CFIndex length = v93;
            CFStringGetCharacters(theString, v100, v91);
          }
        }
      }

      CFStringRef v85 = CFStringCreateWithCharactersNoCopy(0LL, v84, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v85)
      {
        v86 = v85;
        int v87 = 1;
        goto LABEL_167;
      }

LABEL_171:
      CFAllocatorDeallocate(0LL, v84);
LABEL_75:
      v225.int location = v177 + 1;
      v225.CFIndex length = inRange;
      uint64_t v32 = CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, loc, @"NSWritingDirection", v225, &values);
      char v33 = 0;
      CFIndex v55 = values.length + values.location;
      if (v39 < values.length + values.location) {
        CFIndex v55 = v39;
      }
      uint64_t numChars = v55 - loc;
LABEL_78:
      uint64_t v56 = v187;
      int v36 = ptr;
      if (v188 + 2 <= (int)v187)
      {
        unsigned int v35 = range_8;
      }

      else
      {
        char v184 = v33;
        v180 = CFAllocatorAllocate(0LL, 16LL * (_DWORD)v187, 0LL);
        memcpy(v180, range_8, 8LL * (int)v187);
        unsigned int v57 = CFAllocatorAllocate(0LL, 8LL * (_DWORD)v187, 0LL);
        memcpy(v57, ptr, 4LL * (int)v187);
        if ((v182 & 1) != 0)
        {
          CFAllocatorDeallocate(0LL, range_8);
          CFAllocatorDeallocate(0LL, ptr);
        }

        char v182 = 1;
        unsigned int v35 = (void **)v180;
        uint64_t v56 = (2 * v187);
        int v36 = v57;
        char v33 = v184;
      }

      uint64_t v187 = v56;
      if (!v32)
      {
        if (v34 >= 1)
        {
          int v75 = CFAllocatorAllocate(0LL, 10LL, 0LL);
          for (uint64_t i = 0LL; i != v34; ++i)
          {
            uint64_t v77 = *((int *)v212 + i);
            else {
              __int16 v78 = *(_WORD *)&aHI[2 * v77 + 4];
            }
            v75[i] = v78;
            *((_DWORD *)v212 + i) = -1;
          }

          unint64_t v79 = &v75[v34];
          uint64_t v34 = 0LL;
          CFIndex v74 = loc;
LABEL_125:
          *unint64_t v79 = 0;
          v35[v188] = v75;
          *((_DWORD *)v36 + v188++) = v74 - range;
          goto LABEL_127;
        }

LABEL_116:
        CFIndex v74 = loc;
        goto LABEL_127;
      }

      ptra = v36;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v32);
      if (Count < 1) {
        goto LABEL_116;
      }
      CFIndex v59 = Count;
      char v185 = v33;
      range_8a = v35;
      CFIndex v60 = 0LL;
      unsigned int v61 = 0LL;
      uint64_t v62 = 0LL;
      uint64_t v63 = 0LL;
      while (2)
      {
        LODWORD(values.location) = 0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v32, v60);
        CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &values);
        int location = values.location;
        if (LODWORD(values.location) == LODWORD(v214[0]))
        {
          uint64_t v66 = 0LL;
LABEL_91:
          if (LODWORD(values.location) == *((_DWORD *)v212 + v66))
          {
            if (v34 >= 1)
            {
              for (uint64_t j = 0LL; j < v34; ++j)
              {
                int v69 = *((_DWORD *)v212 + j);
                if (location != v69)
                {
                  *((_DWORD *)v210 + v62++) = v69;
                  *((_DWORD *)v212 + j) = -1;
                  --v34;
                }
              }
            }

            goto LABEL_106;
          }

          char v70 = 1;
          if (v61) {
            goto LABEL_106;
          }
LABEL_101:
          uint64_t v71 = CFAllocatorAllocate(0LL, 10LL, 0LL);
          unsigned int v61 = v71;
          int v72 = values.location;
          if (LODWORD(values.location) > 9) {
            __int16 v73 = 0;
          }
          else {
            __int16 v73 = *(_WORD *)&aFG[2 * SLODWORD(values.location)];
          }
          v71[v63++] = v73;
          *((_DWORD *)v212 + v34++) = v72;
          if ((v70 & 1) == 0) {
            *((_DWORD *)v214 + v193++) = v72;
          }
        }

        else
        {
          uint64_t v66 = 0LL;
          while (v66 != 3)
          {
            int v67 = *((_DWORD *)v214 + ++v66);
            if (LODWORD(values.location) == v67) {
              goto LABEL_91;
            }
          }

          char v70 = 0;
          if (!v61) {
            goto LABEL_101;
          }
        }

          uint64_t v56 = vcvtmd_s64_f64(v47 * 5.42101086e-20);
          CFIndex v55 = (unint64_t)(v47 + floor(v47 * 5.42101086e-20) * -1.84467441e19);
        }

        if (v56 < v27) {
          return 0LL;
        }
        goto LABEL_122;
      }

      *(double *)a3 = (double)v27;
      int64_t v28 = (uint64_t)(double)v27;
      return v27 == v28;
    case 17LL:
      unsigned int v35 = __CFNumberTypeTable[v10];
      if ((v35 & 0x20) == 0)
      {
        if ((v35 & 0x40) != 0)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
        }

        else
        {
          int v36 = *v11;
          *(void *)a3 = v36 >> 63;
          *(void *)(a3 + 8) = v36;
        }

        return 1LL;
      }

      if ((v35 & 0x40) != 0)
      {
        CFIndex v59 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v59 >= 1.70141183e38)
          {
            CFIndex v60 = -1LL;
            unsigned int v61 = 0x7FFFFFFFFFFFFFFFLL;
          }

          else
          {
            unsigned int v61 = vcvtmd_s64_f64(v59 * 5.42101086e-20);
            CFIndex v60 = (unint64_t)(v59 + floor(v59 * 5.42101086e-20) * -1.84467441e19);
          }
        }

        else
        {
          CFIndex v60 = 0LL;
          unsigned int v61 = 0x8000000000000000LL;
        }

        *(void *)a3 = v61;
        *(void *)(a3 + 8) = v60;
        int v68 = -v61;
        if (v60) {
          int v68 = ~v61;
        }
        if (v61 >= 0) {
          int v68 = v61;
        }
        else {
          CFIndex v60 = -(uint64_t)v60;
        }
        int v69 = -((double)v60 + (double)v68 * 1.84467441e19);
        if (v61 >= 0) {
          int v69 = (double)v60 + (double)v68 * 1.84467441e19;
        }
        return v69 == v59;
      }

      else
      {
        CFIndex v37 = *(float *)v11;
        if (*(float *)v11 >= -1.7014e38)
        {
          if (v37 >= 1.7014e38)
          {
            int64_t v41 = -1LL;
            CFIndex v42 = 0x7FFFFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v62 = v37 * 5.42101086e-20;
            CFIndex v42 = vcvtmd_s64_f64(v62);
            int64_t v41 = (unint64_t)(v37 + floor(v62) * -1.84467441e19);
          }
        }

        else
        {
          int64_t v41 = 0LL;
          CFIndex v42 = 0x8000000000000000LL;
        }

        *(void *)a3 = v42;
        *(void *)(a3 + 8) = v41;
        uint64_t v66 = -v42;
        if (v41) {
          uint64_t v66 = ~v42;
        }
        if (v42 < 0) {
          int64_t v41 = -(uint64_t)v41;
        }
        else {
          uint64_t v66 = v42;
        }
        int v67 = -((double)v41 + (double)v66 * 1.84467441e19);
        if (v42 >= 0) {
          int v67 = (double)v41 + (double)v66 * 1.84467441e19;
        }
        CFIndex v39 = v67;
        return v37 == v39;
      }

    default:
      return result;
  }

        if (length < v8 || v9 == 0LL) {
          CFIndex v60 = length;
        }
        else {
          CFIndex v60 = v8;
        }
        if (v9) {
          memmove(v9, v26, v60);
        }
        goto LABEL_127;
      }
    }

    unsigned int v61 = 0LL;
    if (!v9) {
      goto LABEL_196;
    }
    goto LABEL_125;
  }

      int v8 = v12;
      goto LABEL_117;
    }

    int v8 = v12;
    a2 = v54;
    uint64_t v45 = (uint64_t (**)(void))&unk_18C539000;
    if (!v13) {
      goto LABEL_139;
    }
LABEL_118:
    int64_t v46 = v11 + 3;
    if (a5)
    {
      if (v46 <= a5)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16936;
        break;
      }

      do
      {
        UniChar v47 = v8;
        unsigned int v48 = *(unsigned __int16 *)(v9 + 2 * v8);
        if (((v48 - 774) > 0x32 || ((1LL << (v48 - 6)) & 0x4000000000005LL) == 0)
          && (v48 - 12441) >= 2)
        {
          uint64_t v51 = v45[451]();
          a2 = v54;
        }

        else
        {
          uint64_t v51 = 1;
        }

        --v8;
      }

      while (v47 >= 2 && (v51 & 1) != 0);
      if (v47 < 2)
      {
        int64_t v46 = 0LL;
        break;
      }

      a4 -= v11;
      continue;
    }

    break;
  }

LABEL_106:
        if (++v60 != v59) {
          continue;
        }
        break;
      }

      if (v61)
      {
        v61[v63] = 0;
        unsigned int v35 = range_8a;
        range_8a[v188] = v61;
        int v36 = ptra;
        CFIndex v74 = loc;
        *((_DWORD *)ptra + v188++) = loc - range;
      }

      else
      {
        CFIndex v74 = loc;
        int v36 = ptra;
        unsigned int v35 = range_8a;
      }

      if (v62 >= 1)
      {
        int v75 = CFAllocatorAllocate(0LL, 10LL, 0LL);
        for (uint64_t k = 0LL; k != v62; ++k)
        {
          uint64_t v81 = *((int *)v210 + k);
          else {
            __int16 v82 = *(_WORD *)&aHI[2 * v81 + 4];
          }
          v75[k] = v82;
        }

        unint64_t v79 = &v75[v62];
        char v33 = v185;
        goto LABEL_125;
      }

      char v33 = v185;
LABEL_127:
      CFIndex v37 = numChars + v74;
    }

    while (v37 < v181);
    char v105 = v33 ^ 1;
    if (!v32) {
      char v105 = 1;
    }
    if ((v105 & 1) == 0) {
      CFRelease(v32);
    }
    ptrb = v36;
    if (v34 < 1)
    {
      v120 = 0LL;
      uint64_t v10 = v169;
    }

    else
    {
      v106 = v35;
      v107 = (UniChar *)CFAllocatorAllocate(0LL, 10LL, 0LL);
      v108 = v107;
      uint64_t v109 = 0LL;
      uint64_t UnicodePropertyDataForPlane = v176;
      do
      {
        uint64_t v110 = *((int *)v212 + v109);
        else {
          UniChar v111 = *(_WORD *)&aHI[2 * v110 + 4];
        }
        v107[v109++] = v111;
      }

      while (v34 != v109);
      v107[v34] = 0;
      ubidi_setContext();
      uint64_t v112 = code;
      if (code >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        u_errorName(code);
        CFLog( 3LL,  (uint64_t)@"ubidi_setContext() failed with errorCode: %d -- %s",  v113,  v114,  v115,  v116,  v117,  v118,  v112);
        uint64_t v10 = v169;
        v119 = v106;
        LODWORD(v106) = v188;
        goto LABEL_258;
      }

      v120 = v108;
      uint64_t v10 = v169;
      unsigned int v35 = v106;
    }

        if (v11 == 1) {
          a4 = CFStringGetCharacterAtIndex(v52, 0LL) == 47;
        }
        goto LABEL_108;
      }

      return 0LL;
    }

    CharacterAtIndex = CFStringGetCharacterAtIndex(v8, 0LL);
    int v12 = CharacterAtIndex != 58;
    v83.int location = 0LL;
    v83.CFIndex length = v11;
    uint64_t v77 = CFStringFindWithOptions(v8, @"::", v83, 0LL, 0LL);
    if (v77)
    {
      int64_t v15 = (UniChar *)malloc(2 * v11);
      v82.int location = 0LL;
      v82.CFIndex length = v11;
      CFStringGetCharacters(v8, v82, v15);
      uint64_t v16 = 0LL;
      int64_t v17 = 0LL;
      uint64_t v18 = -1LL;
      do
      {
        int64_t v19 = v15[v16];
        if (v19 == 58)
        {
          UniChar v20 = v16 + 1;
          if (v16 + 1 < v11 && v15[v20] == 58)
          {
            if (v17 >= 1 && (v18 & 0x8000000000000000LL) == 0)
            {
              if (v18 >= v17) {
                unsigned int v21 = v17;
              }
              else {
                unsigned int v21 = v18;
              }
              unsigned int v22 = v21 - 1;
              while (1)
              {
                if (v17 < 2)
                {
                  int64_t v17 = 0LL;
                  goto LABEL_25;
                }

                if (v17 <= v18) {
                  break;
                }
                BOOL v23 = v15[--v17];
                if (v23 == 58) {
                  goto LABEL_25;
                }
              }

              int64_t v17 = v22;
            }
          }

          else
          {
            UniChar v20 = v16;
          }

    BOOL v23 = 0;
    unsigned int v22 = 0;
    goto LABEL_112;
  }

  unsigned int v22 = v82;
  a7 = v71;
  a8 = v72;
  int64_t v19 = v70;
  if (a5)
  {
    unsigned int v22 = bswap32(v82);
    int v64 = v83;
    goto LABEL_109;
  }

  BOOL v23 = v83;
LABEL_112:
  if (v19) {
LABEL_113:
  }
    free(v19);
LABEL_114:
  if (a7) {
    *a7 = v24;
  }
  if (a8) {
    *a8 = v22;
  }
  if (a9) {
    *a9 = v23;
  }
}

LABEL_187:
    int64_t v121 = range - v206;
    if (range - v206 >= 0)
    {
      int64_t v122 = v207;
      if (v121 + inRange <= v207)
      {
        if (CharactersPtr)
        {
          v119 = v35;
          v108 = 0LL;
        }

        else
        {
          if (inRange > 64) {
            goto LABEL_189;
          }
          if (v121 + inRange > v209 || v121 < v208)
          {
            if (v121 + 64 < v207) {
              int64_t v122 = v121 + 64;
            }
            int64_t v208 = range - v206;
            int64_t v209 = v122;
            v128.CFIndex length = v122 - v121;
            if (v205)
            {
              if (v128.length)
              {
                v129 = &v205[v177 + 1];
                v130 = buffer;
                do
                {
                  UniChar v131 = *v129++;
                  *v130++ = v131;
                  --v128.length;
                }

                while (v128.length);
              }
            }

            else
            {
              v128.int location = v177 + 1;
              CFStringGetCharacters(theString, v128, buffer);
            }
          }

          v119 = v35;
          v108 = 0LL;
        }

        goto LABEL_249;
      }
    }

          uint64_t v32 = v26;
LABEL_188:
          CFIndex v60 = v32 - v26;
          uint64_t v110 = v32 - v26;
          UniChar v102 = v26;
          if (v9)
          {
            if (v60 >= v8) {
              CFIndex v60 = v8;
            }
            uint64_t v110 = v60;
            memmove(v9, v26, v60);
            uint64_t v9 = (UniChar *)((char *)v9 + v60);
            v8 -= v60;
          }

          if (!length || v9 && !v8) {
            goto LABEL_127;
          }
          location += v60;
          UniChar v111 = v60;
          unsigned int v61 = v102;
          if (!v9) {
            goto LABEL_196;
          }
LABEL_125:
          if (!v8) {
            goto LABEL_126;
          }
LABEL_196:
          if (!v9) {
            int v8 = 0LL;
          }
          if (a5)
          {
            uint64_t v81 = a5 == 255 && (_DWORD)a4 == 1536;
            __int16 v82 = (a5 << 24) | 1;
            if (v81) {
              __int16 v82 = 1;
            }
          }

          else
          {
            __int16 v82 = 0;
          }

          v83 = v82 | ((a3 != 0) << 8);
          v84 = __CFWantsToUseASCIICompatibleConversion;
          if (v23) {
            v84 = 0;
          }
          CFStringRef v85 = v83 | v84;
          if (!v61)
          {
            v98 = CFStringGetCharactersPtr(theString);
            if (v98)
            {
              CFStringEncodingUnicodeToBytes( a4,  v85,  (unsigned __int16 *)&v98[location],  length,  &v110,  (unsigned int *)v9,  v8,  &v111);
              goto LABEL_249;
            }
          }

          if (length < 1) {
            goto LABEL_249;
          }
          LOBYTE(v107) = 0;
          v86 = 0LL;
          int v87 = 0LL;
          v101 = v85 & 0xFFFFFEFF;
          while (1)
          {
            if (length >= 512) {
              int64_t v88 = 512LL;
            }
            else {
              int64_t v88 = length;
            }
            v125.int location = location;
            v125.CFIndex length = v88;
            CFStringGetCharacters(theString, v125, buffera);
            CFStringRef v103 = ((length > v88) << 12) | (v107 << 16) | v85;
            int64_t v89 = CFStringEncodingUnicodeToBytes(a4, v103, buffera, v88, &__src, (unsigned int *)v9, v8, &v109);
            LOBYTE(v107) = BYTE2(v89);
            uint64_t v90 = v89 & 0xFF00FFFF;
            if ((v89 & 0xFF00FFFF) != 0)
            {
              if (v90 != 1) {
                goto LABEL_248;
              }
              v91 = __src;
              if ((unint64_t)length >= 0x201 && (uint64_t)(v88 - __src) <= 5)
              {
                RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex( theString,  v88 + location);
                v91 = __src;
                uint64_t v90 = 1;
                if (RangeOfComposedCharactersAtIndex.length <= 6
                  && RangeOfComposedCharactersAtIndex.location < __src + location)
                {
                  CFIndex v93 = CFStringEncodingUnicodeToBytes( a4,  v103,  buffera,  RangeOfComposedCharactersAtIndex.location - location,  &__src,  (unsigned int *)v9,  v8,  &v109);
                  LOBYTE(v107) = BYTE2(v93);
                  uint64_t v90 = v93 & 0xFF00FFFF;
                  v91 = __src;
                }
              }

              if (v90 && v86 >= 1 && v91 <= 5)
              {
                int64_t v94 = CFStringGetRangeOfComposedCharactersAtIndex(theString, location);
                if (v94.length > 6) {
                  goto LABEL_248;
                }
                if (v94.location >= location) {
                  goto LABEL_248;
                }
                CFStringGetCharacters(theString, v94, buffera);
                location -= v86;
                v126.int location = location;
                v126.CFIndex length = v94.location - location;
                CFStringGetCharacters(theString, v126, buffera);
                int64_t v95 = v8 ? (unsigned int *)((char *)v9 - v87) : 0LL;
                CFRange v96 = v8 ? v8 + v87 : 0LL;
                v97 = CFStringEncodingUnicodeToBytes( a4,  v103,  buffera,  v94.location - location,  &__src,  v95,  v96,  &v109);
                if ((v97 & 0xFF00FFFF) != 0)
                {
LABEL_248:
                  v111 += v109;
                  v110 += __src;
                  goto LABEL_249;
                }

                v107 = HIWORD(v97);
                v111 -= v87;
                v110 -= v86;
                length += v86;
                if (v8) {
                  uint64_t v9 = (UniChar *)((char *)v9 - v87);
                }
                int v8 = v96;
              }

              else if (v90)
              {
                goto LABEL_248;
              }
            }

            int v87 = v109;
            v86 = __src;
            v111 += v109;
            v110 += __src;
            if (v8)
            {
              v8 -= v109;
              if (v8 < 1) {
                goto LABEL_249;
              }
              uint64_t v9 = (UniChar *)((char *)v9 + v109);
            }

            location += __src;
            CFStringRef v85 = v101;
            int64_t v44 = length <= __src;
            length -= __src;
            if (v44) {
              goto LABEL_249;
            }
          }
        }

        goto LABEL_116;
      }

      CFIndex v55 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        CFIndex v55 = __CFDefaultEightBitStringEncoding;
      }

      PascalStringPtr = CFStringGetPascalStringPtr(theString, v55);
      if (PascalStringPtr)
      {
        int v26 = &PascalStringPtr[location + 1];
        unsigned int v57 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          v106 = v23;
          unsigned int v58 = (uint64_t)&PascalStringPtr[location + 1];
          __CFStringComputeEightBitStringEncoding();
          int v26 = (const unsigned __int8 *)v58;
          BOOL v23 = v106;
          unsigned int v57 = __CFDefaultEightBitStringEncoding;
        }

        if (v57 != (_DWORD)a4)
        {
          if ((*(char *)v26 & 0x80000000) == 0 && length >= 1)
          {
            uint64_t v32 = v26;
            do
            {
              unint64_t v79 = *(char *)++v32;
              uint64_t v80 = length-- != 0;
            }

            while ((v79 & 0x80000000) == 0 && length != 0 && v80);
            goto LABEL_188;
          }

          goto LABEL_187;
        }

                    if ((unint64_t)v99 < v11)
                    {
                      uint64_t v154 = v99 + 1;
                      *UniChar v99 = 62;
                      uint64_t v115 = (uint64_t)&v10[v41 + 4];
                      goto LABEL_223;
                    }

LABEL_189:
    v119 = v35;
    v123 = (UniChar *)CFAllocatorAllocate(0LL, 2 * inRange, 0LL);
    v124 = v123;
    if (CharactersPtr)
    {
      memmove(v123, &CharactersPtr[v206 + v121], 2 * inRange);
      goto LABEL_191;
    }

    if (v121 < v208 || v209 <= v121)
    {
      if (v121 + inRange <= v208 || v121 + inRange >= v209)
      {
        v126 = v123;
        CFIndex v127 = inRange;
      }

      else
      {
        CFIndex v127 = v208 - v121;
        memmove(&v123[v208 - v121], buffer, 2 * (v121 + inRange - v208));
        v126 = v124;
      }
    }

    else
    {
      if (inRange >= v209 - v121) {
        uint64_t v125 = v209 - v121;
      }
      else {
        uint64_t v125 = inRange;
      }
      memmove(v123, &buffer[v121 - v208], 2 * v125);
      v126 = &v124[v125];
      v121 += v125;
      CFIndex v127 = inRange - v125;
    }

    if (v127 < 1) {
      goto LABEL_191;
    }
    v138.int location = v206 + v121;
    if (!v205)
    {
      v138.CFIndex length = v127;
      CFStringGetCharacters(theString, v138, v126);
LABEL_191:
      v108 = v124;
LABEL_249:
      uint64_t UnicodePropertyDataForPlane = v176;
      goto LABEL_250;
    }

    v139 = &v205[v138.location];
    uint64_t UnicodePropertyDataForPlane = v176;
    do
    {
      UniChar v140 = *v139++;
      *v126++ = v140;
      --v127;
    }

    while (v127);
    v108 = v124;
LABEL_250:
    UErrorCode code = U_ZERO_ERROR;
    ubidi_setParaWithControls();
    if (v120) {
      CFAllocatorDeallocate(0LL, v120);
    }
    uint64_t v143 = code;
    if (code >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      u_errorName(code);
      CFLog( 3LL,  (uint64_t)@"ubidi_setParaWithControls() failed with errorCode: %d -- %s",  v144,  v145,  v146,  v147,  v148,  v149,  v143);
      goto LABEL_256;
    }

    Levels = (const void *)ubidi_getLevels();
    uint64_t v151 = code;
    if (code < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (Levels) {
        memcpy(&v168[v172], Levels, inRange);
      }
      LODWORD(v106) = v188;
      if (v173)
      {
        int ParaLevel = ubidi_getParaLevel();
        memset(v173, ParaLevel, inRange);
      }
    }

    else
    {
      u_errorName(code);
      CFLog( 3LL,  (uint64_t)@"ubidi_getLevels() failed with errorCode: %d -- %s",  v152,  v153,  v154,  v155,  v156,  v157,  v151);
LABEL_256:
      LODWORD(v106) = v188;
    }

    if (v108) {
LABEL_258:
    }
      CFAllocatorDeallocate(0LL, v108);
    if ((int)v106 >= 1)
    {
      v106 = (void **)v106;
      v158 = v119;
      do
      {
        v159 = *v158++;
        CFAllocatorDeallocate(0LL, v159);
        v106 = (void **)((char *)v106 - 1);
      }

      while (v106);
    }

    a2 = v170;
    if ((v182 & 1) != 0)
    {
      CFAllocatorDeallocate(0LL, v119);
      CFAllocatorDeallocate(0LL, ptrb);
    }

    uint64_t v177 = v175;
    uint64_t v24 = v179;
    uint64_t v9 = v171;
LABEL_265:
    int64_t v15 = v24;
  }

  while (v24 < v10);
  ubidi_close();
  if ((*v168 & 1) != 0) {
    return 1LL;
  }
  uint64_t v163 = 1LL;
  do
  {
    uint64_t v164 = v163;
    if (v10 == v163) {
      break;
    }
    char v165 = v168[v163++];
  }

  while ((v165 & 1) == 0);
  return v164 < v10;
}

      if (v51 == v53 && v53 > 0) {
        int64_t v53 = 0LL;
      }
      v108 = v329;
      if (v53) {
        v108 = 0LL;
      }
      v59 += v108;
      CFIndex length = v315;
      v52 += v314;
      unsigned int v61 = v318;
      int v64 = v316;
      if (v59 >= v315) {
        goto LABEL_437;
      }
    }

    CFIndex v93 = v48;
    int64_t v94 = v55;
    int64_t v95 = v50;
    CFRange v96 = v22;
    v97 = v51;
    v98 = CFCharacterSetIsLongCharacterMember(theSet, v67);
    unsigned int v57 = v306;
    uint64_t v56 = v317 ^ 1;
    uint64_t v51 = v97;
    unsigned int v22 = v96;
    CFIndex v60 = v302;
    unsigned int v58 = v303;
    UniChar v47 = v304;
    int64_t v46 = v321;
    uint64_t v50 = v95;
    CFIndex v55 = v94;
    uint64_t v62 = v311;
    int64_t v49 = v317;
    unsigned int v48 = v93;
    if (v98) {
      goto LABEL_189;
    }
    int64_t v89 = v324;
    uint64_t v90 = v325;
    v91 = v324 & 4;
    v120 = (v324 >> 2) & 1;
LABEL_221:
    if (v90 > v68 || v326 <= v68)
    {
      if (!v91) {
        goto LABEL_330;
      }
      goto LABEL_251;
    }

    if (HIWORD(v68) || (v89 & 2) != 0)
    {
      v123 = v48;
      v124 = v55;
      uint64_t v125 = v50;
      v126 = v22;
      CFIndex v127 = v51;
      CFRange v128 = CFCharacterSetIsLongCharacterMember(theSet, v68);
      unsigned int v57 = v306;
      uint64_t v56 = v317 ^ 1;
      uint64_t v51 = v127;
      unsigned int v22 = v126;
      CFIndex v60 = v302;
      unsigned int v58 = v303;
      UniChar v47 = v304;
      int64_t v46 = v321;
      uint64_t v50 = v125;
      CFIndex v55 = v124;
      uint64_t v62 = v311;
      int64_t v49 = v317;
      unsigned int v48 = v123;
      if (!v128) {
        goto LABEL_330;
      }
      goto LABEL_251;
    }

    if (v327)
    {
      if ((v89 & 1) != 0)
      {
        UniChar v131 = *(unsigned __int8 *)(v327 + ((unint64_t)v68 >> 8));
        if (*(_BYTE *)(v327 + ((unint64_t)v68 >> 8)))
        {
          if ((_DWORD)v131 == 255)
          {
            v120 = v91 == 0;
          }

          else
          {
            int64_t v132 = v91 == 0;
          }
        }

        if (!v120) {
          goto LABEL_330;
        }
      }

      else
      {
        uint64_t v43 = v91 == 0;
        int64_t v121 = v91 != 0;
        int64_t v122 = v43;
        if (!v121) {
          goto LABEL_330;
        }
      }

uint64_t CFUniCharGetDefaultWritingDirection()
{
  v0 = __CFXPreferencesCopyCurrentApplicationState();
  uint64_t v1 = CFUniCharGetDefaultWritingDirection_defaultDirection;
  if (CFUniCharGetDefaultWritingDirection_defaultDirection == 255)
  {
    uint64_t v2 = v0;
    if ((__CFUniCharGetBooleanValueForKey(@"NSForceRightToLeftWritingDirection", v0) & 1) != 0)
    {
      uint64_t v1 = 1LL;
    }

    else
    {
      MainBundle = CFBundleGetMainBundle();
      if (MainBundle && (uint64_t v4 = CFBundleCopyBundleLocalizations(MainBundle)) != 0LL)
      {
        unint64_t v5 = v4;
        uint64_t v6 = CFBundleCopyLocalizationsForPreferences(v4, 0LL);
        uint64_t v1 = (uint64_t)v6;
        if (v6)
        {
          if (CFArrayGetCount(v6) >= 1
            && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v1, 0LL),
                CFLocaleGetLanguageCharacterDirection(ValueAtIndex) == kCFLocaleLanguageDirectionRightToLeft))
          {
            CFRelease((CFTypeRef)v1);
            uint64_t v1 = __CFUniCharGetBooleanValueForKey(@"NSForceLeftToRightWritingDirection", v2) ^ 1;
          }

          else
          {
            CFRelease((CFTypeRef)v1);
            uint64_t v1 = 0LL;
          }
        }

        CFRelease(v5);
      }

      else
      {
        uint64_t v1 = 0LL;
      }
    }

    CFUniCharGetDefaultWritingDirection_defaultDirection = v1;
    if (v2)
    {
      CFRelease(v2);
      return CFUniCharGetDefaultWritingDirection_defaultDirection;
    }
  }

  return v1;
}

uint64_t __CFUniCharGetBooleanValueForKey(CFStringRef key, CFDictionaryRef theDict)
{
  v14[1] = *MEMORY[0x1895F89C0];
  if (theDict && (Value = (const __CFString *)CFDictionaryGetValue(theDict, key)) != 0LL)
  {
    uint64_t v4 = Value;
    int v5 = 0;
  }

  else
  {
    uint64_t v6 = (const __CFString *)CFPreferencesCopyAppValue(key, @"kCFPreferencesCurrentApplication");
    if (!v6) {
      return 0LL;
    }
    uint64_t v4 = v6;
    int v5 = 1;
  }

  CFTypeID v7 = CFGetTypeID(v4);
  if (v7 == CFBooleanGetTypeID())
  {
    BOOL v8 = CFBooleanGetValue((CFBooleanRef)v4) == 0;
  }

  else
  {
    if (v7 != CFNumberGetTypeID())
    {
      if (v7 == CFStringGetTypeID() && (CFIndex Length = CFStringGetLength(v4), Length >= 1))
      {
        CFIndex v12 = Length;
        int CharacterAtIndex = CFStringGetCharacterAtIndex(v4, 0LL);
        if ((CharacterAtIndex & 0xFFFFFFDF) == 0x59
          || (uint64_t v9 = 0LL, v12 == 1) && (CharacterAtIndex - 49) <= 8)
        {
          uint64_t v9 = 1LL;
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      goto LABEL_15;
    }

    if (CFNumberGetValue((CFNumberRef)v4, kCFNumberCFIndexType, v14)) {
      BOOL v8 = v14[0] == 0LL;
    }
    else {
      BOOL v8 = 1;
    }
  }

  uint64_t v9 = !v8;
LABEL_15:
  if (v5) {
    CFRelease(v4);
  }
  return v9;
}

uint64_t __CFSearchSignatureROM(unsigned __int8 *a1, uint64_t a2)
{
  if (a2 <= 1024)
  {
    __int16 v4 = __CFStrHashEightBit2(a1, a2);
    unint64_t v5 = MethodSignatureROMTableHashData[v4 & 0x3FFF];
    uint64_t v2 = (v5 >> 3) - 1;
    uint64_t v6 = v5 & 7;
    CFTypeID v7 = (const char **)(&MethodSignatureROMTable + 3 * (MethodSignatureROMTableHashData[v4 & 0x3FFF] >> 3) + 1);
    while (v6)
    {
      BOOL v8 = *v7;
      v7 += 3;
      ++v2;
      --v6;
    }
  }

  return -1LL;
}

_UNKNOWN **__CFGetSignatureROMEntryAtIndex(unint64_t a1)
{
  if (a1 >= 0x28FB) {
    __CFGetSignatureROMEntryAtIndex_cold_1();
  }
  return &MethodSignatureROMTable + 3 * a1;
}

void __CFRelativeDateTimeFormatterDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFRelativeDateTimeFormatterDeallocate_cold_1();
  }
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

CFStringRef __CFRelativeDateTimeFormatterCopyDescription(const void *a1)
{
  if (!a1) {
    __CFRelativeDateTimeFormatterCopyDescription_cold_1();
  }
  uint64_t v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFRelativeDateTimeFormatter %p>[%p]", a1, v3);
}

uint64_t _CFRelativeDateTimeFormatterGetTypeID()
{
  return 67LL;
}

void *_CFRelativeDateTimeFormatterCreate( const __CFAllocator *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    a1 = (const __CFAllocator *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  uint64_t Instance = (void *)_CFRuntimeCreateInstance(a1, 0x43uLL, 32LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    Instance[4] = CFRetain(a2);
    Instance[5] = a5;
    Instance[2] = a4;
    Instance[3] = a3;
  }

  return Instance;
}

CFStringRef _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit( const __CFAllocator *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 32));
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 157LL, 0x600u)) {
      return 0LL;
    }
  }

  uint64_t v10 = 0LL;
  unsigned int v11 = 0;
  switch(*(void *)(a2 + 24))
  {
    case 0LL:
      goto LABEL_10;
    case 1LL:
      int v24 = 0;
      CFIndex v12 = (const void *)__cficu_unum_open(5u, 0LL, 0LL, (uint64_t)CStringPtr, 0LL, &v24);
      uint64_t v10 = (uint64_t)v12;
      if (v24 >= 1)
      {
        if (v12) {
          __cficu_unum_close(v12);
        }
        return 0LL;
      }

      unsigned int v11 = 0;
LABEL_10:
      int v24 = 0;
      unint64_t v13 = *(void *)(a2 + 40);
      if (v13 >= 6) {
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4();
      }
      int v14 = (const void *)__cficu_ureldatefmt_open((uint64_t)CStringPtr, v10, v11, dword_180C32894[v13], &v24);
      int64_t v15 = v14;
      if (v24 >= 1)
      {
        if (v14) {
          __cficu_ureldatefmt_close(v14);
        }
        return 0LL;
      }

      if (a3 <= 31)
      {
        switch(a3)
        {
          case 4LL:
            uint64_t v17 = 0LL;
            goto LABEL_31;
          case 8LL:
            uint64_t v17 = 2LL;
            goto LABEL_31;
          case 16LL:
            uint64_t v17 = 4LL;
            goto LABEL_31;
        }

LABEL_45:
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2();
      }

      if (a3 > 127)
      {
        if (a3 == 128)
        {
          uint64_t v17 = 7LL;
          goto LABEL_31;
        }

        if (a3 == 4096)
        {
          uint64_t v17 = 3LL;
          goto LABEL_31;
        }

        goto LABEL_45;
      }

      if (a3 == 32)
      {
        uint64_t v17 = 5LL;
        goto LABEL_31;
      }

      if (a3 != 64) {
        goto LABEL_45;
      }
      uint64_t v17 = 6LL;
LABEL_31:
      MEMORY[0x1895F8858](v14, v17);
      int v24 = 0;
      uint64_t v19 = *(void *)(a2 + 16);
      if (v19 == 1)
      {
        int v20 = __cficu_ureldatefmt_format((uint64_t)v15, v18, v23, 128LL, &v24, a4);
      }

      else
      {
        if (v19) {
          _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3();
        }
        int v20 = __cficu_ureldatefmt_formatNumeric((uint64_t)v15, v18, v23, 128LL, &v24, a4);
      }

      int v21 = v20;
      __cficu_ureldatefmt_close(v15);
      if (v24 > 0) {
        return 0LL;
      }
      if (!a1)
      {
        uint64_t v22 = _CFGetTSD(1u);
        if (v22) {
          a1 = (const __CFAllocator *)v22;
        }
        else {
          a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        }
      }

      return CFStringCreateWithCharacters(a1, v23, v21);
    case 2LL:
      uint64_t v10 = 0LL;
      unsigned int v11 = 1;
      goto LABEL_10;
    case 3LL:
      uint64_t v10 = 0LL;
      unsigned int v11 = 2;
      goto LABEL_10;
    default:
      _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1();
  }

    -[__NSArrayM setObject:atIndex:].cold.1();
  }

  uint64_t v26 = p_storage->list;
  size = p_storage->size;
  int64_t v28 = p_storage->var0 + a4;
  if (size > v28) {
    size = 0;
  }
  uint64_t v29 = v28 - size;
  int64_t v30 = (uint64_t)v26[v29];
  if ((id)v30 != a3)
  {
    if (((unint64_t)a3 & 0x8000000000000000LL) == 0)
    {
      UniChar v31 = a3;
      int64_t v30 = (uint64_t)v26[v29];
    }

    v26[v29] = (offset *)a3;
    if (v30 >= 1) {
  }
    }

    -[__NSArrayM setObject:atIndexedSubscript:].cold.1();
  }

  uint64_t v26 = p_storage->list;
  size = p_storage->size;
  int64_t v28 = p_storage->var0 + a4;
  if (size > v28) {
    size = 0;
  }
  uint64_t v29 = v28 - size;
  int64_t v30 = (uint64_t)v26[v29];
  if ((id)v30 != a3)
  {
    if (((unint64_t)a3 & 0x8000000000000000LL) == 0)
    {
      UniChar v31 = a3;
      int64_t v30 = (uint64_t)v26[v29];
    }

    v26[v29] = (offset *)a3;
    if (v30 >= 1) {
  }
    }

  int64_t v27 = atomic_load(v3);
  if ((v27 & 8) == 0) {
    CFRelease(ms);
  }
}

    uint64_t v9 = 63;
    goto LABEL_3;
  }

  CFUniCharDecomposeCharacter(*a1, v23, 10LL);
  uint64_t v9 = v23[0];
  if (v23[0] <= 0x7F) {
    goto LABEL_3;
  }
  uint64_t v22 = v23[0];
  return __CFDefaultToBytesFallbackProc(&v22, 1LL, a3, a4, a5);
}

  CFRelease(v11);
LABEL_46:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v24;
}

BOOL isEqualToString(uint64_t a1, void *a2)
{
  v21[2] = *MEMORY[0x1895F89C0];
  __int16 v4 = (uint64_t *)MEMORY[0x189616658];
  int v5 = *MEMORY[0x189616658];
  unint64_t v6 = a1 & 0xC000000000000007LL;
  if ((a1 & 0xC000000000000007LL) == 0xC000000000000007LL) {
    int v5 = 7;
  }
  unint64_t v7 = ((unint64_t)(v5 ^ a1) >> 3) & 0xF;
  if (v7 != [a2 length]) {
    return 0LL;
  }
  uint64_t v8 = *v4;
  if (v6 == 0xC000000000000007LL) {
    uint64_t v8 = 0LL;
  }
  unint64_t v9 = v8 ^ a1;
  BOOL v10 = (~(v8 ^ a1) & 7) == 0LL;
  uint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
  if (v10) {
    uint64_t v11 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t v12 = (v9 >> 3) & 0xF;
  unint64_t v13 = (v11 & (v9 >> 3)) >> 4;
  if (v12 < 8)
  {
    v21[0] = v13;
  }

  else
  {
    uint64_t v14 = (v9 >> 3) & 0xF;
    if (v12 >= 0xA)
    {
      do
      {
        *((_BYTE *)&v20[15] + v14 + 1) = sixBitToCharLookup[v13 & 0x1F];
        v13 >>= 5;
        --v14;
      }

      while (v14);
    }

    else
    {
      do
      {
        *((_BYTE *)&v20[15] + v14 + 1) = sixBitToCharLookup[v13 & 0x3F];
        v13 >>= 6;
        --v14;
      }

      while (v14);
    }
  }

  objc_msgSend(a2, "getCharacters:range:", v20, 0, v7);
  if (!v12) {
    return 1LL;
  }
  if (v20[0] != LOBYTE(v21[0])) {
    return 0LL;
  }
  uint64_t v15 = 1LL;
  do
  {
    unint64_t v16 = v15;
    if (v12 == v15) {
      break;
    }
    int v17 = *((unsigned __int8 *)v21 + v15);
    int v18 = (unsigned __int16)v20[v15++];
  }

  while (v18 == v17);
  return v16 >= v12;
}

unint64_t _NSTaggedPointerStringGetBytes(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  unint64_t v3 = v2 ^ a1;
  BOOL v4 = (~(v2 ^ a1) & 7) == 0LL;
  uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  if (v4) {
    uint64_t v5 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t result = (v3 >> 3) & 0xF;
  unint64_t v7 = (v5 & (v3 >> 3)) >> 4;
  if (result < 8)
  {
    *a2 = v7;
  }

  else
  {
    uint64_t v8 = (char *)a2 - 1;
    unint64_t v9 = result;
    if (result >= 0xA)
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x1F];
        v7 >>= 5;
        --v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x3F];
        v7 >>= 6;
        --v9;
      }

      while (v9);
    }
  }

  return result;
}

unint64_t _NSTaggedPointerStringGetLength(uint64_t a1)
{
  int v1 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    int v1 = 7;
  }
  return ((unint64_t)(v1 ^ a1) >> 3) & 0xF;
}

void *_CFCreateArrayStorage(unint64_t a1, int a2, size_t *a3)
{
  if (a1 >> 61) {
    goto LABEL_7;
  }
  size_t v5 = malloc_good_size(8 * a1);
  if (HIDWORD(v5)) {
    _CFCreateArrayStorage_cold_2();
  }
  size_t v6 = v5;
  unint64_t result = a2 ? calloc(1uLL, v5) : malloc(v5);
  *a3 = v6 >> 3;
  if (!result) {
LABEL_7:
  }
    _CFCreateArrayStorage_cold_1();
  return result;
}

uint64_t __NSArrayM_copy(uint64_t a1)
{
  if (__cf_tsanReadFunction) {
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableArray);
  }
  unint64_t v3 = atomic_load((unint64_t *)(a1 + 8));
  unsigned int v4 = *(_DWORD *)(a1 + 36);
  if (!v3)
  {
    if (v4 > 5) {
      goto LABEL_5;
    }
    return objc_msgSend( __NSArrayImmutablePlaceholder(),  "initWithArray:range:copyItems:",  a1,  0,  *(unsigned int *)(a1 + 36),  0);
  }

  if (v4 < 4) {
    return objc_msgSend( __NSArrayImmutablePlaceholder(),  "initWithArray:range:copyItems:",  a1,  0,  *(unsigned int *)(a1 + 36),  0);
  }
LABEL_5:
  size_t v5 = (unint64_t *)(a1 + 8);
  if (!atomic_load((unint64_t *)(a1 + 8)))
  {
    unint64_t v7 = _cow_create(a1, 1);
    while (!__ldaxr(v5))
    {
    }

    __clrex();
    free(v7);
  }

LABEL_13:
  BOOL v10 = (objc_class *)objc_opt_self();
  uint64_t v11 = __CFAllocateObject(v10, 0LL);
  unint64_t v12 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 8));
  _cow_copy(a1, 1LL, v12, (uint64_t)__NSArray_cowCallbacks, v11, 0LL);
  return v11;
}

          CFIndex v39 = v17;
          goto LABEL_14;
        }

        char v33 = CFUniCharDecomposeCharacter(v26, v41, 10LL);
        int64_t v30 = v33;
        if (!a5)
        {
          if (v33 < 1) {
            goto LABEL_48;
          }
          int v17 = v39;
          unint64_t v13 = v27;
          do
          {
            if (v41[v30 - 1] < 0x10000) {
              int v36 = 1LL;
            }
            else {
              int v36 = 2LL;
            }
            v17 += v36;
          }

          while (v30-- > 1);
          goto LABEL_13;
        }
      }

      else
      {
        if ((a1 & 0x80) == 0 && (v26 & 0xFFFFF800) == 0xD800)
        {
LABEL_72:
          v8 -= (v18 + 1);
          goto LABEL_73;
        }

        if (!v12
          || v26 < 0x80
          || (v27 = v13, IsMemberOf = CFUniCharIsMemberOf(v21 - v13[v18], 0x65u), unint64_t v13 = v27, !IsMemberOf))
        {
          if (a5)
          {
            uint64_t v32 = v40;
            *int64_t v40 = v26;
            int64_t v40 = v32 + 1;
          }

          ++v39;
          goto LABEL_14;
        }

        uint64_t v29 = CFUniCharDecomposeCharacter(v26, v41, 10LL);
        int64_t v30 = v29;
        if (!a5)
        {
          v39 += v29;
LABEL_48:
          unint64_t v13 = v27;
          goto LABEL_14;
        }
      }

      uint64_t v34 = CFUniCharFillDestinationBuffer(v41, v30, (uint64_t *)&v40, a5, &v39, 0);
      unint64_t v13 = v27;
      if ((v34 & 1) == 0) {
        goto LABEL_73;
      }
LABEL_14:
      if (!v10) {
        goto LABEL_73;
      }
    }

  unint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v7;
}

      ++v14;
      ++v12;
      if (!--v13) {
        goto LABEL_17;
      }
    }

    uint64_t v11 = __CStringFromString(*v14);
LABEL_12:
    *unint64_t v12 = 0LL;
    goto LABEL_13;
  }

  int v36 = 0LL;
  CFIndex v37 = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v11 = 0LL;
LABEL_17:
  CFIndex v39 = 0LL;
  unint64_t v16 = "";
  int v17 = "_";
  if (v11) {
    int v18 = (const char *)v11;
  }
  else {
    int v18 = "";
  }
  uint64_t v19 = v36;
  int v20 = v37;
  if (v37) {
    int v21 = "_";
  }
  else {
    int v21 = "";
  }
  if (v37) {
    uint64_t v22 = (const char *)v37;
  }
  else {
    uint64_t v22 = "";
  }
  BOOL v23 = v34;
  else {
    int v24 = "";
  }
  if (v36) {
    uint64_t v25 = (const char *)v36;
  }
  else {
    uint64_t v25 = "";
  }
  if (v34) {
    unint64_t v16 = (const char *)v34;
  }
  else {
    int v17 = "";
  }
  asprintf(&v39, "%s%s%s%s%s%s%s", v18, v21, v22, v24, v25, v17, v16);
  __strlcpy_chk();
  free(v11);
  free(v20);
  free(v19);
  free(v23);
  free(v39);
  if (Count >= 1)
  {
    do
    {
      if (*v10)
      {
        uint64_t v26 = __CStringFromString(*v10);
        int64_t v27 = strcmp((const char *)v26, "kCFLocaleCalendarKey");
        int64_t v28 = (__CFString *)*v7;
        if (v27)
        {
          uint64_t v29 = __CStringFromString(v28);
        }

        else
        {
          Identifier = CFCalendarGetIdentifier((CFCalendarRef)v28);
          uint64_t v29 = __CStringFromString(Identifier);
          UniChar v31 = strdup("calendar");
          free(v26);
          uint64_t v26 = (UInt8 *)v31;
        }

        uint64_t v38 = 0;
        uloc_setKeywordValue();
        free(v26);
        free(v29);
      }

      ++v7;
      ++v10;
      --Count;
    }

    while (Count);
  }

  return CFStringCreateWithCString(v33, v40, 0x600u);
}

    if ((v19 & 1) == 0) {
      break;
    }
  }

  while (v18 != v20++);
  uint64_t v25 = v19 & 1;
  if (v38)
  {
    if ((v19 & 1) != 0)
    {
      uint64_t v25 = __CFBinaryPlistCreateObjectFiltered( BytePtr,  v14,  *(unint64_t *)v40,  (uint64_t)v44,  a1,  a3,  0LL,  (const __CFDictionary *)Mutable,  0LL,  0LL,  0LL,  &v39,  0LL);
      if (v25) {
        *uint64_t v38 = v39;
      }
    }
  }

    unint64_t v13 = 0;
    goto LABEL_16;
  }

  unint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v9) {
    goto LABEL_13;
  }
  BOOL v10 = (CFArrayRef *)v9;
  uint64_t v11 = (pthread_mutex_t *)(v9 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
  unint64_t v12 = v10[14];
  if (v12)
  {
    v17.CFIndex length = CFArrayGetCount(v10[14]);
    v17.int location = 0LL;
    unint64_t v13 = CFArrayContainsValue(v12, v17, observer);
  }

  else
  {
    unint64_t v13 = 0;
  }

  pthread_mutex_unlock(v11);
  CFRelease(v10);
LABEL_16:
  pthread_mutex_unlock(v8);
  return v13;
}

  unint64_t v3 = CFLogTest_file;
LABEL_14:
  if (v3 != -1)
  {
    va_copy(v19, va);
    int v17 = (__CFString *)CFStringCreateWithFormatAndArguments( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  format,  va);
    gettimeofday(&v18, 0LL);
    gmtime_r(&v18.tv_sec, buffer);
    fprintf_l( (FILE *)CFLogTest_file,  0LL,  "%04d-%02d-%02d %02d:%02d:%02d ",  buffer[0].tm_year + 1900,  buffer[0].tm_mon + 1,  buffer[0].tm_mday,  buffer[0].tm_hour,  buffer[0].tm_min,  buffer[0].tm_sec);
    _CFShowToFile((FILE *)CFLogTest_file, v17);
    CFRelease(v17);
  }

    __invoking___( v8,  (uint64_t)self->_retdata,  (__n128 *)self->_frame,  -[NSMethodSignature frameLength](self->_signature, "frameLength"));
    if (_CFExecutableLinkedOnOrAfter(5uLL))
    {
      if (self->_retainedArgs)
      {
        unint64_t v9 = (const UInt8 *)v4->var0;
        BOOL v10 = 1LL;
        if ((*((_WORD *)v4->var0 + 17) & 0x80) == 0) {
          BOOL v10 = 2LL;
        }
        frame = (&self->super.isa)[v10];
LABEL_18:
        __NSI3(v9, (uint64_t)frame, (id *)&self->_container, 1);
        while (1)
        {
          unsigned int v4 = (NSMethodFrameDescriptor *)v4->var1;
          if (!v4) {
            break;
          }
          if ((WORD1(v4[1].var1) & 3) != 1)
          {
            frame = (Class)self->_frame;
            unint64_t v9 = (const UInt8 *)v4;
            goto LABEL_18;
          }
        }
      }
    }

    else
    {
      unint64_t v12 = 1LL;
      if ((*((_WORD *)v4->var0 + 17) & 0x80) == 0) {
        unint64_t v12 = 2LL;
      }
      __NSI3((const UInt8 *)v4->var0, (uint64_t)(&self->super.isa)[v12], (id *)&self->_container, 1);
    }
  }

  if (v8)
  {
    int v18 = v8;
    uint64_t v14 = _os_log_pack_size();
    uint64_t v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = _os_log_pack_fill();
    int v20 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v19,  (uint64_t)"-[__NSArrayReversed getObjects:range:]",  location,  length,  --v18);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v20,  "-[__NSArrayReversed getObjects:range:]",  location,  length,  v18);
  }

  else
  {
    uint64_t v14 = _os_log_pack_size();
    uint64_t v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v16 = _os_log_pack_fill();
    int v17 = __os_log_helper_1_2_3_8_32_8_0_8_0(v16, (uint64_t)"-[__NSArrayReversed getObjects:range:]", location, length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v17,  "-[__NSArrayReversed getObjects:range:]",  location,  length,  v25);
  }

  int v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v15,  v14);
  objc_exception_throw(v21);
  -[__NSArrayReversed initWithArray:](v22, v23, v24);
}

  unint64_t v13 = (objc_class *)objc_opt_self();
  unint64_t v12 = __CFAllocateObject(v13, 0LL);
  uint64_t v14 = (os_unfair_lock_s *)atomic_load((unint64_t *)(v3 + 8));
  _cow_copy(v3, 1LL, v14, (uint64_t)__NSSet_cowCallbacks, v12, 0LL);
  return v12;
}

      ++a1;
      if (!--v4) {
        return v6;
      }
    }

    int v18 = atomic_load((unint64_t *)(v7 + 32));
    v6 += v18;
LABEL_12:
    *a3 = 1;
    goto LABEL_13;
  }

  return 0LL;
}

    if (v9 != v7) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9);
    }
    Value = CFSetGetValue(*(CFSetRef *)(a1 + 48), v13);
    if (!Value)
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v13);
      Value = v13;
    }

    CFRelease(v13);
    CFRetain(Value);
    return Value;
  }

      size_t v6 = 1;
      if (v10) {
        goto LABEL_19;
      }
      if (v13) {
        goto LABEL_15;
      }
LABEL_16:
      unint64_t v7 = v11 + 1;
      if (v7 >= v5)
      {
        if ((v6 & 1) != 0)
        {
          int v18 = (os_log_s *)_CFPrefsDaemonLog();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
            _CFPrefsApplyChangesQueueToDictionary_cold_2();
          }
        }

        return;
      }
    }
  }

  Value = 0LL;
LABEL_14:
  unint64_t v13 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = (void *)objc_msgSend((id)a1, "copyOSLogDescription", *(void *)v18, *(void *)&v18[8]);
    if (Value)
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
      uint64_t v15 = (os_log_s *)_CFPrefsClientLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int v18 = 138478339;
        *(void *)&v18[4] = Value;
        *(_WORD *)&v18[12] = 2114;
        *(void *)&v18[14] = key;
        *(_WORD *)&v18[22] = 2114;
        uint64_t v19 = v14;
        _os_log_debug_impl( &dword_180A4C000,  v15,  OS_LOG_TYPE_DEBUG,  "looked up value %{private}@ for key %{public}@ in %{public}@",  v18,  0x20u);
      }
    }

    else
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
      unint64_t v16 = (os_log_s *)_CFPrefsClientLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        _copyValueForKey_cold_1();
      }
    }

    _CFSetTSD(0xFu, 0LL, 0LL);
    CFRelease(v14);
  }

  if (Value) {
    return CFRetain(Value);
  }
  else {
    return 0LL;
  }
}

LABEL_78:
    -[__NSArrayM insertObject:atIndex:].cold.1();
  }

  if (v18 == 168)
  {
    CFIndex v39 = __CFFromMacSimplifiedChineseMapA8[v23 - 187];
    if (v14)
    {
      uint64_t v51 = v16;
      int64_t v49 = v14;
      int64_t v40 = v15;
      if ((__CFStringEncodingIsDecomposableCharacter( (unsigned __int16)__CFFromMacSimplifiedChineseMapA8[v23 - 187],  (a1 >> 7) & 1) & 1) != 0)
      {
        __CFStringEncodingDecomposeCharacter(a1, (unsigned __int16)v39, v53, v41);
        unint64_t v12 = *a6 + 2;
        if (!a5)
        {
          uint64_t v19 = 2LL;
          uint64_t v15 = v40;
          uint64_t v14 = v49;
          unint64_t v16 = v51;
          goto LABEL_18;
        }

        unint64_t v16 = v51;
        if (v12 <= a5)
        {
          uint64_t v15 = v40;
          *a4 = v53[0];
          a4[1] = v53[1];
          a4 += 2;
          uint64_t v19 = 2LL;
          uint64_t v14 = v49;
          goto LABEL_18;
        }

        return v13;
      }

      unint64_t v12 = *a6;
      uint64_t v15 = v40;
      uint64_t v14 = v49;
      unint64_t v16 = v51;
    }

    if (a5)
    {
      if (v12 >= a5) {
        return v13;
      }
      *a4++ = v39;
    }

      v329 = 1LL;
      if (v61)
      {
LABEL_71:
        int v68 = v346[v52++];
        goto LABEL_92;
      }

    LOWORD(v31) = 73;
  }

        BOOL v23 = v24;
        goto LABEL_79;
      }

      BOOL v23 = v24;
      if (ValueAtIndex != v24)
      {
        char v33 = CFEqual(v24, ValueAtIndex);
        BOOL v23 = v24;
        if (!v33)
        {
          uint64_t v29 = @"kCFURLFileLastModificationTime";
          if (ValueAtIndex == @"kCFURLFileLastModificationTime"
            || (uint64_t v34 = CFEqual(@"kCFURLFileLastModificationTime", ValueAtIndex),
                uint64_t v29 = @"kCFURLFileLastModificationTime",
                v34))
          {
            if (v44)
            {
              UniChar v31 = (__objc2_class **)length;
              if (length)
              {
LABEL_68:
                uint64_t v32 = theDict;
LABEL_69:
                CFDictionarySetValue(v32, v29, v31);
                goto LABEL_62;
              }
            }
          }

          else
          {
            uint64_t v29 = @"kCFURLFileExists";
            if (ValueAtIndex == @"kCFURLFileExists"
              || (v36 = CFEqual(@"kCFURLFileExists", ValueAtIndex), uint64_t v29 = @"kCFURLFileExists", v36))
            {
              uint64_t v32 = theDict;
              if (v44) {
                UniChar v31 = &__kCFBooleanTrue;
              }
              else {
                UniChar v31 = &__kCFBooleanFalse;
              }
              goto LABEL_69;
            }

            if (ValueAtIndex != @"kCFURLFileOwnerID" && !CFEqual(@"kCFURLFileOwnerID", ValueAtIndex))
            {
              BOOL v23 = v24;
              if (!errorCode) {
                goto LABEL_82;
              }
              unsigned int v35 = -16;
              goto LABEL_81;
            }

            if (v44)
            {
              uint64_t v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &v40);
              int64_t v27 = theDict;
              int64_t v28 = @"kCFURLFileOwnerID";
LABEL_61:
              CFDictionarySetValue(v27, v28, v26);
              CFRelease(v26);
LABEL_62:
              BOOL v23 = v24;
              goto LABEL_82;
            }
          }

          goto LABEL_78;
        }
      }

      if (v44)
      {
        uint64_t v26 = CFNumberCreate(allocator, kCFNumberSInt64Type, bytes);
        int64_t v27 = theDict;
        int64_t v28 = v24;
        goto LABEL_61;
      }

LABEL_24:
  BOOL v23 = (used - a4);
  int v67 = size;
  int v68 = a4;
  if (v23 <= a4)
  {
    if ((_DWORD)used != (_DWORD)a4)
    {
      uint64_t v38 = (uint64_t)(p_storage->list + 1);
      CFIndex v39 = v68 + (unint64_t)v23 + p_storage->var0;
      int64_t v40 = v39 - 1;
      else {
        int64_t v41 = v67;
      }
      do
      {
        CFIndex v42 = ((v39 & ~((uint64_t)v39 >> 63)) - (v39 + (v39 >> 63))) / v41;
        uint64_t v43 = v40
            + v67
            + v67
            * (((v40 & ~(v40 >> 63)) - (v40 + ((unint64_t)v40 >> 63))) / v41 + ((unint64_t)v40 >> 63));
        do
          v43 -= v67;
        while (v43 >= v67);
        int64_t v44 = v39 + (v42 + (v39 >> 63)) * v67;
        uint64_t v45 = v67 + v67 * ((v39 >> 63) + v42);
        int64_t v46 = v39 + v45;
        UniChar v47 = v38 + 8LL * v67 + 8 * v44;
        do
        {
          v46 -= v67;
          v45 -= v67;
          v47 -= 8LL * v67;
        }

        while ((uint64_t)(v39 + v45) >= v67);
        else {
          unsigned int v48 = v43;
        }
        if (v23 >= v48 + 1) {
          int64_t v49 = v48 + 1;
        }
        else {
          int64_t v49 = v23;
        }
        if (v43 < v46) {
          int64_t v46 = v43;
        }
        if (v23 >= v46 + 1) {
          uint64_t v50 = v46 + 1;
        }
        else {
          uint64_t v50 = v23;
        }
        memmove((void *)(v47 - 8 * v50), (const void *)(v38 - 8 * v49 + 8 * v43), 8 * v49);
        v40 -= v49;
        v39 -= v49;
        uint64_t v34 = v23 <= v49;
        v23 -= v49;
      }

      while (!v34);
    }
  }

  else
  {
    if ((_DWORD)a4)
    {
      int v24 = a4;
      uint64_t v25 = p_storage->list;
      uint64_t v26 = p_storage->var0;
      int64_t v27 = v26 - 1;
      else {
        int64_t v28 = size;
      }
      do
      {
        uint64_t v29 = v26
            + size
            + size
            * (((v26 & ~(v26 >> 63)) - (v26 + ((unint64_t)v26 >> 63))) / v28 + ((unint64_t)v26 >> 63));
        do
          v29 -= size;
        while (v29 >= size);
        int64_t v30 = v27
            + size
            + size
            * (((unint64_t)v27 >> 63) + ((v27 & ~(v27 >> 63)) - (v27 + ((unint64_t)v27 >> 63))) / v28);
        do
          v30 -= size;
        while (v30 >= size);
        if (v30 <= v29) {
          UniChar v31 = v29;
        }
        else {
          UniChar v31 = v30;
        }
        uint64_t v32 = size - v31;
        if (v24 >= v32) {
          char v33 = v32;
        }
        else {
          char v33 = v24;
        }
        memmove(&v25[v30], &v25[v29], 8 * v33);
        v26 += v33;
        v27 += v33;
        uint64_t v34 = v24 <= v33;
        v24 -= v33;
      }

      while (!v34);
    }

    unsigned int v35 = size + p_storage->var0 - 1;
    p_storage->var0 = v35;
    int v36 = v35 >= size;
    CFIndex v37 = v35 - size;
    if (v36) {
      p_storage->var0 = v37;
    }
  }

  ++p_storage->state.var0.used;
  uint64_t v51 = p_storage->var0 + v68;
  int64_t v52 = (unint64_t)v66;
  else {
    int64_t v53 = 0;
  }
  p_storage->list[v51 - v53] = v66;
  if ((v52 & 0x8000000000000000LL) == 0) {
    int v54 = (id)v52;
  }
}

  if (v14)
  {
    size_t v5 = 0LL;
    uint64_t v22 = 2 * v14;
    BOOL v23 = v22 * *(unsigned __int8 *)(a5 + 7);
  }

  else
  {
    BOOL v23 = 0LL;
    uint64_t v22 = 0LL;
  }

  size_t v5 = 0LL;
  if (!__CFADD__(v23, v13) && &a2[v7] >= (char *)v13 + v23 - 1)
  {
    if (v22 >= 0x402) {
      int v24 = 512LL;
    }
    else {
      int v24 = v22 >> 1;
    }
    uint64_t v25 = malloc(8 * v24);
    if (v25)
    {
      uint64_t v26 = v25;
      if (v22)
      {
        int64_t v27 = 0LL;
        if (v22 >> 1 <= 1) {
          uint64_t v22 = 1LL;
        }
        else {
          v22 >>= 1;
        }
        while (1)
        {
          if (v27 >= v24)
          {
            int v24 = (3 * v24) >> 1;
            int64_t v28 = realloc(v26, 8 * v24);
            if (!v28) {
              break;
            }
            uint64_t v26 = v28;
          }

          uint64_t v29 = &a2[*(void *)(a5 + 24)];
          int64_t v30 = *(unsigned __int8 *)(a5 + 7);
          UniChar v31 = *(unsigned __int8 *)(a5 + 7);
          switch(*(_BYTE *)(a5 + 7))
          {
            case 0:
              break;
            case 1:
              UniChar v31 = *(unsigned __int8 *)v13;
              break;
            case 2:
              UniChar v31 = __rev16(*(unsigned __int16 *)v13);
              break;
            case 4:
              UniChar v31 = bswap32(*v13);
              break;
            case 8:
              UniChar v31 = bswap64(*(void *)v13);
              break;
            default:
              UniChar v31 = 0LL;
              uint64_t v32 = v13;
              do
              {
                char v33 = *(unsigned __int8 *)v32;
                uint64_t v32 = (unsigned int *)((char *)v32 + 1);
                UniChar v31 = v33 | (v31 << 8);
                --v30;
              }

              while (v30);
              break;
          }

          if (*(void *)(a5 + 8) <= v31) {
            break;
          }
          uint64_t v34 = *(unsigned __int8 *)(a5 + 6);
          unsigned int v35 = (unsigned int *)&v29[v31 * v34];
          switch(*(_BYTE *)(a5 + 6))
          {
            case 0:
              break;
            case 1:
              uint64_t v34 = *(unsigned __int8 *)v35;
              break;
            case 2:
              uint64_t v34 = __rev16(*(unsigned __int16 *)v35);
              break;
            case 4:
              uint64_t v34 = bswap32(*v35);
              break;
            case 8:
              uint64_t v34 = bswap64(*(void *)v35);
              break;
            default:
              int v36 = *(unsigned __int8 *)(a5 + 6);
              uint64_t v34 = 0LL;
              do
              {
                CFIndex v37 = *(unsigned __int8 *)v35;
                unsigned int v35 = (unsigned int *)((char *)v35 + 1);
                uint64_t v34 = v37 | (v34 << 8);
                --v36;
              }

              while (v36);
              break;
          }

          int64_t v41 = 0LL;
          v42[0] = 0LL;
          if (__CFBinaryPlistCreateObjectFiltered( a2,  a3,  v34,  a5,  a1,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  v42,  &v41)) {
            uint64_t v38 = v41 == 7;
          }
          else {
            uint64_t v38 = 0;
          }
          if (!v38)
          {
            if (v42[0]) {
              CFRelease(v42[0]);
            }
            break;
          }

          *((CFTypeRef *)v26 + v27++) = v42[0];
          unint64_t v13 = (unsigned int *)((char *)v13 + *(unsigned __int8 *)(a5 + 7));
          if (v27 == v22) {
            goto LABEL_66;
          }
        }

        size_t v5 = 0LL;
      }

      else
      {
LABEL_66:
        size_t v5 = CFSetCreate((CFAllocatorRef)a1, (const void **)v26, v22, &kCFTypeSetCallBacks);
        int64_t v27 = v22;
      }

      if (v27)
      {
        CFIndex v39 = (CFTypeRef *)v26;
        do
        {
          if (*v39) {
            CFRelease(*v39);
          }
          ++v39;
          --v27;
        }

        while (v27);
      }

      free(v26);
      return v5;
    }

    return 0LL;
  }

  return v5;
}

    __break(1u);
    return result;
  }

  switch(v3)
  {
    case 'c':
      return result;
    case 'd':
      return 13LL;
    case 'e':
    case 'g':
    case 'h':
    case 'j':
    case 'k':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'r':
      goto LABEL_24;
    case 'f':
      return 12LL;
    case 'i':
      goto LABEL_15;
    case 'l':
      return 10LL;
    case 'q':
      return 11LL;
    case 's':
      return 8LL;
    default:
      if (v3 == 81)
      {
        unint64_t result = 17LL;
      }

      else
      {
        if (v3 != 83) {
          goto LABEL_24;
        }
LABEL_15:
        unint64_t result = 9LL;
      }

      break;
  }

  return result;
}

    __break(1u);
    return result;
  }

  switch(v3)
  {
    case 'c':
      return result;
    case 'd':
      return 13LL;
    case 'e':
    case 'g':
    case 'h':
    case 'j':
    case 'k':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'r':
      goto LABEL_24;
    case 'f':
      return 12LL;
    case 'i':
      goto LABEL_15;
    case 'l':
      return 10LL;
    case 'q':
      return 11LL;
    case 's':
      return 8LL;
    default:
      if (v3 == 81)
      {
        unint64_t result = 17LL;
      }

      else
      {
        if (v3 != 83) {
          goto LABEL_24;
        }
LABEL_15:
        unint64_t result = 9LL;
      }

      break;
  }

  return result;
}

    MEMORY[0x1895F8858](Length, v8);
    uint64_t v14 = &v15;
    __strlcpy_chk();
    __strlcat_chk();
LABEL_25:
    __strlcat_chk();
    qword_18C539A70 = (uint64_t)v14;
    __break(1u);
  }

  if (!CFStringHasSuffix(v6, @"is") && !CFStringHasSuffix(v6, @"ys"))
  {
    if (!CFStringHasSuffix(v6, @""))
    {
      CFRelease(v6);
      return CFRetain(theString);
    }

    CFStringReplaceAll(v6, theString);
    CFIndex Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.int location = Length - 1;
      BOOL v10 = @"e";
      goto LABEL_8;
    }

    goto LABEL_24;
  }

  CFStringReplaceAll(v6, theString);
  v17.int location = CFStringGetLength(v6) - 1;
  v17.CFIndex length = 1LL;
  CFStringDelete(v6, v17);
LABEL_10:
  unint64_t v12 = CFRetain(v6);
  CFRelease(v6);
  if (v12) {
    return v12;
  }
  return CFRetain(theString);
}

  if (Copy) {
    CFRelease(Copy);
  }
  return Mutable;
}

  *a6 = result;
  return result;
}

    __break(1u);
    return result;
  }

  if (v6 == 3)
  {
    ___CFBasicHashFindBucket_Exponential(result, v5, (uint64_t *)&v10);
    goto LABEL_16;
  }

  if (v6 == 2)
  {
    ___CFBasicHashFindBucket_Double(result, v5, (uint64_t *)&v10);
    goto LABEL_16;
  }

  if (v6 != 1) {
    goto LABEL_24;
  }
  ___CFBasicHashFindBucket_Linear(result, v5, (uint64_t *)&v10);
LABEL_16:
  if (a2[3] == *((void *)&v11 + 1))
  {
    unint64_t v7 = a1[6];
    if ((*(_WORD *)(v7 + 18) & 4) == 0) {
      return 1LL;
    }
    uint64_t v8 = a2[2];
    if (v8 == (void)v11) {
      return 1LL;
    }
    unint64_t v9 = *(unsigned int (**)(uint64_t, void))(CFBasicHashCallBackPtrs[((*(void *)(v7 + 32) >> 34) >> 5) & 0x1F]
                                                        + 8 * ((*(void *)(v7 + 32) >> 34) & 0x1FLL));
    if (v9)
    {
      if (v9(v8, v11)) {
        return 1LL;
      }
    }
  }

  unint64_t result = 0LL;
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
  return result;
}

        __break(1u);
      }

      unint64_t result = ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v8);
    }
  }

  else
  {
    uint64_t v8 = xmmword_180D7EA48;
    unint64_t v9 = unk_180D7EA58;
  }

        __break(1u);
      }

      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v8);
    }
  }

  else
  {
    uint64_t v8 = xmmword_180D7EA48;
    unint64_t v9 = unk_180D7EA58;
  }

    if (v6 <= v13 + v9) {
      int v20 = v6;
    }
    else {
      int v20 = 0LL;
    }
    unint64_t v13 = v13 + v9 - v20;
    if (!--v16) {
      goto LABEL_30;
    }
  }

  int v18 = a2;
LABEL_37:
  BOOL v23 = *(void *)(*v11 + 8 * v13);
  int v24 = -1LL;
  if (v23 != 2780474809LL) {
    int v24 = *(void *)(*v11 + 8 * v13);
  }
  if (v23 == 2814029233LL) {
    uint64_t v25 = 0LL;
  }
  else {
    uint64_t v25 = v24;
  }
  int v21 = v27;
  v27[1] = v18;
  v27[2] = v25;
  *int64_t v27 = v13;
  uint64_t v26 = *(unsigned __int16 *)(a1 + 18);
  if ((v26 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  int v17 = 1LL;
LABEL_31:
  void v21[3] = v17;
  return result;
}

    int v18 = v12 + v17 * v9;
    if (v6 <= v18) {
      v18 %= v6;
    }
    v17 *= v13;
    if (v6 <= v17) {
      v17 %= v6;
    }
    if (!--v16) {
      goto LABEL_31;
    }
  }

  int v20 = a2;
LABEL_38:
  uint64_t v22 = v29;
  int v24 = *(void *)(*v28 + 8 * v18);
  uint64_t v25 = -1LL;
  if (v24 != 2780474809LL) {
    uint64_t v25 = *(void *)(*v28 + 8 * v18);
  }
  if (v24 == 2814029233LL) {
    uint64_t v26 = 0LL;
  }
  else {
    uint64_t v26 = v25;
  }
  v29[1] = v20;
  v29[2] = v26;
  *uint64_t v29 = v18;
  int64_t v27 = *(unsigned __int16 *)(v3 + 18);
  if ((v27 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  uint64_t v19 = 1LL;
LABEL_32:
  v22[3] = v19;
  return result;
}

    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_8 != -1) {
      dispatch_once( &_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_8,  &__block_literal_global_10_0);
    }
    if (CFStringGetLength(MutableCopy) >= 1)
    {
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_doubleStrings == 1)
      {
        int v24 = _CFDoubledStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        Mutableuint64_t Copy = v24;
      }

      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_accentuateStrings == 1)
      {
        uint64_t v25 = _CFAccentuatedStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        Mutableuint64_t Copy = (CFMutableStringRef)v25;
      }

      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_forceRightToLeftStrings == 1)
      {
        uint64_t v26 = _CFRLORightToLeftStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        Mutableuint64_t Copy = (CFMutableStringRef)v26;
      }

      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_surroundStrings == 1)
      {
        int64_t v27 = _CFAffixedStringCreate((uint64_t)MutableCopy, (uint64_t)@"[# ", (uint64_t)@" #]");
        CFRelease(MutableCopy);
        Mutableuint64_t Copy = (CFMutableStringRef)v27;
      }

      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_tallStrings == 1)
      {
        int64_t v28 = _CFTallStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        Mutableuint64_t Copy = (CFMutableStringRef)v28;
      }
    }

    if (!a6 && MutableCopy)
    {
      uint64_t v29 = _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(MutableCopy, (__CFBundle *)a1, (uint64_t)cf);
      CFRelease(MutableCopy);
      Mutableuint64_t Copy = (CFMutableStringRef)v29;
    }

    if (a7)
    {
      *a7 = cf;
    }

    else if (cf)
    {
      CFRelease(cf);
    }

    if (a5 && (int64_t v30 = (os_log_s *)_CFBundleLocalizedStringLogger(), os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)))
    {
      CFMutableDictionaryRef Mutable = CFStringCreateMutable(0LL, 0LL);
      CFStringAppend(Mutable, @"[");
      if (CFArrayGetCount(a5) >= 1)
      {
        uint64_t v32 = 0LL;
        do
        {
          if (v32) {
            CFStringAppend(Mutable, @", ");
          }
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a5, v32);
          CFStringAppend(Mutable, ValueAtIndex);
          ++v32;
        }

        while (v32 < CFArrayGetCount(a5));
      }

      CFStringAppend(Mutable, @"]");
    }

    else
    {
      CFMutableDictionaryRef Mutable = 0LL;
    }

    uint64_t v34 = (os_log_s *)_CFBundleLocalizedStringLogger();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138479107;
      uint64_t v38 = a1;
      CFIndex v39 = 2114;
      int64_t v40 = key;
      int64_t v41 = 2114;
      CFIndex v42 = (unint64_t *)a3;
      uint64_t v43 = 2114;
      int64_t v44 = a4;
      uint64_t v45 = 2114;
      int64_t v46 = Mutable;
      UniChar v47 = 2114;
      unsigned int v48 = MutableCopy;
      _os_log_debug_impl( &dword_180A4C000,  v34,  OS_LOG_TYPE_DEBUG,  "Bundle: %{private}@, key: %{public}@, value: %{public}@, table: %{public}@, localizationNames: %{public}@, result: %{public}@",  buf,  0x3Eu);
      if (!Mutable) {
        return MutableCopy;
      }
    }

    else if (!Mutable)
    {
      return MutableCopy;
    }

    CFRelease(Mutable);
    return MutableCopy;
  }

  if (a3) {
    return (CFMutableStringRef)CFRetain(a3);
  }
  else {
    return (CFMutableStringRef)CFRetain(&stru_1899EF170);
  }
}

      v7 += numKey;
      unsigned int v4 = v4->_subSharedKeySet;
    }

    while (v4);
  }

  return 0x7FFFFFFFFFFFFFFFLL;
}

  int64_t v27 = -[CFPrefsSource copyOSLogDescription](self, "copyOSLogDescription");
  _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
  int64_t v28 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
    -[CFPrefsPlistSource handleReply:toRequestNewDataMessage:onConnection:retryCount:error:].cold.3();
  }
  _CFSetTSD(0xFu, 0LL, 0LL);
  CFRelease(v27);
LABEL_118:
  uint64_t v62 = -[CFPrefsSource copyOSLogDescription](self, "copyOSLogDescription");
  _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
  uint64_t v63 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
    -[CFPrefsPlistSource handleReply:toRequestNewDataMessage:onConnection:retryCount:error:].cold.2();
  }
  _CFSetTSD(0xFu, 0LL, 0LL);
  if (v62) {
    CFRelease(v62);
  }
  *a7 = 1;
  if (Mutable) {
LABEL_123:
  }
    CFRelease(Mutable);
}

LABEL_140:
              uint64_t v109 = *v38;
              v108 = v38 + 1;
              *int64_t v27 = v109;
              CFIndex v39 = v27 + 1;
              if (v33 <= v108) {
                uint64_t v110 = v35;
              }
              else {
                uint64_t v110 = 0LL;
              }
              uint64_t v38 = &v108[v110];
LABEL_144:
              uint64_t v112 = *v38;
              UniChar v111 = v38 + 1;
              *v39++ = v112;
              if (v33 <= v111) {
                uint64_t v113 = v35;
              }
              else {
                uint64_t v113 = 0LL;
              }
              uint64_t v38 = &v111[v113];
LABEL_148:
              uint64_t v115 = *v38;
              uint64_t v114 = v38 + 1;
              *v39++ = v115;
              if (v33 <= v114) {
                uint64_t v116 = v35;
              }
              else {
                uint64_t v116 = 0LL;
              }
              uint64_t v38 = &v114[v116];
LABEL_152:
              *CFIndex v39 = *v38;
              a5 = v157;
              p_storage = v158;
              break;
          }
        }

        uint64_t v117 = a5;
        uint64_t v118 = &v27[a5];
        memmove(v118, a3, 8 * a4);
        v119 = used - v117;
        if (v119)
        {
          v120 = (char *)&v118[a4];
          int64_t v121 = p_storage->list;
          int64_t v122 = p_storage->size;
          v123 = (unint64_t)&p_storage->list[v122];
          v124 = (unint64_t)(&p_storage->list[p_storage->var0] + v117);
          uint64_t v125 = -v122;
          if (v123 <= v124) {
            v126 = -v122;
          }
          else {
            v126 = 0LL;
          }
          CFIndex v127 = (uint64_t *)(v124 + 8 * v126);
          switch(v119)
          {
            case 1uLL:
              goto LABEL_176;
            case 2uLL:
              goto LABEL_172;
            case 3uLL:
              goto LABEL_168;
            case 4uLL:
              goto LABEL_164;
            default:
              CFRange v128 = (uint64_t)(v123 - (void)v127) >> 3;
              if (v128 >= v119) {
                CFRange v128 = v119;
              }
              v129 = v128;
              if ((_DWORD)v128)
              {
                v159 = v128;
                uint64_t v157 = v128;
                memmove(v120, v127, 8LL * v128);
                LODWORD(v128) = v157;
                v129 = v159;
              }

              v130 = v119 - v128;
              if (v130) {
                memmove(&v120[8 * v129], v121, 8LL * v130);
              }
LABEL_164:
              int64_t v132 = *v127;
              UniChar v131 = v127 + 1;
              *(void *)v120 = v132;
              v120 += 8;
              else {
                int64_t v133 = 0LL;
              }
              CFIndex v127 = &v131[v133];
LABEL_168:
              v135 = *v127;
              int64_t v134 = v127 + 1;
              *(void *)v120 = v135;
              v120 += 8;
              else {
                int64_t v136 = 0LL;
              }
              CFIndex v127 = &v134[v136];
LABEL_172:
              CFRange v138 = *v127;
              UniChar v137 = v127 + 1;
              *(void *)v120 = v138;
              v120 += 8;
              else {
                v139 = 0LL;
              }
              CFIndex v127 = &v137[v139];
LABEL_176:
              *(void *)v120 = *v127;
              p_storage = v158;
              break;
          }
        }
      }

      else
      {
        memmove(v26, a3, 8 * a4);
      }

      bzero(&v27[v21], v25 - 8 * v21);
      p_storage->list = v27;
      p_storage->var0 = 0;
      p_storage->size = v25 >> 3;
      p_storage->state.var0.used = v21;
      free(list);
      return;
    }

  if (a7 && v18 >= 1) {
    *a7 = v17 - v110;
  }
  return v18;
}
    }

    else if (*theArray)
    {
LABEL_154:
      _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, v87);
      uint64_t v77 = *(_OWORD *)(a5 + 48);
      UniChar v102 = *(_OWORD *)(a5 + 32);
      CFStringRef v103 = v77;
      CFURLRef v104 = *(void *)(a5 + 64);
      __int16 v78 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)v101 = *(_OWORD *)a5;
      *(_OWORD *)&v101[16] = v78;
      _CFBundleIngestResultForBundleCache(a1, a3, 0, (uint64_t)v101);
      return result;
    }

    char v70 = CFArrayGetValueAtIndex(a4, 0LL);
    *uint64_t v90 = CFRetain(v70);
    uint64_t v71 = CFArrayGetValueAtIndex(a4, 0LL);
    *theArray = CFRetain(v71);
LABEL_142:
    int v72 = *(const __CFData **)(a5 + 56);
    if (v72)
    {
      cf = 0LL;
      v98 = 0;
      v97 = 0LL;
      CFRange v96 = 0;
      if (*(void *)(a5 + 8)) {
        __int16 v73 = *(const __CFString **)(a5 + 8);
      }
      else {
        __int16 v73 = *(const __CFString **)(a5 + 32);
      }
      _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v72, v73, &cf, &v98, &v97, &v96);
      CFIndex v74 = _useLoctableInsteadOfFileBasedOnVersion((CFTypeRef *)a5, v90, v98, cf);
      int v75 = _useLoctableInsteadOfFileBasedOnVersion(v92, theArray, v96, v97);
      if (!(v74 | v75))
      {
        CFRelease(*(CFTypeRef *)(a5 + 56));
        *(void *)(a5 + 56) = 0LL;
      }

      if (!v74 && *(void *)a5 || *v92 && !v75)
      {
        int v76 = (os_log_s *)_CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v79 = *v90;
          *(_DWORD *)v101 = 138412802;
          *(void *)&v101[4] = a1;
          *(_WORD *)&v101[12] = 2112;
          *(void *)&v101[14] = a3;
          *(_WORD *)&v101[22] = 2112;
          *(void *)&v101[24] = v79;
          _os_log_debug_impl( &dword_180A4C000,  v76,  OS_LOG_TYPE_DEBUG,  "loctable overridden by installed files. Bundle: %@, table: %@, language: %@",  v101,  0x20u);
        }
      }
    }

    goto LABEL_154;
  }

  if (v27 | *(void *)(a5 + 32))
  {
    if (*(_BYTE *)(a5 + 68))
    {
      CFIndex v37 = *(const void **)(a5 + 56);
      if (v37)
      {
        CFRelease(v37);
        *(void *)(a5 + 56) = 0LL;
      }
    }

    _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, a2);
    return result;
  }

  int64_t v44 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"strings", 0LL);
  uint64_t v45 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"stringsdict", 0LL);
  theData = *(const __CFData **)(a5 + 56);
  if (theData)
  {
    theArraya = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    CFIndex Count = CFArrayGetCount(theArraya);
    if (v44)
    {
      UniChar v47 = _CFBundleCopyLanguageForStringsResourceURL(v44);
      if (v45)
      {
LABEL_62:
        cf2 = _CFBundleCopyLanguageForStringsResourceURL(v45);
LABEL_77:
        FileVersionForStringsResourceURL = _CFBundleGetFileVersionForStringsResourceURL(v44);
        __int16 v82 = _CFBundleGetFileVersionForStringsResourceURL(v45);
        LOBYTE(v96) = 0;
        CFRange v100 = 0;
        _CFBundleGetLocTableProvenanceForLanguage(theData, @"none", &v96, &v100);
        *(void *)CFIndex v93 = Count - 1;
        if (Count < 1) {
          goto LABEL_123;
        }
        uint64_t v80 = v45;
        uint64_t v81 = v44;
        int64_t v88 = a2;
        int64_t v53 = v47;
        int v54 = 0;
        CFIndex v55 = 0;
        v84 = 0;
        uint64_t v56 = 0LL;
        unsigned int v57 = v96;
        unsigned int v58 = v100;
        CFStringRef v85 = v53;
        if ((_BYTE)v96) {
          CFIndex v59 = v53 == 0LL;
        }
        else {
          CFIndex v59 = 0;
        }
        CFIndex v60 = v59;
        v91 = v60;
        uint64_t v62 = v100 && cf2 == 0LL;
        while (1)
        {
          uint64_t v63 = (const __CFString *)CFArrayGetValueAtIndex(theArraya, v56);
          *(void *)v101 = 0LL;
          LODWORD(v97) = 0;
          cf = 0LL;
          v98 = 0;
          if (v54 | v57 && v55 | v58)
          {
            if (v55) {
              goto LABEL_102;
            }
          }

          else
          {
            _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(theData, v63, v101, &v97, &cf, &v98);
            if (v55) {
              goto LABEL_102;
            }
          }

          if (cf2 && CFEqual(v63, cf2) && v82 >= v98) {
            break;
          }
          if (cf)
          {
            int v64 = CFRetain(cf);
            v84 = 1;
            goto LABEL_101;
          }

          CFIndex v55 = 0;
          if (v54) {
            goto LABEL_103;
          }
LABEL_113:
          if (v85 && CFEqual(v63, v85) && FileVersionForStringsResourceURL >= v97)
          {
            *(void *)a5 = CFRetain(v81);
            int v65 = CFRetain(v63);
          }

          else
          {
            if (!*(void *)v101)
            {
              int v54 = 0;
              goto LABEL_104;
            }

            int v65 = CFRetain(*(CFTypeRef *)v101);
            v84 = 1;
          }

          *(void *)(a5 + 8) = v65;
          if ((v55 & 1) == 0) {
            *(_BYTE *)(a5 + 67) = 0;
          }
LABEL_103:
          int v54 = 1;
LABEL_104:
          if (cf) {
            CFRelease(cf);
          }
          if (*(void *)v101) {
            CFRelease(*(CFTypeRef *)v101);
          }
          if (((v54 | v91) & (v55 | v62) & 1) == 0)
          {
            int v17 = *(void *)v93 == v56++;
            if (!v17) {
              continue;
            }
          }

          a2 = v88;
          uint64_t v45 = v80;
          int64_t v44 = v81;
          UniChar v47 = v85;
          if (!v84)
          {
LABEL_123:
            uint64_t v66 = (os_log_s *)_CFBundleLocalizedStringLogger();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG)) {
              _CFBundleGetStringsSources_cold_1();
            }
            *(_BYTE *)(a5 + 68) = 1;
          }

          if (v47) {
            CFRelease(v47);
          }
          if (cf2) {
            CFRelease(cf2);
          }
          int64_t v52 = theArraya;
LABEL_131:
          CFRelease(v52);
          goto LABEL_132;
        }

        *(void *)(a5 + 24) = CFRetain(v80);
        int v64 = CFRetain(v63);
LABEL_101:
        *(void *)(a5 + 32) = v64;
LABEL_102:
        CFIndex v55 = 1;
        if (v54) {
          goto LABEL_103;
        }
        goto LABEL_113;
      }
    }

    else
    {
      UniChar v47 = 0LL;
      if (v45) {
        goto LABEL_62;
      }
    }

    cf2 = 0LL;
    goto LABEL_77;
  }

  if (v44)
  {
    *(void *)a5 = CFRetain(v44);
    *(void *)(a5 + 8) = _CFBundleCopyLanguageForStringsResourceURL(v44);
  }

  if (v45)
  {
    *(void *)(a5 + 24) = CFRetain(v45);
    *(void *)(a5 + 32) = _CFBundleCopyLanguageForStringsResourceURL(v45);
  }

  if (*v28)
  {
    unsigned int v48 = *(const void **)(a5 + 32);
    if (v48)
    {
      if (!CFEqual(*v28, v48))
      {
        int64_t v49 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
        uint64_t v50 = CFArrayGetCount(v49);
        v106.int location = 0LL;
        v106.CFIndex length = v50;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v49, v106, *(const void **)(a5 + 8));
        v107.int location = 0LL;
        v107.CFIndex length = v50;
        int64_t v52 = v49;
        goto LABEL_131;
      }
    }
  }

LABEL_185:
    -[__NSArrayM insertObjects:count:atIndex:].cold.1();
  }

  int64_t v44 = p_storage->state.var0.used;
  uint64_t v45 = v44 - a5;
  uint64_t v157 = a5;
  v158 = p_storage;
  int64_t v46 = p_storage->var0;
  uint64_t v156 = (used + a4);
  if (v45 <= a5)
  {
    if (v44 != (_DWORD)a5)
    {
      unsigned int v57 = v158->list;
      if ((a4 & 0x8000000000000000LL) != 0)
      {
        v86 = v46 + v157;
        int v87 = v86 + a4;
        else {
          int64_t v88 = size;
        }
        do
        {
          int64_t v89 = v86
              + size
              + size
              * (((v86 & ~(v86 >> 63)) - (v86 + ((unint64_t)v86 >> 63))) / v88 + ((unint64_t)v86 >> 63));
          do
            v89 -= size;
          while (v89 >= size);
          uint64_t v90 = v87
              + size
              + size
              * (((unint64_t)v87 >> 63) + ((v87 & ~(v87 >> 63)) - (v87 + ((unint64_t)v87 >> 63))) / v88);
          do
            v90 -= size;
          while (v90 >= size);
          if (v90 <= v89) {
            v91 = v89;
          }
          else {
            v91 = v90;
          }
          int64_t v92 = size - v91;
          if (v45 >= v92) {
            CFIndex v93 = v92;
          }
          else {
            CFIndex v93 = v45;
          }
          memmove(&v57[v90], &v57[v89], 8 * v93);
          v86 += v93;
          v87 += v93;
          uint64_t v56 = v45 <= v93;
          v45 -= v93;
        }

        while (!v56);
      }

      else
      {
        unsigned int v58 = v57 + 1;
        CFIndex v59 = v157 + v45 + v46 - 1;
        CFIndex v60 = v59 + a4;
        else {
          unsigned int v61 = size;
        }
        uint64_t v62 = v57 + 1;
        v159 = (uint64_t)&v58[size];
        do
        {
          uint64_t v63 = ((v60 & ~((uint64_t)v60 >> 63)) - (v60 + (v60 >> 63))) / v61;
          int v64 = v59
              + size
              + size
              * (((v59 & ~(v59 >> 63)) - (v59 + ((unint64_t)v59 >> 63))) / v61 + ((unint64_t)v59 >> 63));
          do
            v64 -= size;
          while (v64 >= size);
          int v65 = v60 + (v63 + (v60 >> 63)) * size;
          uint64_t v66 = size + size * ((v60 >> 63) + v63);
          int v67 = v60 + v66;
          int v68 = v159 + 8 * v65;
          do
          {
            v67 -= size;
            v66 -= size;
            v68 -= 8 * size;
          }

          while ((uint64_t)(v60 + v66) >= size);
          else {
            int v69 = v64;
          }
          if (v45 >= v69 + 1) {
            char v70 = v69 + 1;
          }
          else {
            char v70 = v45;
          }
          if (v64 < v67) {
            int v67 = v64;
          }
          if (v45 >= v67 + 1) {
            uint64_t v71 = v67 + 1;
          }
          else {
            uint64_t v71 = v45;
          }
          memmove((void *)(v68 - 8 * v71), &v62[v64] - v70, 8 * v70);
          v59 -= v70;
          v60 -= v70;
          uint64_t v56 = v45 <= v70;
          v45 -= v70;
        }

        while (!v56);
      }
    }
  }

  else
  {
    UniChar v47 = a5;
    if ((_DWORD)a5)
    {
      unsigned int v48 = v158->list;
      if ((uint64_t)a4 < 1)
      {
        int v72 = a5 + v46 - 1;
        __int16 v73 = v72 - a4;
        CFIndex v74 = v48 + 1;
        else {
          int v75 = size;
        }
        v159 = (uint64_t)&v74[size];
        do
        {
          int v76 = ((v73 & ~((uint64_t)v73 >> 63)) - (v73 + (v73 >> 63))) / v75;
          uint64_t v77 = v72
              + size
              + size
              * (((v72 & ~(v72 >> 63)) - (v72 + ((unint64_t)v72 >> 63))) / v75 + ((unint64_t)v72 >> 63));
          do
            v77 -= size;
          while (v77 >= size);
          __int16 v78 = v73 + (v76 + (v73 >> 63)) * size;
          unint64_t v79 = size + size * ((v73 >> 63) + v76);
          uint64_t v80 = v73 + v79;
          uint64_t v81 = v159 + 8 * v78;
          do
          {
            v80 -= size;
            v79 -= size;
            v81 -= 8 * size;
          }

          while ((uint64_t)(v73 + v79) >= size);
          else {
            __int16 v82 = v77;
          }
          if (v47 >= v82 + 1) {
            v83 = v82 + 1;
          }
          else {
            v83 = v47;
          }
          if (v77 < v80) {
            uint64_t v80 = v77;
          }
          if (v47 >= v80 + 1) {
            v84 = v80 + 1;
          }
          else {
            v84 = v47;
          }
          memmove((void *)(v81 - 8 * v84), &v74[v77] - v83, 8 * v83);
          v72 -= v83;
          v73 -= v83;
          uint64_t v56 = v47 <= v83;
          v47 -= v83;
        }

        while (!v56);
      }

      else
      {
        int64_t v49 = v46 - a4;
        else {
          uint64_t v50 = size;
        }
        do
        {
          uint64_t v51 = v46
              + size
              + size
              * (((v46 & ~(v46 >> 63)) - (v46 + ((unint64_t)v46 >> 63))) / v50 + ((unint64_t)v46 >> 63));
          do
            v51 -= size;
          while (v51 >= size);
          int64_t v52 = v49
              + size
              + size
              * (((unint64_t)v49 >> 63) + ((v49 & ~(v49 >> 63)) - (v49 + ((unint64_t)v49 >> 63))) / v50);
          do
            v52 -= size;
          while (v52 >= size);
          if (v52 <= v51) {
            int64_t v53 = v51;
          }
          else {
            int64_t v53 = v52;
          }
          int v54 = size - v53;
          if (v47 >= v54) {
            CFIndex v55 = v54;
          }
          else {
            CFIndex v55 = v47;
          }
          memmove(&v48[v52], &v48[v51], 8 * v55);
          v46 += v55;
          v49 += v55;
          uint64_t v56 = v47 <= v55;
          v47 -= v55;
        }

        while (!v56);
      }
    }

    CFStringRef v85 = v158->var0 + size - a4;
    v158->var0 = v85;
  }

  int64_t v94 = 0LL;
  int64_t v95 = v158;
  CFRange v96 = v158->size;
  v97 = (unint64_t)&v158->list[v96];
  v98 = v156;
  UniChar v99 = (unint64_t)(&v95->list[v95->var0] + v157);
  CFRange v100 = -v96;
  do
  {
    if (v97 <= v99) {
      v101 = v100;
    }
    else {
      v101 = 0LL;
    }
    UniChar v102 = (const void **)(v99 + 8 * v101);
    CFStringRef v103 = a3[v94];
    if (*v102 != v103) {
      *UniChar v102 = v103;
    }
    UniChar v99 = (unint64_t)(v102 + 1);
    ++v94;
  }

  while (a4 > v94);
  v95->state.var0.used = v98;
}

                    __break(1u);
                    JUMPOUT(0x180B618ECLL);
                  }

uint64_t __NSArrayM_new(const void *a1, unint64_t a2, char a3)
{
  size_t v6 = (objc_class *)objc_opt_self();
  uint64_t v7 = __CFAllocateObject(v6, 0LL);
  if (v7)
  {
    if (a2)
    {
      if (a2 >> 61)
      {
LABEL_4:

        return 0LL;
      }

      uint64_t v10 = 8 * a2;
      size_t v11 = malloc_good_size(8 * a2);
      if (HIDWORD(v11)) {
        __NSArrayM_new_cold_1();
      }
      size_t v12 = v11;
      if (a1)
      {
        unint64_t v13 = malloc(v11);
        if (!v13) {
          goto LABEL_4;
        }
        unint64_t v9 = v13;
        memmove(v13, a1, 8 * a2);
        if ((a3 & 1) != 0)
        {
          uint64_t v14 = (char *)&v9[a2];
          size_t v15 = v12 - v10;
        }

        else
        {
          uint64_t v17 = 0LL;
          do
          {
            unint64_t v18 = v9[v17];
            if ((v18 & 0x8000000000000000LL) == 0) {
              id v19 = (id)v18;
            }
            ++v17;
          }

          while (a2 != v17);
          uint64_t v14 = (char *)&v9[a2];
          size_t v15 = v12 - v10;
        }

        bzero(v14, v15);
        unsigned int v8 = v12 >> 3;
      }

      else
      {
        unint64_t v16 = calloc(1uLL, v11);
        if (!v16) {
          goto LABEL_4;
        }
        unint64_t v9 = v16;
        LODWORD(a2) = 0;
        unsigned int v8 = v12 >> 3;
      }
    }

    else
    {
      unsigned int v8 = 0;
      unint64_t v9 = 0LL;
    }

    *(void *)(v7 + 16) = v9;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 28) = v8;
    *(_DWORD *)(v7 + 32) = 1;
    *(_DWORD *)(v7 + 36) = a2;
  }

  return v7;
}

uint64_t __NSArrayM_transferNew(void *a1, int a2, int a3)
{
  size_t v6 = (objc_class *)objc_opt_self();
  uint64_t v7 = __CFAllocateObject(v6, 0LL);
  uint64_t v8 = v7;
  if (v7)
  {
    *(void *)(v7 + 16) = a1;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 28) = a3;
    *(_DWORD *)(v7 + 32) = 1;
    *(_DWORD *)(v7 + 36) = a2;
  }

  else
  {
    free(a1);
  }

  return v8;
}

void __RELEASE_OBJECTS_IN_THE_ARRAY__(uint64_t a1, int a2)
{
  uint64_t v2 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  if (a2 == 1) {
    uint64_t v2 = &OBJC_IVAR_____NSArrayM_storage;
  }
  uint64_t v3 = a1 + *v2;
  unsigned int v4 = *(id **)v3;
  uint64_t v5 = *(unsigned int *)(v3 + 8);
  unsigned int v6 = *(_DWORD *)(v3 + 12) - v5;
  unsigned int v7 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(v3 + 20) = 0;
  if (v6 >= v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = v6;
  }
  *(void *)uint64_t v3 = 0LL;
  *(void *)(v3 + 8) = 0LL;
  if (v4)
  {
    if ((_DWORD)v8)
    {
      unint64_t v9 = &v4[v5];
      uint64_t v10 = v8;
      do
      {
        ++v9;
        --v10;
      }

      while (v10);
    }

    if (v7 > v6)
    {
      else {
        uint64_t v11 = v7 - v8;
      }
      size_t v12 = v4;
      do
      {
        ++v12;
        --v11;
      }

      while (v11);
    }

    free(v4);
  }

LABEL_9:
  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

  -[NSMutableOrderedSet insertObjects:count:atIndex:]( self,  "insertObjects:count:atIndex:",  objects,  count,  -[NSOrderedSet count](self, "count"));
}

  uint64_t v11 = -[NSOrderedSet count](self, "count");
  if ((a5 & 0x8000000000000000LL) == 0 && v11 >= a5)
  {
    size_t v12 = -[NSOrderedSet count](self, "count");
    if (a4)
    {
      unint64_t v13 = a5 - v12;
      do
      {
        uint64_t v14 = (uint64_t)*a3++;
        -[NSMutableOrderedSet insertObject:atIndex:]( self,  "insertObject:atIndex:",  v14,  v13 + -[NSOrderedSet count](self, "count"));
        --a4;
      }

      while (a4);
    }

    return;
  }

  inserted = (__NSCFDictionary *)_NSDictionaryRaiseInsertNilValueException((objc_class *)self, a2, (uint64_t)a4);
  -[__NSCFDictionary removeObjectForKey:](inserted, v10, v11);
}

  CFIndex Count = _CFNonObjCArrayGetCount((uint64_t)self);
  uint64_t v10 = (__NSCFArray *)_NSArrayRaiseBoundException((uint64_t)self, a2, a3, Count);
  -[__NSCFArray removeObjectAtIndex:](v10, v11, v12);
}

  unint64_t v9 = *(void *)(a1 + 24);
  if (v9) {
    uint64_t v10 = (*(void *)(a1 + 16) & 0x1FLL) == 6;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = v10;
  if ((*(void *)(a1 + 16) & 0x1FuLL) - 8 < 0xFFFFFFFFFFFFFFFELL || v11 != 0)
  {
    unint64_t v13 = 2LL;
    if (v9) {
      unint64_t v13 = 7LL;
    }
    *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFE0LL | v13;
  }

  uint64_t v14 = *(void *)(a1 + 32);
  if (v9)
  {
    if (v14 && (*(_BYTE *)(v14 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      size_t v15 = *(void *)(a1 + 32);
      if (v15 && (unint64_t v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v15 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72LL) |= 8uLL;
        CFRunLoopSourceSignal(v16);
        CFRelease(v16);
        _wakeUpRunLoop(a1);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }

    unint64_t result = 7LL;
  }

  else
  {
    if (v14 && (*(_BYTE *)(v14 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      uint64_t v17 = *(void *)(a1 + 32);
      if (v17 && (unint64_t v18 = *(__CFRunLoopSource **)(v17 + 56)) != 0LL)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(void *)(*(void *)(a1 + 32) + 72LL) |= 1uLL;
        CFRunLoopSourceSignal(v18);
        CFRelease(v18);
        _wakeUpRunLoop(a1);
      }

      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }

    unint64_t result = 2LL;
  }

  while (v4 < v5)
  {
    unsigned int v7 = *v4++;
    uint64_t v3 = 257 * v3 + v7;
  }

  return (v3 << (v2 & 0x1F)) + v3;
}

  unsigned int v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 4) == 0) {
    return 0LL;
  }
  uint64_t v8 = atomic_load((unint64_t *)&theString->info);
  if ((v8 & 0x10) != 0) {
    return 0LL;
  }
  unint64_t v9 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    unint64_t v9 = __CFDefaultEightBitStringEncoding;
  }

  if (v9 != encoding)
  {
    if (v9 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unint64_t v9 = __CFDefaultEightBitStringEncoding;
    }

    if (v9 == 1536)
    {
      unint64_t result = 0LL;
      switch(BYTE1(encoding))
      {
        case 0:
          unint64_t result = 0LL;
          if ((encoding > 0x22 || ((1LL << encoding) & 0x600000032LL) == 0) && encoding != 152) {
            goto LABEL_15;
          }
          return result;
        case 1:
          if (encoding != 134217984) {
            return 0LL;
          }
          goto LABEL_15;
        case 2:
          if (encoding == 518) {
            return 0LL;
          }
          goto LABEL_15;
        case 6:
          if (encoding != 1536) {
            return 0LL;
          }
          goto LABEL_15;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          if (encoding - 2561 > 0xF) {
            goto LABEL_15;
          }
          unint64_t v18 = 1 << (encoding - 1);
          id v19 = 32785;
          goto LABEL_46;
        case 0xB:
          if (encoding - 3059 > 0xC) {
            goto LABEL_15;
          }
          unint64_t v18 = 1 << (encoding + 13);
          id v19 = 4099;
LABEL_46:
          if ((v18 & v19) != 0) {
            return 0LL;
          }
          goto LABEL_15;
        default:
          if ((encoding & 0xFF00) > 0xC00) {
            return 0LL;
          }
          goto LABEL_15;
      }
    }

    return 0LL;
  }

  unsigned int v6 = atomic_load((unint64_t *)&theString->info);
  if ((v6 & 0x10) == 0) {
    return 0LL;
  }
  unsigned int v7 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v7 & 0x60) != 0) {
    return (const UniChar *)*p_data;
  }
  unint64_t v9 = atomic_load((unint64_t *)&theString->info);
  return (const UniChar *)&p_data[(v9 & 5) != 4LL];
}

      size_t v12 = 1LL;
      goto LABEL_10;
    }
  }

  uint64_t v11 = 0LL;
  if (a4)
  {
    size_t v12 = 0LL;
    uint64_t v5 = -1LL;
LABEL_11:
    *a4 = v5;
    a4[1] = v12;
  }

  return v11;
}

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v9, 0LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v10, 0LL);
  return v10;
}

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v10, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v11, (uint64_t)__NSOrderedSet_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

  if ((a5 & 1) == 0)
  {
    if (!a4 || CFEqual(a4, @"kCFPreferencesNoContainer"))
    {
      if (CFEqual(v11, @"C"))
      {
        if (Copy != @"kCFPreferencesCurrentUser")
        {
        int64_t v44 = @"C/C//B/L";
        goto LABEL_52;
      }

      if (CFEqual(v11, @"kCFPreferencesAnyApplication"))
      {
        if (Copy != @"kCFPreferencesCurrentUser")
        {
        int64_t v44 = @"A/C//B/L";
LABEL_52:
        if (a3) {
          int v20 = v44;
        }
        else {
          int v20 = v43;
        }
        goto LABEL_55;
      }
    }

  if (isAbsolute) {
    *isAbsolute = 0;
  }
  return v4;
}

  uint64_t v8 = 0;
  unint64_t v9 = 32;
  do
  {
    uint64_t v10 = v9;
    v9 >>= 1;
    v8 += v6 & 1;
    v6 >>= 1;
  }

  while ((v10 & 2) == 0);
  uint64_t v11 = (char *)v2 + 16 * v8;
  unint64_t v13 = *((void *)v11 + 7);
  size_t v12 = *((void *)v11 + 8);
  PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (v15)
  {
    unint64_t v16 = PathComponent;
    if (v15 == 2)
    {
      unint64_t v18 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v18, v16) != 46) {
        goto LABEL_21;
      }
      id v19 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v19, v16 + 1) != 46) {
        goto LABEL_21;
      }
    }

    else if (v15 != 1 {
           || (uint64_t v17 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
    }
               (CFStringGetCharacterAtIndex(v17, v16) & 0xFFFE) != 0x2E))
    {
LABEL_21:
      uint64_t v25 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      Mutableuint64_t Copy = CFStringCreateMutableCopy(allocator, 0LL, v25);
      int v21 = MutableCopy;
      if (v16 == v13)
      {
        v32.int location = v13;
        v32.CFIndex length = v12;
        CFStringReplace(MutableCopy, v32, @".");
        CFStringInsert(v21, 1LL, @"/");
        goto LABEL_33;
      }

      v27.CFIndex length = v12 + v13 - v16;
      v27.int location = v16;
      goto LABEL_24;
    }
  }

  int v20 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
  int v21 = CFStringCreateMutableCopy(allocator, 0LL, v20);
  if (v12 <= 0)
  {
    int v24 = 0LL;
    BOOL v23 = v12 + v13;
  }

  else
  {
    uint64_t v22 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    BOOL v23 = v12 + v13;
    if (CFStringGetCharacterAtIndex(v22, v23 - 1) == 47)
    {
      int v24 = 0LL;
    }

    else
    {
      CFStringInsert(v21, v23, @"/");
      int v24 = 1LL;
    }
  }

  CFStringInsert(v21, v24 + v23, @"..");
  CFStringInsert(v21, v24 + v23 + 2, @"/");
  int64_t v28 = v24 + 3 + v12;
  if (v28 >= 5)
  {
    uint64_t v29 = v24 + 3 + v23;
    int64_t v30 = v29 - 5;
    if (CFStringGetCharacterAtIndex(v21, v29 - 5) == 46)
    {
      if ((unint64_t)v28 < 8)
      {
        if (v28 == 5) {
          goto LABEL_31;
        }
      }

      else
      {
        int64_t v30 = v29 - 6;
        if (CFStringGetCharacterAtIndex(v21, v29 - 6) == 47)
        {
LABEL_31:
          Mutableuint64_t Copy = v21;
          v27.int location = v30;
          v27.CFIndex length = 2LL;
LABEL_24:
          CFStringDelete(MutableCopy, v27);
        }
      }
    }
  }

  Class = object_getClass(*(id *)a1);
  Name = class_getName(Class);
  if (class_respondsToSelector(Class, sel_forwardingTargetForSelector_))
  {
    uint64_t v11 = [(id)v4 forwardingTargetForSelector:v5];
    if (v11)
    {
      if (v11 != v4)
      {
        if ((v11 & 0x8000000000000000LL) == 0) {
          goto LABEL_40;
        }
        size_t v12 = 0LL;
        unint64_t v13 = *MEMORY[0x189616658];
        if ((~v11 & 0xC000000000000007LL) == 0) {
          LOBYTE(v13) = 0;
        }
        uint64_t v14 = (v13 ^ v11) & 7;
        while (v14 != *(unsigned __int8 *)(MEMORY[0x189616648] + v12))
        {
          if (++v12 == 7) {
            goto LABEL_40;
          }
        }

        if (v12)
        {
LABEL_40:
          v3->n128_u64[0] = v11;
          return 0LL;
        }

        unsigned int v4 = v11;
        goto LABEL_43;
      }
    }
  }

  if (!strncmp(Name, "_NSZombie_", 0xAuLL)) {
    ___forwarding____cold_2(v4, (uint64_t)Name, v5);
  }
  if (!class_respondsToSelector(Class, sel_methodSignatureForSelector_))
  {
    Superclass = class_getSuperclass(Class);
    object_getClassName((id)v4);
    if (Superclass)
    {
      CFLog( 4LL,  (uint64_t)@"*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- trouble ahead",  v42,  v43,  v44,  v45,  v46,  v47,  v4);
    }

    else
    {
      object_getClassName((id)v4);
      CFLog( 4LL,  (uint64_t)@"*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- did you forget to declare the superclass of '%s'?",  v48,  v49,  v50,  v51,  v52,  v53,  v4);
    }

  -[NSMutableArray insertObjects:count:atIndex:]( self,  "insertObjects:count:atIndex:",  a3,  a4,  -[NSArray count](self, "count"));
}

  uint64_t v11 = -[NSArray count](self, "count");
  if ((a5 & 0x8000000000000000LL) == 0 && v11 >= a5)
  {
    for (; a4; --a4)
    {
      size_t v12 = (uint64_t)*a3++;
      -[NSMutableArray insertObject:atIndex:](self, "insertObject:atIndex:", v12, a5++);
    }

    return;
  }

  unsigned int v7 = (objc_class *)objc_opt_self();
  uint64_t v8 = __CFAllocateObject(v7, 0LL);
  unint64_t v9 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 24));
  _cow_copy(a1, 0LL, v9, (uint64_t)__NSSet_cowCallbacks, v8, 1LL);
  return v8;
}

    size_t v15 = v18;
    if (v18 == -1) {
      return;
    }
  }

  uint64_t v26 = 0;
LABEL_23:
  _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v15, v26);
}

    if (a4 && v17 >= 1)
    {
      int v20 = 0LL;
      while (CFStringGetCharacterAtIndex(a1, v20) != 46)
      {
        if (v17 == ++v20) {
          goto LABEL_17;
        }
      }

      if (v19 != v20)
      {
        uint64_t v8 = v20 + 1;
        v44.CFIndex length = ~v20 + CFStringGetLength(a1);
        v44.int location = v20 + 1;
        *(void *)a4 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v44);
      }
    }
  }

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v10, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

  unint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v10 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v11, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v10, 1LL);
  return v10;
}

LABEL_7:
  unsigned int v7 = (objc_class *)objc_opt_self();
  uint64_t v8 = (void *)__CFAllocateObject(v7, 0LL);
  unint64_t v9 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v9, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v8, 1LL);
  return v8;
}

  uint64_t v8 = (objc_class *)objc_opt_self();
  unint64_t v9 = (void *)__CFAllocateObject(v8, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 0LL, v10, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v9, 1LL);
  return v9;
}

    if ((a1 & 1) == 0 && v15 != 169) {
      goto LABEL_73;
    }
    if (a5)
    {
      unint64_t v16 = v40;
      *int64_t v40 = -3;
      int64_t v40 = v16 + 1;
    }

    ++v8;
LABEL_12:
    uint64_t v17 = v14 + 1;
    goto LABEL_13;
  }

    id v19 = 0LL;
LABEL_100:
    CFLog( 4LL,  (uint64_t)@"*** CFMessagePort: dropping corrupt request Mach message (0b%d%d%d%d%d%d)",  v13,  v14,  v15,  v16,  v17,  v18,  v19);
    mach_msg_destroy((mach_msg_header_t *)a1);
    return 0LL;
  }

  if (a2 < 0x3C) {
    goto LABEL_7;
  }
  uint64_t v29 = 60LL;
LABEL_38:
  UniChar v31 = a1[1];
  if (v29 > v31) {
    goto LABEL_7;
  }
  if (a1[5] != 1128680784)
  {
    if (a1[11] == -252513032)
    {
      id v19 = 0LL;
      goto LABEL_76;
    }

    int64_t v52 = 11LL;
LABEL_75:
    id v19 = a1[v52] != -118164752;
LABEL_76:
    uint64_t v34 = 0;
    if (a1[5] == 1128680784) {
      goto LABEL_77;
    }
LABEL_78:
    int64_t v53 = 4060;
    goto LABEL_79;
  }

  if (a1[10] != -252513032)
  {
    int64_t v52 = 10LL;
    goto LABEL_75;
  }

  uint64_t v34 = 0;
  id v19 = 0LL;
LABEL_77:
  int64_t v53 = 4056;
LABEL_79:
  int v54 = v53 < v31;
  if (!v34 && v53 >= v31)
  {
    if (v28 < 0)
    {
      CFIndex v55 = a1[14];
      unsigned int v58 = (v55 - 1610612737) < 0x9FFFFFFE || a1[10] != v55;
      unsigned int v57 = v58;
      goto LABEL_98;
    }

    if (a1[5] == 1128680784)
    {
      CFIndex v55 = a1[13];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        uint64_t v56 = -56;
LABEL_94:
        CFIndex v59 = v56 + (int)v31 < v55;
        goto LABEL_95;
      }
    }

    else
    {
      CFIndex v55 = a1[14];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        uint64_t v56 = -60;
        goto LABEL_94;
      }
    }

    CFIndex v59 = 1;
LABEL_95:
    unsigned int v57 = v59;
    goto LABEL_96;
  }

  unsigned int v57 = 0;
  CFIndex v55 = 0;
  if (v28 < 0) {
    goto LABEL_98;
  }
LABEL_96:
  if (a1[5] != 1128680784)
  {
LABEL_98:
    CFIndex v60 = 11LL;
    goto LABEL_99;
  }

  CFIndex v60 = 10LL;
LABEL_99:
  unsigned int v61 = a1[v60 + 2] < 1;
  if (v34 || v19 || v54 || v57 || v61) {
    goto LABEL_100;
  }
  if (*a1 < 0)
  {
    uint64_t v26 = a1[12];
    int64_t v30 = *(const UInt8 **)(a1 + 7);
    int v20 = a1[10];
LABEL_44:
    unsigned int v35 = CFDataCreateWithBytesNoCopy(a3, v30, v20, (CFAllocatorRef)&__kCFAllocatorNull);
    goto LABEL_45;
  }

  int v20 = v55 & ~(v55 >> 31);
  int v21 = (unint64_t)a1 + a1[1];
  uint64_t v22 = a1[5];
  BOOL v23 = v22 == 1128680784;
  if (v22 == 1128680784) {
    int v24 = 40LL;
  }
  else {
    int v24 = 44LL;
  }
  uint64_t v25 = (unint64_t)a1 + v20 + v24 + 16;
  if (!v23)
  {
    uint64_t v26 = a1[12];
    if (v25 > v21) {
      goto LABEL_35;
    }
    int64_t v27 = 11LL;
    goto LABEL_43;
  }

  uint64_t v26 = a1[11];
  if (v25 <= v21)
  {
    int64_t v27 = 10LL;
LABEL_43:
    int64_t v30 = (const UInt8 *)&a1[v27 + 4];
    goto LABEL_44;
  }

  if (v7)
  {
    while (1)
    {
      if (a3 == 4 && v13 >= 0x530 && v13 >> 4 < 0x195) {
        goto LABEL_69;
      }
      if (HIWORD(v13)) {
        goto LABEL_31;
      }
      if ((v13 & 0xFC00) != 0xDC00) {
        break;
      }
      size_t v15 = *((void *)buffer + 20);
      if (v15 < v7) {
        break;
      }
      unint64_t v16 = v7 - 1;
      uint64_t v17 = *((void *)buffer + 17);
      if (v17)
      {
        unint64_t v18 = *(_WORD *)(v17 + 2 * (*((void *)buffer + 19) + v16));
      }

      else
      {
        id v19 = *((void *)buffer + 18);
        if (v19)
        {
          unint64_t v18 = *(char *)(v19 + *((void *)buffer + 19) + v16);
        }

        else
        {
          if (*((void *)buffer + 22) < v7 || (int v20 = *((void *)buffer + 21), v20 >= v7))
          {
            int v21 = v7 - 5;
            if (v21 + 64 < v15) {
              size_t v15 = v21 + 64;
            }
            *((void *)buffer + 21) = v21;
            *((void *)buffer + 22) = v15;
            v96.int location = *((void *)buffer + 19) + v21;
            v96.CFIndex length = v15 - v21;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v96, buffer);
            int v20 = *((void *)buffer + 21);
          }

          unint64_t v18 = buffer[v16 - v20];
        }
      }

      if (v18 >> 10 != 54) {
        break;
      }
      unint64_t v13 = v13 + (v18 << 10) - 56613888;
      uint64_t v22 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
      if (v7 == 1)
      {
        unsigned int v7 = 0LL;
        goto LABEL_69;
      }

      BitmapPtrForPlane = v22;
      if (v22)
      {
LABEL_32:
        BOOL v23 = (*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v13 >> 3)) >> (v13 & 7)) & 1;
        goto LABEL_33;
      }

    if (!a1) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  unsigned int v6 = 0;
  unsigned int v7 = 0;
  if (a1) {
    goto LABEL_8;
  }
LABEL_9:
  if (a2) {
    *a2 = v7;
  }
  return result;
}

  uint64_t v11 = (NSEnumerator *)state->extra[1];
LABEL_11:
  state->itemsPtr = buffer;
  unint64_t v13 = state->extra[0];
  if (v13 - v10 >= len) {
    uint64_t v14 = len;
  }
  else {
    uint64_t v14 = v13 - v10;
  }
  if (v14)
  {
    size_t v15 = 0LL;
    while (1)
    {
      unint64_t v16 = -[NSEnumerator nextObject](v11, "nextObject");
      if (!v16) {
        break;
      }
      buffer[v15++] = v16;
      if (v14 == v15)
      {
        uint64_t v10 = state->state;
        goto LABEL_19;
      }
    }

    uint64_t v17 = -1LL;
  }

  else
  {
LABEL_19:
    uint64_t v17 = v10 + v14;
    if (v13 <= v17) {
      uint64_t v17 = -1LL;
    }
    size_t v15 = v14;
  }

  state->state = v17;
  return v15;
}

  uint64_t v11 = (NSEnumerator *)a3->var3[1];
LABEL_11:
  a3->var1 = a4;
  unint64_t v13 = a3->var3[0];
  if (v13 - var0 >= a5) {
    uint64_t v14 = a5;
  }
  else {
    uint64_t v14 = v13 - var0;
  }
  if (v14)
  {
    size_t v15 = 0LL;
    while (1)
    {
      unint64_t v16 = -[NSEnumerator nextObject](v11, "nextObject");
      if (!v16) {
        break;
      }
      a4[v15++] = v16;
      if (v14 == v15)
      {
        var0 = a3->var0;
        goto LABEL_19;
      }
    }

    uint64_t v17 = -1LL;
  }

  else
  {
LABEL_19:
    uint64_t v17 = var0 + v14;
    if (v13 <= v17) {
      uint64_t v17 = -1LL;
    }
    size_t v15 = v14;
  }

  a3->var0 = v17;
  return v15;
}

  unsigned int v6 = atomic_load(&CFBasicHashCallBackPtrsCount);
  if (v6 < 1024)
  {
    unsigned int v7 = atomic_load(&CFBasicHashCallBackPtrsCount);
    uint64_t v8 = atomic_load((unsigned int *)&CFBasicHashCallBackPtrsCapacity);
    if (v7 == v8)
    {
      unint64_t v9 = malloc(0x100uLL);
      uint64_t v10 = atomic_load(&CFBasicHashCallBackPtrsCount);
      CFBasicHashCallBackPtrs[v10 / 32] = (uint64_t)v9;
      do
        unsigned int v7 = __ldaxr((unsigned int *)&CFBasicHashCallBackPtrsCapacity);
      while (__stlxr(v7 + 32, (unsigned int *)&CFBasicHashCallBackPtrsCapacity));
    }

    do
      unsigned int v4 = __ldaxr(&CFBasicHashCallBackPtrsCount);
    while (__stlxr(v4 + 1, &CFBasicHashCallBackPtrsCount));
    *(void *)(CFBasicHashCallBackPtrs[(int)v4 / 32] + 8LL * (int)(v4 - (v7 & 0xFFFFFFE0))) = a1;
LABEL_13:
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBasicHashCallBackPtrsLock);
    return v4;
  }

  __break(1u);
  return result;
}

    if ((unint64_t)v2 >= v1)
    {
      size_t v12 = 0LL;
      goto LABEL_36;
    }
  }

  size_t v12 = 1LL;
LABEL_36:
  *(void *)(a1 + 8) = v2;
  return v12;
}

__n128 cow_copy_instance(uint64_t a1, int a2, uint64_t a3, int a4)
{
  unsigned int v4 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  if (a2 == 1) {
    uint64_t v5 = &OBJC_IVAR_____NSArrayM_cow;
  }
  else {
    uint64_t v5 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  }
  if (a2 == 1) {
    unsigned int v6 = &OBJC_IVAR_____NSArrayM_storage;
  }
  else {
    unsigned int v6 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  uint64_t v8 = (__n128 *)(a1 + *v6);
  if (a4 == 1)
  {
    unsigned int v4 = &OBJC_IVAR_____NSArrayM_cow;
    unint64_t v9 = &OBJC_IVAR_____NSArrayM_storage;
  }

  else
  {
    unint64_t v9 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  }

  atomic_store(v7, (unint64_t *)(a3 + *v4));
  uint64_t v10 = *v9;
  unint64_t v11 = v8[1].n128_u64[0];
  __n128 result = *v8;
  unint64_t v13 = (__n128 *)(a3 + v10);
  *unint64_t v13 = *v8;
  v13[1].n128_u64[0] = v11;
  return result;
}

uint64_t cow_copy_storage(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(char **)(a1 + 16);
  if (!v3)
  {
    unsigned int v6 = 0LL;
LABEL_21:
    uint64_t result = 1LL;
    goto LABEL_22;
  }

  uint64_t v4 = *(unsigned int *)(a1 + 28);
  uint64_t result = (uint64_t)malloc(8 * v4);
  unsigned int v6 = (char *)result;
  if (result)
  {
    unsigned int v7 = *(_DWORD *)(v2 + 20);
    uint64_t v8 = *(unsigned int *)(v2 + 8);
    unsigned int v9 = v4 - v8;
    else {
      uint64_t v10 = v9;
    }
    if ((_DWORD)v10)
    {
      unint64_t v11 = (id *)(result + 8 * v8);
      memcpy(v11, &v3[8 * v8], 8LL * v10);
      uint64_t v12 = v10;
      do
      {
        ++v11;
        --v12;
      }

      while (v12);
    }

    if (v7 > v9)
    {
      memcpy(v6, v3, 8LL * (v7 - v10));
      uint64_t v14 = 0LL;
      else {
        uint64_t v15 = v7 - v10;
      }
      uint64_t v16 = 8 * v15;
      do
      {
        unint64_t v17 = *(void *)&v6[v14];
        if ((v17 & 0x8000000000000000LL) == 0) {
          id v18 = (id)v17;
        }
        v14 += 8LL;
      }

      while (v16 != v14);
    }

    goto LABEL_21;
  }

LABEL_22:
  *(void *)(a1 + 16) = v6;
  return result;
}

      uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x1FuLL, 208LL, 0LL, v19, v20, v21, v22);
      if (!Instance)
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          _CFBundleCreate_cold_3();
        }
        return 0LL;
      }

      uint64_t v16 = (void *)Instance;
      *(void *)(Instance + 16) = v9;
      *(_BYTE *)(Instance + 53) = v23;
      *(_DWORD *)(Instance + 48) = 0;
      *(_BYTE *)(Instance + 54) = v10;
      *(_BYTE *)(Instance + 55) = v15;
      *(_DWORD *)(Instance + 96) = 0;
      *(_DWORD *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 176) = 0;
      uint64_t v25 = CFURLCopyAbsoluteURL(v9);
      v16[24] = CFURLCopyFileSystemPath(v25, kCFURLPOSIXPathStyle);
      CFRelease(v25);
      *((_DWORD *)v16 + 50) = 0;
      if (a4) {
        _CFBundleLoadLimitedInfoDictionary((uint64_t)v16, a4);
      }
      InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v16);
      Identifier = CFBundleGetIdentifier((CFBundleRef)v16);
      __dmb(0xBu);
      if ((v13 & 1) != 0)
      {
        int64_t v28 = (__CFString *)Identifier;
        os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
        uint64_t v29 = _CFBundleCopyFromTablesForURLLocked((void *)v16[2]);
        if (v29)
        {
          int64_t v30 = v29;
          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          return v30;
        }

        char v33 = _CFBundleGetFromTablesLocked(v28);
        if (!v33
          || (uint64_t v34 = v33,
              unsigned int v35 = (const __CFString *)*((void *)v33 + 24),
              !CFStringGetFileSystemRepresentation((CFStringRef)v16[24], buffer, 1024LL))
          || !CFStringGetFileSystemRepresentation(v35, v49, 1024LL))
        {
LABEL_59:
          if ((v46 & 1) != 0 || (*(void *)int64_t v49 = 0LL, _CFBundleInitPlugIn(v16, InfoDictionary, v49)))
          {
            if ((v17 & 1) == 0) {
              _CFBundleAddToTablesLocked((const void **)v16, v28);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
            if ((v46 & 1) == 0) {
              _CFPlugInHandleDynamicRegistration((__CFBundle *)v16);
            }
            return v16;
          }

          Value = CFDictionaryGetValue(InfoDictionary, @"CFPlugInFactories");
          if (Value)
          {
            CFIndex v42 = Value;
            uint64_t v43 = CFGetTypeID(Value);
            if (v43 == CFDictionaryGetTypeID()) {
              int64_t v44 = v42;
            }
            else {
              int64_t v44 = 0LL;
            }
          }

          else
          {
            int64_t v44 = 0LL;
          }

          if (_CFBundleLoadingLogger_onceToken != -1) {
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
          }
          uint64_t v45 = (os_log_s *)_CFBundleLoadingLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buffer = 138543874;
            uint64_t v51 = v44;
            int64_t v52 = 2114;
            int64_t v53 = v16;
            int v54 = 2114;
            CFIndex v55 = *(CFURLRef *)v49;
            _os_log_error_impl( &dword_180A4C000,  v45,  OS_LOG_TYPE_ERROR,  "More than one bundle with the same factory UUID detected: %{public}@ in %{public}@ and %{public}@",  (uint8_t *)buffer,  0x20u);
          }

          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          UniChar v31 = *(CFURLRef *)v49;
          if (!*(void *)v49) {
            return 0LL;
          }
LABEL_39:
          CFRelease(v31);
          return 0LL;
        }

        int v36 = open(buffer, 0);
        CFIndex v37 = open(v49, 0);
        uint64_t v38 = v37;
        if (v36 < 1 || v37 < 1)
        {
          CFIndex v39 = 0;
          int64_t v40 = 0;
          if (v36 < 1)
          {
LABEL_55:
            if (v38 >= 1) {
              close(v38);
            }
            if (v40)
            {
              os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
              CFRelease(v16);
              return CFRetain(v34);
            }

            goto LABEL_59;
          }
        }

        else
        {
          CFIndex v39 = !fstat(v36, &v48) && !fstat(v38, &v47) && v48.st_dev == v47.st_dev && v48.st_ino == v47.st_ino;
        }

        close(v36);
        int64_t v40 = v39;
        goto LABEL_55;
      }

      if ((v17 & 1) == 0) {
        _CFBundleCreate_cold_4();
      }
      return v16;
    default:
      id v13 = 1;
      uint64_t v14 = 1;
      uint64_t v15 = 0;
      goto LABEL_14;
  }

      int v20 = atomic_load(v11);
      if ((v20 & 8) != 0) {
        goto LABEL_75;
      }
      int v21 = *((void *)theSet + 5);
      if (!v21 || !*(_DWORD *)(v21 + 8) && !*(_BYTE *)(v21 + 13))
      {
        uint64_t v22 = atomic_load(v11);
        switch((v22 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((void *)theSet + 4)) {
              goto LABEL_28;
            }
            break;
          case 3u:
          case 4u:
            if (*((void *)theSet + 3)) {
              goto LABEL_28;
            }
            break;
          default:
            goto LABEL_28;
        }

        uint64_t v63 = atomic_load(v11);
        while (1)
        {
          int v64 = __ldaxr(v11);
          if (v64 != v63) {
            break;
          }
          if (__stlxr(v63 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v11)) {
            goto LABEL_89;
          }
          int v65 = 1;
LABEL_90:
          uint64_t v63 = v64;
          if (v65)
          {
            *((_DWORD *)theSet + 6) = location;
            *((void *)theSet + 4) = length;
            uint64_t v66 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              int v67 = __ldaxr(v11);
              if (v67 != v66) {
                break;
              }
              if (__stlxr(v66 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
                goto LABEL_96;
              }
              int v68 = 1;
LABEL_97:
              uint64_t v66 = v67;
              if ((v68 & 1) != 0) {
                return;
              }
            }

            __clrex();
LABEL_96:
            int v68 = 0;
            goto LABEL_97;
          }
        }

        __clrex();
LABEL_89:
        int v65 = 0;
        goto LABEL_90;
      }

      int v20 = atomic_load(v11);
      if ((v20 & 8) == 0) {
        goto LABEL_23;
      }
      CFIndex v37 = *((void *)theSet + 5);
      if (!v37 || !*(_DWORD *)(v37 + 8) && !*(_BYTE *)(v37 + 13))
      {
        uint64_t v38 = atomic_load(v11);
        switch((v38 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((void *)theSet + 4)) {
              goto LABEL_47;
            }
            break;
          case 3u:
          case 4u:
            if (*((void *)theSet + 3)) {
              goto LABEL_47;
            }
            break;
          default:
            goto LABEL_47;
        }

        CFIndex v93 = atomic_load(v11);
        while (1)
        {
          int64_t v94 = __ldaxr(v11);
          if (v94 != v93) {
            break;
          }
          if (__stlxr(v93 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v11)) {
            goto LABEL_137;
          }
          int64_t v95 = 1;
LABEL_138:
          CFIndex v93 = v94;
          if (v95)
          {
            *((_DWORD *)theSet + 6) = location;
            *((void *)theSet + 4) = length;
            CFRange v96 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              v97 = __ldaxr(v11);
              if (v97 != v96) {
                break;
              }
              if (__stlxr(v96 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
                goto LABEL_144;
              }
              v98 = 1;
LABEL_145:
              CFRange v96 = v97;
              if ((v98 & 1) != 0) {
                return;
              }
            }

            __clrex();
LABEL_144:
            v98 = 0;
            goto LABEL_145;
          }
        }

        __clrex();
LABEL_137:
        int64_t v95 = 0;
        goto LABEL_138;
      }

    __key[0] = v8;
    unint64_t v11 = (char **)bsearch( __key,  localeStringRegionToDefaults,  5uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey);
    if (v11) {
      _RemoveSubstringsIfPresent(buffer, v11[1]);
    }
    goto LABEL_24;
  }

  __strlcpy_chk();
  v16[0] = 0;
LABEL_26:
  _AppendKeyValueString((uint64_t)buffer, v16);
  _AppendKeyValueString((uint64_t)buffer, v17);
  return CFStringCreateWithCString(allocator, buffer, 0x600u);
}

    ;
  }

  switch(*i)
  {
    case 'D':
      v3 |= 0x10000uLL;
      goto LABEL_22;
    case 'E':
    case 'c':
      v3 |= 0x200uLL;
      goto LABEL_22;
    case 'F':
      v3 |= 0x400uLL;
      goto LABEL_22;
    case 'G':
      v3 |= 2uLL;
      goto LABEL_22;
    case 'H':
      v3 |= 0x20uLL;
      goto LABEL_22;
    case 'I':
    case 'J':
    case 'K':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'V':
    case 'X':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '_':
    case 'a':
    case 'b':
      goto LABEL_22;
    case 'L':
    case 'M':
      goto LABEL_7;
    case 'Q':
      v3 |= 0x800uLL;
      goto LABEL_22;
    case 'U':
      goto LABEL_6;
    case 'W':
      v3 |= 0x1000uLL;
      goto LABEL_22;
    case 'Y':
      v3 |= 0x4000uLL;
      goto LABEL_22;
    case '^':
      goto LABEL_8;
    case 'd':
      v3 |= 0x10uLL;
      goto LABEL_22;
    default:
      if (*i == 35)
      {
        v3 |= 0x8000uLL;
        goto LABEL_22;
      }

      if (*i) {
        goto LABEL_22;
      }
      uint64_t v5 = -[__CFCalendar components:fromDate:]( calendar,  "components:fromDate:",  v3,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
      if (v5)
      {
        unsigned int v6 = *vars8;
        if (*vars8)
        {
          unsigned int v7 = (void *)v5;
          uint64_t v8 = vars8 + 1;
          while (2)
          {
            unsigned int v9 = va_arg(v13, _DWORD *);
            switch(v6)
            {
              case 'D':
                uint64_t v10 = [v7 dayOfYear];
                goto LABEL_46;
              case 'E':
              case 'c':
                uint64_t v10 = [v7 weekday];
                goto LABEL_46;
              case 'F':
                uint64_t v10 = [v7 weekdayOrdinal];
                goto LABEL_46;
              case 'G':
                uint64_t v10 = [v7 era];
                goto LABEL_46;
              case 'H':
                uint64_t v10 = [v7 hour];
                goto LABEL_46;
              case 'I':
              case 'J':
              case 'K':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'V':
              case 'X':
              case 'Z':
              case '[':
              case '\\':
              case ']':
              case '_':
              case 'a':
              case 'b':
                goto LABEL_47;
              case 'L':
              case 'M':
                uint64_t v10 = [v7 month];
                goto LABEL_46;
              case 'Q':
                uint64_t v10 = [v7 quarter];
                goto LABEL_46;
              case 'U':
LABEL_29:
                uint64_t v10 = objc_msgSend(v7, "year", v13);
                goto LABEL_46;
              case 'W':
                uint64_t v10 = [v7 weekOfMonth];
                goto LABEL_46;
              case 'Y':
                uint64_t v10 = [v7 yearForWeekOfYear];
                goto LABEL_46;
              case '^':
LABEL_31:
                *unsigned int v9 = objc_msgSend(v7, "weekOfYear", v13);
                if ([v7 weekOfYear] != 0x7FFFFFFFFFFFFFFFLL) {
                  goto LABEL_47;
                }
                uint64_t v10 = [v7 week];
LABEL_46:
                *unsigned int v9 = v10;
LABEL_47:
                unint64_t v11 = *v8++;
                unsigned int v6 = v11;
                if (!v11) {
                  break;
                }
                continue;
              case 'd':
                uint64_t v10 = [v7 day];
                goto LABEL_46;
              default:
                switch(v6)
                {
                  case 'l':
                    uint64_t v10 = [v7 isLeapMonth];
                    goto LABEL_46;
                  case 'm':
                    uint64_t v10 = [v7 minute];
                    goto LABEL_46;
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'x':
                    goto LABEL_47;
                  case 'r':
                  case 'y':
                    goto LABEL_29;
                  case 's':
                    uint64_t v10 = [v7 second];
                    goto LABEL_46;
                  case 'w':
                    goto LABEL_31;
                  default:
                    if (v6 != 35) {
                      goto LABEL_47;
                    }
                    uint64_t v10 = [v7 nanosecond];
                    break;
                }

                goto LABEL_46;
            }

            break;
          }
        }

        LOBYTE(v5) = 1;
      }

      return v5;
  }

      uint64_t v12 = *(unsigned __int8 *)v10++;
      unsigned int v9 = v12;
    }

    while (v12);
  }

  id v13 = (void *)-[__CFCalendar dateByAddingComponents:toDate:options:]( calendar,  "dateByAddingComponents:toDate:options:",  v8,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *at,  v16),  options);

  if (!v13) {
    return 0;
  }
  [v13 timeIntervalSinceReferenceDate];
  *(void *)at = v14;
  return 1;
}

  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
}

        if (!v24 || ((*(unsigned __int8 *)(v24 + ((unsigned __int16)v23 >> 3)) >> (v23 & 7)) & 1) == 0)
        {
          a2 = v17;
          id v18 = v160;
          goto LABEL_208;
        }

        goto LABEL_35;
      }

      if (v182 <= v25 || (int64_t v136 = v181, v181 > v25))
      {
        UniChar v137 = v17 - 3;
        if (v17 < 3) {
          UniChar v137 = 0LL;
        }
        CFIndex v181 = v137;
        char v182 = v26;
        v194.int location = v179 + v137;
        v194.CFIndex length = v26 - v137;
        CFStringGetCharacters(theString, v194, buffer);
        int64_t v136 = v181;
      }

      int64_t v28 = v25 - v136;
      int64_t v27 = buffer;
    }

    uint64_t v29 = v27[v28];
    goto LABEL_286;
  }

  return a2;
}

  int v21 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  uint64_t v22 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (2)
  {
    BOOL v23 = (uint64_t)(0x8E38E38E38E38E39LL * (v21 - v22)) >> 1;
    int v24 = &v22[9 * v23];
    uint64_t v25 = *v24;
    if (v25 > v15)
    {
      int v21 = v24 - 9;
      goto LABEL_28;
    }

    if (v25 + 8 <= v15)
    {
      uint64_t v22 = v24 + 9;
LABEL_28:
      if (v22 > v21) {
        goto LABEL_38;
      }
      continue;
    }

    break;
  }

  int64_t v27 = v22[9 * v23 + 1 + (int)(v15 - v25)];
  if ((_WORD)v27) {
    int64_t v28 = (unsigned __int16)v27 == 65533;
  }
  else {
    int64_t v28 = 1;
  }
  if (!v28)
  {
    if (a5)
    {
      if (v11 + 2 > a5) {
        goto LABEL_159;
      }
      *(_WORD *)a4 = bswap32(v27) >> 16;
      a4 += 2;
    }

    v11 += 2LL;
    goto LABEL_41;
  }

  if (!v19)
  {
    int64_t v30 = 0;
    int64_t v27 = 0LL;
    goto LABEL_521;
  }

  UniChar v140 = (_DWORD *)((char *)v19 + 257);
  __s1 = (char *)v19;
  uint64_t v146 = v20;
  if (v20 < 4)
  {
    int64_t v30 = 0;
LABEL_43:
    int64_t v27 = 0LL;
    goto LABEL_44;
  }

  int64_t v141 = v18;
  uint64_t v25 = 0LL;
  uint64_t v26 = *(_DWORD *)v19;
  int64_t v27 = (char *)&__CFBundleMagicNumbersArray[62] + 3;
  int64_t v28 = bswap32(*(_DWORD *)v19);
  do
  {
    uint64_t v29 = __CFBundleMagicNumbersArray[v25];
    v27 += 5;
    if (v29 == v28) {
      break;
    }
    v107 = v25++ >= 0x3F;
  }

  while (!v107);
  if (v29 != v28)
  {
    int64_t v30 = 0;
    int64_t v27 = 0LL;
LABEL_30:
    id v19 = (unsigned __int16 *)__s1;
    goto LABEL_31;
  }

  if (v26 == -1095041334 && v20 >= 8 && *((_WORD *)__s1 + 2))
  {
    int64_t v30 = 0;
    int64_t v27 = "class";
LABEL_142:
    id v19 = (unsigned __int16 *)__s1;
    goto LABEL_425;
  }

  if (v20 < 32) {
    goto LABEL_216;
  }
  if (a3) {
    CFIndex v60 = (BOOL *)&v147;
  }
  else {
    CFIndex v60 = 0LL;
  }
  *(void *)buffer = 0LL;
  if (a3) {
    uint64_t v147 = 0;
  }
  if (a5) {
    *a5 = 0LL;
  }
  if (a6) {
    *a6 = 0LL;
  }
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  if (v26 > -17958195)
  {
    if (v26 > 561606473)
    {
      if (v26 == 561606474 || v26 == 1248819489)
      {
        int64_t v27 = "pef";
        int64_t v30 = 4096;
LABEL_505:
        id v19 = (unsigned __int16 *)__s1;
LABEL_506:
        if (!a3) {
          goto LABEL_526;
        }
        goto LABEL_507;
      }

      goto LABEL_216;
    }

    if (v26 != -17958194)
    {
      if (v26 != -17958193) {
        goto LABEL_216;
      }
      v129 = v60;
      int64_t v134 = -17958193;
      v139 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = *((_DWORD *)__s1 + 1);
      if (a5)
      {
        int64_t v133 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(void *)buffer = v133;
      }

      else
      {
        int64_t v133 = 0LL;
      }

      if (a3 && v139 == 2) {
        const char *v129 = _CFBundleGrokX11FromFile(v18, (uint64_t)__s1, v146, 0, 0, 1);
      }
      if (a6) {
        *a6 = _CFBundleCreateInfoDictFromFile(v18, (UInt8 *)__s1, v146, 0, 0, 1);
      }
      if (a7 || a8 || a10)
      {
        CFIndex v127 = a10;
        uint64_t v109 = v18;
        uint64_t v110 = (uint64_t)__s1;
        UniChar v111 = v146;
        uint64_t v112 = 0;
LABEL_465:
        uint64_t v113 = 1;
LABEL_487:
        _CFBundleGrokObjcImageInfoFromFile(v109, v110, v111, 0, v112, v113, a7, a8, v127);
      }

    int v20 = _os_log_pack_size();
    int v21 = (char *)v40 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int64_t v30 = _os_log_pack_fill();
    UniChar v31 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v30,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inArray:range:]",  v10,  v9,  v13 - 1);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v31,  "-[NSMutableArray removeObjectsInRange:inArray:range:]",  v10,  v9,  v13 - 1);
    goto LABEL_23;
  }

  if (a4 && (_NSIsNSArray((uint64_t)a4) & 1) == 0)
  {
    uint64_t v10 = _os_log_pack_size();
    unsigned int v9 = (NSUInteger)v40 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int64_t v28 = _os_log_pack_fill();
    *(_DWORD *)int64_t v28 = 136315138;
    *(void *)(v28 + 4) = "-[NSMutableArray removeObjectsInRange:inArray:range:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: array argument is not an NSArray",  "-[NSMutableArray removeObjectsInRange:inArray:range:]");
    uint64_t v29 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v9,  v10);
    objc_exception_throw(v29);
    goto LABEL_22;
  }

  uint64_t v14 = [a4 count];
  uint64_t v15 = v14;
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v14 < location + length)
  {
    if (v14)
    {
      int v24 = _os_log_pack_size();
      uint64_t v25 = (char *)v40 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unsigned int v35 = _os_log_pack_fill();
      int v36 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v35,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inArray:range:]",  location,  length,  v15 - 1);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v36,  "-[NSMutableArray removeObjectsInRange:inArray:range:]",  location,  length,  v15 - 1);
    }

    else
    {
      int v24 = _os_log_pack_size();
      uint64_t v25 = (char *)v40 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v26 = _os_log_pack_fill();
      int64_t v27 = __os_log_helper_1_2_3_8_32_8_0_8_0( v26,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inArray:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v27,  "-[NSMutableArray removeObjectsInRange:inArray:range:]",  location,  length);
    }

    uint64_t v32 = _CFAutoreleasePoolAddObject();
    char v33 = v25;
    uint64_t v34 = v24;
    goto LABEL_26;
  }

  uint64_t v16 = (void *)_CFAutoreleasePoolPush();
  unint64_t v17 = +[NSSet setWithArray:range:copyItems:]( &OBJC_CLASS___NSSet,  "setWithArray:range:copyItems:",  a4,  location,  length,  0LL);
  if (v9)
  {
    id v18 = v17;
    id v19 = v9 - 1;
    do
    {
      if (-[NSSet containsObject:]( v18,  "containsObject:",  -[NSArray objectAtIndex:](self, "objectAtIndex:", v10 + v19)))
      {
        -[NSMutableArray removeObjectAtIndex:](self, "removeObjectAtIndex:", v19);
      }

      --v19;
    }

    while (v19 != -1LL);
  }

  _CFAutoreleasePoolPop(v16);
}

    uint64_t v26 = v12;
    uint64_t v15 = _os_log_pack_size();
    uint64_t v16 = (char *)v38 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int64_t v27 = _os_log_pack_fill();
    int64_t v28 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v27,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  v10,  v9,  --v26);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v28,  "-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  v10,  v9,  v26);
    goto LABEL_23;
  }

  if (a4 && (_NSIsNSOrderedSet((uint64_t)a4) & 1) == 0)
  {
    BOOL v23 = _os_log_pack_size();
    uint64_t v10 = (NSUInteger)v38;
    int v24 = _os_log_pack_fill();
    *(_DWORD *)int v24 = 136315138;
    *(void *)(v24 + 4) = "-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: ordered set argument is not an NSOrderedSet",  "-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]");
    uint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v23);
    objc_exception_throw(v25);
    goto LABEL_22;
  }

  id v13 = [a4 count];
  if ((location & 0x8000000000000000LL) != 0 || (length & 0x8000000000000000LL) != 0 || v13 < location + length)
  {
    if (v13)
    {
      uint64_t v32 = v13;
      id v19 = _os_log_pack_size();
      int v20 = (char *)v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      char v33 = _os_log_pack_fill();
      uint64_t v34 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v33,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  location,  length,  --v32);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v34,  "-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  location,  length,  v32);
    }

    else
    {
      id v19 = _os_log_pack_size();
      int v20 = (char *)v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v21 = _os_log_pack_fill();
      uint64_t v22 = __os_log_helper_1_2_3_8_32_8_0_8_0( v21,  (uint64_t)"-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  location,  length);
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v22,  "-[NSMutableArray removeObjectsInRange:inOrderedSet:range:]",  location,  length);
    }

    uint64_t v29 = _CFAutoreleasePoolAddObject();
    int64_t v30 = v20;
    UniChar v31 = v19;
    goto LABEL_26;
  }

  if (v9)
  {
    uint64_t v14 = v9 - 1;
    do
    {
      if (objc_msgSend( a4,  "containsObject:inRange:",  -[NSArray objectAtIndex:](self, "objectAtIndex:", v10 + v14),  location,  length)) {
        -[NSMutableArray removeObjectAtIndex:](self, "removeObjectAtIndex:", v14);
      }
      --v14;
    }

    while (v14 != -1LL);
  }

  if (!self->_managed || CFPreferencesIsManaged(-[CFPDSource user](self, "user"), self->_managedUsesContainer))
  {
    os_unfair_lock_lock(&self->_writeLock);
    if (self->_parentFD == -1)
    {
      -[CFPDSource cacheFileInfo](self, "cacheFileInfo");
      if (self->_parentFD == -1) {
        goto LABEL_39;
      }
    }

    actualPath = self->_actualPath;
    int v20 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(void *)&buf.st_dev = MEMORY[0x1895F87A8];
      buf.st_ino = 3221225472LL;
      *(void *)&buf.st_uid = __DEBUG_CACHE_MISS_block_invoke;
      *(void *)&buf.st_rdev = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
      buf.st_atimespec.tv_sec = (__darwin_time_t)actualPath;
      _extractCFPDBits(0LL, 0LL, self, (uint64_t)&buf);
    }

    int v21 = *((_BYTE *)self + 142);
    if ((v21 & 8) == 0)
    {
      if (!strstr(self->_actualPath, "Preferences/"))
      {
        uint64_t v22 = -[CFPDSource copyUncanonicalizedPath](self, "copyUncanonicalizedPath");
        if (v22
          && (BOOL v23 = v22,
              v45.CFIndex length = CFStringGetLength(v22),
              v45.int location = 0LL,
              int v24 = CFStringFindWithOptions(v23, @"Preferences/", v45, 0LL, 0LL),
              CFRelease(v23),
              v24))
        {
          int v21 = *((_BYTE *)self + 142);
        }

        else
        {
          int v21 = *((_BYTE *)self + 142) | 4;
        }
      }

      *((_BYTE *)self + 142) = v21 | 8;
    }

    uint64_t v25 = -[CFPDSource openActualPath]((uint64_t)self);
    if ((v25 & 0x80000000) != 0)
    {
LABEL_39:
      os_unfair_lock_unlock(&self->_writeLock);
    }

    else
    {
      uint64_t v26 = v25;
      int64_t v27 = !self->_managed && (*((_BYTE *)self + 142) & 4) == 0;
      uint64_t v16 = +[CFPDDataBuffer newBufferFromFile:allowMappingIfSafe:]( &OBJC_CLASS___CFPDDataBuffer,  "newBufferFromFile:allowMappingIfSafe:",  v25,  v27);
      if (v16)
      {
        int64_t v28 = fstat(v26, &buf);
        if (v28) {
          st_uid = 0;
        }
        else {
          st_uid = buf.st_uid;
        }
        if (v28) {
          st_mode = 0;
        }
        else {
          st_mode = buf.st_mode;
        }
        -[CFPDSource setPlist:owner:mode:]((uint64_t)self, v16, st_uid, st_mode);

        if (v7)
        {
          UniChar v31 = -[CFPDDataBuffer validatePlist](v16, "validatePlist");
          uint64_t v32 = (os_log_s *)_CFPrefsDaemonLog();
          char v33 = v32;
          if (v31)
          {
            if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
            {
              unsigned int v35 = self->_userName;
              uint64_t v34 = self->_domain;
              *(_DWORD *)CFIndex v39 = 138412546;
              int64_t v40 = v34;
              int64_t v41 = 2112;
              CFIndex v42 = v35;
              _os_log_impl( &dword_180A4C000,  v33,  OS_LOG_TYPE_INFO,  "Validation of plist read from disk succeeded. {%@ %@}",  v39,  0x16u);
            }
          }

          else
          {
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              -[CFPDSource copyPropertyListWithoutDrainingPendingChangesValidatingPlist:andReturnFileUID:andMode:].cold.2();
            }
            unlinkat(self->_parentFD, self->_fileName, 0);
            -[CFPDSource clearCacheForReason:](self, "clearCacheForReason:", @"plist on disk is invalid");
            uint64_t v16 = 0LL;
          }
        }

        else
        {
          int v36 = self->_plist;
          v37[0] = MEMORY[0x1895F87A8];
          v37[1] = 3221225472LL;
          v37[2] = __100__CFPDSource_copyPropertyListWithoutDrainingPendingChangesValidatingPlist_andReturnFileUID_andMode___block_invoke_59;
          v37[3] = &unk_18999B4C8;
          v37[4] = self;
          -[CFPDDataBuffer quicklyValidatePlistAndOnFailureInvokeBlock:]( v36,  "quicklyValidatePlistAndOnFailureInvokeBlock:",  v37);
        }
      }

      else
      {
        -[CFPDSource setPlist:owner:mode:]((uint64_t)self, 0LL, 0, 0);
      }

      close(v26);
      os_unfair_lock_unlock(&self->_writeLock);
      if (v16) {
        goto LABEL_16;
      }
    }

    if (a4) {
      *a4 = self->_lastEuid;
    }
    if (!a5)
    {
      uint64_t v16 = 0LL;
      return v16;
    }

    unint64_t v17 = 384;
    if ((*((_BYTE *)self + 142) & 0x10) != 0)
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      uint64_t v16 = 0LL;
      if (CFEqual(self->_userName, @"kCFPreferencesAnyUser")) {
        unint64_t v17 = 420;
      }
      else {
        unint64_t v17 = 384;
      }
    }

uint64_t cow_set_cow(uint64_t result, unint64_t a2)
{
  return result;
}

uint64_t ___deque_enumerateObjectsWithOptionsBlock_block_invoke(uint64_t a1)
{
  return __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(*(void *)(a1 + 32));
}

uint64_t (**__CFStringEncodingGetVietnameseConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_0) {
    __CFStringEncodingPrecomposeLatinCharacter_0 = (_UNKNOWN *)a2(4LL);
  }
  if (a1 == 1288) {
    return __CFConverterWindowsVietnamese;
  }
  else {
    return 0LL;
  }
}

uint64_t __CFToWindowsVietnamese(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
  unsigned int v6 = (unsigned __int16 *)&unk_180C32BF8;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    unsigned int v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromWindowsVietnamese(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsVietnamese_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsVietnamesePrecompose( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_0(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      unint64_t v11 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180C32BF8;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          unint64_t v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

LABEL_2:
  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

            LOBYTE(v5) = 0;
            return v5;
          }

          uint64_t v22 = *(void *)(v7 + 40);
          if (!v22 || !*(_BYTE *)(v22 + 13) || *((_DWORD *)v20 + 6)) {
            goto LABEL_88;
          }
          id v18 = v20[4] == 0x10000LL;
        }

        else
        {
          id v18 = *(_BYTE *)(v19 + 13) == 0;
        }
      }

      else
      {
        uint64_t v26 = atomic_load((unint64_t *)(v7 + 8));
        int64_t v27 = (v26 >> 4) & 7;
        if (v27 != 4 && v27 != 3)
        {
          if (v27 == 2 && !*(void *)(v7 + 32)) {
            return v5;
          }
          goto LABEL_88;
        }

        id v18 = *(void *)(v7 + 24) == 0LL;
      }
    }

    else
    {
      uint64_t v5 = *(void *)(v7 + 24);
      if (v5 == 1)
      {
        if (v6 == 14 || (v4 & 8) != 0) {
          return v5;
        }
        LODWORD(v5) = 1;
      }

      else
      {
        if (v5 < 4 || v5 == 15)
        {
          if (v6) {
            id v18 = v10 == 0;
          }
          else {
            id v18 = 0;
          }
          goto LABEL_65;
        }

        BOOL v23 = v10 >> 3;
        if (v5 == 12)
        {
          if ((_DWORD)v23) {
            int v24 = v6 - 14 >= 0xFFFFFFFFFFFFFFF5LL;
          }
          else {
            int v24 = 0;
          }
          LOBYTE(v5) = !v24;
          return v5;
        }

        if ((_DWORD)v23) {
          goto LABEL_88;
        }
      }

      id v18 = CFUniCharGetBitmapPtrForPlane(v5, v6) == 0;
    }

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

    *a3 = a2;
    return 1LL;
  }

  uint64_t result = 0LL;
  if (a2 != 161 && a2 != 165) {
    goto LABEL_16;
  }
  return result;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return 2LL;
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return v16[0];
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return v16[0];
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return v16[0];
}

  if (!(_BYTE)v9) {
    return 0LL;
  }
  if (a5) {
    *a4 = v9;
  }
  *a6 = 1LL;
  return v16[0];
}

uint64_t __CFIsValidCombiningCharacterForVietnamese(int a1)
{
  else {
    return (__CFVietnameseCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

void __CFBinaryHeapDeallocate(uint64_t a1)
{
  uint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  CFBinaryHeapRemoveAllValues((CFBinaryHeapRef)a1);
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0xC) == 4LL) {
    CFAllocatorDeallocate(v2, *(void **)(a1 + 112));
  }
}

uint64_t __CFBinaryHeapEqual(__CFBinaryHeap *heap, __CFBinaryHeap *a2)
{
  v14[128] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *((void *)heap + 2);
  if (v2 != *((void *)a2 + 2)) {
    return 0LL;
  }
  uint64_t v5 = (uint64_t (*)(void))*((void *)heap + 8);
  if (!v2) {
    return 1LL;
  }
  if (v2 >= 129)
  {
    uint64_t v8 = (void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 16 * v2, 0LL);
    BOOL v7 = v8 != values;
    if (__CFOASafe) {
      BOOL v9 = v8 == values;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      __CFSetLastAllocationEventName();
      BOOL v7 = 1;
    }
  }

  else
  {
    BOOL v7 = 0;
    uint64_t v8 = values;
  }

  if (v2 >= 129) {
    uint64_t v10 = (const void **)&v8[v2];
  }
  else {
    uint64_t v10 = (const void **)v14;
  }
  CFBinaryHeapGetValues(heap, (const void **)v8);
  CFBinaryHeapGetValues(a2, v10);
  if (v2 < 1)
  {
LABEL_22:
    if (v7)
    {
      uint64_t v12 = CFGetAllocator(heap);
      CFAllocatorDeallocate(v12, v8);
    }

    return 1LL;
  }

  unint64_t v11 = v8;
  while (1)
  {
    if (*v11 != *v10)
    {
      if (!v5) {
        return 0LL;
      }
      uint64_t result = v5();
      if (!result) {
        return result;
      }
    }

    ++v10;
    ++v11;
    if (!--v2) {
      goto LABEL_22;
    }
  }

uint64_t __CFBinaryHeapHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFBinaryHeapCopyDescription(void *a1)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v2 = a1[2];
  char v3 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 0LL);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat( Mutable,  0LL,  @"<CFBinaryHeap %p [%p]>{count = %lu, capacity = %lu, objects = (\n"),  a1,  v5,  v2,  a1[3];
  if (v2 >= 129)
  {
    unsigned int v6 = (void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v2, 0LL);
    BOOL v7 = v6 != values;
    if (__CFOASafe) {
      BOOL v8 = v6 == values;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      __CFSetLastAllocationEventName();
      BOOL v7 = 1;
    }

    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)v6);
  }

  else
  {
    unsigned int v6 = values;
    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)values);
    if (v2 <= 0)
    {
      CFStringAppend(Mutable, @"}"));
      return Mutable;
    }

    BOOL v7 = 0;
  }

  for (uint64_t i = 0LL; i != v2; ++i)
  {
    uint64_t v10 = v6[i];
    unint64_t v11 = (uint64_t (*)(void *))a1[7];
    if (v11 && (uint64_t v12 = v11(v6[i])) != 0)
    {
      uint64_t v13 = (const void *)v12;
      CFStringAppendFormat(Mutable, 0LL, @"\t%lu : %@\n", i, v12);
      CFRelease(v13);
    }

    else
    {
      CFStringAppendFormat(Mutable, 0LL, @"\t%lu : <%p>\n", i, v10);
    }
  }

  CFStringAppend(Mutable, @"}"));
  if (v7)
  {
    uint64_t v14 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v14, v6);
  }

  return Mutable;
}

CFTypeID CFBinaryHeapGetTypeID(void)
{
  return 23LL;
}

CFBinaryHeapRef CFBinaryHeapCreate( CFAllocatorRef allocator, CFIndex capacity, const CFBinaryHeapCallBacks *callBacks, const CFBinaryHeapCompareContext *compareContext)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit( allocator,  0LL,  0LL,  (uint64_t)callBacks,  (uint64_t)compareContext,  v4,  v5,  v6);
}

uint64_t __CFBinaryHeapCreateInit( const __CFAllocator *a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x17uLL, 104LL, 0LL, a5, a6, a7, a8);
  uint64_t v14 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 24) = 4LL;
    unsigned int v15 = CFAllocatorAllocate(a1, 32LL, 0LL);
    *(void *)(v14 + 112) = v15;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      unsigned int v15 = *(void **)(v14 + 112);
    }

    if (v15)
    {
      if (a4)
      {
        *(_OWORD *)(v14 + 40) = *(_OWORD *)(a4 + 8);
        *(_OWORD *)(v14 + 56) = *(_OWORD *)(a4 + 24);
      }

      if (a5)
      {
        __int128 v16 = *(_OWORD *)a5;
        __int128 v17 = *(_OWORD *)(a5 + 16);
        *(void *)(v14 + 104) = *(void *)(a5 + 32);
        *(_OWORD *)(v14 + 88) = v17;
        *(_OWORD *)(v14 + 72) = v16;
      }

      id v18 = (unint64_t *)(v14 + 8);
      unint64_t v19 = atomic_load((unint64_t *)(v14 + 8));
      while (1)
      {
        unint64_t v20 = __ldaxr(v18);
        if (v20 != v19) {
          break;
        }
        if (__stlxr(v19 & 0xFFFFFFFFFFFFFFF3LL | 4, v18)) {
          goto LABEL_14;
        }
        int v21 = 1;
LABEL_15:
        unint64_t v19 = v20;
        if (v21)
        {
          if (a3 >= 1)
          {
            do
            {
              uint64_t v22 = *a2++;
              CFBinaryHeapAddValue((CFBinaryHeapRef)v14, v22);
              --a3;
            }

            while (a3);
          }

          unint64_t v23 = atomic_load(v18);
          while (1)
          {
            unint64_t v24 = __ldaxr(v18);
            if (v24 != v23) {
              break;
            }
            if (__stlxr(v23 & 0xFFFFFFFFFFFFFFF3LL | 4, v18)) {
              goto LABEL_23;
            }
            int v25 = 1;
LABEL_24:
            unint64_t v23 = v24;
            if (v25) {
              return v14;
            }
          }

          __clrex();
LABEL_23:
          int v25 = 0;
          goto LABEL_24;
        }
      }

      __clrex();
LABEL_14:
      int v21 = 0;
      goto LABEL_15;
    }

    CFRelease((CFTypeRef)v14);
    return 0LL;
  }

  return v14;
}

CFBinaryHeapRef CFBinaryHeapCreateCopy(CFAllocatorRef allocator, CFIndex capacity, CFBinaryHeapRef heap)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit( allocator,  *((const void ***)heap + 14),  *((void *)heap + 2),  (uint64_t)heap + 32,  (uint64_t)heap + 72,  v3,  v4,  v5);
}

CFIndex CFBinaryHeapGetCount(CFBinaryHeapRef heap)
{
  return *((void *)heap + 2);
}

CFIndex CFBinaryHeapGetCountOfValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2 = *((void *)heap + 2);
  if (v2 < 1) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  CFIndex v6 = 0LL;
  BOOL v7 = (uint64_t (*)(const void *))*((void *)heap + 8);
  do
  {
    ++v5;
  }

  while (v2 != v5);
  return v6;
}

Boolean CFBinaryHeapContainsValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2 = *((void *)heap + 2);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = 0LL;
  CFIndex v6 = (uint64_t (*)(const void *))*((void *)heap + 8);
  while (*(const void **)(*((void *)heap + 14) + 8 * v5) != value && (!v6 || v6(value)))
  {
    if (v2 == ++v5) {
      return 0;
    }
  }

  return 1;
}

const void *__cdecl CFBinaryHeapGetMinimum(CFBinaryHeapRef heap)
{
  else {
    return (const void *)**((void **)heap + 14);
  }
}

Boolean CFBinaryHeapGetMinimumIfPresent(CFBinaryHeapRef heap, const void **value)
{
  if (!*((void *)heap + 2)) {
    return 0;
  }
  if (value) {
    *value = (const void *)**((void **)heap + 14);
  }
  return 1;
}

void CFBinaryHeapGetValues(CFBinaryHeapRef heap, const void **values)
{
  if (*((void *)heap + 2))
  {
    uint64_t v4 = CFGetAllocator(heap);
    uint64_t Init = __CFBinaryHeapCreateInit( v4,  *((const void ***)heap + 14),  *((void *)heap + 2),  (uint64_t)heap + 32,  (uint64_t)heap + 72,  v5,  v6,  v7);
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        BOOL v9 = **(const void ***)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        *values++ = v9;
      }

      while (*(uint64_t *)(Init + 16) > 0);
    }

    CFRelease((CFTypeRef)Init);
  }

void CFBinaryHeapRemoveMinimumValue(CFBinaryHeapRef heap)
{
  uint64_t v1 = *((void *)heap + 2);
  if (!v1) {
    return;
  }
  uint64_t v3 = v1 - 1;
  *((void *)heap + 2) = v1 - 1;
  uint64_t v4 = (uint64_t (*)(unint64_t, unint64_t, void))*((void *)heap + 8);
  CFAllocatorRef v5 = CFGetAllocator(heap);
  uint64_t v6 = (void (*)(CFAllocatorRef, void))*((void *)heap + 6);
  if (v6) {
    v6(v5, **((void **)heap + 14));
  }
  uint64_t v7 = *((void *)heap + 14);
  unint64_t v8 = *(void *)(v7 + 8 * v3);
  uint64_t v9 = *((void *)heap + 2);
  if (v9 < 2)
  {
    uint64_t v10 = 0LL;
    goto LABEL_24;
  }

  uint64_t v10 = 0LL;
  uint64_t v11 = 1LL;
  while (1)
  {
    uint64_t v12 = v10;
    uint64_t v7 = *((void *)heap + 14);
    unint64_t v13 = *(void *)(v7 + 8 * v11);
    uint64_t v14 = v11 + 1;
    if (v11 + 1 < v9) {
      break;
    }
    if (!v4 && v13 > v8) {
      goto LABEL_23;
    }
    uint64_t v10 = v11;
    if (v4) {
      goto LABEL_14;
    }
LABEL_20:
    *(void *)(v7 + 8 * v12) = v13;
    uint64_t v11 = (2 * v10) | 1;
    if (v11 >= v9)
    {
      uint64_t v7 = *((void *)heap + 14);
      goto LABEL_24;
    }
  }

  unint64_t v15 = *(void *)(v7 + 8 * v14);
  if (v4)
  {
    if (v4(*(void *)(v7 + 8 * v11), *(void *)(v7 + 8 * v14), *((void *)heap + 10)) == 1)
    {
      ++v11;
      unint64_t v13 = v15;
    }

LABEL_14:
    uint64_t v16 = v4(v13, v8, *((void *)heap + 10));
    uint64_t v7 = *((void *)heap + 14);
    if (v16 == 1) {
      goto LABEL_23;
    }
    uint64_t v9 = *((void *)heap + 2);
    uint64_t v10 = v11;
    goto LABEL_20;
  }

  if (v13 <= v15)
  {
    uint64_t v10 = v11;
  }

  else
  {
    unint64_t v13 = *(void *)(v7 + 8 * v14);
    uint64_t v10 = v11 + 1;
  }

  if (v13 <= v8) {
    goto LABEL_20;
  }
LABEL_23:
  uint64_t v10 = v12;
LABEL_24:
  *(void *)(v7 + 8 * v10) = v8;
}

  if (v7 >= v8) {
    return 0LL;
  }
  unint64_t v13 = *(v7 - 1);
  if (v11 == -1) {
    uint64_t v11 = (_DWORD)v7 - (v13 == 47) - (_DWORD)v6;
  }
  *(void *)(a1 + 8) = v7 + 1;
  if (v11)
  {
    uint64_t v14 = -1;
    unint64_t v15 = 1;
    uint64_t v16 = 6LL;
    __int128 v17 = 1;
    id v18 = 1;
    unint64_t v19 = 1;
    unint64_t v20 = 1;
    int v21 = 1;
    switch(*v6)
    {
      case 'a':
        if (v11 != 5) {
          goto LABEL_65;
        }
        uint64_t v22 = *(_DWORD *)v6 ^ 0x61727261 | v6[4] ^ 0x79;
        __int128 v17 = v22 != 0;
        if (v22) {
          uint64_t v14 = -1;
        }
        else {
          uint64_t v14 = 1;
        }
        unint64_t v15 = 1;
        goto LABEL_49;
      case 'b':
      case 'c':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'q':
        goto LABEL_71;
      case 'd':
        if (v11 != 4) {
          goto LABEL_65;
        }
        if (*(_DWORD *)v6 == 1952672100)
        {
          id v18 = 0;
          uint64_t v14 = 2;
          goto LABEL_64;
        }

        uint64_t v16 = 6LL;
        if (*(_DWORD *)v6 == 1635017060)
        {
          int v21 = 0;
          uint64_t v14 = 5;
        }

        else if (*(_DWORD *)v6 == 1702125924)
        {
          uint64_t v14 = 6;
        }

        else
        {
          uint64_t v14 = -1;
        }

        unint64_t v15 = 1;
        goto LABEL_70;
      case 'f':
        if (v11 != 5) {
          goto LABEL_65;
        }
        unint64_t v24 = (*(_DWORD *)v6 ^ 0x736C6166 | v6[4] ^ 0x65) == 0;
        int v25 = 10;
        goto LABEL_54;
      case 'i':
        if (v11 != 7) {
          goto LABEL_65;
        }
        unint64_t v24 = (*(_DWORD *)v6 ^ 0x65746E69 | *(_DWORD *)(v6 + 3) ^ 0x72656765) == 0;
        int v25 = 8;
        goto LABEL_54;
      case 'k':
        if (v11 != 3) {
          goto LABEL_65;
        }
        if (*(_WORD *)v6 != 25963 || v6[2] != 121) {
          goto LABEL_57;
        }
        unint64_t v15 = 1;
        unint64_t v20 = 0;
        uint64_t v16 = 3LL;
        if (a2) {
          *a2 = 1;
        }
        __int128 v17 = 1;
        id v18 = 1;
        uint64_t v14 = 3;
        goto LABEL_71;
      case 'p':
        if (v11 != 5) {
          goto LABEL_65;
        }
        int64_t v27 = *(_DWORD *)v6 ^ 0x73696C70 | v6[4] ^ 0x74;
        unint64_t v24 = v27 == 0;
        unint64_t v15 = v27 != 0;
        if (v24) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = -1;
        }
        __int128 v17 = 1;
LABEL_49:
        uint64_t v16 = 6LL;
        goto LABEL_58;
      case 'r':
        if (v11 != 4) {
          goto LABEL_65;
        }
        int64_t v28 = *(_DWORD *)v6 == 1818322290;
        uint64_t v29 = 7;
        goto LABEL_61;
      case 's':
        if (v11 != 6) {
          goto LABEL_65;
        }
        int64_t v30 = *(_DWORD *)v6 ^ 0x69727473 | *((unsigned __int16 *)v6 + 2) ^ 0x676E;
        unint64_t v24 = v30 == 0;
        unint64_t v19 = v30 != 0;
        int v25 = 4;
LABEL_54:
        if (v24) {
          uint64_t v14 = v25;
        }
        else {
          uint64_t v14 = -1;
        }
LABEL_57:
        unint64_t v15 = 1;
        uint64_t v16 = 6LL;
        __int128 v17 = 1;
LABEL_58:
        id v18 = 1;
        goto LABEL_71;
      case 't':
        if (v11 == 4)
        {
          int64_t v28 = *(_DWORD *)v6 == 1702195828;
          uint64_t v29 = 9;
LABEL_61:
          if (v28) {
            uint64_t v14 = v29;
          }
          else {
            uint64_t v14 = -1;
          }
LABEL_64:
          unint64_t v15 = 1;
          uint64_t v16 = 6LL;
LABEL_70:
          __int128 v17 = 1;
        }

        else
        {
LABEL_65:
          uint64_t v16 = 6LL;
        }

    unint64_t v13 = 0;
    goto LABEL_19;
  }

  uint64_t v9 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v9) {
    goto LABEL_14;
  }
  uint64_t v10 = (void *)v9;
  uint64_t v11 = (pthread_mutex_t *)(v9 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
  uint64_t v12 = (const __CFSet *)v10[12];
  if (v12 && CFSetContainsValue(v12, source))
  {
    unint64_t v13 = 1;
  }

  else
  {
    unint64_t v15 = (const __CFSet *)v10[13];
    if (v15) {
      unint64_t v13 = CFSetContainsValue(v15, source) != 0;
    }
    else {
      unint64_t v13 = 0;
    }
  }

  pthread_mutex_unlock(v11);
  CFRelease(v10);
LABEL_19:
  pthread_mutex_unlock(v8);
  return v13;
}

  uint64_t v9 = a1[14];
  uint64_t v10 = a2[14];
  if (v5) {
    return v5(v9, v10);
  }
  else {
    return v9 == v10;
  }
}

    LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(a1);
    return _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
  }

  if ((_DWORD)result == 28) {
    return 82LL;
  }
  if ((_DWORD)result == 37) {
    return 0LL;
  }
  return result;
}

  if (error)
  {
    int v21 = 0LL;
    *error = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 4LL, 0LL);
    if (!v15) {
      goto LABEL_64;
    }
LABEL_63:
    CFRelease(v15);
    goto LABEL_64;
  }

  int v21 = 0LL;
  if (v15) {
    goto LABEL_63;
  }
LABEL_64:
  if (v16) {
    CFRelease(v16);
  }
  return (CFURLRef)v21;
}

  if (v9)
  {
    id v18 = v9;
    uint64_t v14 = _os_log_pack_size();
    unint64_t v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unint64_t v19 = _os_log_pack_fill();
    unint64_t v20 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0(v19, (uint64_t)"-[NSArray getObjects:range:]", location, length, --v18);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v20,  "-[NSArray getObjects:range:]",  location,  length,  v18);
  }

  else
  {
    uint64_t v14 = _os_log_pack_size();
    unint64_t v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = _os_log_pack_fill();
    __int128 v17 = __os_log_helper_1_2_3_8_32_8_0_8_0(v16, (uint64_t)"-[NSArray getObjects:range:]", location, length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty array",  v17,  "-[NSArray getObjects:range:]",  location,  length,  v25);
  }

  int v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v15,  v14);
  objc_exception_throw(v21);
  -[NSArray getObjects:](v22, v23, v24);
}

  os_unfair_lock_lock_with_options();
  Value = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)signatureWithObjCTypes__cache, types);
  os_unfair_lock_unlock((os_unfair_lock_t)&signatureWithObjCTypes__lock);
  if (Value) {
    return (NSMethodSignature *)Value;
  }
  if (_os_feature_enabled_impl())
  {
    uint64_t v12 = (os_log_s *)_CFMethodSignatureROMLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)keyCallBacks = 136315138;
      *(void *)&keyCallBacks[4] = types;
      _os_log_impl(&dword_180A4C000, v12, OS_LOG_TYPE_DEFAULT, "MISS: %s", keyCallBacks, 0xCu);
    }
  }

  uint64_t v34 = types;
  uint64_t v51 = 0LL;
  uint64_t v50 = 0u;
  int64_t v49 = 0u;
  unsigned int v48 = 0u;
  UniChar v47 = 0u;
  int64_t v46 = 0u;
  uint64_t v45 = 0u;
  int64_t v44 = 0u;
  uint64_t v43 = 0u;
  CFIndex v42 = 0u;
  int64_t v41 = 0u;
  int64_t v40 = 0u;
  CFIndex v39 = 0u;
  memset(&keyCallBacks[24], 0, 32);
  unint64_t v13 = calloc(1uLL, 0x18uLL);
  uint64_t v14 = parseFrameArgumentInfo((uint64_t *)&v34, 0LL, 0, 0LL);
  unint64_t v15 = (uint64_t)v14;
  *(void *)unint64_t v13 = v14;
  if (v14)
  {
    *(_OWORD *)keyCallBacks = xmmword_180D7DFA0;
    *(void *)&keyCallBacks[16] = 224LL;
    uint64_t v16 = *((unsigned __int8 *)v14 + 36);
    __int128 v17 = (v16 - 35);
    if (v17 <= 0x31)
    {
      if (v17 == 33)
      {
LABEL_52:
        v14[3] = 0x5000000010LL;
        int64_t v28 = -2048;
LABEL_54:
        *((_WORD *)v14 + 16) = v28;
        goto LABEL_29;
      }
    }

    if (((1 << (v16 - 105)) & 0xD09) == 0)
    {
      if (v16 == 123)
      {
        CFIndex v37 = 0LL;
        int v36 = 0;
        if (__NSMFAIsHFA_arm64((uint64_t)v14, &v36, (unint64_t *)&v37))
        {
          unsigned int v35 = 0LL;
          __NSMFASetRegisterOffsetsForHFA_arm64(v15, 80LL, &v35);
        }

        else if (*(_DWORD *)(v15 + 16) < 0x11u)
        {
          copyMemStateToFrameState(v15);
        }

        else
        {
          uint64_t v29 = strlen((const char *)(v15 + 37));
          int64_t v30 = calloc(1uLL, v29 + 42);
          *(void *)int64_t v30 = v15;
          v30[1] = xmmword_180D7DFB0;
          *((_WORD *)v30 + 17) |= 0x1082u;
          *((_WORD *)v30 + 18) = 24158;
          UniChar v31 = strlen((const char *)(v15 + 37));
          memmove((char *)v30 + 38, (const void *)(v15 + 37), v31 + 1);
          copyMemStateToFrameState(*(void *)v15);
          *(void *)unint64_t v13 = v30;
        }

        goto LABEL_29;
      }

  unint64_t v13 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@.plist",  CacheStringForBundleID);
LABEL_16:
  uint64_t v14 = v13;
  CFRelease(CacheStringForBundleID);
  if (!v14)
  {
    uint64_t v16 = 0LL;
    goto LABEL_21;
  }

  unint64_t v15 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v14,  kCFURLPOSIXPathStyle,  0,  PreferencesDirectoryURLForTriplet);
  CFRelease(v14);
  CFRelease(PreferencesDirectoryURLForTriplet);
  if (v15)
  {
    uint64_t v16 = CFURLGetFileSystemRepresentation(v15, 1u, a5, 1024LL) != 0;
    PreferencesDirectoryURLForTriplet = v15;
LABEL_21:
    CFRelease(PreferencesDirectoryURLForTriplet);
    return v16;
  }

  return 0LL;
}

    if (!v1) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  unint64_t v15 = v0;
  uint64_t v16 = (const char **)v1;
  while (1)
  {
    __int128 v17 = asprintf((char **)v31[3], "%s\n", *v16);
    ++v16;
    if (!--v15) {
      goto LABEL_25;
    }
  }

  uint64_t v4 = 0LL;
LABEL_15:
  free(v1);
LABEL_16:
  if (v2)
  {
    while (1)
    {
      unint64_t v13 = v31[3];
      v31[3] = v13 - 8;
      free(*(void **)(v13 - 8));
    }

    free(v2);
  }

  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v4;
}

    switch(v4)
    {
      case 18LL:
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
        else {
          uint64_t v12 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 16 * Count, 0LL);
        }
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a2, v12, &v12[Count]);
        char v33 = -48;
        break;
      case 17LL:
        CFIndex Count = CFSetGetCount((CFSetRef)a2);
        else {
          uint64_t v12 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
        }
        CFSetGetValues((CFSetRef)a2, v12);
        char v33 = -64;
        break;
      case 19LL:
        CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
        else {
          uint64_t v12 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
        }
        v57.int location = 0LL;
        v57.CFIndex length = Count;
        CFArrayGetValues((CFArrayRef)a2, v57, v12);
        char v33 = -96;
        break;
      default:
        return 0LL;
    }

    int v36 = 15;
    if (Count < 15) {
      int v36 = Count;
    }
    __src = v33 | v36;
    bufferWrite_0((uint64_t)a1, &__src, 1LL);
    if (Count < 15)
    {
      if (Count < 1)
      {
LABEL_97:
        return 1LL;
      }

      goto LABEL_92;
    }

    if ((unint64_t)Count > 0x7F)
    {
      if ((unint64_t)Count >> 15)
      {
        if ((unint64_t)Count >> 31)
        {
          LOBYTE(v54) = 19;
          *(_WORD *)((char *)&v54 + 1) = Count;
          BYTE3(v54) = BYTE2(Count);
          BYTE4(v54) = BYTE3(Count);
          BYTE5(v54) = BYTE4(Count);
          BYTE6(v54) = BYTE5(Count);
          BYTE7(v54) = BYTE6(Count);
          BYTE8(v54) = HIBYTE(Count) ^ 0x80;
          CFIndex v37 = (char *)&v54;
          uint64_t v38 = (uint64_t)a1;
          CFIndex v39 = 9LL;
          goto LABEL_91;
        }

        LOBYTE(v54) = 18;
        bufferWrite_0((uint64_t)a1, &v54, 1LL);
        int64_t v53 = BYTE1(Count);
        LOBYTE(usedBufLen) = Count;
        int64_t v52 = BYTE2(Count);
        uint64_t v51 = BYTE3(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &usedBufLen, 1LL);
        bufferWrite_0((uint64_t)a1, &v53, 1LL);
        bufferWrite_0((uint64_t)a1, &v52, 1LL);
        CFIndex v37 = &v51;
      }

      else
      {
        LOBYTE(v54) = 17;
        bufferWrite_0((uint64_t)a1, &v54, 1LL);
        LOBYTE(usedBufLen) = Count;
        int64_t v53 = BYTE1(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &usedBufLen, 1LL);
        CFIndex v37 = &v53;
      }
    }

    else
    {
      LOBYTE(v54) = Count ^ 0x80;
      LOBYTE(usedBufLen) = 16;
      bufferWrite_0((uint64_t)a1, &usedBufLen, 1LL);
      CFIndex v37 = (char *)&v54;
    }

    uint64_t v38 = (uint64_t)a1;
    CFIndex v39 = 1LL;
LABEL_91:
    bufferWrite_0(v38, v37, v39);
LABEL_92:
    int64_t v40 = 0LL;
    if (Count << (v5 == 18) <= 1) {
      int64_t v41 = 1LL;
    }
    else {
      int64_t v41 = Count << (v5 == 18);
    }
    while (__writeObject15(a1, v12[v40]))
    {
      if (v41 == ++v40) {
        goto LABEL_97;
      }
    }

    return 0LL;
  }

  int v21 = CFStringGetLength(a2);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v21, 0x8000100u);
  unint64_t v23 = MaximumSizeForEncoding;
  if (!*a1 && !a1[1])
  {
    uint64_t v32 = MaximumSizeForEncoding + 10;
    UniChar v31 = (uint64_t)a1;
    BytePtr = 0LL;
LABEL_70:
    bufferWrite_0(v31, BytePtr, v32);
    return 1LL;
  }

  if (MaximumSizeForEncoding <= 1024)
  {
    usedBufLen = 0LL;
    unint64_t v24 = (UInt8 *)valuePtr;
LABEL_42:
    v56.int location = 0LL;
    v56.CFIndex length = v21;
    Bytes = CFStringGetBytes(a2, v56, 0x8000100u, 0, 0, v24, v23, &usedBufLen);
    goto LABEL_43;
  }

  unint64_t v24 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, MaximumSizeForEncoding, 0LL);
  usedBufLen = 0LL;
  if (v24) {
    goto LABEL_42;
  }
  Bytes = 0LL;
LABEL_43:
  if (Bytes == v21)
  {
    int64_t v27 = usedBufLen;
    if (usedBufLen >= 15) {
      int64_t v27 = 15;
    }
    uint64_t v45 = v27 | 0x70;
    bufferWrite_0((uint64_t)a1, &v45, 1LL);
    int64_t v28 = usedBufLen;
    if (usedBufLen < 15) {
      goto LABEL_108;
    }
    if ((unint64_t)usedBufLen > 0x7F)
    {
      if ((unint64_t)usedBufLen >> 15)
      {
        if ((unint64_t)usedBufLen >> 31)
        {
          LOBYTE(v54) = 19;
          *(void *)((char *)&v54 + 1) = usedBufLen ^ 0x8000000000000000LL;
          uint64_t v29 = (char *)&v54;
          CFIndex v42 = (uint64_t)a1;
          uint64_t v43 = 9LL;
          goto LABEL_107;
        }

        LOBYTE(v54) = 18;
        bufferWrite_0((uint64_t)a1, &v54, 1LL);
        int64_t v52 = BYTE1(v28);
        int64_t v53 = v28;
        uint64_t v51 = BYTE2(v28);
        uint64_t v50 = HIBYTE(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v53, 1LL);
        bufferWrite_0((uint64_t)a1, &v52, 1LL);
        bufferWrite_0((uint64_t)a1, &v51, 1LL);
        uint64_t v29 = &v50;
      }

      else
      {
        LOBYTE(v54) = 17;
        bufferWrite_0((uint64_t)a1, &v54, 1LL);
        int64_t v53 = v28;
        int64_t v52 = BYTE1(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v53, 1LL);
        uint64_t v29 = &v52;
      }
    }

    else
    {
      LOBYTE(v54) = usedBufLen ^ 0x80;
      int64_t v53 = 16;
      bufferWrite_0((uint64_t)a1, &v53, 1LL);
      uint64_t v29 = (char *)&v54;
    }

    CFIndex v42 = (uint64_t)a1;
    uint64_t v43 = 1LL;
LABEL_107:
    bufferWrite_0(v42, v29, v43);
LABEL_108:
    bufferWrite_0((uint64_t)a1, v24, usedBufLen);
  }

  if (v24 != (UInt8 *)valuePtr) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v24);
  }
  return Bytes == v21;
}

void CFBinaryHeapApplyFunction(CFBinaryHeapRef heap, CFBinaryHeapApplierFunction applier, void *context)
{
  if (*((void *)heap + 2))
  {
    uint64_t v6 = CFGetAllocator(heap);
    uint64_t Init = __CFBinaryHeapCreateInit( v6,  *((const void ***)heap + 14),  *((void *)heap + 2),  (uint64_t)heap + 32,  (uint64_t)heap + 72,  v7,  v8,  v9);
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        uint64_t v11 = **(void **)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        ((void (*)(uint64_t, void *))applier)(v11, context);
      }

      while (*(uint64_t *)(Init + 16) > 0);
    }

    CFRelease((CFTypeRef)Init);
  }

void CFBinaryHeapAddValue(CFBinaryHeapRef heap, const void *value)
{
  CFAllocatorRef v4 = CFGetAllocator(heap);
  char v5 = atomic_load((unint64_t *)heap + 1);
  if ((v5 & 0xC) == 4LL)
  {
    uint64_t v6 = *((void *)heap + 2);
    if (v6 == *((void *)heap + 3))
    {
      uint64_t v7 = v6 >= 3 ? 1 << flsl(v6 + 1) : 4LL;
      uint64_t v8 = (malloc_zone_t *)CFGetAllocator(heap);
      *((void *)heap + 3) = v7;
      *((void *)heap + 14) = __CFSafelyReallocateWithAllocator(v8, *((void **)heap + 14), 8 * v7, 0LL, 0LL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }

  uint64_t v9 = *((void *)heap + 2);
  *((void *)heap + 2) = v9 + 1;
  if (v9 >= 1)
  {
    uint64_t v10 = (uint64_t (*)(void, const void *, void))*((void *)heap + 8);
    while (1)
    {
      uint64_t v11 = (v9 - 1) >> 1;
      uint64_t v12 = *((void *)heap + 14);
      unint64_t v13 = *(void *)(v12 + 8 * v11);
      if (v10)
      {
        if (v10(*(void *)(v12 + 8 * v11), value, *((void *)heap + 10)) != 1) {
          break;
        }
        uint64_t v12 = *((void *)heap + 14);
      }

      *(void *)(v12 + 8 * v9) = v13;
      BOOL v14 = v9 <= 2;
      uint64_t v9 = (v9 - 1) >> 1;
      if (v14) {
        goto LABEL_19;
      }
    }
  }

  uint64_t v11 = v9;
LABEL_19:
  unint64_t v15 = (uint64_t (*)(CFAllocatorRef, const void *))*((void *)heap + 5);
  if (v15) {
    value = (const void *)v15(v4, value);
  }
  *(void *)(*((void *)heap + 14) + 8 * v11) = value;
}

void CFBinaryHeapRemoveAllValues(CFBinaryHeapRef heap)
{
  uint64_t v2 = *((void *)heap + 2);
  if (*((void *)heap + 6)) {
    BOOL v3 = v2 < 1;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = 0LL;
    do
    {
      char v5 = (void (*)(CFAllocatorRef, void))*((void *)heap + 6);
      CFAllocatorRef v6 = CFGetAllocator(heap);
      v5(v6, *(void *)(*((void *)heap + 14) + 8 * v4++));
    }

    while (v2 != v4);
  }

  *((void *)heap + 2) = 0LL;
}

__objc2_class **__NSArrayImmutablePlaceholder()
{
  return &___immutablePlaceholderArray;
}

__objc2_class **__NSArrayMutablePlaceholder()
{
  return &___mutablePlaceholderArray;
}

uint64_t __initWithArrayDontCopyItems(__objc2_class **a1, void *a2)
{
  uint64_t v4 = (__objc2_class *)objc_opt_class();
  if (v4 != &OBJC_CLASS_____NSArrayI && v4 != &OBJC_CLASS_____NSArrayM && v4 != &OBJC_CLASS_____NSFrozenArrayM) {
    return 0LL;
  }
  if (a1 == &___mutablePlaceholderArray) {
    return [a2 mutableCopyWithZone:0];
  }
  if (a1 != &___immutablePlaceholderArray) {
    return 0LL;
  }
  return [a2 copyWithZone:0];
}

CFStringRef __CFKeyedArchiverUIDCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"@%u@",  *(unsigned int *)(a1 + 16));
}

CFStringRef __CFKeyedArchiverUIDCopyDescription(unsigned int *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFKeyedArchiverUID %p [%p]>{value = %u}",  a1,  v2,  a1[4]);
}

uint64_t _CFKeyedArchiverUIDGetTypeID()
{
  return 41LL;
}

uint64_t _CFKeyedArchiverUIDCreate( const __CFAllocator *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _CFRuntimeCreateInstance(a1, 0x29uLL, 8LL, 0LL, a5, a6, a7, a8);
  if (result) {
    *(_DWORD *)(result + 16) = a2;
  }
  return result;
}

uint64_t _CFKeyedArchiverUIDGetValue(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 41) {
    _CFAssertMismatchedTypeID(0x29uLL, v2);
  }
  return *(unsigned int *)(a1 + 16);
}

uint64_t __CFBinaryPlistWriteOrPresize( const void *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  __src[4] = *MEMORY[0x1895F89C0];
  memset(v39, 0, sizeof(v39));
  uint64_t v9 = (objc_class **)CFBasicHashCreate((uint64_t)&__kCFAllocatorSystemDefault, 0xA001u, (uint64_t *)v39);
  _CFRuntimeSetInstanceTypeIDAndIsa(v9, 0x12uLL);
  *(_OWORD *)&callBacks.CFIndex version = xmmword_1899959D0;
  *(_OWORD *)&callBacks.CFArrayReleaseCallBack release = *(_OWORD *)&off_1899959E0;
  callBacks.equal = 0LL;
  uint64_t v10 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &callBacks);
  CFSetCallBacks v37 = *(CFSetCallBacks *)byte_1899959F8;
  uint64_t v11 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &v37);
  _flattenPlist(a1, v10, (__CFDictionary *)v9, v11);
  CFRelease(v11);
  CFIndex Count = CFArrayGetCount(v10);
  unint64_t v13 = (unint64_t *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
  BOOL v14 = (int *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8208LL, 0LL);
  *(void *)BOOL v14 = a2;
  *((void *)v14 + 1) = 0LL;
  *((void *)v14 + 2) = 0LL;
  *((void *)v14 + 3) = 0LL;
  if (a2)
  {
    CFTypeID v15 = CFGetTypeID(a2);
    BOOL v16 = v15 == CFDataGetTypeID();
  }

  else
  {
    BOOL v16 = 1;
  }

  *((_BYTE *)v14 + 44) = v16;
  *((void *)v14 + 4) = 0LL;
  v14[10] = 0;
  bufferWrite((uint64_t)v14, "bplist00", 8LL, a5);
  __src[0] = 0LL;
  __src[1] = bswap64(Count);
  __src[2] = 0LL;
  unsigned __int8 v17 = 0;
  if (!Count) {
    goto LABEL_12;
  }
  uint64_t v18 = -1LL;
  do
  {
    ++v17;
    BOOL v20 = (Count & (v18 << 8)) == 0;
    v18 <<= 8;
  }

  while (!v20);
  if (v17 <= 7u)
  {
LABEL_12:
    while (1)
    {
      unsigned int v19 = v17;
      BOOL v20 = v17 > 4u || ((1 << v17) & 0x16) == 0;
      if (!v20) {
        break;
      }
      ++v17;
      if (v19 >= 7)
      {
        unsigned __int8 v17 = 8;
        break;
      }
    }
  }

  HIBYTE(__src[0]) = v17;
  if (Count < 1)
  {
LABEL_20:
    CFRelease(v9);
    CFRelease(v10);
    unint64_t v23 = *((void *)v14 + 4) + v14[10];
    __src[3] = bswap64(v23);
    unsigned __int8 v24 = 0;
    if (!v23) {
      goto LABEL_28;
    }
    uint64_t v25 = -1LL;
    do
    {
      ++v24;
      BOOL v20 = (v23 & (v25 << 8)) == 0;
      v25 <<= 8;
    }

    while (!v20);
    if (v24 <= 7u)
    {
LABEL_28:
      while (1)
      {
        unsigned int v26 = v24;
        if (v24 <= 4u && ((1 << v24) & 0x16) != 0) {
          break;
        }
        ++v24;
        if (v26 >= 7)
        {
          unsigned __int8 v24 = 8;
          break;
        }
      }
    }

    BYTE6(__src[0]) = v24;
    if (Count >= 1)
    {
      int64_t v28 = v13;
      CFIndex v29 = Count;
      do
      {
        unint64_t v30 = *v28++;
        unint64_t v36 = bswap64(v30);
        bufferWrite((uint64_t)v14, (_BYTE *)&v36 - v24 + 8, v24, a5);
        --v29;
      }

      while (v29);
    }

    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
    bufferWrite((uint64_t)v14, __src, 32LL, a5);
    writeBytes((uint64_t)v14, (const UInt8 *)v14 + 45, v14[10], a5);
    v14[10] = 0;
    UniChar v31 = (const void *)*((void *)v14 + 3);
    if (v31)
    {
      if (a6)
      {
        uint64_t v32 = 0LL;
        *a6 = v31;
      }

      else
      {
        CFRelease(v31);
        uint64_t v32 = 0LL;
      }
    }

    else
    {
      uint64_t v32 = v23 + Count * v24 + 32;
    }

    unint64_t v13 = (unint64_t *)v14;
  }

  else
  {
    CFIndex v21 = 0LL;
    while (1)
    {
      v13[v21] = *((void *)v14 + 4) + v14[10];
      ValueAtIndex = CFArrayGetValueAtIndex(v10, v21);
      if (Count == ++v21) {
        goto LABEL_20;
      }
    }

    CFRelease(v9);
    CFRelease(v10);
    char v33 = (const void *)*((void *)v14 + 3);
    if (a6)
    {
      if (v33) {
        *a6 = v33;
      }
    }

    else if (v33)
    {
      CFRelease(v33);
    }

    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
    uint64_t v32 = 0LL;
  }

  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
  return v32;
}

void _flattenPlist(const void *a1, const __CFArray *a2, __CFDictionary *a3, const __CFSet *a4)
{
  v30[1] = *MEMORY[0x1895F89C0];
  CFTypeID v8 = CFGetTypeID(a1);
  CFTypeID v9 = v8;
  if (v8 > 0x2A
    || ((1LL << v8) & 0x40000500080LL) == 0
    || (CFIndex v10 = CFSetGetCount(a4), CFSetAddValue(a4, a1), CFSetGetCount(a4) != v10))
  {
    unsigned int Count = CFArrayGetCount(a2);
    CFArrayAppendValue(a2, a1);
    CFDictionaryAddValue(a3, a1, (const void *)Count);
    if (v9 != 19)
    {
      if (v9 != 18) {
        return;
      }
      CFIndex v14 = CFDictionaryGetCount((CFDictionaryRef)a1);
      uint64_t v16 = MEMORY[0x1895F8858](v14, v15);
      uint64_t v18 = (const void **)((char *)v30 - v17);
      if (v16 >= 129)
      {
        unsigned int v19 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 16 * v14, 0LL);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v19, &v19[v14]);
      }

      else
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, (const void **)((char *)v30 - v17), &v18[v14]);
        unsigned int v19 = v18;
        if (v14 < 1)
        {
LABEL_19:
          if (v19 == v18) {
            return;
          }
          int64_t v28 = v19;
LABEL_26:
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28);
          return;
        }
      }

      uint64_t v26 = 0LL;
      if (2 * v14 <= 1) {
        uint64_t v27 = 1LL;
      }
      else {
        uint64_t v27 = 2 * v14;
      }
      do
        _flattenPlist(v19[v26++], a2, a3, a4);
      while (v27 != v26);
      goto LABEL_19;
    }

    uint64_t v20 = CFArrayGetCount((CFArrayRef)a1);
    uint64_t v22 = MEMORY[0x1895F8858](v20, v21);
    unsigned __int8 v24 = (const void **)((char *)v30 - v23);
    if (v22 >= 257)
    {
      uint64_t v25 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v20, 0LL);
      v32.int location = 0LL;
      v32.CFIndex length = v20;
      CFArrayGetValues((CFArrayRef)a1, v32, v25);
    }

    else
    {
      v31.int location = 0LL;
      v31.CFIndex length = v20;
      CFArrayGetValues((CFArrayRef)a1, v31, (const void **)((char *)v30 - v23));
      uint64_t v25 = v24;
      if (v20 < 1)
      {
LABEL_24:
        if (v25 == v24) {
          return;
        }
        int64_t v28 = v25;
        goto LABEL_26;
      }
    }

    uint64_t v29 = 0LL;
    do
      _flattenPlist(v25[v29++], a2, a3, a4);
    while (v20 != v29);
    goto LABEL_24;
  }

  Value = CFSetGetValue(a4, a1);
  if (Value != a1)
  {
    unsigned int v12 = CFDictionaryGetValue(a3, Value);
    CFDictionaryAddValue(a3, a1, (const void *)v12);
  }

void bufferWrite(uint64_t a1, _BYTE *__src, int64_t a3, int a4)
{
  if (a3)
  {
    if (a3 < 8160)
    {
      int v8 = *(_DWORD *)(a1 + 40);
      if (8160LL - v8 >= a3) {
        size_t v9 = a3;
      }
      else {
        size_t v9 = 8160LL - v8;
      }
      if (!a4 && (*(void *)a1 || *(void *)(a1 + 8)))
      {
        uint64_t v10 = v8;
        switch(v9)
        {
          case 1uLL:
            goto LABEL_14;
          case 2uLL:
            goto LABEL_13;
          case 3uLL:
            goto LABEL_12;
          case 4uLL:
            *(_BYTE *)(v8 + a1 + 48) = __src[3];
            int v8 = *(_DWORD *)(a1 + 40);
LABEL_12:
            *(_BYTE *)(a1 + v8 + 47) = __src[2];
            int v8 = *(_DWORD *)(a1 + 40);
LABEL_13:
            *(_BYTE *)(a1 + v8 + 46) = __src[1];
            uint64_t v10 = *(int *)(a1 + 40);
LABEL_14:
            *(_BYTE *)(a1 + v10 + 45) = *__src;
            break;
          default:
            memmove((void *)(a1 + v8 + 45), __src, v9);
            break;
        }
      }

      int v11 = *(_DWORD *)(a1 + 40) + v9;
      *(_DWORD *)(a1 + 40) = v11;
      if (v11 == 8160)
      {
        writeBytes(a1, (const UInt8 *)(a1 + 45), 8160LL, a4);
        if (!a4 && (*(void *)a1 || *(void *)(a1 + 8))) {
          memmove((void *)(a1 + 45), &__src[v9], a3 - v9);
        }
        *(_DWORD *)(a1 + 40) = a3 - v9;
      }
    }

    else
    {
      writeBytes(a1, (const UInt8 *)(a1 + 45), *(int *)(a1 + 40), a4);
      *(_DWORD *)(a1 + 40) = 0;
      writeBytes(a1, __src, a3, a4);
    }
  }

uint64_t _appendObject(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  int v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v2;
  uint64_t v48 = *MEMORY[0x1895F89C0];
  int64_t v12 = CFGetTypeID(v9);
  uint64_t v13 = 0LL;
  if (v12 > 40)
  {
    if (v12 == 41)
    {
      unsigned int v34 = _CFKeyedArchiverUIDGetValue((uint64_t)v10);
      uint64_t v35 = 4LL;
      if (v34 < 0x10000) {
        uint64_t v35 = 2LL;
      }
      if (v34 < 0x100) {
        uint64_t v36 = 1LL;
      }
      else {
        uint64_t v36 = v35;
      }
      valuePtr.i8[0] = (v36 - 1) | 0x80;
      keys[0] = (void *)bswap64(v34);
      uint64_t v13 = 1LL;
      bufferWrite(v11, &valuePtr, 1LL, v4);
      uint64_t v19 = v11;
      uint64_t v18 = (void **)((char *)&keys[1] - v36);
      int64_t v20 = v36;
    }

    else
    {
      if (v12 != 42) {
        return v13;
      }
      valuePtr.i8[0] = 51;
      uint64_t v13 = 1LL;
      bufferWrite(v11, &valuePtr, 1LL, v4);
      keys[0] = (void *)bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime(v10)));
      uint64_t v18 = keys;
      uint64_t v19 = v11;
      int64_t v20 = 8LL;
    }

    bufferWrite(v19, v18, v20, v4);
    return v13;
  }

  switch(v12)
  {
    case 18LL:
      CFIndex Count = CFDictionaryGetCount(v10);
      int64_t v15 = Count;
      char v16 = 15;
      if (Count < 15) {
        char v16 = Count;
      }
      char __src = v16 | 0xD0;
      bufferWrite(v11, &__src, 1LL, v4);
      if (v15 < 15)
      {
        uint64_t v17 = (const void **)keys;
        CFDictionaryGetKeysAndValues(v10, (const void **)keys, (const void **)&keys[v15]);
        if (v15 < 1) {
          goto LABEL_74;
        }
      }

      else
      {
        _appendInt(v11, v15, v4);
        else {
          uint64_t v17 = (const void **)keys;
        }
        CFDictionaryGetKeysAndValues(v10, v17, &v17[v15]);
      }

      uint64_t v37 = 0LL;
      if (2 * v15 <= 1) {
        uint64_t v38 = 1LL;
      }
      else {
        uint64_t v38 = 2 * v15;
      }
      while (1)
      {
        CFIndex v39 = v17[v37];
        if (v8)
        {
          valuePtr.i32[0] = 0;
          valuePtr.i32[0] = bswap32(CFDictionaryGetValue(v8, v39));
          bufferWrite(v11, &valuePtr.i8[-v6 + 4], v6, v4);
        }

        else if (!_appendObject(v11, v39, 0LL, v6, v4))
        {
          uint64_t v43 = v17;
          goto LABEL_71;
        }

        if (v38 == ++v37)
        {
          int64_t v40 = v17;
          goto LABEL_66;
        }
      }

    case 19LL:
      CFIndex v21 = CFArrayGetCount(v10);
      uint64_t v22 = v21;
      char v23 = 15;
      if (v21 < 15) {
        char v23 = v21;
      }
      char __src = v23 | 0xA0;
      bufferWrite(v11, &__src, 1LL, v4);
      if (v22 < 15)
      {
        unsigned __int8 v24 = (const void **)keys;
        v49.int location = 0LL;
        v49.CFIndex length = v22;
        CFArrayGetValues(v10, v49, (const void **)keys);
        if (v22 < 1) {
          goto LABEL_74;
        }
      }

      else
      {
        _appendInt(v11, v22, v4);
        else {
          unsigned __int8 v24 = (const void **)keys;
        }
        v50.int location = 0LL;
        v50.CFIndex length = v22;
        CFArrayGetValues(v10, v50, v24);
      }

      uint64_t v41 = 0LL;
      while (2)
      {
        CFIndex v42 = v24[v41];
        if (v8)
        {
          valuePtr.i32[0] = 0;
          valuePtr.i32[0] = bswap32(CFDictionaryGetValue(v8, v42));
          bufferWrite(v11, &valuePtr.i8[-v6 + 4], v6, v4);
          goto LABEL_63;
        }

        if (_appendObject(v11, v42, 0LL, v6, v4))
        {
LABEL_63:
          if (v22 == ++v41)
          {
            if (v24 != (const void **)keys)
            {
              int64_t v40 = v24;
LABEL_66:
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v40);
            }

            goto LABEL_74;
          }

          continue;
        }

        break;
      }

      if (v24 != (const void **)keys)
      {
        uint64_t v43 = v24;
LABEL_71:
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v43);
      }

      return 0LL;
    case 20LL:
      CFIndex Length = CFDataGetLength(v10);
      int64_t v26 = Length;
      char v27 = 15;
      if (Length < 15) {
        char v27 = Length;
      }
      LOBYTE(keys[0]) = v27 | 0x40;
      bufferWrite(v11, keys, 1LL, v4);
      if (v26 >= 15) {
        _appendInt(v11, v26, v4);
      }
      BytePtr = (int8x16_t *)CFDataGetBytePtr(v10);
      uint64_t v29 = v11;
      int64_t v30 = v26;
      goto LABEL_45;
    case 21LL:
      if (CFBooleanGetValue(v10)) {
        char v31 = 9;
      }
      else {
        char v31 = 8;
      }
      LOBYTE(keys[0]) = v31;
      uint64_t v13 = 1LL;
      bufferWrite(v11, keys, 1LL, v4);
      return v13;
    case 22LL:
      if (CFNumberIsFloatType(v10))
      {
        if (CFNumberGetByteSize(v10) > 4)
        {
          CFNumberGetValue(v10, kCFNumberFloat64Type, &valuePtr);
          keys[0] = (void *)bswap64(valuePtr.u64[0]);
          char v32 = 35;
          uint64_t v33 = 8LL;
        }

        else
        {
          CFNumberGetValue(v10, kCFNumberFloat32Type, &valuePtr);
          LODWORD(keys[0]) = bswap32(valuePtr.u32[0]);
          char v32 = 34;
          uint64_t v33 = 4LL;
        }

        valuePtr.i8[0] = v32;
        bufferWrite(v11, &valuePtr, 1LL, v4);
        uint64_t v29 = v11;
        BytePtr = (int8x16_t *)keys;
        int64_t v30 = v33;
        goto LABEL_45;
      }

      if (_CFNumberGetType2((unint64_t *)v10) == 17)
      {
        CFNumberGetValue(v10, kCFNumberMaxType|kCFNumberSInt8Type, keys);
        int8x16_t valuePtr = vrev64q_s8(*(int8x16_t *)keys);
        char __src = 20;
        bufferWrite(v11, &__src, 1LL, v4);
        BytePtr = &valuePtr;
        uint64_t v29 = v11;
        int64_t v30 = 16LL;
LABEL_45:
        bufferWrite(v29, BytePtr, v30, v4);
        goto LABEL_74;
      }

      CFNumberGetValue(v10, kCFNumberSInt64Type, keys);
      _appendInt(v11, (unint64_t)keys[0], v4);
LABEL_74:
      uint64_t v13 = 1LL;
      break;
    default:
      if (v12 != 7) {
        return v13;
      }
      _appendString(v11, (CFStringRef)v10, v4);
      goto LABEL_74;
  }

  return v13;
}

uint64_t __CFBinaryPlistWrite(const void *a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, a5);
}

uint64_t __CFBinaryPlistWriteToStream(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0LL);
}

uint64_t __CFBinaryPlistWriteToStreamWithEstimate(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0LL);
}

uint64_t __CFBinaryPlistWriteToStreamWithOptions(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0LL);
}

unint64_t *__CFBinaryPlistCreateDataUsingExternalBufferAllocator( const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v8 = __CFBinaryPlistWriteOrPresize(a1, 0LL, a3, a4, 1, a5);
  if (v8 < 1) {
    return 0LL;
  }
  unint64_t v9 = v8;
  uint64_t v10 = (const __CFAllocator *)(*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, v8);
  if (!v10)
  {
    if (!a5) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because an allocator could not be created.");
    goto LABEL_13;
  }

  uint64_t v11 = v10;
  int64_t v12 = (const UInt8 *)CFAllocatorAllocate(v10, v9, 0LL);
  if (!v12)
  {
    CFRelease(v11);
    if (!a5) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because an external buffer could not be allocated.");
    goto LABEL_13;
  }

  uint64_t v13 = (UInt8 *)v12;
  FixedMutableWithBuffer = _CFDataCreateFixedMutableWithBuffer(&__kCFAllocatorSystemDefault, v9, v12, v11);
  if (!FixedMutableWithBuffer)
  {
    CFAllocatorDeallocate(v11, v13);
    if (!a5) {
      return 0LL;
    }
    CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because a CFMutableDataRef using the external buffer could not be allocated.");
LABEL_13:
    int64_t v15 = 0LL;
    *a5 = Error;
    return v15;
  }

  int64_t v15 = FixedMutableWithBuffer;
  CFRelease(v11);
  if (v9 != __CFBinaryPlistWriteOrPresize(a1, v15, v16, v17, 0, a5))
  {
    CFRelease(v15);
    return 0LL;
  }

  return v15;
}

uint64_t __CFBinaryPlistGetTopLevelInfo( _DWORD *a1, unint64_t a2, _BYTE *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v5 = 0LL;
  if (a1 && a2 >= 0x29)
  {
    uint64_t v5 = 0LL;
    uint64_t v8 = (char *)a1 + a2;
    unint64_t v9 = bswap64(*(void *)((char *)a1 + a2 - 24));
    if ((uint64_t)v9 >= 1)
    {
      unint64_t v10 = bswap64(*((void *)v8 - 1));
      if ((v10 & 0x8000000000000000LL) == 0)
      {
        unint64_t v11 = bswap64(*((void *)v8 - 2));
        if (v9 > v11 && v10 >= 9 && a2 - 32 > v10)
        {
          unint64_t v12 = *(v8 - 26);
          if (!*(v8 - 26)) {
            return 0LL;
          }
          unsigned int v13 = *(v8 - 25);
          if (!*(v8 - 25)) {
            return 0LL;
          }
          if (!is_mul_ok(v9, v12)) {
            return 0LL;
          }
          unint64_t v14 = v9 * v12;
          if (!(v9 * v12) || v10 + v14 > 0xFFFFFFFFFFFFFFDFLL) {
            return 0LL;
          }
          uint64_t v5 = 0LL;
          if (v10 > ~v14 || v10 + v14 + 32 != a2) {
            return v5;
          }
          if (v13 <= 7 && v9 >> (8 * v13)
            || v12 <= 7 && v10 >> (8 * v12))
          {
            return 0LL;
          }

          uint64_t v5 = 0LL;
          BOOL v15 = __CFADD__(v10, a1);
          if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFF7LL && !v15)
          {
            if ((unint64_t)a1 + v10 <= -(uint64_t)v14)
            {
              uint64_t v16 = 0LL;
              uint64_t v17 = v8 - 32;
              if (v12 <= 1) {
                uint64_t v18 = 1LL;
              }
              else {
                uint64_t v18 = *(v8 - 26);
              }
              uint64_t v19 = (_DWORD *)((char *)a1 + v10);
              while (1)
              {
                switch((int)v12)
                {
                  case 1:
                    unint64_t v20 = *(unsigned __int8 *)v19;
                    break;
                  case 2:
                    unint64_t v20 = __rev16(*(unsigned __int16 *)v19);
                    break;
                  case 4:
                    unint64_t v20 = bswap32(*v19);
                    break;
                  case 8:
                    unint64_t v20 = bswap64(*(void *)v19);
                    break;
                  default:
                    uint64_t v21 = 0LL;
                    unint64_t v20 = 0LL;
                    do
                      unint64_t v20 = *((unsigned __int8 *)v19 + v21++) | (v20 << 8);
                    while (v18 != v21);
                    break;
                }

                if (v10 - 1 < v20) {
                  break;
                }
                uint64_t v19 = (unsigned int *)((char *)v19 + v12);
                if (++v16 == v9)
                {
                  uint64_t v22 = (_DWORD *)((char *)a1 + v10 + v11 * v12);
                  switch((int)v12)
                  {
                    case 1:
                      unint64_t v23 = *(unsigned __int8 *)v22;
                      break;
                    case 2:
                      unint64_t v23 = __rev16(*(unsigned __int16 *)v22);
                      break;
                    case 4:
                      unint64_t v23 = bswap32(*v22);
                      break;
                    case 8:
                      unint64_t v23 = bswap64(*(void *)v22);
                      break;
                    default:
                      unint64_t v23 = 0LL;
                      do
                      {
                        unsigned int v24 = *(unsigned __int8 *)v22;
                        uint64_t v22 = (unsigned int *)((char *)v22 + 1);
                        unint64_t v23 = v24 | (v23 << 8);
                        --v18;
                      }

                      while (v18);
                      break;
                  }

                  if (v23 >= 8 && v10 > v23)
                  {
                    if (a5)
                    {
                      int v26 = *(_DWORD *)v17;
                      *(_WORD *)(a5 + 4) = *((_WORD *)v17 + 2);
                      *(_DWORD *)a5 = v26;
                      *(_BYTE *)(a5 + 6) = v12;
                      *(_BYTE *)(a5 + 7) = v13;
                      *(void *)(a5 + 8) = v9;
                      *(void *)(a5 + 16) = v11;
                      *(void *)(a5 + 24) = v10;
                    }

                    if (a4) {
                      *a4 = v23;
                    }
                    if (a3) {
                      *a3 = *((_BYTE *)a1 + v23);
                    }
                    return 1LL;
                  }

                  return 0LL;
                }
              }
            }

            return 0LL;
          }
        }
      }
    }
  }

  return v5;
}

BOOL __CFBinaryPlistIsArray(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL result = 0LL;
  if (a3 >= 8 && *(void *)(a4 + 24) - 1LL >= a3) {
    return (*(_BYTE *)(a1 + a3) & 0xF0) == 160;
  }
  return result;
}

uint64_t __CFBinaryPlistGetOffsetForValueFromArray2( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v6 = 0LL;
  if (a3 < 8) {
    return v6;
  }
  uint64_t v7 = *(void *)(a4 + 24);
  uint64_t v8 = v7 - 1;
  if (v7 - 1 < a3) {
    return v6;
  }
  uint64_t v6 = 0LL;
  unint64_t v9 = (_BYTE *)(a1 + a3);
  if (a1 + a3 == -1LL) {
    return v6;
  }
  char v10 = *v9;
  if ((*v9 & 0xF0) != 0xA0) {
    return v6;
  }
  unint64_t v11 = v9 + 1;
  unint64_t v12 = v10 & 0xF;
  if ((v10 & 0xF) != 0xF)
  {
LABEL_24:
    if (v12 > a5)
    {
      unint64_t v20 = *(unsigned __int8 *)(a4 + 7);
      if (is_mul_ok(v12, v20))
      {
        uint64_t v6 = 0LL;
        uint64_t v21 = (unsigned int *)&v11[v20 * a5];
        if (a1 + 8 <= (unint64_t)v21)
        {
          uint64_t v22 = a1 + v7;
          if (a1 + v7 - v20 >= (unint64_t)v21)
          {
            unint64_t v23 = *(unsigned __int8 *)(a4 + 7);
            switch(*(_BYTE *)(a4 + 7))
            {
              case 0:
                break;
              case 1:
                unint64_t v23 = *(unsigned __int8 *)v21;
                break;
              case 2:
                unint64_t v23 = __rev16(*(unsigned __int16 *)v21);
                break;
              case 4:
                unint64_t v23 = bswap32(*v21);
                break;
              case 8:
                unint64_t v23 = bswap64(*(void *)v21);
                break;
              default:
                unint64_t v23 = 0LL;
                do
                {
                  unsigned int v24 = *(unsigned __int8 *)v21;
                  uint64_t v21 = (unsigned int *)((char *)v21 + 1);
                  unint64_t v23 = v24 | (v23 << 8);
                  --v20;
                }

                while (v20);
                break;
            }

            if (*(void *)(a4 + 8) > v23)
            {
              if (a6)
              {
                unint64_t v25 = *(unsigned __int8 *)(a4 + 6);
                int v26 = (unsigned int *)(v22 + v23 * v25);
                switch(*(_BYTE *)(a4 + 6))
                {
                  case 0:
                    break;
                  case 1:
                    unint64_t v25 = *(unsigned __int8 *)v26;
                    break;
                  case 2:
                    unint64_t v25 = __rev16(*(unsigned __int16 *)v26);
                    break;
                  case 4:
                    unint64_t v25 = bswap32(*v26);
                    break;
                  case 8:
                    unint64_t v25 = bswap64(*(void *)v26);
                    break;
                  default:
                    uint64_t v28 = *(unsigned __int8 *)(a4 + 6);
                    unint64_t v25 = 0LL;
                    do
                    {
                      unsigned int v29 = *(unsigned __int8 *)v26;
                      int v26 = (unsigned int *)((char *)v26 + 1);
                      unint64_t v25 = v29 | (v25 << 8);
                      --v28;
                    }

                    while (v28);
                    break;
                }

                *a6 = v25;
              }

              return 1LL;
            }
          }
        }
      }
    }

    return 0LL;
  }

  unsigned int v13 = v9 + 2;
  unsigned __int8 v14 = *v11;
  if ((*v11 & 0xF0) != 0x10) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  unsigned int v15 = v14 & 0xF;
  uint64_t v16 = 1LL << (v14 & 0xF);
  if (!__CFADD__(v16, v13) && (unint64_t)&v11[v16] <= a1 + v8)
  {
    switch((char)v16)
    {
      case 1:
        unint64_t v12 = *v13;
        goto LABEL_23;
      case 2:
        unint64_t v12 = __rev16(*(unsigned __int16 *)(v11 + 1));
        goto LABEL_23;
      case 4:
        unint64_t v12 = bswap32(*(_DWORD *)(v11 + 1));
        goto LABEL_23;
      case 8:
        unint64_t v12 = bswap64(*(void *)(v11 + 1));
        goto LABEL_22;
      default:
        if (v15 > 7)
        {
          unint64_t v12 = 0LL;
LABEL_23:
          unint64_t v11 = &v13[v16];
          goto LABEL_24;
        }

        unint64_t v12 = 0LL;
        if ((v16 & 0xFE) != 0) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = 1LL;
        }
        uint64_t v18 = v11 + 1;
        do
        {
          unsigned int v19 = *v18++;
          unint64_t v12 = v19 | (v12 << 8);
          --v17;
        }

        while (v17);
LABEL_22:
        if ((v12 & 0x8000000000000000LL) == 0) {
          goto LABEL_23;
        }
        break;
    }

    return 0LL;
  }

  return v6;
}

unint64_t __CFBinaryPlistIsDictionary(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = 0LL;
  if (a3 < 8) {
    return v4;
  }
  unint64_t v5 = *(void *)(a4 + 24) - 1LL;
  if (v5 < a3) {
    return v4;
  }
  unint64_t v4 = 0LL;
  uint64_t v6 = (_BYTE *)(a1 + a3);
  if (a1 + a3 == -1LL) {
    return v4;
  }
  char v7 = *v6;
  if ((*v6 & 0xF0) != 0xD0) {
    return v4;
  }
  uint64_t v8 = v6 + 1;
  unint64_t v4 = v7 & 0xF;
  if ((v7 & 0xF) != 0xF)
  {
LABEL_24:
    if (v4)
    {
      unint64_t v16 = 2 * v4;
      unint64_t v4 = v16 * *(unsigned __int8 *)(a4 + 7);
    }

    BOOL v17 = __CFADD__(v4, v8);
    LODWORD(v4) = a1 + v5 >= (unint64_t)&v8[v4 - 1];
    if (v17) {
      return 0LL;
    }
    else {
      return v4;
    }
  }

  unint64_t v9 = v6 + 2;
  unsigned __int8 v10 = *v8;
  if ((*v8 & 0xF0) != 0x10) {
    return 0LL;
  }
  unint64_t v4 = 0LL;
  unsigned int v11 = v10 & 0xF;
  uint64_t v12 = 1LL << (v10 & 0xF);
  if (!__CFADD__(v12, v9) && (unint64_t)&v8[v12] <= a1 + v5)
  {
    switch((char)v12)
    {
      case 1:
        unint64_t v4 = *v9;
        goto LABEL_23;
      case 2:
        unint64_t v4 = __rev16(*(unsigned __int16 *)(v8 + 1));
        goto LABEL_23;
      case 4:
        unint64_t v4 = bswap32(*(_DWORD *)(v8 + 1));
        goto LABEL_23;
      case 8:
        unint64_t v4 = bswap64(*(void *)(v8 + 1));
        goto LABEL_22;
      default:
        if (v11 > 7)
        {
          unint64_t v4 = 0LL;
LABEL_23:
          uint64_t v8 = &v9[v12];
          goto LABEL_24;
        }

        unint64_t v4 = 0LL;
        if ((v12 & 0xFE) != 0) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = 1LL;
        }
        unsigned __int8 v14 = v9;
        do
        {
          unsigned int v15 = *v14++;
          unint64_t v4 = v15 | (v4 << 8);
          --v13;
        }

        while (v13);
LABEL_22:
        if ((v4 & 0x8000000000000000LL) == 0) {
          goto LABEL_23;
        }
        break;
    }

    return 0LL;
  }

  return v4;
}

CFSetRef __CFBinaryPlistCopyTopLevelKeys( __objc2_class **a1, char *a2, int a3, unint64_t a4, uint64_t a5)
{
  CFSetRef v5 = 0LL;
  v42[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (a4 < 8) {
    return v5;
  }
  unint64_t v7 = *(void *)(a5 + 24) - 1LL;
  if (v7 < a4) {
    return v5;
  }
  CFSetRef v5 = 0LL;
  unint64_t v9 = &a2[a4];
  char v10 = *v9;
  if ((*v9 & 0xF0) != 0xD0) {
    return v5;
  }
  uint64_t v13 = (unsigned int *)(v9 + 1);
  unint64_t v14 = v10 & 0xF;
  if ((v10 & 0xF) == 0xF)
  {
    if (&a2[v7] >= (char *)v13)
    {
      unsigned int v15 = (unsigned __int8 *)(v9 + 2);
      char v16 = *(_BYTE *)v13;
      if ((*(_BYTE *)v13 & 0xF0) == 0x10)
      {
        CFSetRef v5 = 0LL;
        unsigned int v17 = v16 & 0xF;
        uint64_t v18 = 1LL << (v16 & 0xF);
        if (!__CFADD__(v18, v15) && (char *)v13 + v18 <= &a2[v7])
        {
          switch((char)v18)
          {
            case 1:
              unint64_t v14 = *v15;
              goto LABEL_23;
            case 2:
              unint64_t v14 = __rev16(*(unsigned __int16 *)((char *)v13 + 1));
              goto LABEL_23;
            case 4:
              unint64_t v14 = bswap32(*(unsigned int *)((char *)v13 + 1));
              goto LABEL_23;
            case 8:
              unint64_t v14 = bswap64(*(void *)((char *)v13 + 1));
              goto LABEL_22;
            default:
              if (v17 > 7)
              {
                unint64_t v14 = 0LL;
LABEL_23:
                uint64_t v13 = (unsigned int *)&v15[v18];
                goto LABEL_24;
              }

              unint64_t v14 = 0LL;
              if ((v18 & 0xFE) != 0) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = 1LL;
              }
              unint64_t v20 = (unsigned __int8 *)v13 + 1;
              do
              {
                unsigned int v21 = *v20++;
                unint64_t v14 = v21 | (v14 << 8);
                --v19;
              }

              while (v19);
LABEL_22:
              if ((v14 & 0x8000000000000000LL) == 0) {
                goto LABEL_23;
              }
              break;
          }

          return 0LL;
        }

        return v5;
      }
    }

    return 0LL;
  }

uint64_t __CFBinaryPlistCreateObjectFiltered( const void *Value, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, uint64_t a7, const __CFDictionary *a8, CFSetRef theSet, uint64_t a10, const __CFSet *a11, CFTypeRef *a12, CFTypeID *a13)
{
  v203[1] = *(__CFSet **)MEMORY[0x1895F89C0];
  if ((unint64_t)a10 >= 0x81)
  {
    uint64_t v13 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
      __CFBinaryPlistCreateObjectFiltered_cold_1(v13);
    }
    return 0LL;
  }

  uint64_t v20 = (uint64_t)Value;
  v195 = a5;
  v196 = a13;
  unint64_t v197 = ~a3;
  if (a8)
  {
    if (a12)
    {
      Value = CFDictionaryGetValue(a8, (const void *)v197);
      *a12 = Value;
      if (Value)
      {
        CFRetain(Value);
        if (v196) {
          CFTypeID *v196 = CFGetTypeID(*a12);
        }
        return 1LL;
      }
    }
  }

  v194 = (CFMutableSetRef *)a12;
  if (theSet)
  {
    Value = (const void *)CFSetContainsValue(theSet, (const void *)v197);
    if ((_DWORD)Value) {
      return 0LL;
    }
  }

  CFMutableDictionaryRef v193 = a8;
  BOOL v21 = 0LL;
  if (a3 < 8) {
    return v21;
  }
  v192 = theSet;
  unint64_t v23 = *(void *)(a4 + 24) - 1LL;
  if (v23 < a3) {
    return v21;
  }
  BOOL v21 = 0LL;
  unint64_t v24 = v20 + a3;
  unsigned int v25 = *(unsigned __int8 *)(v20 + a3);
  switch(v25 >> 4)
  {
    case 0u:
      if (v25 == 9)
      {
        if (v194) {
          CFMutableSetRef *v194 = (CFMutableSetRef)&__kCFBooleanTrue;
        }
        if (v196) {
          CFTypeID *v196 = 21LL;
        }
        return 1LL;
      }

      if (v25 == 8)
      {
        UniChar v47 = (uint64_t *)v196;
        if (v194) {
          CFMutableSetRef *v194 = (CFMutableSetRef)&__kCFBooleanFalse;
        }
        if (!v47) {
          return 1LL;
        }
        uint64_t v48 = 21LL;
      }

      else
      {
        UniChar v47 = (uint64_t *)v196;
        if (*(_BYTE *)(v20 + a3)) {
          return 0LL;
        }
        if (v194) {
          CFMutableSetRef *v194 = (CFMutableSetRef)&__kCFNull;
        }
        if (!v47) {
          return 1LL;
        }
        uint64_t v48 = 16LL;
      }

      *UniChar v47 = v48;
      return 1LL;
    case 1u:
      if (v24 == -1LL) {
        return 0LL;
      }
      unsigned int v49 = v25 & 0xF;
      uint64_t v50 = 1LL << (v25 & 0xF);
      if (v24 >= ~v50) {
        return 0LL;
      }
      BOOL v21 = 0LL;
      if (v49 > 4) {
        return v21;
      }
      uint64_t v51 = (unsigned int *)(v24 + 1);
      if (v20 + v23 < v24 + v50) {
        return v21;
      }
      switch((1LL << (v25 & 0xF)))
      {
        case 1u:
          unint64_t v52 = *(unsigned __int8 *)v51;
          goto LABEL_131;
        case 2u:
          unint64_t v52 = __rev16(*(unsigned __int16 *)v51);
          goto LABEL_131;
        case 4u:
          unint64_t v52 = bswap32(*v51);
          goto LABEL_131;
        case 8u:
          unint64_t v52 = bswap64(*(void *)v51);
LABEL_131:
          uint64_t v63 = v196;
          break;
        default:
          unint64_t v52 = 0LL;
          if ((v50 & 0xFE) != 0) {
            uint64_t v62 = (1LL << (v25 & 0xF));
          }
          else {
            uint64_t v62 = 1LL;
          }
          uint64_t v63 = v196;
          do
          {
            unsigned int v64 = *(unsigned __int8 *)v51;
            uint64_t v51 = (unsigned int *)((char *)v51 + 1);
            unint64_t v52 = v64 | (v52 << 8);
            --v62;
          }

          while (v62);
          break;
      }

      v203[0] = (__CFSet *)v52;
      if (v63) {
        CFTypeID *v63 = 22LL;
      }
      if (!v194) {
        return 1LL;
      }
      if (v49 < 4)
      {
        CFNumberRef v65 = CFNumberCreate((CFAllocatorRef)v195, kCFNumberSInt64Type, v203);
      }

      else
      {
        valuePtr[0] = 0LL;
        valuePtr[1] = (__CFSet *)v52;
        CFNumberRef v65 = CFNumberCreate((CFAllocatorRef)v195, kCFNumberMaxType|kCFNumberSInt8Type, valuePtr);
      }

      CFNumberRef v46 = v65;
      BOOL v21 = v65 != 0LL;
      if (v193 && v65) {
        goto LABEL_140;
      }
      goto LABEL_141;
    case 2u:
      if ((v25 & 0xF) == 3)
      {
        if (v24 == -1LL) {
          return 0LL;
        }
        BOOL v21 = 0LL;
        if (v24 > 0xFFFFFFFFFFFFFFF6LL || v20 + v23 < v24 + 8) {
          return v21;
        }
        valuePtr[0] = (__CFSet *)bswap64(*(void *)(v24 + 1));
        if (v196) {
          CFTypeID *v196 = 22LL;
        }
        if (v194)
        {
          CFNumberRef v46 = CFNumberCreate((CFAllocatorRef)v195, kCFNumberFloat64Type, valuePtr);
          BOOL v21 = v46 != 0LL;
          if (v46) {
            BOOL v58 = v193 != 0LL;
          }
          else {
            BOOL v58 = 0;
          }
          if (!v58) {
            goto LABEL_141;
          }
LABEL_140:
          CFDictionarySetValue(v193, (const void *)v197, v46);
LABEL_141:
          CFMutableSetRef *v194 = v46;
          return v21;
        }
      }

      else
      {
        if ((v25 & 0xF) != 2 || v24 == -1LL) {
          return 0LL;
        }
        BOOL v21 = 0LL;
        if (v24 > 0xFFFFFFFFFFFFFFFALL || v20 + v23 < v24 + 4) {
          return v21;
        }
        LODWORD(valuePtr[0]) = bswap32(*(_DWORD *)(v24 + 1));
        if (v196) {
          CFTypeID *v196 = 22LL;
        }
        if (v194)
        {
          CFNumberRef v46 = CFNumberCreate((CFAllocatorRef)v195, kCFNumberFloat32Type, valuePtr);
          BOOL v21 = v46 != 0LL;
          if (v46) {
            BOOL v53 = v193 != 0LL;
          }
          else {
            BOOL v53 = 0;
          }
          if (!v53) {
            goto LABEL_141;
          }
          goto LABEL_140;
        }
      }

      return 1LL;
    case 3u:
      BOOL v21 = 0LL;
      if (v24 == -1LL) {
        return v21;
      }
      if (v25 != 51) {
        return v21;
      }
      BOOL v21 = 0LL;
      if (v24 > 0xFFFFFFFFFFFFFFF6LL || v20 + v23 < v24 + 8) {
        return v21;
      }
      unint64_t v44 = *(void *)(v24 + 1);
      if (v196) {
        CFTypeID *v196 = 42LL;
      }
      if (!v194) {
        return 1LL;
      }
      CFDateRef v45 = CFDateCreate((CFAllocatorRef)v195, COERCE_CFABSOLUTETIME(bswap64(v44)));
      CFNumberRef v46 = v45;
      BOOL v21 = v45 != 0LL;
      if (v193 && v45) {
LABEL_121:
      }
        CFDictionarySetValue(v193, (const void *)v197, v46);
      goto LABEL_141;
    case 4u:
      if (v24 == -1LL) {
        return 0LL;
      }
      unsigned int v37 = (const UInt8 *)(v24 + 1);
      CFIndex v38 = v25 & 0xF;
      if ((v25 & 0xF) == 0xF)
      {
        if (v20 + v23 >= (unint64_t)v37)
        {
          CFIndex v39 = (unsigned __int8 *)(v24 + 2);
          UInt8 v40 = *v37;
          if ((*v37 & 0xF0) == 0x10)
          {
            BOOL v21 = 0LL;
            unsigned int v41 = v40 & 0xF;
            uint64_t v42 = 1LL << (v40 & 0xF);
            switch((char)v42)
            {
              case 1:
                CFIndex v38 = *v39;
                goto LABEL_398;
              case 2:
                CFIndex v38 = __rev16(*(unsigned __int16 *)(v24 + 2));
                goto LABEL_398;
              case 4:
                CFIndex v38 = bswap32(*(_DWORD *)(v24 + 2));
                goto LABEL_398;
              case 8:
                CFIndex v38 = bswap64(*(void *)(v24 + 2));
                goto LABEL_397;
              default:
                if (v41 <= 7)
                {
                  CFIndex v38 = 0LL;
                  if ((v42 & 0xFE) != 0) {
                    uint64_t v171 = v42;
                  }
                  else {
                    uint64_t v171 = 1LL;
                  }
                  uint64_t v172 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    unsigned int v173 = *v172++;
                    CFIndex v38 = v173 | (unint64_t)(v38 << 8);
                    --v171;
                  }

                  while (v171);
LABEL_397:
                  if (v38 < 0) {
                    return 0LL;
                  }
                }

                else
                {
                  CFIndex v38 = 0LL;
                }

LABEL_398:
                unsigned int v37 = &v39[v42];
                goto LABEL_399;
            }
          }
        }

        return 0LL;
      }

LABEL_399:
      BOOL v21 = 0LL;
      if (v196) {
        CFTypeID *v196 = 20LL;
      }
      if (v194)
      {
        if (a6 == 2LL)
        {
          CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)v195, 0LL);
          uint64_t v175 = Mutable;
          if (Mutable) {
            CFDataAppendBytes(Mutable, v37, v38);
          }
          BOOL v21 = v175 != 0LL;
        }

        else
        {
          CFDataRef v176 = CFDataCreate((CFAllocatorRef)v195, v37, v38);
          uint64_t v175 = v176;
          BOOL v21 = v176 != 0LL;
          if (v193 && v176)
          {
            CFDictionarySetValue(v193, (const void *)v197, v176);
            BOOL v21 = 1LL;
          }
        }

        CFMutableSetRef *v194 = v175;
        return v21;
      }

      return 1LL;
    case 5u:
      v201[0] = MEMORY[0x1895F87A8];
      v201[1] = 3221225472LL;
      v201[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke;
      v201[3] = &__block_descriptor_104_e12_B24__0r_8q16l;
      v201[4] = v196;
      v201[5] = v194;
      v201[6] = a6;
      v201[7] = a6;
      v201[8] = v195;
      v201[9] = a7;
      v201[10] = a3;
      v201[11] = v193;
      v201[12] = v197;
      return __CFBinaryPlistParseASCIIString(v20, v23, (_BYTE *)v24, (uint64_t)v201);
    case 6u:
      v200[0] = MEMORY[0x1895F87A8];
      v200[1] = 3221225472LL;
      v200[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke_2;
      v200[3] = &__block_descriptor_104_e13_B24__0r_S8q16l;
      v200[4] = v196;
      v200[5] = v194;
      v200[6] = a6;
      v200[7] = a6;
      v200[8] = v195;
      v200[9] = a7;
      v200[10] = a3;
      v200[11] = v193;
      v200[12] = v197;
      return __CFBinaryPlistParseUnicode16String(v20, v23, (_BYTE *)v24, (uint64_t)v200);
    case 8u:
      if (v24 != -1LL)
      {
        int v54 = (unsigned int *)(v24 + 1);
        uint64_t v55 = (v25 & 0xF) + 1LL;
        if (v24 < ~v55 && v20 + v23 >= v24 + v55)
        {
          switch(v25 & 0xF)
          {
            case 0u:
              LODWORD(v57) = *(unsigned __int8 *)v54;
              goto LABEL_110;
            case 1u:
              LODWORD(v57) = __rev16(*(unsigned __int16 *)v54);
              goto LABEL_110;
            case 3u:
              LODWORD(v57) = bswap32(*v54);
LABEL_110:
              CFIndex v59 = v196;
              goto LABEL_116;
            case 7u:
              unint64_t v57 = bswap64(*(void *)v54);
              CFIndex v59 = v196;
              goto LABEL_115;
            default:
              unint64_t v57 = 0LL;
              CFIndex v59 = v196;
              do
              {
                unsigned int v60 = *(unsigned __int8 *)v54;
                int v54 = (unsigned int *)((char *)v54 + 1);
                unint64_t v57 = v60 | (v57 << 8);
                --v55;
              }

              while (v55);
LABEL_115:
              if (HIDWORD(v57)) {
                return 0LL;
              }
LABEL_116:
              if (v59) {
                *CFIndex v59 = 41LL;
              }
              if (!v194) {
                return 1LL;
              }
              uint64_t Instance = _CFRuntimeCreateInstance( (const __CFAllocator *)v195,  0x29uLL,  8LL,  0LL,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8);
              CFNumberRef v46 = (CFNumberRef)Instance;
              BOOL v21 = Instance != 0;
              if (Instance)
              {
                *(_DWORD *)(Instance + 16) = v57;
                if (v193) {
                  goto LABEL_121;
                }
              }

              goto LABEL_141;
          }
        }
      }

      return 0LL;
    case 0xAu:
    case 0xCu:
      CFSetRef v190 = a11;
      uint64_t v191 = a6;
      if (v24 == -1LL) {
        return 0LL;
      }
      int v26 = (unsigned __int8 *)(v24 + 1);
      unint64_t v27 = v25 & 0xF;
      if ((v25 & 0xF) == 0xF)
      {
        if (v20 + v23 >= (unint64_t)v26)
        {
          uint64_t v28 = (unsigned __int8 *)(v24 + 2);
          unsigned __int8 v29 = *v26;
          if ((*v26 & 0xF0) == 0x10)
          {
            BOOL v21 = 0LL;
            unsigned int v30 = v29 & 0xF;
            uint64_t v31 = 1LL << (v29 & 0xF);
            switch((char)v31)
            {
              case 1:
                unint64_t v27 = *v28;
                goto LABEL_163;
              case 2:
                unint64_t v27 = __rev16(*(unsigned __int16 *)(v24 + 2));
                goto LABEL_163;
              case 4:
                unint64_t v27 = bswap32(*(_DWORD *)(v24 + 2));
                goto LABEL_163;
              case 8:
                unint64_t v27 = bswap64(*(void *)(v24 + 2));
                goto LABEL_162;
              default:
                if (v30 <= 7)
                {
                  unint64_t v27 = 0LL;
                  if ((v31 & 0xFE) != 0) {
                    uint64_t v66 = v31;
                  }
                  else {
                    uint64_t v66 = 1LL;
                  }
                  int v67 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    unsigned int v68 = *v67++;
                    unint64_t v27 = v68 | (v27 << 8);
                    --v66;
                  }

                  while (v66);
LABEL_162:
                  if ((v27 & 0x8000000000000000LL) != 0) {
                    return 0LL;
                  }
                }

                else
                {
                  unint64_t v27 = 0LL;
                }

LABEL_163:
                int v26 = &v28[v31];
                goto LABEL_164;
            }
          }
        }

        return 0LL;
      }

    LOBYTE(v50) = v151;
    unsigned int v49 = v140;
    UniChar v47 = v141;
  }

  else if (v50)
  {
    copyBlocks(v84, v52, v149, v83, 1, a2, v154, a4);
  }

  if (v47)
  {
    BOOL v87 = atomic_load(v5);
    if ((v87 & 0x20) != 0) {
      __CFStrDeallocateMutableContents((uint64_t)v155, v51);
    }
    UniChar v47 = 1;
  }

  BOOL result = v143;
  unsigned __int8 v29 = v144;
LABEL_171:
  if ((v50 & 1) != 0)
  {
    int64_t v88 = (unint64_t *)v155;
    if (!v53)
    {
      uint64_t v89 = atomic_load(v5);
      while (1)
      {
        uint64_t v90 = __ldaxr(v5);
        if (v90 != v89) {
          break;
        }
        if (__stlxr(v89 | 0x10, v5)) {
          goto LABEL_178;
        }
        uint64_t v91 = 1;
LABEL_179:
        uint64_t v89 = v90;
        if (v91) {
          goto LABEL_180;
        }
      }

      __clrex();
LABEL_178:
      uint64_t v91 = 0;
      goto LABEL_179;
    }

LABEL_164:
      if (v27)
      {
        unint64_t v69 = v27 * *(unsigned __int8 *)(a4 + 7);
        uint64_t v189 = v27;
      }

      else
      {
        uint64_t v189 = 0LL;
        unint64_t v69 = 0LL;
      }

      BOOL v21 = 0LL;
      if (__CFADD__(v69, v26)) {
        return v21;
      }
      v186 = (const void **)v26;
      if (v27)
      {
        uint64_t v187 = (char *)v27;
        uint64_t v70 = 8 * v189;
      }

      else
      {
        uint64_t v187 = 0LL;
        uint64_t v70 = 0LL;
      }

      MEMORY[0x1895F8858](Value, v70);
      CFIndex v74 = (__CFSet **)&v178[-v72];
      uint64_t v185 = v75;
      if (v194)
      {
        int v188 = (__CFSet **)&v178[-v72];
        if (v73 >= 0x101)
        {
          int v188 = (__CFSet **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v71, 0LL);
          if (!v188) {
            return 0LL;
          }
        }
      }

      else
      {
        int v188 = 0LL;
      }

      CFIndex v181 = v74;
      int v76 = 0LL;
      if (!v192 && a10 >= 16)
      {
        int v76 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL);
        v192 = v76;
      }

      char v182 = v76;
      if (v192) {
        CFSetAddValue(v192, (const void *)v197);
      }
      CFAllocatorRef v180 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      CFSetRef v77 = v190;
      __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, v190, valuePtr, v203);
      int v179 = v25 & 0xF0;
      if (v77) {
        BOOL v83 = (v25 & 0xF0) == 160;
      }
      else {
        BOOL v83 = 0;
      }
      int v84 = !v83;
      if (valuePtr[0])
      {
        int v85 = CFSetContainsValue(valuePtr[0], @"*");
        v86 = (const __CFAllocator *)v195;
        BOOL v87 = v85 != 0;
      }

      else
      {
        BOOL v87 = 0;
        v86 = (const __CFAllocator *)v195;
      }

      if ((v84 | v87) == 1)
      {
        int64_t v88 = (unsigned int *)v186;
        if (v189)
        {
          uint64_t v89 = 0LL;
          CFSetRef v190 = (CFSetRef)(v20 + 8);
          uint64_t v90 = (unint64_t *)&v199;
          if (!v194) {
            uint64_t v90 = 0LL;
          }
          uint64_t v183 = (uint64_t)v90;
          char v184 = (const void **)(a10 + 1);
          uint64_t v91 = -1LL;
          while (v190 <= (CFSetRef)v88)
          {
            int64_t v92 = v88;
            uint64_t v93 = v20 + *(void *)(a4 + 24);
            uint64_t v94 = *(unsigned __int8 *)(a4 + 7);
            unint64_t v95 = *(unsigned __int8 *)(a4 + 7);
            switch(*(_BYTE *)(a4 + 7))
            {
              case 0:
                break;
              case 1:
                unint64_t v95 = *(unsigned __int8 *)v92;
                break;
              case 2:
                unint64_t v95 = __rev16(*(unsigned __int16 *)v92);
                break;
              case 4:
                unint64_t v95 = bswap32(*v92);
                break;
              case 8:
                unint64_t v95 = bswap64(*(void *)v92);
                break;
              default:
                unint64_t v95 = 0LL;
                CFRange v96 = v92;
                do
                {
                  unsigned int v97 = *(unsigned __int8 *)v96;
                  CFRange v96 = (unsigned int *)((char *)v96 + 1);
                  unint64_t v95 = v97 | (v95 << 8);
                  --v94;
                }

                while (v94);
                break;
            }

            if (*(void *)(a4 + 8) <= v95) {
              break;
            }
            uint64_t v98 = *(unsigned __int8 *)(a4 + 6);
            UniChar v99 = (unsigned int *)(v93 + v95 * v98);
            switch(*(_BYTE *)(a4 + 6))
            {
              case 0:
                break;
              case 1:
                LODWORD(v98) = *(unsigned __int8 *)v99;
                break;
              case 2:
                LODWORD(v98) = __rev16(*(unsigned __int16 *)v99);
                break;
              case 4:
                LODWORD(v98) = bswap32(*v99);
                break;
              case 8:
                LODWORD(v98) = bswap64(*(void *)v99);
                break;
              default:
                uint64_t v100 = *(unsigned __int8 *)(a4 + 6);
                LODWORD(v98) = 0;
                do
                {
                  int v101 = *(unsigned __int8 *)v99;
                  UniChar v99 = (unsigned int *)((char *)v99 + 1);
                  LODWORD(v98) = v101 | ((_DWORD)v98 << 8);
                  --v100;
                }

                while (v100);
                break;
            }

            v199 = 0LL;
            UniChar v102 = v203[0];
            if (v84) {
              UniChar v102 = 0LL;
            }
            if ((__CFBinaryPlistCreateObjectFiltered( v20,  a2,  v98,  a4,  (int)v195,  a6,  a7,  (int)v193,  v192,  (uint64_t)v184,  (uint64_t)v102,  v183,  0LL) & 1) == 0)
            {
              CFIndex v127 = v188;
              if (v188)
              {
                while (v91 != -1)
                {
                  CFRange v128 = v127[v91--];
                  CFRelease(v128);
                }

                if (v127 != v181) {
                  CFAllocatorDeallocate(v180, v188);
                }
              }

              goto LABEL_281;
            }

            if (v188) {
              v188[v89] = v199;
            }
            int64_t v88 = (unsigned int *)((char *)v92 + *(unsigned __int8 *)(a4 + 7));
            ++v89;
            ++v91;
            if (v89 >= v189) {
              goto LABEL_223;
            }
          }

          v119 = v188;
          if (v188)
          {
            v120 = v181;
            while (v91 != -1)
            {
              int64_t v121 = v119[v91--];
              CFRelease(v121);
            }

            if (v119 != v120) {
              CFAllocatorDeallocate(v180, v119);
            }
          }

LABEL_281:
          BOOL v21 = 0LL;
          goto LABEL_302;
        }

    *BOOL v87 = v91 + 1;
    *int64_t v88 = v84 + ~v91;
    *v92 |= 0x80u;
    BOOL v83 = __count;
LABEL_276:
    ++v83;
  }

  while (v79 > (int)v84);
  CFIndex v74 = alloc;
  p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
LABEL_290:
  unsigned int v156 = (int)a9;
  uint64_t v157 = 3 * (v49 + (_DWORD)a9) + 1;
  v158 = v525;
  if (v157 >= 62)
  {
    v158 = CFAllocatorAllocate(v74, 16LL * (3 * (v49 + (_DWORD)a9) + 1), 0LL);
    if (v158 != v525)
    {
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }

  bzero(v158, 16LL * v157);
  if (v486 >= 1) {
    v519 = a13;
  }
  __srcb = v158;
  uint64_t v72 = v513;
  if ((_DWORD)v83)
  {
    int v160 = 0LL;
    if (v472) {
      int64_t v161 = theDict == 0LL;
    }
    else {
      int64_t v161 = 1;
    }
    uint64_t v162 = !v161;
    v474 = v162;
    uint64_t v163 = v83;
    uint64_t v164 = v157;
    v478 = a9;
    while (2)
    {
      char v165 = &v72[32 * v160];
      CFDictionaryRef v166 = *((unsigned __int16 *)v165 + 1);
      uint64_t v167 = (1LL << v166) & 0x180100000001LL;
      if (v166 <= 0x2C && v167 != 0) {
        goto LABEL_308;
      }
      uint64_t v169 = v164 - 1;
      uint64_t v170 = v165 + 24;
      uint64_t v172 = v165 + 25;
      uint64_t v171 = (char)v165[25];
      if (v169 > v171) {
        uint64_t v171 = v169;
      }
      unsigned int v173 = v165 + 26;
      v509 = v165 + 26;
      if (v164 > v171)
      {
        int v174 = v165[26];
        goto LABEL_332;
      }

      uint64_t v175 = 3 * v171 + 1;
      if (v171 < 21)
      {
        BOOL v177 = __srcb;
      }

      else
      {
        CFDataRef v176 = (char *)CFAllocatorAllocate(alloc, 16LL * (3 * v171 + 1), 0LL);
        BOOL v177 = v176;
        if (v176 != v525 && __CFOASafe != 0)
        {
          __CFSetLastAllocationEventName();
          goto LABEL_327;
        }

        if (v176 == v525)
        {
          uint64_t v72 = v513;
          BOOL v177 = __srcb;
        }

        else
        {
LABEL_327:
          memcpy(v177, __srcb, 16LL * v164);
          bzero(&v177[16 * v164], 16 * (v175 - (uint64_t)v164));
          if (__srcb != v525) {
            CFAllocatorDeallocate(alloc, __srcb);
          }
          uint64_t v72 = v513;
          p_info = &OBJC_METACLASS_____NSCFTimer.info;
        }

        uint64_t v172 = v165 + 25;
        unsigned int v173 = v165 + 26;
        uint64_t v170 = v165 + 24;
      }

      int v174 = *v173;
      __srcb = v177;
      uint64_t v164 = v175;
LABEL_332:
      if (v174 == 254)
      {
        void *v173 = v156;
        ++v156;
      }

      if (*v172 == 254)
      {
        *uint64_t v172 = v156;
        ++v156;
      }

      int v179 = *v170;
      if (v179 == 255)
      {
        *uint64_t v170 = v156;
        if (((char)v156 - 127) <= 0xFFFFFEFF)
        {
LABEL_899:
          if (a15)
          {
            v444 = _CFGetTSD(1u);
            if (v444) {
              v445 = (const __CFAllocator *)v444;
            }
            else {
              v445 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
            }
            v446 = CFDictionaryCreateMutable( v445,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v446, @"NSDebugDescription", @"Overflow occurred");
            v447 = CFErrorCreate(v445, @"NSCocoaErrorDomain", 2048LL, v446);
            CFRelease(v446);
            uint64_t v72 = v513;
            *a15 = v447;
          }

          unint64_t v44 = alloc;
          goto LABEL_905;
        }

        LOBYTE(v179) = v156++;
      }

      CFAllocatorRef v180 = &__srcb[16 * (char)v179];
      *((_WORD *)v180 + 1) = *(_WORD *)v165;
      CFIndex v181 = *((unsigned __int16 *)v165 + 1);
      *(_WORD *)CFAllocatorRef v180 = v181;
      char v182 = (char)v72[32 * v160 + 27];
      if (v182 == -1)
      {
        CFIndex v59 = v181 == 32;
        v192 = v474;
        if (v59) {
          v192 = 0;
        }
        if (v192 == 1)
        {
          CFMutableDictionaryRef v193 = v172;
          v194 = &v72[32 * v160];
          v195 = *((int *)v194 + 1);
          v196 = *((int *)v194 + 2);
          unint64_t v44 = alloc;
          unint64_t v197 = v495;
          if (v495)
          {
            v198 = *((unsigned int *)p_info + 175);
            if ((_DWORD)v198 == -1)
            {
              __CFStringComputeEightBitStringEncoding();
              unint64_t v197 = v495;
              v198 = *((unsigned int *)p_info + 175);
            }

            v199 = (int8x16_t *)(v197 + v195);
            v200 = (__objc2_class **)alloc;
            v201 = v196;
            v202 = 18LL;
          }

          else
          {
            v201 = 2 * v196;
            v199 = (int8x16_t *)(v494 + 2 * v195);
            v200 = (__objc2_class **)alloc;
            v198 = 256LL;
            v202 = 16LL;
          }

          v232 = __CFStringCreateImmutableFunnel3(v200, v199, v201, v198, v202, (uint64_t)&__kCFAllocatorNull, 0LL, v159);
          uint64_t v70 = v487;
          if (!v232)
          {
            v449 = CFDictionaryCreateMutable( alloc,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue( v449,  @"NSDebugDescription",  @"Unable to allocate CFString to validate format specifiers");
            *a15 = CFErrorCreate(alloc, @"NSCocoaErrorDomain", 2048LL, v449);
            CFRelease(v449);
            CFDateRef v45 = v469;
LABEL_908:
            uint64_t v72 = v513;
LABEL_909:
            CFIndex v71 = __srcb;
LABEL_910:
            unsigned __int8 v29 = a14;
            goto LABEL_876;
          }

          v233 = __CFStringValidateFormat((uint64_t)v472, (uint64_t)v232);
          CFRelease(v232);
          uint64_t v72 = v513;
          v478 = (CFMutableStringRef)v233;
          uint64_t v172 = v193;
          if (v233 < 0)
          {
            unint64_t v44 = alloc;
            CFDateRef v45 = v469;
            goto LABEL_909;
          }
        }
      }

      else
      {
        v497 = v170;
        uint64_t v183 = v172;
        char v184 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)v487[v182],  @"NSStringFormatValueTypeKey");
        if (v184)
        {
          uint64_t v185 = (unint64_t *)v184;
          CharactersPtr = (UniChar *)CFStringGetCharactersPtr(v184);
          uint64_t v187 = *((_DWORD *)p_info + 175);
          if (v187 == -1)
          {
            __CFStringComputeEightBitStringEncoding();
            uint64_t v187 = *((_DWORD *)p_info + 175);
          }

          CStringPtrInternal = _CFStringGetCStringPtrInternal(v185, v187, 1, 1);
          uint64_t v189 = CFStringGetLength((CFStringRef)v185);
          CFSetRef v190 = v189;
          if ((unint64_t)CharactersPtr | CStringPtrInternal)
          {
            uint64_t v191 = 0LL;
          }

          else
          {
            CharactersPtr = (UniChar *)CFAllocatorAllocate(alloc, 2 * v189, 0LL);
            v529.int location = 0LL;
            v529.CFIndex length = v190;
            CFStringGetCharacters((CFStringRef)v185, v529, CharactersPtr);
            uint64_t v191 = CharactersPtr;
          }

          v476 = (const __CFString *)v185;
          if ((int)v190 < 1)
          {
            uint64_t v219 = 0;
            CFRange v220 = 43;
          }

          else
          {
            v203 = 0;
            CFRange v204 = 0;
            cf2 = 0;
            v205 = 0;
            key = -1;
            uint64_t v206 = -1LL;
            int64_t v207 = -1;
            do
            {
              if (CStringPtrInternal) {
                int64_t v208 = *(unsigned __int8 *)(CStringPtrInternal + v205);
              }
              else {
                int64_t v208 = CharactersPtr[v205];
              }
              ++v205;
              if (v206 < 0)
              {
                while (2)
                {
                  int v213 = 0LL;
                  else {
                    v214 = v205;
                  }
                  int v215 = &CharactersPtr[v205];
                  v216 = v205;
                  v217 = v205 - (uint64_t)v214;
                  while (2)
                  {
                    uint64_t v218 = CharactersPtr;
                    uint64_t v219 = 1;
                    CFRange v220 = 33;
                    switch(v208)
                    {
                      case ' ':
                      case '+':
                      case '-':
                      case '0':
                        v205 += v213;
                        goto LABEL_422;
                      case '#':
                        v205 += v213;
                        CFRange v204 = 1;
                        goto LABEL_422;
                      case '*':
                        v205 += v213;
                        int64_t v207 = -2;
                        goto LABEL_422;
                      case '.':
                        if (!(v217 + v213)) {
                          goto LABEL_446;
                        }
                        if (CStringPtrInternal) {
                          int64_t v208 = *(unsigned __int8 *)(CStringPtrInternal + v205 + v213);
                        }
                        else {
                          int64_t v208 = v215[v213];
                        }
                        CharactersPtr = v218;
                        ++v213;
                        ++v216;
                        if (v208 != 42) {
                          continue;
                        }
                        v205 += v213;
                        key = -2;
                        goto LABEL_423;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        CFRange v221 = 0LL;
                        CFRange v222 = v205 + v213;
                        v205 = v216;
                        CharactersPtr = v218;
                        break;
                      case '@':
                        if (!v204) {
                          goto LABEL_472;
                        }
                        CFRange v204 = 0;
                        uint64_t v206 = v213 + v205;
                        v205 += v213;
                        goto LABEL_422;
                      case 'A':
                      case 'a':
                        goto LABEL_448;
                      case 'C':
                        uint64_t v219 = 2;
                        CFRange v220 = 41;
                        goto LABEL_456;
                      case 'D':
                      case 'U':
                      case 'd':
                      case 'i':
                      case 'u':
                        v235 = v191;
                        _CFExecutableLinkedOnOrAfter(8uLL);
                        uint64_t v191 = v235;
                        goto LABEL_453;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        v234 = v191;
                        _CFExecutableLinkedOnOrAfter(8uLL);
                        uint64_t v191 = v234;
LABEL_448:
                        if (cf2 == 5) {
                          uint64_t v219 = 5;
                        }
                        else {
                          uint64_t v219 = 4;
                        }
                        CFRange v220 = 34;
                        goto LABEL_456;
                      case 'L':
                        v205 += v213;
                        CFRange v225 = 5;
                        goto LABEL_409;
                      case 'O':
                      case 'X':
                      case 'o':
                      case 'x':
LABEL_453:
                        CFRange v220 = 33;
                        goto LABEL_455;
                      case 'P':
                        uint64_t v219 = 4;
                        CFRange v220 = 40;
                        goto LABEL_456;
                      case 'S':
                        uint64_t v219 = 4;
                        CFRange v220 = 38;
                        goto LABEL_456;
                      case '[':
                        v226 = v213 + v205;
                        v205 += v213;
                        if (!v203) {
                          uint64_t v206 = v226;
                        }
                        v203 = 1;
                        goto LABEL_422;
                      case 'c':
                        goto LABEL_456;
                      case 'h':
                        v227 = v213 + v205;
                        if ((int)v213 + v205 >= (int)v190)
                        {
                          v230 = 2;
                          goto LABEL_421;
                        }

                        if (CStringPtrInternal) {
                          v228 = *(unsigned __int8 *)(CStringPtrInternal + v205 + v213);
                        }
                        else {
                          v228 = v215[v213];
                        }
                        CharactersPtr = v218;
                        if (v228 == 104) {
                          ++v205;
                        }
                        v205 += v213;
                        if (v228 == 104) {
                          v231 = 1;
                        }
                        else {
                          v231 = 2;
                        }
                        goto LABEL_435;
                      case 'j':
                      case 'q':
                      case 't':
                      case 'z':
                        v205 += v213;
                        CFRange v225 = 4;
LABEL_409:
                        cf2 = v225;
                        goto LABEL_422;
                      case 'l':
                        v227 = v213 + v205;
                        if ((int)v213 + v205 >= (int)v190)
                        {
                          v230 = 4;
LABEL_421:
                          cf2 = v230;
                          v205 = v227;
                          goto LABEL_422;
                        }

                        if (CStringPtrInternal) {
                          v229 = *(unsigned __int8 *)(CStringPtrInternal + v205 + v213);
                        }
                        else {
                          v229 = v215[v213];
                        }
                        CharactersPtr = v218;
                        if (v229 == 108) {
                          ++v205;
                        }
                        v205 += v213;
                        v231 = 4;
LABEL_435:
                        cf2 = v231;
                        goto LABEL_423;
                      case 'n':
                        uint64_t v219 = 4;
                        CFRange v220 = 42;
                        goto LABEL_456;
                      case 'p':
                        uint64_t v219 = 4;
                        CFRange v220 = 35;
                        goto LABEL_456;
                      case 's':
                        uint64_t v219 = 4;
                        CFRange v220 = 39;
                        goto LABEL_456;
                      default:
                        CFRange v220 = 32;
                        goto LABEL_455;
                    }

                    break;
                  }

                  do
                  {
                    CFRange v223 = 10 * v221;
                    CFRange v224 = v208 - 48LL;
                    CFRange v221 = v223 + v224;
                    if (__OFADD__(v223, v224)) {
                      goto LABEL_454;
                    }
                    if (CStringPtrInternal) {
                      int64_t v208 = *(unsigned __int8 *)(CStringPtrInternal + v222);
                    }
                    else {
                      int64_t v208 = v218[v222];
                    }
                    ++v222;
                    ++v205;
                  }

                  while (v208 - 48 < 0xA);
                  if (v208 != 36)
                  {
                    if (v221 <= 0x7FFFFFFF) {
                      continue;
                    }
LABEL_454:
                    CFRange v220 = 0;
                    goto LABEL_455;
                  }

                  break;
                }

                if (v221 > 127) {
                  goto LABEL_454;
                }
                if (key == 254)
                {
                  key = v221 - 1;
                }

                else if (v207 == 254)
                {
                  int64_t v207 = v221 - 1;
                }

LABEL_223:
        if (v179 != 160)
        {
          if (!v194)
          {
LABEL_273:
            int v109 = 1;
            uint64_t v106 = 17LL;
LABEL_275:
            v108 = (uint64_t *)v196;
            goto LABEL_286;
          }

          if (v191)
          {
            CFMutableSetRef v103 = CFSetCreateMutable((CFAllocatorRef)v195, 0LL, &kCFTypeSetCallBacks);
            CFMutableSetRef *v194 = v103;
            if (v189)
            {
              char v105 = v187;
              CFURLRef v104 = (const void **)v188;
              do
              {
                CFSetAddValue(*v194, *v104++);
                --v105;
              }

              while (v105);
              if (v189)
              {
                uint64_t v106 = 17LL;
                v107 = (CFTypeRef *)v188;
                v108 = (uint64_t *)v196;
                int v109 = 1;
                do
                {
                  CFRelease(*v107++);
                  --v187;
                }

                while (v187);
                goto LABEL_286;
              }
            }

            goto LABEL_273;
          }

          uint64_t Transfer = __CFSetCreateTransfer((uint64_t)v195, (unint64_t *)v188, v189);
          uint64_t v106 = 17LL;
LABEL_284:
          v108 = (uint64_t *)v196;
LABEL_285:
          CFMutableSetRef *v194 = (CFMutableSetRef)Transfer;
          int v109 = 1;
          goto LABEL_286;
        }

        if (v194)
        {
          if (!v191)
          {
            uint64_t Transfer = (uint64_t)__CFArrayCreateTransfer( (const __CFAllocator *)v195,  v188,  v189,  v78,  v79,  v80,  v81,  v82);
            uint64_t v106 = 19LL;
            goto LABEL_284;
          }

          int64_t v122 = CFArrayCreateMutable((CFAllocatorRef)v195, 0LL, &kCFTypeArrayCallBacks);
          CFMutableSetRef *v194 = v122;
          v204.int location = 0LL;
          v204.CFIndex length = 0LL;
          CFArrayReplaceValues(v122, v204, (const void **)v188, v189);
          if (v189)
          {
            uint64_t v106 = 19LL;
            v123 = (CFTypeRef *)v188;
            do
            {
              CFRelease(*v123++);
              --v187;
            }

            while (v187);
            int v109 = 1;
            goto LABEL_275;
          }
        }

        int v109 = 1;
        uint64_t v106 = 19LL;
        goto LABEL_275;
      }

      CFIndex Count = CFSetGetCount(valuePtr[0]);
      v108 = (uint64_t *)v196;
      uint64_t v189 = (uint64_t)CFArrayCreateMutable(v86, Count, &kCFTypeArrayCallBacks);
      if (!valuePtr[0])
      {
        int v109 = 1;
        goto LABEL_265;
      }

      CFIndex v111 = CFSetGetCount(valuePtr[0]);
      char v184 = (const void **)malloc(8 * v111);
      CFSetGetValues(valuePtr[0], v184);
      CFIndex v112 = CFSetGetCount(valuePtr[0]);
      if (v112 < 1)
      {
        int v109 = 1;
        goto LABEL_264;
      }

      CFSetRef v190 = (CFSetRef)v112;
      uint64_t v113 = &v198;
      if (!v194) {
        uint64_t v113 = 0LL;
      }
      v186 = v113;
      uint64_t v187 = (char *)(a10 + 1);
      uint64_t v114 = (CFStringRef *)v184;
      while (2)
      {
        uint64_t v115 = *v114;
        SInt32 IntValue = CFStringGetIntValue(*v114);
        unsigned int v118 = IntValue;
        if (IntValue == 0x7FFFFFFF) {
          goto LABEL_247;
        }
        if (IntValue)
        {
          if (IntValue < 0) {
            goto LABEL_247;
          }
        }

        else if (CFStringCompare(@"0", v115, 0LL))
        {
          goto LABEL_247;
        }

        if (!__CFBinaryPlistGetOffsetForValueFromArray2( v20,  v117,  a3,  a4,  v118,  (unint64_t *)&v199)) {
          goto LABEL_247;
        }
        v198 = 0LL;
        if (__CFBinaryPlistCreateObjectFiltered( v20,  a2,  (int)v199,  a4,  (int)v195,  a6,  a7,  (int)v193,  v192,  (uint64_t)v187,  (uint64_t)v203[0],  (uint64_t)v186,  0LL))
        {
          if (v198)
          {
            CFArrayAppendValue((CFMutableArrayRef)v189, v198);
            CFRelease(v198);
          }

LABEL_247:
          ++v114;
          CFSetRef v190 = (CFSetRef)((char *)v190 - 1);
          if (!v190)
          {
            int v109 = 1;
            goto LABEL_249;
          }

          continue;
        }

        break;
      }

      int v109 = 0;
LABEL_249:
      v108 = (uint64_t *)v196;
LABEL_264:
      free(v184);
LABEL_265:
      if (v194 && v109)
      {
        if ((unint64_t)(v191 - 1) < 2)
        {
          uint64_t v106 = 19LL;
          uint64_t Transfer = v189;
          goto LABEL_285;
        }

        uint64_t v125 = (const void *)v189;
        CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)v195, (CFArrayRef)v189);
        CFMutableSetRef *v194 = Copy;
        CFRelease(v125);
        int v109 = 1;
      }

      else if (v189)
      {
        CFRelease((CFTypeRef)v189);
      }

      uint64_t v106 = 19LL;
LABEL_286:
      if (v108) {
        uint64_t *v108 = v106;
      }
      if (v192) {
        CFSetRemoveValue(v192, (const void *)v197);
      }
      BOOL v21 = v109 != 0;
      if (v194 && v193 && !v191 && v109) {
        CFDictionarySetValue(v193, (const void *)v197, *v194);
      }
      if (v188 && v188 != v181) {
        CFAllocatorDeallocate(v180, v188);
      }
      if (valuePtr[0]) {
        CFRelease(valuePtr[0]);
      }
      if (v203[0]) {
        CFRelease(v203[0]);
      }
LABEL_302:
      if (v182) {
        CFRelease(v182);
      }
      return v21;
    case 0xDu:
      uint64_t v191 = a6;
      if (v24 == -1LL) {
        return 0LL;
      }
      char v32 = (unsigned __int8 *)(v24 + 1);
      unint64_t v33 = v25 & 0xF;
      if ((v25 & 0xF) == 0xF)
      {
        if (v20 + v23 >= (unint64_t)v32)
        {
          unint64_t v34 = (unsigned __int8 *)(v24 + 2);
          if ((*v32 & 0xF0) == 0x10)
          {
            BOOL v21 = 0LL;
            unsigned int v35 = *v32 & 0xF;
            uint64_t v36 = 1LL << v35;
            switch((1LL << v35))
            {
              case 1u:
                unint64_t v33 = *v34;
                goto LABEL_312;
              case 2u:
                unint64_t v33 = __rev16(*(unsigned __int16 *)(v24 + 2));
                goto LABEL_312;
              case 4u:
                unint64_t v33 = bswap32(*(_DWORD *)(v24 + 2));
                goto LABEL_312;
              case 8u:
                unint64_t v33 = bswap64(*(void *)(v24 + 2));
                goto LABEL_311;
              default:
                if (v35 <= 7)
                {
                  unint64_t v33 = 0LL;
                  if ((v36 & 0xFE) != 0) {
                    uint64_t v129 = v36;
                  }
                  else {
                    uint64_t v129 = 1LL;
                  }
                  v130 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    unsigned int v131 = *v130++;
                    unint64_t v33 = v131 | (v33 << 8);
                    --v129;
                  }

                  while (v129);
LABEL_311:
                  if ((v33 & 0x8000000000000000LL) != 0) {
                    return 0LL;
                  }
                }

                else
                {
                  unint64_t v33 = 0LL;
                }

LABEL_312:
                char v32 = &v34[v36];
                goto LABEL_313;
            }
          }
        }

        return 0LL;
      }

LABEL_313:
      if (v33)
      {
        unint64_t v132 = 2 * v33;
        int64_t v133 = (const __CFSet *)(a4 + 7);
        unint64_t v134 = v132 * *(unsigned __int8 *)(a4 + 7);
      }

      else
      {
        unint64_t v134 = 0LL;
        unint64_t v132 = 0LL;
        int64_t v133 = (const __CFSet *)(a4 + 7);
      }

      BOOL v21 = 0LL;
      if (__CFADD__(v134, v32)) {
        return v21;
      }
      CFSetRef v190 = v133;
      v135 = v32;
      if (v33)
      {
        if (v132 >> 61) {
          return 0LL;
        }
        int64_t v136 = a11;
        uint64_t v137 = 8 * v132;
      }

      else
      {
        uint64_t v137 = 0LL;
        int64_t v136 = a11;
      }

      int v188 = (__CFSet **)v178;
      MEMORY[0x1895F8858](Value, v137);
      int64_t v141 = &v178[-v140];
      v186 = (const void **)&v178[-v140];
      uint64_t v183 = v139;
      if (v194)
      {
        if (v139 >= 257)
        {
          int64_t v141 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v138, 0LL);
          if (!v141) {
            return 0LL;
          }
        }
      }

      else
      {
        int64_t v141 = 0LL;
      }

      uint64_t v189 = (uint64_t)v141;
      int64_t v142 = 0LL;
      if (!v192 && a10 >= 16)
      {
        int64_t v142 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL);
        v192 = v142;
      }

      uint64_t v187 = (char *)v142;
      if (v192) {
        CFSetAddValue(v192, (const void *)v197);
      }
      if (!v136)
      {
        uint64_t v185 = v183 >> 1;
        uint64_t v146 = v183;
        if (v183 >= 1)
        {
          unint64_t v147 = (unint64_t)v135;
          int64_t v148 = 0LL;
          char v184 = (const void **)(v20 + 8);
          uint64_t v149 = valuePtr;
          if (!v194) {
            uint64_t v149 = 0LL;
          }
          CFIndex v181 = v149;
          char v182 = (const __CFSet *)(a10 + 1);
          uint64_t v150 = -1LL;
          while ((unint64_t)v184 <= v147)
          {
            uint64_t v151 = (unsigned int *)v147;
            uint64_t v152 = v20 + *(void *)(a4 + 24);
            uint64_t v153 = *(unsigned __int8 *)(a4 + 7);
            if (v152 - v153 < v147) {
              break;
            }
            unint64_t v154 = *(unsigned __int8 *)(a4 + 7);
            switch(*(_BYTE *)(a4 + 7))
            {
              case 0:
                break;
              case 1:
                unint64_t v154 = *(unsigned __int8 *)v151;
                break;
              case 2:
                unint64_t v154 = __rev16(*(unsigned __int16 *)v151);
                break;
              case 4:
                unint64_t v154 = bswap32(*v151);
                break;
              case 8:
                unint64_t v154 = bswap64(*(void *)v151);
                break;
              default:
                unint64_t v154 = 0LL;
                uint64_t v155 = v151;
                do
                {
                  unsigned int v156 = *(unsigned __int8 *)v155;
                  uint64_t v155 = (unsigned int *)((char *)v155 + 1);
                  unint64_t v154 = v156 | (v154 << 8);
                  --v153;
                }

                while (v153);
                break;
            }

            if (*(void *)(a4 + 8) <= v154) {
              break;
            }
            uint64_t v157 = *(unsigned __int8 *)(a4 + 6);
            v158 = (unsigned int *)(v152 + v154 * v157);
            switch(*(_BYTE *)(a4 + 6))
            {
              case 0:
                break;
              case 1:
                LODWORD(v157) = *(unsigned __int8 *)v158;
                break;
              case 2:
                LODWORD(v157) = __rev16(*(unsigned __int16 *)v158);
                break;
              case 4:
                LODWORD(v157) = bswap32(*v158);
                break;
              case 8:
                LODWORD(v157) = bswap64(*(void *)v158);
                break;
              default:
                uint64_t v159 = *(unsigned __int8 *)(a4 + 6);
                LODWORD(v157) = 0;
                do
                {
                  int v160 = *(unsigned __int8 *)v158;
                  v158 = (unsigned int *)((char *)v158 + 1);
                  LODWORD(v157) = v160 | ((_DWORD)v157 << 8);
                  --v159;
                }

                while (v159);
                break;
            }

            valuePtr[0] = 0LL;
            v203[0] = 0LL;
            if (!__CFBinaryPlistCreateObjectFiltered( v20,  a2,  v157,  a4,  (int)v195,  a6,  a7,  (int)v193,  v192,  (uint64_t)v182,  0LL,  (uint64_t)v181,  (uint64_t)v203)
              || v148 < v185 && v203[0] != (__CFSet *)7)
            {
              uint64_t v169 = (const void **)v189;
              if (valuePtr[0]) {
                CFRelease(valuePtr[0]);
              }
              if (v169)
              {
                while (v150 != -1)
                {
                  uint64_t v170 = v169[v150--];
                  CFRelease(v170);
                }

                if (v169 != v186) {
                  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v169);
                }
              }

              goto LABEL_414;
            }

            if (v189) {
              *(__CFSet **)(v189 + 8 * v148) = valuePtr[0];
            }
            unint64_t v147 = (unint64_t)v151 + *(unsigned __int8 *)v190;
            ++v148;
            ++v150;
            if (v148 == v146) {
              goto LABEL_367;
            }
          }

          uint64_t v167 = v189;
          if (v189)
          {
            while (v150 != -1)
            {
              v168 = *(const void **)(v167 + 8 * v150--);
              CFRelease(v168);
            }
          }

LABEL_414:
          BOOL v21 = 0LL;
LABEL_432:
          if (v187) {
            CFRelease(v187);
          }
          return v21;
        }

LABEL_367:
        if (v194)
        {
          if (v191)
          {
            int64_t v161 = CFDictionaryCreateMutable( (CFAllocatorRef)v195,  v185,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            if (v146 >= 1)
            {
              uint64_t v162 = v185;
              if (v185 <= 1) {
                uint64_t v163 = 1LL;
              }
              else {
                uint64_t v163 = v185;
              }
              uint64_t v164 = (const void **)v189;
              do
              {
                CFDictionaryAddValue(v161, *v164, v164[v162]);
                ++v164;
                --v163;
              }

              while (v163);
              char v165 = (CFTypeRef *)v189;
              do
              {
                CFRelease(*v165++);
                --v146;
              }

              while (v146);
            }
          }

          else
          {
            int64_t v161 = (__CFDictionary *)__CFDictionaryCreateTransfer( v195,  (unint64_t *)v189,  (unint64_t *)(v189 + 8 * v185),  v185);
          }

          CFMutableSetRef *v194 = v161;
        }

        if (v196) {
          CFTypeID *v196 = 18LL;
        }
        goto LABEL_419;
      }

      uint64_t v143 = v191;
      FilteredDictionary = __CFPropertyListCreateFilteredDictionary( (const __CFAllocator *)v195,  v136,  v20,  a2,  a3,  a4,  v194 == 0LL,  v191,  a7,  SHIDWORD(a7),  (int)v193,  v192,  a10);
      uint64_t v145 = FilteredDictionary;
      if (v194 && FilteredDictionary)
      {
        if ((unint64_t)(v143 - 1) < 2)
        {
          CFMutableSetRef *v194 = FilteredDictionary;
LABEL_419:
          BOOL v21 = 1LL;
          goto LABEL_420;
        }

        CFDictionaryRef v166 = CFDictionaryCreateCopy((CFAllocatorRef)v195, FilteredDictionary);
        CFMutableSetRef *v194 = v166;
      }

      else if (!FilteredDictionary)
      {
        BOOL v21 = 0LL;
LABEL_420:
        if (v192) {
          CFSetRemoveValue(v192, (const void *)v197);
        }
        if (v191) {
          BOOL v177 = 0;
        }
        else {
          BOOL v177 = v21;
        }
        if (v194 && v193 && v177) {
          CFDictionarySetValue(v193, (const void *)v197, *v194);
        }
        goto LABEL_432;
      }

      CFRelease(v145);
      goto LABEL_419;
    default:
      return v21;
  }

void sub_180A67A34(_Unwind_Exception *exception_object)
{
  if (*(void *)(v1 + 64)) {
    CFRelease(*(CFTypeRef *)(v1 + 64));
  }
  _Unwind_Resume(exception_object);
}

uint64_t __CFBinaryPlistGetOffsetForValueFromDictionary3( char *a1, int a2, unint64_t a3, uint64_t a4, const __CFString *cf, unint64_t *a6, unint64_t *a7)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  if (!cf) {
    return 0LL;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 < 0x14 && ((0xE0001u >> v14) & 1) != 0) {
    return 0LL;
  }
  uint64_t v15 = 0LL;
  if (a3 < 8) {
    return v15;
  }
  unint64_t v16 = *(void *)(a4 + 24) - 1LL;
  if (v16 < a3) {
    return v15;
  }
  uint64_t v15 = 0LL;
  unsigned int v17 = &a1[a3];
  char v18 = *v17;
  if ((*v17 & 0xF0) != 0xD0) {
    return v15;
  }
  uint64_t v19 = (unsigned int *)(v17 + 1);
  unint64_t v20 = v18 & 0xF;
  if ((v18 & 0xF) == 0xF)
  {
    if (&a1[v16] >= (char *)v19)
    {
      BOOL v21 = (unsigned __int8 *)(v17 + 2);
      char v22 = *(_BYTE *)v19;
      if ((*(_BYTE *)v19 & 0xF0) == 0x10)
      {
        uint64_t v15 = 0LL;
        unsigned int v23 = v22 & 0xF;
        uint64_t v24 = 1LL << (v22 & 0xF);
        switch((char)v24)
        {
          case 1:
            unint64_t v20 = *v21;
            goto LABEL_26;
          case 2:
            unint64_t v20 = __rev16(*(unsigned __int16 *)((char *)v19 + 1));
            goto LABEL_26;
          case 4:
            unint64_t v20 = bswap32(*(unsigned int *)((char *)v19 + 1));
            goto LABEL_26;
          case 8:
            unint64_t v20 = bswap64(*(void *)((char *)v19 + 1));
            goto LABEL_25;
          default:
            if (v23 > 7)
            {
              unint64_t v20 = 0LL;
LABEL_26:
              uint64_t v19 = (unsigned int *)&v21[v24];
              goto LABEL_27;
            }

            unint64_t v20 = 0LL;
            if ((v24 & 0xFE) != 0) {
              uint64_t v25 = v24;
            }
            else {
              uint64_t v25 = 1LL;
            }
            int v26 = (unsigned __int8 *)v19 + 1;
            do
            {
              unsigned int v27 = *v26++;
              unint64_t v20 = v27 | (v20 << 8);
              --v25;
            }

            while (v25);
LABEL_25:
            if ((v20 & 0x8000000000000000LL) == 0) {
              goto LABEL_26;
            }
            break;
        }
      }
    }

    return 0LL;
  }

LABEL_27:
  if (v20)
  {
    uint64_t v29 = 2 * v20 * *(unsigned __int8 *)(a4 + 7);
    unint64_t v84 = v20;
  }

  else
  {
    unint64_t v84 = 0LL;
    uint64_t v29 = 0LL;
  }

  uint64_t v15 = 0LL;
  CFSetRef v77 = a6;
  if (v14 != 7)
  {
    unsigned int v35 = 0LL;
    unsigned int v31 = *(unsigned __int8 *)(a4 + 7);
    uint64_t v79 = (unsigned __int8 *)(a4 + 7);
LABEL_47:
    int64_t v34 = -1LL;
    goto LABEL_48;
  }

  CFIndex Length = CFStringGetLength(cf);
  unsigned int v31 = *(unsigned __int8 *)(a4 + 7);
  uint64_t v79 = (unsigned __int8 *)(a4 + 7);
  if (Length == -1)
  {
    unsigned int v35 = 0LL;
    goto LABEL_47;
  }

  uint64_t v32 = Length;
  CStringPtr = CFStringGetCStringPtr(cf, 0);
  int64_t v34 = v32;
  unsigned int v35 = (char *)CStringPtr;
  if (v32 > 15 || CStringPtr)
  {
LABEL_48:
    if (!v20) {
      goto LABEL_112;
    }
    goto LABEL_49;
  }

  if (CFStringGetCString(cf, buffer, 16LL, 0))
  {
    size_t v36 = strnlen(buffer, 0x10uLL);
    int64_t v34 = v32;
    if (v36 == v32) {
      unsigned int v35 = buffer;
    }
    else {
      unsigned int v35 = 0LL;
    }
    if (!v20) {
      goto LABEL_112;
    }
    goto LABEL_49;
  }

  unsigned int v35 = 0LL;
  int64_t v34 = v32;
  if (!v20)
  {
LABEL_112:
    BOOL v38 = 0;
LABEL_113:
    int v69 = 0;
    return v38 & v69;
  }

        uint64_t v15 = CFGetAllocator((CFTypeRef)a1);
        unint64_t v16 = (__CFBundle *)a1;
        unsigned int v17 = 3584LL;
LABEL_39:
        v18[0] = _CFBundleCreateErrorDebug(v15, v16, v17, 0LL);
LABEL_40:
        unsigned int v11 = 0LL;
        *a3 = v18[0];
        return v11;
    }
  }

  _CFPlugInUnscheduleForUnloading((const void *)a1);
  return 1LL;
}

  CFIndex length = rangepa.length;
  BOOL v21 = CFStringGetLength(string);
  if ((v5 & 1) != 0 || length == v21)
  {
    if (rangep) {
      *rangep = rangepa;
    }
    char v22 = kCFNumberSInt64Type;
    return CFNumberCreate(v9, v22, valuePtr);
  }

    LOBYTE(v9) = 0;
    return v9;
  }

  CFSetRef v5 = 0LL;
  uint64_t v6 = *MEMORY[0x189616658];
  unint64_t v7 = v6 ^ (unint64_t)a3;
  uint64_t v8 = v7 & 7;
  while (v8 != *(unsigned __int8 *)(MEMORY[0x189616648] + v5))
  {
    if (++v5 == 7) {
      goto LABEL_16;
    }
  }

  if (v5 == 2)
  {
    LOBYTE(v9) = _NSTaggedPointerStringEqualCFString(a3, self);
    return v9;
  }

    LOBYTE(v9) = 0;
    return v9;
  }

  CFSetRef v5 = 0LL;
  uint64_t v6 = *MEMORY[0x189616658];
  unint64_t v7 = v6 ^ (unint64_t)a3;
  uint64_t v8 = v7 & 7;
  while (v8 != *(unsigned __int8 *)(MEMORY[0x189616648] + v5))
  {
    if (++v5 == 7) {
      goto LABEL_16;
    }
  }

  if (v5 == 2)
  {
    LOBYTE(v9) = _NSTaggedPointerStringEqualCFString(a3, self);
    return v9;
  }

  if (!pw_dir && a2)
  {
    unint64_t v16 = __CFgetenv("HOME");
    unsigned int v17 = (const UInt8 *)v16;
    if (v16)
    {
      char v18 = strlen(v16);
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v17,  v18,  1u);
      if (pw_dir) {
        goto LABEL_35;
      }
      v26((uint64_t)v25);
      uint64_t v19 = os_variant_has_internal_diagnostics();
      unint64_t v20 = *(__CFString **)(v30[0] + 24LL);
      if (v19)
      {
        CFStringAppendFormat( v20,  0LL,  @"CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value: %s",  v17);
        pw_dir = 0LL;
        goto LABEL_35;
      }

      CFStringAppend(v20, @"CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value");
    }

    pw_dir = 0LL;
  }

      if (v16) {
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue( Mutable,  @"NSDebugDescription",  @"Property list reading could not be completed because the stream had an unknown error. Did you forget to open the stream?");
      if (v24) {
        CFDictionarySetValue(Mutable, @"NSUnderlyingError", v24);
      }
      *unint64_t v9 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSCocoaErrorDomain", 3842LL, Mutable);
      CFRelease(Mutable);
      goto LABEL_32;
    }

    unint64_t v20 = v13 + 78;
    BOOL v21 = v13;
    while (1)
    {
      char v22 = ((char *)v20 - (char *)v21) >> 3;
      unsigned int v23 = &v21[2 * v22];
      uint64_t v24 = *v23;
      unint64_t v20 = v23 - 2;
LABEL_32:
      if (v21 > v20) {
        goto LABEL_33;
      }
    }

    if (v24 < v14)
    {
      BOOL v21 = v23 + 2;
      goto LABEL_32;
    }

    LODWORD(v21) = v21[2 * v22 + 1];
    if (v21 > 0xFF)
    {
      uint64_t v19 = v11 + 2;
      if (a5)
      {
        if (v19 > a5) {
          goto LABEL_170;
        }
        *a4 = BYTE1(v21);
        goto LABEL_127;
      }
    }

    else
    {
      uint64_t v19 = v11 + 1;
      if (a5) {
        *a4++ = (_BYTE)v21;
      }
    }

  if (Copy) {
    CFRelease(Copy);
  }
}

  if (Copy) {
    CFRelease(Copy);
  }
}

      unsigned int v17 = (__CFNumberFormatter *)*v14;
      if (!*v14)
      {
LABEL_46:
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
        return 0LL;
      }

    uint64_t v24 = 0LL;
    unsigned int v23 = 0;
    uint64_t v28 = a2;
    goto LABEL_29;
  }

  if (a3 < 1) {
    goto LABEL_27;
  }
  unsigned int v23 = 0;
  uint64_t v24 = 0LL;
  while (1)
  {
    uint64_t v25 = a2[v24];
    if (!a2[v24]) {
      break;
    }
    if ((_DWORD)v25 == 47 || (sURLValidBytes[v25] & 1) == 0)
    {
      *char v22 = 37;
      v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
      v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
      v22 += 3;
      unsigned int v23 = 1;
    }

    else
    {
      *v22++ = v25;
    }

    if (a3 == ++v24) {
      goto LABEL_34;
    }
  }

    unint64_t v20 = -[NSArray initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSArray), "initWithObjects:count:", v10, v13);
    return v20;
  }

  if (!v12) {
    goto LABEL_27;
  }
LABEL_26:
  unint64_t v20 = -[NSArray _initByAdoptingBuffer:count:size:]( objc_alloc(&OBJC_CLASS___NSArray),  "_initByAdoptingBuffer:count:size:",  v12,  v13,  v13);
  return v20;
}

      switch(*((_BYTE *)v14 + 36))
      {
        case '[':
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported return type encoding spec '%s'",  (char *)v14 + 37);
          unint64_t v33 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
          objc_exception_throw(v33);
          goto LABEL_60;
        case '^':
        case 'c':
          break;
        case 'd':
          goto LABEL_52;
        case 'f':
          v14[3] = 0x5000000010LL;
          uint64_t v28 = -3072;
          goto LABEL_54;
        default:
          goto LABEL_29;
      }
    }

  uint64_t v28 = (CFTypeRef *)(a5 + 8);
  unsigned int v27 = *(void *)(a5 + 8);
  if (a4)
  {
    if (v27)
    {
      CFRelease((CFTypeRef)v27);
      *uint64_t v28 = 0LL;
    }

    if (*(void *)a5)
    {
      CFRelease(*(CFTypeRef *)a5);
      *(void *)a5 = 0LL;
    }

    uint64_t v29 = *(const void **)(a5 + 16);
    if (v29)
    {
      CFRelease(v29);
      *(void *)(a5 + 16) = 0LL;
    }

    unsigned int v30 = *(const void **)(a5 + 32);
    if (v30)
    {
      CFRelease(v30);
      *(void *)(a5 + 32) = 0LL;
    }

    uint64_t v90 = (CFTypeRef *)(a5 + 8);
    unsigned int v31 = *(const void **)(a5 + 24);
    if (v31)
    {
      CFRelease(v31);
      *(void *)(a5 + 24) = 0LL;
    }

    int64_t v92 = (CFTypeRef *)(a5 + 24);
    theArray = (CFTypeRef *)(a5 + 32);
    BOOL v87 = a2;
    uint64_t v32 = *(const void **)(a5 + 40);
    if (v32)
    {
      CFRelease(v32);
      *(void *)(a5 + 40) = 0LL;
    }

    if (CFArrayGetCount(a4) >= 1)
    {
      unint64_t v33 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a4, v33);
        unsigned int v35 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, @"strings", 0LL, ValueAtIndex);
        size_t v36 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, @"stringsdict", 0LL, ValueAtIndex);
        if (++v33 >= CFArrayGetCount(a4)) {
          goto LABEL_51;
        }
      }

      CFIndex v39 = v36;
      *(void *)a5 = v35;
      *(void *)(a5 + 8) = CFRetain(ValueAtIndex);
      *(void *)(a5 + 24) = v39;
      *(void *)(a5 + 32) = CFRetain(ValueAtIndex);
    }

    CFRetain(v19);
    return;
  }

  uint64_t v25 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatFamilyInfoKey");
  int v26 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSStringFormatLocaleInfoKey");
  RelevantLocaleInfoFromLocaleSummary = _CFStringGetRelevantLocaleInfoFromLocaleSummary(v26, (const __CFLocale *)v7);
  uint64_t v28 = (const __CFDictionary *)CFRetain(RelevantLocaleInfoFromLocaleSummary);
  v77[0] = 0LL;
  if (!CFDictionaryGetValueIfPresent(v28, @"NSStringFormatRuleStartEndInfoKey", v77))
  {
    if (CFDictionaryGetValueIfPresent(v28, @"NSStringConditionalFormatRuleInfoKey", v77))
    {
      uint64_t v40 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], @"default");
      unint64_t v41 = CFGetTypeID(a1);
      else {
        uint64_t v42 = (const __CFDictionary *)CFDictionaryGetValue(v40, @"default");
      }
      unint64_t v33 = v42;
      goto LABEL_96;
    }

    goto LABEL_84;
  }

  uint64_t v29 = CFGetTypeID(a1);
  if (v29 == CFStringGetTypeID())
  {
    v70[0] = MEMORY[0x1895F87A8];
    v70[1] = 3221225472LL;
    unint64_t v71 = ___CFCopyResolvedFormatStringWithConfiguration_block_invoke;
    uint64_t v72 = &__block_descriptor_40_e29__v20__0____CFDictionary__8S16l;
    uint64_t v73 = v25;
    unsigned int v30 = (const __CFDictionary *)v77[0];
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0LL);
    uint64_t v32 = (const __CFDictionary *)___CFCopyResolvedFormatStringWithConfiguration_block_invoke( (uint64_t)v70,  v30,  CharacterAtIndex);
    unint64_t v33 = v32;
    if (!v32) {
      goto LABEL_96;
    }
    int64_t v34 = CFGetTypeID(v32);
    if (v34 == CFDictionaryGetTypeID())
    {
      CFIndex Length = CFStringGetLength(a1);
      size_t v36 = CFStringGetCharacterAtIndex(a1, Length - 1);
      uint64_t v37 = (const __CFDictionary *)v71((uint64_t)v70, v33, v36);
      unint64_t v33 = v37;
      if (v37)
      {
        BOOL v38 = CFGetTypeID(v37);
        CFIndex v39 = CFStringGetTypeID();
        goto LABEL_81;
      }

      goto LABEL_96;
    }

LABEL_49:
  uint64_t v37 = 0LL;
  unint64_t v75 = v20 * v31;
  BOOL v83 = a1 + 8;
  unint64_t v78 = (unint64_t)&a1[*(void *)(a4 + 24) - 1];
  unint64_t v76 = ~v34;
  BOOL v38 = 1;
  unint64_t v80 = v20;
  size_t __n = v34;
  __s2 = v35;
  while (1)
  {
    CFIndex v39 = &a1[*(void *)(a4 + 24)];
    uint64_t v40 = *(unsigned __int8 *)(a4 + 7);
    unint64_t v41 = *(unsigned __int8 *)(a4 + 7);
    switch(*(_BYTE *)(a4 + 7))
    {
      case 0:
        break;
      case 1:
        unint64_t v41 = *(unsigned __int8 *)v19;
        break;
      case 2:
        unint64_t v41 = __rev16(*(unsigned __int16 *)v19);
        break;
      case 4:
        unint64_t v41 = bswap32(*v19);
        break;
      case 8:
        unint64_t v41 = bswap64(*(void *)v19);
        break;
      default:
        unint64_t v41 = 0LL;
        uint64_t v42 = *(unsigned __int8 *)(a4 + 7);
        uint64_t v43 = v19;
        do
        {
          unsigned int v44 = *(unsigned __int8 *)v43;
          uint64_t v43 = (unsigned int *)((char *)v43 + 1);
          unint64_t v41 = v44 | (v41 << 8);
          --v42;
        }

        while (v42);
        break;
    }

    if (*(void *)(a4 + 8) <= v41) {
      goto LABEL_113;
    }
    unint64_t v45 = *(unsigned __int8 *)(a4 + 6);
    CFNumberRef v46 = (unsigned int *)&v39[v41 * v45];
    switch(*(_BYTE *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        unint64_t v45 = *(unsigned __int8 *)v46;
        break;
      case 2:
        unint64_t v45 = __rev16(*(unsigned __int16 *)v46);
        break;
      case 4:
        unint64_t v45 = bswap32(*v46);
        break;
      case 8:
        unint64_t v45 = bswap64(*(void *)v46);
        break;
      default:
        uint64_t v47 = *(unsigned __int8 *)(a4 + 6);
        unint64_t v45 = 0LL;
        do
        {
          unsigned int v48 = *(unsigned __int8 *)v46;
          CFNumberRef v46 = (unsigned int *)((char *)v46 + 1);
          unint64_t v45 = v48 | (v45 << 8);
          --v47;
        }

        while (v47);
        break;
    }

    if (v35)
    {
      char v49 = a1[v45];
      if ((v49 & 0xF0) == 0x50) {
        break;
      }
    }

    uint64_t v55 = v19;
    uint64_t v56 = v37;
    BOOL v57 = v38;
    CFTypeRef v86 = 0LL;
    CFTypeID v85 = 0LL;
    if (!__CFBinaryPlistCreateObjectFiltered( a1,  a2,  v45,  a4,  &__kCFAllocatorSystemDefault,  0xFFFFFFFF80000000LL,  0LL,  0LL,  0LL,  0LL,  0LL,  &v86,  &v85)
      || v85 <= 0x13 && ((1LL << v85) & 0xE0001) != 0)
    {
      if (v86) {
        CFRelease(v86);
      }
      goto LABEL_110;
    }

    int v58 = CFEqual(cf, v86);
    CFRelease(v86);
    int64_t v34 = __n;
    unsigned int v35 = __s2;
    uint64_t v37 = v56;
    uint64_t v19 = v55;
    if (v58) {
      goto LABEL_104;
    }
    uint64_t v40 = *v79;
LABEL_86:
    uint64_t v19 = (unsigned int *)((char *)v19 + v40);
    BOOL v38 = ++v37 < v80;
    if (v37 == v84) {
      goto LABEL_113;
    }
  }

  unint64_t v50 = v49 & 0xF;
  uint64_t v51 = (unsigned __int8 *)&a1[v45 + 1];
  if (v34 >= 15 && (_DWORD)v50 == 15)
  {
    unint64_t v52 = &a1[v45 + 2];
    if ((*v51 & 0xF0) != 0x10) {
      goto LABEL_113;
    }
    unsigned int v53 = *v51 & 0xF;
    uint64_t v54 = 1LL << v53;
    switch((1LL << v53))
    {
      case 1u:
        unint64_t v50 = *v52;
        goto LABEL_99;
      case 2u:
        unint64_t v50 = __rev16(*(unsigned __int16 *)&a1[v45 + 2]);
        goto LABEL_99;
      case 4u:
        unint64_t v50 = bswap32(*(_DWORD *)&a1[v45 + 2]);
        goto LABEL_99;
      case 8u:
        unint64_t v50 = bswap64(*(void *)&a1[v45 + 2]);
        goto LABEL_98;
      default:
        if (v53 < 8)
        {
          unint64_t v50 = 0LL;
          if ((v54 & 0xFE) != 0) {
            uint64_t v59 = v54;
          }
          else {
            uint64_t v59 = 1LL;
          }
          unsigned int v60 = &a1[v45 + 2];
          do
          {
            unsigned int v61 = *v60++;
            unint64_t v50 = v61 | (v50 << 8);
            --v59;
          }

          while (v59);
LABEL_98:
          if ((v50 & 0x8000000000000000LL) != 0) {
            goto LABEL_113;
          }
        }

        else
        {
          unint64_t v50 = 0LL;
        }

          MutableCFArrayRef Copy = (__CFString *)CFRetain(@"_CFBAF_");
          goto LABEL_50;
        }

        MutableCFArrayRef Copy = (__CFString *)CFRetain(Copy);
      }

      CFURLRef v104 = 0;
      goto LABEL_50;
    }

  uint64_t i = (unsigned __int8 *)(BytePtr + 5);
  size_t v36 = &BytePtr[v22];
  if (v22 < 6uLL)
  {
LABEL_76:
    unsigned int v27 = v50;
    if (i < v36)
    {
      CFIndex v39 = *i;
      if (v39 == 39 || v39 == 34)
      {
        uint64_t v40 = (char)v39;
        unint64_t v41 = i + 1;
        uint64_t v42 = 1LL;
        while (&i[v42] < v36)
        {
          uint64_t v43 = i[v42++];
          if (v43 == v40)
          {
            if ((_DWORD)v42 == 7
              && (*v41 | 0x20) == 0x75
              && (i[2] | 0x20) == 0x74
              && (i[3] | 0x20) == 0x66
              && i[4] == 45
              && i[5] == 56)
            {
              goto LABEL_88;
            }

            unint64_t v45 = CFStringCreateWithBytes( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v41,  (v42 - 2),  0x201u,  0);
            CFNumberRef v46 = CFStringConvertIANACharSetNameToEncoding(v45);
            if (v46 == -1)
            {
              unsigned int v44 = __CFPropertyListCreateError(3840LL, @"Encountered unknown encoding (%@)", v45);
              if (v45) {
                CFRelease(v45);
              }
              goto LABEL_92;
            }

            uint64_t v24 = v46;
            char v49 = a6;
            if (v45)
            {
              uint64_t v47 = v46;
              CFRelease(v45);
              uint64_t v24 = v47;
            }

            if (v24 == 134217984)
            {
              int v26 = 0LL;
              unsigned int v27 = v50;
              a6 = v49;
              return _CFPropertyListCreateFromUTF8Data( (const __CFAllocator *)a1,  theData,  v26,  0LL,  0x8000100u,  a3,  a4,  v27,  a6,  a7,  a8,  v11,  v12);
            }

            unsigned int v44 = 0LL;
            uint64_t v28 = 0LL;
            if (!v24) {
              goto LABEL_92;
            }
            goto LABEL_56;
          }
        }
      }
    }

    goto LABEL_88;
  }

  uint64_t v37 = *i;
  unsigned int v27 = v50;
  if ((v37 & 0xFE) == 0x3E)
  {
LABEL_88:
    int v26 = 0LL;
    return _CFPropertyListCreateFromUTF8Data( (const __CFAllocator *)a1,  theData,  v26,  0LL,  0x8000100u,  a3,  a4,  v27,  a6,  a7,  a8,  v11,  v12);
  }

  for (uint64_t i = (unsigned __int8 *)(BytePtr + 14); i < v36; ++i)
  {
    BOOL v38 = *(i - 8);
    if (v37 == 101
      && v38 == 110
      && *(i - 7) == 99
      && *(i - 6) == 111
      && *(i - 5) == 100
      && *(i - 4) == 105
      && *(i - 3) == 110
      && *(i - 2) == 103
      && *(i - 1) == 61)
    {
      goto LABEL_76;
    }

    int v26 = 0LL;
    uint64_t v37 = v38;
    if ((v38 & 0xFE) == 0x3E) {
      return _CFPropertyListCreateFromUTF8Data( (const __CFAllocator *)a1,  theData,  v26,  0LL,  0x8000100u,  a3,  a4,  v27,  a6,  a7,  a8,  v11,  v12);
    }
  }

  unsigned int v44 = __CFPropertyListCreateError(3840LL, @"End of buffer while looking for encoding name", v26);
LABEL_92:
  if (a4 && !v44)
  {
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Could not determine the encoding of the XML data");
    goto LABEL_17;
  }

  if (a4 && v44)
  {
    char v18 = 0LL;
    *a4 = v44;
    return v18;
  }

  char v18 = 0LL;
  if (!a4 && v44)
  {
    CFRelease(v44);
    return 0LL;
  }

  return v18;
}

        unsigned int v27 = 0LL;
        uint64_t v28 = *v3;
        if (v5 == 0xC000000000000007LL) {
          uint64_t v28 = 0LL;
        }
        uint64_t v29 = v28 ^ (unint64_t)v1;
        do
        {
          if ((v29 & 7) == *(_BYTE *)(v8 + v27)) {
            break;
          }
          ++v27;
        }

        while (v27 != 7);
        unsigned int v30 = v27 | v29;
        unsigned int v31 = v27 & 7;
        uint64_t v32 = (v30 >> 55) + 8;
        if (v31 == 7) {
          LODWORD(v31) = v32;
        }
        uint64_t v15 = 22LL;
        switch((int)v31)
        {
          case 0:
            goto LABEL_63;
          case 1:
            goto LABEL_64;
          case 2:
            goto LABEL_62;
          case 3:
            goto LABEL_18;
          case 4:
          case 5:
            goto LABEL_63;
          case 6:
            uint64_t v15 = 42LL;
            goto LABEL_18;
          default:
            if ((_DWORD)v31 == 20)
            {
LABEL_63:
              uint64_t v15 = 1LL;
              goto LABEL_18;
            }

            if ((_DWORD)v31 == 22)
            {
LABEL_62:
              uint64_t v15 = 7LL;
              goto LABEL_18;
            }

  uint64_t v29 = *(const __CFArray **)(a3 + 40);
  if (v29)
  {
    unsigned int v30 = CFStringCreateByCombiningStrings(alloc, v29, @"/");
    CFStringAppend(MutableCopy, v30);
    CFRelease(v30);
  }

  if (*(void *)(a3 + 48))
  {
    CFStringAppend(MutableCopy, @";");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
  }

  if (*(void *)(a3 + 56))
  {
    CFStringAppend(MutableCopy, @"?");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 56));
  }

  if (*(void *)(a3 + 64))
  {
    CFStringAppend(MutableCopy, @"#");
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 64));
  }

  if (MutableCopy) {
    goto LABEL_36;
  }
LABEL_58:
  unsigned int v31 = 0LL;
LABEL_63:
  CFRelease(MutableCopy);
  return v31;
}

LABEL_99:
        uint64_t v51 = (unsigned __int8 *)&v52[v54];
        int64_t v34 = __n;
        break;
    }
  }

  if (v50 != v34) {
    goto LABEL_86;
  }
  uint64_t v62 = v19;
  uint64_t v63 = v37;
  BOOL v57 = v38;
  int v64 = memcmp(v51, __s2, v34);
  int64_t v34 = __n;
  unsigned int v35 = __s2;
  uint64_t v37 = v63;
  uint64_t v19 = v62;
  if (v64) {
    goto LABEL_86;
  }
LABEL_104:
  CFNumberRef v65 = (unsigned int *)((char *)v19 + v75);
  if (v83 > (char *)v19 + v75)
  {
LABEL_110:
    int v69 = 0;
    BOOL v38 = v57;
    return v38 & v69;
  }

  uint64_t v66 = &a1[*(void *)(a4 + 24)];
  uint64_t v67 = *(unsigned __int8 *)(a4 + 7);
  BOOL v38 = v57;
  unint64_t v68 = *(unsigned __int8 *)(a4 + 7);
  switch(*(_BYTE *)(a4 + 7))
  {
    case 0:
      break;
    case 1:
      unint64_t v68 = *(unsigned __int8 *)v65;
      break;
    case 2:
      unint64_t v68 = __rev16(*(unsigned __int16 *)v65);
      break;
    case 4:
      unint64_t v68 = bswap32(*v65);
      break;
    case 8:
      unint64_t v68 = bswap64(*(void *)v65);
      break;
    default:
      unint64_t v68 = 0LL;
      do
      {
        unsigned int v70 = *(unsigned __int8 *)v65;
        CFNumberRef v65 = (unsigned int *)((char *)v65 + 1);
        unint64_t v68 = v70 | (v68 << 8);
        --v67;
      }

      while (v67);
      break;
  }

  if (*(void *)(a4 + 8) <= v68) {
    goto LABEL_113;
  }
  if (a7)
  {
    unint64_t v71 = *(unsigned __int8 *)(a4 + 6);
    uint64_t v72 = (unsigned int *)&v66[v68 * v71];
    switch(*(_BYTE *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        unint64_t v71 = *(unsigned __int8 *)v72;
        break;
      case 2:
        unint64_t v71 = __rev16(*(unsigned __int16 *)v72);
        break;
      case 4:
        unint64_t v71 = bswap32(*v72);
        break;
      case 8:
        unint64_t v71 = bswap64(*(void *)v72);
        break;
      default:
        uint64_t v73 = *(unsigned __int8 *)(a4 + 6);
        unint64_t v71 = 0LL;
        do
        {
          unsigned int v74 = *(unsigned __int8 *)v72;
          uint64_t v72 = (unsigned int *)((char *)v72 + 1);
          unint64_t v71 = v74 | (v71 << 8);
          --v73;
        }

        while (v73);
        break;
    }

    *a7 = v71;
  }

  if (v77) {
    *CFSetRef v77 = v45;
  }
  int v69 = 1;
  return v38 & v69;
}

      int v58 = *v42;
      if (*v42)
      {
        uint64_t v59 = (unsigned __int8 *)(v42 + 1);
        unsigned int v60 = (char *)a1;
        do
        {
          *v60++ = v58;
          unsigned int v61 = *v59++;
          int v58 = v61;
        }

        while (v61);
      }
    }

    else
    {
LABEL_82:
      unsigned int v48 = (const char *)v39[3];
      if (!v70 || (BOOL result = _CheckForTag((uint64_t)(v70 + 1), v48 + 1), !(_DWORD)result))
      {
        BOOL result = (unint64_t)strstr(a1, v48);
        if (!result) {
          goto LABEL_107;
        }
        char v49 = *(char *)(result + 3);
        if ((v49 & 0x80000000) != 0)
        {
          BOOL result = __maskrune(v49, 0x500uLL);
          if ((_DWORD)result) {
            goto LABEL_107;
          }
        }

        else
        {
          BOOL result = *(_DWORD *)(v24 + 4LL * v49 + 60) & 0x500;
          if ((_DWORD)result) {
            goto LABEL_107;
          }
        }
      }

      uint64_t v62 = (_BYTE *)v39[4];
      uint64_t v63 = *v62;
      if (*v62)
      {
        int v64 = v62 + 1;
        CFNumberRef v65 = (char *)a1;
        do
        {
          *v65++ = v63;
          uint64_t v66 = *v64++;
          uint64_t v63 = v66;
        }

        while (v66);
      }
    }

uint64_t __CFBinaryPlistParseASCIIString(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  if (a3 != (_BYTE *)-1LL)
  {
    char v5 = *a3;
    unint64_t v4 = a3 + 1;
    unint64_t v6 = v5 & 0xF;
    if ((_DWORD)v6 == 15)
    {
      if (a1 + a2 >= (unint64_t)v4)
      {
        unint64_t v7 = v4 + 1;
        if ((*v4 & 0xF0) == 0x10)
        {
          unsigned int v8 = *v4 & 0xF;
          uint64_t v9 = 1LL << v8;
          if (!__CFADD__(1LL << v8, v7) && (unint64_t)&v4[v9] <= a1 + a2)
          {
            switch((1LL << v8))
            {
              case 1u:
                unint64_t v6 = *v7;
                goto LABEL_20;
              case 2u:
                unint64_t v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
                goto LABEL_20;
              case 4u:
                unint64_t v6 = bswap32(*(_DWORD *)(v4 + 1));
                goto LABEL_20;
              case 8u:
                unint64_t v6 = bswap64(*(void *)(v4 + 1));
                goto LABEL_19;
              default:
                if (v8 > 7)
                {
                  unint64_t v6 = 0LL;
LABEL_20:
                  unint64_t v4 = &v7[v9];
                  goto LABEL_21;
                }

                unint64_t v6 = 0LL;
                if ((v9 & 0xFE) != 0) {
                  uint64_t v10 = v9;
                }
                else {
                  uint64_t v10 = 1LL;
                }
                unsigned int v11 = v4 + 1;
                do
                {
                  unsigned int v12 = *v11++;
                  unint64_t v6 = v12 | (v6 << 8);
                  --v10;
                }

                while (v10);
LABEL_19:
                if ((v6 & 0x8000000000000000LL) == 0) {
                  goto LABEL_20;
                }
                break;
            }
          }
        }
      }
    }

    else
    {
LABEL_21:
    }
  }

  return 0LL;
}

uint64_t __CFBinaryPlistParseUnicode16String(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  if (a3 == (_BYTE *)-1LL) {
    return 0LL;
  }
  char v5 = *a3;
  unint64_t v4 = a3 + 1;
  unint64_t v6 = v5 & 0xF;
  if ((_DWORD)v6 == 15)
  {
    if (a1 + a2 >= (unint64_t)v4)
    {
      unint64_t v7 = v4 + 1;
      if ((*v4 & 0xF0) == 0x10)
      {
        unsigned int v8 = *v4 & 0xF;
        uint64_t v9 = 1LL << v8;
        if (!__CFADD__(1LL << v8, v7) && (unint64_t)&v4[v9] <= a1 + a2)
        {
          switch((1LL << v8))
          {
            case 1u:
              unint64_t v6 = *v7;
              goto LABEL_20;
            case 2u:
              unint64_t v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
              goto LABEL_20;
            case 4u:
              unint64_t v6 = bswap32(*(_DWORD *)(v4 + 1));
              goto LABEL_20;
            case 8u:
              unint64_t v6 = bswap64(*(void *)(v4 + 1));
              goto LABEL_19;
            default:
              if (v8 > 7)
              {
                unint64_t v6 = 0LL;
LABEL_20:
                unint64_t v4 = &v7[v9];
                goto LABEL_21;
              }

              unint64_t v6 = 0LL;
              if ((v9 & 0xFE) != 0) {
                uint64_t v10 = v9;
              }
              else {
                uint64_t v10 = 1LL;
              }
              unsigned int v11 = v4 + 1;
              do
              {
                unsigned int v12 = *v11++;
                unint64_t v6 = v12 | (v6 << 8);
                --v10;
              }

              while (v10);
LABEL_19:
              if ((v6 & 0x8000000000000000LL) == 0) {
                goto LABEL_20;
              }
              break;
          }
        }
      }
    }

    return 0LL;
  }

CFMutableDictionaryRef __CFPropertyListCreateFilteredDictionary( const __CFAllocator *a1, const __CFSet *a2, uint64_t a3, int a4, unint64_t a5, uint64_t a6, int a7, int a8, int a9, int a10, int a11, const __CFSet *a12, uint64_t a13)
{
  uint64_t v85 = *MEMORY[0x1895F89C0];
  __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, &theSet, (__CFSet **)&cf);
  if (!theSet) {
    return 0LL;
  }
  if (a5 < 8) {
    goto LABEL_36;
  }
  unint64_t v20 = *(void *)(a6 + 24) - 1LL;
  if (v20 < a5) {
    goto LABEL_36;
  }
  BOOL v21 = (_BYTE *)(a3 + a5);
  if (a3 + a5 == -1LL) {
    goto LABEL_36;
  }
  char v22 = *v21;
  if ((*v21 & 0xF0) != 0xD0) {
    goto LABEL_36;
  }
  unsigned int v23 = (unsigned int *)(v21 + 1);
  unint64_t v24 = v22 & 0xF;
  if ((v22 & 0xF) == 0xF)
  {
    if (a3 + v20 >= (unint64_t)v23)
    {
      uint64_t v25 = v21 + 2;
      char v26 = *(_BYTE *)v23;
      if ((*(_BYTE *)v23 & 0xF0) == 0x10)
      {
        unsigned int v27 = v26 & 0xF;
        uint64_t v28 = 1LL << (v26 & 0xF);
        if (!__CFADD__(v28, v25) && (unint64_t)v23 + v28 <= a3 + v20)
        {
          switch((char)v28)
          {
            case 1:
              unint64_t v24 = *v25;
              goto LABEL_24;
            case 2:
              unint64_t v24 = __rev16(*(unsigned __int16 *)((char *)v23 + 1));
              goto LABEL_24;
            case 4:
              unint64_t v24 = bswap32(*(unsigned int *)((char *)v23 + 1));
              goto LABEL_24;
            case 8:
              unint64_t v24 = bswap64(*(void *)((char *)v23 + 1));
              goto LABEL_23;
            default:
              if (v27 > 7)
              {
                unint64_t v24 = 0LL;
LABEL_24:
                unsigned int v23 = (unsigned int *)&v25[v28];
                goto LABEL_25;
              }

              unint64_t v24 = 0LL;
              if ((v28 & 0xFE) != 0) {
                uint64_t v29 = v28;
              }
              else {
                uint64_t v29 = 1LL;
              }
              unsigned int v30 = (unsigned __int8 *)v23 + 1;
              do
              {
                unsigned int v31 = *v30++;
                unint64_t v24 = v31 | (v24 << 8);
                --v29;
              }

              while (v29);
LABEL_23:
              if ((v24 & 0x8000000000000000LL) == 0) {
                goto LABEL_24;
              }
              break;
          }
        }
      }
    }

    goto LABEL_36;
  }

LABEL_122:
  if (theSet) {
    CFRelease(theSet);
  }
  if (cf) {
    CFRelease(cf);
  }
  _Block_object_dispose(&v74, 8);
  return Mutable;
}

    BOOL v83 = *(void *)(a2 + 16);
    uint64_t v19 = v40 / v83;
    uint64_t v9 = v16;
    unint64_t v20 = v41 / v83;
    goto LABEL_128;
  }

  BOOL v21 = __CFStorageCreateNode(a1, a2, 0, 0LL);
  char v22 = a4 - 1;
  unsigned int v23 = (int64_t *)*((void *)v9 + 2);
  unint64_t v24 = *v23;
  if (*v23 >= a4)
  {
    char v26 = 0LL;
    CFTypeRef v86 = 1;
  }

  else
  {
    v22 -= v24;
    unsigned int v23 = (int64_t *)*((void *)v9 + 3);
    uint64_t v25 = v22 - *v23;
    if (v22 >= *v23)
    {
      CFTypeRef v86 = 0;
      unsigned int v23 = (int64_t *)*((void *)v9 + 4);
      char v26 = 2LL;
      char v22 = v25;
    }

    else
    {
      CFTypeRef v86 = 1;
      char v26 = 1LL;
    }
  }

  inserted = __CFStorageInsertFrozen(a1, a2, v23, v22 + 1, a5, a6);
  unint64_t v44 = inserted;
  uint64_t v46 = v45;
  unsigned int v47 = 0LL;
  uint64_t v91 = 0u;
  int64_t v92 = 0u;
  do
  {
    CFSetRef v48 = *(void *)&v9[2 * v47 + 4];
    if (v48)
    {
      int v49 = (unsigned int *)(v48 + 8);
      if (*(_DWORD *)(v48 + 8))
      {
        do
          unint64_t v50 = __ldxr(v49);
        while (__stxr(v50 + 1, v49));
      }

      *(_BYTE *)(v48 + 12) = 1;
    }

    *((void *)&v91 + v47++) = v48;
  }

  while (v47 != 3);
  CFStringRef v51 = *((void *)&v91 + v26);
  if (v51 != inserted)
  {
    unint64_t v52 = (unsigned int *)(v51 + 8);
    if (*(_DWORD *)(v51 + 8))
    {
      do
      {
        uint64_t v53 = __ldxr(v52);
        uint64_t v54 = v53 - 1;
      }

      while (__stxr(v54, v52));
      if (!v54) {
        __CFStorageDeallocateNode((const void *)a2, v51);
      }
    }

    *((void *)&v91 + v26) = v44;
  }

  if (v46)
  {
    if (v86)
    {
      *((void *)&v92 + 1) = v92;
      if (v24 >= a4) {
        *(void *)&int64_t v92 = *((void *)&v91 + 1);
      }
    }

    *((void *)&v91 + v26 + 1) = v46;
  }

  unint64_t v55 = v91;
  *((_OWORD *)v21 + 1) = v91;
  unsigned int v56 = (_DWORD *)*((void *)&v92 + 1);
  if (*((void *)&v92 + 1))
  {
    uint64_t v57 = __CFStorageCreateNode(a1, a2, 0, 0LL);
    int v58 = (uint64_t *)v92;
    v57[2] = v92;
    v57[3] = v56;
    *(void *)BOOL v21 = **((void **)&v55 + 1) + *(void *)v55;
    uint64_t v59 = *v58;
    uint64_t v9 = v56;
  }

  else
  {
    *((void *)v21 + 4) = v92;
    uint64_t v57 = v21;
    uint64_t v59 = a5;
  }

  void *v57 = *(void *)v9 + v59;
  return v21;
}

void sub_180A68EC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t __CFBinaryPlistCreateObject( const void *a1, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, const __CFDictionary *a7, CFTypeRef *a8)
{
  return __CFBinaryPlistCreateObjectFiltered(a1, a2, a3, a4, a5, a6, 0LL, a7, 0LL, 0LL, 0LL, a8, 0LL);
}

uint64_t __CFTryParseBinaryPlist( __objc2_class **a1, CFDataRef theData, uint64_t a3, void *a4, CFTypeRef *a5)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  BytePtr = CFDataGetBytePtr(theData);
  unint64_t Length = CFDataGetLength(theData);
  if (Length < 8) {
    return 0LL;
  }
  int v12 = Length;
  CFMutableDictionaryRef Mutable = (__objc2_class **)CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
  _CFDictionarySetCapacity(Mutable, v20);
  CFTypeRef v16 = 0LL;
  uint64_t v14 = __CFBinaryPlistCreateObjectFiltered( BytePtr,  v12,  *(unint64_t *)v17,  (uint64_t)v19,  a1,  a3,  0LL,  (const __CFDictionary *)Mutable,  0LL,  0LL,  0LL,  &v16,  0LL);
  if ((_DWORD)v14)
  {
    if (a4) {
      *a4 = v16;
    }
  }

  else
  {
    if (a4) {
      *a4 = 0LL;
    }
    if (a5) {
      *a5 = CFRetain(@"binary data is corrupt");
    }
  }

  CFRelease(Mutable);
  return v14;
}

void writeBytes(uint64_t a1, const UInt8 *__src, int64_t __len, int a4)
{
  if (__len >= 1)
  {
    uint64_t v19 = v7;
    uint64_t v20 = v6;
    uint64_t v21 = v5;
    uint64_t v22 = v4;
    if (!*(void *)(a1 + 24))
    {
      CFIndex v12 = __len;
      unint64_t v13 = __src;
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14)
      {
        uint64_t v15 = *(void *)(a1 + 32);
        if (__CFADD__(__len, v15) || *(void *)(a1 + 16) < (unint64_t)(v15 + __len))
        {
          CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because databytes is full.",  v19,  v20,  v21,  v22,  v8,  v9);
LABEL_7:
          *(void *)(a1 + 24) = Error;
          return;
        }

        if (!a4) {
          memmove((void *)(v14 + v15), __src, __len);
        }
      }

      if (!*(_BYTE *)(a1 + 44))
      {
        while (1)
        {
          CFIndex v17 = v12;
          if (!a4)
          {
            CFIndex v17 = v12;
            if (*(void *)a1)
            {
              CFIndex v17 = CFWriteStreamWrite(*(CFWriteStreamRef *)a1, v13, v12);
              if (!v17)
              {
                CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because stream is full.",  v19,  v20,  v21,  v22,  v8,  v9);
                goto LABEL_7;
              }

              if (v17 < 0) {
                break;
              }
            }
          }

          *(void *)(a1 + 32) += v17;
          v13 += v17;
          BOOL v18 = v12 <= v17;
          v12 -= v17;
          if (v18) {
            return;
          }
        }

        if (!*(void *)a1 || (CFErrorRef Error = CFWriteStreamCopyError(*(CFWriteStreamRef *)a1)) == 0LL) {
          CFErrorRef Error = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because the stream had an unknown error.",  v19,  v20,  v21,  v22,  v8,  v9);
        }
        goto LABEL_7;
      }

      if (!a4)
      {
        if (*(void *)a1) {
          CFDataAppendBytes(*(CFMutableDataRef *)a1, v13, v12);
        }
      }

      *(void *)(a1 + 32) += v12;
    }
  }

void _appendString(uint64_t a1, CFStringRef theString, int a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(theString);
  if (Length >= 1025) {
    uint64_t v7 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length, 0LL);
  }
  else {
    uint64_t v7 = buffer;
  }
  v18.int location = 0LL;
  v18.CFIndex length = Length;
  if (CFStringGetBytes(theString, v18, 0x600u, 0, 0, v7, Length, &usedBufLen) == Length)
  {
    char v8 = usedBufLen;
    if (usedBufLen >= 15) {
      char v8 = 15;
    }
    char __src = v8 | 0x50;
    bufferWrite(a1, &__src, 1LL, a3);
    CFIndex v9 = usedBufLen;
    if (usedBufLen >= 15)
    {
      _appendInt(a1, usedBufLen, a3);
      CFIndex v9 = usedBufLen;
    }

    bufferWrite(a1, v7, v9, a3);
  }

  else
  {
    char v10 = 15;
    if (Length < 15) {
      char v10 = Length;
    }
    char __src = v10 | 0x60;
    bufferWrite(a1, &__src, 1LL, a3);
    if (Length >= 15) {
      _appendInt(a1, Length, a3);
    }
    int64_t v11 = 2 * Length;
    CFIndex v12 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * Length, 0LL);
    v19.int location = 0LL;
    v19.CFIndex length = Length;
    CFStringGetCharacters(theString, v19, v12);
    if (Length >= 1)
    {
      unint64_t v13 = v12;
      do
      {
        *unint64_t v13 = bswap32(*v13) >> 16;
        ++v13;
        --Length;
      }

      while (Length);
    }

    bufferWrite(a1, v12, v11, a3);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
  }

  if (v7 != buffer) {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
  }
}

void _appendInt(uint64_t a1, unint64_t a2, int a3)
{
  v7[1] = *MEMORY[0x1895F89C0];
  if (a2 > 0xFF)
  {
    if (a2 >> 16)
    {
      if (HIDWORD(a2))
      {
        char __src = 19;
        int64_t v5 = 8LL;
      }

      else
      {
        char __src = 18;
        int64_t v5 = 4LL;
      }
    }

    else
    {
      char __src = 17;
      int64_t v5 = 2LL;
    }
  }

  else
  {
    char __src = 16;
    int64_t v5 = 1LL;
  }

  v7[0] = bswap64(a2);
  bufferWrite(a1, &__src, 1LL, a3);
  bufferWrite(a1, (_BYTE *)&v7[1] - v5, v5, a3);
}

void __CFBitVectorDeallocate(void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  uint64_t v3 = (void *)a1[4];
  if (v3) {
    CFAllocatorDeallocate(v2, v3);
  }
}

uint64_t __CFBitVectorEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (v2) {
      BOOL v3 = v2 < -7;
    }
    else {
      BOOL v3 = 1;
    }
    if (v3) {
      return 1LL;
    }
    uint64_t v4 = v2 / 8;
    int64_t v5 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v6 = *(unsigned __int8 **)(a2 + 32);
    uint64_t v7 = v4 + 1;
    while (1)
    {
      int v9 = *v5++;
      int v8 = v9;
      int v10 = *v6++;
      if (v8 != v10) {
        break;
      }
      if (!--v7) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t __CFBitVectorHash(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__CFString *__CFBitVectorCopyDescription(void *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[4];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFStringAppendFormat( Mutable,  0LL,  @"<CFBitVector %p [%p]>{count = %lu, capacity = %lu, objects = (\n"),  a1,  v5,  v2,  a1[3];
  uint64_t v6 = 0LL;
  uint64_t v7 = v2 + 63;
  if (v2 >= 0) {
    uint64_t v7 = v2;
  }
  if (v2 >= 64)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v10 = v7 >> 6;
    do
    {
      CFStringAppendFormat(Mutable, 0LL, @"\t%lu : ", v9 << 6);
      unint64_t v11 = 0LL;
      do
      {
        unsigned int v12 = *(unsigned __int8 *)(v3 + ((v8 + v11) >> 3));
        CFStringAppendFormat( Mutable,  0LL,  @"%u%u%u%u",  (v12 >> (v11 & 4 ^ 7)) & 1,  (v12 >> (v11 & 4 ^ 6)) & 1,  (v12 >> (v11 & 4 ^ 5)) & 1,  (v12 >> (v11 & 4 ^ 4)) & 1);
        BOOL v13 = v11 >= 0x3C;
        v11 += 4LL;
      }

      while (!v13);
      CFStringAppend(Mutable, @"\n");
      ++v9;
      v8 += 64LL;
    }

    while (v9 != v10);
    uint64_t v6 = v10 << 6;
  }

  if (v6 < v2)
  {
    CFStringAppendFormat(Mutable, 0LL, @"\t%lu : ", v6);
    do
    {
      CFStringAppendFormat( Mutable,  0LL,  @"%u",  (*(unsigned __int8 *)(v3 + ((unint64_t)v6 >> 3)) >> (~(_BYTE)v6 & 7)) & 1);
      ++v6;
    }

    while (v2 != v6);
  }

  CFStringAppend(Mutable, @"\n}"));
  return Mutable;
}

CFTypeID CFBitVectorGetTypeID(void)
{
  return 24LL;
}

CFBitVectorRef CFBitVectorCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex numBits)
{
  return (CFBitVectorRef)__CFBitVectorInit(allocator, 0, bytes, numBits, v3, v4, v5, v6);
}

uint64_t __CFBitVectorInit( const __CFAllocator *a1, char a2, const void *a3, int64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x18uLL, 24LL, 0LL, a5, a6, a7, a8);
  uint64_t v13 = Instance;
  if (Instance)
  {
    else {
      uint64_t v14 = a4;
    }
    uint64_t v16 = v14 + 63;
    BOOL v15 = v14 < -63;
    uint64_t v17 = v14 + 126;
    if (!v15) {
      uint64_t v17 = v16;
    }
    *(void *)(Instance + 24) = v17 & 0xFFFFFFFFFFFFFFC0LL;
    CFRange v18 = CFAllocatorAllocate(a1, (8 * (v17 >> 6)) | 1, 0LL);
    *(void *)(v13 + 32) = v18;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      CFRange v18 = *(void **)(v13 + 32);
    }

    if (v18)
    {
      bzero(v18, *(void *)(v13 + 24) / 8LL + 1);
      *(void *)(v13 + 16) = a4;
      if (a3)
      {
        if ((a4 & 7) != 0) {
          size_t v19 = a4 / 8 + 1;
        }
        else {
          size_t v19 = a4 / 8;
        }
        memmove(*(void **)(v13 + 32), a3, v19);
      }

      uint64_t v20 = (unint64_t *)(v13 + 8);
      unint64_t v21 = atomic_load((unint64_t *)(v13 + 8));
      while (1)
      {
        unint64_t v22 = __ldaxr(v20);
        if (v22 != v21) {
          break;
        }
        if (__stlxr(v21 & 0xFFFFFFFFFFFFFFF3LL | (4LL * (a2 & 3)), v20)) {
          goto LABEL_20;
        }
        int v23 = 1;
LABEL_21:
        unint64_t v21 = v22;
        if (v23) {
          return v13;
        }
      }

      __clrex();
LABEL_20:
      int v23 = 0;
      goto LABEL_21;
    }

    CFRelease((CFTypeRef)v13);
    return 0LL;
  }

  return v13;
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit(allocator, 1, 0LL, 0LL, v2, v3, v4, v5);
}

CFBitVectorRef CFBitVectorCreateCopy(CFAllocatorRef allocator, CFBitVectorRef bv)
{
  return (CFBitVectorRef)__CFBitVectorInit(allocator, 0, *((const void **)bv + 4), *((void *)bv + 2), v2, v3, v4, v5);
}

CFMutableBitVectorRef CFBitVectorCreateMutableCopy( CFAllocatorRef allocator, CFIndex capacity, CFBitVectorRef bv)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit( allocator,  1,  *((const void **)bv + 4),  *((void *)bv + 2),  v3,  v4,  v5,  v6);
}

CFIndex CFBitVectorGetCount(CFBitVectorRef bv)
{
  return *((void *)bv + 2);
}

CFIndex CFBitVectorGetCountOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!range.length) {
    return 0LL;
  }
  CFBit v4 = value;
  CFIndex v5 = 0LL;
  __CFBitVectorInternalMap( (uint64_t)bv,  range.location,  range.length,  (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorCountBits,  (uint64_t)&v4);
  return v5;
}

uint64_t __CFBitVectorInternalMap( uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t, uint64_t), uint64_t a5)
{
  if (a3)
  {
    uint64_t v7 = result;
    uint64_t v8 = a2 / 8;
    uint64_t v9 = (a2 & 7) + a3;
    if (v9 <= 7) {
      uint64_t v10 = 0LL;
    }
    else {
      uint64_t v10 = (a2 | 0xFFFFFFFFFFFFFFF8LL) + a3;
    }
    if (v9 <= 7) {
      uint64_t v11 = (255 << (8 - a3)) >> (a2 & 7);
    }
    else {
      uint64_t v11 = 0xFFu >> (a2 & 7);
    }
    BOOL result = a4(*(unsigned __int8 *)(*(void *)(result + 32) + v8), v11, a5);
    *(_BYTE *)(*(void *)(v7 + 32) + v8) = *(_BYTE *)(*(void *)(v7 + 32) + v8) & ~(_BYTE)v11 | result & v11;
    if (v10 >= 0) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = v10 + 7;
    }
    unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v14 = v8 + 1;
    if ((unint64_t)(v10 + 7) >= 0xF)
    {
      uint64_t v15 = v12 >> 3;
      do
      {
        --v15;
        BOOL result = a4(*(unsigned __int8 *)(*(void *)(v7 + 32) + v14), 255LL, a5);
        *(_BYTE *)(*(void *)(v7 + 32) + v14++) = result;
      }

      while (v15);
    }

    if (v13 != v10)
    {
      int v16 = 255 << (v13 - v10 + 8);
      BOOL result = a4(*(unsigned __int8 *)(*(void *)(v7 + 32) + v14), v16, a5);
      *(_BYTE *)(*(void *)(v7 + 32) + v14) = *(_BYTE *)(*(void *)(v7 + 32) + v14) & ~(_BYTE)v16 | result & v16;
    }
  }

  return result;
}

uint64_t __CFBitVectorCountBits(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (*(_DWORD *)a3) {
    int v3 = result;
  }
  else {
    int v3 = ~(_DWORD)result;
  }
  *(void *)(a3 + 8) += __CFBitVectorCountBits___CFNibbleBitCount[v3 & a2 & 0xFLL]
                       + (unint64_t)__CFBitVectorCountBits___CFNibbleBitCount[(unint64_t)(v3 & a2) >> 4];
  return result;
}

Boolean CFBitVectorContainsBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!range.length) {
    return 0;
  }
  CFBit v4 = value;
  uint64_t v5 = 0LL;
  __CFBitVectorInternalMap( (uint64_t)bv,  range.location,  range.length,  (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorCountBits,  (uint64_t)&v4);
  return v5 != 0;
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return (*(unsigned __int8 *)(*((void *)bv + 4) + idx / 8) >> (~(_BYTE)idx & 7)) & 1;
}

void CFBitVectorGetBits(CFBitVectorRef bv, CFRange range, UInt8 *bytes)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (range.length)
  {
    v3[0] = bytes;
    v3[1] = range.location & 7;
    v3[2] = range.length;
    char v4 = 1;
    __CFBitVectorInternalMap( (uint64_t)bv,  range.location,  range.length,  (uint64_t (*)(void, uint64_t, uint64_t))__CFBitVectorGetBits,  (uint64_t)v3);
  }

uint64_t __CFBitVectorGetBits(uint64_t result, int a2, uint64_t a3)
{
  unsigned int v3 = a2 & result;
  uint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = 8 - v4;
  if (8 - v4 >= *(void *)(a3 + 16)) {
    uint64_t v5 = *(void *)(a3 + 16);
  }
  if (v4 >= 1)
  {
    if (!*(_BYTE *)(a3 + 24))
    {
      **(_BYTE **)a3 |= v3 >> (8 - v4);
      uint64_t v4 = *(void *)(a3 + 8);
      ++*(void *)a3;
      *(void *)(a3 + 16) -= v4;
      *(_BYTE *)(a3 + 24) = 0;
    }

    v3 <<= v4;
  }

  if (v5 < 8)
  {
    char v7 = v3;
    uint64_t v9 = v5;
  }

  else
  {
    uint64_t v6 = *(_BYTE **)a3;
    do
    {
      char v7 = 0;
      *uint64_t v6 = v3;
      uint64_t v8 = *(void *)(a3 + 8);
      uint64_t v6 = (_BYTE *)(*(void *)a3 + 1LL);
      *(void *)a3 = v6;
      *(void *)(a3 + 16) -= v8;
      uint64_t v9 = v5 - 8;
      LOBYTE(v3) = 0;
      BOOL v10 = (unint64_t)v5 > 0xF;
      v5 -= 8LL;
    }

    while (v10);
  }

  if (v9 >= 1)
  {
    **(_BYTE **)a3 = v7;
    *(void *)(a3 + 16) -= v9;
  }

  return result;
}

CFIndex CFBitVectorGetFirstIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  if (range.length < 1) {
    return -1LL;
  }
  while (((*(unsigned __int8 *)(*((void *)bv + 4) + range.location / 8) >> (~LOBYTE(range.location) & 7)) & 1) != value)
  {
    ++range.location;
    if (!--range.length) {
      return -1LL;
    }
  }

  return range.location;
}

CFIndex CFBitVectorGetLastIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  CFIndex v3 = range.length + range.location - 1;
  while (range.length)
  {
    --range.length;
    int v4 = (*(unsigned __int8 *)(*((void *)bv + 4) + v3 / 8) >> (~(_BYTE)v3 & 7)) & 1;
    --v3;
    if (v4 == value) {
      return v3 + 1;
    }
  }

  return -1LL;
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
  CFIndex v4 = *((void *)bv + 2);
  char v5 = atomic_load((unint64_t *)bv + 1);
  BOOL v6 = (v5 & 0xC) != 4LL || count <= v4;
  if (!v6)
  {
    CFIndex v7 = count;
    uint64_t v8 = v7 + 63;
    BOOL v6 = v7 < -63;
    uint64_t v9 = v7 + 126;
    if (!v6) {
      uint64_t v9 = v8;
    }
    uint64_t v10 = v9 >> 6;
    unint64_t v11 = v9 & 0xFFFFFFFFFFFFFFC0LL;
    uint64_t v12 = (malloc_zone_t *)CFGetAllocator(bv);
    *((void *)bv + 3) = v11;
    *((void *)bv + 4) = __CFSafelyReallocateWithAllocator(v12, *((void **)bv + 4), (8 * v10) | 1, 0LL, 0LL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  CFIndex v13 = count - v4;
  if (count > v4)
  {
    uint64_t v14 = v4 / 8;
    uint64_t v15 = (v4 & 7) + v13;
    uint64_t v16 = (v4 | 0xFFFFFFFFFFFFFFF8LL) + v13;
    int v17 = (255 << ((v4 & 7) - v15 + 8)) >> (v4 & 7);
    if (v15 > 7) {
      LOBYTE(v17) = 0xFFu >> (v4 & 7);
    }
    else {
      uint64_t v16 = 0LL;
    }
    *(_BYTE *)(*((void *)bv + 4) + v14) &= ~(_BYTE)v17;
    if (v16 >= 0) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = v16 + 7;
    }
    unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v20 = v14 + 1;
    if ((unint64_t)(v16 + 7) >= 0xF)
    {
      uint64_t v21 = v18 >> 3;
      do
      {
        *(_BYTE *)(*((void *)bv + 4) + v20++) = 0;
        --v21;
      }

      while (v21);
    }

    if (v19 != v16) {
      *(_BYTE *)(*((void *)bv + 4) + v20) &= ~(255 << (v19 - v16 + 8));
    }
  }

  *((void *)bv + 2) = count;
}

void CFBitVectorFlipBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx)
{
  *(_BYTE *)(*((void *)bv + 4) + idx / 8) ^= 1 << (~(_BYTE)idx & 7);
}

void CFBitVectorFlipBits(CFMutableBitVectorRef bv, CFRange range)
{
  if (range.length)
  {
    CFIndex v2 = range.location / 8;
    CFIndex v3 = (range.location & 7) + range.length;
    if (v3 <= 7) {
      int64_t v4 = 0LL;
    }
    else {
      int64_t v4 = (range.location | 0xFFFFFFFFFFFFFFF8LL) + range.length;
    }
    if (v3 <= 7) {
      char v5 = (255 << (8 - LOBYTE(range.length))) >> (range.location & 7);
    }
    else {
      char v5 = 0xFFu >> (range.location & 7);
    }
    *(_BYTE *)(*((void *)bv + 4) + v2) ^= v5;
    if (v4 >= 0) {
      uint64_t v6 = v4;
    }
    else {
      uint64_t v6 = v4 + 7;
    }
    unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFF8LL;
    CFIndex v8 = v2 + 1;
    if ((unint64_t)(v4 + 7) >= 0xF)
    {
      uint64_t v9 = v6 >> 3;
      do
      {
        *(_BYTE *)(*((void *)bv + 4) + v8) = ~*(_BYTE *)(*((void *)bv + 4) + v8);
        ++v8;
        --v9;
      }

      while (v9);
    }

    if (v7 != v4) {
      *(_BYTE *)(*((void *)bv + 4) + v8) ^= 255 << (v7 - v4 + 8);
    }
  }

void CFBitVectorSetBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx, CFBit value)
{
  uint64_t v3 = *((void *)bv + 4);
  CFIndex v4 = idx / 8;
  int v5 = 1 << (~(_BYTE)idx & 7);
  if (value) {
    char v6 = *(_BYTE *)(v3 + v4) | v5;
  }
  else {
    char v6 = *(_BYTE *)(v3 + v4) & ~(_BYTE)v5;
  }
  *(_BYTE *)(v3 + v4) = v6;
}

void CFBitVectorSetBits(CFMutableBitVectorRef bv, CFRange range, CFBit value)
{
  if (range.length)
  {
    CFIndex v3 = range.location / 8;
    char v4 = range.location & 7;
    CFIndex v5 = (range.location & 7) + range.length;
    char v6 = 8 - LOBYTE(range.length);
    if (value)
    {
      int v7 = (255 << v6) >> v4;
      BOOL v8 = v5 <= 7;
      if (v5 <= 7) {
        int64_t v9 = 0LL;
      }
      else {
        int64_t v9 = (range.location | 0xFFFFFFFFFFFFFFF8LL) + range.length;
      }
      if (!v8) {
        LOBYTE(v7) = 0xFFu >> (range.location & 7);
      }
      *(_BYTE *)(*((void *)bv + 4) + v3) |= v7;
      if (v9 >= 0) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 + 7;
      }
      unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFF8LL;
      CFIndex v12 = v3 + 1;
      if ((unint64_t)(v9 + 7) >= 0xF)
      {
        uint64_t v13 = v10 >> 3;
        do
        {
          *(_BYTE *)(*((void *)bv + 4) + v12++) = -1;
          --v13;
        }

        while (v13);
      }

      if (v11 != v9)
      {
        uint64_t v14 = *((void *)bv + 4);
        int v15 = *(unsigned __int8 *)(v14 + v12) | (255 << (v11 - v9 + 8));
LABEL_29:
        *(_BYTE *)(v14 + v12) = v15;
      }
    }

    else
    {
      int v16 = (255 << v6) >> v4;
      BOOL v17 = v5 <= 7;
      if (v5 <= 7) {
        int64_t v18 = 0LL;
      }
      else {
        int64_t v18 = (range.location | 0xFFFFFFFFFFFFFFF8LL) + range.length;
      }
      if (!v17) {
        LOBYTE(v16) = 0xFFu >> (range.location & 7);
      }
      *(_BYTE *)(*((void *)bv + 4) + v3) &= ~(_BYTE)v16;
      if (v18 >= 0) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 + 7;
      }
      unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8LL;
      CFIndex v12 = v3 + 1;
      if ((unint64_t)(v18 + 7) >= 0xF)
      {
        uint64_t v21 = v19 >> 3;
        do
        {
          *(_BYTE *)(*((void *)bv + 4) + v12++) = 0;
          --v21;
        }

        while (v21);
      }

      if (v20 != v18)
      {
        int v15 = 255 << (v20 - v18 + 8);
        uint64_t v14 = *((void *)bv + 4);
        LOBYTE(v15) = *(_BYTE *)(v14 + v12) & ~(_BYTE)v15;
        goto LABEL_29;
      }
    }
  }

void CFBitVectorSetAllBits(CFMutableBitVectorRef bv, CFBit value)
{
  uint64_t v2 = *((void *)bv + 2);
  uint64_t v3 = v2 + 7;
  if (v2 >= 0) {
    uint64_t v3 = *((void *)bv + 2);
  }
  size_t v4 = v3 >> 3;
  uint64_t v5 = v2 - (v3 & 0xFFFFFFFFFFFFFFF8LL);
  if (v5 >= 1)
  {
    int v6 = 255 << (8 - v5);
    BOOL v7 = (unint64_t)v5 >= 8;
    unint64_t v8 = v5 - 8;
    if (!v7) {
      unint64_t v8 = 0LL;
    }
    if (value)
    {
      if (v7) {
        LOBYTE(v6) = -1;
      }
      *(_BYTE *)(*((void *)bv + 4) + v4) |= v6;
      unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF8LL;
      size_t v10 = v4 + 1;
      if (v8 >= 8)
      {
        uint64_t v11 = -(uint64_t)(v8 >> 3);
        do
        {
          *(_BYTE *)(*((void *)bv + 4) + v10++) = -1;
          BOOL v7 = __CFADD__(v11++, 1LL);
        }

        while (!v7);
      }

      if (v9 != v8)
      {
        int v12 = 255 << (v9 - v8 + 8);
        uint64_t v13 = *((void *)bv + 4);
        char v14 = *(_BYTE *)(v13 + v10) | v12;
LABEL_25:
        *(_BYTE *)(v13 + v10) = v14;
      }
    }

    else
    {
      if (v7) {
        char v15 = 0;
      }
      else {
        char v15 = ~(_BYTE)v6;
      }
      *(_BYTE *)(*((void *)bv + 4) + v4) &= v15;
      unint64_t v16 = v8 & 0xFFFFFFFFFFFFFFF8LL;
      size_t v10 = v4 + 1;
      if (v8 >= 8)
      {
        uint64_t v17 = -(uint64_t)(v8 >> 3);
        do
        {
          *(_BYTE *)(*((void *)bv + 4) + v10++) = 0;
          BOOL v7 = __CFADD__(v17++, 1LL);
        }

        while (!v7);
      }

      if (v16 != v8)
      {
        int v18 = 255 << (v16 - v8 + 8);
        uint64_t v13 = *((void *)bv + 4);
        char v14 = *(_BYTE *)(v13 + v10) & ~(_BYTE)v18;
        goto LABEL_25;
      }
    }
  }

  uint64_t v19 = (void *)*((void *)bv + 4);
  if (value) {
    int v20 = -1;
  }
  else {
    int v20 = 0;
  }
  memset(v19, v20, v4);
}

uint64_t CFStringEncodingIsValidCombiningCharacterForLatin1(int a1)
{
  else {
    return (__CFLatin1CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t CFStringEncodingPrecomposeLatinCharacter(unsigned __int16 *a1, uint64_t a2, unint64_t *a3)
{
  if (a2 < 1) {
    goto LABEL_18;
  }
  unsigned int v5 = *a1;
  if ((v5 & 0xF800 | 0x400) == 0xDC00)
  {
    if (a3) {
      *a3 = 1LL;
    }
    return (unsigned __int16)v5;
  }

  unint64_t v7 = 1LL;
  if ((unint64_t)a2 >= 2)
  {
    while (1)
    {
      unsigned int v8 = a1[v7];
      unsigned int v9 = CFUniCharPrecomposeCharacter(v5, v8);
      if (v9 == 65533 || HIWORD(v9) != 0) {
        break;
      }
      ++v7;
      unsigned int v5 = v9;
      if (a2 == v7)
      {
        LOWORD(v5) = v9;
        unint64_t v7 = a2;
        break;
      }
    }
  }

  if (a3) {
    *a3 = v7;
  }
  if (v7 <= 1) {
LABEL_18:
  }
    LOWORD(v5) = -3;
  return (unsigned __int16)v5;
}

BOOL __CFToASCII(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F) {
    *a3 = a2;
  }
  return a2 < 0x80;
}

uint64_t __CFFromASCII(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) == 0) {
    *a3 = a2;
  }
  return (a2 >> 7) ^ 1;
}

BOOL __CFToISOLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xFF) {
    *a3 = a2;
  }
  return a2 < 0x100;
}

uint64_t __CFFromISOLatin1(uint64_t a1, __int16 a2, _WORD *a3)
{
  *a3 = a2;
  return 1LL;
}

unint64_t __CFToISOLatin1Precompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v13[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v13);
  if (v9 > 0xFF) {
    return 0LL;
  }
  char v10 = v9;
  unint64_t result = 0LL;
  if (v10)
  {
    unint64_t v12 = v13[0];
    if ((uint64_t)v13[0] >= 2)
    {
      if (a5) {
        *a4 = v10;
      }
      *a6 = 1LL;
      return v12;
    }
  }

  return result;
}

uint64_t __CFToMacRoman(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      size_t v4 = (unsigned __int16 *)&macRoman_from_uni;
      unsigned int v5 = (unsigned __int16 *)&unk_180C33080;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        unint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          size_t v4 = v7 + 2;
        }

        else
        {
          unsigned int v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

uint64_t __CFFromMacRoman(uint64_t a1, int a2, _WORD *a3)
{
  *a3 = __CFMacRomanCharToUnicharTable[a2];
  return 1LL;
}

unint64_t __CFToMacRomanPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v18[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    int v10 = v9;
    goto LABEL_3;
  }

  uint64_t v13 = (unsigned __int16 *)&macRoman_from_uni;
  char v14 = (unsigned __int16 *)&unk_180C33080;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    unint64_t v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v9) {
      break;
    }
    char v14 = v16 - 2;
LABEL_14:
    if (v13 > v14) {
      return 0LL;
    }
  }

  if (v17 < v9)
  {
    uint64_t v13 = v16 + 2;
    goto LABEL_14;
  }

  int v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  unint64_t result = 0LL;
  if (v10)
  {
    unint64_t v12 = v18[0];
    if ((uint64_t)v18[0] >= 2)
    {
      if (a5) {
        *a4 = v10;
      }
      *a6 = 1LL;
      return v12;
    }
  }

  return result;
}

uint64_t __CFToWinLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 < 0x80 || a2 - 160 <= 0x5F)
  {
    char v9 = a2;
    goto LABEL_12;
  }

  if (a2 - 8483 < 0xFFFFE02F) {
    return 0LL;
  }
  uint64_t v3 = (unsigned __int16 *)&cp1252_from_uni;
  size_t v4 = (unsigned __int16 *)&unk_180C330EC;
  while (1)
  {
    uint64_t v5 = ((char *)v4 - (char *)v3) >> 3;
    uint64_t v6 = &v3[2 * v5];
    unsigned int v7 = *v6;
    if (v7 <= a2) {
      break;
    }
    size_t v4 = v6 - 2;
LABEL_9:
    if (v3 > v4) {
      return 0LL;
    }
  }

  if (v7 < a2)
  {
    uint64_t v3 = v6 + 2;
    goto LABEL_9;
  }

  char v9 = v3[2 * v5 + 1];
LABEL_12:
  *a3 = v9;
  return 1LL;
}

BOOL __CFFromWinLatin1(uint64_t a1, int a2, _WORD *a3)
{
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin1Precompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, (unint64_t *)&v14);
  int v10 = __CFToWinLatin1(v9, v9, &v15);
  uint64_t result = v14;
  if (v10) {
    BOOL v12 = v15 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || v14 < 2) {
    return 0LL;
  }
  if (a5) {
    *a4 = v15;
  }
  *a6 = 1LL;
  return result;
}

uint64_t __CFToNextStepLatin(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      size_t v4 = (unsigned __int16 *)&nextstep_from_tab;
      uint64_t v5 = (unsigned __int16 *)&unk_180C33328;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        unsigned int v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          size_t v4 = v7 + 2;
        }

        else
        {
          uint64_t v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

BOOL __CFFromNextStepLatin(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = NSToPrecompUnicodeTable[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

unint64_t __CFToNextStepLatinPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v18[1] = *MEMORY[0x1895F89C0];
  v18[0] = 0LL;
  unsigned int v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    int v10 = v9;
    goto LABEL_3;
  }

  uint64_t v13 = (unsigned __int16 *)&nextstep_from_tab;
  int64_t v14 = (unsigned __int16 *)&unk_180C33328;
  while (1)
  {
    uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
    uint64_t v16 = &v13[2 * v15];
    unsigned int v17 = *v16;
    if (v17 <= v9) {
      break;
    }
    int64_t v14 = v16 - 2;
LABEL_16:
    if (v13 > v14) {
      return 0LL;
    }
  }

  if (v17 < v9)
  {
    uint64_t v13 = v16 + 2;
    goto LABEL_16;
  }

  int v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  unint64_t result = v18[0];
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return result;
}

uint64_t __CFToUTF8(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v6 = a4;
  unsigned int v7 = a2;
  if (a3 < 1)
  {
LABEL_43:
    if (!a6) {
      return v7 - a2;
    }
    goto LABEL_44;
  }

  unint64_t v8 = (unint64_t)&a2[a3];
  unint64_t v9 = (unint64_t)&a4[a5];
  int v10 = a2;
  uint64_t v6 = a4;
  while (1)
  {
    if (a5 && (unint64_t)v6 >= v9)
    {
LABEL_42:
      unsigned int v7 = v10;
      goto LABEL_43;
    }

    unsigned int v7 = v10 + 1;
    unsigned int v11 = *v10;
    if (v11 <= 0x7F)
    {
      if (a5) {
        *uint64_t v6 = v11;
      }
      uint64_t v12 = 1LL;
      goto LABEL_40;
    }

    if (v11 >> 11 >= 0x1B)
    {
      if (v11 >> 10 > 0x36)
      {
        if ((a1 & 0x80) == 0 && v11 < 0xE000) {
          goto LABEL_42;
        }
      }

      else if ((unint64_t)v7 < v8 && (int v13 = *v7, (v13 & 0xFC00) == 0xDC00))
      {
        unsigned int v7 = v10 + 2;
        unsigned int v11 = v13 + (v11 << 10) - 56613888;
      }

      else if ((a1 & 0x80) == 0)
      {
        goto LABEL_42;
      }
    }

    if (!a5)
    {
      if (v11 < 0x10000) {
        unsigned __int16 v14 = 3;
      }
      else {
        unsigned __int16 v14 = 4;
      }
      if (v11 < 0x800) {
        unsigned __int16 v14 = 2;
      }
      if (v11 < 0x80) {
        unsigned __int16 v14 = 1;
      }
      goto LABEL_39;
    }

    if (v11 < 0x10000) {
      unsigned __int16 v14 = 3;
    }
    else {
      unsigned __int16 v14 = 4;
    }
    if (v11 < 0x800) {
      unsigned __int16 v14 = 2;
    }
    if (v11 < 0x80) {
      unsigned __int16 v14 = 1;
    }
    switch(v14)
    {
      case 1u:
        goto LABEL_31;
      case 2u:
        goto LABEL_30;
      case 3u:
        goto LABEL_29;
      case 4u:
        v6[3] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_29:
        void v6[2] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_30:
        v6[1] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_31:
        *uint64_t v6 = firstByteMark[v14] | v11;
        break;
      default:
        break;
    }

LABEL_39:
    uint64_t v12 = v14;
LABEL_40:
    v6 += v12;
    int v10 = v7;
  }

  uint64_t v16 = -4LL;
  if (v11 < 0x10000) {
    uint64_t v16 = -2LL;
  }
  unsigned int v7 = (unsigned __int16 *)((char *)v7 + v16);
  if (a6) {
LABEL_44:
  }
    *a6 = v6 - a4;
  return v7 - a2;
}

  *(void *)(a1 + 16) &= ~0x40uLL;
  return result;
}

    *a7 = a8;
    *a9 = a10;
    return;
  }

    unint64_t v24 = 0;
    *(_DWORD *)(a1 + 124) = 0;
LABEL_40:
    *(void *)(a1 + 48) = result;
    uint64_t v25 = (int)v24;
    if (a3)
    {
      *(void *)(a1 + 32) = v11;
      char v26 = _bufferSizes[v24];
      *(void *)(a1 + 16) = v11 + v26;
      if (v11 + v26 <= v9)
      {
        if (v11 + v26 < v9)
        {
          unint64_t v9 = __pinIndex(v11 + v26, v9, theString, a3, 1);
          *(void *)(a1 + 16) = v9;
          unsigned int v11 = *(void *)(a1 + 32);
        }

        else
        {
          LODWORD(v9) = v11 + v26;
        }
      }

      else
      {
        *(void *)(a1 + 16) = v9;
      }

      uint64_t v29 = 0;
      unsigned int v30 = v9 - v11;
      unsigned int v31 = v9 - v11;
    }

    else
    {
      if (v11 >= v9) {
        unsigned int v27 = v9;
      }
      else {
        unsigned int v27 = v11;
      }
      *(void *)(a1 + 16) = v27;
      uint64_t v28 = _bufferSizes[v25];
      unsigned int v11 = v27 - v28;
      *(void *)(a1 + 32) = v27 - v28;
      if (v27 - v28 < 0)
      {
        unsigned int v11 = 0LL;
        *(void *)(a1 + 32) = 0LL;
      }

      else if (v27 != v28)
      {
        unsigned int v11 = __pinIndex(v27 - v28, v9, theString, 0, 1);
        *(void *)(a1 + 32) = v11;
        unsigned int v27 = *(void *)(a1 + 16);
      }

      uint64_t v29 = v27 - v11;
      unsigned int v30 = v29;
      unsigned int v31 = v29;
    }

    *(_DWORD *)(a1 + 40) = v29;
    *(_DWORD *)(a1 + 44) = v30;
    v33.CFIndex length = v31;
    v33.int location = v11;
    CFStringGetCharacters(theString, v33, *(UniChar **)(a1 + 48));
    int v20 = *(_DWORD *)(a1 + 44);
    goto LABEL_57;
  }

  unint64_t result = (uint64_t)malloc(0x400uLL);
  *(void *)(a1 + 88) = result;
  if (result) {
    goto LABEL_39;
  }
  return result;
}

      unint64_t v52 = v43 - v46;
      if (v43 - v46 >= 1)
      {
        uint64_t v53 = (v43 - 1);
        uint64_t v54 = *(unsigned __int16 *)&v44[2 * v53];
        if (v54 == 8217 || v54 == 39)
        {
          LODWORD(v53) = v43 - 2;
          goto LABEL_43;
        }

        if (v52 >= 2)
        {
          uint64_t v74 = (unsigned __int16 *)&v44[2 * (int)v43];
          CFSetRef v77 = *(v74 - 2);
          unint64_t v75 = v74 - 2;
          uint64_t v76 = v77;
          if ((v77 == 8217 || v76 == 39) && (unint64_t v78 = v54 - 100, v78 <= 0x10) && ((1 << v78) & 0x18001) != 0)
          {
            LODWORD(v53) = v43 - 3;
LABEL_43:
            uint64_t v53 = (int)v53;
          }

          else if (v52 >= 3)
          {
            BOOL v83 = *(unsigned __int16 *)&v44[2 * (int)v43 - 6];
            if (v83 == 8217 || v83 == 39)
            {
              uint64_t v84 = 0LL;
              uint64_t v85 = 1;
              CFTypeRef v86 = &word_180D7F8E2;
              do
              {
                if (v76 == (unsigned __int16)*(v86 - 1))
                {
                  uint64_t v42 = (unsigned __int16)*v86;
                  if (v75[1] == (_DWORD)v42) {
                    break;
                  }
                }

                uint64_t v85 = v84 < 4;
                v86 += 2;
                ++v84;
              }

              while (v84 != 5);
              if (v85) {
                uint64_t v53 = (int)v43 - 4;
              }
            }
          }
        }

        unint64_t v55 = v53 <= v46;
        unsigned int v56 = v53 - v46;
        if (v55) {
          uint64_t v57 = 0LL;
        }
        else {
          uint64_t v57 = v46;
        }
        if (v55) {
          int v58 = (v41 - v37);
        }
        else {
          int v58 = v56 + 1;
        }
        if (v58 < 5) {
          goto LABEL_98;
        }
        uint64_t v98 = v30;
        uint64_t v93 = v37;
        unint64_t v95 = a3 + v37;
        MEMORY[0x1895F8858](v42, &v44[2 * v57]);
        uint64_t v61 = (char *)&v92 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        BOOL v62 = 0LL;
        do
        {
          uint64_t v63 = 0;
          uint64_t v64 = v62 + 2;
          if (v62 >= 3 && v64 < v58) {
            uint64_t v63 = v59[v62 - 1] - 97 <= 0x19 && v59[v62] - 65 < 0x1A;
          }
          v61[v62++] = v63;
        }

        while (v64 - 1 != v58);
        CFRange v96 = v60;
        MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( v102,  v59,  v58,  v58,  v101);
        if (!MutableWithExternalCharactersNoCopy) {
          goto LABEL_103;
        }
        unsigned int v97 = &v92;
        uint64_t v66 = MutableWithExternalCharactersNoCopy;
        CFStringLowercase(MutableWithExternalCharactersNoCopy, v9);
        uint64_t v67 = __CFHyphenationCopyTrieInstance(v9);
        char v68 = v66;
        if (v67)
        {
          unint64_t v69 = v67;
          v108[0] = 0;
          uint64_t v94 = v68;
          CFBurstTrieContains((uint64_t)v67, v68, 0LL, v58, v108);
          CFBurstTrieRelease(v69);
          if (v108[0] >> 28 != 15)
          {
            char v68 = v94;
            goto LABEL_77;
          }

          uint64_t v70 = v106;
          if (v106 < 1 || v108[0] == -1)
          {
            CFRelease(v94);
          }

          else
          {
            unint64_t v71 = 0LL;
            uint64_t v72 = ~v108[0];
            uint64_t v73 = v99 + v96 + v93;
            do
            {
              if ((v72 & 1) != 0) {
                *((void *)&v104->isa + v71++) = v73;
              }
              if (v72 < 2) {
                break;
              }
              v72 >>= 1;
              ++v73;
            }

            while (v71 < v70);
            char v68 = v94;
            if (v71 == -1) {
              goto LABEL_77;
            }
LABEL_83:
            CFRelease(v68);
            if (v71 >= 1)
            {
              v38 += v71;
              if (v106 - v71 < 1) {
                goto LABEL_103;
              }
              v106 -= v71;
              CFURLRef v104 = (const __CFString *)((char *)v104 + 8 * v71);
            }
          }

          uint64_t v40 = v105;
          unsigned int v30 = v98;
          goto LABEL_98;
        }

  unsigned int v31 = 1;
LABEL_40:
  if (v28) {
    uint64_t v32 = v29;
  }
  else {
    uint64_t v32 = v31;
  }
  *a8 = v32;
  if ((v32 - 2) <= 2)
  {
    unint64_t v33 = v32 - 3;
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, a1);
    unsigned int v35 = MutableCopy;
    if (v32 == 4 || v32 == 2) {
      char v37 = v8;
    }
    else {
      char v37 = 0LL;
    }
    if (v33 >= 2) {
      v38.int location = a6;
    }
    else {
      v38.int location = a4;
    }
    if (v33 >= 2) {
      uint64_t v39 = 0LL;
    }
    else {
      uint64_t v39 = a5;
    }
    v38.CFIndex length = (CFIndex)v39 + v37;
    CFStringDelete(MutableCopy, v38);
    *a2 = v35;
  }

unsigned __int8 *__CFFromUTF8( __int16 a1, unsigned __int8 *a2, uint64_t a3, _WORD *a4, uint64_t a5, void *a6)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  uint64_t v39 = 0LL;
  uint64_t v40 = a4;
  unint64_t v8 = a2;
  if (a3)
  {
    uint64_t v10 = a3;
    int v12 = a1 & 0xC0;
    int v13 = &offsetsFromUTF8;
    unint64_t v8 = a2;
    while (1)
    {
      uint64_t v14 = v39;
      if (a5 && v39 >= a5) {
        goto LABEL_73;
      }
      unsigned int v15 = *v8;
      --v10;
      if ((~(_BYTE)v15 & 0xF8) == 0) {
        break;
      }
      uint64_t v18 = (unsigned __int16)trailingBytesForUTF8[*v8];
      if ((a1 & 0x800) == 0)
      {
        uint64_t v19 = &v8[v18];
        while (v19 > v8)
        {
          char v20 = *v19--;
          if ((v20 & 0xC0) != 0x80) {
            goto LABEL_7;
          }
        }

        if (*v8 > 0xEFu)
        {
          if (v15 == 240)
          {
            if (v8[1] < 0x90u) {
              break;
            }
          }

          else if (v15 == 244 && v8[1] >= 0x90u)
          {
            break;
          }
        }

        else if (v15 == 224)
        {
          if (v8[1] < 0xA0u) {
            break;
          }
        }

        else if (v15 == 237 && v8[1] > 0x9Fu)
        {
          break;
        }
      }

      int v21 = 0;
      int v22 = (unsigned __int16)trailingBytesForUTF8[*v8];
      switch(*v8)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_39;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_38;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_37;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          int v21 = v15 << 6;
          unsigned int v23 = *++v8;
          unsigned int v15 = v23;
LABEL_37:
          unsigned int v24 = *++v8;
          int v21 = (v21 + v15) << 6;
          unsigned int v15 = v24;
LABEL_38:
          unsigned int v25 = *++v8;
          int v22 = (v21 + v15) << 6;
          unsigned int v15 = v25;
LABEL_39:
          ++v8;
          int v21 = v22 + v15;
          break;
        default:
          break;
      }

      v10 -= v18;
      unsigned int v26 = v21 - v13[v18];
      if (HIWORD(v26))
      {
        if (v26 >= 0x110000)
        {
          if ((a1 & 0x80) == 0) {
            goto LABEL_72;
          }
          if (a5)
          {
            unsigned int v31 = v40;
            *uint64_t v40 = -3;
            uint64_t v40 = v31 + 1;
          }

          goto LABEL_12;
        }

        if (!v12) {
          goto LABEL_62;
        }
        unsigned int v27 = v13;
        if ((CFUniCharIsMemberOf(v21 - v13[v18], 0x65u) & 1) == 0)
        {
          uint64_t v14 = v39;
          int v13 = v27;
LABEL_62:
          uint64_t v17 = v14 + 2;
          if (a5)
          {
            if (v17 > a5) {
              goto LABEL_73;
            }
            unsigned int v35 = v40;
            *uint64_t v40 = ((v26 + 67043328) >> 10) - 10240;
            uint64_t v40 = v35 + 2;
            v35[1] = v26 & 0x3FF | 0xDC00;
          }

LABEL_73:
  if (a6) {
    *a6 = v39;
  }
  return (unsigned __int8 *)(v8 - a2);
}

          CFStringAppendCharacters(Mutable, chars, 1LL);
LABEL_74:
          if (v22 == ++v23) {
            goto LABEL_75;
          }
        }

        switch(CharacterAtIndex)
        {
          case 'h':
            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              unsigned int v25 = CFStringGetLength(Mutable);
            }
            if (v63) {
              goto LABEL_59;
            }
            break;
          case 'i':
          case 'l':
          case 'n':
          case 'o':
          case 'p':
          case 'q':
          case 'r':
            goto LABEL_73;
          case 'j':
            goto LABEL_39;
          case 'k':
            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              unsigned int v25 = CFStringGetLength(Mutable);
            }
            if (!v60) {
              break;
            }
            unsigned int v24 = 0;
            uint64_t v28 = 75;
            goto LABEL_60;
          case 'm':
          case 's':
            if (v24) {
              goto LABEL_67;
            }
            CFStringGetLength(Mutable);
            break;
          default:
            if (CharacterAtIndex != 75)
            {
              if (CharacterAtIndex == 97)
              {
                unsigned int v27 = v24;
                unsigned int v24 = v24;
                if (!v27)
                {
                  if (v58)
                  {
                    unsigned int v24 = 0;
                    goto LABEL_74;
                  }
                }
              }

              goto LABEL_73;
            }

            if (v24) {
              goto LABEL_67;
            }
            if (v25 == -1) {
              unsigned int v25 = CFStringGetLength(Mutable);
            }
            if (v63)
            {
              unsigned int v24 = 0;
              uint64_t v28 = 107;
              goto LABEL_60;
            }

            break;
        }

            unint64_t v50 = v11;
LABEL_74:
          }
        }

      if (++v23 >= length) {
        return;
      }
    }
  }

  unsigned int v24 = atomic_load((unint64_t *)&theString->info);
  unsigned int v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    unsigned int v26 = *v25;
  }

  else
  {
    unsigned int v27 = atomic_load((unint64_t *)&theString->info);
    unsigned int v26 = (char *)&v25[(v27 & 5) != 4LL];
  }

  uint64_t v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    unsigned int v23 = 0LL;
    uint64_t v29 = &v26[(v28 >> 2) & 1];
    do
    {
      unint64_t v30 = v29[v23];
      if ((v30 - 65) > 0x19)
      {
        if ((v30 & 0x80) != 0) {
          goto LABEL_28;
        }
      }

      else
      {
        v29[v23] = v30 + 32;
      }

      ++v23;
    }

    while (length != v23);
  }

      if (v51 + 56 >= v80) {
        goto LABEL_87;
      }
      uint64_t v54 = 1;
      unint64_t v55 = v51;
      while (1)
      {
        unsigned int v56 = (char *)v20 + v55;
        uint64_t v57 = (char *)v20 + v55 + 56;
        int v58 = strncmp((const char *)v20 + v55 + 72, "__OBJC", 0x10uLL);
        if (!v58) {
          unsigned int v24 = 1;
        }
        if (!(strncmp(v57, "__image_info", 0x10uLL) | v58)) {
          break;
        }
        if (v54 >= v53)
        {
          char v20 = v81;
          goto LABEL_87;
        }

        uint64_t v59 = v55 + 124;
        v55 += 68LL;
        ++v54;
        char v20 = v81;
        if (v59 >= v80) {
          goto LABEL_87;
        }
      }

      a5 = v78;
      if (!v78)
      {
        LODWORD(v75) = *((_DWORD *)v56 + 23);
        uint64_t v74 = *(unsigned int *)((char *)v81 + v55 + 96);
        goto LABEL_98;
      }

      LODWORD(v75) = bswap32(*((_DWORD *)v56 + 23));
      char v20 = v81;
      uint64_t v74 = bswap32(*(unsigned int *)((char *)v81 + v55 + 96));
      int v60 = 1;
      unsigned int v27 = v77;
    }

    else
    {
      int v60 = 0;
    }

    uint64_t v61 = v50[1];
LABEL_88:
    uint64_t v61 = bswap32(v61);
    BOOL v62 = v60;
LABEL_89:
    if (v62) {
      goto LABEL_98;
    }
    goto LABEL_90;
  }

  unsigned int v25 = v20[4];
  uint64_t v73 = a1;
  if (a5)
  {
    unsigned int v25 = bswap32(v25);
    unsigned int v26 = bswap32(v20[5]);
  }

  else
  {
    unsigned int v26 = v20[5];
  }

  unsigned int v24 = 0;
  if (v26 <= 0xFE0) {
    uint64_t v29 = v26 + 32LL;
  }
  else {
    uint64_t v29 = 4096LL;
  }
  if (!v25)
  {
    unsigned int v23 = 0;
    int v22 = 0;
    goto LABEL_112;
  }

  unint64_t v69 = a4;
  char v68 = v17;
  unsigned int v23 = 0;
  int v22 = 0;
  if (v29 < 0x21) {
    goto LABEL_112;
  }
  uint64_t v66 = a2;
  uint64_t v67 = a3;
  uint64_t v70 = v19;
  unint64_t v71 = a7;
  uint64_t v72 = a8;
  LODWORD(v75) = 0;
  uint64_t v74 = 0;
  unint64_t v30 = 0;
  unsigned int v24 = 0;
  unsigned int v31 = (int *)(v20 + 8);
  uint64_t v32 = 32LL;
  uint64_t v76 = v25;
  while (1)
  {
    uint64_t v33 = *v31;
    if (a5) {
      break;
    }
    if (v33 == 25)
    {
      char v34 = v31[16];
      goto LABEL_29;
    }

    uint64_t v42 = v31[1];
LABEL_48:
    if (++v30 < v25)
    {
      v32 += v42;
      unsigned int v31 = (int *)((char *)v20 + v32);
      unint64_t v44 = v32 < 0x20 || v32 >= v29;
      if (!v44) {
        continue;
      }
    }

    goto LABEL_98;
  }

  if (v33 != 419430400)
  {
    unint64_t v41 = 0;
LABEL_43:
    uint64_t v42 = v31[1];
LABEL_46:
    uint64_t v42 = bswap32(v42);
    unsigned int v43 = v41;
LABEL_47:
    if (v43) {
      goto LABEL_98;
    }
    goto LABEL_48;
  }

  char v34 = bswap32(v31[16]);
LABEL_29:
  uint64_t v79 = v30;
  if (!v34 || v32 + 72 >= v29)
  {
LABEL_45:
    unint64_t v41 = 0;
    unsigned int v43 = 0;
    uint64_t v42 = v31[1];
    unsigned int v25 = v76;
    a5 = v78;
    unint64_t v30 = v79;
    if (!v78) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }

  unsigned int v35 = v32 + 152;
  uint64_t v36 = 1;
  while (1)
  {
    char v37 = v29;
    BOOL v38 = (char *)v20 + v35;
    uint64_t v39 = (char *)v20 + v35 - 80;
    uint64_t v40 = strncmp((const char *)v20 + v35 - 64, "__DATA", 0x10uLL);
    if (!v40) {
      unsigned int v24 = 1;
    }
    if (!(strncmp(v39, "__objc_imageinfo", 0x10uLL) | v40)) {
      break;
    }
    if (v36 >= v34)
    {
      char v20 = v81;
      uint64_t v29 = v37;
      goto LABEL_45;
    }

    ++v36;
    uint64_t v29 = v37;
    unint64_t v44 = v35 >= v37;
    v35 += 80LL;
    char v20 = v81;
    if (v44) {
      goto LABEL_45;
    }
  }

  a5 = v78;
  if (v78)
  {
    LODWORD(v75) = bswap64(*((void *)v38 - 5));
    char v20 = v81;
    uint64_t v74 = bswap32(*(unsigned int *)((char *)v81 + v35 - 32));
    unint64_t v41 = 1;
    unsigned int v25 = v76;
    uint64_t v29 = v37;
    unint64_t v30 = v79;
    goto LABEL_43;
  }

  uint64_t v74 = *(unsigned int *)((char *)v81 + v35 - 32);
  unint64_t v75 = *((void *)v38 - 5);
LABEL_98:
  if (v75 < 8)
  {
    unsigned int v23 = 0;
    int v22 = 0;
    a7 = v71;
    a8 = v72;
    uint64_t v19 = v70;
    goto LABEL_112;
  }

  if (v73 < 0 || lseek(v73, v74 + v69, 0) != v74 + v69 || read(v73, &v82, 8uLL) < 8)
  {
    a7 = v71;
    a8 = v72;
    uint64_t v19 = v70;
    if (v69 + v74 + 8 <= v67)
    {
      unint64_t v65 = (unsigned int *)(v66 + v68 + v74);
      int v22 = *v65;
      if (a5)
      {
        int v22 = bswap32(v22);
        uint64_t v64 = v65[1];
LABEL_109:
        unsigned int v23 = bswap32(v64);
      }

      else
      {
        unsigned int v23 = v65[1];
      }

      goto LABEL_112;
    }

    unsigned int v11 = CFStringCreateWithBytes(0LL, v16, v18 - v16, 0x8000100u, 0);
LABEL_74:
    if (v12 >= 0x401) {
      free(v14);
    }
    return v11;
  }

  return 0LL;
}

        if ((a1 & 1) != 0)
        {
          uint64_t v39 = 63;
          goto LABEL_75;
        }

uint64_t __CFToUTF8Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  LODWORD(result) = 0;
  size_t v4 = a2;
  do
  {
    unsigned int v6 = *v4++;
    unsigned int v5 = v6;
    uint64_t v7 = a3 - 1;
    if ((v6 & 0xFC00) != 0xD800 || a3 == 1)
    {
      --a3;
    }

    else
    {
      int v9 = *v4;
      int v10 = v9 & 0xFC00;
      unsigned int v11 = a2 + 2;
      int v12 = v9 + (v5 << 10) - 56613888;
      a3 -= 2LL;
      if (v10 == 56320) {
        size_t v4 = v11;
      }
      else {
        a3 = v7;
      }
      if (v10 == 56320) {
        unsigned int v5 = v12;
      }
    }

    if (v5 < 0x10000) {
      int v13 = 3;
    }
    else {
      int v13 = 4;
    }
    if (v5 < 0x800) {
      int v13 = 2;
    }
    if (v5 >= 0x80) {
      int v14 = v13;
    }
    else {
      int v14 = 1;
    }
    uint64_t result = (v14 + result);
    a2 = v4;
  }

  while (a3);
  return result;
}

uint64_t __CFFromUTF8Len(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v6 = 0LL;
    int v7 = a1 & 0xC0;
    while (1)
    {
      unsigned int v8 = *a2;
      --v3;
      if ((~(_BYTE)v8 & 0xF8) == 0) {
        break;
      }
      uint64_t v9 = (unsigned __int16)trailingBytesForUTF8[*a2];
      if ((a1 & 0x800) == 0)
      {
        int v10 = &a2[v9];
        while (v10 > a2)
        {
          char v11 = *v10--;
          if ((v11 & 0xC0) != 0x80) {
            goto LABEL_5;
          }
        }

        if (*a2 > 0xEFu)
        {
          if (v8 == 240)
          {
            if (a2[1] < 0x90u) {
              break;
            }
          }

          else if (v8 == 244 && a2[1] >= 0x90u)
          {
            break;
          }
        }

        else if (v8 == 224)
        {
          if (a2[1] < 0xA0u) {
            break;
          }
        }

        else if (v8 == 237 && a2[1] > 0x9Fu)
        {
          break;
        }
      }

      int v12 = 0;
      int v13 = (unsigned __int16)trailingBytesForUTF8[*a2];
      switch(*a2)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_34;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_33;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_32;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          int v12 = v8 << 6;
          unsigned int v14 = *++a2;
          unsigned int v8 = v14;
LABEL_32:
          unsigned int v15 = *++a2;
          int v12 = (v12 + v8) << 6;
          unsigned int v8 = v15;
LABEL_33:
          unsigned int v16 = *++a2;
          int v13 = (v12 + v8) << 6;
          unsigned int v8 = v16;
LABEL_34:
          ++a2;
          int v12 = v13 + v8;
          break;
        default:
          break;
      }

      v3 -= v9;
      unsigned int v17 = v12 - offsetsFromUTF8[v9];
      if (HIWORD(v17))
      {
        if (v17 < 0x110000)
        {
          if (v7 && CFUniCharIsMemberOf(v17, 0x65u))
          {
            uint64_t v18 = CFUniCharDecomposeCharacter(v17, v22, 10LL);
            if (v18 >= 1)
            {
              do
              {
                if (v22[v18 - 1] < 0x10000) {
                  uint64_t v19 = 1LL;
                }
                else {
                  uint64_t v19 = 2LL;
                }
                v6 += v19;
              }

              while ((unint64_t)v18-- > 1);
            }
          }

          else
          {
            v6 += 2LL;
          }

          goto LABEL_9;
        }
      }

      else
      {
        if ((a1 & 0x80) == 0 && (v17 & 0xFFFFF800) == 0xD800) {
          return v6;
        }
        if (v7 && v17 >= 0x80 && CFUniCharIsMemberOf(v17, 0x65u))
        {
          v6 += CFUniCharDecomposeCharacter(v17, v22, 10LL);
          goto LABEL_9;
        }
      }

LABEL_5:
    if ((a1 & 1) == 0 && v8 != 169) {
      return v6;
    }
    ++a2;
    goto LABEL_8;
  }

  return 0LL;
}

  uint64_t v19 = atomic_load((unint64_t *)&a1->info);
  p_data = &a1->data;
  if ((v19 & 0x60) != 0)
  {
    int v21 = (char **)*p_data;
    if (__dst)
    {
LABEL_7:
      if (a3 >= a8) {
        a3 = a8;
      }
      int v22 = atomic_load((unint64_t *)&a1->info);
      memmove(__dst, (char *)v21 + a2 + ((v22 >> 2) & 1), a3);
    }
  }

  else
  {
    unsigned int v24 = atomic_load((unint64_t *)&a1->info);
    int v21 = &p_data[(v24 & 5) != 4LL];
    if (__dst) {
      goto LABEL_7;
    }
  }

  if (a9) {
    *a9 = a3;
  }
  return a3;
}

  while (1)
  {
    int v10 = -1;
LABEL_6:
    if (v10 != 12288
      && (unsigned __int16)(v10 - 0x2000) >= 0xCu
      && v10 >= 0x21u
      && (unsigned __int16)(v10 - 127) > 0x21u)
    {
      break;
    }

    uint64_t v6 = *a2 + 1;
    *a2 = v6;
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_2;
    }
  }

  unsigned int v14 = v10 - 48;
  if (v10 != 48)
  {
    if ((unsigned __int16)(v10 - 48) > 9u)
    {
      if ((unsigned __int16)(v10 - 65) > 5u)
      {
        unsigned int v14 = v10 - 87;
      }

      else
      {
        unsigned int v14 = v10 - 55;
      }
    }

    if (v14 != -1) {
      goto LABEL_33;
    }
    return 0LL;
  }

  unsigned int v15 = *a2;
  unsigned int v16 = v15 + 1;
  *a2 = v15 + 1;
  if ((int)v15 >= -1)
  {
    unsigned int v17 = *((void *)buffer + 20);
    if (v17 > v16)
    {
      uint64_t v18 = *((void *)buffer + 17);
      if (v18)
      {
        uint64_t v19 = *(_WORD *)(v18 + 2 * (*((void *)buffer + 19) + v16));
      }

      else
      {
        unsigned int v31 = *((void *)buffer + 18);
        if (v31)
        {
          uint64_t v19 = *(char *)(v31 + *((void *)buffer + 19) + v16);
        }

        else
        {
          if (*((void *)buffer + 22) <= v16 || (uint64_t v32 = *((void *)buffer + 21), v32 > v16))
          {
            uint64_t v33 = v16 - 4;
            if (v33 + 64 < v17) {
              unsigned int v17 = v33 + 64;
            }
            *((void *)buffer + 21) = v33;
            *((void *)buffer + 22) = v17;
            v43.int location = *((void *)buffer + 19) + v33;
            v43.CFIndex length = v17 - v33;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v43, buffer);
            uint64_t v32 = *((void *)buffer + 21);
          }

          uint64_t v19 = buffer[v16 - v32];
        }
      }

      if ((v19 & 0xFFDF) == 0x58)
      {
        char v34 = *a2;
        unsigned int v35 = v34 + 1;
        *a2 = v34 + 1;
        uint64_t v36 = *((void *)buffer + 20);
        if (v36 <= v35) {
          goto LABEL_93;
        }
        char v37 = *((void *)buffer + 17);
        if (v37)
        {
          uint64_t v19 = *(_WORD *)(v37 + 2 * (*((void *)buffer + 19) + v35));
        }

        else
        {
          BOOL v38 = *((void *)buffer + 18);
          if (v38)
          {
            uint64_t v19 = *(char *)(v38 + *((void *)buffer + 19) + v35);
          }

          else
          {
            if (*((void *)buffer + 22) <= v35 || (uint64_t v39 = *((void *)buffer + 21), v39 > v35))
            {
              uint64_t v40 = v35 - 4;
              if (v40 + 64 < v36) {
                uint64_t v36 = v40 + 64;
              }
              *((void *)buffer + 21) = v40;
              *((void *)buffer + 22) = v36;
              v44.int location = *((void *)buffer + 19) + v40;
              v44.CFIndex length = v36 - v40;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v44, buffer);
              uint64_t v39 = *((void *)buffer + 21);
            }

            uint64_t v19 = buffer[v35 - v39];
          }
        }
      }

      if ((unsigned __int16)(v19 - 48) > 9u)
      {
        if (v19 - 65 > 5)
        {
          unsigned int v14 = v19 - 87;
        }

        else
        {
          unsigned int v14 = v19 - 55;
        }
      }

      else
      {
        unsigned int v14 = v19 - 48;
      }

      if (v14 != -1)
      {
LABEL_33:
        char v20 = 0;
        do
        {
          int v21 = v14 + 16 * v20;
          if (v20 >> 28) {
            char v20 = -1;
          }
          else {
            char v20 = v21;
          }
          int v22 = *a2;
          uint64_t v23 = v22 + 1;
          *a2 = v22 + 1;
          unsigned int v24 = *((void *)buffer + 20);
          if (v24 <= v23) {
            break;
          }
          unsigned int v25 = *((void *)buffer + 17);
          if (v25)
          {
            unsigned int v26 = *(_WORD *)(v25 + 2 * (*((void *)buffer + 19) + v23));
          }

          else
          {
            unsigned int v27 = *((void *)buffer + 18);
            if (v27)
            {
              unsigned int v26 = *(char *)(v27 + *((void *)buffer + 19) + v23);
            }

            else
            {
              if (*((void *)buffer + 22) <= v23 || (uint64_t v28 = *((void *)buffer + 21), v28 > v23))
              {
                uint64_t v29 = v23 - 4;
                if (v29 + 64 < v24) {
                  unsigned int v24 = v29 + 64;
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v24;
                v42.int location = *((void *)buffer + 19) + v29;
                v42.CFIndex length = v24 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v42, buffer);
                uint64_t v28 = *((void *)buffer + 21);
              }

              unsigned int v26 = buffer[v23 - v28];
            }
          }

          if ((unsigned __int16)(v26 - 48) > 9u)
          {
            if (v26 - 65 > 5)
            {
              unsigned int v14 = v26 - 87;
            }

            else
            {
              unsigned int v14 = v26 - 55;
            }
          }

          else
          {
            unsigned int v14 = v26 - 48;
          }
        }

        while (v14 != -1);
        if (!a3) {
          return 1LL;
        }
        goto LABEL_95;
      }
    }
  }

  while (1)
  {
    char v11 = -1;
LABEL_6:
    if (v11 != 12288
      && (unsigned __int16)(v11 - 0x2000) >= 0xCu
      && v11 >= 0x21u
      && (unsigned __int16)(v11 - 127) >= 0x22u)
    {
      break;
    }

    int v7 = *a3 + 1;
    *a3 = v7;
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_2;
    }
  }

  if (v11 >= 0x80u)
  {
    __src[0] = 0;
    uint64_t v18 = __src;
    uint64_t v28 = strtod_l(__src, &v31, 0LL);
  }

  else
  {
    unint64_t v30 = a4;
    unsigned int v15 = 0LL;
    unsigned int v16 = 0LL;
    unsigned int v17 = 256;
    uint64_t v18 = __src;
    while (1)
    {
      uint64_t v19 = v15;
      if (((__CFNumberSet[v11 >> 3] >> (v11 & 7)) & 1) == 0) {
        break;
      }
      if (v15 >= v17 - 1)
      {
        if (!v16)
        {
          char v20 = _CFGetTSD(1u);
          if (v20) {
            unsigned int v16 = (const __CFAllocator *)v20;
          }
          else {
            unsigned int v16 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
          }
        }

        v17 += 256;
        if (v18 == __src)
        {
          uint64_t v18 = (char *)CFAllocatorAllocate(v16, v17, 0LL);
          memmove(v18, __src, v19);
        }

        else
        {
          uint64_t v18 = (char *)__CFSafelyReallocateWithAllocator((malloc_zone_t *)v16, v18, v17, 0LL, 0LL);
        }
      }

      v18[v19] = v11;
      int v21 = v19 + *a3 + 1;
      if ((v21 & 0x80000000) == 0)
      {
        int v22 = v21;
        uint64_t v23 = *((void *)buffer + 20);
        if (v23 > v21)
        {
          unsigned int v24 = *((void *)buffer + 17);
          if (v24)
          {
            char v11 = *(_WORD *)(v24 + 2 * (*((void *)buffer + 19) + v21));
          }

          else
          {
            unsigned int v25 = *((void *)buffer + 18);
            if (v25)
            {
              char v11 = *(char *)(v25 + *((void *)buffer + 19) + v21);
            }

            else
            {
              if (*((void *)buffer + 22) <= v21 || (unsigned int v26 = *((void *)buffer + 21), v26 > v21))
              {
                else {
                  unsigned int v27 = 0LL;
                }
                if (v27 + 64 < v23) {
                  uint64_t v23 = v27 + 64;
                }
                *((void *)buffer + 21) = v27;
                *((void *)buffer + 22) = v23;
                v35.int location = *((void *)buffer + 19) + v27;
                v35.CFIndex length = v23 - v27;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v35, buffer);
                unsigned int v26 = *((void *)buffer + 21);
              }

              char v11 = buffer[v22 - v26];
            }
          }

          unsigned int v15 = v19 + 1;
          if (v11 < 0x80u) {
            continue;
          }
        }
      }

      LODWORD(v19) = v19 + 1;
      break;
    }

    v18[v19] = 0;
    uint64_t v28 = strtod_l(v18, &v31, 0LL);
    if (v16) {
      CFAllocatorDeallocate(v16, v18);
    }
    a4 = v30;
  }

  if (v18 == v31) {
    return 0LL;
  }
  *a3 += (_DWORD)v31 - (_DWORD)v18;
  if (a4) {
    *a4 = v28;
  }
  return 1LL;
}

      unsigned int v5 = 1LL;
LABEL_6:
      a2 += v5;
      ++result;
      uint64_t v6 = __OFADD__(a3, v4);
      a3 += v4;
      if ((a3 < 0) ^ v6 | (a3 == 0)) {
        return result;
      }
    }

  uint64_t v6 = (unint64_t *)(v3 + 8);
  if (!atomic_load((unint64_t *)(v3 + 8)))
  {
    unsigned int v8 = _cow_create(v3, 1);
    while (!__ldaxr(v6))
    {
    }

    __clrex();
    free(v8);
  }

  unsigned int v17 = xpc_dictionary_get_int64(a2, "CFPreferencesByteCountThreshold");
  -[CFPrefsPlistSource handlePossibleOversizedMessage:forWritingKeys:values:count:]( (unsigned __int8 *)v14,  v17,  a4,  a5,  a6);
  if (object_getClass(a2) == (Class)MEMORY[0x1895F9268]
    || (uint64_t result = (uint64_t)xpc_dictionary_get_value(a2, "CFPreferencesErrorDescription")) != 0)
  {
    if (a2 == (id)MEMORY[0x1895F91A0])
    {
      -[CFPrefsPlistSource writeFailedForKeys:values:count:](v14, a4, (const __CFString **)a5, a6);
      atomic_store(1u, (unsigned __int8 *)(v14 + 105));
      if (handleErrorReply_toMessage_settingKeys_toValues_count_retryCount_retryContinuation__onceToken != -1) {
        dispatch_once( &handleErrorReply_toMessage_settingKeys_toValues_count_retryCount_retryContinuation__onceToken,  &__block_literal_global_38);
      }
    }

    else
    {
      if (object_getClass(a2) != v16) {
        -[CFPrefsPlistSource handleErrorReply:toMessage:settingKeys:toValues:count:retryCount:retryContinuation:].cold.3();
      }
      uint64_t v18 = xpc_dictionary_get_int64(a2, "CFPreferencesErrorType");
      uint64_t v19 = xpc_dictionary_get_string(a2, "CFPreferencesErrorDescription");
      char v20 = (const __CFString *)[(id)v14 copyOSLogDescription];
      if (xpc_dictionary_get_BOOL(a2, "CFPreferencesErrorClientFault")) {
        int v21 = OS_LOG_TYPE_FAULT;
      }
      else {
        int v21 = OS_LOG_TYPE_ERROR;
      }
      if (v18 == 1)
      {
        if (a6 < 1)
        {
          _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
          uint64_t v40 = (os_log_s *)_CFPrefsClientLog();
          if (os_log_type_enabled(v40, v21))
          {
            *(_DWORD *)buf = 138543618;
            uint64_t v54 = v20;
            unint64_t v55 = 2082;
            unsigned int v56 = v19;
            _os_log_impl( &dword_180A4C000,  v40,  v21,  "Couldn't read values in %{public}@: %{public}s, detaching from cfprefsd",  buf,  0x16u);
          }

          _CFSetTSD(0xFu, 0LL, 0LL);
        }

        else
        {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
          uint64_t v23 = a6;
          unsigned int v24 = a4;
          do
          {
            if (*v24) {
              CFArrayAppendValue(Mutable, *v24);
            }
            ++v24;
            --v23;
          }

          while (v23);
          unsigned int v25 = CFCopyDescription(Mutable);
          if (Mutable) {
            CFRelease(Mutable);
          }
          _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
          unsigned int v26 = (os_log_s *)_CFPrefsClientLog();
          if (os_log_type_enabled(v26, v21))
          {
            *(_DWORD *)buf = 138543874;
            uint64_t v54 = v25;
            unint64_t v55 = 2114;
            unsigned int v56 = (const char *)v20;
            uint64_t v57 = 2082;
            int v58 = v19;
            _os_log_impl( &dword_180A4C000,  v26,  v21,  "Couldn't write values for keys %{public}@ in %{public}@: %{public}s, detaching from cfprefsd",  buf,  0x20u);
          }

          _CFSetTSD(0xFu, 0LL, 0LL);
          if (v25) {
            CFRelease(v25);
          }
        }

        -[CFPrefsPlistSource writeFailedForKeys:values:count:](v14, a4, (const __CFString **)a5, a6);
        atomic_store(1u, (unsigned __int8 *)(v14 + 105));
      }

      else
      {
        if (a6 < 1)
        {
          _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
          unint64_t v41 = (os_log_s *)_CFPrefsClientLog();
          if (os_log_type_enabled(v41, v21))
          {
            *(_DWORD *)buf = 138543618;
            uint64_t v54 = v20;
            unint64_t v55 = 2082;
            unsigned int v56 = v19;
            _os_log_impl(&dword_180A4C000, v41, v21, "Couldn't read values in %{public}@: %{public}s", buf, 0x16u);
          }

          _CFSetTSD(0xFu, 0LL, 0LL);
        }

        else
        {
          uint64_t v32 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
          uint64_t v33 = a6;
          char v34 = a4;
          do
          {
            if (*v34) {
              CFArrayAppendValue(v32, *v34);
            }
            ++v34;
            --v33;
          }

          while (v33);
          unsigned int v35 = CFCopyDescription(v32);
          if (v32) {
            CFRelease(v32);
          }
          _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
          uint64_t v36 = (os_log_s *)_CFPrefsClientLog();
          if (os_log_type_enabled(v36, v21))
          {
            *(_DWORD *)buf = 138543874;
            uint64_t v54 = v35;
            unint64_t v55 = 2114;
            unsigned int v56 = (const char *)v20;
            uint64_t v57 = 2082;
            int v58 = v19;
            _os_log_impl( &dword_180A4C000,  v36,  v21,  "Couldn't write values for keys %{public}@ in %{public}@: %{public}s",  buf,  0x20u);
          }

          _CFSetTSD(0xFu, 0LL, 0LL);
          if (v35) {
            CFRelease(v35);
          }
        }

        -[CFPrefsPlistSource writeFailedForKeys:values:count:](v14, a4, (const __CFString **)a5, a6);
      }

      CFRelease(v20);
    }

    if (a6 >= 1) {
      atomic_store(xpc_dictionary_get_uint64(a2, "CFPreferencesShmemState"), (unsigned int *)(v14 + 48));
    }
    return 1LL;
  }

  return result;
}

CFURLRef _CFBundleCopyMainBundleExecutableURL(_BYTE *a1)
{
  uint64_t v2 = _CFProcessPath();
  if (v2 && (uint64_t v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2)) != 0LL)
  {
    size_t v4 = v3;
    CFURLRef v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, kCFURLPOSIXPathStyle, 0);
    CFRelease(v4);
    if (!a1) {
      return v5;
    }
  }

  else
  {
    CFURLRef v5 = 0LL;
    if (!a1) {
      return v5;
    }
  }

  char v6 = _mainBundle;
  if (_mainBundle) {
    char v6 = *(unsigned __int8 *)(_mainBundle + 53) - 5 < 0xFFFFFFFE;
  }
  *a1 = v6;
  return v5;
}

CFBundleRef CFBundleGetMainBundle(void)
{
  v31[129] = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
  if ((_initedMainBundle & 1) == 0)
  {
    _initedMainBundle = 1;
    v0 = _CFProcessPath();
    if (v0)
    {
      uint64_t v1 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v0);
      uint64_t v2 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, kCFURLPOSIXPathStyle, 0);
      if (!v2)
      {
        if (!v1) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }

      uint64_t v3 = v2;
      size_t v4 = _CFBundleCopyBundleURLForExecutableURL(v2);
      if (!v4)
      {
LABEL_54:
        if (v1) {
          CFRelease(v1);
        }
        uint64_t v1 = (const __CFString *)v3;
LABEL_57:
        CFRelease(v1);
        goto LABEL_58;
      }

      CFURLRef v5 = v4;
      Main = _CFBundleCreateMain((const __CFAllocator *)&__kCFAllocatorSystemDefault, v4);
      _mainBundle = (uint64_t)Main;
      if (!Main)
      {
LABEL_53:
        CFRelease(v5);
        goto LABEL_54;
      }

      *((_BYTE *)Main + 52) = 1;
      if (!*((_DWORD *)Main + 12))
      {
        int v8 = _CFBundleGrokBinaryType(v3, v7);
        Main = (void *)_mainBundle;
        *(_DWORD *)(_mainBundle + 48) = v8;
        if (v8 != 1 && v8 != 6) {
          *((_BYTE *)Main + 64) = 1;
        }
      }

      if (!Main[7])
      {
        Main[7] = -5LL;
        int v10 = (os_log_s *)_CFBundleLoadingLogger();
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        Main = (void *)_mainBundle;
        if (v11)
        {
          CFBundleGetMainBundle_cold_1(_mainBundle, v10, v31);
          Main = (void *)v31[0];
        }
      }

      CFBundleGetInfoDictionary((CFBundleRef)Main);
      uint64_t v12 = _mainBundle;
      if (*(void *)(_mainBundle + 24))
      {
        CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_mainBundle + 24));
        uint64_t v12 = _mainBundle;
        if (Count)
        {
          if (*(_DWORD *)(_mainBundle + 48) == 2)
          {
            unsigned int v14 = _CFBundleCopyExecutableName((CFBundleRef)_mainBundle, 0LL, 0LL);
            unsigned int v15 = v14;
            if (v1)
            {
              if (v14 && CFStringHasSuffix(v1, v14)) {
                goto LABEL_43;
              }
            }

            InfoDictFromMainExecutable = _CFBundleCreateInfoDictFromMainExecutable();
            if (InfoDictFromMainExecutable)
            {
              unsigned int v17 = InfoDictFromMainExecutable;
              if (CFDictionaryGetCount(InfoDictFromMainExecutable) < 1)
              {
                CFRelease(v17);
              }

              else
              {
                uint64_t v18 = _mainBundle;
                uint64_t v19 = *(const void **)(_mainBundle + 24);
                if (v19)
                {
                  CFRelease(v19);
                  uint64_t v18 = _mainBundle;
                }

                *(void *)(v18 + 24) = v17;
              }
            }

            if (v15) {
LABEL_43:
            }
              CFRelease(v15);
          }

LABEL_44:
          uint64_t v23 = _mainBundle;
          if (!*(void *)(_mainBundle + 24))
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            uint64_t v23 = _mainBundle;
            *(void *)(_mainBundle + 24) = Mutable;
          }

          if (v1 && !*(void *)(v23 + 104))
          {
            CFTypeRef v25 = CFRetain(v1);
            uint64_t v23 = _mainBundle;
            *(void *)(_mainBundle + 104) = v25;
          }

          Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v23 + 24), @"CFBundleIdentifier");
          if (Value)
          {
            unsigned int v27 = Value;
            bzero(v31, 0x402uLL);
            if (!CFStringGetCString(v27, (char *)v31, 1024LL, 0x8000100u))
            {
              LOBYTE(v31[0]) = 0;
              __CFBundleMainID = (uint64_t)strdup((const char *)v31);
            }
          }

          os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
          InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)_mainBundle);
          _CFBundleInitPlugIn((void *)_mainBundle, InfoDictionary, 0LL);
          _CFPlugInHandleDynamicRegistration((__CFBundle *)_mainBundle);
          os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
          goto LABEL_53;
        }
      }

      if (*(_BYTE *)(v12 + 53))
      {
        if (*(_BYTE *)(v12 + 53) == 3) {
          *(_BYTE *)(v12 + 53) = 4;
        }
        goto LABEL_37;
      }

      char v20 = _CFBundleCopyExecutableName((CFBundleRef)v12, 0LL, 0LL);
      int v21 = v20;
      if (v1 && v20)
      {
        if (!CFStringHasSuffix(v1, v20)) {
          *(_BYTE *)(_mainBundle + 53) = 4;
        }
      }

      else
      {
        uint64_t v12 = _mainBundle;
        *(_BYTE *)(_mainBundle + 53) = 4;
        if (!v21) {
          goto LABEL_37;
        }
      }

      CFRelease(v21);
      uint64_t v12 = _mainBundle;
LABEL_37:
      if ((*(_DWORD *)(v12 + 48) | 4) == 6)
      {
        int v22 = *(const void **)(v12 + 24);
        if (v22) {
          CFRelease(v22);
        }
        *(void *)(_mainBundle + 24) = _CFBundleCreateInfoDictFromMainExecutable();
      }

      goto LABEL_44;
    }
  }

          uint64_t v29 = (char *)*((void *)theSet + 5);
          if (!v29)
          {
            char v34 = CFGetAllocator(theSet);
            uint64_t v29 = (char *)CFAllocatorAllocate(v34, 16LL, 0LL);
            *((void *)theSet + 5) = v29;
            *(void *)(v29 + 6) = 0LL;
            *(void *)uint64_t v29 = 0LL;
          }

          goto LABEL_46;
        }

        uint64_t v19 = atomic_load(v8);
        if ((v19 & 0x70) == 0x40LL)
        {
          char v20 = 0LL;
          LODWORD(v21) = 0;
          int v22 = *((void *)theSet + 3);
          do
          {
            if (*(unsigned __int8 *)(v22 + v20) == 255)
            {
              *(_BYTE *)(v22 + v20) = 0;
            }

            else if (*(_BYTE *)(v22 + v20))
            {
              LODWORD(v21) = v21 + 32;
            }

            else
            {
              *(_BYTE *)(v22 + v20) = -1;
            }

            ++v20;
          }

          while (v20 != 256);
          if ((int)v21 >= 1)
          {
            uint64_t v23 = (_BYTE *)(v22 + 256);
            int v21 = v21;
            do
            {
              *uint64_t v23 = ~*v23;
              ++v23;
              --v21;
            }

            while (v21);
          }

          goto LABEL_44;
        }

        unsigned int v24 = atomic_load(v8);
        CFTypeRef v25 = atomic_load(v8);
        unsigned int v26 = v24 & 8;
        while (2)
        {
          unsigned int v27 = __ldaxr(v8);
          if (v27 == v25)
          {
            if (!__stlxr((v25 & 0xFFFFFFFFFFFFFFF7LL | v26) ^ 8, v8))
            {
              uint64_t v28 = 1;
              goto LABEL_40;
            }
          }

          else
          {
            __clrex();
          }

          uint64_t v28 = 0;
LABEL_40:
          CFTypeRef v25 = v27;
          if (v28)
          {
            uint64_t v29 = (char *)*((void *)theSet + 5);
            if (!v29)
            {
              unint64_t v30 = CFGetAllocator(theSet);
              uint64_t v29 = (char *)CFAllocatorAllocate(v30, 16LL, 0LL);
              *((void *)theSet + 5) = v29;
              *(void *)uint64_t v29 = 0LL;
              *(void *)(v29 + 6) = 0LL;
              unsigned int v31 = 1;
              goto LABEL_47;
            }

  if (!v6)
  {
    if ((a2 & 1) != 0 && (a2 & 2) == 0) {
      LODWORD(v6) = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
    }
    if (v12)
    {
      if ((a2 & 1) != 0 || a5) {
        goto LABEL_84;
      }
      v21[5] = 0LL;
      uint64_t v36 = atomic_load(v21 + 1);
      while (1)
      {
        char v37 = __ldaxr(v22);
        if (v37 != v36) {
          break;
        }
        if (__stlxr(v36 & 0xFFFFFFFFFFFFFFFBLL, v22)) {
          goto LABEL_58;
        }
        BOOL v38 = 1;
LABEL_59:
        uint64_t v36 = v37;
        if (v38)
        {
          if ((__CFDataInit_didCheck & 1) == 0)
          {
            uint64_t v39 = _CFProcessPath();
            if (v39)
            {
              uint64_t v40 = strrchr(v39, 47);
              if (!v40) {
                goto LABEL_75;
              }
            }

            else
            {
              uint64_t v40 = "";
            }

        unsigned int v26 = 2;
LABEL_45:
        if (v26 == 3) {
          return (DIR *)closedir(v8);
        }
      }
    }
  }

  return result;
}

  if ((unsigned __int16)(v20 + 13919) <= 0x5Du)
  {
    if (a5)
    {
      uint64_t v29 = v20 + 5727;
      goto LABEL_50;
    }

    goto LABEL_51;
  }

  if ((unsigned __int16)(v20 + 351) <= 0x5Du)
  {
    if (a5)
    {
      uint64_t v29 = v20 - 3907;
LABEL_50:
      *a4++ = v29;
    }

    if (!a5)
    {
      if (a1 == 73)
      {
        if (a3 + 1 < a4) {
          return 4 * (*(_WORD *)(a2 + 2 * (a3 + 1)) == 775);
        }
        return 0LL;
      }

      if (a1 == 775) {
        return (a7 >> 1) & 2;
      }
    }

    goto LABEL_45;
  }

  if ((a7 & 8) != 0) {
    return 8 * ((a1 & 0xFFFFFFDF) == 74);
  }
  if ((a1 & 0xFFFFFFDF) != 0x49 || a5 != 2) {
    goto LABEL_45;
  }
  if (a3 + 1 >= a4) {
    return 0LL;
  }
  unsigned int v35 = *(unsigned __int16 *)(a2 + 2 * (a3 + 1));
  if (v35 == 106) {
    return 8LL;
  }
  else {
    return 8 * (v35 == 74);
  }
}

LABEL_58:
  uint64_t v29 = (__CFBundle *)_mainBundle;
  os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
  return v29;
}

        ++v7;
        v10 += 8;
        if (v4 + 1 == v7)
        {
          char v6 = *((void *)cf + 5);
          break;
        }
      }
    }

    if (v6 && !*(_DWORD *)(v6 + 8) && !*(_BYTE *)(v6 + 13))
    {
      for (uint64_t i = 0LL; i != 16; ++i)
      {
        uint64_t v42 = *((void *)cf + 5);
        if (((*(_DWORD *)(v42 + 8) >> i) & 2) != 0) {
          CFRelease(*(CFTypeRef *)(*(void *)v42 + 8 * i));
        }
      }

      unsigned int v43 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v43, **((void ***)cf + 5));
      unint64_t v44 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v44, *((void **)cf + 5));
      *((void *)cf + 5) = 0LL;
    }
  }

            uint64_t v18 = [a1 _cfTypeID];
            break;
        }

        break;
    }
  }

  else
  {
    unsigned int v15 = atomic_load(a1 + 1);
    if (CF_IS_OBJC((v15 >> 8) & 0x3FF, (__objc2_class **)a1))
    {
LABEL_15:
      if ((objc_opt_respondsToSelector() & 1) != 0) {
        return [a1 _copyFormattingDescription:a2];
      }
      return 0LL;
    }

    unsigned int v17 = atomic_load(a1 + 1);
    uint64_t v18 = (v17 >> 8) & 0x3FF;
  }

  if (v18 > 0x47) {
    uint64_t v19 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v18 - 72) >> 6] + 8LL * (((_DWORD)v18 - 72) & 0x3F));
  }
  else {
LABEL_19:
  }
    uint64_t v19 = &__CFRuntimeBuiltinClassTable + v18;
  unsigned int v14 = (CFStringRef (*)(uint64_t))*((void *)*v19 + 7);
  if (v14) {
    return ((uint64_t (*)(unint64_t *, uint64_t))v14)(a1, a2);
  }
  return 0LL;
}

      if (v121 < 0 || a3 >= 129)
      {
        if (v121 >= a3)
        {
          p_dst = ptr;
        }

        else
        {
          if (a3 <= 0) {
            uint64_t v40 = -((v15 - v38) & 0x7F);
          }
          else {
            uint64_t v40 = a3 & 0x7F;
          }
          unint64_t v41 = a3 - v40;
          uint64_t v42 = v41 + 128;
          if (v121)
          {
            p_dst = (UniChar *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  ptr,  2 * (v41 + 128),  0LL,  0LL);
          }

          else
          {
            p_dst = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * (v41 + 128), 0LL);
            if (!p_dst) {
              __CFStringHandleOutOfMemory();
            }
          }

          int64_t v121 = v42;
          a4 = __src;
        }
      }

      else
      {
        p_dst = (UniChar *)&__dst;
      }

      unint64_t v50 = *((void *)buffer + 17);
      if (v50)
      {
        memmove(p_dst, (const void *)(v50 + 2LL * *((void *)buffer + 19) + 2 * v15), 2 * a3);
        ptr = p_dst;
      }

      else
      {
        CFStringRef v51 = *((void *)buffer + 21);
        if (v15 < v51 || (v52 = *((void *)buffer + 22), v53 = v52 <= v15, uint64_t v54 = v52 - v15, v53))
        {
          unsigned int v56 = p_dst;
          uint64_t v57 = v15;
          int v58 = a3;
          if (a2 > v51)
          {
            unsigned int v56 = p_dst;
            uint64_t v57 = v15;
            int v58 = a3;
            if (a2 < *((void *)buffer + 22))
            {
              int v58 = v51 - v15;
              memmove(&p_dst[v51 - v15], buffer, 2 * (a2 - v51));
              unsigned int v56 = p_dst;
              uint64_t v57 = v15;
            }
          }
        }

        else
        {
          if (a3 >= v54) {
            unint64_t v55 = v54;
          }
          else {
            unint64_t v55 = a3;
          }
          memmove(p_dst, &buffer[v15 - v51], 2 * v55);
          unsigned int v56 = &p_dst[v55];
          uint64_t v57 = v55 + v15;
          int v58 = a3 - v55;
        }

        if (v58 >= 1)
        {
          uint64_t v59 = *((void *)buffer + 18);
          v60.int location = *((void *)buffer + 19) + v57;
          if (v59)
          {
            uint64_t v61 = (char *)(v59 + v60.location);
            do
            {
              BOOL v62 = *v61++;
              *v56++ = v62;
              --v58;
            }

            while (v58);
          }

          else
          {
            v60.CFIndex length = v58;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v60, v56);
          }
        }

        ptr = p_dst;
        a4 = __src;
      }

      goto LABEL_100;
    }

    p_dst = (UniChar *)(v43 + 2LL * *((void *)buffer + 19) + 2 * v15);
LABEL_100:
    char v37 = (int64_t)v131;
LABEL_101:
    if (a5 < v37)
    {
      uint64_t v63 = __extendLocationForward( a5,  a4,  _CFCompareStringsWithLocale_alnumBMP,  _CFCompareStringsWithLocale_punctBMP,  _CFCompareStringsWithLocale_controlBMP,  v37);
      a5 = v63;
      a6 = v63 - v16;
      if (v16 < 0 || (uint64_t v64 = *((void *)a4 + 20), v63 > v64))
      {
LABEL_104:
        if (v122 < 0 || a6 >= 129)
        {
          if (v122 >= a6)
          {
            unsigned int v35 = v124;
          }

          else
          {
            if (a6 <= 0) {
              unint64_t v65 = -((v16 - v63) & 0x7F);
            }
            else {
              unint64_t v65 = a6 & 0x7F;
            }
            uint64_t v66 = a6 - v65;
            uint64_t v67 = v66 + 128;
            if (v122)
            {
              unsigned int v35 = (UniChar *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v124,  2 * (v66 + 128),  0LL,  0LL);
            }

            else
            {
              unsigned int v35 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * (v66 + 128), 0LL);
              if (!v35) {
                __CFStringHandleOutOfMemory();
              }
            }

            int64_t v122 = v67;
            a4 = __src;
          }
        }

        else
        {
          unsigned int v35 = (UniChar *)&v134;
        }

        unint64_t v75 = *((void *)a4 + 17);
        if (v75)
        {
          memmove(v35, (const void *)(v75 + 2LL * *((void *)a4 + 19) + 2 * v16), 2 * a6);
          v124 = v35;
          goto LABEL_146;
        }

        uint64_t v76 = *((void *)a4 + 21);
        CFSetRef v77 = v16 - v76;
        if (v16 < v76 || (unint64_t v78 = *((void *)a4 + 22), v53 = v78 <= v16, v79 = v78 - v16, v53))
        {
          uint64_t v82 = v35;
          BOOL v83 = v16;
          uint64_t v84 = a6;
          if (a5 > v76)
          {
            uint64_t v82 = v35;
            BOOL v83 = v16;
            uint64_t v84 = a6;
            if (a5 < *((void *)__src + 22))
            {
              uint64_t v84 = v76 - v16;
              memmove(&v35[v76 - v16], __src, 2 * (a5 - v76));
              uint64_t v82 = v35;
              BOOL v83 = v16;
            }
          }
        }

        else
        {
          uint64_t v80 = a4;
          if (a6 >= v79) {
            uint64_t v81 = v79;
          }
          else {
            uint64_t v81 = a6;
          }
          memmove(v35, &v80[v77], 2 * v81);
          uint64_t v82 = &v35[v81];
          BOOL v83 = v81 + v16;
          uint64_t v84 = a6 - v81;
        }

        if (v84 >= 1)
        {
          uint64_t v85 = *((void *)__src + 18);
          v86.int location = *((void *)__src + 19) + v83;
          if (!v85)
          {
            v86.CFIndex length = v84;
            CFStringGetCharacters(*((CFStringRef *)__src + 16), v86, v82);
            v124 = v35;
            a4 = __src;
            goto LABEL_145;
          }

          BOOL v87 = (char *)(v85 + v86.location);
          do
          {
            uint64_t v88 = *v87++;
            *v82++ = v88;
            --v84;
          }

          while (v84);
        }

        v124 = v35;
        a4 = __src;
LABEL_145:
        buffer = v119;
        goto LABEL_146;
      }

      char v68 = *((void *)a4 + 17);
      if (v68)
      {
        unsigned int v35 = (UniChar *)(v68 + 2LL * *((void *)a4 + 19) + 2 * v16);
      }

      else
      {
        if (a6 > 64) {
          goto LABEL_104;
        }
        if (v63 > *((void *)a4 + 22) || (unint64_t v69 = *((void *)a4 + 21), v16 < v69))
        {
          if (v16 + 64 < v64) {
            uint64_t v64 = v16 + 64;
          }
          *((void *)a4 + 21) = v16;
          *((void *)a4 + 22) = v64;
          v70.CFIndex length = v64 - v16;
          uint64_t v72 = *((void *)a4 + 18);
          unint64_t v71 = *((void *)a4 + 19);
          if (v72)
          {
            unint64_t v69 = v16;
            if (v70.length)
            {
              uint64_t v73 = v72 + v71;
              uint64_t v74 = a4;
              do
              {
                *v74++ = *(char *)(v73 + v16);
                ++v73;
                --v64;
              }

              while (v16 != v64);
              unint64_t v69 = v16;
            }
          }

          else
          {
            v70.int location = v71 + v16;
            CFStringGetCharacters(*((CFStringRef *)a4 + 16), v70, a4);
            unint64_t v69 = *((void *)a4 + 21);
          }
        }

        unsigned int v35 = &a4[v16 - v69];
      }
    }

            CFStringAppendCharacters(Mutable, buffer, v40);
            unsigned int v47 = 0LL;
            goto LABEL_59;
          }

          if (v47)
          {
            CFStringAppendCharacters(Mutable, buffer, v47);
            unsigned int v47 = 0LL;
          }

          CFStringAppend(Mutable, v16);
        }

        uint64_t v40 = v47;
        if (!v47) {
          goto LABEL_59;
        }
        goto LABEL_58;
      }
    }

    else
    {
      if (v47)
      {
        CFStringAppendCharacters(Mutable, buffer, v47);
        unsigned int v47 = 0LL;
      }

      CFStringAppend(Mutable, @"file://");
      if (!v15) {
        goto LABEL_40;
      }
    }

    uint64_t v29 = CFStringGetLength(v15);
    unint64_t v30 = v47;
    if (v29 < 1025)
    {
      unsigned int v31 = v29;
      if (v47 + v29 >= 1025)
      {
        CFStringAppendCharacters(Mutable, buffer, v47);
        unint64_t v30 = 0LL;
        unsigned int v47 = 0LL;
      }

      uint64_t v32 = &buffer[v30];
      v51.int location = 0LL;
      v51.CFIndex length = v31;
      CFStringGetCharacters(v15, v51, v32);
      v47 += v31;
    }

    else
    {
      if (v47)
      {
        CFStringAppendCharacters(Mutable, buffer, v47);
        unsigned int v47 = 0LL;
      }

      CFStringAppend(Mutable, v15);
    }

    goto LABEL_40;
  }

        int v13 = v8;
        if (!v8) {
          return v12;
        }
        goto LABEL_65;
      }

  unint64_t v30 = 0LL;
LABEL_59:
  char v37 = 0LL;
  uint64_t v32 = -1LL;
LABEL_60:
  uint64_t v36 = -1LL;
LABEL_61:
  if (a3)
  {
    *a3 = v36;
    a3[1] = v37;
  }

  if (a4)
  {
    *a4 = v32;
    a4[1] = v30;
  }

      unsigned int v31 = -[CFPDSource copyPropertyListWithoutDrainingPendingChangesValidatingPlist:andReturnFileUID:andMode:]( self,  "copyPropertyListWithoutDrainingPendingChangesValidatingPlist:andReturnFileUID:andMode:",  v34,  &v69,  &v70);
      uint64_t v32 = -1;
      goto LABEL_59;
    }
  }

  unint64_t v30 = 0LL;
  unsigned int v31 = 0LL;
  uint64_t v32 = -1;
  if (!v18)
  {
LABEL_41:
    LOWORD(v64) = v70;
    uint64_t v18 = -[CFPDSource validateMessage:withNewKey:newValue:plistIsAvailableToRead:containerPath:fileUID:mode:diagnosticMessage:]( self,  "validateMessage:withNewKey:newValue:plistIsAvailableToRead:containerPath:fileUID:mode:diagnosticMessage:",  a3,  v75,  v74,  v30,  v84,  v69,  v64,  &v71);
  }

uint64_t _CFBundleSupportsFHSBundles()
{
  return 0LL;
}

uint64_t _CFBundleSupportsFreestandingBundles()
{
  return 0LL;
}

uint64_t _CFBundleResourceLogger()
{
  if (_CFBundleResourceLogger_onceToken != -1) {
    dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
  }
  return _CFBundleResourceLogger__log;
}

uint64_t _CFBundleLocalizedStringLogger()
{
  if (_CFBundleLocalizedStringLogger_onceToken != -1) {
    dispatch_once(&_CFBundleLocalizedStringLogger_onceToken, &__block_literal_global_96);
  }
  return _CFBundleLocalizedStringLogger__log;
}

uint64_t _CFBundleLoadingLogger()
{
  if (_CFBundleLoadingLogger_onceToken != -1) {
    dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
  }
  return _CFBundleLoadingLogger__log;
}

CFURLRef _CFURLCreateResolvedDirectoryWithString( const __CFAllocator *a1, const __CFString *a2, const __CFURL *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  size_t v4 = CFURLCreateWithString(a1, a2, a3);
  CFURLRef v5 = CFURLCopyAbsoluteURL(v4);
  CFRelease(v4);
  char v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  CFRelease(v5);
  LODWORD(v5) = CFStringGetFileSystemRepresentation(v6, buffer, 1024LL);
  CFRelease(v6);
  if (!(_DWORD)v5) {
    return 0LL;
  }
  int v7 = open(buffer, 0);
  if (v7 < 1) {
    return 0LL;
  }
  int v8 = v7;
  if (fcntl(v7, 50, v13) == -1)
  {
    if (_CFBundleResourceLogger_onceToken != -1) {
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    }
    BOOL v11 = (os_log_s *)_CFBundleResourceLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFURLCreateResolvedDirectoryWithString_cold_1(v11);
    }
    close(v8);
    return 0LL;
  }

  close(v8);
  uint64_t v9 = CFStringCreateWithFileSystemRepresentation(a1, v13);
  CFURLRef v10 = CFURLCreateWithFileSystemPath(a1, v9, kCFURLPOSIXPathStyle, 1u);
  CFRelease(v9);
  return v10;
}

const char *_CFBundleNormalizedPath(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!strncmp(result, "/private/preboot/Cryptexes/OS/", 0x1EuLL))
    {
      return v1 + 29;
    }

    else
    {
      int v2 = strncmp(v1, "/System/Cryptexes/OS/", 0x15uLL);
      uint64_t v3 = 20LL;
      if (v2) {
        uint64_t v3 = 0LL;
      }
      return &v1[v3];
    }
  }

  return result;
}

CFURLRef _CFBundleCreateNormalizedURL(const __CFAllocator *a1, CFURLRef url)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL)) {
    return 0LL;
  }
  uint64_t v3 = _CFBundleNormalizedPath((const char *)buffer);
  size_t v4 = strlen(v3);
  return CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)v3, v4, 1u);
}

uint64_t _CFBundleResourceURLIsSafeForMapping(const __CFURL *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026LL);
  if ((_DWORD)result) {
    return !statfs((const char *)buffer, &v3) && (v3.f_flags & 0x1200) == 4096;
  }
  return result;
}

CFDataRef _CFBundleCreateMappedOrLoadedPlistData( const __CFURL *a1, int a2, uint64_t a3, BOOL *a4, CFErrorRef *a5)
{
  int v9 = _CFBundleResourceURLIsSafeForMapping(a1);
  if (!a2 || !v9)
  {
    *a4 = 0;
    return _CFDataCreateFromURL(a1, a5);
  }

  CFDataRef result = (CFDataRef)_CFBundleCreateMappedBPlistFile();
  *a4 = result != 0LL;
  if (!result) {
    return _CFDataCreateFromURL(a1, a5);
  }
  return result;
}

uint64_t _CFBundleEffectiveLayoutVersion(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 53);
  if (!*(_BYTE *)(a1 + 53))
  {
    InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)a1);
    if (InfoDictionary && CFDictionaryGetCount(InfoDictionary))
    {
      return 0LL;
    }

    else
    {
      CFURLRef v5 = CFBundleCopyExecutableURL((CFBundleRef)a1);
      if (v5)
      {
        uint64_t v7 = v5;
        int v8 = *(_DWORD *)(a1 + 48);
        if (!v8)
        {
          int v8 = _CFBundleGrokBinaryType(v7, v6);
          *(_DWORD *)(a1 + 48) = v8;
        }

        uint64_t v1 = 4LL;
        if (v8 != 1 && v8 != 6)
        {
          uint64_t v1 = 0LL;
          *(_BYTE *)(a1 + 64) = 1;
        }

        CFRelease(v7);
      }

      else
      {
        return 4LL;
      }
    }
  }

  return v1;
}

const void *_CFBundleCreateIfLooksLikeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  int v2 = _CFBundleCreate(a1, a2, 1, 0LL);
  statfs v3 = v2;
  if (v2 && _CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
  {
    CFRelease(v3);
    return 0LL;
  }

  return v3;
}

void *_CFBundleCreateUnique(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 1, 0LL);
}

uint64_t _CFBundleURLLooksLikeBundle(const __CFURL *a1)
{
  uint64_t result = (uint64_t)_CFBundleCreateIfLooksLikeBundle((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1LL;
  }

  return result;
}

CFBundleRef _CFBundleGetMainBundleIfLooksLikeBundle()
{
  CFBundleRef result = CFBundleGetMainBundle();
  if (result)
  {
  }

  return result;
}

CFBundleRef _CFBundleMainBundleInfoDictionaryComesFromResourceFork()
{
  CFBundleRef result = CFBundleGetMainBundle();
  if (result) {
    return (CFBundleRef)(*((_BYTE *)result + 65) != 0);
  }
  return result;
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  if (!bundleURL) {
    return 0LL;
  }
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (!MainBundle) {
    return (CFBundleRef)_CFBundleCreate(allocator, bundleURL, 0LL, 0LL);
  }
  CFBundleRef v5 = MainBundle;
  int32x4_t v6 = (const void *)*((void *)MainBundle + 2);
  if (!v6 || !CFEqual(v6, bundleURL)) {
    return (CFBundleRef)_CFBundleCreate(allocator, bundleURL, 0LL, 0LL);
  }
  CFRetain(v5);
  return v5;
}

void _CFBundleFlushBundleCaches(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  size_t v4 = *(const __CFDictionary **)(a1 + 24);
  statfs v3 = *(const void **)(a1 + 32);
  *(void *)(a1 + 24) = 0LL;
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 32) = 0LL;
  }

  CFBundleRef v5 = *(const void **)(a1 + 216);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 216) = 0LL;
  }

  int32x4_t v6 = *(const void **)(a1 + 104);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 104) = 0LL;
  }

  uint64_t v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 40) = 0LL;
  }

  int v8 = *(const void **)(a1 + 144);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 144) = 0LL;
  }

  int v9 = *(const void **)(a1 + 152);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 152) = 0LL;
  }

  CFURLRef v10 = *(const void **)(a1 + 160);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 160) = 0LL;
  }

  if (*(_BYTE *)(a1 + 128))
  {
    *(_BYTE *)(a1 + 128) = 0;
    BOOL v11 = *(const void **)(a1 + 120);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a1 + 120) = 0LL;
    }
  }

  _CFBundleRefreshInfoDictionaryAlreadyLocked(a1);
  if (v4)
  {
    if (!*(void *)(a1 + 24)) {
      *(void *)(a1 + 24) = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    }
    Value = CFDictionaryGetValue(v4, @"NSPrincipalClass");
    if (Value) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"NSPrincipalClass", Value);
    }
    CFRelease(v4);
  }

  _CFBundleFlushQueryTableCache(a1);
  os_unfair_lock_unlock(v2);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return _CFBundleGetBundleWithIdentifier((__CFString *)bundleID, v1);
}

__CFBundle *_CFBundleGetBundleWithIdentifier(__CFString *a1, uint64_t a2)
{
  if (a1)
  {
    CFBundleRef MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      CFBundleRef v5 = MainBundle;
      InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
      if (InfoDictionary)
      {
        Value = CFDictionaryGetValue(InfoDictionary, @"CFBundleIdentifier");
        if (Value)
        {
          int v8 = Value;
          CFTypeID v9 = CFGetTypeID(Value);
          if (v9 == CFStringGetTypeID())
          {
            if (CFEqual(v8, a1)) {
              return v5;
            }
          }
        }
      }
    }

    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    CFBundleRef v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (a2 && !v5)
    {
      CFStringRef v10 = _CFBundleCopyLoadedImagePathForPointer();
      if (v10)
      {
        CFStringRef v11 = v10;
        _CFBundleEnsureBundleExistsForImagePath((uint64_t)v10, 0LL);
        CFRelease(v11);
      }

      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFBundleRef v5 = _CFBundleGetFromTablesLocked(a1);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    }

    if (v5) {
      return v5;
    }
    _CFBundleEnsureBundlesUpToDateWithHint(a1);
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    CFBundleRef v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (v5) {
      return v5;
    }
  }

  _CFBundleEnsureAllBundlesUpToDate();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  int v13 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v13;
}

void __CFBundleDeallocate(void *a1)
{
  statfs v3 = (const void *)a1[2];
  int v2 = (const __CFDictionary *)a1[3];
  a1[2] = 0LL;
  if (v2) {
    CFDictionaryGetValue(v2, @"CFBundleIdentifier");
  }
  _CFBundleUnloadExecutable((uint64_t)a1, 0);
  _CFBundleDeallocatePlugIn((uint64_t)a1);
  if (v3) {
    CFRelease(v3);
  }
  size_t v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }
  CFBundleRef v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  int32x4_t v6 = (const void *)a1[5];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[13];
  if (v7) {
    CFRelease(v7);
  }
  int v8 = (const void *)a1[27];
  if (v8) {
    CFRelease(v8);
  }
  CFTypeID v9 = (const void *)a1[18];
  if (v9) {
    CFRelease(v9);
  }
  CFStringRef v10 = (const void *)a1[19];
  if (v10) {
    CFRelease(v10);
  }
  CFStringRef v11 = (const void *)a1[20];
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = (const void *)a1[21];
  if (v12) {
    CFRelease(v12);
  }
  int v13 = (const void *)a1[24];
  if (v13) {
    CFRelease(v13);
  }
  unsigned int v14 = (const void *)a1[23];
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (const void *)a1[15];
  if (v15) {
    CFRelease(v15);
  }
  unsigned int v16 = (const void *)a1[17];
  if (v16) {
    CFRelease(v16);
  }
  unsigned int v17 = (const void *)a1[26];
  if (v17) {
    CFRelease(v17);
  }
}

CFStringRef __CFBundleCopyDescription(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v2 = *(const __CFURL **)(a1 + 16);
  if (v2 && CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026LL)) {
    CFStringRef v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)buffer);
  }
  else {
    CFStringRef v3 = 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 48) - 2;
  CFBundleRef v5 = &stru_1899EF170;
  int32x4_t v6 = &stru_1899EF170;
  if (v4 <= 3) {
    int32x4_t v6 = off_189995F20[v4];
  }
  if (!*(_BYTE *)(a1 + 52)) {
    CFBundleRef v5 = @"not ";
  }
  if (*(_BYTE *)(a1 + 72)) {
    CFStringRef v7 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"CFBundle/CFPlugIn %p <%@> (%@%@loaded)",  a1,  v3,  v6,  v5);
  }
  else {
    CFStringRef v7 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"CFBundle %p <%@> (%@%@loaded)",  a1,  v3,  v6,  v5);
  }
  CFStringRef v8 = v7;
  if (v3) {
    CFRelease(v3);
  }
  return v8;
}

CFTypeID CFBundleGetTypeID(void)
{
  return 31LL;
}

CFBundleRef _CFBundleGetExistingBundleWithBundleURL(CFURLRef bundleURL)
{
  return CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bundleURL);
}

void *_CFBundleCreate(const __CFAllocator *a1, const __CFURL *a2, int a3, const __CFSet *a4)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  CFURLRef NormalizedURL = _CFBundleCreateNormalizedURL(a1, a2);
  if (!NormalizedURL)
  {
    if (_CFBundleResourceLogger_onceToken != -1) {
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR)) {
      _CFBundleCreate_cold_1();
    }
    return 0LL;
  }

  CFURLRef v9 = NormalizedURL;
  char v10 = 0;
  char v11 = 1;
  char v12 = 0;
  char v13 = 1;
  char v14 = 1;
  char v15 = 0;
  switch(a3)
  {
    case 0:
      goto LABEL_10;
    case 1:
      char v11 = 0;
      char v13 = 0;
      char v15 = 0;
      char v10 = 1;
      goto LABEL_14;
    case 2:
      char v11 = 0;
      char v13 = 0;
      char v10 = 1;
      char v15 = 1;
      goto LABEL_14;
    case 3:
      goto LABEL_14;
    case 4:
      char v12 = 1;
LABEL_10:
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      unsigned int v16 = _CFBundleCopyFromTablesForURLLocked(v9);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      if (v16)
      {
        CFRelease(v9);
        return v16;
      }

      char v10 = 0;
      char v14 = 0;
      char v15 = 0;
      char v11 = v12;
LABEL_14:
      char v46 = v11;
      char v17 = v14;
      int BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v9, v8);
      char v23 = BundleVersionForURL;
      if (BundleVersionForURL != 3) {
        goto LABEL_22;
      }
      v49[0] = 0;
      *(_DWORD *)buffer = 0;
      if (_CFGetFileProperties(a1, v9, v49, buffer, 0LL, 0LL, 0LL, 0LL))
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          _CFBundleCreate_cold_5();
        }
        return 0LL;
      }

      if (!v49[0] || (*(_WORD *)buffer & 0xF000) != 0x4000)
      {
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
          _CFBundleCreate_cold_2();
        }
        CFURLRef v31 = v9;
        goto LABEL_39;
      }

void *_CFBundleCreateUniqueWithOptions( const __CFAllocator *a1, const __CFURL *a2, const __CFSet *a3, char a4)
{
  if ((a4 & 1) != 0) {
    int v5 = 2;
  }
  else {
    int v5 = 1;
  }
  return _CFBundleCreate(a1, a2, v5, a3);
}

void *_CFBundleCreateMain(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 3, 0LL);
}

CFArrayRef CFBundleCreateBundlesFromDirectory( CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(allocator, 0LL, &kCFTypeArrayCallBacks);
  int v5 = _CFCreateContentsOfDirectory((uint64_t)allocator, 0LL);
  if (v5)
  {
    int32x4_t v6 = v5;
    CFIndex Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0LL; i != v8; ++i)
      {
        ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v6, i);
        CFBundleRef v11 = CFBundleCreate(allocator, ValueAtIndex);
        if (v11) {
          CFArrayAppendValue(Mutable, v11);
        }
      }
    }

    CFRelease(v6);
  }

  return Mutable;
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef result = (CFURLRef)*((void *)bundle + 2);
  if (result)
  {
    CFRetain(result);
    return (CFURLRef)*((void *)bundle + 2);
  }

  return result;
}

UInt32 CFBundleGetVersionNumber(CFBundleRef bundle)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  Value = (const __CFNumber *)CFDictionaryGetValue(InfoDictionary, @"CFBundleNumericVersion");
  if (Value)
  {
    CFStringRef v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
      LODWORD(Value) = valuePtr;
    }

    else
    {
      LODWORD(Value) = 0;
    }
  }

  return Value;
}

CFStringRef CFBundleGetDevelopmentRegion(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!InfoDictionary) {
    return 0LL;
  }
  Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleDevelopmentRegion");
  int v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 != CFStringGetTypeID() || !CFStringGetLength(v5)) {
      return 0LL;
    }
  }

  return v5;
}

uint64_t _CFBundleGetHasChanged()
{
  return 1LL;
}

uint64_t _CFBundleGetStringsFilesShared()
{
  return 0LL;
}

CFURLRef CFBundleCopySupportFilesDirectoryURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFStringRef v3 = (const __CFURL *)*((void *)bundle + 2);
  if (!v3) {
    return 0LL;
  }
  unsigned int v4 = *((unsigned __int8 *)bundle + 53);
  if (v4 <= 0xB)
  {
    if (v4 == 1)
    {
      int v5 = @"Support%20Files/";
      return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v3);
    }

    if (v4 == 2)
    {
      int v5 = @"Contents/";
      return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v3);
    }

    return (CFURLRef)CFRetain(*((CFTypeRef *)bundle + 2));
  }

  if (v4 == 12)
  {
    uint64_t v7 = @"WrappedBundle/Contents/";
    return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v7, v3);
  }

  if (v4 == 13)
  {
    uint64_t v7 = @"WrappedBundle/";
    return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v7, v3);
  }

  return (CFURLRef)CFRetain(*((CFTypeRef *)bundle + 2));
}

CFURLRef _CFBundleCopyResourcesDirectoryURLInDirectory(CFURLRef baseURL, int a2)
{
  if (baseURL)
  {
    if (a2 <= 1)
    {
      if (a2)
      {
        if (a2 != 1) {
          return (CFURLRef)CFRetain(baseURL);
        }
        CFStringRef v3 = @"Support%20Files/Resources/";
      }

      else
      {
        CFStringRef v3 = @"Resources/";
      }
    }

    else
    {
      if (a2 != 2)
      {
        if (a2 == 12)
        {
          unint64_t v2 = @"WrappedBundle/Contents/Resources/";
          return _CFURLCreateResolvedDirectoryWithString( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  v2,  baseURL);
        }

        if (a2 == 13)
        {
          unint64_t v2 = @"WrappedBundle/";
          return _CFURLCreateResolvedDirectoryWithString( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  v2,  baseURL);
        }

        return (CFURLRef)CFRetain(baseURL);
      }

      CFStringRef v3 = @"Contents/Resources/";
    }

    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, baseURL);
  }

  return baseURL;
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  return _CFBundleCopyResourcesDirectoryURLInDirectory(*((CFURLRef *)bundle + 2), *((unsigned __int8 *)bundle + 53));
}

CFURLRef _CFBundleCopyAppStoreReceiptURLInDirectory(CFURLRef baseURL, unsigned int a2)
{
  if (baseURL && a2 <= 0xD && ((0x300Fu >> a2) & 1) != 0) {
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, off_189995F40[(char)a2], baseURL);
  }
  else {
    return 0LL;
  }
}

CFURLRef _CFBundleCopyAppStoreReceiptURL(uint64_t a1)
{
  return _CFBundleCopyAppStoreReceiptURLInDirectory(*(CFURLRef *)(a1 + 16), *(unsigned __int8 *)(a1 + 53));
}

CFURLRef _CFBundleCopyWrappedBundleURL(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  if ((*(_BYTE *)(a1 + 53) & 0xFE) == 0xC) {
    return _CFURLCreateResolvedDirectoryWithString( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  @"WrappedBundle",  *(const __CFURL **)(a1 + 16));
  }
  else {
    return 0LL;
  }
}

CFURLRef _CFBundleCopyWrapperContainerURL(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  if ((*(_BYTE *)(a1 + 53) & 0xFE) == 0xC) {
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Wrapper", *(CFURLRef *)(a1 + 16));
  }
  else {
    return 0LL;
  }
}

CFStringRef _CFBundleCopyExecutableName( CFBundleRef bundle, CFURLRef relativeURL, CFDictionaryRef theDict)
{
  InfoDictionary = theDict;
  if (bundle && !theDict) {
    InfoDictionary = CFBundleGetInfoDictionary(bundle);
  }
  if (bundle && !relativeURL) {
    relativeURL = (CFURLRef)*((void *)bundle + 2);
  }
  if (InfoDictionary
    && ((Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleExecutable")) != 0LL
     || (Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"NSExecutable")) != 0LL)
    && (CFTypeID v7 = CFGetTypeID(Value), v7 == CFStringGetTypeID())
    && CFStringGetLength(Value) >= 1)
  {
    CFRetain(Value);
  }

  else if (relativeURL {
         && (CFIndex v8 = CFURLCopyAbsoluteURL(relativeURL),
  }
             CFURLRef v9 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle),
             CFRelease(v8),
             v9))
  {
    CFIndex Length = CFStringGetLength(v9);
    CFIndex PathComponent2 = _CFStartOfLastPathComponent2(v9);
    uint64_t v12 = _CFLengthAfterDeletingPathExtension2(v9);
    Value = 0LL;
    if (PathComponent2 <= Length && v12 <= Length && v12 > PathComponent2)
    {
      v14.int location = PathComponent2;
      v14.CFIndex length = v12 - PathComponent2;
      Value = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, v14);
    }

    CFRelease(v9);
  }

  else
  {
    return 0LL;
  }

  return Value;
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFStringRef v3 = (os_unfair_lock_s *)((char *)bundle + 96);
  os_unfair_lock_lock_with_options();
  Boolean v4 = *((_BYTE *)bundle + 52);
  os_unfair_lock_unlock(v3);
  return v4;
}

CFURLRef CFBundleGetExecutableType(uint64_t a1)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  CFURLRef result = CFBundleCopyExecutableURL((CFBundleRef)a1);
  if (result)
  {
    int v5 = result;
    if (!*(_DWORD *)(a1 + 48))
    {
      int v7 = _CFBundleGrokBinaryType(result, v4);
      *(_DWORD *)(a1 + 48) = v7;
      if (v7 != 1 && v7 != 6) {
        *(_BYTE *)(a1 + 64) = 1;
      }
    }

    CFRelease(v5);
    int v6 = *(_DWORD *)(a1 + 48) - 1;
    else {
      return (const __CFURL *)dword_180C33598[v6];
    }
  }

  else
  {
    *(_DWORD *)(a1 + 48) = 7;
  }

  return result;
}

CFErrorRef _CFBundleCreateErrorDebug(const __CFAllocator *a1, CFBundleRef bundle, CFIndex a3, void *a4)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  CFIndex v8 = CFBundleCopyBundleURL(bundle);
  CFURLRef v9 = CFURLCopyAbsoluteURL(v8);
  char v10 = CFBundleCopyExecutableURL(bundle);
  BundleWithCFStringRef Identifier = _CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation", v4);
  CFStringRef v12 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  if (v10)
  {
    CFStringRef v13 = CFURLCopyFileSystemPath(v10, kCFURLPOSIXPathStyle);
    if (BundleWithIdentifier) {
      goto LABEL_3;
    }
LABEL_6:
    CFStringRef StringWithValidatedFormat = 0LL;
    CFStringRef v17 = 0LL;
    goto LABEL_31;
  }

  CFStringRef v13 = 0LL;
  if (!BundleWithIdentifier) {
    goto LABEL_6;
  }
LABEL_3:
  CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(bundle, @"CFBundleName");
  alCFIndex loc = a1;
  if (ValueForInfoDictionaryKey)
  {
    char v15 = (const __CFString *)CFRetain(ValueForInfoDictionaryKey);
  }

  else
  {
    uint64_t v18 = CFBundleCopyBundleURL(bundle);
    if (!v18)
    {
      CFTypeRef v25 = @"<unknown>";
      goto LABEL_17;
    }

    uint64_t v19 = v18;
    CFIndex v20 = a3;
    uint64_t v21 = CFURLCopyFileSystemPath(v18, kCFURLPOSIXPathStyle);
    CFIndex Length = CFStringGetLength(v21);
    CFRelease(v19);
    if (Length >= 1026) {
      CFIndex v23 = 1026LL;
    }
    else {
      CFIndex v23 = Length;
    }
    v38.int location = 0LL;
    v38.CFIndex length = v23;
    CFStringGetCharacters(v21, v38, buffer);
    CFRelease(v21);
    if (Length < 1) {
      uint64_t PathComponent = 0LL;
    }
    else {
      uint64_t PathComponent = _CFStartOfLastPathComponent(buffer, v23);
    }
    a3 = v20;
    char v15 = CFStringCreateWithCharacters( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  &buffer[PathComponent],  v23 - PathComponent);
  }

  CFTypeRef v25 = v15;
LABEL_17:
  uint64_t v32 = a3;
  switch(a3)
  {
    case 3584LL:
      unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3584",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable isn\\U2019t loadable.",  @"Error");
      CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3584-C",  @"The bundle\\U2019s executable isn\\U2019t loadable.",  @"Error");
      unsigned int v27 = @"BundleErr3584-R";
      goto LABEL_25;
    case 3585LL:
      unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3585",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it doesn\\U2019t contain a version for the current architecture.",  @"Error");
      CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3585-C",  @"The bundle doesn\\U2019t contain a version for the current architecture.",  @"Error");
      unsigned int v27 = @"BundleErr3585-R";
      uint64_t v28 = @"Try installing a universal version of the bundle.";
      goto LABEL_26;
    case 3586LL:
      unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3586",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it isn\\U2019t compatible with the current application.",  @"Error");
      CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3586-C",  @"The bundle isn\\U2019t compatible with this application.",  @"Error");
      unsigned int v27 = @"BundleErr3586-R";
      uint64_t v28 = @"Try installing a newer version of the bundle.";
      goto LABEL_26;
    case 3587LL:
      unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3587",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it is damaged or missing necessary resources.",  @"Error");
      CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3587-C",  @"The bundle is damaged or missing necessary resources.",  @"Error");
      unsigned int v27 = @"BundleErr3587-R";
      goto LABEL_25;
    case 3588LL:
      unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3588",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded.",  @"Error");
      CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr3588-C",  @"The bundle couldn\\U2019t be loaded.",  @"Error");
      unsigned int v27 = @"BundleErr3588-R";
      goto LABEL_25;
    default:
      if (a3 == 4)
      {
        uint64_t v32 = 4LL;
        unsigned int v26 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr4",  @"The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable couldn\\U2019t be located.",  @"Error");
        CFStringRef v17 = CFBundleCopyLocalizedString( BundleWithIdentifier,  @"BundleErr4-C",  @"The bundle\\U2019s executable couldn\\U2019t be located.",  @"Error");
        unsigned int v27 = @"BundleErr4-R";
LABEL_25:
        uint64_t v28 = @"Try reinstalling the bundle.";
LABEL_26:
        BundleWithCFStringRef Identifier = (__CFBundle *)CFBundleCopyLocalizedString(BundleWithIdentifier, v27, v28, @"Error");
        if (v26)
        {
          CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(alloc, 0LL, @"%@", v26, 0LL, v25);
          CFRelease(v26);
        }

        else
        {
          CFStringRef StringWithValidatedFormat = 0LL;
        }

        a3 = v32;
      }

      else
      {
        BundleWithCFStringRef Identifier = 0LL;
        CFStringRef v17 = 0LL;
        CFStringRef StringWithValidatedFormat = 0LL;
      }

      CFRelease(v25);
      a1 = alloc;
      break;
  }

LABEL_31:
  if (v12)
  {
    *(void *)buffer = @"NSBundlePath";
    userInfoValues[0] = (void *)v12;
    CFIndex v29 = 1LL;
    if (!v13) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }

  CFIndex v29 = 0LL;
  if (v13)
  {
LABEL_33:
    *(void *)&buffer[4 * v29] = @"NSFilePath";
    userInfoValues[v29++] = (void *)v13;
  }

  if (v9) {
    CFRelease(v9);
  }
}

  pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
  if ((*((_WORD *)timer + 8) & 4) == 0) {
    CFRelease(timer);
  }
}

    uint64_t v18 = 2LL;
    goto LABEL_32;
  }

  return v13;
}

          CFRelease(v14);
          goto LABEL_32;
        }

        CFIndex v23 = 1LL;
        goto LABEL_32;
      }
    }

    else
    {
LABEL_42:
      LOWORD(v24) = -3;
    }

LABEL_34:
  if (StringWithValidatedFormat)
  {
    *(void *)&buffer[4 * v29] = @"NSLocalizedDescription";
    userInfoValues[v29++] = (void *)StringWithValidatedFormat;
  }

  if (v17)
  {
    *(void *)&buffer[4 * v29] = @"NSLocalizedFailureReason";
    userInfoValues[v29++] = (void *)v17;
  }

  if (BundleWithIdentifier)
  {
    *(void *)&buffer[4 * v29] = @"NSLocalizedRecoverySuggestion";
    userInfoValues[v29++] = BundleWithIdentifier;
  }

  if (a4)
  {
    *(void *)&buffer[4 * v29] = @"NSDebugDescription";
    userInfoValues[v29++] = a4;
  }

  CFErrorRef v30 = CFErrorCreateWithUserInfoKeysAndValues( a1,  @"NSCocoaErrorDomain",  a3,  (const void *const *)buffer,  (const void *const *)userInfoValues,  v29);
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (StringWithValidatedFormat) {
    CFRelease(StringWithValidatedFormat);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (BundleWithIdentifier) {
    CFRelease(BundleWithIdentifier);
  }
  return v30;
}

  unsigned int v16 = atomic_load(v5 + 1);
  if ((v16 & 0x70) == 0 || (CFStringRef v17 = atomic_load(v4 + 1), (v17 & 0x70) == 0))
  {
    unsigned int v27 = atomic_load(v5 + 1);
    uint64_t v28 = atomic_load(v4 + 1);
    if (((v28 ^ v27) & 0x70) != 0) {
      goto LABEL_47;
    }
    if (v5[3] != v4[3]) {
      goto LABEL_47;
    }
    CFIndex v29 = atomic_load(v5 + 1);
    if ((v29 & 8) != 0) {
      goto LABEL_47;
    }
    CFErrorRef v30 = atomic_load(v4 + 1);
    if ((v30 & 8) != 0) {
      goto LABEL_47;
    }
    goto LABEL_97;
  }

  uint64_t v18 = atomic_load(v5 + 1);
  if ((v18 & 0x70) != 0x10LL)
  {
    uint64_t v19 = atomic_load(v4 + 1);
    if ((v19 & 0x70) != 0x10LL)
    {
      char v34 = v5[5];
      if (v34) {
        unsigned int v35 = *(_DWORD *)(v34 + 8);
      }
      else {
        unsigned int v35 = 0;
      }
      BOOL v39 = v4[5];
      if (v39)
      {
        BOOL v40 = *(_DWORD *)(v39 + 8);
        if (v34) {
          goto LABEL_56;
        }
      }

      else
      {
        BOOL v40 = 0;
        if (v34)
        {
LABEL_56:
          unint64_t v41 = *(unsigned __int8 *)(v34 + 13) != 0;
          if (v39) {
            goto LABEL_57;
          }
          goto LABEL_64;
        }
      }

      unint64_t v41 = 0;
      if (v39)
      {
LABEL_57:
        uint64_t v42 = *(unsigned __int8 *)(v39 + 13) == 0;
        if (v41) {
          CFTypeID v43 = ~v35 & 0x1FFFE;
        }
        else {
          CFTypeID v43 = v35;
        }
        if (*(_BYTE *)(v39 + 13)) {
          BOOL v40 = ~v40 & 0x1FFFE;
        }
        goto LABEL_68;
      }

  if (!a3) {
    goto LABEL_35;
  }
LABEL_36:
  if (!bundle && InfoDictionary) {
    CFRelease(InfoDictionary);
  }
  return v10;
}

  *(void *)(a1 + 184) = v7;
  *(void *)(a1 + 192) = v6;
}

        if (v23 == 8205)
        {
LABEL_35:
          CFErrorRef v30 = v17;
          while (1)
          {
            a2 = v30;
            CFURLRef v31 = v30 - 2;
            if (v30 < 2)
            {
LABEL_121:
              uint64_t v18 = v17 - a2 + v160;
              uint64_t v64 = v160 + v17;
              if (v18 < 2 || v64 >= v8)
              {
LABEL_207:
                CFRange v14 = BitmapPtrForPlane;
LABEL_208:
                uint64_t v91 = v18 + a2;
                if (v18 + a2 <= 5) {
                  int64_t v92 = 5LL;
                }
                else {
                  int64_t v92 = v18 + a2;
                }
                uint64_t v93 = v92 - 5;
                if (v92 - 5 <= a2)
                {
                  int64_t v161 = v18;
                  uint64_t v94 = a2 + 6;
                  unint64_t v95 = (char *)&v173 + 6;
                  CFRange v96 = 5 - v92;
                  unsigned int v97 = v92 + 59;
                  uint64_t v98 = (unsigned __int8 *)&__CFTranscodingHintLength;
                  while (1)
                  {
                    UniChar v99 = v92 - 5;
                    uint64_t v100 = v93 >= 4 ? 4LL : v93;
                    int v101 = v180;
                    if (v180 > v99)
                    {
                      if (v177)
                      {
                        UniChar v102 = v177[v92 - 5 + v179];
                      }

                      else if (v178)
                      {
                        UniChar v102 = *(char *)(v178 + v179 + v92 - 5);
                      }

                      else
                      {
                        if (v182 <= v99 || (CFMutableSetRef v103 = v181, v181 > v99))
                        {
                          CFURLRef v104 = -5 - v100;
                          uint64_t v157 = v95;
                          v158 = a2;
                          char v105 = v100 + v96;
                          uint64_t v106 = v97 - v100;
                          v107 = v92 + v104;
                          v108 = v107 + 64;
                          if (v107 + 64 >= v180) {
                            v108 = v180;
                          }
                          CFIndex v181 = v107;
                          char v182 = v108;
                          if (v180 >= v106) {
                            int v101 = v106;
                          }
                          v192.CFIndex length = v101 + v105;
                          int v109 = v98;
                          v192.int location = v107 + v179;
                          CFStringGetCharacters(theString, v192, buffer);
                          uint64_t v98 = v109;
                          unint64_t v95 = v157;
                          a2 = v158;
                          CFMutableSetRef v103 = v181;
                        }

                        UniChar v102 = *(_WORD *)&v95[2 * v92 + -2 * v103];
                      }

                      if ((v102 & 0xFFF0) == 0xF860)
                      {
                        uint64_t v110 = v98[v102 - 63584];
                        if (v92 + v110 - 4 >= v91) {
                          break;
                        }
                      }
                    }

                    ++v93;
                    ++v92;
                    --v96;
                    ++v97;
                    if (v94 == v92)
                    {
                      uint64_t v18 = v161;
                      CFRange v14 = BitmapPtrForPlane;
                      goto LABEL_233;
                    }
                  }

                  uint64_t v115 = v110 + v92;
                  uint64_t v116 = v115 - 5;
                  uint64_t v18 = v161;
                  CFRange v14 = BitmapPtrForPlane;
                  if (v115 - 5 < v8)
                  {
                    a2 = v92 - 5;
                    uint64_t v117 = v115 - 4;
                    unsigned int v118 = v92 - 4;
                    while (v118 <= v116)
                    {
                      v119 = _CFStringInlineBufferGetComposedRange(buffer, v118, v164, BitmapPtrForPlane, v163);
                      unsigned int v118 = v119 + v120;
                      if (v118 > v117)
                      {
                        uint64_t v117 = v119;
                        break;
                      }
                    }

                    uint64_t v18 = v117 - v92 + 5;
                  }
                }

    CFRange v14 = "L";
    goto LABEL_35;
  }

  CFRange v14 = "C";
LABEL_35:
  v46[0] = v14;
  if (a4) {
    uint64_t v21 = a4;
  }
  else {
    uint64_t v21 = &stru_1899EF170;
  }
  if (a3) {
    uint64_t v22 = "B";
  }
  else {
    uint64_t v22 = "*";
  }
  CFIndex Length = CFStringGetLength(v11);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFTypeRef v25 = CFStringGetLength(Copy);
  unsigned int v26 = CFStringGetMaximumSizeForEncoding(v25, 0x8000100u);
  unsigned int v27 = CFStringGetLength(v21);
  uint64_t v28 = CFStringGetMaximumSizeForEncoding(v27, 0x8000100u);
  v46[1] = (const char *)v46;
  CFIndex v29 = MaximumSizeForEncoding + v26 + v28;
  CFErrorRef v30 = v29 + 2;
  CFURLRef v31 = v29 + 7;
  MEMORY[0x1895F8858](v28, v32);
  char v34 = (UInt8 *)v46 - v33;
  if (v30 < 1019) {
    bzero((char *)v46 - v33, v31);
  }
  else {
    char v34 = (UInt8 *)calloc(v31, 1uLL);
  }
  v47[0] = 0LL;
  v48.CFIndex length = CFStringGetLength(v11);
  v48.int location = 0LL;
  CFStringGetBytes(v11, v48, 0x8000100u, 0, 0, v34, v31, v47);
  unsigned int v35 = v31 + ~v47[0];
  int v36 = (UInt8 *)(strncat((char *)&v34[v47[0]], "/", v35) + 1);
  v49.CFIndex length = CFStringGetLength(Copy);
  v49.int location = 0LL;
  CFStringGetBytes(Copy, v49, 0x8000100u, 0, 0, v36, v35, v47);
  uint64_t v37 = v35 - v47[0];
  CFRange v38 = v35 - v47[0] - 1;
  BOOL v39 = (UInt8 *)(strncat((char *)&v36[v47[0]], "/", v38) + 1);
  v50.CFIndex length = CFStringGetLength(v21);
  v50.int location = 0LL;
  CFStringGetBytes(v21, v50, 0x8000100u, 0, 0, v39, v38, v47);
  BOOL v40 = (char *)&v39[v47[0]];
  strncat((char *)&v39[v47[0]], "/", v37 - 2);
  strncat(v40 + 1, v22, v37 - 3);
  strncat(v40 + 2, "/", v37 - 4);
  strncat(v40 + 3, v46[0], v37 - 5);
  unint64_t v41 = strlen((const char *)v34);
  if (v30 < 1019) {
    uint64_t v42 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v41, 0x8000100u, 0);
  }
  else {
    uint64_t v42 = CFStringCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v34,  v41,  0x8000100u,  0,  (CFAllocatorRef)&__kCFAllocatorMalloc);
  }
  CFIndex v20 = v42;
  CFRelease(Copy);
  return v20;
}

  if (!a4)
  {
    if (a6)
    {
      if (a3 >= 2 && v22 - v20 >= 4)
      {
        CFErrorRef v30 = v22 - v20 - 3;
        do
        {
          CFIndex v29 = (uint64_t)v22;
          v22 -= 3;
          if (strncmp(v22, "%2F", 3uLL)) {
            break;
          }
          if (a3 < 3) {
            goto LABEL_58;
          }
          --a3;
          CFIndex v29 = (uint64_t)v22;
          CFURLRef v31 = v30 < 4;
          v30 -= 3LL;
        }

        while (!v31);
        goto LABEL_59;
      }
    }

    else if (a3 >= 2)
    {
      CFIndex v29 = (uint64_t)&v22[-a3 + 1];
      while (a2[a3 - 1] == 47)
      {
        --a3;
        --v22;
      }
    }

    goto LABEL_58;
  }

  if (!a6)
  {
    if (a3 >= 1 && a2[a3 - 1] != 47) {
      *v22++ = 47;
    }
    goto LABEL_58;
  }

  if (v22 - v20 < 4 || !strncmp(v22 - 3, "%2F", 3uLL))
  {
LABEL_58:
    CFIndex v29 = (uint64_t)v22;
    goto LABEL_59;
  }

  *(_WORD *)uint64_t v22 = 12837;
  CFIndex v29 = (uint64_t)(v22 + 3);
  v22[2] = 70;
LABEL_59:
  uint64_t v32 = CFStringCreateWithBytes(a1, (const UInt8 *)v20, v29 - (void)v20, 0x8000100u, 0);
LABEL_60:
  a7 = (char *)v34[0];
  if (v20 != v18) {
    free(v20);
  }
LABEL_62:
  if (a7) {
    *a7 = v23;
  }
  return v32;
}

  unsigned int v26 = 0;
  p_info = &OBJC_METACLASS_____NSCFTimer.info;
LABEL_35:
  _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
  if (makeLogHandles_logToken != -1) {
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_133);
  }
  if (os_log_type_enabled((os_log_t)p_info[474], OS_LOG_TYPE_DEBUG)) {
    -[CFPrefsSearchListSource copyCloudConfigurationWithURL:outConfigFileSource:outStoreName:].cold.1(a1);
  }
  _CFSetTSD(0xFu, 0LL, 0LL);
  uint64_t v4 = 0LL;
  if ((v26 & 1) == 0) {
    goto LABEL_40;
  }
  return v4;
}

CFErrorRef _CFBundleCreateError(const __CFAllocator *a1, __CFBundle *a2, CFIndex a3)
{
  return _CFBundleCreateErrorDebug(a1, a2, a3, 0LL);
}

uint64_t _CFBundleLoadExecutableAndReturnError(uint64_t a1, int a2, void *a3)
{
  v18[1] = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  }
  v18[0] = 0LL;
  if (a3) {
    int v7 = (CFTypeRef *)v18;
  }
  else {
    int v7 = 0LL;
  }
  CFIndex v8 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!v8) {
    *(_DWORD *)(a1 + 48) = 7;
  }
  _CFBundleDlfcnCheckLoaded(a1);
  if (!*(_DWORD *)(a1 + 48))
  {
    int v13 = _CFBundleGrokBinaryType(v8, v9);
    *(_DWORD *)(a1 + 48) = v13;
    if (v13 != 1 && v13 != 6) {
      *(_BYTE *)(a1 + 64) = 1;
    }
  }

  if (v8) {
    CFRelease(v8);
  }
  int v10 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (!v10)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 3:
      case 6:
      case 8:
        uint64_t Bundle = _CFBundleDlfcnLoadBundle(a1, a2, v7);
        goto LABEL_29;
      case 2:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (!os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        _CFBundleLoadExecutableAndReturnError_cold_2();
        if (!a3) {
          return 0LL;
        }
        goto LABEL_27;
      case 4:
        uint64_t Bundle = _CFBundleDlfcnLoadFramework(a1, v7);
LABEL_29:
        uint64_t v11 = Bundle;
        if ((_DWORD)Bundle)
        {
          if (*(_BYTE *)(a1 + 72)) {
            _CFPlugInHandleDynamicRegistration(a1);
          }
          return v11;
        }

        if (a3) {
          goto LABEL_40;
        }
        return 0LL;
      case 7:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_3();
          if (!a3) {
            return 0LL;
          }
        }

        else if (!a3)
        {
          return 0LL;
        }

        char v15 = CFGetAllocator((CFTypeRef)a1);
        unsigned int v16 = (__CFBundle *)a1;
        CFIndex v17 = 4LL;
        goto LABEL_39;
      default:
        if (_CFBundleLoadingLogger_onceToken != -1) {
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_1();
          if (!a3) {
            return 0LL;
          }
        }

        else
        {
LABEL_26:
          if (!a3) {
            return 0LL;
          }
        }

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, error);
}

Boolean CFBundleLoadExecutable(CFBundleRef bundle)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, 0LL);
}

Boolean CFBundlePreflightExecutable(CFBundleRef bundle, CFErrorRef *error)
{
  v15[1] = *MEMORY[0x1895F89C0];
  v15[0] = 0LL;
  if (error) {
    uint64_t v4 = (CFErrorRef *)v15;
  }
  else {
    uint64_t v4 = 0LL;
  }
  int v5 = CFBundleCopyExecutableURL(bundle);
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 24);
  if (!v5) {
    *((_DWORD *)bundle + 12) = 7;
  }
  _CFBundleDlfcnCheckLoaded((uint64_t)bundle);
  if (!*((_DWORD *)bundle + 12))
  {
    int v9 = _CFBundleGrokBinaryType(v5, v6);
    *((_DWORD *)bundle + 12) = v9;
    if (v9 != 1 && v9 != 6) {
      *((_BYTE *)bundle + 64) = 1;
    }
  }

  if (v5) {
    CFRelease(v5);
  }
  int v7 = *((unsigned __int8 *)bundle + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 24);
  if (v7)
  {
    LOBYTE(v8) = 1;
  }

  else
  {
    switch(*((_DWORD *)bundle + 12))
    {
      case 0:
      case 3:
      case 4:
      case 6:
      case 8:
        int v8 = _CFBundleDlfcnPreflight((unsigned __int8 *)bundle, v4);
        if (error) {
          goto LABEL_22;
        }
        break;
      case 7:
        if (!error) {
          goto LABEL_24;
        }
        int v10 = CFGetAllocator(bundle);
        uint64_t v11 = bundle;
        CFIndex v12 = 4LL;
        goto LABEL_21;
      default:
        if (error)
        {
          int v10 = CFGetAllocator(bundle);
          uint64_t v11 = bundle;
          CFIndex v12 = 3584LL;
LABEL_21:
          CFErrorRef ErrorDebug = _CFBundleCreateErrorDebug(v10, v11, v12, 0LL);
          int v8 = 0;
          v15[0] = ErrorDebug;
LABEL_22:
          if (!v8) {
            *error = (CFErrorRef)v15[0];
          }
        }

        else
        {
LABEL_24:
          LOBYTE(v8) = 0;
        }

        break;
    }
  }

  return v8;
}

CFArrayRef CFBundleCopyExecutableArchitectures(CFBundleRef bundle)
{
  CFArrayRef result = CFBundleCopyExecutableURL(bundle);
  if (result)
  {
    CFArrayRef v3 = result;
    uint64_t v4 = _CFBundleCopyArchitecturesForExecutable(result, v2);
    CFRelease(v3);
    return v4;
  }

  return result;
}

void CFBundleUnloadExecutable(CFBundleRef bundle)
{
}

void _CFBundleUnloadExecutable(uint64_t a1, int a2)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (!a2) {
    _CFPlugInUnloadScheduledPlugIns();
  }
  os_unfair_lock_lock_with_options();
  int v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (v5)
  {
    _CFPlugInUnscheduleForUnloading((const void *)a1);
    _CFPlugInWillUnload(a1);
    os_unfair_lock_lock_with_options();
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }

uint64_t __CFBundleGetResourceData(uint64_t a1)
{
  return a1 + 64;
}

CFPlugInRef CFBundleGetPlugIn(CFPlugInRef bundle)
{
  if (!*((_BYTE *)bundle + 72)) {
    return 0LL;
  }
  return bundle;
}

uint64_t __CFBundleGetPlugInData(uint64_t a1)
{
  return a1 + 72;
}

BOOL _CFBundleCouldBeBundle(CFURLRef url)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  if (_CFGetFileProperties( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  url,  &v3,  &v2,  0LL,  0LL,  0LL,  0LL)
    || !v3)
  {
    return 0LL;
  }

  if ((v2 & 0xF000) == 0x4000) {
    return (v2 & 0x124) != 0;
  }
  return 0LL;
}

CFURLRef _CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1)
{
  return __CFBundleCopyFrameworkURLForExecutablePath(a1, 0LL);
}

CFURLRef __CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  int v4 = v3;
  int v5 = (const __CFString *)v2;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  bzero(buffer, 0x804uLL);
  bzero(v18, 0x804uLL);
  MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  0LL);
  CFIndex Length = CFStringGetLength(v5);
  if (Length >= 1026) {
    CFIndex v8 = 1026LL;
  }
  else {
    CFIndex v8 = Length;
  }
  v21.int location = 0LL;
  v21.CFIndex length = v8;
  CFStringGetCharacters(v5, v21, buffer);
  uint64_t v9 = _CFLengthAfterDeletingPathExtension(buffer, v8);
  _CFStartOfLastPathComponent(buffer, v9);
  __memmove_chk();
  uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v9);
  if (v4) {
    uint64_t v11 = &stru_1899EF170;
  }
  else {
    uint64_t v11 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
  }
  if (PathComponent >= 1)
  {
    do
    {
      uint64_t v12 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (PathComponent <= v12) {
        break;
      }
      CFStringSetExternalCharactersNoCopy( MutableWithExternalCharactersNoCopy,  &buffer[v12],  PathComponent - v12,  1026 - v12);
      if (!v4 && CFEqual(MutableWithExternalCharactersNoCopy, @"Resources"))
      {
        unsigned int v16 = 0LL;
        goto LABEL_26;
      }

      if (CFEqual(MutableWithExternalCharactersNoCopy, @"Support Files")
        || CFEqual(MutableWithExternalCharactersNoCopy, @"Contents"))
      {
        if (v4
          || (uint64_t v13 = _CFStartOfLastPathComponent(buffer, PathComponent),
              CFStringSetExternalCharactersNoCopy( MutableWithExternalCharactersNoCopy,  &buffer[v13],  PathComponent - v13,  1026 - v13),  CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
        {
          CFIndex v15 = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
          CFRange v14 = MutableWithExternalCharactersNoCopy;
          goto LABEL_22;
        }
      }

      else if (CFStringHasSuffix(MutableWithExternalCharactersNoCopy, @".framework") {
             && (v4 || CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
      }
      {
        CFRange v14 = MutableWithExternalCharactersNoCopy;
        CFIndex v15 = PathComponent;
LABEL_22:
        CFStringSetExternalCharactersNoCopy(v14, buffer, v15, 1026LL);
        unsigned int v16 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  MutableWithExternalCharactersNoCopy,  kCFURLPOSIXPathStyle,  1u);
        if (_CFBundleCouldBeBundle(v16)) {
          goto LABEL_25;
        }
        CFRelease(v16);
        break;
      }

      uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
    }

    while (PathComponent > 0);
  }

  unsigned int v16 = 0LL;
LABEL_25:
  if (!v4) {
LABEL_26:
  }
    CFRelease(v11);
  CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, 0LL, 0LL, 0LL);
  CFRelease(MutableWithExternalCharactersNoCopy);
  return v16;
}

__CFBundle *_CFBundleGetBundleWithIdentifierAndLibraryName(void *a1, const __CFString *a2)
{
  if (a2) {
    _CFBundleEnsureBundlesUpToDateWithHint(a2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  int v3 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v3;
}

void _CFBundleEnsureBundlesUpToDateWithHint(const __CFString *a1)
{
  uint64_t v2 = _CFBundleDYLDCopyLoadedImagePathsForHint(a1);
  if (v2)
  {
    int v3 = v2;
    _CFBundleEnsureBundlesExistForImagePaths(v2);
    CFRelease(v3);
  }

CFArrayRef CFBundleGetAllBundles(void)
{
  if (CFBundleGetAllBundles__lastBundleList)
  {
    if (!CFEqual((CFTypeRef)CFBundleGetAllBundles__lastBundleList, (CFTypeRef)_allBundles))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      v0 = _CFBundleCopyAllBundles();
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v0;
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    uint64_t v1 = _CFBundleCopyAllBundles();
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (CFBundleGetAllBundles__lastBundleList) {
      CFRelease(v1);
    }
    else {
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v1;
    }
  }

  uint64_t v2 = (const __CFArray *)CFBundleGetAllBundles__lastBundleList;
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v2;
}

__CFArray *_CFBundleCopyAllBundles()
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFIndex Count = CFArrayGetCount((CFArrayRef)_allBundles);
  MutableCFStringRef Copy = CFArrayCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Count + 1,  (CFArrayRef)_allBundles);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFArrayInsertValueAtIndex(MutableCopy, 0LL, MainBundle);
  return MutableCopy;
}

void _CFBundleEnsureAllBundlesUpToDate()
{
  v0 = _CFBundleDYLDCopyLoadedImagePathsIfChanged();
  if (v0)
  {
    uint64_t v1 = v0;
    _CFBundleEnsureBundlesExistForImagePaths(v0);
    CFRelease(v1);
  }

uint64_t _CFBundleLayoutVersion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 53);
}

CFURLRef CFBundleCopyPrivateFrameworksURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/Contents/Frameworks/";
    }

    else
    {
      if (v3 != 13) {
        goto LABEL_12;
      }
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/Frameworks/";
    }

    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }

  if (v3 == 1)
  {
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"Support%20Files/Frameworks/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  if (v3 != 2)
  {
LABEL_12:
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"Frameworks/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  int v4 = CFGetAllocator(bundle);
  int v5 = (const __CFURL *)*((void *)bundle + 2);
  int32x4_t v6 = @"Contents/Frameworks/";
  return CFURLCreateWithString(v4, v6, v5);
}

CFURLRef CFBundleCopySharedFrameworksURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/Contents/SharedFrameworks/";
    }

    else
    {
      if (v3 != 13) {
        goto LABEL_12;
      }
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/SharedFrameworks/";
    }

    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }

  if (v3 == 1)
  {
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"Support%20Files/SharedFrameworks/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  if (v3 != 2)
  {
LABEL_12:
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"SharedFrameworks/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  int v4 = CFGetAllocator(bundle);
  int v5 = (const __CFURL *)*((void *)bundle + 2);
  int32x4_t v6 = @"Contents/SharedFrameworks/";
  return CFURLCreateWithString(v4, v6, v5);
}

CFURLRef CFBundleCopySharedSupportURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/Contents/SharedSupport/";
    }

    else
    {
      if (v3 != 13) {
        goto LABEL_12;
      }
      int v7 = CFGetAllocator(bundle);
      CFIndex v8 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v9 = @"WrappedBundle/SharedSupport/";
    }

    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }

  if (v3 == 1)
  {
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"Support%20Files/SharedSupport/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  if (v3 != 2)
  {
LABEL_12:
    int v4 = CFGetAllocator(bundle);
    int v5 = (const __CFURL *)*((void *)bundle + 2);
    int32x4_t v6 = @"SharedSupport/";
    return CFURLCreateWithString(v4, v6, v5);
  }

  int v4 = CFGetAllocator(bundle);
  int v5 = (const __CFURL *)*((void *)bundle + 2);
  int32x4_t v6 = @"Contents/SharedSupport/";
  return CFURLCreateWithString(v4, v6, v5);
}

CFURLRef CFBundleCopyBuiltInPlugInsURL(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  unsigned int v3 = CFGetAllocator(bundle);
  int v4 = v3;
  unsigned int v5 = *((unsigned __int8 *)bundle + 53);
  if (v5 <= 0xB)
  {
    if (v5 == 1)
    {
      int32x4_t v6 = (const __CFURL *)*((void *)bundle + 2);
      int v7 = @"Support%20Files/PlugIns/";
      goto LABEL_13;
    }

    if (v5 == 2)
    {
      int32x4_t v6 = (const __CFURL *)*((void *)bundle + 2);
      int v7 = @"Contents/PlugIns/";
LABEL_13:
      uint64_t v11 = CFURLCreateWithString(v3, v7, v6);
      goto LABEL_14;
    }

LABEL_12:
    int32x4_t v6 = (const __CFURL *)*((void *)bundle + 2);
    int v7 = @"PlugIns/";
    goto LABEL_13;
  }

  if (v5 == 12)
  {
    CFIndex v8 = CFGetAllocator(bundle);
    uint64_t v9 = (const __CFURL *)*((void *)bundle + 2);
    int v10 = @"WrappedBundle/Contents/PlugIns/";
  }

  else
  {
    if (v5 != 13) {
      goto LABEL_12;
    }
    CFIndex v8 = CFGetAllocator(bundle);
    uint64_t v9 = (const __CFURL *)*((void *)bundle + 2);
    int v10 = @"WrappedBundle/PlugIns/";
  }

  uint64_t v11 = _CFURLCreateResolvedDirectoryWithString(v8, v10, v9);
LABEL_14:
  uint64_t v12 = v11;
  unsigned int v13 = *((unsigned __int8 *)bundle + 53);
  if (v13 > 0xB)
  {
    if (v13 == 12)
    {
      unsigned int v16 = CFGetAllocator(bundle);
      CFIndex v17 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v18 = @"WrappedBundle/Contents/Plug-ins/";
    }

    else
    {
      if (v13 != 13) {
        goto LABEL_26;
      }
      unsigned int v16 = CFGetAllocator(bundle);
      CFIndex v17 = (const __CFURL *)*((void *)bundle + 2);
      uint64_t v18 = @"WrappedBundle/Plug-ins/";
    }

    uint64_t v19 = _CFURLCreateResolvedDirectoryWithString(v16, v18, v17);
    goto LABEL_28;
  }

  if (v13 == 1)
  {
    CFRange v14 = (const __CFURL *)*((void *)bundle + 2);
    CFIndex v15 = @"Support%20Files/Plug-ins/";
    goto LABEL_27;
  }

  if (v13 != 2)
  {
LABEL_26:
    CFRange v14 = (const __CFURL *)*((void *)bundle + 2);
    CFIndex v15 = @"Plug-ins/";
    goto LABEL_27;
  }

  CFRange v14 = (const __CFURL *)*((void *)bundle + 2);
  CFIndex v15 = @"Contents/Plug-ins/";
LABEL_27:
  uint64_t v19 = CFURLCreateWithString(v4, v15, v14);
LABEL_28:
  uint64_t v20 = v19;
  if (v19)
  {
    unsigned int v21 = _CFURLExists(v19);
    if (v12 || (v21 & 1) == 0)
    {
      if (v21) {
        uint64_t v22 = v20;
      }
      else {
        uint64_t v22 = v12;
      }
      if (v21) {
        CFIndex v23 = v12;
      }
      else {
        CFIndex v23 = v20;
      }
      CFRelease(v23);
      return v22;
    }

    else
    {
      return v20;
    }
  }

  return v12;
}

    *(_DWORD *)(Instance + 2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(Instance + 24) = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(Instance + 28) = *(_DWORD *)(a1 + 72);
    *(void *)(Instance + 32) = 0LL;
    *(void *)(Instance + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
    unsigned int v16 = *(unsigned int *)(a1 + 68);
    CFIndex v17 = MEMORY[0x1895F87A8];
    if ((v16 & 0x80000000) == 0)
    {
      uint64_t v18 = (dispatch_queue_s *)__fdQueue();
      uint64_t v19 = dispatch_source_create(MEMORY[0x1895F8B60], v16, 0LL, v18);
      handler[0] = v17;
      handler[1] = 0x40000000LL;
      handler[2] = __CFFileDescriptorCreate_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_2;
      handler[4] = v11;
      handler[5] = v19;
      dispatch_source_set_event_handler(v19, handler);
      v32[0] = v17;
      v32[1] = 0x40000000LL;
      v32[2] = __CFFileDescriptorCreate_block_invoke_3;
      v32[3] = &__block_descriptor_tmp_3;
      v32[4] = v19;
      uint64_t v33 = *(_DWORD *)(a1 + 68);
      dispatch_source_set_cancel_handler(v19, v32);
      *(void *)(v11 + 32) = v19;
    }

    uint64_t v20 = *(unsigned int *)(a1 + 72);
    if ((v20 & 0x80000000) == 0)
    {
      unsigned int v21 = (dispatch_queue_s *)__fdQueue();
      uint64_t v22 = dispatch_source_create(MEMORY[0x1895F8B90], v20, 0LL, v21);
      v31[0] = v17;
      v31[1] = 0x40000000LL;
      v31[2] = __CFFileDescriptorCreate_block_invoke_4;
      v31[3] = &__block_descriptor_tmp_4;
      v31[4] = v11;
      v31[5] = v22;
      dispatch_source_set_event_handler(v22, v31);
      v29[0] = v17;
      v29[1] = 0x40000000LL;
      v29[2] = __CFFileDescriptorCreate_block_invoke_5;
      v29[3] = &__block_descriptor_tmp_5;
      v29[4] = v22;
      CFErrorRef v30 = *(_DWORD *)(a1 + 72);
      dispatch_source_set_cancel_handler(v22, v29);
      *(void *)(v11 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v22;
    }

    *(_WORD *)(v11 + 48) = 257;
    *(void *)(v11 + 64) = *(void *)(a1 + 48);
    CFIndex v23 = *(__int128 **)(a1 + 56);
    if (v23)
    {
      unsigned int v24 = *v23;
      CFTypeRef v25 = v23[1];
      *(void *)(v11 + 104) = *((void *)v23 + 4);
      *(_OWORD *)(v11 + 88) = v25;
      *(_OWORD *)(v11 + 72) = v24;
      unsigned int v26 = *(void *)(a1 + 56);
      unsigned int v27 = *(void *)(v26 + 8);
      uint64_t v28 = *(uint64_t (**)(uint64_t))(v26 + 16);
      if (v28) {
        unsigned int v27 = v28(v27);
      }
      *(void *)(v11 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v27;
    }

    *(_DWORD *)(v11 + 16) = 0;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v11;
  }

  int v7 = 0LL;
LABEL_13:
  free(v3);
  return v7;
}

  int v7 = 0LL;
LABEL_13:
  free(v3);
  return v7;
}

  os_unfair_lock_unlock(v6);
  return v9;
}

    unsigned int v13 = 0LL;
    int v10 = 0LL;
    ValueAtIndex = -1;
    goto LABEL_13;
  }

  if ((v5 & 3) != 3) {
    goto LABEL_12;
  }
  uint64_t v9 = *(const __CFArray **)(a1 + 256);
  if (!v9 || CFArrayGetCount(v9) < 1) {
    goto LABEL_12;
  }
  int v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0LL);
  CFRetain(v10);
  ValueAtIndex = -1;
LABEL_11:
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 256), 0LL);
  unsigned int v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 264), 0LL);
  CFRetain(v13);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 264), 0LL);
LABEL_13:
  CFRange v14 = *(void (**)(void))(a1 + 232);
  theData = (const __CFData *)v10;
  if (v14)
  {
    unint64_t v50 = *(void (**)(uint64_t))(a1 + 240);
    stat v47 = *(void *)(a1 + 224);
    v14();
  }

  else
  {
    stat v47 = 0LL;
    unint64_t v50 = 0LL;
  }

  CFIndex v15 = v13;
  unsigned int v16 = 0;
  __int16 v52 = v5;
  uint64_t v53 = 0;
  CFIndex v17 = (v8 >> 6) & 1;
  __int16 v54 = ValueAtIndex;
  uint64_t v18 = atomic_load(v3);
  uint64_t v19 = atomic_load(v3);
  uint64_t v20 = atomic_load(v3);
  char v46 = v20;
  unsigned int v21 = atomic_load(v3);
  if ((v21 & 0x40) != 0) {
    unsigned int v16 = (*(_BYTE *)(a1 + 18) & 1) == 0;
  }
  CFStringRef v51 = v7 & 3 | (8 * v17);
  uint64_t v22 = v19 & 3;
  CFIndex v23 = atomic_load(v3);
  do
  {
    unsigned int v24 = __ldaxr(v3);
    if (v24 == v23)
    {
      if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFDFLL, v3))
      {
        CFTypeRef v25 = 1;
        goto LABEL_24;
      }
    }

    else
    {
      __clrex();
    }

    CFTypeRef v25 = 0;
LABEL_24:
    CFIndex v23 = v24;
  }

  while (!v25);
  unsigned int v26 = atomic_load(v3);
  do
  {
    unsigned int v27 = __ldaxr(v3);
    if (v27 == v26)
    {
      if (!__stlxr(v26 & 0xFFFFFFFFFFFFFFBFLL, v3))
      {
        uint64_t v28 = 1;
        goto LABEL_31;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v28 = 0;
LABEL_31:
    unsigned int v26 = v27;
  }

  while (!v28);
  stat v48 = *(void *)(a1 + 224);
  if ((v21 & 0x40) != 0)
  {
    uint64_t v53 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)(a1 + 16) |= 0x10000u;
  }

  CFIndex v29 = *(void (**)(uint64_t, uint64_t, const void *, int *, uint64_t))(a1 + 208);
  pthread_mutex_unlock(v2);
  CFErrorRef v30 = v16 & (v18 >> 2);
  if (v30 == 1)
  {
    if (v53)
    {
      if (v29)
      {
        CFURLRef v31 = &v53;
        uint64_t v32 = a1;
        goto LABEL_41;
      }
    }

    else if (v29)
    {
      uint64_t v32 = a1;
      CFURLRef v31 = 0LL;
LABEL_41:
      v29(v32, 4LL, 0LL, v31, v48);
    }

    uint64_t v33 = 1;
  }

  else
  {
    uint64_t v33 = 0;
  }

  switch(v22)
  {
    case 2:
      char v34 = v15;
      unsigned int v35 = theData;
      if (v54 != -1)
      {
        if (v30)
        {
          uint64_t v33 = 1;
          if (!CFSocketIsValid((CFSocketRef)a1) || !v29) {
            break;
          }
        }

        else if (!v29)
        {
          goto LABEL_69;
        }

        v29(a1, 2LL, v34, (int *)&v54, v48);
        goto LABEL_69;
      }

      break;
    case 3:
      char v34 = v15;
      unsigned int v35 = theData;
      if (theData)
      {
        if (!v30 || CFSocketIsValid((CFSocketRef)a1))
        {
          CFIndex Length = CFDataGetLength(theData);
          if (v29) {
            v29(a1, 3LL, v34, (int *)theData, v48);
          }
          if (!Length && *(_DWORD *)(a1 + 156) == 1) {
            CFSocketInvalidate((CFSocketRef)a1);
          }
        }

          *a4 = -3;
          return 0LL;
        }

        int v7 = v10 + 33;
      }

      else
      {
        CFIndex v8 = v10 - 33;
      }

      if (v7 > v8) {
        goto LABEL_12;
      }
    }
  }

  return result;
}

  unsigned int v16 = atomic_load(v10);
  CFIndex v17 = atomic_load(v10);
  uint64_t v18 = v17 & 0x60;
  uint64_t v19 = (int8x16_t **)(a2 + 16);
  if ((v16 & 0x10) != 0)
  {
    if (v18)
    {
      unsigned int v21 = *v19;
    }

    else
    {
      CFErrorRef v30 = atomic_load((unint64_t *)(a2 + 8));
      unsigned int v21 = (int8x16_t *)&v19[(v30 & 5) != 4];
    }

    CFURLRef v31 = atomic_load((unint64_t *)(a2 + 8));
    if ((v31 & 5) == 4LL)
    {
      uint64_t v32 = (int8x16_t *)v21->u8[0];
    }

    else
    {
      uint64_t v33 = atomic_load((unint64_t *)(a2 + 8));
      if ((v33 & 0x60) != 0) {
        uint64_t v32 = *(int8x16_t **)(a2 + 24);
      }
      else {
        uint64_t v32 = *v19;
      }
    }

    int v36 = 2LL * (void)v32;
    unsigned int v35 = a1;
    char v34 = 256LL;
    uint64_t v37 = 2LL;
  }

  else
  {
    if (v18)
    {
      uint64_t v20 = *v19;
    }

    else
    {
      CFTypeRef v25 = atomic_load((unint64_t *)(a2 + 8));
      uint64_t v20 = (int8x16_t *)&v19[(v25 & 5) != 4LL];
    }

    unsigned int v26 = atomic_load((unint64_t *)(a2 + 8));
    unsigned int v27 = (int8x16_t *)((char *)v20 + ((v26 >> 2) & 1));
    LOBYTE(v26) = atomic_load((unint64_t *)(a2 + 8));
    if ((v26 & 5) == 4)
    {
      uint64_t v28 = v20->u8[0];
    }

    else
    {
      CFIndex v29 = atomic_load((unint64_t *)(a2 + 8));
      if ((v29 & 0x60) != 0) {
        uint64_t v28 = *(void *)(a2 + 24);
      }
      else {
        uint64_t v28 = (int64_t)*v19;
      }
    }

    char v34 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      char v34 = __CFDefaultEightBitStringEncoding;
    }

    unsigned int v35 = a1;
    unsigned int v21 = v27;
    int v36 = v28;
    uint64_t v37 = 0LL;
  }

  return (unint64_t *)__CFStringCreateImmutableFunnel3(v35, v21, v36, v34, v37, -1LL, 0LL, a8);
}

      int v7 = MEMORY[0x186E04540](v7, __s);
    }

    while ((_DWORD)v7);
  }

  return Mutable;
}

    unsigned int v16 = 0;
LABEL_13:
    CFIndex v17 = v8 + 31;
    ++v8;
    if (v17 >= a3) {
      goto LABEL_124;
    }
  }

  if (v11 != 1 || *(_BYTE *)(v8 + a2 + 3) != 2) {
    goto LABEL_12;
  }
  uint64_t v12 = 0;
  unsigned int v13 = 46;
  CFRange v14 = 28LL;
LABEL_11:
  CFIndex v15 = *(unsigned __int16 *)&v10[v14];
  if (v8 + v13 + v15 > a3) {
    goto LABEL_12;
  }
  uint64_t v18 = v13;
  uint64_t v19 = v12 ^ 1;
  if ((_DWORD)v15 != 8) {
    uint64_t v19 = 1;
  }
  if ((v19 & 1) != 0)
  {
    if (*(unsigned __int16 *)&v10[v14] <= 0x12u)
    {
      if ((_DWORD)v15 == 9)
      {
        if (!strncasecmp_l(&v10[v13], "META-INF/", 9uLL, 0LL))
        {
          unsigned int v16 = 0;
          LODWORD(v56) = 1;
          goto LABEL_78;
        }

        goto LABEL_19;
      }

      if ((_DWORD)v15 == 11)
      {
        if (!strncasecmp_l(&v10[v13], "content.xml", 0xBuLL, 0LL))
        {
          unsigned int v16 = 0;
          DWORD1(v56) = 1;
          goto LABEL_78;
        }

        if (!strncasecmp_l(&v10[v18], "_rels/.rels", 0xBuLL, 0LL))
        {
          unsigned int v16 = 0;
          LODWORD(v59) = 1;
          goto LABEL_78;
        }

        goto LABEL_19;
      }
    }

    else
    {
      switch((_DWORD)v15)
      {
        case 0x13:
          if (!strncasecmp_l(&v10[v13], "[Content_Types].xml", 0x13uLL, 0LL))
          {
            unsigned int v16 = 0;
            HIDWORD(v59) = 1;
            goto LABEL_78;
          }

          goto LABEL_19;
        case 0x14:
          if (!strncasecmp_l(&v10[v13], "META-INF/MANIFEST.MF", 0x14uLL, 0LL))
          {
            unsigned int v16 = 0;
            CFURLRef v55 = 1;
            goto LABEL_78;
          }

          goto LABEL_19;
        case 0x15:
          if (!strncasecmp_l(&v10[v13], "META-INF/manifest.xml", 0x15uLL, 0LL))
          {
            unsigned int v16 = 0;
            DWORD2(v56) = 1;
            goto LABEL_78;
          }

  uint64_t v9 = (unsigned __int16 *)&__CFToJISCharMap;
  int v10 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (2)
  {
    uint64_t v11 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v10 - v9)) >> 1;
    uint64_t v12 = &v9[17 * v11];
    unsigned int v13 = *v12;
    if (v13 > a2)
    {
      int v10 = v12 - 17;
      goto LABEL_18;
    }

    if (v13 + 16 <= a2)
    {
      uint64_t v9 = v12 + 17;
LABEL_18:
      if (v9 > v10) {
        goto LABEL_19;
      }
      continue;
    }

    break;
  }

  CFIndex v17 = v9[17 * v11 + 1 + (int)(a2 - v13)];
  if (v17 && (unsigned __int16)(v17 - 256) <= 0x7431u && (unsigned __int16)(v17 - 12111) <= 0xF9D1u)
  {
    uint64_t v18 = v17 >> 8;
    uint64_t v19 = v17 & 0x7F;
    if ((v17 & 0x100) != 0) {
      uint64_t v20 = 31;
    }
    else {
      uint64_t v20 = 125;
    }
    CFIndex v15 = v20 + v19;
    unsigned int v16 = (v18 + 479) >> 1;
    unsigned int v21 = v16 - 127;
    uint64_t v22 = (v16 - 127);
    if (v15 > 0x7E) {
      LOBYTE(v15) = v15 + 1;
    }
    LOBYTE(v16) = v16 - 63;
    if (v22 <= 0x9F) {
      LOBYTE(v16) = v21;
    }
    goto LABEL_37;
  }

  if (&OBJC_CLASS___NSDictionary == a1)
  {
    if (a5 == 1)
    {
      __NSSingleEntryDictionaryI_new((unint64_t)*a4, (unint64_t)*a3, 4);
    }

    else if (a5)
    {
      return (id)__NSDictionaryI_new((uint64_t *)a4, (uint64_t *)a3, 0LL, a5, 5LL);
    }

    else
    {
      return &__NSDictionary0__struct;
    }
  }

  else if (&OBJC_CLASS___NSMutableDictionary == a1)
  {
    __NSDictionaryM_new((uint64_t)a4, (uint64_t)a3, a5, 3uLL);
  }

  else
  {
    CFIndex v8 = __CFLookUpClass("NSDictionary");
    __CFRequireConcreteImplementation(v8, (uint64_t)a1);
    return 0LL;
  }

  return result;
}

      CFArrayRef result = (result + v12);
      *(_BYTE *)(a3 + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v11;
      int v4 = ++v5;
      if (v5 >= a2) {
        goto LABEL_15;
      }
    }
  }

  CFArrayRef result = 0LL;
LABEL_15:
  *(_BYTE *)(a3 + result) = 0;
  return result;
}

  if (self == (__NSPlaceholderDictionary *)&___immutablePlaceholderDictionary)
  {
    if (a5 == 1)
    {
      __NSSingleEntryDictionaryI_new((unint64_t)*a4, (unint64_t)*a3, 1);
    }

    else if (a5)
    {
      return (__NSPlaceholderDictionary *)__NSDictionaryI_new((uint64_t *)a4, (uint64_t *)a3, 0LL, a5, 1LL);
    }

    else
    {
      return (__NSPlaceholderDictionary *)&__NSDictionary0__struct;
    }
  }

  else if (self == (__NSPlaceholderDictionary *)&___mutablePlaceholderDictionary)
  {
    __NSDictionaryM_new((uint64_t)a4, (uint64_t)a3, a5, 3uLL);
  }

  else
  {
    __break(1u);
  }

  return self;
}

void _CFBundleEnsureBundleExistsForImagePath(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = __CFBundleCopyFrameworkURLForExecutablePath(a1, a2);
  if (v2)
  {
    unsigned int v3 = v2;
    int v4 = (os_unfair_lock_s *)_CFBundleCreate(&__kCFAllocatorSystemDefault, v2, 4LL, 0LL);
    if (v4)
    {
      uint64_t v5 = (uint64_t)v4;
      int32x4_t v6 = v4 + 24;
      os_unfair_lock_lock(v4 + 24);
      if (!*(_BYTE *)(v5 + 52))
      {
        _CFBundleDlfcnCheckLoaded(v5);
        int v7 = *(_DWORD *)(v5 + 48);
        if (v7 != 6 && v7 != 1)
        {
          if (!v7) {
            *(_DWORD *)(v5 + 48) = 4;
          }
          *(_BYTE *)(v5 + 64) = 1;
        }

        if (!*(_BYTE *)(v5 + 52))
        {
          if (_CFBundleLoadingLogger_onceToken != -1) {
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
          }
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
            _CFBundleEnsureBundleExistsForImagePath_cold_2();
          }
        }
      }

      os_unfair_lock_unlock(v6);
      InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v5);
      _CFBundleInitPlugIn((void *)v5, InfoDictionary, 0LL);
      _CFPlugInHandleDynamicRegistration(v5);
    }

    else
    {
      if (_CFBundleLoadingLogger_onceToken != -1) {
        dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
      }
      if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG)) {
        _CFBundleEnsureBundleExistsForImagePath_cold_1();
      }
    }

    CFRelease(v3);
  }

void *_CFBundleCopyFromTablesForURLLocked(void *key)
{
  if (!_bundlesByURL) {
    return 0LL;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)_bundlesByURL, key);
  unsigned int v3 = Value;
  if (Value)
  {
    if (Value[2])
    {
      CFRetain(Value);
      return v3;
    }

    CFDictionaryRemoveValue((CFMutableDictionaryRef)_bundlesByURL, key);
    return 0LL;
  }

  return v3;
}

__CFBundle *_CFBundleGetFromTablesLocked(void *key)
{
  ValueAtIndex = 0LL;
  if (key && _bundlesByIdentifier)
  {
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_bundlesByIdentifier, key);
    if (Value && (unsigned int v3 = Value, Count = CFArrayGetCount(Value), Count >= 1))
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0LL;
      do
      {
        ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v3, v6++);
        if (CFBundleIsExecutableLoaded(ValueAtIndex)) {
          BOOL v7 = ValueAtIndex == 0LL;
        }
        else {
          BOOL v7 = 1;
        }
        int v8 = v7;
      }

      while (v8 == 1 && v6 < v5);
      if (v8) {
        return (__CFBundle *)CFArrayGetValueAtIndex(v3, 0LL);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return ValueAtIndex;
}

void _CFBundleAddToTablesLocked(const void **value, const void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!*((_BYTE *)value + 54))
  {
    int v4 = (__CFArray *)_allBundles;
    if (!_allBundles)
    {
      *(_OWORD *)&callBacks.CFIndex version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
      *(_OWORD *)&callBacks.CFArrayReleaseCallBack release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
      callBacks.equal = CFEqual;
      int v4 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &callBacks);
      _allBundles = (uint64_t)v4;
    }

    CFArrayAppendValue(v4, value);
    CFMutableDictionaryRef Mutable = (__CFDictionary *)_bundlesByURL;
    if (!_bundlesByURL)
    {
      memset(&callBacks, 0, 24);
      callBacks.copyDescription = kCFTypeDictionaryValueCallBacks.copyDescription;
      callBacks.equal = CFEqual;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  (const CFDictionaryValueCallBacks *)&callBacks);
      _bundlesByURL = (uint64_t)Mutable;
    }

    CFDictionarySetValue(Mutable, value[2], value);
    if (a2)
    {
      CFIndex v6 = (const __CFDictionary *)_bundlesByIdentifier;
      if (!_bundlesByIdentifier)
      {
        CFIndex v6 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        _bundlesByCFStringRef Identifier = (uint64_t)v6;
      }

      BOOL v7 = (const __CFArray *)CFDictionaryGetValue(v6, a2);
      if (!v7)
      {
        memset(&callBacks, 0, 24);
        callBacks.copyDescription = kCFTypeArrayCallBacks.copyDescription;
        callBacks.equal = CFEqual;
        CFRange v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &callBacks);
        CFArrayAppendValue(v14, value);
        CFDictionarySetValue((CFMutableDictionaryRef)_bundlesByIdentifier, a2, v14);
        CFIndex v15 = v14;
LABEL_28:
        CFRelease(v15);
        return;
      }

      int v8 = v7;
      CFIndex Count = CFArrayGetCount(v7);
      UInt32 VersionNumber = CFBundleGetVersionNumber((CFBundleRef)value);
      if (Count < 1)
      {
        CFIndex v12 = 0LL;
      }

      else
      {
        UInt32 v11 = VersionNumber;
        CFIndex v12 = 0LL;
        while (1)
        {
          ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v8, v12);
          if (v11 >= CFBundleGetVersionNumber(ValueAtIndex)) {
            break;
          }
          if (Count == ++v12)
          {
            CFIndex v12 = Count;
            break;
          }
        }
      }

      CFArrayInsertValueAtIndex(v8, v12, value);
      if (_CFBundleResourceLogger_onceToken != -1) {
        dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
      }
      if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v16 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
        if (CFArrayGetCount(v8) >= 1)
        {
          CFIndex v17 = 0LL;
          do
          {
            uint64_t v18 = CFArrayGetValueAtIndex(v8, v17);
            CFStringRef v19 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"Bundle %p at %@",  v18,  v18[2]);
            CFArrayAppendValue(v16, v19);
            CFRelease(v19);
            ++v17;
          }

          while (v17 < CFArrayGetCount(v8));
        }

        if (_CFBundleResourceLogger_onceToken != -1) {
          dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
        }
        if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG)) {
          _CFBundleAddToTablesLocked_cold_1();
        }
        CFIndex v15 = v16;
        goto LABEL_28;
      }
    }
  }

void _CFBundleEnsureBundlesExistForImagePaths(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0LL; i != v3; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      _CFBundleEnsureBundleExistsForImagePath((uint64_t)ValueAtIndex, 1LL);
    }
  }

void OUTLINED_FUNCTION_0_0( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_3( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void _CFBundleFlushQueryTableCache(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 176);
  os_unfair_lock_lock_with_options();
  CFIndex v3 = *(__CFDictionary **)(a1 + 184);
  if (v3) {
    CFDictionaryRemoveAllValues(v3);
  }
  os_unfair_lock_unlock(v2);
}

BOOL _CFIsResourceAtURL(CFURLRef url, char *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (_CFGetFileProperties( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  url,  (char *)&v10,  &v9,  0LL,  0LL,  0LL,  0LL)) {
    return 0LL;
  }
  int v4 = v10;
  __int16 v5 = v9;
  if (a2)
  {
    if (v10) {
      BOOL v6 = (v9 & 0xF000) == 0x4000;
    }
    else {
      BOOL v6 = 0;
    }
    char v7 = v6;
    *a2 = v7;
  }

  return (v5 & 0x124) != 0 && v4 != 0;
}

CFURLRef CFBundleCopyResourceURL( CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle) {
    return _CFBundleCopyFindResources( (unint64_t *)bundle,  0LL,  (uint64_t)resourceType,  resourceName,  resourceType,  subDirName,  0LL,  0,  0,  0LL);
  }
  return bundle;
}

CFMutableArrayRef _CFBundleCopyFindResources( unint64_t *a1, const __CFURL *a2, uint64_t a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, uint64_t a10)
{
  uint64_t v15 = (uint64_t)a1;
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unint64_t v16 = _CFGetNonObjCTypeID(a1);
    if (v16 != 31) {
      _CFAssertMismatchedTypeID(0x1FuLL, v16);
    }
  }

  int v17 = dyld_program_sdk_at_least();
  int v107 = a8;
  if (!a6 || !v17)
  {
LABEL_16:
    if (!a4)
    {
LABEL_24:
      CFStringRef Copy = 0LL;
      CFIndex v29 = 0LL;
      goto LABEL_40;
    }

LABEL_66:
                    int v43 = 0;
LABEL_67:
                    LOBYTE(range) = v43;
                    if (a2)
                    {
                      unint64_t v44 = _CFBundleCopyLanguageSearchListInDirectory(a2, (unsigned __int8 *)&range);
                      int v43 = range;
                    }

                    else
                    {
                      unint64_t v44 = 0LL;
                    }

                    if (v43 <= 1)
                    {
                      if (!v43)
                      {
                        unint64_t v45 = @"Resources";
                        goto LABEL_82;
                      }

                      if (v43 == 1)
                      {
                        unint64_t v45 = @"Support Files/Resources";
                        goto LABEL_82;
                      }
                    }

                    else
                    {
                      switch(v43)
                      {
                        case 13:
                          unint64_t v45 = @"WrappedBundle";
                          goto LABEL_82;
                        case 12:
                          unint64_t v45 = @"WrappedBundle/Contents/Resources";
                          goto LABEL_82;
                        case 2:
                          unint64_t v45 = @"Contents/Resources";
                          goto LABEL_82;
                      }
                    }

                    unint64_t v45 = &stru_1899EF170;
LABEL_82:
                    CFTypeRef cf = v44;
                    UniChar v99 = v45;
                    char v46 = _copyResourceURLsFromBundle(v15, a2, v44, v45, v42, v41, a7, v107, a9, v43, a10);
                    uint64_t v33 = v46;
                    if (v46)
                    {
                      stat v47 = v42;
                      stat v48 = Copy;
                      int v49 = a2;
                      unint64_t v50 = v29;
                      CFStringRef v51 = a4;
                      CFTypeID v52 = CFGetTypeID(v46);
                      if (v52 != CFArrayGetTypeID())
                      {
                        a4 = v51;
                        CFIndex v29 = v50;
                        a2 = v49;
                        CFStringRef Copy = v48;
                        uint64_t v42 = v47;
                        goto LABEL_89;
                      }

                      a4 = v51;
                      CFIndex v29 = v50;
                      a2 = v49;
                      CFStringRef Copy = v48;
                      uint64_t v42 = v47;
                      if (CFArrayGetCount(v33)) {
                        goto LABEL_89;
                      }
                    }

                    if ((range & 0xFD) == 0)
                    {
                      if (v15)
                      {
                        CFAllocatorRef allocator = *(CFAllocatorRef *)(v15 + 192);
                        CFRetain(allocator);
                      }

                      else
                      {
                        uint64_t v63 = CFURLCopyAbsoluteURL(a2);
                        uint64_t v64 = v42;
                        unint64_t v65 = a5;
                        uint64_t v66 = Copy;
                        uint64_t v67 = a2;
                        char v68 = v29;
                        unint64_t v69 = a4;
                        uint64_t v70 = v63;
                        CFAllocatorRef allocator = (CFAllocatorRef)CFURLCopyFileSystemPath(v63, kCFURLPOSIXPathStyle);
                        unint64_t v71 = v70;
                        a4 = v69;
                        CFIndex v29 = v68;
                        a2 = v67;
                        CFStringRef Copy = v66;
                        a5 = v65;
                        uint64_t v42 = v64;
                        CFRelease(v71);
                      }

                      if ((_BYTE)range && !CFEqual(@"/Library/Spotlight", allocator))
                      {
LABEL_174:
                        CFRelease(allocator);
                        if (!v15) {
                          goto LABEL_120;
                        }
                        goto LABEL_90;
                      }

                      if (v33) {
                        CFRelease(v33);
                      }
                      int v72 = range;
                      if ((_BYTE)range)
                      {
                        uint64_t v73 = v106;
                      }

                      else
                      {
                        uint64_t v73 = v106;
                        if (v42)
                        {
                          if (CFEqual(v42, @"Resources"))
                          {
LABEL_157:
                            CFStringRef v84 = &stru_1899EF170;
                            goto LABEL_170;
                          }

                          int v72 = range;
                        }
                      }

                      BOOL v83 = cf;
                      if (v72 == 2 && v42)
                      {
                        if (CFEqual(v42, @"Contents/Resources")) {
                          goto LABEL_157;
                        }
                        int v72 = range;
                        BOOL v83 = cf;
                      }

                      if (!v72
                        && v42
                        && (CFIndex v85 = CFStringGetLength(v42), v83 = cf, v85 >= 11)
                        && (HasPrefix = CFStringHasPrefix(v42, @"Resources/"), BOOL v83 = cf, HasPrefix))
                      {
                        unint64_t v95 = v29;
                        UniChar v102 = a4;
                        uint64_t v87 = -10LL;
                        CFIndex v88 = 10LL;
                      }

                      else
                      {
                        if (range != 2 || !v42)
                        {
                          uint64_t v89 = &stru_1899EF170;
                          goto LABEL_173;
                        }

                        if (CFStringGetLength(v42) < 20 || !CFStringHasPrefix(v42, @"Contents/Resources/"))
                        {
                          uint64_t v89 = &stru_1899EF170;
                          BOOL v83 = cf;
                          goto LABEL_173;
                        }

                        unint64_t v95 = v29;
                        UniChar v102 = a4;
                        uint64_t v87 = -19LL;
                        CFIndex v88 = 19LL;
                      }

                      v118.CFIndex length = CFStringGetLength(v42) + v87;
                      v118.int location = v88;
                      CFStringRef v84 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v42, v118);
                      a4 = v102;
                      CFIndex v29 = v95;
LABEL_170:
                      CFRelease(v42);
                      uint64_t v42 = (__CFString *)v84;
                      BOOL v83 = cf;
                      uint64_t v73 = v106;
                      uint64_t v89 = v99;
LABEL_173:
                      uint64_t v33 = _copyResourceURLsFromBundle(v15, a2, v83, v89, v42, v73, a7, v107, a9, range, a10);
                      goto LABEL_174;
                    }

    __break(1u);
    return result;
  }

  int v26 = v8;
LABEL_65:
  *(void *)&GregorianDate.year = *(void *)&GregorianDate.year & 0xFFFF000000000000LL | v7 | (v26 << 32) | ((unint64_t)v20 << 40);
  return units->seconds
       + CFGregorianDateGetAbsoluteTime(GregorianDate, tz)
       + (double)units->hours * 3600.0
       + (double)units->minutes * 60.0;
}

  if (v7) {
    CFRelease(v7);
  }
  return 0LL;
}

          kdebug_trace();
          kdebug_trace();
          pthread_mutex_lock(v63);
          pthread_mutex_lock(v64);
          if (v30)
          {
            *(double *)(a1 + 664) = *(double *)(a1 + 664) + CFAbsoluteTimeGetCurrent() - Current;
            a4 = v61;
            if (name) {
              mach_port_extract_member(*MEMORY[0x1895FBBE0], name, v28);
            }
            *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
            int v38 = atomic_load((unint64_t *)(a1 + 8));
            while (1)
            {
              BOOL v39 = __ldaxr(v26);
              if (v39 != v38) {
                break;
              }
              if (__stlxr(v38 & 0xFFFFFFFFFFFFFFFDLL, v26)) {
                goto LABEL_74;
              }
              int v40 = 1;
LABEL_75:
              int v38 = v39;
              if (v40)
              {
                if ((*(_BYTE *)(a2 + 144) & 0x40) != 0) {
                  __CFRunLoopDoObservers(a1, a2, 64LL);
                }
                goto LABEL_87;
              }
            }

            __clrex();
LABEL_74:
            int v40 = 0;
            goto LABEL_75;
          }

          *(double *)(a1 + 664) = *(double *)(a1 + 664) + 0.0;
          a4 = v61;
          if (name) {
            mach_port_extract_member(*MEMORY[0x1895FBBE0], name, v28);
          }
          *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
          unint64_t v41 = atomic_load((unint64_t *)(a1 + 8));
          while (2)
          {
            uint64_t v42 = __ldaxr(v26);
            if (v42 == v41)
            {
              if (!__stlxr(v41 & 0xFFFFFFFFFFFFFFFDLL, v26))
              {
                int v43 = 1;
                goto LABEL_86;
              }
            }

            else
            {
              __clrex();
            }

            int v43 = 0;
LABEL_86:
            unint64_t v41 = v42;
            if (v43) {
              goto LABEL_87;
            }
            continue;
          }
        }
      }

      __clrex();
LABEL_51:
      BOOL v37 = 0;
      goto LABEL_52;
    }

  CFRange v14 = 0;
LABEL_67:
  if (a5)
  {
LABEL_68:
    if (v9 == 1 && !v14 && v12 == a5 && *__s1 == 15) {
      ++v13;
    }
  }

  return v13;
}

    uint64_t v42 = v29 + 1;
    v76[0] = 1LL;
    if (a7) {
      *(_BYTE *)(v72 + v24) = v71;
    }
    goto LABEL_72;
  }

  if (v76[0] + v24 == a7) {
    goto LABEL_114;
  }
  unint64_t v41 = (uint64_t (*)(uint64_t *, void, unint64_t, uint64_t, void, void, uint64_t *))v17[1];
  if (v41)
  {
    if (v41(v17, v73, v13 + 2 * v29, v30, 0LL, 0LL, &v75)) {
      goto LABEL_114;
    }
    goto LABEL_64;
  }

  if (!(*(uint64_t (**)(void, unint64_t, uint64_t, void, void, uint64_t *))*v17)( v73,  v13 + 2 * v29,  v30,  0LL,  0LL,  &v75)) {
    goto LABEL_64;
  }
LABEL_114:
  v24 += v76[0];
  LODWORD(v14) = v73;
  if ((v73 & 0xFF000001) == 1)
  {
    v76[0] = 0LL;
    do
    {
      __int16 v54 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v17[4])( v13 + 2 * v29,  a4 - v29,  0LL,  0LL,  v76);
      if (!v54) {
        break;
      }
      CFURLRef v55 = v76[0] ? 0LL : v54;
      v29 += v55;
    }

    while (v29 < a4 && v76[0] == 0LL);
  }

  CFArrayRef result = 2 * (v29 < a4);
LABEL_129:
  int v23 = v29;
  if (!(_DWORD)result)
  {
LABEL_130:
    if (a7 && v23 < a4)
    {
      if ((v14 & 0xFF000001) == 1)
      {
        v76[0] = 0LL;
        do
        {
          uint64_t v57 = ((uint64_t (*)(unint64_t, uint64_t, void, void, void *))v17[4])( v13 + 2 * v23,  a4 - v23,  0LL,  0LL,  v76);
          if (!v57) {
            break;
          }
          int v58 = v76[0] ? 0LL : v57;
          v23 += v58;
        }

        while (v23 < a4 && v76[0] == 0LL);
      }

      CFArrayRef result = 2 * (v23 < a4);
    }
  }

  if (a8) {
    *a8 = v24;
  }
  if (a5) {
    *a5 = v23;
  }
  return result;
}

  unsigned int v35 = v9 < 2;
  v9 -= 2LL;
  if (v35) {
    return v13;
  }
  BOOL v36 = a2[1] | (v14 << 8);
  BOOL v37 = (unsigned __int16 *)&macjapanese_to_uni_decomp;
  int v38 = (unsigned __int16 *)&unk_180D7B094;
  while (2)
  {
    BOOL v39 = ((char *)v38 - (char *)v37) >> 3;
    int v40 = &v37[2 * v39];
    unint64_t v41 = *v40;
    if (v41 > v36)
    {
      int v38 = v40 - 2;
      goto LABEL_73;
    }

    if (v41 < v36)
    {
      BOOL v37 = v40 + 2;
LABEL_73:
      if (v37 > v38) {
        return v13;
      }
      continue;
    }

    break;
  }

  uint64_t v42 = LOBYTE(v37[2 * v39 + 1]);
  int v43 = (v42 >> 6) + 2;
  if (v50)
  {
  }

  v12 += v43;
  if (!a5)
  {
LABEL_94:
    *a6 = v12;
    v13 += 2LL;
    a2 += 2;
    goto LABEL_35;
  }

  if (v12 <= a5)
  {
    else {
      unint64_t v45 = (char *)&__CFTwoCharDecompSeqTable_0 + 4 * v42 - 4;
    }
    char v46 = v43;
    stat v47 = a4;
    do
    {
      stat v48 = *(_WORD *)v45;
      v45 += 2;
      *v47++ = v48;
      --v46;
    }

    while (v46);
    a4 += v43;
    goto LABEL_94;
  }

  return v13;
}

LABEL_89:
                    if (!v15)
                    {
LABEL_120:
                      if ((v104 & 1) == 0) {
                        CFRelease(Copy);
                      }
                      if (v42) {
                        CFRelease(v42);
                      }
                      if (v29) {
                        CFRelease(v29);
                      }
                      if (cf) {
                        CFRelease(cf);
                      }
                      CFRelease(v106);
                      uint64_t v74 = (os_log_s *)_CFBundleResourceLogger();
                      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                      {
                        unint64_t v75 = a2;
                        CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
                        CFSetRef v77 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
                        unint64_t v78 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
                        if (v15)
                        {
                          CFStringAppendFormat(Mutable, 0LL, @"%@", v15);
                        }

                        else if (v75)
                        {
                          CFStringAppendFormat(Mutable, 0LL, @"CFURL %@", v75);
                        }

                        if (a4) {
                          CFStringAppend(v77, a4);
                        }
                        if (a5) {
                          CFStringAppendFormat(v77, 0LL, @" type: %@", a5);
                        }
                        if (a6) {
                          CFStringAppendFormat(v77, 0LL, @" path: %@", a6);
                        }
                        if (a7) {
                          CFStringAppendFormat(v77, 0LL, @" localization: %@", a7);
                        }
                        if (v33)
                        {
                          CFTypeID v79 = CFGetTypeID(v33);
                          if (v79 == CFArrayGetTypeID())
                          {
                            if (CFArrayGetCount(v33) >= 1)
                            {
                              CFIndex v80 = 0LL;
                              do
                              {
                                ValueAtIndex = CFArrayGetValueAtIndex(v33, v80);
                                CFStringAppendFormat(v78, 0LL, @"%@, ", ValueAtIndex);
                                ++v80;
                              }

                              while (v80 < CFArrayGetCount(v33));
                            }
                          }

                          else
                          {
                            CFStringAppendFormat(v78, 0LL, @"%@", v33);
                          }
                        }

                        else
                        {
                          CFStringAppendFormat(v78, 0LL, @"None", v90);
                        }

                        uint64_t v82 = (os_log_s *)_CFBundleResourceLogger();
                        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buffer = 138478339;
                          CFIndex v111 = Mutable;
                          __int16 v112 = 2114;
                          uint64_t v113 = v77;
                          __int16 v114 = 2114;
                          uint64_t v115 = v78;
                          _os_log_debug_impl( &dword_180A4C000,  v82,  OS_LOG_TYPE_DEBUG,  "Resource lookup at %{private}@\n \tRequest       : %{public}@\n \tResult        : %{public}@\n",  (uint8_t *)buffer,  0x20u);
                        }

                        CFRelease(Mutable);
                        CFRelease(v77);
                        CFRelease(v78);
                      }

                      return v33;
                    }

  int v40 = CFUniCharMapCaseTo(v113, v114, 8LL, 3LL, 0, (unsigned __int16 *)__s1);
  unint64_t v41 = v40;
  uint64_t v42 = &v114[v40];
  v18 -= v18 > 0;
  if (v18 >= 1 && (v40 & 0xFFFFFFFE) != 0)
  {
    int v43 = 0LL;
    if (v40)
    {
      unint64_t v44 = v114;
      unint64_t v45 = v114;
      do
      {
        char v46 = *v45++;
        if ((v46 & 0xFC00) == 0xD800 && v45 < v42)
        {
          stat v48 = v44[1] & 0xFC00;
          int v49 = v44 + 2;
          if (v48 == 56320) {
            unint64_t v45 = v49;
          }
        }

        ++v43;
        unint64_t v44 = v45;
      }

      while (v45 < v42);
    }

    memmove(&a6[v43], a6 + 1, 4 * v18);
  }

  int v109 = a4;
  if (v41)
  {
    unint64_t v50 = v114;
    CFStringRef v51 = a6;
    do
    {
      uint64_t v53 = (unsigned __int16 *)(v50 + 1);
      CFTypeID v52 = (unsigned __int16)*v50;
      uint64_t v113 = v52;
      __int16 v54 = (v52 & 0xFC00) != 0xD800 || v53 >= (unsigned __int16 *)v42;
      if (v54 || (CFURLRef v55 = *v53, (v55 & 0xFC00) != 0xDC00))
      {
        uint64_t v56 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
        ++v50;
      }

      else
      {
        v50 += 2;
        uint64_t v113 = (v52 << 10) - 56613888 + v55;
        uint64_t v56 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
        CFTypeID v52 = v113;
      }

      if (v56) {
        uint64_t v57 = v33;
      }
      else {
        uint64_t v57 = 1;
      }
      if ((v57 & 1) != 0 || ((*(unsigned __int8 *)(v56 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
      {
        *v51++ = v52;
        ++v18;
      }
    }

    while (v50 < v42);
  }

  CFStringRef v19 = 0;
  LOBYTE(a4) = v109;
LABEL_118:
  if ((a4 & 0x90) != 0)
  {
    LODWORD(v59) = (a4 & 0x80) == 0 || v113 > 0x50F;
    if (v18) {
      goto LABEL_126;
    }
    *a6 = v113;
    if ((_DWORD)v59)
    {
      if (v17 < 0 || (char v68 = *((void *)buffer + 20), v68 <= v17))
      {
        unint64_t v71 = 0;
      }

      else
      {
        unint64_t v69 = *((void *)buffer + 17);
        if (v69)
        {
          uint64_t v70 = *(_WORD *)(v69 + 2 * (*((void *)buffer + 19) + v17));
        }

        else
        {
          unint64_t v78 = *((void *)buffer + 18);
          if (v78)
          {
            uint64_t v70 = *(char *)(v78 + *((void *)buffer + 19) + v17);
          }

          else
          {
            if (*((void *)buffer + 22) <= v17 || (CFTypeID v79 = *((void *)buffer + 21), v79 > v17))
            {
              CFIndex v80 = v17 - 4;
              if (v80 + 64 < v68) {
                char v68 = v80 + 64;
              }
              *((void *)buffer + 21) = v80;
              *((void *)buffer + 22) = v68;
              v117.int location = *((void *)buffer + 19) + v80;
              v117.CFIndex length = v68 - v80;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v117, buffer);
              CFTypeID v79 = *((void *)buffer + 21);
            }

            uint64_t v70 = buffer[v17 - v79];
          }
        }

        unint64_t v71 = v70;
        if (v70 >> 10 == 54)
        {
          uint64_t v81 = v17 + 1;
          uint64_t v82 = *((void *)buffer + 20);
          if (v82 > v17 + 1)
          {
            BOOL v83 = *((void *)buffer + 17);
            if (v83)
            {
              CFStringRef v84 = *(_WORD *)(v83 + 2 * (*((void *)buffer + 19) + v81));
            }

            else
            {
              CFIndex v85 = *((void *)buffer + 18);
              if (v85)
              {
                CFStringRef v84 = *(char *)(v85 + *((void *)buffer + 19) + v81);
              }

              else
              {
                if (*((void *)buffer + 22) <= v81 || (CFIndex v88 = *((void *)buffer + 21), v88 > v81))
                {
                  uint64_t v89 = v17 - 3;
                  if (v89 + 64 < v82) {
                    uint64_t v82 = v89 + 64;
                  }
                  *((void *)buffer + 21) = v89;
                  *((void *)buffer + 22) = v82;
                  v119.int location = *((void *)buffer + 19) + v89;
                  v119.CFIndex length = v82 - v89;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v119, buffer);
                  CFIndex v88 = *((void *)buffer + 21);
                }

                CFStringRef v84 = buffer[v81 - v88];
              }
            }

            if (v84 >> 10 == 55)
            {
              unint64_t v71 = (v71 << 10) + v84 - 56613888;
              uint64_t v59 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v71));
              int v72 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v71));
              if (!v59) {
                goto LABEL_200;
              }
LABEL_151:
              uint64_t v73 = (unsigned __int16)v71 >> 3;
              uint64_t v74 = 1 << (v71 & 7);
              if ((v74 & *(_BYTE *)(v59 + v73)) == 0)
              {
                uint64_t v18 = 0LL;
                LODWORD(v59) = 0;
                goto LABEL_201;
              }

              if ((a4 & 0x80) != 0 && v71 < 0x510)
              {
                uint64_t v18 = 1LL;
              }

              else if (v72 && (v74 & *(_BYTE *)(v72 + v73)) != 0)
              {
                unint64_t v75 = CFUniCharDecomposeCharacter(v71, a6 + 1, 63LL);
                uint64_t v18 = v75 + 1;
                if (v111 && !v75)
                {
                  uint64_t v18 = 1LL;
                  *CFIndex v111 = 1;
                }
              }

              else
              {
                a6[1] = v71;
                uint64_t v18 = 2LL;
              }

              uint64_t v76 = v59 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              LODWORD(v59) = 1;
              if (v76) {
                CFSetRef v77 = 1LL;
              }
              else {
                CFSetRef v77 = 2LL;
              }
              v17 += v77;
LABEL_126:
              if (v18 > 63)
              {
LABEL_127:
                if (v111) {
                  *CFIndex v111 = 1;
                }
LABEL_129:
                if (v18 >= 2)
                {
                  int v60 = a7;
                  uint64_t v61 = &a6[v18];
                  BOOL v62 = -4LL;
                  do
                  {
                    uint64_t v63 = v62;
                    uint64_t v64 = (int *)((char *)v61 + v62);
                    unint64_t v65 = *v64;
                    if (HIWORD(*v64))
                    {
                      uint64_t v66 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(*v64));
                      if (!v66) {
                        break;
                      }
                    }

                    else
                    {
                      uint64_t v66 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
                      if (!__CFStringFoldCharacterClusterAtIndex_graphemeBMP) {
                        break;
                      }
                    }

                    BOOL v62 = v63 - 4;
                  }

                  while (((*(unsigned __int8 *)(v66 + ((unsigned __int16)v65 >> 3)) >> (v65 & 7)) & 1) != 0);
                  if (-v63 >= 5) {
                    CFUniCharPrioritySort(v64, (unint64_t)-v63 >> 2);
                  }
                  a7 = v60;
                }

                goto LABEL_140;
              }

  uint64_t v98 = 0LL;
  UniChar v99 = 0LL;
  unint64_t v95 = v58;
  uint64_t v59 = a2 + a3 - (a3 != 0);
  if (v59 < 0 || (int v60 = v97, v97 <= v59))
  {
    uint64_t v61 = 0LL;
    BOOL v62 = -1;
  }

  else
  {
    if (v94)
    {
      uint64_t v61 = 0LL;
      BOOL v62 = v94[v96 + v59];
    }

    else if (v58)
    {
      uint64_t v61 = 0LL;
      BOOL v62 = v58[v96 + v59];
    }

    else
    {
      uint64_t v81 = v59 - 4;
      if (v81 + 64 < v97) {
        int v60 = v81 + 64;
      }
      uint64_t v98 = v81;
      UniChar v99 = v60;
      v103.int location = v96 + v81;
      v103.CFIndex length = v60 - v81;
      CFStringGetCharacters(theStringa, v103, &buffer);
      uint64_t v61 = v98;
      BOOL v62 = *(_WORD *)&v92[2 * (v59 - v98) - 2];
    }

    if (v62 == 10)
    {
      uint64_t v82 = v59 - 1;
      if (v59 && (BOOL v83 = v97, v97 >= v59))
      {
        if (v94)
        {
          CFStringRef v84 = v94[v96 + v82];
        }

        else if (v95)
        {
          CFStringRef v84 = v95[v96 + v82];
        }

        else
        {
          if (v99 < v59 || v61 >= v59)
          {
            uint64_t v87 = v59 - 5;
            if (v87 + 64 < v97) {
              BOOL v83 = v87 + 64;
            }
            uint64_t v98 = v87;
            UniChar v99 = v83;
            v105.int location = v96 + v87;
            v105.CFIndex length = v83 - v87;
            CFStringGetCharacters(theStringa, v105, &buffer);
            uint64_t v61 = v98;
          }

          CFStringRef v84 = *(_WORD *)&v92[2 * (v82 - v61) - 2];
        }
      }

      else
      {
        CFStringRef v84 = -1;
      }

      CFIndex v85 = v84 == 13;
      if (v84 == 13) {
        uint64_t v64 = v59 - 1;
      }
      else {
        uint64_t v64 = a2 + a3 - (a3 != 0);
      }
LABEL_184:
      char v68 = 1LL;
      if (v85) {
        char v68 = 2LL;
      }
      if (a6) {
        goto LABEL_135;
      }
      goto LABEL_136;
    }
  }

  if (length <= v59) {
    uint64_t v63 = a2 + a3 - (a3 != 0);
  }
  else {
    uint64_t v63 = length;
  }
  while (2)
  {
    uint64_t v64 = v59;
    if ((unsigned __int16)(v62 - 14) < 0x77u)
    {
LABEL_104:
      if (v63 == v59)
      {
        char v68 = 0LL;
        uint64_t v64 = length;
        if (a6) {
          goto LABEL_135;
        }
        goto LABEL_136;
      }

      ++v59;
      BOOL v62 = -1;
      if (v64 >= -1 && v97 > v59)
      {
        if (v94)
        {
          BOOL v62 = v94[v96 + 1 + v64];
        }

        else if (v95)
        {
          BOOL v62 = v95[v96 + 1 + v64];
        }

        else
        {
          uint64_t v59 = v64 + 1;
          if (v99 <= v64 + 1 || v61 > v59)
          {
            unint64_t v65 = v64 - 3;
            uint64_t v66 = v65 + 64;
            if (v65 + 64 >= v97) {
              uint64_t v66 = v97;
            }
            uint64_t v98 = v65;
            UniChar v99 = v66;
            v102.int location = v96 + v65;
            v102.CFIndex length = v66 - v65;
            CFStringGetCharacters(theStringa, v102, &buffer);
            uint64_t v61 = v98;
          }

          BOOL v62 = *(_WORD *)&v92[2 * v64 + -2 * v61];
        }
      }

      continue;
    }

    break;
  }

  if (v62 == 10) {
    goto LABEL_134;
  }
  if (v62 != 13)
  {
    if (v62 == 8233 || a7 && (v62 == 133 || v62 == 8232)) {
      goto LABEL_134;
    }
    goto LABEL_104;
  }

  if (v59 >= -1)
  {
    unint64_t v69 = v59 + 1;
    uint64_t v70 = v97;
    if (v97 > v59 + 1)
    {
      if (v94)
      {
        unint64_t v71 = &v94[v96 + v59];
        goto LABEL_133;
      }

      if (v95)
      {
        int v72 = v95[v96 + 1 + v59];
      }

      else
      {
        if (v99 <= v69 || v61 > v69)
        {
          CFIndex v88 = v59 - 3;
          if (v88 + 64 < v97) {
            uint64_t v70 = v88 + 64;
          }
          uint64_t v98 = v88;
          UniChar v99 = v70;
          v106.int location = v96 + v88;
          v106.CFIndex length = v70 - v88;
          CFStringGetCharacters(theStringa, v106, &buffer);
          uint64_t v61 = v98;
        }

        unint64_t v71 = (UniChar *)&v92[2 * v59 - 2 + -2 * v61];
LABEL_133:
        int v72 = v71[1];
      }

      CFIndex v85 = v72 == 10;
      goto LABEL_184;
    }
  }

          if (v86)
          {
            uint64_t v76 = (const void **)&a4[i];
            CFSetRef v77 = *v76;
            unint64_t v78 = CFDictionaryGetValue(Mutable, *v76);
            -[CFPrefsSearchListSource deferredNotifyCausedByLocalWriteOfChangesToKey:fromValue:toValue:]( self,  "deferredNotifyCausedByLocalWriteOfChangesToKey:fromValue:toValue:",  v77,  v78,  CFDictionaryGetValue((CFDictionaryRef)(&self->super.super.isa)[v95 / 8], *v76));
          }
        }
      }
    }
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
}

LABEL_90:
                    uint64_t v53 = (os_unfair_lock_s *)(v15 + 200);
                    os_unfair_lock_lock((os_unfair_lock_t)(v15 + 200));
                    __int16 v54 = *(const __CFDictionary **)(v15 + 208);
                    if (!v54 || !v107 && v33) {
                      goto LABEL_119;
                    }
                    uint64_t v91 = Copy;
                    uint64_t v94 = v29;
                    CFURLRef v55 = a5;
                    CFIndex Count = CFDictionaryGetCount(v54);
                    uint64_t v57 = (const void **)malloc(8 * Count);
                    int v58 = (const void **)malloc(8 * Count);
                    uint64_t v93 = v57;
                    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v15 + 208), v57, v58);
                    int64_t v92 = v58;
                    if (Count < 1)
                    {
                      uint64_t v59 = v33;
                      a5 = v55;
                      CFIndex v29 = v94;
                    }

                    else
                    {
                      uint64_t v100 = a2;
                      uint64_t v59 = 0LL;
                      do
                      {
                        LOBYTE(v9_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a9;
                        int v60 = a7;
                        uint64_t Resources = _CFBundleCopyFindResources(*v58, 0LL);
                        if (Resources)
                        {
                          BOOL v62 = (const __CFArray *)Resources;
                          if (!v107) {
                            goto LABEL_102;
                          }
                          if (!v59) {
                            uint64_t v59 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v33);
                          }
                          v117.CFIndex length = CFArrayGetCount(v62);
                          v117.int location = 0LL;
                          CFArrayAppendArray(v59, v62, v117);
                          CFRelease(v62);
                        }

                        ++v58;
                        --Count;
                        a7 = v60;
                      }

                      while (Count);
                      BOOL v62 = v33;
LABEL_102:
                      a5 = v55;
                      CFIndex v29 = v94;
                      if (v59)
                      {
                        CFStringRef Copy = v91;
                        if (v62) {
                          CFRelease(v62);
                        }
                        a7 = v60;
                        a2 = v100;
                        goto LABEL_118;
                      }

                      uint64_t v59 = v62;
                      a7 = v60;
                      a2 = v100;
                    }

                    CFStringRef Copy = v91;
LABEL_118:
                    free(v93);
                    free(v92);
                    uint64_t v33 = v59;
                    uint64_t v53 = (os_unfair_lock_s *)(v15 + 200);
LABEL_119:
                    os_unfair_lock_unlock(v53);
                    goto LABEL_120;
                  }

                  BOOL v39 = v29;
                }

                else
                {
                  BOOL v39 = a6;
                }

                uint64_t v42 = (__CFString *)CFRetain(v39);
                unint64_t v41 = v106;
                if (v15) {
                  goto LABEL_64;
                }
                goto LABEL_66;
              }
            }

            else
            {
              BOOL v36 = 0;
              if (v29) {
                goto LABEL_52;
              }
            }

            BOOL v37 = 0;
            goto LABEL_55;
          }

    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  0LL);
    __CFAllLocalMessagePorts = (uint64_t)Mutable;
    goto LABEL_91;
  }

  CFRetain(cf[0]);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  CFRelease((CFTypeRef)v30);
  return cf[0];
}

    int v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v21, v25 + a3, v59 - v25);
    return v49 != 0;
  }

  stat v47 = 1LL;
  BOOL v62 = 0LL;
  uint64_t v63 = &v62;
  if (v20) {
    stat v47 = 2LL;
  }
  if (v21) {
    stat v48 = v47 + 1;
  }
  else {
    stat v48 = v47;
  }
  uint64_t v64 = 0x2000000000LL;
  unint64_t v65 = 0;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = ____CFStorageEnumerateNodesInByteRangeWithBlock_block_invoke;
  block[3] = &unk_18999CC08;
  block[6] = v67;
  block[7] = a1;
  block[8] = v69;
  block[9] = a3;
  block[10] = v68;
  block[11] = v46;
  block[4] = a7;
  block[5] = &v62;
  dispatch_apply(v48, 0LL, block);
  int v49 = *((unsigned __int8 *)v63 + 24);
  _Block_object_dispose(&v62, 8);
  return v49 != 0;
}

LABEL_40:
    char v104 = 1;
    if (!a5) {
      goto LABEL_49;
    }
    goto LABEL_41;
  }

  int v101 = a4;
  uint64_t v18 = a5;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a6,  @"/");
  CFIndex v20 = CFArrayGetCount(ArrayBySeparatingStrings);
  if (v20 < 1)
  {
    CFRelease(ArrayBySeparatingStrings);
    a5 = v18;
    if (!a4) {
      goto LABEL_24;
    }
    goto LABEL_17;
  }

  CFIndex v21 = v20;
  uint64_t v96 = v15;
  unsigned int v97 = a2;
  CFIndex v22 = 0LL;
  int v23 = 0;
  do
  {
    unsigned int v24 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v22);
    CFTypeRef v25 = v24;
    if (v22 || CFStringCompare(v24, &stru_1899EF170, 0LL))
    {
      if (CFStringCompare(v25, @".", 0LL))
      {
        if (CFStringCompare(v25, @"..", 0LL)) {
          ++v23;
        }
        else {
          --v23;
        }
        if (v23 < 0)
        {
          CFRelease(ArrayBySeparatingStrings);
          int v26 = v107;
          goto LABEL_26;
        }
      }
    }

    ++v22;
  }

  while (v21 != v22);
  CFRelease(ArrayBySeparatingStrings);
  a4 = v101;
  a5 = v18;
  uint64_t v15 = v96;
  a2 = v97;
  int v26 = v107;
  if ((v23 & 0x80000000) == 0) {
    goto LABEL_16;
  }
LABEL_26:
  if (v26) {
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  }
  return 0LL;
}

  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (key) {
    CFRelease(key);
  }
  return 1LL;
}

        BOOL v6 = 0LL;
LABEL_41:
        if (v19 <= v13)
        {
          uint64_t v33 = v10[2];
          char v34 = v33 + ~v13;
          if (v34 >= 1)
          {
            unsigned int v35 = &v10[2 * v13 + 8];
            BOOL v36 = &v10[2 * v19 + 6];
            do
            {
              BOOL v37 = *(_OWORD *)v35;
              v35 += 2;
              *(_OWORD *)BOOL v36 = v37;
              v36 += 2;
              --v34;
            }

            while (v34);
            uint64_t v33 = v10[2];
          }

          int v38 = v33 + v19 - (v13 + 1);
          v10[2] = v38;
          __CFRunArraySetBlockCapacity(a1, v38);
        }

        goto LABEL_47;
      }

      int v26 = &v10[2 * v24];
      if (CFEqual((CFTypeRef)v26[7], v11))
      {
        v26[6] += a5;
        v10[1] += a5;
        goto LABEL_37;
      }
    }

    unsigned int v27 = v10[2];
    if (v13 + 1 < v27)
    {
      CFRange v28 = &v10[2 * v13 + 2];
      if (CFEqual((CFTypeRef)v28[7], v11))
      {
        v28[6] += a5;
        v10[1] += a5;
        if (v19 < 1) {
          goto LABEL_40;
        }
        goto LABEL_37;
      }

      unsigned int v27 = v10[2];
    }

    if (v19 < v27)
    {
      BOOL v39 = CFRetain(v6);
      BOOL v6 = 0LL;
      int v40 = &v10[2 * v19];
      v40[6] = a5;
      v40[7] = (uint64_t)v39;
      v10[1] += a5;
      ++v19;
    }

    goto LABEL_41;
  }

      pthread_mutex_lock(v33);
      pthread_mutex_lock(v34);
      if (v11 != v36) {
        free(v11);
      }
      return kdebug_trace();
    }
  }

  return result;
}

        CFIndex v22 = 0LL;
        int v23 = *v3;
        if (v5 == 0xC000000000000007LL) {
          int v23 = 0LL;
        }
        unsigned int v24 = v23 ^ (unint64_t)cf;
        do
        {
          if ((v24 & 7) == *(_BYTE *)(v8 + v22)) {
            break;
          }
          ++v22;
        }

        while (v22 != 7);
        CFTypeRef v25 = v22 | v24;
        int v26 = v22 & 7;
        unsigned int v27 = (v25 >> 55) + 8;
        if (v26 == 7) {
          LODWORD(v26) = v27;
        }
        uint64_t v15 = 22LL;
        switch((int)v26)
        {
          case 0:
            goto LABEL_55;
          case 1:
            goto LABEL_56;
          case 2:
            goto LABEL_54;
          case 3:
            goto LABEL_16;
          case 4:
          case 5:
            goto LABEL_55;
          case 6:
            uint64_t v15 = 42LL;
            goto LABEL_16;
          default:
            if ((_DWORD)v26 == 20)
            {
LABEL_55:
              uint64_t v15 = 1LL;
              goto LABEL_16;
            }

            if ((_DWORD)v26 == 22)
            {
LABEL_54:
              uint64_t v15 = 7LL;
              goto LABEL_16;
            }

        ++v31;
        ++v30;
        if (CStringPtrInternal + v30 >= (unint64_t)(CStringPtrInternal + Length))
        {
          uint64_t v31 = CStringPtrInternal + v30;
          goto LABEL_44;
        }
      }

      if (v24)
      {
        v24[v30] += 32;
        goto LABEL_40;
      }

      uint64_t v31 = CStringPtrInternal + v30;
LABEL_44:
      theLocale = v94;
      int v23 = v31 - CStringPtrInternal;
      int v17 = v96;
LABEL_45:
      if (Length > v23)
      {
        if (v16)
        {
          uint64_t v33 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * (Length - v23), 0LL);
          v114.int location = v23;
          v114.CFIndex length = Length - v23;
          CFStringGetCharacters(theString, v114, v33);
          char v34 = v33;
          int v17 = v96;
          MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v34,  Length - v23,  Length - v23,  0LL);
          if (MutableWithExternalCharactersNoCopy)
          {
            BOOL v36 = MutableWithExternalCharactersNoCopy;
            CFStringFold(MutableWithExternalCharactersNoCopy, theFlagsa, v96);
            v115.int location = v23;
            v115.CFIndex length = Length - v23;
            CFStringReplace(theString, v115, v36);
            CFRelease(v36);
            goto LABEL_155;
          }
        }

        if (v22 >= 1)
        {
          int v101 = v23 + 1;
          UniChar v102 = 0LL;
          __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v101, 1LL, v22 - 1, 1);
          BOOL v37 = atomic_load((unint64_t *)&theString->info);
          int v38 = v37 & 5;
          BOOL v39 = atomic_load((unint64_t *)&theString->info);
          int v40 = v39 & 0x60;
          if (v38 == 4)
          {
            unint64_t v41 = &theString->data;
            if (v40)
            {
              uint64_t v42 = *v41;
            }

            else
            {
              int v43 = atomic_load((unint64_t *)&theString->info);
              uint64_t v42 = (char *)&v41[(v43 & 5) != 4];
            }

            CFIndex Length = *v42;
          }

          else if ((v39 & 0x60) != 0)
          {
            CFIndex Length = theString->length;
          }

          else
          {
            CFIndex Length = (uint64_t)theString->data;
          }

          theStringa = theString;
          int v109 = 0LL;
          uint64_t v110 = Length;
          unint64_t v44 = CFStringGetCharactersPtr(theString);
          unint64_t v45 = 0LL;
          int v107 = v44;
          if (!v44) {
            unint64_t v45 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
          }
          v108 = v45;
          CFIndex v111 = 0LL;
          __int16 v112 = 0LL;
          char v46 = atomic_load((unint64_t *)&theString->info);
          stat v47 = &theString->data;
          if ((v46 & 0x60) != 0)
          {
            stat v48 = *v47;
          }

          else
          {
            int v49 = atomic_load((unint64_t *)&theString->info);
            stat v48 = (char *)&v47[(v49 & 5) != 4LL];
          }

          unint64_t v50 = v103;
          CFStringRef v51 = &v48[2 * v23];
          do
          {
            CFTypeID v52 = *v50++;
            *(_WORD *)CFStringRef v51 = v52;
            v51 += 2;
          }

          while (v50 < &v103[v22]);
          ++v23;
        }

        if (v23 < Length)
        {
          unint64_t v95 = &theString->data;
          do
          {
            if (v107)
            {
              uint64_t v53 = v107[v109 + v23];
            }

            else if (v108)
            {
              uint64_t v53 = *(char *)(v108 + v109 + v23);
            }

            else
            {
              __int16 v54 = v111;
              if (v112 <= v23 || v111 > v23)
              {
                uint64_t v56 = v23 - 4;
                if (v23 < 4) {
                  uint64_t v56 = 0LL;
                }
                uint64_t v57 = v56 + 64;
                if (v56 + 64 >= v110) {
                  uint64_t v57 = v110;
                }
                CFIndex v111 = v56;
                __int16 v112 = v57;
                v116.int location = v109 + v56;
                v116.CFIndex length = v57 - v56;
                CFStringGetCharacters(theStringa, v116, buffer);
                __int16 v54 = v111;
              }

              uint64_t v53 = buffer[v23 - v54];
            }

            int v58 = v53;
            uint64_t v100 = 0LL;
            if ((v13 & 0x80) != 0 || SpecialCaseHandlingLanguageIdentifierForLocale || v53 > 0x7Fu)
            {
              BOOL v62 = v23 + 1;
              if (v53 >> 10 == 54 && v62 < Length)
              {
                if (v107)
                {
                  uint64_t v64 = v107[v109 + v62];
                }

                else if (v108)
                {
                  uint64_t v64 = *(char *)(v108 + v109 + v62);
                }

                else
                {
                  if (v112 <= v62 || (unint64_t v65 = v111, v111 > v62))
                  {
                    uint64_t v66 = v23 - 3;
                    if (v23 < 3) {
                      uint64_t v66 = 0LL;
                    }
                    uint64_t v67 = v66 + 64;
                    if (v66 + 64 >= v110) {
                      uint64_t v67 = v110;
                    }
                    CFIndex v111 = v66;
                    __int16 v112 = v67;
                    v117.int location = v109 + v66;
                    v117.CFIndex length = v67 - v66;
                    CFStringGetCharacters(theStringa, v117, buffer);
                    unint64_t v65 = v111;
                  }

                  uint64_t v64 = buffer[v62 - v65];
                }

                char v68 = v64 >> 10 == 55;
                unint64_t v69 = (v58 << 10) + v64 - 56613888;
                if (v68) {
                  int v58 = v69;
                }
              }

              uint64_t v70 = __CFStringFoldCharacterClusterAtIndex( v58,  buffer,  v23,  theFlagsa,  SpecialCaseHandlingLanguageIdentifierForLocale,  v103,  &v100,  0LL);
              int v60 = v100;
              if (v100 >= 1)
              {
                uint64_t v61 = v70;
                uint64_t v59 = &v103[v70];
                if (v70 >= 1) {
                  goto LABEL_112;
                }
                uint64_t v73 = 0;
LABEL_119:
                if (v61 == v60)
                {
                  uint64_t v74 = atomic_load((unint64_t *)&theString->info);
                  if ((v74 & 0x10) == 0)
                  {
                    int v60 = v100;
                    goto LABEL_122;
                  }
                }

                else
                {
LABEL_122:
                  unint64_t v75 = v60 - v61;
                  if (v60 < v61)
                  {
                    unint64_t v75 = 0LL;
                    uint64_t v76 = v61 - v60;
                  }

                  else
                  {
                    int v60 = v61;
                    uint64_t v76 = 0LL;
                  }

                  int v101 = v60 + v23;
                  UniChar v102 = v75;
                  __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v101, 1LL, v76, 1);
                  CFSetRef v77 = atomic_load((unint64_t *)&theString->info);
                  unint64_t v78 = atomic_load((unint64_t *)&theString->info);
                  CFTypeID v79 = v78 & 0x60;
                  if ((v77 & 5) == 4LL)
                  {
                    if (v79)
                    {
                      CFIndex v80 = *v95;
                    }

                    else
                    {
                      uint64_t v81 = atomic_load((unint64_t *)&theString->info);
                      CFIndex v80 = (char *)&v95[(v81 & 5) != 4LL];
                    }

                    CFIndex Length = *v80;
                  }

                  else if (v79)
                  {
                    CFIndex Length = theString->length;
                  }

                  else
                  {
                    CFIndex Length = (uint64_t)*v95;
                  }

                  theStringa = theString;
                  int v109 = 0LL;
                  uint64_t v110 = Length;
                  uint64_t v82 = CFStringGetCharactersPtr(theString);
                  BOOL v83 = 0LL;
                  int v107 = v82;
                  if (!v82) {
                    BOOL v83 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, v97);
                  }
                  v108 = v83;
                  CFIndex v111 = 0LL;
                  __int16 v112 = 0LL;
                }

                CFStringRef v84 = atomic_load((unint64_t *)&theString->info);
                if ((v84 & 0x60) != 0)
                {
                  CFIndex v85 = *v95;
                  if (v73) {
                    goto LABEL_138;
                  }
                  goto LABEL_153;
                }

                uint64_t v93 = atomic_load((unint64_t *)&theString->info);
                CFIndex v85 = (char *)&v95[(v93 & 5) != 4LL];
                if (!v73)
                {
LABEL_153:
                  int v17 = v96;
                  goto LABEL_154;
                }

  uint64_t v164 = v12;
  CFIndex v22 = a3 - v11;
  int v23 = *a2;
  if (v23 - 4352 > 0xFE) {
    goto LABEL_71;
  }
  if (v22 < 2) {
    goto LABEL_72;
  }
  unsigned int v24 = a2[1] - 4449;
  if (v24 > 0x15) {
    goto LABEL_72;
  }
  if ((unint64_t)v22 < 3)
  {
    CFTypeRef v25 = 0;
  }

  else
  {
    CFTypeRef v25 = a2[2] - 4519;
  }

  uint64_t v31 = v25 + 28 * (v24 + 21 * (char)v23) - 21504;
  if ((unsigned __int16)v31 < 0xA1u)
  {
LABEL_72:
    BOOL v37 = (unsigned __int16 *)&KSX1001_from_uni;
    int v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
    while (1)
    {
      BOOL v39 = (0xF83E0F83E0F83E1LL * (v38 - v37)) >> 1;
      int v40 = &v37[33 * v39];
      unint64_t v41 = *v40;
      if (v41 <= v23)
      {
        if (v41 + 32 > v23)
        {
          char v46 = (uint64_t)&v37[33 * v39 + (int)(v23 - v41)];
          LODWORD(v43) = *(unsigned __int16 *)(v46 + 2);
          if (*(_WORD *)(v46 + 2))
          {
            stat v47 = 1LL;
            goto LABEL_97;
          }

          goto LABEL_78;
        }

        BOOL v37 = v40 + 33;
      }

      else
      {
        int v38 = v40 - 33;
      }

      if (v37 > v38) {
        goto LABEL_78;
      }
    }
  }

  uint64_t v32 = (unsigned __int16 *)&KSX1001_from_uni;
  uint64_t v33 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    char v34 = (0xF83E0F83E0F83E1LL * (v33 - v32)) >> 1;
    unsigned int v35 = &v32[33 * v34];
    BOOL v36 = *v35;
    uint64_t v33 = v35 - 33;
LABEL_70:
    if (v32 > v33) {
      goto LABEL_71;
    }
  }

  if (v36 + 32 <= (unsigned __int16)v31)
  {
    uint64_t v32 = v35 + 33;
    goto LABEL_70;
  }

  uint64_t v57 = (uint64_t)&v32[33 * v34 + (int)((unsigned __int16)v31 - v36)];
  LODWORD(v43) = *(unsigned __int16 *)(v57 + 2);
  if (!*(_WORD *)(v57 + 2))
  {
LABEL_71:
    if (v23 < 0xA1) {
      goto LABEL_78;
    }
    goto LABEL_72;
  }

  else {
    stat v47 = 3LL;
  }
  uint64_t v162 = v31;
LABEL_97:
  v166[0] = v47;
  if ((_DWORD)v43 == 65533)
  {
LABEL_78:
    LOBYTE(v42) = -1;
    LOBYTE(v43) = -3;
  }

  else
  {
    LODWORD(v42) = v43 >> 8;
    if (v43 >> 8 >= 0xA1
      && (_DWORD)v42 != 255
      && v43 >= 0xA1u
      && v43 != 255)
    {
      if (a5)
      {
        if (v10 + 2 > a5) {
          goto LABEL_452;
        }
        *(_WORD *)a4 = __rev16(v43);
        a4 += 2;
        stat v47 = v166[0];
      }

      CFIndex v12 = 0;
      unint64_t v16 = v47 + v11;
      v10 += 2LL;
      goto LABEL_106;
    }
  }

  if ((unsigned __int16)(v13 + 0x2000) <= 0xBBu)
  {
    CFErrorRef v30 = v10 + 2;
    if (a5)
    {
      if (v30 > a5) {
        goto LABEL_452;
      }
      if (v13 >= 0xE05E) {
        unint64_t v44 = -2;
      }
      else {
        unint64_t v44 = -55;
      }
      *a4 = v44;
      if (v165 >= 0xE05Eu) {
        unint64_t v45 = 67;
      }
      else {
        unint64_t v45 = -95;
      }
      a4[1] = v45 + v165;
      a4 += 2;
    }

  if (v8 >= __dst) {
    CFStringRef v19 = (v8 - __dst) >> 1;
  }
  else {
    CFStringRef v19 = 0LL;
  }
  return CFStringCreateWithCharactersNoCopy(alloc, (const UniChar *)__dst, v19, alloc);
}

    a3 = v14 + 1;
  }

  while (v14 + 1 < v11);
  CFErrorRef v30 = CFDataCreate(allocator, v9, v10);
  if (v9 != bytes) {
    free(v9);
  }
  return v30;
}

            CFRelease(v10);
            return v4;
          }

          goto LABEL_34;
        }
      }

      *a3 = -[CFPrefsConfigurationFileSource initWithConfigurationPropertyList:containingPreferences:]( objc_alloc(&OBJC_CLASS___CFPrefsConfigurationFileSource),  "initWithConfigurationPropertyList:containingPreferences:",  v13,  *(void *)(a1 + 8));
      goto LABEL_29;
    }

    CFRelease(v13);
LABEL_26:
    int v26 = 0;
    goto LABEL_35;
  }

  CFIndex v12 = __CFBasicHashTableSizes[v9];
  if (v12 >= 1)
  {
    for (CFIndex i = 0LL; v12 != i; ++i)
    {
      CFRange v14 = *(void *)(a1 + 40);
      uint64_t v15 = *(void *)(v14 + 8 * i);
      if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v15 == 2780474809)
        {
          uint64_t v15 = -1LL;
        }

        else
        {
          if (v15 == 2814029233) {
            uint64_t v15 = 0LL;
          }
          if (v15 < a3) {
            continue;
          }
        }

        unint64_t v16 = __CFADD__(v15, 1LL);
        int v17 = v15 + 1;
        if (v16) {
          int v17 = 2814029233LL;
        }
        if (v17 == -1) {
          int v17 = 2780474809LL;
        }
        *(void *)(v14 + 8 * i) = v17;
        ++*(_WORD *)(a1 + 16);
      }
    }
  }

  __CFBasicHashAddValue(a1, v18, a2, a3);
  return 1LL;
}

CFArrayRef CFBundleCopyResourceURLsOfType(CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle) {
    return _CFBundleCopyFindResources( (unint64_t *)bundle,  0LL,  (uint64_t)subDirName,  0LL,  resourceType,  subDirName,  0LL,  1,  0,  0LL);
  }
  else {
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  }
}

unint64_t *_CFBundleCopyResourceURLForLanguage( unint64_t *result, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  if (result) {
    return (unint64_t *)_CFBundleCopyFindResources(result, 0LL, (uint64_t)a3, a2, a3, a4, a5, 0, 1, 0LL);
  }
  return result;
}

CFURLRef CFBundleCopyResourceURLForLocalization( CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle) {
    return _CFBundleCopyFindResources( (unint64_t *)bundle,  0LL,  (uint64_t)resourceType,  resourceName,  resourceType,  subDirName,  localizationName,  0,  1,  0LL);
  }
  return bundle;
}

CFArrayRef CFBundleCopyResourceURLsOfTypeForLocalization( CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle) {
    return _CFBundleCopyFindResources( (unint64_t *)bundle,  0LL,  (uint64_t)subDirName,  0LL,  resourceType,  subDirName,  localizationName,  1,  1,  0LL);
  }
  else {
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  }
}

CFURLRef CFBundleCopyResourceURLInDirectory( CFURLRef bundleURL, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026LL)) {
    return 0LL;
  }
  size_t v8 = strlen((const char *)buffer);
  int v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v8, 1u);
  if (!v9) {
    int v9 = (const __CFURL *)CFRetain(bundleURL);
  }
  if (_CFBundleCouldBeBundle(v9))
  {
    uint64_t Resources = _CFBundleCopyFindResources(0LL, bundleURL, v10, resourceName, resourceType, subDirName, 0LL, 0, 0, 0LL);
    if (!v9) {
      return Resources;
    }
    goto LABEL_9;
  }

  uint64_t Resources = 0LL;
  if (v9) {
LABEL_9:
  }
    CFRelease(v9);
  return Resources;
}

CFArrayRef CFBundleCopyResourceURLsOfTypeInDirectory( CFURLRef bundleURL, CFStringRef resourceType, CFStringRef subDirName)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026LL)) {
    return 0LL;
  }
  size_t v6 = strlen((const char *)buffer);
  char v7 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v7) {
    char v7 = (const __CFURL *)CFRetain(bundleURL);
  }
  if (_CFBundleCouldBeBundle(v7))
  {
    uint64_t Resources = _CFBundleCopyFindResources(0LL, bundleURL, v8, 0LL, resourceType, subDirName, 0LL, 1, 0, 0LL);
    if (!v7) {
      return Resources;
    }
    goto LABEL_9;
  }

  uint64_t Resources = 0LL;
  if (v7) {
LABEL_9:
  }
    CFRelease(v7);
  return Resources;
}

uint64_t _CFBundleGetBundleVersionForURL(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (const __CFURL *)MEMORY[0x1895F8858](a1, a2);
  uint64_t v72 = *MEMORY[0x1895F89C0];
  CFIndex v3 = CFURLCopyAbsoluteURL(v2);
  int v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  __int16 v5 = CFURLGetString(v2);
  int HasSuffix = CFStringHasSuffix(v5, @".framework/");
  CFIndex Length = CFStringGetLength(@"Resources");
  CFIndex v8 = CFStringGetLength(@"Contents");
  CFIndex v9 = CFStringGetLength(@"Support Files");
  CFIndex v10 = CFStringGetLength(@"WrappedBundle");
  CFIndex v11 = CFStringGetLength(@"Wrapper");
  uint64_t v63 = 0LL;
  uint64_t v64 = &v63;
  uint64_t v65 = 0x2000000000LL;
  char v66 = 0;
  uint64_t v59 = 0LL;
  int v60 = &v59;
  uint64_t v61 = 0x2000000000LL;
  char v62 = 0;
  uint64_t v55 = 0LL;
  uint64_t v56 = &v55;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 0;
  uint64_t v51 = 0LL;
  CFTypeID v52 = &v51;
  uint64_t v53 = 0x2000000000LL;
  char v54 = 0;
  uint64_t v47 = 0LL;
  stat v48 = &v47;
  uint64_t v49 = 0x2000000000LL;
  char v50 = 0;
  uint64_t v43 = 0LL;
  unint64_t v44 = &v43;
  uint64_t v45 = 0x2000000000LL;
  char v46 = 0;
  v42[0] = MEMORY[0x1895F87A8];
  v42[1] = 0x40000000LL;
  CFTypeRef v42[2] = ___CFBundleGetBundleVersionForURL_block_invoke;
  v42[3] = &unk_189995FB8;
  v42[10] = Length;
  v42[11] = v8;
  v42[4] = &v63;
  v42[5] = &v59;
  v42[12] = v9;
  v42[13] = v11;
  v42[6] = &v55;
  v42[7] = &v47;
  v42[14] = v10;
  v42[8] = &v51;
  v42[9] = &v43;
  CFStringRef string = v4;
  _CFIterateDirectory(v4, 0, 0LL, (uint64_t)v42);
  if (*((_BYTE *)v44 + 24))
  {
    v71[0] = 0;
    uint64_t v12 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Wrapper", v2);
    unsigned int v13 = v12;
    if (v12)
    {
      BOOL v14 = _CFIsResourceAtURL(v12, v71);
      int v15 = v71[0];
      CFRelease(v13);
      if (v14)
      {
        if (v15)
        {
          *((_BYTE *)v48 + 24) = 1;
          unint64_t v16 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"WrappedBundle", v2);
          v71[0] = 0;
          if (_CFIsResourceAtURL(v16, v71) && v71[0]) {
            *((_BYTE *)v52 + 24) = 1;
          }
          CFRelease(v16);
          if (*((_BYTE *)v48 + 24) && *((_BYTE *)v52 + 24)) {
            *((_BYTE *)v44 + 24) = 0;
          }
        }
      }
    }
  }

  if (!*((_BYTE *)v48 + 24) || !*((_BYTE *)v52 + 24))
  {
    if (HasSuffix)
    {
      if (*((_BYTE *)v64 + 24))
      {
LABEL_24:
        unsigned __int8 v23 = 0;
        goto LABEL_44;
      }

      if (*((_BYTE *)v60 + 24))
      {
LABEL_29:
        unsigned __int8 v23 = 2;
        goto LABEL_44;
      }
    }

    else
    {
      if (*((_BYTE *)v60 + 24)) {
        goto LABEL_29;
      }
      if (*((_BYTE *)v64 + 24)) {
        goto LABEL_24;
      }
    }

    if (*((_BYTE *)v56 + 24)) {
      unsigned __int8 v23 = 1;
    }
    else {
      unsigned __int8 v23 = 3;
    }
    goto LABEL_44;
  }

  int v17 = CFURLCreateCopyAppendingPathComponent( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v3,  @"WrappedBundle",  1u);
  uint64_t v18 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
  CFRelease(v17);
  uint64_t v38 = 0LL;
  BOOL v39 = &v38;
  uint64_t v40 = 0x2000000000LL;
  char v41 = 0;
  v37[0] = MEMORY[0x1895F87A8];
  v37[1] = 0x40000000LL;
  v37[2] = ___CFBundleGetBundleVersionForURL_block_invoke_2;
  v37[3] = &unk_189995FE0;
  v37[4] = &v38;
  v37[5] = v8;
  _CFIterateDirectory(v18, 0, 0LL, (uint64_t)v37);
  if (CFStringGetFileSystemRepresentation(v18, v71, 1024LL) && CFStringGetFileSystemRepresentation(v4, buffer, 1024LL))
  {
    ssize_t v19 = readlink(v71, __s, 0x3FFuLL);
    if (v19 >= 2 && __s[0] != 47)
    {
      __s[v19] = 0;
      CFIndex v20 = strrchr(__s, 46);
      CFIndex v21 = strrchr(buffer, 46);
      if (v21 && v20)
      {
        if (strcmp(v20 + 1, v21 + 1))
        {
          CFIndex v22 = (os_log_s *)_CFBundleResourceLogger();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            _CFBundleGetBundleVersionForURL_cold_3();
          }
LABEL_48:
          int v26 = 0;
LABEL_50:
          int v30 = open(v71, 0);
          int v31 = open(buffer, 0);
          int v32 = v31;
          if (v30 < 1 || v31 < 1)
          {
            BOOL v33 = 0;
            BOOL v34 = 0;
            if (v30 < 1) {
              goto LABEL_60;
            }
          }

          else
          {
            BOOL v33 = fcntl(v30, 50, __s1) != -1
               && fcntl(v32, 50, __s2) != -1
               && strncmp(__s1, __s2, 0x400uLL)
               && strnstr(__s1, __s2, 0x400uLL) == __s1;
          }

          close(v30);
          BOOL v34 = v33;
LABEL_60:
          if (v32 >= 1) {
            close(v32);
          }
          if (v34)
          {
            char v25 = 1;
          }

          else
          {
            unsigned int v35 = (os_log_s *)_CFBundleResourceLogger();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              _CFBundleGetBundleVersionForURL_cold_2();
            }
            char v25 = 0;
          }

          goto LABEL_36;
        }
      }

      else if ((unint64_t)v21 | (unint64_t)v20)
      {
        CFIndex v29 = (os_log_s *)_CFBundleResourceLogger();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          _CFBundleGetBundleVersionForURL_cold_4();
        }
        goto LABEL_48;
      }

      int v26 = 1;
      goto LABEL_50;
    }

    unsigned int v24 = (os_log_s *)_CFBundleResourceLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      _CFBundleGetBundleVersionForURL_cold_1();
    }
  }

  char v25 = 0;
  int v26 = 0;
LABEL_36:
  CFRelease(v18);
  char v27 = v25 ^ 1;
  if (!v26) {
    char v27 = 1;
  }
  if ((v27 & 1) != 0)
  {
    unsigned __int8 v23 = 3;
  }

  else if (*((_BYTE *)v39 + 24))
  {
    unsigned __int8 v23 = 12;
  }

  else
  {
    unsigned __int8 v23 = 13;
  }

  _Block_object_dispose(&v38, 8);
LABEL_44:
  CFRelease(v3);
  CFRelease(string);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  _Block_object_dispose(&v55, 8);
  _Block_object_dispose(&v59, 8);
  _Block_object_dispose(&v63, 8);
  return v23;
}

void sub_180A70390( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, char a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
}

uint64_t _CFBundleGetSupportedPlatforms()
{
  return 0LL;
}

CFStringRef _CFBundleGetCurrentPlatform()
{
  return @"iPhoneOS";
}

CFStringRef _CFBundleGetPlatformExecutablesSubdirectoryName()
{
  return @"MacOS";
}

CFArrayRef CFBundleCopyExecutableArchitecturesForURL(CFURLRef url)
{
  unint64_t v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  if (!v2) {
    return _CFBundleCopyArchitecturesForExecutable(url, v3);
  }
  int v4 = v2;
  __int16 v5 = CFBundleCopyExecutableArchitectures(v2);
  CFRelease(v4);
  return v5;
}

__CFArray *_copyResourceURLsFromBundle( uint64_t a1, const __CFURL *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, char a10, uint64_t a11)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  char v73 = 0;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  CFTypeRef cf = 0LL;
  CFStringRef theString = a4;
  MutableCFStringRef Copy = CFStringCreateMutableCopy(0LL, 0LL, a4);
  ssize_t v19 = (__CFString *)MutableCopy;
  CFIndex v20 = a2;
  uint64_t v67 = a3;
  uint64_t v68 = a1;
  if (a10 == 1)
  {
    CFIndex Length = CFStringGetLength(MutableCopy);
    _CFAppendPathComponent2(v19, @"Non-localized Resources");
    Table = _copyQueryTable(a1, a2, a3, v19, a5);
    unsigned __int8 v23 = Table;
    unsigned int v24 = a5;
    if (a11) {
      _CFBundleFindResourcesWithPredicate(Mutable, Table, a11, &v73);
    }
    else {
      CFTypeRef cf = CFDictionaryGetValue(Table, a6);
    }
    v75.CFIndex length = CFStringGetLength(v19) - Length;
    v75.int location = Length;
    CFStringDelete(v19, v75);
    if (cf || v73) {
      goto LABEL_12;
    }
    a1 = v68;
    if (v23) {
      CFRelease(v23);
    }
  }

  char v25 = _copyQueryTable(a1, v20, a3, v19, a5);
  unsigned __int8 v23 = v25;
  unsigned int v24 = a5;
  if (a11) {
    _CFBundleFindResourcesWithPredicate(Mutable, v25, a11, &v73);
  }
  else {
    CFTypeRef cf = CFDictionaryGetValue(v25, a6);
  }
LABEL_12:
  if (v24) {
    BOOL v26 = CFStringGetLength(v24) > 0;
  }
  else {
    BOOL v26 = 0;
  }
  char v66 = v20;
  if (a7) {
    BOOL v27 = CFStringGetLength(a7) > 0;
  }
  else {
    BOOL v27 = 0;
  }
  if (!a9 || !cf)
  {
    if (cf)
    {
      CFTypeID v29 = CFGetTypeID(cf);
      if (v29 == CFArrayGetTypeID())
      {
        v76.CFIndex length = CFArrayGetCount((CFArrayRef)cf);
        v76.int location = 0LL;
        CFArrayAppendArray(Mutable, (CFArrayRef)cf, v76);
      }

      else
      {
        CFArrayAppendValue(Mutable, cf);
      }
    }

    goto LABEL_52;
  }

  CFTypeID v28 = CFGetTypeID(cf);
  if (v28 == CFStringGetTypeID()) {
    CFTypeRef cf = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &cf, 1LL, &kCFTypeArrayCallBacks);
  }
  else {
    CFRetain(cf);
  }
  if (a8)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count <= 0)
    {
      CFRelease(cf);
LABEL_52:
      BOOL v36 = v67;
      goto LABEL_53;
    }
  }

  else
  {
    CFIndex Count = 1LL;
  }

  uint64_t v64 = v19;
  for (CFIndex i = 0LL; Count != i; ++i)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
    CFIndex v33 = CFStringGetLength(ValueAtIndex);
    CFIndex v34 = v33;
    if (v26)
    {
      v77.int location = 0LL;
      v77.CFIndex length = v33;
      if (CFStringFindWithOptions(ValueAtIndex, v24, v77, 0LL, &result)) {
        BOOL v35 = result.location == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (v35) {
        goto LABEL_46;
      }
    }

    else
    {
      if (!v33) {
        goto LABEL_46;
      }
      v78.int location = 0LL;
      v78.CFIndex length = v33;
      if (!CFStringFindWithOptions(ValueAtIndex, @".lproj", v78, 0LL, &result) || result.location + 7 >= v34) {
        goto LABEL_46;
      }
    }

    if (!a7) {
      break;
    }
    if (CFStringGetLength(a7) < 1) {
      break;
    }
    v79.int location = 0LL;
    v79.CFIndex length = v34;
    if (!CFStringFindWithOptions(ValueAtIndex, a7, v79, 8uLL, &result)) {
      break;
    }
    v80.int location = result.length + result.location;
    v80.CFIndex length = 1LL;
    if (!CFStringFindWithOptions(ValueAtIndex, @".", v80, 0LL, &result)) {
      break;
    }
    BOOL v27 = 0;
LABEL_46:
    CFArrayAppendValue(Mutable, ValueAtIndex);
  }

  CFRelease(cf);
  BOOL v36 = v67;
  if (!a8 && CFArrayGetCount(Mutable)) {
    BOOL v27 = 0;
  }
  ssize_t v19 = v64;
LABEL_53:
  CFTypeRef cf = 0LL;
  CFRelease(v23);
  if (v27)
  {
    CFMutableStringRef v37 = CFStringCreateMutableCopy(0LL, 0LL, a7);
    _CFAppendPathExtension2(v37, @"lproj");
    if (v24 && CFStringGetLength(v24) >= 1) {
      _CFAppendPathComponent2(v37, v24);
    }
    uint64_t v38 = _copyQueryTable(v68, v66, v36, v19, v37);
    CFRelease(v37);
    Value = CFDictionaryGetValue(v38, a6);
    CFTypeRef cf = Value;
    if (Value)
    {
      CFTypeID v40 = CFGetTypeID(Value);
      CFTypeID TypeID = CFStringGetTypeID();
      uint64_t v42 = (const __CFArray *)cf;
      if (v40 == TypeID)
      {
        CFArrayAppendValue(Mutable, cf);
      }

      else
      {
        v81.CFIndex length = CFArrayGetCount((CFArrayRef)cf);
        v81.int location = 0LL;
        CFArrayAppendArray(Mutable, v42, v81);
      }
    }

    CFRelease(v38);
  }

  if (CFArrayGetCount(Mutable) < 1)
  {
    if (a8) {
      uint64_t v45 = (__CFArray *)CFRetain(Mutable);
    }
    else {
      uint64_t v45 = 0LL;
    }
  }

  else
  {
    int v43 = _CFGetSlash();
    if (v68)
    {
      CFMutableStringRef v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, *(CFStringRef *)(v68 + 192));
    }

    else
    {
      char v46 = CFURLCopyAbsoluteURL(v66);
      uint64_t v47 = CFURLCopyFileSystemPath(v46, kCFURLPOSIXPathStyle);
      CFMutableStringRef v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v47);
      CFRelease(v46);
      CFRelease(v47);
    }

    if (theString && CFStringGetLength(theString)) {
      _CFAppendPathComponent2(v44, theString);
    }
    _CFAppendTrailingPathSlash2(v44);
    if (a8)
    {
      stat v48 = v19;
      CFIndex v49 = CFArrayGetCount(Mutable);
      char v50 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
      uint64_t v45 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
      if (v49 >= 1)
      {
        for (CFIndex j = 0LL; j != v49; ++j)
        {
          CFTypeID v52 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, j);
          uint64_t v53 = _CFGetSlashStr();
          CFURLRef RelativeURLFromBaseAndPath = _CFBundleCreateRelativeURLFromBaseAndPath(v52, v50, v43, v53);
          CFArrayAppendValue(v45, RelativeURLFromBaseAndPath);
          CFRelease(RelativeURLFromBaseAndPath);
        }
      }

      CFRelease(v50);
      ssize_t v19 = v48;
    }

    else
    {
      int HasPrefix = CFStringHasPrefix(a6, @"_CFBT_");
      int v56 = CFStringHasPrefix(a6, @"_CFBAF_") | HasPrefix;
      uint64_t v57 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, 0LL);
      if (v56)
      {
        char v58 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
        uint64_t v59 = _CFGetSlashStr();
        uint64_t v45 = _CFBundleCreateRelativeURLFromBaseAndPath(v57, v58, v43, v59);
        CFRelease(v58);
      }

      else
      {
        CFStringAppend(v44, v57);
        CFIndex v60 = CFStringGetLength(v57);
        if (CFStringGetCharacterAtIndex(v57, v60 - 1) == v43)
        {
          uint64_t v61 = v44;
          Boolean v62 = 1;
        }

        else
        {
          uint64_t v61 = v44;
          Boolean v62 = 0;
        }

        uint64_t v45 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v61,  kCFURLPOSIXPathStyle,  v62);
      }
    }

    CFRelease(v44);
  }

  if (v19) {
    CFRelease(v19);
  }
  CFRelease(Mutable);
  return v45;
}

CFBundleRef _CFBundleAddResourceURL(uint64_t a1, const __CFURL *a2)
{
  CFBundleRef result = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  if (result)
  {
    __int16 v5 = result;
    if (result == (CFBundleRef)a1)
    {
      __break(1u);
    }

    else
    {
      os_unfair_lock_lock_with_options();
      CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 208);
      if (!Mutable)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        *(void *)(a1 + 208) = Mutable;
      }

      CFDictionarySetValue(Mutable, a2, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 200));
      CFRelease(v5);
      _CFBundleFlushStringSourceCache(a1);
      return (CFBundleRef)1;
    }
  }

  return result;
}

uint64_t _CFBundleRemoveResourceURL(uint64_t a1, const void *a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 200);
  os_unfair_lock_lock_with_options();
  __int16 v5 = *(__CFDictionary **)(a1 + 208);
  if (v5)
  {
    CFDictionaryRemoveValue(v5, a2);
    uint64_t v6 = 1LL;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  os_unfair_lock_unlock(v4);
  _CFBundleFlushStringSourceCache(a1);
  return v6;
}

CFDictionaryRef _copyQueryTable( uint64_t a1, CFURLRef relativeURL, const __CFArray *cf, const __CFString *a4, const __CFString *a5)
{
  char v7 = cf;
  if (a1 && !cf)
  {
    char v7 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    goto LABEL_7;
  }

  if (cf) {
    CFRetain(cf);
  }
  if (a1)
  {
LABEL_7:
    if (a5)
    {
      MutableCFStringRef Copy = CFStringCreateMutableCopy(0LL, 0LL, a4);
      _CFAppendPathComponent2(MutableCopy, a5);
    }

    else
    {
      MutableCFStringRef Copy = (__CFString *)CFRetain(a4);
    }

    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 176));
    CFIndex v11 = *(const __CFDictionary **)(a1 + 184);
    if (v11)
    {
      Value = (__CFDictionary *)CFDictionaryGetValue(v11, MutableCopy);
      if (Value)
      {
        QueryTableAtPath = Value;
        CFRetain(Value);
LABEL_15:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 176));
        goto LABEL_17;
      }
    }

    else
    {
      *(void *)(a1 + 184) = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    }

    QueryTableAtPath = _createQueryTableAtPath(*(const __CFString **)(a1 + 192), v7, a4, a5, *(_BYTE *)(a1 + 55));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 184), MutableCopy, QueryTableAtPath);
    goto LABEL_15;
  }

  BOOL v14 = CFURLCopyAbsoluteURL(relativeURL);
  MutableCFStringRef Copy = (__CFString *)CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
  CFRelease(v14);
  QueryTableAtPath = _createQueryTableAtPath(MutableCopy, v7, a4, a5, 0);
LABEL_17:
  CFRelease(MutableCopy);
  if (v7) {
    CFRelease(v7);
  }
  if (QueryTableAtPath) {
    return QueryTableAtPath;
  }
  else {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
}

void _CFBundleFindResourcesWithPredicate(__CFArray *a1, CFDictionaryRef theDict, uint64_t a3, _BYTE *a4)
{
  CFIndex Count = CFDictionaryGetCount(theDict);
  if (Count)
  {
    uint64_t v9 = Count;
    size_t v10 = 8 * Count;
    CFIndex v11 = (const void **)malloc(8 * Count);
    uint64_t v12 = (const void **)malloc(v10);
    unsigned int v13 = v12;
    if (v11 && v12)
    {
      CFDictionaryGetKeysAndValues(theDict, v11, v12);
      uint64_t v14 = v9 - 1;
      if (v9 >= 1)
      {
        int v15 = v11;
        unint64_t v16 = v13;
        do
        {
          if ((*(unsigned int (**)(uint64_t, const void *, _BYTE *))(a3 + 16))(a3, *v15, a4))
          {
            CFTypeID v17 = CFGetTypeID(*v16);
            CFTypeID TypeID = CFStringGetTypeID();
            ssize_t v19 = (const __CFArray *)*v16;
            if (v17 == TypeID)
            {
              CFArrayAppendValue(a1, *v16);
            }

            else
            {
              v21.CFIndex length = CFArrayGetCount((CFArrayRef)*v16);
              v21.int location = 0LL;
              CFArrayAppendArray(a1, v19, v21);
            }
          }

          if (*a4) {
            BOOL v20 = 1;
          }
          else {
            BOOL v20 = v14 == 0;
          }
          --v14;
          ++v16;
          ++v15;
        }

        while (!v20);
      }

      free(v11);
LABEL_19:
      free(v13);
      return;
    }

    if (v11) {
      free(v11);
    }
    if (v13) {
      goto LABEL_19;
    }
  }

CFURLRef _CFBundleCreateRelativeURLFromBaseAndPath( const __CFString *a1, const __CFURL *a2, int a3, const __CFString *a4)
{
  char v7 = a1;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  v18.CFIndex length = CFStringGetLength(a1) - 1;
  v18.int location = 0LL;
  int v8 = CFStringFindWithOptions(v7, a4, v18, 4uLL, &result);
  if (v8)
  {
    v19.CFIndex length = result.location;
    v19.int location = 0LL;
    uint64_t v9 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v19);
    a2 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, v9, 1u);
    CFIndex v10 = result.location + 1;
    CFIndex Length = CFStringGetLength(v7);
    v20.CFIndex length = Length + ~result.location;
    v20.int location = v10;
    char v7 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v20);
    CFRelease(v9);
  }

  CFIndex v12 = CFStringGetLength(v7);
  Boolean v13 = CFStringGetCharacterAtIndex(v7, v12 - 1) == a3;
  CFURLRef v14 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v7,  kCFURLPOSIXPathStyle,  v13,  a2);
  if (v8)
  {
    CFRelease(a2);
    CFRelease(v7);
  }

  return v14;
}

__CFDictionary *_createQueryTableAtPath( const __CFString *a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, char a5)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  CFIndex v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  CFMutableDictionaryRef v30 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, a1);
  CFIndex v12 = MutableCopy;
  if (a3) {
    _CFAppendPathComponent2(MutableCopy, a3);
  }
  CFIndex Length = CFStringGetLength(v12);
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  _CFBundleReadDirectory( v12,  (const __CFArray *)a4,  a5,  (uint64_t)theArray,  0,  (uint64_t)Mutable,  (uint64_t)v30,  0LL,  0,  0LL);
  v32.CFIndex length = CFStringGetLength(v12) - Length;
  v32.int location = Length;
  CFStringDelete(v12, v32);
  CFIndex Count = CFArrayGetCount(theArray);
  if (!a2)
  {
    CFMutableDictionaryRef cf = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFIndex v14 = 0LL;
    goto LABEL_11;
  }

  CFIndex v14 = CFArrayGetCount(a2);
  CFMutableDictionaryRef cf = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (v14 < 1)
  {
LABEL_11:
    BOOL v18 = 0;
    goto LABEL_12;
  }

  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, 0LL);
  CFIndex v16 = CFStringGetLength(ValueAtIndex);
  uint64_t v17 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16 + 5, ValueAtIndex);
  CFStringAppend(v17, @".lproj");
  _CFAppendPathComponent2(v12, ValueAtIndex);
  _CFAppendPathExtension2(v12, @"lproj");
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  _CFBundleReadDirectory( v12,  (const __CFArray *)a4,  a5,  (uint64_t)theArray,  0,  (uint64_t)Mutable,  (uint64_t)v30,  (uint64_t)cf,  1,  v17);
  CFRelease(v17);
  v33.CFIndex length = CFStringGetLength(v12) - Length;
  v33.int location = Length;
  CFStringDelete(v12, v33);
  BOOL v18 = Count < CFArrayGetCount(theArray);
LABEL_12:
  CFRange v19 = Mutable;
  _CFAppendPathComponent2(v12, @"Base");
  _CFAppendPathExtension2(v12, @"lproj");
  if (a4) {
    _CFAppendPathComponent2(v12, a4);
  }
  char v20 = 1;
  _CFBundleReadDirectory( v12,  (const __CFArray *)a4,  a5,  (uint64_t)theArray,  v18,  (uint64_t)v19,  (uint64_t)v30,  (uint64_t)cf,  1,  @"Base.lproj");
  v34.CFIndex length = CFStringGetLength(v12) - Length;
  v34.int location = Length;
  CFStringDelete(v12, v34);
  if (!v18) {
    char v20 = Count < CFArrayGetCount(theArray);
  }
  if (v14 > 1 && CFArrayGetCount(a2) > 1)
  {
    CFIndex v21 = 1LL;
    do
    {
      CFIndex v22 = (const __CFString *)CFArrayGetValueAtIndex(a2, v21);
      CFIndex v23 = CFStringGetLength(v22);
      unsigned int v24 = v10;
      char v25 = CFStringCreateMutableCopy(v10, v23 + 5, v22);
      CFStringAppend(v25, @".lproj");
      _CFAppendPathComponent2(v12, v22);
      _CFAppendPathExtension2(v12, @"lproj");
      if (a4) {
        _CFAppendPathComponent2(v12, a4);
      }
      _CFBundleReadDirectory( v12,  (const __CFArray *)a4,  a5,  (uint64_t)theArray,  v20,  (uint64_t)v19,  (uint64_t)v30,  (uint64_t)cf,  0,  v25);
      CFRelease(v25);
      v35.CFIndex length = CFStringGetLength(v12) - Length;
      v35.int location = Length;
      CFStringDelete(v12, v35);
      if (v20) {
        char v20 = 1;
      }
      else {
        char v20 = Count < CFArrayGetCount(theArray);
      }
      CFIndex v10 = v24;
      ++v21;
    }

    while (v21 < CFArrayGetCount(a2));
  }

  CFRelease(cf);
  CFRelease(v12);
  if (CFArrayGetCount(theArray) >= 1) {
    CFDictionarySetValue(v19, @"_CFBAF_", theArray);
  }
  CFRelease(theArray);
  CFRelease(v30);
  return v19;
}

void _CFBundleReadDirectory( const __CFString *a1, const __CFArray *a2, char a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, void *a10)
{
  CFArrayRef v15 = a2;
  CFIndex v16 = a10;
  values[2] = *(void **)MEMORY[0x1895F89C0];
  BOOL v26 = a2;
  uint64_t ProductNameSuffix = _CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  if (v16) {
    BOOL v19 = v15 == 0LL;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19)
  {
    if (v16)
    {
      CFArrayRef v15 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&a10,  1LL,  &kCFTypeArrayCallBacks);
      CFIndex v16 = a10;
    }

    else
    {
      if (v15) {
        CFArrayRef v15 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&v26,  1LL,  &kCFTypeArrayCallBacks);
      }
      CFIndex v16 = 0LL;
    }
  }

  else
  {
    values[0] = v16;
    values[1] = v15;
    CFArrayRef v15 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)values,  2LL,  &kCFTypeArrayCallBacks);
  }

  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 0x40000000LL;
  v22[2] = ___CFBundleReadDirectory_block_invoke;
  v22[3] = &__block_descriptor_tmp_51;
  char v23 = a3;
  v22[4] = ProductNameSuffix;
  v22[5] = PlatformNameSuffix;
  char v24 = a5;
  v22[6] = a4;
  v22[7] = a6;
  v22[8] = a7;
  v22[9] = a8;
  char v25 = a9;
  unsigned int v22[10] = v16;
  _CFIterateDirectory(a1, 1, v15, (uint64_t)v22);
  if (v15) {
    CFRelease(v15);
  }
}

LABEL_38:
    uint64_t v9 = *(__CFDictionary **)(a1 + 56);
    CFIndex v10 = key;
LABEL_39:
    CFDictionarySetValue(v9, v10, a3);
  }

    CFRange v34 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
    CFRange v35 = (unsigned __int16 *)&__CFToGB2312CharMap;
    while (1)
    {
      BOOL v36 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v34 - v35)) >> 1;
      CFMutableStringRef v37 = &v35[17 * v36];
      uint64_t v38 = *v37;
      CFRange v34 = v37 - 17;
LABEL_44:
      if (v35 > v34) {
        goto LABEL_51;
      }
    }

    if (v38 + 16 <= v17)
    {
      CFRange v35 = v37 + 17;
      goto LABEL_44;
    }

    BOOL v39 = v35[17 * v36 + 1 + (int)(v17 - v38)];
    if (v39) {
      CFTypeID v40 = v39 == 65533;
    }
    else {
      CFTypeID v40 = 1;
    }
    if (!v40)
    {
      uint64_t v65 = v10 + 2;
      if ((v14 & 1) == 0) {
        uint64_t v65 = v10;
      }
      CFIndex v10 = v65 + 2;
      if (!a5)
      {
        CFIndex v14 = 0LL;
        goto LABEL_110;
      }

      if (v10 > a5)
      {
        CFRange v75 = -2LL;
        if ((v14 & 1) != 0) {
          CFRange v75 = -4LL;
        }
        uint64_t v68 = v10 + v75;
        v10 += v75 + 2;
LABEL_116:
        if (v10 <= a5)
        {
          *(_WORD *)a4 = 32126;
        }

        else
        {
          if ((unint64_t)v15 > v7)
          {
            for (--v15; ; --v15)
            {
              unint64_t v69 = *v15;
              if (((v69 - 774) > 0x32 || ((1LL << (v69 - 6)) & 0x4000000000005LL) == 0)
                && (v69 - 12441) >= 2)
              {
                else {
                  uint64_t v72 = 0;
                }
                if (!v72) {
                  break;
                }
              }

              else if ((unint64_t)v15 <= v7)
              {
                break;
              }
            }
          }

          if ((unint64_t)v15 <= v7 || *(v15 - 1) > 0x7Fu)
          {
            *((_WORD *)a4 - 1) = 32126;
            CFIndex v10 = v68;
          }

          else
          {
            CFIndex v10 = v68 - 4;
          }
        }

        goto LABEL_138;
      }

      if ((v14 & 1) != 0)
      {
        char v66 = 0LL;
        uint64_t v67 = 126;
        do
        {
          a4[v66] = v67;
          uint64_t v67 = v16[++v66];
        }

        while (v66 != 2);
        a4 += 2;
      }

      CFIndex v14 = 0LL;
      *a4 = HIBYTE(v39) & 0x7F;
      a4[1] = v39 & 0x7F;
      a4 += 2;
LABEL_110:
      if ((unint64_t)++v15 >= v11)
      {
LABEL_114:
        if ((v14 & 1) != 0) {
          goto LABEL_138;
        }
        uint64_t v68 = v10;
        v10 += 2LL;
        if (!a5) {
          goto LABEL_138;
        }
        goto LABEL_116;
      }

      continue;
    }

    break;
  }

    if ((v12 & 1) != 0 && (v13 == v25 || v101[v25] != 47))
    {
LABEL_113:
      *a3 = v12 & 0xFFFFFEFF;
      *a4 = 0LL;
      a4[1] = v20;
      *a5 = 1;
      goto LABEL_215;
    }

    BOOL v26 = v12 | 0x4000;
    if (v13 - v25 >= 2 && v101[v25] == 47 && v101[v25 + 1] == 47)
    {
      BOOL v27 = v25 + 2;
      if (v25 + 2 >= v13) {
        goto LABEL_48;
      }
      CFTypeID v28 = v25 + 2;
      while ((v101[v28] | 0x10) != 0x3F)
      {
        if (v13 == ++v28)
        {
          CFTypeID v28 = v13;
          break;
        }
      }

      if (v28 == v27)
      {
LABEL_48:
        CFTypeID v28 = v25 + 2;
      }

      else
      {
        if (v27 >= v28)
        {
LABEL_236:
          uint64_t v87 = v14;
        }

        else
        {
          CFTypeRef v86 = -1LL;
          while (v101[v27 + 1 + v86] != 64)
          {
            ++v86;
            if (v25 - v28 + 2 + v86 == -1) {
              goto LABEL_236;
            }
          }

          BOOL v26 = v12 | 0x4002;
          uint64_t v87 = v14 + 1;
          *(void *)&uint64_t v106 = v25 + 2;
          if (v27 < v25 + v86 + 3)
          {
            uint64_t v91 = 0LL;
            int64_t v92 = &v101[v27];
            uint64_t v93 = v86;
            while (v92[v91] != 58)
            {
              ++v91;
              if (--v93 == -1) {
                goto LABEL_284;
              }
            }

            BOOL v26 = v12 | 0x4006;
            uint64_t v87 = v14 + 2;
            *(void *)&int v107 = v25 + v91 + 3;
            *((void *)&v107 + 1) = v93;
            *((void *)&v106 + 1) = v91;
          }

  if (a1 != 12288) {
    return 0LL;
  }
  return v4;
}

  if ((a1 & 8) != 0 || !v12) {
    goto LABEL_159;
  }
  if ((a1 & 0x10) == 0) {
    goto LABEL_41;
  }
  if (((v15 - 774) > 0x32 || ((1LL << (v15 - 6)) & 0x4000000000005LL) == 0)
    && (v15 - 12441) >= 2)
  {
    char v46 = a6;
    if (v13[438](v15, 1025LL, &__CFToBig5CharMap))
    {
      LODWORD(v15) = *a2;
      a6 = v46;
      Boolean v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
      CFIndex v14 = 0xA692u;
      goto LABEL_48;
    }

    a6 = v46;
    switch((int)v15)
    {
      case 63612:
        CFRange v32 = *(a2 - 1);
        Boolean v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
        CFIndex v14 = 42642LL;
        switch(v32)
        {
          case 8254:
            CFRange v33 = -61;
            goto LABEL_142;
          case 65343:
            CFRange v33 = -59;
            goto LABEL_142;
          case 65099:
            CFRange v33 = -53;
            goto LABEL_142;
        }

        goto LABEL_159;
      case 63613:
        char v41 = *(a2 - 1);
        Boolean v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
        CFIndex v14 = 42642LL;
        if (v41 <= 0xFF0D)
        {
          switch(v41)
          {
            case 0x3001u:
              CFRange v33 = 78;
              break;
            case 0xFF01u:
              CFRange v33 = 84;
              break;
            case 0xFF0Cu:
              CFRange v33 = 77;
              break;
            default:
              goto LABEL_159;
          }
        }

        else if (*(a2 - 1) > 0xFF1Au)
        {
          if (v41 == 65307)
          {
            CFRange v33 = 81;
          }

          else
          {
            if (v41 != 65311) {
              goto LABEL_159;
            }
            CFRange v33 = 83;
          }
        }

        else if (v41 == 65294)
        {
          CFRange v33 = 79;
        }

        else
        {
          if (v41 != 65306) {
            goto LABEL_159;
          }
          CFRange v33 = 82;
        }

void _CFBundleAddValueForType( void *key, __CFDictionary *a2, CFDictionaryRef theDict, const void *a4, __CFDictionary *a5, int a6)
{
  Value = (void *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    if (!a5) {
      goto LABEL_7;
    }
  }

  else
  {
    CFStringRef v13 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@.%@",  @"_CFBT_",  key);
    Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    CFDictionarySetValue(a2, v13, Value);
    CFDictionarySetValue(theDict, key, Value);
    CFRelease(Value);
    CFRelease(v13);
    if (!a5)
    {
LABEL_7:
      CFArrayAppendValue((CFMutableArrayRef)Value, a4);
      return;
    }
  }

  if (a6)
  {
    CFDictionarySetValue(a5, key, key);
    goto LABEL_7;
  }

  if (!CFDictionaryGetValue(a5, key)) {
    goto LABEL_7;
  }
}

void OUTLINED_FUNCTION_0_1( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

uint64_t __CFCharacterSetIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

BOOL _CFCharacterSetIsValidRange(unint64_t a1, uint64_t a2)
{
  return a1 >> 16 <= 0x10 && a2 < 1114113 && a1 + a2 < 0x110001;
}

void __CFCharacterSetDeallocate(uint64_t a1)
{
  unint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  int32x4_t v3 = (unint64_t *)(a1 + 8);
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) != 0
    || (char v5 = atomic_load(v3), (v5 & 1) != 0)
    || (char v6 = atomic_load((unint64_t *)(a1 + 8)), (v6 & 8) != 0)
    || CFCharacterSetGetPredefined(*(CFCharacterSetPredefinedSet *)(a1 + 24)) != (CFCharacterSetRef)a1)
  {
    char v7 = atomic_load(v3);
    if ((v7 & 0x70) == 0x20LL && (int v8 = *(void **)(a1 + 24)) != 0LL
      || (char v9 = atomic_load((unint64_t *)(a1 + 8)), (v9 & 0x70) == 0x30LL) && (v8 = *(void **)(a1 + 24)) != 0LL
      || (char v10 = atomic_load((unint64_t *)(a1 + 8)), (v10 & 0x70) == 0x40LL) && (v8 = *(void **)(a1 + 24)) != 0LL)
    {
      CFAllocatorDeallocate(v2, v8);
    }

    if (*(void *)(a1 + 40))
    {
      for (uint64_t i = 0LL; i != 16; ++i)
      {
        uint64_t v12 = *(void *)(a1 + 40);
        if (((*(_DWORD *)(v12 + 8) >> i) & 2) != 0) {
          CFRelease(*(CFTypeRef *)(*(void *)v12 + 8 * i));
        }
      }

      CFStringRef v13 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v13, **(void ***)(a1 + 40));
      CFIndex v14 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v14, *(void **)(a1 + 40));
      *(void *)(a1 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
    }
  }

void __CFCharacterSetEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v146 = *MEMORY[0x1895F89C0];
  char v6 = atomic_load((unint64_t *)(v2 + 8));
  char v7 = atomic_load((unint64_t *)(v3 + 8));
  char v8 = atomic_load((unint64_t *)(v2 + 8));
  if ((v8 & 4) != 0)
  {
    char v9 = atomic_load((unint64_t *)(v3 + 8));
    if ((v9 & 4) != 0 && *(void *)(v2 + 16) != *(void *)(v3 + 16)) {
      return;
    }
  }

  char v10 = v7 ^ v6;
  uint64_t v11 = *(void *)(v2 + 40);
  if (!v11 || !*(_DWORD *)(v11 + 8) && !*(_BYTE *)(v11 + 13))
  {
    unsigned int v12 = atomic_load((unint64_t *)(v2 + 8));
    switch((v12 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v2 + 32)) {
          goto LABEL_19;
        }
        break;
      case 3u:
      case 4u:
        if (*(void *)(v2 + 24)) {
          goto LABEL_19;
        }
        break;
      default:
        goto LABEL_19;
    }

    uint64_t v13 = *(void *)(v3 + 40);
    if (!v13 || !*(_DWORD *)(v13 + 8) && !*(_BYTE *)(v13 + 13))
    {
      unsigned int v14 = atomic_load((unint64_t *)(v3 + 8));
      switch((v14 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v3 + 32)) {
            goto LABEL_19;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(v3 + 24)) {
            goto LABEL_19;
          }
          break;
        default:
          goto LABEL_19;
      }

      if ((v10 & 8) != 0) {
        return;
      }
    }
  }

LABEL_109:
    uint64_t v67 = *(void *)(v2 + 40);
    if (v67 && (*(_DWORD *)(v67 + 8) || *(_BYTE *)(v67 + 13)))
    {
LABEL_189:
      int v69 = 0;
    }

    else
    {
      unsigned int v68 = atomic_load((unint64_t *)(v2 + 8));
      switch((v68 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v2 + 32)) {
            goto LABEL_189;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(v2 + 24)) {
            goto LABEL_189;
          }
          break;
        default:
          goto LABEL_189;
      }

      int v69 = 1;
    }

    if (v3 == v2) {
      int v69 = 1;
    }
    if (v69) {
      uint64_t v5 = v3;
    }
    char v104 = atomic_load((unint64_t *)(v5 + 8));
    if ((v104 & 0x70) == 0) {
      return;
    }
    char v105 = atomic_load((unint64_t *)(v5 + 8));
    if ((v105 & 0x70) == 0x10LL) {
      return;
    }
    uint64_t v106 = *(void *)(v5 + 40);
    if (v106)
    {
      int v107 = *(unsigned __int8 *)(v106 + 13);
      int v108 = *(_DWORD *)(v106 + 8);
      if (v107)
      {
        if (v108 != 131070) {
          return;
        }
      }

      else if (v108)
      {
        return;
      }
    }

    char v123 = atomic_load((unint64_t *)(v5 + 8));
    if ((v123 & 0x70) == 0x30LL)
    {
      v124 = *(int8x16_t **)(v5 + 24);
      if (!v124)
      {
LABEL_243:
        uint64_t v125 = *(void *)(v5 + 40);
        if (v125 && *(_BYTE *)(v125 + 13))
        {
          uint64_t v126 = 1LL;
          while (1)
          {
            char v127 = atomic_load((unint64_t *)(v5 + 8));
            if ((v127 & 0x70) == 0x30LL)
            {
              uint64_t v128 = *(void *)(v5 + 40);
              if (v128)
              {
                if (*(_BYTE *)(v128 + 13)) {
                  uint64_t v129 = 0LL;
                }
                else {
                  uint64_t v129 = -1LL;
                }
              }

              else
              {
                uint64_t v129 = -1LL;
              }
            }

            else
            {
              if (!(_BYTE)v126)
              {
                __break(1u);
                return;
              }

              uint64_t v130 = *(void *)(v5 + 40);
              if (v130
                && ((*(_DWORD *)(v130 + 8) >> v126) & 1) != 0
                && *(unsigned __int8 *)(v130 + 12) >= v126)
              {
                uint64_t v131 = *(void *)(*(void *)v130 + 8LL * (v126 - 1));
              }

              else
              {
                uint64_t v131 = 0LL;
              }

              __CFCSetGetBitmap(v131, v145);
              if (v145 != (int8x16_t *)-1LL)
              {
                for (uint64_t i = 0LL; i != 2048; ++i)
                {
                  __int32 v133 = v145[0].i32[i];
                  if (v133 != -1) {
                    return;
                  }
                }
              }
            }

            if (++v126 == 16) {
              return;
            }
          }
        }

        return;
      }
    }

    else
    {
      v124 = v145;
      __CFCSetGetBitmap(v5, v145);
    }

    for (uint64_t j = 0LL; j != 2048; ++j)
    {
      if (v124->i32[j]) {
        return;
      }
    }

    goto LABEL_243;
  }

            __cficu_unum_setSymbol(v19, v20, buffer, v18, &v41);
            goto LABEL_110;
          }

          unint64_t v37 = CFStringGetLength((CFStringRef)value);
          if (v37 >= 768) {
            unsigned int v14 = 768LL;
          }
          else {
            unsigned int v14 = v37;
          }
          v60.int location = 0LL;
          v60.CFIndex length = v14;
          CFStringGetCharacters((CFStringRef)value, v60, buffer);
          unsigned __int8 v15 = *((void *)formatter + 2);
          unsigned __int8 v16 = 3;
        }

                Symbol = __cficu_unum_getTextAttribute(v33, v34, (const UniChar *)valuePtr, 768LL, &v36);
                goto LABEL_92;
              }

              CFRange result = (CFTypeRef)*((void *)formatter + 8);
              if (!result) {
                return result;
              }
            }

            return CFRetain(result);
          }

          uint64_t v21 = *((void *)formatter + 2);
          unsigned int v22 = 11;
        }
      }
    }
  }

  CFRelease(Mutable);
LABEL_112:
  BOOL v46 = __CFPropertyListCreateError(3840LL, @"Unable to convert string to correct encoding");
  CFRange result = 0LL;
  *(void *)(a1 + 24) = v46;
  return result;
}

  CFMutableSetRef v103 = (_DWORD)v8 != 0;
  unsigned int v31 = v14 - v8;
  if (!v20) {
    goto LABEL_141;
  }
  unint64_t v48 = &ptr->u8[v8];
  unint64_t v37 = ptr;
LABEL_111:
  if (!__CFTaggedStringClass) {
    goto LABEL_133;
  }
  if ((uint64_t)v31 <= 7)
  {
    unsigned int v49 = v37;
    uint64_t v106 = 0LL;
    unsigned int v50 = v31;
    unsigned int v51 = v48;
    __memmove_chk();
    if ((v106 & 0x8080808080808080LL) != 0)
    {
      unint64_t v37 = v49;
      unint64_t v48 = v51;
      unsigned int v31 = v50;
      goto LABEL_133;
    }

    int v56 = v50;
    uint64_t Instance = (8 * v50) | (v106 << 7) | 0x8000000000000002LL;
    uint64_t v57 = *MEMORY[0x189616658] ^ Instance;
    unint64_t v37 = v49;
    if ((~v57 & 0xC000000000000007LL) != 0) {
      uint64_t Instance = v57 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v57 & 7));
    }
    unint64_t v48 = v51;
    unsigned int v31 = v56;
    if (!Instance) {
      goto LABEL_133;
    }
LABEL_130:
    ptr = 0LL;
    if (!v105 || v18 == (const __CFAllocator *)&__kCFAllocatorNull) {
      goto LABEL_227;
    }
    CFAllocatorDeallocate(v18, v37);
    goto LABEL_158;
  }

  if (v31 > 0xB) {
    goto LABEL_133;
  }
  if (v31 < 0xA)
  {
    CFTypeID v52 = 0LL;
    unsigned int v53 = v31;
    unsigned int v54 = v48;
    while (1)
    {
      uint64_t v55 = charToSixBitLookup_0[*v54];
      if (v55 > 0x3F) {
        goto LABEL_133;
      }
      CFTypeID v52 = v55 | (v52 << 6);
      ++v54;
      if (!--v53) {
        goto LABEL_128;
      }
    }
  }

  CFTypeID v52 = 0LL;
  __int32 v58 = v31;
  unsigned int v59 = v48;
  do
  {
    unint64_t v60 = charToSixBitLookup_0[*v59];
    if (v60 > 0x1F) {
      goto LABEL_133;
    }
    CFTypeID v52 = v60 | (32 * v52);
    ++v59;
    --v58;
  }

  while (v58);
LABEL_128:
  uint64_t Instance = (8 * v31) | (v52 << 7) | 0x8000000000000002LL;
  int v61 = Instance ^ *MEMORY[0x189616658];
  if ((~v61 & 0xC000000000000007LL) == 0) {
    goto LABEL_130;
  }
  uint64_t Instance = v61 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v61 & 7));
  if (Instance) {
    goto LABEL_130;
  }
LABEL_133:
  if ((v12 & 0x20) != 0)
  {
    ptr = v37;
LABEL_141:
    char v62 = v105;
    uint64_t v63 = v104;
    if (!v105) {
      goto LABEL_138;
    }
    goto LABEL_142;
  }

  char v62 = v105;
  if (__CFStringCreateImmutableFunnel3_onceToken != -1)
  {
    char v98 = v31;
    uint64_t v99 = v48;
    char v100 = v37;
    dispatch_once(&__CFStringCreateImmutableFunnel3_onceToken, &__block_literal_global_18);
    unint64_t v48 = v99;
    unsigned int v31 = v98;
    unint64_t v37 = v100;
  }

  uint64_t v63 = v104;
  if (!__CFStringCreateImmutableFunnel3_sDisableStringROM)
  {
    unsigned int v68 = v37;
    int v69 = __CFSearchStringROM(v48, v31);
    if (v69)
    {
      int v70 = (const void *)v69;
      if (v105 && v18 != (const __CFAllocator *)&__kCFAllocatorNull) {
        CFAllocatorDeallocate(v18, v68);
      }
      uint64_t Instance = (unint64_t)CFRetain(v70);
LABEL_158:
      ptr = 0LL;
      goto LABEL_227;
    }

    ptr = v68;
    if (!v105) {
      goto LABEL_138;
    }
LABEL_142:
    uint64_t v65 = v18 == (const __CFAllocator *)&__kCFAllocatorNull || v18 == (const __CFAllocator *)v16;
    char v66 = 16LL;
    if (v65) {
      char v66 = 8LL;
    }
    if ((_DWORD)v8) {
      uint64_t v67 = v66;
    }
    else {
      uint64_t v67 = v66 + 8;
    }
    goto LABEL_169;
  }

  ptr = v37;
  if (v105) {
    goto LABEL_142;
  }
LABEL_138:
  if ((_DWORD)v8)
  {
    LODWORD(v8) = 1;
    int v64 = v14;
  }

  else if ((_DWORD)a4 == 256 || (uint64_t)v14 > 255)
  {
    LODWORD(v8) = 0;
    int v64 = v14 + 8;
  }

  else
  {
    int v64 = v14 + 1;
    LODWORD(v8) = 1;
  }

  if (v63) {
    int v71 = 0;
  }
  else {
    int v71 = (_DWORD)a4 == 256;
  }
  uint64_t v63 = !v71;
  if (v71) {
    uint64_t v67 = v64;
  }
  else {
    uint64_t v67 = v64 + 1;
  }
LABEL_169:
  uint64_t Instance = _CFRuntimeCreateInstance((const __CFAllocator *)v16, 7uLL, v67, 0LL, a5, a6, a7, a8);
  if (!Instance)
  {
    if (v62 && v18 != (const __CFAllocator *)&__kCFAllocatorNull)
    {
      CFAllocatorDeallocate(v18, ptr);
      uint64_t Instance = 0LL;
    }

    goto LABEL_227;
  }

  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  uint64_t v72 = 96LL;
  if (v18 == (const __CFAllocator *)&__kCFAllocatorNull) {
    uint64_t v72 = 64LL;
  }
  unsigned int v73 = 32LL;
  if (v18 != (const __CFAllocator *)v16) {
    unsigned int v73 = v72;
  }
  unint64_t v74 = (unint64_t *)(Instance + 8);
  unsigned __int16 v75 = atomic_load((unint64_t *)(Instance + 8));
  if (!v62) {
    unsigned int v73 = 0LL;
  }
  do
  {
    int v76 = __ldaxr(v74);
    if (v76 == v75)
    {
      if (!__stlxr(v75 & 0xFFFFFFFFFFFFFF9FLL | v73, v74))
      {
        uint64_t v77 = 1;
        goto LABEL_183;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v77 = 0;
LABEL_183:
    unsigned __int16 v75 = v76;
  }

  while (!v77);
  uint64_t v78 = atomic_load(v74);
  do
  {
    uint64_t v79 = __ldaxr(v74);
    if (v79 == v78)
    {
      if (!__stlxr(v78 & 0xFFFFFFFFFFFFFFEFLL | (16LL * ((_DWORD)a4 == 256)), v74))
      {
        char v80 = 1;
        goto LABEL_190;
      }
    }

    else
    {
      __clrex();
    }

    char v80 = 0;
LABEL_190:
    uint64_t v78 = v79;
  }

  while (!v80);
  unsigned __int16 v81 = atomic_load(v74);
  do
  {
    BOOL v82 = __ldaxr(v74);
    if (v82 == v81)
    {
      if (!__stlxr(v81 & 0xFFFFFFFFFFFFFFF7LL | (8LL * v63), v74))
      {
        char v83 = 1;
        goto LABEL_197;
      }
    }

    else
    {
      __clrex();
    }

    char v83 = 0;
LABEL_197:
    unsigned __int16 v81 = v82;
  }

  while (!v83);
  BOOL v84 = atomic_load(v74);
  do
  {
    unint64_t v85 = __ldaxr(v74);
    if (v85 == v84)
    {
      if (!__stlxr(v84 & 0xFFFFFFFFFFFFFFFBLL | (4LL * v8), v74))
      {
        uint64_t v86 = 1;
        goto LABEL_204;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v86 = 0;
LABEL_204:
    BOOL v84 = v85;
  }

  while (!v86);
  if ((_DWORD)v8)
  {
    if (v62) {
      goto LABEL_207;
    }
LABEL_217:
    char v92 = atomic_load((unint64_t *)(Instance + 8));
    uint64_t v93 = (_BYTE **)(Instance + 16);
    if ((v92 & 0x60) != 0)
    {
      uint64_t v94 = *v93;
    }

    else
    {
      uint64_t v95 = atomic_load(v74);
      uint64_t v94 = &v93[(v95 & 5) != 4LL];
    }

    if ((_DWORD)v8) {
      unsigned int v96 = v103;
    }
    else {
      unsigned int v96 = 1;
    }
    if ((v96 & 1) == 0) {
      *v94++ = v14;
    }
    memmove(v94, ptr, v14);
    if (v63) {
      v94[v14] = 0;
    }
  }

  else
  {
    char v90 = atomic_load((unint64_t *)(Instance + 8));
    uint64_t v65 = (v90 & 0x60) == 0LL;
    uint64_t v91 = 24LL;
    if (v65) {
      uint64_t v91 = 16LL;
    }
    *(void *)(Instance + v91) = v31 >> ((_DWORD)a4 == 256);
    if (!v62) {
      goto LABEL_217;
    }
LABEL_207:
    *(void *)(Instance + 16) = ptr;
    unint64_t v87 = atomic_load((unint64_t *)(Instance + 8));
    if ((~v87 & 0x60) == 0)
    {
      CFRetain(v18);
      uint64_t v88 = atomic_load((unint64_t *)(Instance + 8));
      uint64_t v65 = (v88 & 5) == 4LL;
      uint64_t v89 = 32LL;
      if (v65) {
        uint64_t v89 = 24LL;
      }
      *(void *)(Instance + v89) = v18;
    }
  }

LABEL_29:
  uint64_t v21 = *(void *)(v3 + 40);
  if (!v21 || !*(_DWORD *)(v21 + 8) && !*(_BYTE *)(v21 + 13))
  {
    unsigned int v22 = atomic_load((unint64_t *)(v3 + 8));
    switch((v22 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(void *)(v3 + 32)) {
          break;
        }
        goto LABEL_109;
      case 3u:
      case 4u:
        if (!*(void *)(v3 + 24)) {
          goto LABEL_109;
        }
        break;
      default:
        break;
    }
  }

  char v23 = atomic_load((unint64_t *)(v2 + 8));
  if ((v23 & 0x70) != 0)
  {
    char v24 = atomic_load((unint64_t *)(v3 + 8));
    if ((v24 & 0x70) != 0)
    {
      char v25 = atomic_load((unint64_t *)(v2 + 8));
      if ((v25 & 0x70) == 0x10LL || (char v26 = atomic_load((unint64_t *)(v3 + 8)), (v26 & 0x70) == 0x10LL))
      {
        char v27 = atomic_load((unint64_t *)(v2 + 8));
        if ((v27 & 0x70) == 0x10LL) {
          uint64_t v28 = v2;
        }
        else {
          uint64_t v28 = v3;
        }
        if (v28 == v2) {
          uint64_t v5 = v3;
        }
        int v29 = *(_DWORD *)(v28 + 24);
        int v30 = v29 + *(_DWORD *)(v28 + 32);
        unsigned int v31 = atomic_load((unint64_t *)(v28 + 8));
        char v32 = atomic_load((unint64_t *)(v5 + 8));
        if ((v32 & 0x70) == 0x30LL)
        {
          CFRange v33 = *(int8x16_t **)(v5 + 24);
        }

        else
        {
          CFRange v33 = v145;
          __CFCSetGetBitmap(v5, v145);
        }

        int v70 = (v31 >> 3) & 1;
        int v71 = v30 - 1;
        if ((v29 & 0xFF0000) != 0)
        {
          if (v70) {
            uint64_t v72 = -1LL;
          }
          else {
            uint64_t v72 = 0LL;
          }
          unsigned int v73 = (unsigned __int16)v29;
          unint64_t v74 = BYTE2(v29);
        }

        else
        {
          if ((v71 & 0xFF0000) != 0) {
            unsigned __int16 v75 = -1;
          }
          else {
            unsigned __int16 v75 = v30 - 1;
          }
          unsigned int v73 = 0;
          unint64_t v74 = 1LL;
        }

        int v76 = (unsigned __int16)(v30 - 1);
        uint64_t v77 = *(void *)(v5 + 40);
        if (v77) {
          LODWORD(v77) = *(unsigned __int8 *)(v77 + 13) != 0;
        }
        uint64_t v78 = 0LL;
        uint64_t v79 = ((v31 & 8) == 0) ^ v77;
        uint64_t v139 = v79 ^ 1;
        unsigned int v138 = v73;
        if (v73) {
          char v80 = 1;
        }
        else {
          char v80 = ((v31 & 8) == 0) ^ v77;
        }
        if (v74 == BYTE2(v71)) {
          unsigned __int16 v81 = v30 - 1;
        }
        else {
          unsigned __int16 v81 = -1;
        }
        BOOL v82 = v76 == 0xFFFF;
        if (v76 == 0xFFFF) {
          char v83 = ((v31 & 8) == 0) ^ v77;
        }
        else {
          char v83 = 1;
        }
        char v143 = v83;
        BOOL v84 = !v82 && v74 == BYTE2(v71);
        char v141 = v80 | v84;
        unint64_t v85 = v74 - 1;
        uint64_t v86 = BYTE2(v71) - 1LL;
        unsigned int v137 = v81;
        while (1)
        {
          unint64_t v87 = v78 + 1;
          uint64_t v88 = *(void *)(v5 + 40);
          if (v88
            && ((*(_DWORD *)(v88 + 8) >> v87) & 1) != 0
            && *(unsigned __int8 *)(v88 + 12) >= v87
            && (uint64_t v89 = *(void *)(*(void *)v88 + 8 * v78)) != 0)
          {
            char v90 = atomic_load((unint64_t *)(v89 + 8));
            if ((v90 & 0x70) == 0x30LL)
            {
              uint64_t v91 = *(int8x16_t **)(v89 + 24);
            }

            else
            {
              uint64_t v91 = v145;
              __CFCSetGetBitmap(v89, v145);
            }

            if (v87 < v74 || v87 > BYTE2(v71))
            {
              uint64_t v93 = (uint64_t)v91;
              uint64_t v94 = v139 << 63 >> 63;
LABEL_173:
              goto LABEL_157;
            }

            if (v87 > v74 && v87 < BYTE2(v71))
            {
              uint64_t v93 = (uint64_t)v91;
              uint64_t v94 = v79 << 63 >> 63;
              goto LABEL_173;
            }

            if (v85 == v78)
            {
              uint64_t v95 = (uint64_t)v91;
              unsigned int v97 = v137;
              unsigned int v96 = v138;
            }

            else
            {
              if (v86 != v78) {
                goto LABEL_157;
              }
              unsigned int v97 = (unsigned __int16)v71;
              uint64_t v95 = (uint64_t)v91;
              unsigned int v96 = 0;
            }
          }

          else if (v87 < v74 || v87 > BYTE2(v71))
          {
            if ((v79 & 1) == 0) {
              return;
            }
          }

          else if (v87 <= v74 || v87 >= BYTE2(v71))
          {
            if (v85 == v78)
            {
              if ((v141 & 1) != 0) {
                return;
              }
            }

            else
            {
              char v92 = v143;
              if (v86 != v78) {
                char v92 = 0;
              }
              if ((v92 & 1) != 0) {
                return;
              }
            }
          }

          else if ((v79 & 1) != 0)
          {
            return;
          }

  *a2 = v11 + 1;
  a1[v11] = 46;
  memmove(&a1[v11 + 1], a4, 2 * a5);
  *a2 += a5;
  return 1LL;
}

    if (*(void *)valuePtr || (unsigned int v12 = (const void *)*((void *)formatter + 9)) == 0LL)
    {
      if (v11 == 1.0) {
        char v23 = *(void *)valuePtr;
      }
      else {
        char v23 = (uint64_t)(v11 * (double)*(uint64_t *)valuePtr);
      }
      _CFBigNumInitWithInt64((uint64_t)v49, v23);
LABEL_34:
      _CFBigNumToCString((uint64_t)v49, 0, 1, __s, 0x300uLL);
      BOOL v45 = 0;
      char v24 = strlen(__s);
      char v25 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v24, (uint64_t)v51, 768LL, 0LL, &v45);
      uint64_t v18 = v25;
      if (v45 != 15 && v25 < 769)
      {
        unsigned int v20 = 0LL;
LABEL_39:
        unsigned int v19 = v45;
        goto LABEL_40;
      }

      char v26 = v25 + 2LL;
      unsigned int v20 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * v26, 0LL);
      BOOL v45 = 0;
      char v27 = strlen(__s);
      unsigned int v22 = __cficu_unum_formatDecimal(*((void *)formatter + 2), __s, v27, (uint64_t)(v20 + 1), v26, 0LL, &v45);
LABEL_38:
      uint64_t v18 = v22;
      goto LABEL_39;
    }

    return (CFStringRef)CFRetain(v12);
  }

  if (((1LL << numberType) & 0x810) != 0) {
    goto LABEL_29;
  }
  if (((1LL << numberType) & 0x1020) == 0)
  {
    if (((1LL << numberType) & 0x2040) != 0)
    {
      if (*(double *)valuePtr != 0.0 || (unsigned int v12 = (const void *)*((void *)formatter + 9)) == 0LL)
      {
        uint64_t v13 = *(double *)valuePtr * v11;
        unsigned int v14 = *((void *)formatter + 2);
        goto LABEL_24;
      }

      return (CFStringRef)CFRetain(v12);
    }

    goto LABEL_28;
  }

  unsigned __int8 v15 = *(float *)valuePtr;
  if (*(float *)valuePtr == 0.0)
  {
    unsigned int v12 = (const void *)*((void *)formatter + 9);
    if (v12) {
      return (CFStringRef)CFRetain(v12);
    }
  }

  if (v11 != 1.0)
  {
    unsigned __int8 v16 = v11 * v15;
    unsigned __int8 v15 = v16;
  }

  unsigned int v14 = *((void *)formatter + 2);
  uint64_t v13 = v15;
LABEL_24:
  char v17 = __cficu_unum_formatDouble(v14, (uint64_t)v51, 768LL, 0LL, &v45, v13);
  uint64_t v18 = v17;
  unsigned int v19 = v45;
  if (v45 == 15 || v17 >= 769)
  {
    uint64_t v21 = v17 + 2LL;
    unsigned int v20 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * v21, 0LL);
    BOOL v45 = 0;
    unsigned int v22 = __cficu_unum_formatDouble(*((void *)formatter + 2), (uint64_t)(v20 + 1), v21, 0LL, &v45, v13);
    goto LABEL_38;
  }

  unsigned int v20 = 0LL;
LABEL_40:
  if (v19 > 0)
  {
    uint64_t v28 = 0LL;
    if (!v20) {
      return v28;
    }
    goto LABEL_54;
  }

  if (v20) {
    int v29 = v20;
  }
  else {
    int v29 = (UniChar *)v50;
  }
  if (*((_BYTE *)formatter + 82)
    && (CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    *int v29 = 8207;
    ++v18;
  }

  else
  {
    if (v20) {
      unsigned int v31 = v20;
    }
    else {
      unsigned int v31 = (UniChar *)v50;
    }
    int v29 = v31 + 1;
  }

  uint64_t v28 = CFStringCreateWithCharacters(v7, v29, v18);
  if (v20) {
LABEL_54:
  }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20);
  return v28;
}

  if ((v5 & 1) != 0) {
    return 0LL;
  }
  unsigned int v22 = kCFNumberFloat64Type;
  if (!CFNumberFormatterGetValueFromString(formatter, string, rangep, kCFNumberFloat64Type, valuePtr)) {
    return 0LL;
  }
  return CFNumberCreate(v9, v22, valuePtr);
}

  CFDateGetAbsoluteTime(a2);
  CFDateGetAbsoluteTime(a3);
  bzero(chars, 0x7D0uLL);
  LODWORD(v46[0]) = 0;
  uint64_t v28 = udtitvfmt_format();
  if (v28 < 1001)
  {
    unsigned int v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v28);
  }

  else
  {
    int v29 = (UniChar *)calloc(v28, 2uLL);
    LODWORD(v46[0]) = 0;
    int v30 = udtitvfmt_format();
    unsigned int v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v29, v30);
    free(v29);
  }

      LOBYTE(v23) = 0;
LABEL_33:
      if (v13 != 8205
        && (v13 & 0xFFFFFFFE) != 0xFF9E
        && (v13 & 0x1FFFF0) != 0xF870
        && v13 - 127995 >= 5
        && (v23 & 1) == 0
        && v13 - 917536 > 0x5F)
      {
        char v7 = v16;
        goto LABEL_69;
      }

      char v7 = v16 - 1;
      char v24 = *((void *)buffer + 20);
      if (v24 >= v16)
      {
        char v26 = *((void *)buffer + 17);
        if (v26)
        {
          char v25 = *(_WORD *)(v26 + 2 * (*((void *)buffer + 19) + v7));
        }

        else
        {
          char v27 = *((void *)buffer + 18);
          if (v27)
          {
            char v25 = *(char *)(v27 + *((void *)buffer + 19) + v7);
          }

          else
          {
            if (*((void *)buffer + 22) < v16 || (uint64_t v28 = *((void *)buffer + 21), v28 >= v16))
            {
              int v29 = v16 - 5;
              if (v29 + 64 < v24) {
                char v24 = v29 + 64;
              }
              *((void *)buffer + 21) = v29;
              *((void *)buffer + 22) = v24;
              v97.int location = *((void *)buffer + 19) + v29;
              v97.CFIndex length = v24 - v29;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v97, buffer);
              uint64_t v28 = *((void *)buffer + 21);
            }

            char v25 = buffer[v7 - v28];
          }
        }
      }

      else
      {
        char v25 = 0;
      }

      uint64_t v13 = v25;
      if (v16 <= 1) {
        goto LABEL_69;
      }
    }

    BitmapPtrForPlane = a4;
LABEL_31:
    unsigned __int8 v16 = v7;
    if (BitmapPtrForPlane) {
      goto LABEL_32;
    }
    goto LABEL_29;
  }

    char v8 = -1LL;
    goto LABEL_60;
  }

  uint64_t v11 = 0LL;
  unsigned int v12 = 0;
  char v7 = 0LL;
  uint64_t v13 = (CFIndex *)((char *)v5 + 56);
  char v8 = -1LL;
  unsigned int v14 = 1LL;
  while (v12)
  {
    if ((v14 & v6) != 0) {
      goto LABEL_17;
    }
    unsigned int v12 = 1;
LABEL_23:
    unsigned __int8 v15 = v14 >= 0x81;
    v14 *= 2LL;
    if (v15) {
      goto LABEL_25;
    }
  }

  unsigned int v12 = (v14 & v10) != 0;
  if ((v14 & v6) == 0) {
    goto LABEL_23;
  }
  if ((v14 & v10) == 0)
  {
    unsigned int v12 = 0;
    uint64_t v11 = v13[1] + *v13;
LABEL_22:
    v13 += 2;
    goto LABEL_23;
  }

        unsigned int v20 = *(const __CFArray **)(a3 + 32);
        if (v20)
        {
          uint64_t v21 = CFStringCreateByCombiningStrings(alloc, v20, @"/");
          CFStringAppend(MutableCopy, v21);
          CFRelease(v21);
        }

        if (*(void *)(a3 + 40))
        {
          CFStringAppend(MutableCopy, @"?");
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 40));
        }

        if (*(void *)(a3 + 48))
        {
          CFStringAppend(MutableCopy, @"#");
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
        }

        if (!MutableCopy) {
          goto LABEL_58;
        }
LABEL_36:
        unsigned int v22 = alloc;
        char v23 = MutableCopy;
        char v24 = v12;
LABEL_62:
        unsigned int v31 = _CFURLCreateWithURLString(v22, v23, 1, v24);
        goto LABEL_63;
      }
    }

    else
    {
      unsigned __int8 v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
        if (!v11) {
          goto LABEL_29;
        }
        goto LABEL_26;
      }
    }

    CFStringAppend(MutableCopy, v16);
    if (*(void *)(a3 + 24) != -1LL) {
      CFStringAppendFormat(MutableCopy, 0LL, @":%ld", *(void *)(a3 + 24));
    }
    goto LABEL_26;
  }

  if (a2 != 1)
  {
    if (!a2)
    {
      uint64_t v5 = *(const __CFString **)a3;
      if (*(void *)a3)
      {
        chars = 58;
        char v6 = CFStringGetLength(v5) + 1;
        CFIndex Length = *(const __CFString **)(a3 + 8);
        if (Length) {
          CFIndex Length = (const __CFString *)CFStringGetLength(Length);
        }
        MutableCFStringRef Copy = CFStringCreateMutableCopy(alloc, (CFIndex)Length + v6, *(CFStringRef *)a3);
        CFStringAppendCharacters(MutableCopy, &chars, 1LL);
        char v9 = *(const __CFString **)(a3 + 8);
        if (v9) {
          CFStringAppend(MutableCopy, v9);
        }
        if (!MutableCopy) {
          return 0LL;
        }
        goto LABEL_61;
      }

      MutableCFStringRef Copy = *(__CFString **)(a3 + 8);
      if (MutableCopy)
      {
        CFRetain(*(CFTypeRef *)(a3 + 8));
LABEL_61:
        unsigned int v22 = alloc;
        char v23 = MutableCopy;
        char v24 = 0LL;
        goto LABEL_62;
      }
    }

    return 0LL;
  }

  uint64_t v13 = CFStringCreateMutable(alloc, 0LL);
  MutableCFStringRef Copy = v13;
  if (*(void *)a3)
  {
    CFStringAppend(v13, *(CFStringRef *)a3);
    CFStringAppend(MutableCopy, @"://");
    unsigned int v12 = 0LL;
    unsigned int v14 = 1;
  }

  else
  {
    unsigned int v14 = 0;
    unsigned int v12 = *(const __CFURL **)(a3 + 72);
  }

  char v17 = *(const __CFString **)(a3 + 8);
  if (v17)
  {
    CFStringAppend(MutableCopy, v17);
    if (!*(void *)(a3 + 16)) {
      goto LABEL_39;
    }
  }

  else if (!*(void *)(a3 + 16))
  {
    goto LABEL_40;
  }

  CFStringAppend(MutableCopy, @":");
  CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 16));
LABEL_39:
  CFStringAppend(MutableCopy, @"@");
  unsigned int v14 = 1;
LABEL_40:
  char v25 = *(const __CFString **)(a3 + 24);
  if (v25)
  {
    CFStringAppend(MutableCopy, v25);
    char v26 = *(void *)(a3 + 32);
    if (v26 == -1) {
      goto LABEL_45;
    }
  }

  else
  {
    char v26 = *(void *)(a3 + 32);
    if (v26 == -1)
    {
      if (!v14) {
        goto LABEL_49;
      }
      goto LABEL_45;
    }
  }

  CFStringAppendFormat(MutableCopy, 0LL, @":%ld", v26);
LABEL_45:
  char v27 = *(const __CFArray **)(a3 + 40);
  if (!v27
    || !CFArrayGetCount(v27)
    || (uint64_t v28 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0LL), CFStringGetLength(v28)))
  {
    CFStringAppend(MutableCopy, @"/");
  }

    *((void *)v4 + v9) = a1;
    LOBYTE(v4) = v9 + 1;
    unsigned __int8 v15 = v9 + 1;
    v8[1] = v15;
    if (v15 >= v10)
    {
      if (!(_BYTE)v10)
      {
        LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
LABEL_39:
        v8[1] = v10;
        return v4 << 16;
      }
    }

    else if (!*(void *)(*((void *)v8 + 1) + 8LL * v15))
    {
      return v4 << 16;
    }

    unsigned __int8 v16 = 0LL;
    while (*(void *)(*((void *)v8 + 1) + 8 * v16))
    {
    }

    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v16;
    goto LABEL_39;
  }

  if ((a2 & 0xFF0000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)_CFGetTSD(7u);
    if (!v5)
    {
      uint64_t v5 = (unsigned __int8 *)CFAllocatorAllocate(0LL, 16LL, 0LL);
      *(void *)uint64_t v5 = 0LL;
      *((void *)v5 + 1) = 0LL;
      _CFSetTSD(7u, (uint64_t)v5, (uint64_t)__CFICUThreadDataDestructor);
    }

    char v6 = (_BYTE)v4 - 1;
    if (*v5 > ((_BYTE)v4 - 1))
    {
      char v7 = *((void *)v5 + 1);
      if (*(void *)(v7 + 8LL * ((_BYTE)v4 - 1)) == a1)
      {
        *(void *)(v7 + 8LL * ((_BYTE)v4 - 1)) = 0LL;
      }
    }
  }

    if (*(void *)&v12[8 * v17])
    {
      unsigned int v22 = *(void *)&v36[8 * v17];
      if (v22 >= 1) {

      }
      goto LABEL_37;
    }

    char v23 = *(void *)(a1 + 8 * v13);
    if ((v34 & 1) == 0)
    {
      *(void *)&v12[8 * v17] = v23;
      if (v23 >= 1) {
        char v24 = (id)v23;
      }
      goto LABEL_36;
    }

    char v25 = [*(id *)(a1 + 8 * v13) copyWithZone:0];
    *(void *)&v12[8 * v17] = v25;
    if (!v25) {
      break;
    }
LABEL_36:
LABEL_37:
    char v26 = *(void *)(a2 + 8 * v13);
    *(void *)&v36[8 * v17] = v26;
    if ((v34 & 4) == 0 && v26 >= 1) {
      char v27 = (id)v26;
    }
    if (++v13 == a3) {
      goto LABEL_43;
    }
  }

  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSDictionary: -copyWithZone: for key %@ returned nil",  v23);
  uint64_t v28 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
  objc_exception_throw(v28);
  -[__NSDictionaryM dealloc](v29, v30);
}

LABEL_157:
          if (++v78 == 15) {
            return;
          }
        }
      }

      char v98 = atomic_load((unint64_t *)(v2 + 8));
      uint64_t v99 = v98 & 0x70;
      char v100 = atomic_load((unint64_t *)(v3 + 8));
      uint64_t v101 = v100 & 0x70;
      if (v99 == 48 && v101 == 48)
      {
        UniChar v102 = *(int8x16_t **)(v2 + 24);
        CFMutableSetRef v103 = *(int8x16_t **)(v3 + 24);
      }

      else
      {
        if (v99 == 48 || v101 == 48)
        {
          if (v101 == 48) {
            uint64_t v136 = v2;
          }
          else {
            uint64_t v136 = v3;
          }
          if (v101 == 48) {
            uint64_t v5 = v3;
          }
          __CFCSetGetBitmap(v136, v145);
          uint64_t v4 = v136;
LABEL_279:
          __CFCSetIsEqualAnnex(v5, v4);
          return;
        }

        __CFCSetGetBitmap(v2, v145);
        __CFCSetGetBitmap(v4, __b);
        UniChar v102 = v145;
        CFMutableSetRef v103 = __b;
      }

      goto LABEL_279;
    }
  }

  char v34 = atomic_load((unint64_t *)(v2 + 8));
  if ((v34 & 0x70) != 0) {
    uint64_t v35 = v3;
  }
  else {
    uint64_t v35 = v2;
  }
  if (v35 == v2) {
    uint64_t v5 = v3;
  }
  char v36 = atomic_load((unint64_t *)(v5 + 8));
  if ((v36 & 0x70) == 0x10LL)
  {
    unint64_t v37 = 0LL;
    int v38 = *(_DWORD *)(v5 + 24);
    int v39 = v38 + *(_DWORD *)(v5 + 32);
    int v40 = -v39;
    int v41 = v39 - 1;
    if (BYTE2(v38) != BYTE2(v41)) {
      unsigned __int16 v42 = 0;
    }
    else {
      unsigned __int16 v42 = v38;
    }
    else {
      unsigned __int16 v43 = v41;
    }
    if ((_WORD)v38) {
      BOOL v44 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v41);
    }
    else {
      BOOL v44 = 0;
    }
    BOOL v45 = (unsigned __int16)v40 == 0;
    if ((_WORD)v40) {
      BOOL v46 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v41);
    }
    else {
      BOOL v46 = 0;
    }
    char v47 = !v45 || v44;
    unint64_t v48 = BYTE2(v41);
    if ((_WORD)v38) {
      BOOL v46 = 1;
    }
    BOOL v140 = v46;
    char v142 = v47;
    unsigned int v49 = v43;
    unsigned int v50 = v42;
    unsigned int v51 = (unsigned __int16)v41;
    while (1)
    {
      int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v35 + 24), v37, v145, (v10 & 8) == 0LL);
      if (v37 < BYTE2(v38) || v37 > v48)
      {
        if (BitmapForPlane)
        {
          if (BitmapForPlane == 1) {
            return;
          }
        }

        else
        {
          for (uint64_t k = 0LL; k != 2048; ++k)
          {
            if (v145[0].i32[k]) {
              return;
            }
          }
        }
      }

      else if (v37 <= BYTE2(v38) || v37 >= v48)
      {
        if (BitmapForPlane == 1)
        {
          if (v37 == BYTE2(v38))
          {
            if (v140) {
              return;
            }
          }

          else if ((v142 & 1) != 0)
          {
            return;
          }
        }

        else
        {
          if (BitmapForPlane == 255) {
            return;
          }
          if (v37 == BYTE2(v38))
          {
            unsigned int v53 = (unsigned __int16)v38;
            unsigned int v54 = v49;
          }

          else
          {
            unsigned int v53 = v50;
            unsigned int v54 = v51;
          }
        }
      }

      else if (BitmapForPlane)
      {
        if (BitmapForPlane == 255) {
          return;
        }
      }

      else if (v145 != (int8x16_t *)-1LL)
      {
        for (uint64_t m = 0LL; m != 2048; ++m)
        {
          __int32 v58 = v145[0].i32[m];
          if (v58 != -1) {
            return;
          }
        }
      }

      if (++v37 == 16) {
        return;
      }
    }
  }

  unsigned int v59 = *(_DWORD *)(v35 + 24);
  unint64_t v60 = atomic_load((unint64_t *)(v35 + 8));
  int v61 = CFUniCharGetBitmapForPlane(v59, 0, v145, (v60 >> 3) & 1);
  char v62 = atomic_load((unint64_t *)(v5 + 8));
  uint64_t v63 = v62 & 0x70;
  if (v61)
  {
    int v64 = v61;
    if (v63 == 48)
    {
      if (v61 == 1) {
        uint64_t v65 = -1LL;
      }
      else {
        uint64_t v65 = 0LL;
      }
      char v66 = *(int8x16_t **)(v5 + 24);
    }

    else
    {
      __CFCSetGetBitmap(v5, v145);
      if (v64 == 1) {
        uint64_t v65 = -1LL;
      }
      else {
        uint64_t v65 = 0LL;
      }
      char v66 = v145;
    }
  }

  else if (v63 == 48)
  {
    char v66 = *(int8x16_t **)(v5 + 24);
    uint64_t v65 = (uint64_t)v145;
  }

  else
  {
    __CFCSetGetBitmap(v5, __b);
    uint64_t v65 = (uint64_t)v145;
    char v66 = __b;
  }

  if (__CFCSetIsEqualBitmap(v65, (uint64_t)v66))
  {
    unint64_t v110 = atomic_load((unint64_t *)(v35 + 8));
    uint64_t v111 = *(void *)(v5 + 40);
    if (v111) {
      LODWORD(v111) = *(unsigned __int8 *)(v111 + 13) != 0;
    }
    uint64_t v112 = 0LL;
    int v113 = (v110 >> 3) & 1 ^ v111;
    do
    {
      unsigned __int8 v114 = v112 + 1;
      int v115 = CFUniCharGetBitmapForPlane(*(_DWORD *)(v35 + 24), (int)v112 + 1, v145, v113);
      uint64_t v116 = *(void *)(v5 + 40);
      if (v116 && ((*(_DWORD *)(v116 + 8) >> v114) & 1) != 0 && *(unsigned __int8 *)(v116 + 12) >= v114)
      {
        uint64_t v117 = *(void *)(*(void *)v116 + 8 * v112);
        if (!v115)
        {
LABEL_224:
          if (!v117) {
            return;
          }
          char v122 = atomic_load((unint64_t *)(v117 + 8));
          if ((v122 & 0x70) == 0x30LL)
          {
            v120 = *(int8x16_t **)(v117 + 24);
            uint64_t v121 = (uint64_t)v145;
          }

          else
          {
            __CFCSetGetBitmap(v117, __b);
            uint64_t v121 = (uint64_t)v145;
            v120 = __b;
          }

LABEL_232:
          goto LABEL_233;
        }
      }

      else
      {
        uint64_t v117 = 0LL;
        if (!v115) {
          goto LABEL_224;
        }
      }

      if (v117)
      {
        char v118 = atomic_load((unint64_t *)(v117 + 8));
        if ((v118 & 0x70) == 0x30LL)
        {
          if (v115 == 1) {
            uint64_t v119 = -1LL;
          }
          else {
            uint64_t v119 = 0LL;
          }
          v120 = *(int8x16_t **)(v117 + 24);
          uint64_t v121 = v119;
        }

        else
        {
          __CFCSetGetBitmap(v117, v145);
          if (v115 == 1) {
            uint64_t v121 = -1LL;
          }
          else {
            uint64_t v121 = 0LL;
          }
          v120 = v145;
        }

        goto LABEL_232;
      }

      if (v115 == 1) {
        return;
      }
LABEL_233:
      ++v112;
    }

    while (v112 != 15);
  }

unint64_t __CFCharacterSetHash(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unint64_t *)MEMORY[0x1895F8858](a1, a2);
  uint64_t v3 = v2;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v4 = v2 + 1;
  char v5 = atomic_load(v2 + 1);
  if ((v5 & 4) == 0)
  {
    unint64_t v6 = v2[5];
    if (v6 && (*(_DWORD *)(v6 + 8) || *(_BYTE *)(v6 + 13)))
    {
LABEL_7:
      char v8 = atomic_load(v2 + 1);
      if ((v8 & 0x70) == 0x30LL)
      {
        char v9 = (int8x16_t *)v2[3];
      }

      else
      {
        __CFCSetGetBitmap((uint64_t)v2, __b);
        char v9 = __b;
      }

      v3[2] = CFHashBytes((uint64_t)v9, 0x2000LL);
    }

    else
    {
      unsigned int v7 = atomic_load(v4);
      switch((v7 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (v2[4]) {
            goto LABEL_7;
          }
          break;
        case 3u:
        case 4u:
          if (v2[3]) {
            goto LABEL_7;
          }
          break;
        default:
          goto LABEL_7;
      }

      int v14 = atomic_load(v2 + 1);
      v2[2] = (v14 << 28 >> 31);
    }

    unint64_t v10 = atomic_load(v4);
    while (1)
    {
      unint64_t v11 = __ldaxr(v4);
      if (v11 != v10) {
        break;
      }
      if (__stlxr(v10 | 4, v4)) {
        goto LABEL_16;
      }
      int v12 = 1;
LABEL_17:
      unint64_t v10 = v11;
      if (v12) {
        return v3[2];
      }
    }

    __clrex();
LABEL_16:
    int v12 = 0;
    goto LABEL_17;
  }

  return v3[2];
}

CFStringRef __CFCharacterSetCopyDescription(unint64_t *cf)
{
  unint64_t v2 = cf[5];
  if (v2 && (*(_DWORD *)(v2 + 8) || *(_BYTE *)(v2 + 13)))
  {
LABEL_6:
    unsigned int v4 = atomic_load(cf + 1);
    switch((v4 >> 4) & 7)
    {
      case 0u:
        switch(cf[3])
        {
          case 1uLL:
            char v5 = @"<CFCharacterSet Predefined Control Set>";
            return (CFStringRef)CFRetain(v5);
          case 2uLL:
            char v5 = @"<CFCharacterSet Predefined Whitespace Set>";
            return (CFStringRef)CFRetain(v5);
          case 3uLL:
            char v5 = @"<CFCharacterSet Predefined WhitespaceAndNewline Set>";
            return (CFStringRef)CFRetain(v5);
          case 4uLL:
            char v5 = @"<CFCharacterSet Predefined DecimalDigit Set>";
            return (CFStringRef)CFRetain(v5);
          case 5uLL:
            char v5 = @"<CFCharacterSet Predefined Letter Set>";
            return (CFStringRef)CFRetain(v5);
          case 6uLL:
            char v5 = @"<CFCharacterSet Predefined LowercaseLetter Set>";
            return (CFStringRef)CFRetain(v5);
          case 7uLL:
            char v5 = @"<CFCharacterSet Predefined UppercaseLetter Set>";
            return (CFStringRef)CFRetain(v5);
          case 8uLL:
            char v5 = @"<CFCharacterSet Predefined NonBase Set>";
            return (CFStringRef)CFRetain(v5);
          case 9uLL:
            char v5 = @"<CFCharacterSet Predefined Decomposable Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xAuLL:
            char v5 = @"<CFCharacterSet Predefined AlphaNumeric Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xBuLL:
            char v5 = @"<CFCharacterSet Predefined Punctuation Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xCuLL:
            char v5 = @"<CFCharacterSet Predefined Illegal Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xDuLL:
            char v5 = @"<CFCharacterSet Predefined CapitalizedLetter Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xEuLL:
            char v5 = @"<CFCharacterSet Predefined Symbol Set>";
            return (CFStringRef)CFRetain(v5);
          case 0xFuLL:
            char v5 = @"<CFCharacterSet Predefined Newline Set>";
            return (CFStringRef)CFRetain(v5);
          default:
            goto LABEL_14;
        }

      case 1u:
        char v9 = CFGetAllocator(cf);
        return CFStringCreateWithFormat( v9,  0LL,  @"<CFCharacterSet Range(%u, %ld)>",  *((unsigned int *)cf + 6),  cf[4]);
      case 2u:
        uint64_t v10 = cf[4];
        unint64_t v11 = CFGetAllocator(cf);
        CFIndex Length = CFStringGetLength(@"<CFCharacterSet Items(");
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(v11, Length - v10 + 8 * v10 + 2);
        CFStringAppend(Mutable, @"<CFCharacterSet Items(");
        if (v10 >= 1)
        {
          for (uint64_t i = 0LL; i != v10; ++i)
          {
            if (i) {
              int v14 = " ";
            }
            else {
              int v14 = "";
            }
            CFStringAppendFormat(Mutable, 0LL, @"%sU+%04X", v14, *(unsigned __int16 *)(cf[3] + 2 * i));
          }
        }

        CFStringAppend(Mutable, @">"));
        goto LABEL_23;
      case 3u:
      case 4u:
        char v5 = @"<CFCharacterSet Bitmap>";
        return (CFStringRef)CFRetain(v5);
      default:
LABEL_14:
        CFMutableDictionaryRef Mutable = 0LL;
LABEL_23:
        CFStringRef result = Mutable;
        break;
    }
  }

  else
  {
    unsigned int v3 = atomic_load(cf + 1);
    switch((v3 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (cf[4]) {
          goto LABEL_6;
        }
        break;
      case 3u:
      case 4u:
        if (cf[3]) {
          goto LABEL_6;
        }
        break;
      default:
        goto LABEL_6;
    }

    char v7 = atomic_load(cf + 1);
    if ((v7 & 8) != 0) {
      char v5 = @"<CFCharacterSet All>";
    }
    else {
      char v5 = @"<CFCharacterSet Empty>";
    }
    return (CFStringRef)CFRetain(v5);
  }

  return result;
}

void __CFCharacterSetInitialize()
{
  if (__CFCharacterSetInitialize_initOnce != -1) {
    dispatch_once(&__CFCharacterSetInitialize_initOnce, &__block_literal_global_0);
  }
}

CFTypeID CFCharacterSetGetTypeID(void)
{
  return 25LL;
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)(&__CFBuiltinSets + 6 * theSetIdentifier - 6);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef alloc, CFRange theRange)
{
  CFIndex length = theRange.length;
  int location = theRange.location;
  if ((unint64_t)theRange.location >> 16 > 0x10
    || theRange.length >= 1114113
    || theRange.location + theRange.length >= 0x110001uLL)
  {
    CFCharacterSetRef result = (CFCharacterSetRef)CFLog( 3LL,  (uint64_t)@"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)",  theRange.length,  v2,  v3,  v4,  v5,  v6,  (uint64_t)"CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef, CFRange)");
    qword_18C539A70 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
    return result;
  }

  CFCharacterSetRef result = (CFCharacterSetRef)_CFRuntimeCreateInstance(alloc, 0x19uLL, 32LL, 0LL, v3, v4, v5, v6);
  if (!length)
  {
    if (!result) {
      return result;
    }
    char v17 = (unint64_t *)((char *)result + 8);
    unint64_t v18 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      unint64_t v19 = __ldaxr(v17);
      if (v19 != v18) {
        break;
      }
      if (__stlxr(v18 & 0xFFFFFFFFFFFFFFFELL, v17)) {
        goto LABEL_27;
      }
      int v20 = 1;
LABEL_28:
      unint64_t v18 = v19;
      if (v20)
      {
        unint64_t v21 = atomic_load(v17);
        while (1)
        {
          unint64_t v22 = __ldaxr(v17);
          if (v22 != v21) {
            break;
          }
          if (__stlxr(v21 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v17)) {
            goto LABEL_34;
          }
          int v23 = 1;
LABEL_35:
          unint64_t v21 = v22;
          if (v23)
          {
            *((void *)result + 5) = 0LL;
            *((void *)result + 2) = 0LL;
            *((void *)result + 3) = 0LL;
            unint64_t v24 = atomic_load((unint64_t *)result + 1);
            while (1)
            {
              unint64_t v25 = __ldaxr(v17);
              if (v25 != v24) {
                break;
              }
              if (__stlxr(v24 | 4, v17)) {
                goto LABEL_41;
              }
              int v26 = 1;
LABEL_42:
              unint64_t v24 = v25;
              if (v26) {
                return result;
              }
            }

            __clrex();
LABEL_41:
            int v26 = 0;
            goto LABEL_42;
          }
        }

        __clrex();
LABEL_34:
        int v23 = 0;
        goto LABEL_35;
      }
    }

    __clrex();
LABEL_27:
    int v20 = 0;
    goto LABEL_28;
  }

  if (result)
  {
    uint64_t v10 = (unint64_t *)((char *)result + 8);
    unint64_t v11 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      unint64_t v12 = __ldaxr(v10);
      if (v12 != v11) {
        break;
      }
      if (__stlxr(v11 & 0xFFFFFFFFFFFFFFFELL, v10)) {
        goto LABEL_11;
      }
      int v13 = 1;
LABEL_12:
      unint64_t v11 = v12;
      if (v13)
      {
        unint64_t v14 = atomic_load(v10);
        while (1)
        {
          unint64_t v15 = __ldaxr(v10);
          if (v15 != v14) {
            break;
          }
          if (__stlxr(v14 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v10)) {
            goto LABEL_18;
          }
          int v16 = 1;
LABEL_19:
          unint64_t v14 = v15;
          if (v16)
          {
            *((void *)result + 2) = 0LL;
            *((_DWORD *)result + 6) = location;
            *((void *)result + 4) = length;
            *((void *)result + 5) = 0LL;
            return result;
          }
        }

        __clrex();
LABEL_18:
        int v16 = 0;
        goto LABEL_19;
      }
    }

    __clrex();
LABEL_11:
    int v13 = 0;
    goto LABEL_12;
  }

  return result;
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (Length > 63) {
    goto LABEL_39;
  }
  uint64_t v9 = Length;
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(alloc, 0x19uLL, 32LL, 0LL, v5, v6, v7, v8);
  CFMutableCharacterSetRef Mutable = (CFMutableCharacterSetRef)Instance;
  if (!Instance) {
    return Mutable;
  }
  unint64_t v12 = Instance + 1;
  unint64_t v13 = atomic_load(Instance + 1);
  do
  {
    unint64_t v14 = __ldaxr(v12);
    if (v14 == v13)
    {
      if (!__stlxr(v13 & 0xFFFFFFFFFFFFFFFELL, v12))
      {
        int v15 = 1;
        goto LABEL_9;
      }
    }

    else
    {
      __clrex();
    }

    int v15 = 0;
LABEL_9:
    unint64_t v13 = v14;
  }

  while (!v15);
  unint64_t v16 = atomic_load(v12);
  do
  {
    unint64_t v17 = __ldaxr(v12);
    if (v17 == v16)
    {
      if (!__stlxr(v16 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v12))
      {
        int v18 = 1;
        goto LABEL_16;
      }
    }

    else
    {
      __clrex();
    }

    int v18 = 0;
LABEL_16:
    unint64_t v16 = v17;
  }

  while (!v18);
  Instance[2] = 0LL;
  Instance[5] = 0LL;
  unint64_t v19 = CFGetAllocator(Instance);
  int v20 = (UniChar *)CFAllocatorAllocate(v19, 128LL, 0LL);
  *((void *)Mutable + 3) = v20;
  *((void *)Mutable + 4) = v9;
  v38.int location = 0LL;
  v38.CFIndex length = v9;
  CFStringGetCharacters(theString, v38, v20);
  qsort(*((void **)Mutable + 3), v9, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
  uint64_t v21 = v9;
  if (v9 >= 2)
  {
    uint64_t v22 = 0LL;
    uint64_t v23 = *((void *)Mutable + 3);
    uint64_t v24 = v9 - 1;
    unint64_t v25 = (unsigned __int16 *)(v23 + 2);
    do
    {
      int v27 = *v25++;
      __int16 v26 = v27;
      if (*(unsigned __int16 *)(v23 + 2 * v22) != v27)
      {
        ++v22;
        *(_WORD *)(v23 + 2 * v22) = v26;
      }

      --v24;
    }

    while (v24);
    uint64_t v21 = v22 + 1;
  }

  *((void *)Mutable + 4) = v21;
  if (!v9)
  {
    unint64_t v30 = atomic_load(v12);
    while (1)
    {
      unint64_t v31 = __ldaxr(v12);
      if (v31 != v30) {
        break;
      }
      if (__stlxr(v30 | 4, v12)) {
        goto LABEL_35;
      }
      char v32 = 1;
LABEL_36:
      unint64_t v30 = v31;
      if ((v32 & 1) != 0) {
        return Mutable;
      }
    }

    __clrex();
LABEL_35:
    char v32 = 0;
    goto LABEL_36;
  }

  if (v9 >= 2)
  {
    uint64_t v28 = (_WORD *)*((void *)Mutable + 3);
    if ((unsigned __int16)*v28 >> 10 <= 0x36u)
    {
      int v29 = &v28[v9];
      if ((unsigned __int16)*(v29 - 1) >> 10 >= 0x37u)
      {
        while ((*v28 & 0xF800 | 0x400) != 0xDC00)
        {
          if (++v28 >= v29) {
            return Mutable;
          }
        }

        CFRelease(Mutable);
LABEL_39:
        CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(alloc);
        CFCharacterSetAddCharactersInString(Mutable, theString);
        __CFCSetMakeCompact((unint64_t *)Mutable);
        CFRange v33 = (unint64_t *)((char *)Mutable + 8);
        unint64_t v34 = atomic_load((unint64_t *)Mutable + 1);
        while (2)
        {
          unint64_t v35 = __ldaxr(v33);
          if (v35 == v34)
          {
            if (!__stlxr(v34 & 0xFFFFFFFFFFFFFFFELL, v33))
            {
              int v36 = 1;
              goto LABEL_45;
            }
          }

          else
          {
            __clrex();
          }

          int v36 = 0;
LABEL_45:
          unint64_t v34 = v35;
          if (v36) {
            return Mutable;
          }
          continue;
        }
      }
    }
  }

  return Mutable;
}

uint64_t chcompar(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 - *a2;
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  CFMutableCharacterSetRef result = (CFMutableCharacterSetRef)_CFRuntimeCreateInstance(alloc, 0x19uLL, 32LL, 0LL, v1, v2, v3, v4);
  if (result)
  {
    uint64_t v6 = (unint64_t *)((char *)result + 8);
    unint64_t v7 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      unint64_t v8 = __ldaxr(v6);
      if (v8 != v7) {
        break;
      }
      if (__stlxr(v7 | 1, v6)) {
        goto LABEL_7;
      }
      int v9 = 1;
LABEL_8:
      unint64_t v7 = v8;
      if (v9)
      {
        unint64_t v10 = atomic_load(v6);
        while (1)
        {
          unint64_t v11 = __ldaxr(v6);
          if (v11 != v10) {
            break;
          }
          if (__stlxr(v10 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v6)) {
            goto LABEL_14;
          }
          int v12 = 1;
LABEL_15:
          unint64_t v10 = v11;
          if (v12)
          {
            *((void *)result + 5) = 0LL;
            *((void *)result + 2) = 0LL;
            *((void *)result + 3) = 0LL;
            unint64_t v13 = atomic_load((unint64_t *)result + 1);
            while (1)
            {
              unint64_t v14 = __ldaxr(v6);
              if (v14 != v13) {
                break;
              }
              if (__stlxr(v13 | 4, v6)) {
                goto LABEL_21;
              }
              int v15 = 1;
LABEL_22:
              unint64_t v13 = v14;
              if (v15) {
                return result;
              }
            }

            __clrex();
LABEL_21:
            int v15 = 0;
            goto LABEL_22;
          }
        }

        __clrex();
LABEL_14:
        int v12 = 0;
        goto LABEL_15;
      }
    }

    __clrex();
LABEL_7:
    int v9 = 0;
    goto LABEL_8;
  }

  return result;
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet addCharactersInString:](theSet, "addCharactersInString:", theString);
    return;
  }

  unint64_t v10 = (unint64_t *)((char *)theSet + 8);
  char v11 = atomic_load((unint64_t *)theSet + 1);
  if ((v11 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef, CFStringRef)");
  }

  char v12 = atomic_load(v10);
  if ((v12 & 0x70) != 0
    || (char v13 = atomic_load(v10), (v13 & 1) != 0)
    || (char v14 = atomic_load(v10), (v14 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    uint64_t v15 = *((void *)theSet + 5);
    if (v15)
    {
      if (*(_DWORD *)(v15 + 8) || *(_BYTE *)(v15 + 13)) {
        goto LABEL_18;
      }
    }

    unsigned int v16 = atomic_load(v10);
    switch((v16 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*((void *)theSet + 4)) {
          goto LABEL_18;
        }
        break;
      case 3u:
      case 4u:
        if (*((void *)theSet + 3)) {
          goto LABEL_18;
        }
        break;
      default:
        goto LABEL_18;
    }

    char v17 = atomic_load(v10);
    if ((v17 & 8) == 0)
    {
LABEL_18:
      CFIndex Length = CFStringGetLength(theString);
      if (!Length) {
        return;
      }
      CFIndex v19 = Length;
      char v20 = atomic_load(v10);
      if ((v20 & 8) != 0) {
        goto LABEL_31;
      }
      uint64_t v21 = *((void *)theSet + 5);
      if (v21 && (*(_DWORD *)(v21 + 8) || *(_BYTE *)(v21 + 13)))
      {
LABEL_27:
        char v24 = atomic_load(v10);
        uint64_t v23 = (v24 & 0x70) == 0x20LL ? *((void *)theSet + 4) : 64LL;
      }

      else
      {
        unsigned int v22 = atomic_load(v10);
        switch((v22 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((void *)theSet + 4)) {
              goto LABEL_27;
            }
            break;
          case 3u:
          case 4u:
            if (*((void *)theSet + 3)) {
              goto LABEL_27;
            }
            break;
          default:
            goto LABEL_27;
        }

        uint64_t v23 = 0LL;
      }

      size_t v25 = v23 + Length;
      if (v23 + Length > 63)
      {
LABEL_31:
        __CFCSetMakeBitmap((char *)theSet);
        CFStringRef theStringa = theString;
        uint64_t v76 = 0LL;
        CFIndex v77 = v19;
        CharactersPtr = CFStringGetCharactersPtr(theString);
        CStringPtr = 0LL;
        unint64_t v74 = CharactersPtr;
        if (!CharactersPtr) {
          CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
        }
        int64_t v78 = 0LL;
        int64_t v79 = 0LL;
        unsigned __int16 v75 = CStringPtr;
        if (v19 < 1)
        {
          char v36 = 0;
        }

        else
        {
          uint64_t v35 = 0LL;
          char v36 = 0;
          int64_t v37 = 0LL;
          uint64_t v38 = 64LL;
          do
          {
            else {
              uint64_t v39 = v37;
            }
            if (v74)
            {
              UniChar v40 = v74[v37 + v76];
            }

            else if (v75)
            {
              UniChar v40 = v75[v76 + v37];
            }

            else
            {
              int64_t v41 = v78;
              if (v79 <= v37 || v78 > v37)
              {
                uint64_t v43 = -v39;
                uint64_t v44 = v39 + v35;
                uint64_t v45 = v38 - v39;
                int64_t v46 = v37 + v43;
                CFIndex v47 = v46 + 64;
                if (v46 + 64 >= v77) {
                  CFIndex v47 = v77;
                }
                int64_t v78 = v46;
                int64_t v79 = v47;
                if (v77 < v45) {
                  uint64_t v45 = v77;
                }
                v81.CFIndex length = v45 + v44;
                v81.int location = v46 + v76;
                CFStringGetCharacters(theStringa, v81, buffer);
                int64_t v41 = v78;
              }

              UniChar v40 = buffer[v37 - v41];
            }

            if ((v40 & 0xF800 | 0x400) == 0xDC00) {
              char v36 = 1;
            }
            else {
              *(_BYTE *)(*((void *)theSet + 3) + (v40 >> 3)) |= 1 << (v40 & 7);
            }
            ++v37;
            --v35;
            ++v38;
          }

          while (v19 != v37);
        }

        unint64_t v48 = atomic_load(v10);
        while (1)
        {
          unint64_t v49 = __ldaxr(v10);
          if (v49 != v48) {
            break;
          }
          if (__stlxr(v48 & 0xFFFFFFFFFFFFFFFBLL, v10)) {
            goto LABEL_63;
          }
          int v50 = 1;
LABEL_64:
          unint64_t v48 = v49;
          if (v50)
          {
            if (__CFCheckForExapendedSet == 1) {
              __CFCheckForExpandedSet((const char *)theSet, v26, v27, v28, v29, v30, v31, v32);
            }
            if ((v36 & 1) != 0) {
              __CFApplySurrogatesInString( (uint64_t)theSet,  theString,  (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
            }
            return;
          }
        }

        __clrex();
LABEL_63:
        int v50 = 0;
        goto LABEL_64;
      }

      uint64_t v51 = *((void *)theSet + 3);
      if (v51)
      {
        CFTypeID v52 = (UniChar *)(v51 + 2LL * *((void *)theSet + 4));
      }

      else
      {
        unsigned int v53 = CFGetAllocator(theSet);
        CFTypeID v52 = (UniChar *)CFAllocatorAllocate(v53, 128LL, 0LL);
      }

      v82.int location = 0LL;
      v82.CFIndex length = v19;
      CFStringGetCharacters(theString, v82, v52);
      if (v19 < 2)
      {
        char v54 = 0;
      }

      else
      {
        char v54 = 0;
        uint64_t v55 = v52;
        int v56 = &v52[v19];
        do
        {
          if ((*v55 & 0xF800 | 0x400) == 0xDC00)
          {
            memmove(v55, v55 + 1, (char *)v56-- - (char *)(v55 + 1));
            char v54 = 1;
          }

          else
          {
            ++v55;
          }
        }

        while (v55 < v56);
        size_t v25 = v23 + v56 - v52;
      }

      uint64_t v57 = (UniChar *)*((void *)theSet + 3);
      if (!v25)
      {
        if (!v57)
        {
          unsigned int v68 = CFGetAllocator(theSet);
          CFAllocatorDeallocate(v68, v52);
        }

        goto LABEL_99;
      }

      if (v57) {
        goto LABEL_90;
      }
      unint64_t v58 = atomic_load(v10);
      while (1)
      {
        unint64_t v59 = __ldaxr(v10);
        if (v59 != v58) {
          break;
        }
        if (__stlxr(v58 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v10)) {
          goto LABEL_87;
        }
        int v60 = 1;
LABEL_88:
        unint64_t v58 = v59;
        if (v60)
        {
          *((void *)theSet + 3) = v52;
          uint64_t v57 = v52;
LABEL_90:
          *((void *)theSet + 4) = v25;
          qsort(v57, v25, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
          uint64_t v61 = *((void *)theSet + 4);
          if (v61 >= 2)
          {
            uint64_t v62 = 0LL;
            uint64_t v63 = *((void *)theSet + 3);
            uint64_t v64 = v61 - 1;
            uint64_t v65 = (unsigned __int16 *)(v63 + 2);
            do
            {
              int v67 = *v65++;
              __int16 v66 = v67;
              if (*(unsigned __int16 *)(v63 + 2 * v62) != v67)
              {
                ++v62;
                *(_WORD *)(v63 + 2 * v62) = v66;
              }

              --v64;
            }

            while (v64);
            uint64_t v61 = v62 + 1;
          }

          *((void *)theSet + 4) = v61;
LABEL_99:
          unint64_t v69 = atomic_load(v10);
          while (2)
          {
            unint64_t v70 = __ldaxr(v10);
            if (v70 == v69)
            {
              if (!__stlxr(v69 & 0xFFFFFFFFFFFFFFFBLL, v10))
              {
                int v71 = 1;
                goto LABEL_105;
              }
            }

            else
            {
              __clrex();
            }

            int v71 = 0;
LABEL_105:
            unint64_t v69 = v70;
            if (v71)
            {
              if ((v54 & 1) != 0) {
                __CFApplySurrogatesInString( (uint64_t)theSet,  theString,  (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
              }
              return;
            }

            continue;
          }
        }
      }

      __clrex();
LABEL_87:
      int v60 = 0;
      goto LABEL_88;
    }
  }

void __CFCSetMakeCompact(unint64_t *cf)
{
  uint64_t v1 = cf + 1;
  char v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x30LL)
  {
    uint64_t v4 = (unsigned __int8 *)cf[3];
    if (v4)
    {
      uint64_t v5 = CFGetAllocator(cf);
      uint64_t v6 = __CFCreateCompactBitmap(v5, v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = CFGetAllocator(cf);
        CFAllocatorDeallocate(v8, v4);
        unint64_t v9 = atomic_load(cf + 1);
        while (1)
        {
          unint64_t v10 = __ldaxr(v1);
          if (v10 != v9) {
            break;
          }
          if (__stlxr(v9 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v1)) {
            goto LABEL_9;
          }
          int v11 = 1;
LABEL_10:
          unint64_t v9 = v10;
          if (v11)
          {
            cf[3] = (unint64_t)v7;
            return;
          }
        }

        __clrex();
LABEL_9:
        int v11 = 0;
        goto LABEL_10;
      }
    }
  }

CFCharacterSetRef CFCharacterSetCreateWithBitmapRepresentation(CFAllocatorRef alloc, CFDataRef theData)
{
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance(alloc, 0x19uLL, 32LL, 0LL, v2, v3, v4, v5);
  unint64_t v9 = Instance;
  if (!Instance) {
    return (CFCharacterSetRef)v9;
  }
  unint64_t v10 = Instance + 1;
  unint64_t v11 = atomic_load(Instance + 1);
  do
  {
    unint64_t v12 = __ldaxr(v10);
    if (v12 == v11)
    {
      if (!__stlxr(v11 & 0xFFFFFFFFFFFFFFFELL, v10))
      {
        int v13 = 1;
        goto LABEL_8;
      }
    }

    else
    {
      __clrex();
    }

    int v13 = 0;
LABEL_8:
    unint64_t v11 = v12;
  }

  while (!v13);
  unint64_t v14 = atomic_load(v10);
  do
  {
    unint64_t v15 = __ldaxr(v10);
    if (v15 == v14)
    {
      if (!__stlxr(v14 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v10))
      {
        int v16 = 1;
        goto LABEL_15;
      }
    }

    else
    {
      __clrex();
    }

    int v16 = 0;
LABEL_15:
    unint64_t v14 = v15;
  }

  while (!v16);
  Instance[2] = 0LL;
  Instance[5] = 0LL;
  if (!theData || (CFIndex Length = CFDataGetLength(theData), Length < 1))
  {
    v9[3] = 0LL;
    unint64_t v26 = atomic_load(v9 + 1);
    while (1)
    {
      unint64_t v27 = __ldaxr(v10);
      if (v27 != v26) {
        break;
      }
      if (__stlxr(v26 | 4, v10)) {
        goto LABEL_33;
      }
      int v28 = 1;
LABEL_34:
      unint64_t v26 = v27;
      if (v28) {
        return (CFCharacterSetRef)v9;
      }
    }

    __clrex();
LABEL_33:
    int v28 = 0;
    goto LABEL_34;
  }

  int64_t v18 = Length;
  if ((unint64_t)Length >> 13)
  {
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
    uint64_t v31 = __CFCreateCompactBitmap(alloc, BytePtr);
    if (v31)
    {
      v9[3] = (unint64_t)v31;
      unint64_t v32 = atomic_load(v9 + 1);
      while (1)
      {
        unint64_t v33 = __ldaxr(v10);
        if (v33 != v32) {
          break;
        }
        if (__stlxr(v32 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v10)) {
          goto LABEL_42;
        }
        int v34 = 1;
LABEL_43:
        unint64_t v32 = v33;
        if (v34) {
          goto LABEL_47;
        }
      }

      __clrex();
LABEL_42:
      int v34 = 0;
      goto LABEL_43;
    }

    uint64_t v35 = CFAllocatorAllocate(alloc, 0x2000LL, 0LL);
    char v36 = CFDataGetBytePtr(theData);
    memmove(v35, v36, 0x2000uLL);
    v9[3] = (unint64_t)v35;
LABEL_47:
    uint64_t v37 = v18 - 0x2000;
    if (v18 <= 0x2000) {
      return (CFCharacterSetRef)v9;
    }
    CFCharacterSetRef result = (CFCharacterSetRef)CFDataGetBytePtr(theData);
    if (v18 == 8193) {
      return (CFCharacterSetRef)v9;
    }
    uint64_t v38 = (unsigned __int8 *)result;
LABEL_50:
    uint64_t v39 = v38[0x2000];
    if (!v38[0x2000])
    {
      __break(1u);
      return result;
    }

    if (v39 > 0x10)
    {
      uint64_t v40 = 0LL;
LABEL_64:
      v38 += 8193;
      if ((unint64_t)v37 <= 0x2000)
      {
        int v50 = (char *)CFAllocatorAllocate(alloc, 0x2000LL, 0LL);
        memmove(v50, v38, v37 - 1);
        bzero(&v50[v37 - 1], 8193 - v37);
        CFCharacterSetRef result = (CFCharacterSetRef)__CFCreateCompactBitmap(alloc, (unsigned __int8 *)v50);
        if (result)
        {
          CFCharacterSetRef v51 = result;
          CFAllocatorDeallocate(alloc, v50);
          *(void *)(v40 + 24) = v51;
          CFTypeID v52 = (unint64_t *)(v40 + 8);
          unint64_t v53 = atomic_load((unint64_t *)(v40 + 8));
          while (1)
          {
            unint64_t v54 = __ldaxr(v52);
            if (v54 != v53) {
              break;
            }
            if (__stlxr(v53 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v52)) {
              goto LABEL_71;
            }
            char v55 = 1;
LABEL_72:
            unint64_t v53 = v54;
            if ((v55 & 1) != 0) {
              goto LABEL_98;
            }
          }

          __clrex();
LABEL_71:
          char v55 = 0;
          goto LABEL_72;
        }

        *(void *)(v40 + 24) = v50;
        int v60 = (unint64_t *)(v40 + 8);
        unint64_t v61 = atomic_load((unint64_t *)(v40 + 8));
        while (1)
        {
          unint64_t v62 = __ldaxr(v60);
          if (v62 != v61) {
            break;
          }
          if (__stlxr(v61 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v60)) {
            goto LABEL_88;
          }
          char v63 = 1;
LABEL_89:
          unint64_t v61 = v62;
          if ((v63 & 1) != 0) {
            goto LABEL_98;
          }
        }

        __clrex();
LABEL_88:
        char v63 = 0;
        goto LABEL_89;
      }

      CFCharacterSetRef result = (CFCharacterSetRef)__CFCreateCompactBitmap(alloc, v38);
      if (result)
      {
        *(void *)(v40 + 24) = result;
        int v56 = (unint64_t *)(v40 + 8);
        unint64_t v57 = atomic_load((unint64_t *)(v40 + 8));
        while (1)
        {
          unint64_t v58 = __ldaxr(v56);
          if (v58 != v57) {
            break;
          }
          if (__stlxr(v57 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v56)) {
            goto LABEL_80;
          }
          int v59 = 1;
LABEL_81:
          unint64_t v57 = v58;
          if (v59) {
            goto LABEL_98;
          }
        }

        __clrex();
LABEL_80:
        int v59 = 0;
        goto LABEL_81;
      }

      uint64_t v64 = CFAllocatorAllocate(alloc, 0x2000LL, 0LL);
      CFCharacterSetRef result = (CFCharacterSetRef)memmove(v64, v38, 0x2000uLL);
      *(void *)(v40 + 24) = v64;
      uint64_t v65 = (unint64_t *)(v40 + 8);
      unint64_t v66 = atomic_load((unint64_t *)(v40 + 8));
      while (1)
      {
        unint64_t v67 = __ldaxr(v65);
        if (v67 != v66) {
          break;
        }
        if (__stlxr(v66 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v65)) {
          goto LABEL_96;
        }
        char v68 = 1;
LABEL_97:
        unint64_t v66 = v67;
        if ((v68 & 1) != 0)
        {
LABEL_98:
          BOOL v69 = v37 <= 8194;
          v37 -= 8193LL;
          if (v69) {
            return (CFCharacterSetRef)v9;
          }
          goto LABEL_50;
        }
      }

      __clrex();
LABEL_96:
      char v68 = 0;
      goto LABEL_97;
    }

    unint64_t v41 = v9[5];
    if (v41)
    {
      if (*(unsigned __int8 *)(v41 + 12) >= v39)
      {
LABEL_60:
        if ((*(_DWORD *)(v41 + 8) & (1 << v39)) != 0)
        {
          uint64_t v47 = (v39 - 1);
        }

        else
        {
          unint64_t v48 = CFGetAllocator(v9);
          CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v48);
          uint64_t v47 = (v39 - 1);
          *(void *)(*(void *)v9[5] + 8LL * v47) = Mutable;
          unint64_t v41 = v9[5];
          *(_DWORD *)(v41 + 8) |= 1 << v39;
        }

        uint64_t v40 = *(void *)(*(void *)v41 + 8 * v47);
        goto LABEL_64;
      }

      *(_BYTE *)(v41 + 12) = v39;
      uint64_t v42 = *(void *)v41;
      uint64_t v43 = (malloc_zone_t *)CFGetAllocator(v9);
      if (v42)
      {
        uint64_t v44 = __CFSafelyReallocateWithAllocator(v43, *(void **)v9[5], 8 * v39, 0LL, 0LL);
LABEL_59:
        unint64_t v41 = v9[5];
        *(void *)unint64_t v41 = v44;
        goto LABEL_60;
      }
    }

    else
    {
      uint64_t v45 = CFGetAllocator(v9);
      int64_t v46 = CFAllocatorAllocate(v45, 16LL, 0LL);
      v9[5] = (unint64_t)v46;
      v46[12] = v39;
      v46[13] = 0;
      *((_DWORD *)v46 + 2) = 0;
      uint64_t v43 = (malloc_zone_t *)CFGetAllocator(v9);
    }

    uint64_t v44 = CFAllocatorAllocate((CFAllocatorRef)v43, 8 * v39, 0LL);
    goto LABEL_59;
  }

  CFIndex v19 = (char *)CFAllocatorAllocate(alloc, 0x2000LL, 0LL);
  char v20 = CFDataGetBytePtr(theData);
  memmove(v19, v20, v18);
  bzero(&v19[v18], 0x2000 - v18);
  uint64_t v21 = __CFCreateCompactBitmap(alloc, (unsigned __int8 *)v19);
  if (v21)
  {
    unsigned int v22 = v21;
    CFAllocatorDeallocate(alloc, v19);
    v9[3] = (unint64_t)v22;
    unint64_t v23 = atomic_load(v9 + 1);
    while (1)
    {
      unint64_t v24 = __ldaxr(v10);
      if (v24 != v23) {
        break;
      }
      if (__stlxr(v23 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v10)) {
        goto LABEL_25;
      }
      char v25 = 1;
LABEL_26:
      unint64_t v23 = v24;
      if ((v25 & 1) != 0) {
        return (CFCharacterSetRef)v9;
      }
    }

    __clrex();
LABEL_25:
    char v25 = 0;
    goto LABEL_26;
  }

  v9[3] = (unint64_t)v19;
  return (CFCharacterSetRef)v9;
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  CFStringRef Copy = (unint64_t *)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
  CFCharacterSetInvert((CFMutableCharacterSetRef)Copy);
  uint64_t v6 = Copy + 1;
  unint64_t v7 = atomic_load(Copy + 1);
  do
  {
    unint64_t v8 = __ldaxr(v6);
    if (v8 == v7)
    {
      if (!__stlxr(v7 & 0xFFFFFFFFFFFFFFFELL, v6))
      {
        int v9 = 1;
        goto LABEL_9;
      }
    }

    else
    {
      __clrex();
    }

    int v9 = 0;
LABEL_9:
    unint64_t v7 = v8;
  }

  while (!v9);
  return (CFCharacterSetRef)Copy;
}

CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFMutableCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
}

void CFCharacterSetInvert(CFMutableCharacterSetRef theSet)
{
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet invert](theSet, "invert");
    return;
  }

  unint64_t v8 = (unint64_t *)((char *)theSet + 8);
  char v9 = atomic_load((unint64_t *)theSet + 1);
  if ((v9 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFCharacterSetInvert(CFMutableCharacterSetRef)");
  }

  char v10 = atomic_load(v8);
  if ((v10 & 0x70) != 0
    || (char v11 = atomic_load(v8), (v11 & 1) != 0)
    || (char v12 = atomic_load(v8), (v12 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    unint64_t v13 = atomic_load(v8);
    while (1)
    {
      unint64_t v14 = __ldaxr(v8);
      if (v14 != v13) {
        break;
      }
      if (__stlxr(v13 & 0xFFFFFFFFFFFFFFFBLL, v8)) {
        goto LABEL_15;
      }
      int v15 = 1;
LABEL_16:
      unint64_t v13 = v14;
      if (v15)
      {
        char v16 = atomic_load(v8);
        if ((v16 & 0x70) == 0x30LL)
        {
          uint64_t v17 = *((void *)theSet + 3);
          if (v17)
          {
            for (uint64_t i = 0LL; i != 0x2000; i += 16LL)
              *(int8x16_t *)(v17 + i) = vmvnq_s8(*(int8x16_t *)(v17 + i));
          }

          else
          {
            unint64_t v32 = CFGetAllocator(theSet);
            unint64_t v33 = CFAllocatorAllocate(v32, 0x2000LL, 0LL);
            *((void *)theSet + 3) = v33;
            memset(v33, 255, 0x2000uLL);
          }

LABEL_46:
            BOOL v31 = v29[13] == 0;
LABEL_47:
            v29[13] = v31;
            return;
          }

          continue;
        }
      }
    }

    __clrex();
LABEL_15:
    int v15 = 0;
    goto LABEL_16;
  }

    __CFCSetMakeBitmap((char *)v5);
    unint64_t v41 = atomic_load((unint64_t *)(v4 + 8));
    uint64_t v42 = v5[3];
    if ((v41 & 0x70) == 0x30LL)
    {
      uint64_t v43 = 0LL;
      uint64_t v44 = *(void *)(v4 + 24);
      do
      {
        *(_DWORD *)((char *)&v42->isa + v43) &= *(_DWORD *)(v44 + v43);
        v43 += 4LL;
      }

      while (v43 != 0x2000);
    }

    else
    {
      __CFCSetGetBitmap(v4, __b);
      for (uint64_t j = 0LL; j != 2048; ++j)
        *(_DWORD *)((char *)&v42->isa + j * 4) &= __b[0].u32[j];
    }

    int64_t v46 = atomic_load(v12);
    while (1)
    {
      uint64_t v47 = __ldaxr(v12);
      if (v47 != v46) {
        break;
      }
      if (__stlxr(v46 & 0xFFFFFFFFFFFFFFFBLL, v12)) {
        goto LABEL_57;
      }
      unint64_t v48 = 1;
LABEL_58:
      int64_t v46 = v47;
      if (v48)
      {
        unint64_t v49 = *(void *)(v4 + 40);
        if (v49 && *(_DWORD *)(v49 + 8))
        {
          CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(0LL);
          CFCharacterSetRef v51 = 0LL;
          CFTypeID v52 = 1LL;
          while (1)
          {
            unint64_t v53 = *(void *)(v4 + 40);
            if (v53)
            {
              unint64_t v54 = 1 << v52;
              if ((*(_DWORD *)(v53 + 8) & (1 << v52)) != 0
                && *(unsigned __int8 *)(v53 + 12) >= v52)
              {
                char v55 = *(__CFCharacterSet **)(*(void *)v53 + v51);
                if (v55) {
                  break;
                }
              }
            }

            int v60 = v5[5];
            if (v60)
            {
              unint64_t v61 = 1 << v52;
              if (((uint64_t)v60->superclass & (1 << v52)) != 0)
              {
                if (BYTE4(v60->superclass) >= v52)
                {
                  unint64_t v62 = *(CFMutableCharacterSetRef *)((char *)&v60->isa->isa + v51);
                  if (v62)
                  {
                    if (!BYTE5(v60->superclass))
                    {
                      CFRelease(v62);
                      CFIndex v77 = v5[5];
                      int64_t v78 = (uint64_t)v77->superclass & ~v61;
LABEL_114:
                      LODWORD(v77->superclass) = v78;
                      goto LABEL_121;
                    }

                    CFCharacterSetInvert(v62);
                    CFCharacterSetIntersect(v62, Mutable);
                    goto LABEL_112;
                  }
                }

                if (BYTE4(v60->superclass) >= v52
                  && *(__objc2_class **)((char *)&v60->isa->isa + v51))
                {
                  goto LABEL_121;
                }
              }

              if (!BYTE5(v60->superclass)) {
                goto LABEL_121;
              }
              if (BYTE4(v60->superclass) < v52)
              {
                BYTE4(v60->superclass) = v52;
                char v63 = v60->isa;
                uint64_t v64 = (malloc_zone_t *)CFGetAllocator(v5);
                if (v63) {
                  uint64_t v65 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v64, v5[5]->isa, v51 + 8, 0LL, 0LL);
                }
                else {
                  uint64_t v65 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v64, v51 + 8, 0LL);
                }
                int v60 = v5[5];
                v60->isa = v65;
              }

              if (((uint64_t)v60->superclass & v61) != 0)
              {
                unint64_t v74 = (CFMutableCharacterSetRef *)((char *)v60->isa + v51);
              }

              else
              {
                unsigned __int16 v75 = CFGetAllocator(v5);
                *(__objc2_class **)((char *)&v5[5]->isa->isa + v51) = (__objc2_class *)CFCharacterSetCreateMutable(v75);
                int v60 = v5[5];
                LODWORD(v60->superclass) |= v61;
                unint64_t v74 = (CFMutableCharacterSetRef *)((char *)v60->isa + 8 * v52 - 8);
              }

              unint64_t v62 = *v74;
              if (BYTE5(v60->superclass)) {
                CFCharacterSetInvert(*v74);
              }
              CFCharacterSetIntersect(v62, Mutable);
              uint64_t v76 = v5[5];
              if (!v76 || !BYTE5(v76->superclass)) {
                goto LABEL_121;
              }
LABEL_112:
              CFCharacterSetInvert(v62);
            }

  _CFAutoreleasePoolPop(v37);
  return v44 != 0;
}

  _CFAutoreleasePoolPop(v37);
  return v44 != 0;
}

    char v11 = *a5;
LABEL_47:
    *a3 = v7;
    *a5 = v11;
    return 1LL;
  }

  uint64_t v7 = *a3;
  if (a2 < 1) {
    goto LABEL_46;
  }
  char v12 = a2 + 1;
  char v11 = *a5;
  while (1)
  {
    unint64_t v14 = *a1++;
    unint64_t v13 = v14;
    int v15 = v14 >= 0x200000;
    if (v14 >= 0x200000) {
      char v16 = 65533;
    }
    else {
      char v16 = v13;
    }
    if (v15) {
      uint64_t v17 = 2;
    }
    else {
      uint64_t v17 = 4;
    }
    if (v13 < 0x10000)
    {
      char v16 = v13;
      uint64_t v17 = 3;
    }

    if (v13 < 0x800)
    {
      char v16 = v13;
      uint64_t v17 = 2;
    }

    if (v13 >= 0x80)
    {
      int64_t v18 = v17;
    }

    else
    {
      char v16 = v13;
      int64_t v18 = 1LL;
    }

    v11 += v18;
    if (!a4) {
      goto LABEL_37;
    }
    if (v11 > a4) {
      return 0LL;
    }
    char v19 = v7 + v18;
    switch((int)v18)
    {
      case 1:
        goto LABEL_35;
      case 2:
        goto LABEL_34;
      case 3:
        goto LABEL_33;
      case 4:
        *(_BYTE *)--char v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_33:
        *(_BYTE *)--char v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_34:
        *(_BYTE *)--char v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_35:
        *(_BYTE *)--char v19 = CFUniCharFillDestinationBuffer_firstByteMark[v18] | v16;
        break;
      default:
        break;
    }

    uint64_t v7 = v19 + v18;
LABEL_37:
  }

    unint64_t v23 = v20 | (v17 << 8);
    char v24 = (unsigned __int16 *)&__CFFromBig5CharMap;
    unint64_t v25 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + 28248);
    while (1)
    {
      uint64_t v26 = (0xF83E0F83E0F83E1LL * (v25 - v24)) >> 1;
      unint64_t v27 = &v24[33 * v26];
      int v28 = *v27;
      if (v28 <= v23)
      {
        if (v28 + 32 > v23)
        {
          uint64_t v29 = v24[33 * v26 + 1 + (int)(v23 - v28)];
          if (v29) {
            uint64_t v30 = v29 == 65533;
          }
          else {
            uint64_t v30 = 1;
          }
          if (v30) {
            return v13;
          }
          if (v14 != 64
            || (uint64_t v39 = v15,
                IsDecomposableCharacter_1 = __CFStringEncodingIsDecomposableCharacter_1(),
                int v15 = v39,
                unint64_t v14 = 64,
                !IsDecomposableCharacter_1))
          {
            if (a5) {
              *a4++ = v29;
            }
            char v12 = *a6;
LABEL_159:
            ++v12;
LABEL_160:
            int64_t v18 = 2LL;
LABEL_15:
            *a6 = v12;
            goto LABEL_16;
          }

          unint64_t v32 = __CFStringEncodingDecomposeCharacter_1( a1,  v29,  v40,  4279957629LL,  327680LL,  4282382460LL,  4278777983LL,  &jpt_180B36994);
          unint64_t v33 = *a6;
          char v12 = *a6 + v32;
          *a6 = v12;
          if (!a5) {
            goto LABEL_149;
          }
          if (v12 > a5)
          {
            *a6 = v33;
            return v13;
          }

          if (v32 < 1)
          {
LABEL_149:
            int64_t v18 = 2LL;
            unint64_t v14 = 64;
            int v15 = v39;
            goto LABEL_16;
          }

          int v34 = v32 + 1;
          uint64_t v35 = (__int16 *)v40;
          unint64_t v14 = 64;
          int v15 = v39;
          do
          {
            char v36 = *v35++;
            *a4++ = v36;
            --v34;
          }

          while (v34 > 1);
          int64_t v18 = 2LL;
LABEL_16:
          v13 += v18;
          a2 += v18;
          char v19 = (uint64_t)v9 <= v18;
          v9 -= v18;
          if (v19) {
            return v13;
          }
          goto LABEL_5;
        }

        char v24 = v27 + 33;
      }

      else
      {
        unint64_t v25 = v27 - 33;
      }

      if (v24 > v25) {
        return v13;
      }
    }
  }

  v12 += v15;
  if (!a5)
  {
LABEL_14:
    int64_t v18 = 1LL;
    goto LABEL_15;
  }

  if (v12 <= a5)
  {
    *a4 = 92;
    if ((a1 & 0x200) != 0)
    {
      int64_t v18 = 1LL;
      ++a4;
      goto LABEL_15;
    }

    a4[1] = -1921;
    a4 += 2;
    goto LABEL_14;
  }

  return v13;
}

    int v34 = v21 | (v13 << 8);
    uint64_t v35 = (unsigned __int16 *)&__CFEmojiIndexFromNTTDocomoSJIS;
    char v36 = (unsigned __int16 *)&unk_180D7C0AE;
    while (2)
    {
      uint64_t v37 = ((char *)v36 - (char *)v35) >> 3;
      uint64_t v38 = &v35[2 * v37];
      uint64_t v39 = *v38;
      if (v39 > v34)
      {
        char v36 = v38 - 2;
        goto LABEL_52;
      }

      if (v39 < v34)
      {
        uint64_t v35 = v38 + 2;
LABEL_52:
        if (v35 > v36) {
          return v12;
        }
        continue;
      }

      break;
    }

    uint64_t v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    unint64_t v41 = v40;
    if (!a5) {
      goto LABEL_57;
    }
    if (a5 - v11 < v40) {
      break;
    }
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    char v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2LL;
    a2 += 2;
    char v9 = v20;
  }

  while (v9 > 0);
  return v12;
}

    char v24 = 1LL;
    uint64_t v21 = v11;
LABEL_31:
    a2 += v24;
    v12 += v24;
    char v11 = v21;
  }

  while (v12 < v8);
LABEL_84:
  *a6 = v21;
  return v12;
}

    unint64_t v25 = 1LL;
    uint64_t v22 = v11;
LABEL_31:
    a2 += v25;
    v12 += v25;
    char v11 = v22;
  }

  while (v12 < v8);
LABEL_84:
  *a6 = v22;
  return v12;
}

    int v34 = v21 | (v13 << 8);
    uint64_t v35 = (unsigned __int16 *)&__CFEmojiIndexFromSoftBankSJIS;
    char v36 = (unsigned __int16 *)&unk_180D7DD46;
    while (2)
    {
      uint64_t v37 = ((char *)v36 - (char *)v35) >> 3;
      uint64_t v38 = &v35[2 * v37];
      uint64_t v39 = *v38;
      if (v39 > v34)
      {
        char v36 = v38 - 2;
        goto LABEL_52;
      }

      if (v39 < v34)
      {
        uint64_t v35 = v38 + 2;
LABEL_52:
        if (v35 > v36) {
          return v12;
        }
        continue;
      }

      break;
    }

    uint64_t v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    unint64_t v41 = v40;
    if (!a5) {
      goto LABEL_57;
    }
    if (a5 - v11 < v40) {
      break;
    }
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    char v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2LL;
    a2 += 2;
    char v9 = v20;
  }

  while (v9 > 0);
  return v12;
}

          if (*result == 43) {
            ++result;
          }
          return result;
        }

        switch((char)v19)
        {
          case '(':
            unint64_t v58 = v10[2];
            if (v10[2])
            {
              int v59 = 0LL;
              CFCharacterSetRef result = v10 + 3;
              do
              {
                if (v58 == 41)
                {
                  if (!v59) {
                    goto LABEL_41;
                  }
                  int v60 = -1LL;
                }

                else
                {
                  int v60 = v58 == 40;
                }

                v59 += v60;
                unint64_t v61 = *result++;
                unint64_t v58 = v61;
              }

              while (v61);
            }

            break;
          case '[':
            unint64_t v54 = v10[2];
            if (v10[2])
            {
              char v55 = 0LL;
              CFCharacterSetRef result = v10 + 3;
              do
              {
                if (v54 == 93)
                {
                  if (!v55) {
                    goto LABEL_41;
                  }
                  int v56 = -1LL;
                }

                else
                {
                  int v56 = v54 == 91;
                }

                v55 += v56;
                unint64_t v57 = *result++;
                unint64_t v54 = v57;
              }

              while (v57);
            }

            break;
          case '{':
            int v50 = v10[2];
            if (v10[2])
            {
              CFCharacterSetRef v51 = 0LL;
              CFCharacterSetRef result = v10 + 3;
              do
              {
                if (v50 == 125)
                {
                  if (!v51) {
                    goto LABEL_41;
                  }
                  CFTypeID v52 = -1LL;
                }

                else
                {
                  CFTypeID v52 = v50 == 123;
                }

                v51 += v52;
                unint64_t v53 = *result++;
                int v50 = v53;
              }

              while (v53);
            }

            break;
          default:
            CFCharacterSetRef result = (_BYTE *)((uint64_t (*)(void))__NSGetSizeAndAlignment)();
            if (result) {
              goto LABEL_41;
            }
            break;
        }

        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed pointed-to-type spec at '%s' in '%s'",  v9,  a4);
        goto LABEL_174;
      case 'v':
        goto LABEL_46;
      case '{':
        uint64_t v20 = "struct";
        uint64_t v21 = 125;
        uint64_t v22 = 1;
LABEL_66:
        if (a6 >= 0x200)
        {
LABEL_178:
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): type encoding string '%s' contains too many nesting levels",  a4);
          goto LABEL_174;
        }

        if (!*result) {
          goto LABEL_74;
        }
        int v28 = 0LL;
        uint64_t v29 = *result;
        uint64_t v30 = result;
        while (2)
        {
          if (v21 != (char)v29)
          {
            BOOL v31 = v29 == v11;
LABEL_73:
            v28 += v31;
            unint64_t v32 = *++v30;
            uint64_t v29 = v32;
            if (!v32)
            {
LABEL_74:
              CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed %s spec at '%s' in '%s'",  v20,  v9,  a4);
              goto LABEL_174;
            }

            continue;
          }

          break;
        }

        if (v28)
        {
          BOOL v31 = -1LL;
          goto LABEL_73;
        }

        unint64_t v33 = *result;
        int v34 = result;
        break;
      default:
        if ((_DWORD)v11) {
          goto LABEL_175;
        }
        return v10;
    }

    break;
  }

  while (v33 <= 60)
  {
    if (!v33 || v33 == 41) {
      goto LABEL_85;
    }
LABEL_82:
    if (v33) {
      ++v34;
    }
    unint64_t v33 = *v34;
  }

  if (v33 == 61) {
    goto LABEL_86;
  }
  if (v33 != 125) {
    goto LABEL_82;
  }
LABEL_85:
  unint64_t v33 = *result;
  int v34 = result;
LABEL_86:
  BOOL v69 = v9;
  if (v33 == 61) {
    CFCharacterSetRef result = v34 + 1;
  }
  else {
    CFCharacterSetRef result = v34;
  }
  if (result < v30)
  {
    uint64_t v35 = 0LL;
    char v36 = 0LL;
    while (1)
    {
      CFCharacterSetRef result = (_BYTE *)((uint64_t (*)(void))__NSGetSizeAndAlignment)();
      uint64_t v37 = v71;
      if (v36 <= v71) {
        char v36 = v71;
      }
      if (v71)
      {
        if (v22) {
          goto LABEL_95;
        }
      }

      else
      {
        int v71 = 1LL;
        uint64_t v37 = 1LL;
        if (v22)
        {
LABEL_95:
          if (v35 > ~v37 - v72)
          {
            CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): struct too large at '%s' in '%s'",  v69,  a4);
            char v63 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
            objc_exception_throw(v63);
            goto LABEL_185;
          }

          uint64_t v35 = v72 + (v37 + v35 - 1) / v37 * v37;
          goto LABEL_100;
        }
      }

      if (v35 <= v72) {
        uint64_t v35 = v72;
      }
LABEL_100:
      if (result >= v30) {
        goto LABEL_111;
      }
    }
  }

  char v36 = 0LL;
  uint64_t v35 = 0LL;
LABEL_111:
  if (result && *result) {
    ++result;
  }
  if (a3) {
    *a3 = v36;
  }
  if (v36 <= 1) {
    unint64_t v41 = 1LL;
  }
  else {
    unint64_t v41 = v36;
  }
  if (a2)
  {
    if (__CFADD__(v41, v35))
    {
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): struct or union too large at '%s' in '%s'",  v69,  a4);
      uint64_t v65 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
      objc_exception_throw(v65);
      goto LABEL_185;
    }

    *a2 = (v41 + v35 - 1) / v41 * v41;
  }

  if (result < v30) {
    goto LABEL_46;
  }
  return result;
}

        ;
      }
    }
  }

  free(v4);
  return v3;
}

            if (!v22) {
              return;
            }
            v44.int location = 0LL;
            v44.CFIndex length = location;
            unint64_t v23 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, v44);
            if (v18 == -1)
            {
              char v24 = 0LL;
            }

            else
            {
              v45.int location = v18;
              v45.CFIndex length = v17;
              char v24 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, v45);
            }

            if (v14 == -1)
            {
              unint64_t v25 = 0LL;
            }

            else
            {
              v48.int location = v14;
              v48.CFIndex length = v16;
              unint64_t v25 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, v48);
            }

            if (!((unint64_t)v24 | (unint64_t)v25))
            {
              char v24 = 0LL;
              goto LABEL_69;
            }

            if (v24)
            {
              if (v25)
              {
                if (_CFGetProductName_onceToken != -1) {
                  dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
                }
                uint64_t v26 = CFEqual((CFTypeRef)_CFGetProductName__cfBundlePlatform, v25);
                if (v26) {
                  uint64_t v26 = CFEqual(@"tvos", v24) != 0;
                }
LABEL_68:
                if (!v26)
                {
                  CFArrayAppendValue(a1[4], cf);
                  if (!v24) {
                    goto LABEL_77;
                  }
                  goto LABEL_76;
                }

char *_CFCharacterSetInitCopyingSet(char *allocator, char *cf, uint64_t a3, char a4)
{
  uint64_t v6 = (const __CFAllocator *)allocator;
  char v7 = atomic_load((unint64_t *)(a3 + 8));
  uint64_t v8 = v7 & 0x70;
  char v9 = (unint64_t *)(cf + 8);
  unint64_t v10 = atomic_load((unint64_t *)cf + 1);
  do
  {
    unint64_t v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 & 0xFFFFFFFFFFFFFF8FLL | v8, v9))
      {
        int v12 = 1;
        goto LABEL_7;
      }
    }

    else
    {
      __clrex();
    }

    int v12 = 0;
LABEL_7:
    unint64_t v10 = v11;
  }

  while (!v12);
  char v13 = atomic_load((unint64_t *)(a3 + 8));
  unint64_t v14 = atomic_load(v9);
  uint64_t v15 = v13 & 4;
  do
  {
    unint64_t v16 = __ldaxr(v9);
    if (v16 == v14)
    {
      if (!__stlxr(v14 & 0xFFFFFFFFFFFFFFFBLL | v15, v9))
      {
        int v17 = 1;
        goto LABEL_14;
      }
    }

    else
    {
      __clrex();
    }

    int v17 = 0;
LABEL_14:
    unint64_t v14 = v16;
  }

  while (!v17);
  char v18 = atomic_load((unint64_t *)(a3 + 8));
  unint64_t v19 = atomic_load(v9);
  uint64_t v20 = v18 & 8;
  do
  {
    unint64_t v21 = __ldaxr(v9);
    if (v21 == v19)
    {
      if (!__stlxr(v19 & 0xFFFFFFFFFFFFFFF7LL | v20, v9))
      {
        int v22 = 1;
        goto LABEL_21;
      }
    }

    else
    {
      __clrex();
    }

    int v22 = 0;
LABEL_21:
    unint64_t v19 = v21;
  }

  while (!v22);
  *((void *)cf + 2) = *(void *)(a3 + 16);
  unsigned int v23 = atomic_load((unint64_t *)(a3 + 8));
  switch((v23 >> 4) & 7)
  {
    case 0u:
      *((void *)cf + 3) = *(void *)(a3 + 24);
      goto LABEL_43;
    case 1u:
      *((_DWORD *)cf + 6) = *(_DWORD *)(a3 + 24);
      *((void *)cf + 4) = *(void *)(a3 + 32);
      goto LABEL_43;
    case 2u:
      char v24 = CFAllocatorAllocate((CFAllocatorRef)allocator, 128LL, 0LL);
      *((void *)cf + 3) = v24;
      *((void *)cf + 4) = *(void *)(a3 + 32);
      CFAllocatorRef allocator = (char *)memmove(v24, *(const void **)(a3 + 24), 2LL * *(void *)(a3 + 32));
      goto LABEL_43;
    case 3u:
      unint64_t v25 = *(unsigned __int8 **)(a3 + 24);
      if (v25)
      {
        if ((a4 & 1) == 0)
        {
          CFAllocatorRef allocator = (char *)__CFCreateCompactBitmap((const __CFAllocator *)allocator, v25);
          if (allocator)
          {
            *((void *)cf + 3) = allocator;
            unint64_t v26 = atomic_load((unint64_t *)cf + 1);
            while (1)
            {
              unint64_t v27 = __ldaxr(v9);
              if (v27 != v26) {
                break;
              }
              if (__stlxr(v26 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v9)) {
                goto LABEL_34;
              }
              char v28 = 1;
LABEL_35:
              unint64_t v26 = v27;
              if ((v28 & 1) != 0) {
                goto LABEL_43;
              }
            }

            __clrex();
LABEL_34:
            char v28 = 0;
            goto LABEL_35;
          }
        }

        uint64_t v43 = CFAllocatorAllocate(v6, 0x2000LL, 0LL);
        CFAllocatorRef allocator = (char *)memmove(v43, *(const void **)(a3 + 24), 0x2000uLL);
        *((void *)cf + 3) = v43;
      }

      else
      {
        *((void *)cf + 3) = 0LL;
      }

LABEL_43:
      uint64_t v44 = *(void *)(a3 + 40);
      if (!v44) {
        return allocator;
      }
      if (!*(_DWORD *)(v44 + 8))
      {
        if (*(_BYTE *)(v44 + 13))
        {
          CFAllocatorRef allocator = (char *)*((void *)cf + 5);
          if (!allocator) {
            goto LABEL_70;
          }
          goto LABEL_67;
        }

        return allocator;
      }

      uint64_t v45 = 0LL;
      uint64_t v46 = 1LL;
      break;
    case 4u:
      uint64_t v29 = *(char **)(a3 + 24);
      if (v29)
      {
        uint64_t v30 = 0LL;
        int32x4_t v31 = (int32x4_t)xmmword_180C336A0;
        int32x4_t v32 = 0uLL;
        v33.i64[0] = -1LL;
        v33.i64[1] = -1LL;
        v34.i64[0] = 0xFEFEFEFEFEFEFEFELL;
        v34.i64[1] = 0xFEFEFEFEFEFEFEFELL;
        v35.i64[0] = 0x2000000020LL;
        v35.i64[1] = 0x2000000020LL;
        int32x4_t v36 = 0uLL;
        int32x4_t v37 = 0uLL;
        do
        {
          int8x16_t v38 = (int8x16_t)vcgtq_u8(v34, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v29[v30], v33));
          int16x8_t v39 = vmovl_s8(*(int8x8_t *)v38.i8);
          int16x8_t v40 = vmovl_high_s8(v38);
          int32x4_t v37 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v40), (int8x16_t)vaddq_s32(v37, v35), (int8x16_t)v37);
          int32x4_t v36 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_s16(*(int16x4_t *)v40.i8),  (int8x16_t)vaddq_s32(v36, v35),  (int8x16_t)v36);
          int32x4_t v32 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v39), (int8x16_t)vaddq_s32(v32, v35), (int8x16_t)v32);
          int32x4_t v31 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_s16(*(int16x4_t *)v39.i8),  (int8x16_t)vaddq_s32(v31, v35),  (int8x16_t)v31);
          v30 += 16LL;
        }

        while (v30 != 256);
        size_t v41 = vaddvq_s32(vaddq_s32(vaddq_s32(v31, v36), vaddq_s32(v32, v37)));
        uint64_t v42 = CFAllocatorAllocate((CFAllocatorRef)allocator, v41, 0LL);
        CFAllocatorRef allocator = (char *)memmove(v42, v29, v41);
        *((void *)cf + 3) = v42;
      }

      goto LABEL_43;
    default:
      goto LABEL_43;
  }

  while (2)
  {
    uint64_t v47 = *(void *)(a3 + 40);
    if (v47)
    {
      int v48 = 1 << v46;
      if ((*(_DWORD *)(v47 + 8) & (1 << v46)) != 0
        && *(unsigned __int8 *)(v47 + 12) >= v46)
      {
        unint64_t v49 = *(const void **)(*(void *)v47 + v45);
        if (v49)
        {
          CFStringRef Copy = (const void *)__CFCharacterSetCreateCopy(v6, v49);
          CFCharacterSetRef v51 = (uint64_t *)*((void *)cf + 5);
          if (!v51)
          {
            char v55 = CFGetAllocator(cf);
            int v56 = CFAllocatorAllocate(v55, 16LL, 0LL);
            *((void *)cf + 5) = v56;
            v56[6] = v46;
            *((_DWORD *)v56 + 2) = 0;
            unint64_t v53 = (malloc_zone_t *)CFGetAllocator(cf);
            goto LABEL_55;
          }

          if (*((unsigned __int8 *)v51 + 12) < v46)
          {
            *((_BYTE *)v51 + 12) = v46;
            uint64_t v52 = *v51;
            unint64_t v53 = (malloc_zone_t *)CFGetAllocator(cf);
            if (v52)
            {
              unint64_t v54 = __CFSafelyReallocateWithAllocator(v53, **((void ***)cf + 5), v45 + 8, 0LL, 0LL);
              goto LABEL_56;
            }

        char v24 = 0LL;
        unint64_t v25 = *v5;
        if (v7 == 0xC000000000000007LL) {
          unint64_t v25 = 0LL;
        }
        unint64_t v26 = v25 ^ (unint64_t)a1;
        do
        {
          if ((v26 & 7) == *(_BYTE *)(v10 + v24)) {
            break;
          }
          ++v24;
        }

        while (v24 != 7);
        unint64_t v27 = v24 | v26;
        char v28 = v24 & 7;
        uint64_t v29 = (v27 >> 55) + 8;
        if (v28 == 7) {
          LODWORD(v28) = v29;
        }
        char v18 = 22LL;
        switch((int)v28)
        {
          case 0:
            goto LABEL_57;
          case 1:
            goto LABEL_58;
          case 2:
            goto LABEL_56;
          case 3:
            goto LABEL_19;
          case 4:
          case 5:
            goto LABEL_57;
          case 6:
            char v18 = 42LL;
            goto LABEL_19;
          default:
            if ((_DWORD)v28 == 20)
            {
LABEL_57:
              char v18 = 1LL;
              goto LABEL_19;
            }

            if ((_DWORD)v28 == 22)
            {
LABEL_56:
              char v18 = 7LL;
              goto LABEL_19;
            }

    if ((a1 & 0x10) == 0) {
      goto LABEL_47;
    }
    uint64_t v30 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    int32x4_t v31 = (unsigned __int16 *)&__CFToJISCharMap;
    int32x4_t v32 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      int8x16_t v33 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v32 - v31)) >> 1;
      uint8x16_t v34 = &v31[17 * v33];
      int32x4_t v35 = *v34;
      if (v35 > v30)
      {
        int32x4_t v32 = v34 - 17;
        goto LABEL_57;
      }

      if (v35 + 16 <= v30)
      {
        int32x4_t v31 = v34 + 17;
LABEL_57:
        if (v31 > v32) {
          goto LABEL_83;
        }
        continue;
      }

      break;
    }

    uint64_t v45 = (__int16)v31[17 * v33 + 1 + (int)(v30 - v35)];
    if (v45 < 1) {
      goto LABEL_83;
    }
    if (a5)
    {
      uint64_t v46 = -2LL;
      if (*(a4 - 1) == 61) {
        uint64_t v46 = -1LL;
      }
      uint64_t v47 = &a4[v46];
      int v48 = BYTE1(v45);
      unint64_t v49 = v45 & 0x7F;
      if ((v45 & 0x100) != 0) {
        int v50 = 31;
      }
      else {
        int v50 = 125;
      }
      CFCharacterSetRef v51 = v50 + v49;
      uint64_t v52 = (v48 + 479) >> 1;
      unint64_t v53 = v52 - 127;
      unint64_t v54 = (v52 - 127);
      if (v51 > 0x7E) {
        LOBYTE(v51) = v51 + 1;
      }
      char v55 = v52 - 63;
      if (v54 <= 0x9F) {
        char v55 = v53;
      }
      *uint64_t v47 = v55;
      v47[1] = v51;
    }

        CFRelease(v10);
        goto LABEL_44;
      }
    }

    CFRelease(v14);
LABEL_28:
    char v7 = 0LL;
    unint64_t v10 = 0LL;
    int v17 = 1;
    goto LABEL_29;
  }

  uint64_t v5 = CFGetTypeID(locale);
  if (v5 != CFLocaleGetTypeID())
  {
    int v12 = CFLocaleCopyCurrent();
    uint64_t v6 = CFDateFormatterCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v12,  kCFDateFormatterFullStyle,  kCFDateFormatterFullStyle);
    CFRelease(v12);
    if (v6) {
      goto LABEL_4;
    }
LABEL_15:
    char v7 = 0LL;
    goto LABEL_46;
  }

  uint64_t v6 = CFDateFormatterCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (CFLocaleRef)locale,  kCFDateFormatterFullStyle,  kCFDateFormatterFullStyle);
  if (!v6) {
    goto LABEL_15;
  }
LABEL_4:
  CFDateFormatterCreateStringWithDate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, (CFDateRef)self);
  char v7 = (NSString *)_CFAutoreleasePoolAddObject();
LABEL_45:
  CFRelease(v6);
LABEL_46:
  if (v7) {
    return v7;
  }
  else {
    return (NSString *)@"<description unavailable>";
  }
}

        if (v29 < v21 && v26 <= 0xF) {
          break;
        }
        if (v29 < v21) {
          int32x4_t v32 = v20;
        }
        else {
          int32x4_t v32 = v20 + 1;
        }
        mdict_rehashd((uint64_t)v78, v32);
        uint64_t v20 = (unint64_t)v9[1] >> 58;
        unint64_t v21 = __NSDictionarySizes_0[v20];
      }

      int8x16_t v33 = *(void **)(v24 + 8 * v29);
      uint8x16_t v34 = v24 + 8LL * v21;
      if ((v77 & 0x200000000000000LL) != 0) {
        [v78 willChangeValueForKey:a4];
      }
      int32x4_t v35 = *(void *)(v34 + 8 * v29);
      if (v33 == &___NSDictionaryM_DeletedMarker || v33 == 0LL)
      {
        if ((v75 & 0x80000000) != 0)
        {
          int32x4_t v37 = (id)[a4 copyWithZone:0];
        }

        else
        {
          int32x4_t v37 = a4;
          if (((unint64_t)a4 & 0x8000000000000000LL) == 0)
          {
            int8x16_t v38 = a4;
            int32x4_t v37 = a4;
          }
        }

        *(void *)(v24 + 8 * v29) = v37;
        *(void *)(v34 + 8 * v29) = v76;
        char v60 = v9[1];
        unint64_t v61 = (v60 + 0x100000000LL) & 0x1FFFFFF00000000LL;
        v9[1] = v61 | v60 & 0xFE000000FFFFFFFFLL;
      }

      else
      {
        *(void *)(v34 + 8 * v29) = v76;
      }

      if ((v77 & 0x200000000000000LL) != 0) {
        [v78 didChangeValueForKey:a4];
      }
      if (v35 >= 1) {

      }
      return;
    }

    goto LABEL_118;
  }

  CFLog( 3LL,  (uint64_t)@"*** CFDictionarySetValue(): attempt to use this function to set a key which is not copyable into a non-CFDictionary via toll-free bridging",  v14,  v15,  v16,  v17,  v18,  v19,  v74);
  int16x8_t v39 = v9[1];
  int16x8_t v40 = v39 >> 58;
  if (v39 >> 58)
  {
    LODWORD(v41) = __NSDictionarySizes_0[v40];
    if (((unint64_t)a3 & 0x8000000000000000LL) == 0) {
LABEL_61:
    }
      uint64_t v42 = a3;
  }

  else
  {
    v9[1] = v39 & 0x3FFFFFFFFFFFFFFLL | 0x400000000000000LL;
    unint64_t v62 = calloc(1uLL, 0x30uLL);
    if (!v62)
    {
LABEL_118:
      __break(1u);
LABEL_119:
      objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  @"key should be copyable",  0LL));
      -[__NSDictionaryM _mutate](v72, v73);
      return;
    }

    *char v9 = (uint64_t)v62;
    LODWORD(v4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
    LODWORD(v41) = 3;
  }

  CFIndex v77 = v9[1];
  while (1)
  {
    uint64_t v43 = *v9;
    uint64_t v44 = v41;
    uint64_t v45 = [a4 hash];
    uint64_t v46 = 0LL;
    if ((_DWORD)v41)
    {
      uint64_t v47 = v45 % v41;
      size_t v41 = v41;
      int v48 = v41;
      while (1)
      {
        unint64_t v49 = *(id *)(v43 + 8 * v47);
        if (!v49) {
          break;
        }
        if (v49 == &___NSDictionaryM_DeletedMarker)
        {
          ++v46;
          if (v48 == v44) {
            int v48 = v47;
          }
        }

        else if (v49 == a4 || ([v49 isEqual:a4] & 1) != 0)
        {
          int v48 = v47;
          goto LABEL_81;
        }

        if (v47 + 1 >= v44) {
          int v50 = v44;
        }
        else {
          int v50 = 0LL;
        }
        uint64_t v47 = v47 + 1 - v50;
        if (!--v41) {
          goto LABEL_81;
        }
      }

      if (v48 == v44) {
        int v48 = v47;
      }
    }

    else
    {
      int v48 = 0LL;
    }

LABEL_55:
            unint64_t v54 = CFAllocatorAllocate((CFAllocatorRef)v53, v45 + 8, 0LL);
LABEL_56:
            CFCharacterSetRef v51 = (uint64_t *)*((void *)cf + 5);
            *CFCharacterSetRef v51 = (uint64_t)v54;
          }

          if (((_DWORD)v51[1] & v48) != 0) {
            CFRelease(*(CFTypeRef *)(*v51 + v45));
          }
          if (Copy)
          {
            *(void *)(**((void **)cf + 5) + v45) = CFRetain(Copy);
            uint64_t v57 = *((void *)cf + 5);
            int v58 = *(_DWORD *)(v57 + 8) | v48;
          }

          else
          {
            uint64_t v57 = *((void *)cf + 5);
            int v58 = *(_DWORD *)(v57 + 8) & ~v48;
          }

          *(_DWORD *)(v57 + 8) = v58;
          CFRelease(Copy);
        }
      }
    }

    ++v46;
    v45 += 8LL;
    if (v46 != 17) {
      continue;
    }
    break;
  }

  uint64_t v59 = *(void *)(a3 + 40);
  if (v59)
  {
    CFAllocatorRef allocator = (char *)*((void *)cf + 5);
    if (*(_BYTE *)(v59 + 13))
    {
      if (allocator) {
        goto LABEL_67;
      }
LABEL_70:
      unint64_t v61 = CFGetAllocator(cf);
      CFAllocatorRef allocator = (char *)CFAllocatorAllocate(v61, 16LL, 0LL);
      *((void *)cf + 5) = allocator;
      *(void *)(allocator + 6) = 0LL;
      *(void *)CFAllocatorRef allocator = 0LL;
LABEL_67:
      char v60 = 1;
LABEL_74:
      allocator[13] = v60;
      return allocator;
    }
  }

  else
  {
    CFAllocatorRef allocator = (char *)*((void *)cf + 5);
  }

  if (allocator)
  {
    char v60 = 0;
    goto LABEL_74;
  }

  return allocator;
}

    ++a2;
    ++v12;
    unint64_t v11 = v19;
    if (v12 >= a3) {
      goto LABEL_171;
    }
  }

    if ((a1 & 8) != 0 || v12 < 1) {
      break;
    }
    if ((a1 & 0x10) == 0) {
      continue;
    }
    int32x4_t v32 = a6;
    int8x16_t v33 = __CFPrecomposeCharKorean(a2 - 1);
    if (!v33)
    {
      a6 = v32;
      break;
    }

    a6 = v32;
    if (v33 < 0xA1) {
      break;
    }
    char v13 = 0xF73Eu;
    uint8x16_t v34 = (unsigned __int16 *)&KSX1001_from_uni;
    int32x4_t v35 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
LABEL_64:
    int32x4_t v36 = (0xF83E0F83E0F83E1LL * (v35 - v34)) >> 1;
    int32x4_t v37 = &v34[33 * v36];
    int8x16_t v38 = *v37;
    if (v38 > v33)
    {
      int32x4_t v35 = v37 - 33;
      goto LABEL_68;
    }

    if (v38 + 32 <= v33)
    {
      uint8x16_t v34 = v37 + 33;
LABEL_68:
      if (v34 > v35) {
        break;
      }
      goto LABEL_64;
    }

    uint64_t v42 = v34[33 * v36 + 1 + (int)(v33 - v38)];
    if (v42) {
      uint64_t v43 = v42 == 65533;
    }
    else {
      uint64_t v43 = 1;
    }
    if (v43) {
      break;
    }
    if (v50) {
      uint64_t v44 = v11 + 1;
    }
    else {
      uint64_t v44 = v11;
    }
    if (!a5) {
      goto LABEL_89;
    }
    if (v44 > a5)
    {
      unint64_t v49 = v44 - 1;
      if (v50) {
        unint64_t v11 = v49;
      }
      break;
    }

    uint64_t v45 = -2LL;
    if (v50) {
      uint64_t v45 = -1LL;
    }
    uint64_t v46 = &a4[v45];
    *(_WORD *)uint64_t v46 = __rev16(v42);
    a4 = v46 + 2;
LABEL_89:
    int v50 = 0;
    ++a2;
    ++v12;
    unint64_t v11 = v44;
  }

  while (v12 < a3);
LABEL_97:
  *a6 = v11;
  return v12;
}

    if ((a1 & 8) != 0 || v12 < 1) {
      goto LABEL_103;
    }
    if ((a1 & 0x10) == 0)
    {
LABEL_58:
      if (v12 >= a3) {
        goto LABEL_103;
      }
      continue;
    }

    break;
  }

  int32x4_t v35 = a6;
  int32x4_t v36 = __CFPrecomposeCharKorean(a2 - 1);
  if (v36 <= 0xA0)
  {
    a6 = v35;
    goto LABEL_103;
  }

  char v13 = 0xF73Eu;
  int32x4_t v37 = (unsigned __int16 *)&KSX1001_from_uni;
  int8x16_t v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
  a6 = v35;
  while (2)
  {
    int16x8_t v39 = (0xF83E0F83E0F83E1LL * (v38 - v37)) >> 1;
    int16x8_t v40 = &v37[33 * v39];
    size_t v41 = *v40;
    if (v41 > v36)
    {
      int8x16_t v38 = v40 - 33;
      goto LABEL_80;
    }

    if (v41 + 32 <= v36)
    {
      int32x4_t v37 = v40 + 33;
LABEL_80:
      if (v37 > v38) {
        goto LABEL_103;
      }
      continue;
    }

    break;
  }

  uint64_t v42 = v37[33 * v39 + 1 + (int)(v36 - v41)];
  else {
    uint64_t v43 = 1;
  }
  if (v43
    || v42 >> 8 < 0xA1
    || v42 >> 8 == 255
    || v37[33 * v39 + 1 + (int)(v36 - v41)] < 0xA1u
    || v37[33 * v39 + 1 + (int)(v36 - v41)] == 255)
  {
    goto LABEL_103;
  }

  if (v48) {
    ++v11;
  }
  if (!a5)
  {
LABEL_52:
    int v48 = 0;
    goto LABEL_54;
  }

  if (v11 <= a5)
  {
    uint64_t v44 = -2LL;
    if (v48) {
      uint64_t v44 = -1LL;
    }
    uint64_t v45 = &a4[v44];
    *uint64_t v45 = BYTE1(v42);
    a4 = v45 + 2;
    v45[1] = v42;
    goto LABEL_52;
  }

_OWORD *__CFCreateCompactBitmap(const __CFAllocator *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = 0LL;
  int v4 = 0;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a2;
  do
  {
    int v6 = *v5;
    if ((v6 + 1) <= 1u)
    {
      unsigned int v7 = 32;
      uint64_t v8 = 1LL;
      while (v5[v8] == v6)
      {
        --v7;
        ++v8;
        if (v7 <= 1)
        {
          __src[v3] = v6;
          goto LABEL_9;
        }
      }
    }

    __src[v3] = v4 + 1;
    if (v4++ > 127) {
      return 0LL;
    }
LABEL_9:
    v5 += 32;
    ++v3;
  }

  while (v3 != 256);
  unint64_t v10 = CFAllocatorAllocate(a1, 32 * v4 + 256, 0LL);
  uint64_t v15 = v10;
  if (v4 < 1)
  {
    memmove(v10, __src, 0x100uLL);
  }

  else
  {
    uint64_t v11 = 0LL;
    int v12 = v10 + 16;
    do
    {
      int v13 = __src[v11];
      *((_BYTE *)v10 + v11) = v13;
      if (v13 && v13 != 255)
      {
        __int128 v14 = v2[1];
        *int v12 = *v2;
        v12[1] = v14;
        v12 += 2;
      }

      v2 += 2;
      ++v11;
    }

    while (v11 != 256);
  }

  return v15;
}

char *__CFCharacterSetCreateCopy(CFAllocatorRef alloc, unint64_t *cf, char a3, int a4)
{
  if ((a3 & 1) == 0)
  {
    char v8 = atomic_load(cf + 1);
    if ((v8 & 1) == 0) {
      return (char *)CFRetain(cf);
    }
  }

  CFMutableCharacterSetRef Mutable = (char *)CFCharacterSetCreateMutable(alloc);
  _CFCharacterSetInitCopyingSet((char *)alloc, Mutable, (uint64_t)cf, a3);
  return Mutable;
}

CFCharacterSetRef CFCharacterSetCreateCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 0, 1);
}

char *_CFCharacterSetCreateCopy(const __CFAllocator *a1, unint64_t *a2)
{
  return __CFCharacterSetCreateCopy(a1, a2, 0, 0);
}

char *_CFCharacterSetCreateMutableCopy(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableCharacterSetRef Mutable = (char *)CFCharacterSetCreateMutable(a1);
  _CFCharacterSetInitCopyingSet((char *)a1, Mutable, a2, 1);
  return Mutable;
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  uint64_t v2 = theChar;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    LOBYTE(v4) = -[__CFCharacterSet longCharacterIsMember:](theSet, "longCharacterIsMember:", v2);
  }

  else
  {
    unsigned int v6 = atomic_load((unint64_t *)theSet + 1);
    unsigned int v7 = atomic_load((unint64_t *)theSet + 1);
    int v4 = (v6 >> 3) & 1;
    switch((v7 >> 4) & 7)
    {
      case 0u:
        v4 ^= CFUniCharIsMemberOf(v2, *((_DWORD *)theSet + 6));
        break;
      case 1u:
        uint64_t v18 = *((void *)theSet + 4);
        if (v18)
        {
          uint64_t v19 = *((unsigned int *)theSet + 6);
          char v20 = v4 ^ (v18 + v19 > v2);
        }

        break;
      case 2u:
        uint64_t v8 = *((void *)theSet + 4);
        if (v8)
        {
          char v9 = (unsigned __int16 *)*((void *)theSet + 3);
          if (*v9 <= v2)
          {
            unint64_t v10 = &v9[v8];
            unsigned int v12 = *(v10 - 1);
            uint64_t v11 = v10 - 1;
            if (v12 >= v2 && v8 >= 1)
            {
              while (1)
              {
                __int128 v14 = &v9[((char *)v11 - (char *)v9) >> 2];
                unsigned int v15 = *v14;
                if (v15 <= v2)
                {
                  if (v15 >= v2)
                  {
                    LOBYTE(v4) = v4 ^ 1;
                    return v4;
                  }

                  char v9 = v14 + 1;
                }

                else
                {
                  uint64_t v11 = v14 - 1;
                }

                if (v9 > v11) {
                  return v4;
                }
              }
            }
          }
        }

        break;
      case 3u:
        uint64_t v21 = *((void *)theSet + 3);
        if (v21)
        {
          unsigned int v22 = *(unsigned __int8 *)(v21 + ((unint64_t)v2 >> 3));
          goto LABEL_29;
        }

        break;
      case 4u:
        uint64_t v16 = *((void *)theSet + 3);
        if (v16)
        {
          uint64_t v17 = *(unsigned __int8 *)(v16 + ((unint64_t)v2 >> 8));
          if ((_DWORD)v17 == 255)
          {
            LOBYTE(v4) = 1;
          }

          else
          {
            unsigned int v22 = *(unsigned __int8 *)(v16 + 32 * v17 + ((unint64_t)(v2 & 0xF8) >> 3) + 224);
LABEL_29:
            int v4 = (v22 >> (v2 & 7)) & 1;
          }
        }

        break;
      default:
LABEL_22:
        LOBYTE(v4) = 0;
        break;
    }
  }

  return v4;
}

uint64_t _CFCharacterSetIsLongCharacterMember(uint64_t a1, unsigned int a2)
{
  if (BYTE2(a2))
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x70) == 0)
    {
      unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
      return (v10 >> 3) & 1 ^ CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
    }

    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      uint64_t v4 = *(_BYTE *)(v3 + 13) != 0;
      unsigned int v5 = *(_DWORD *)(v3 + 8);
      if (BYTE2(a2) <= 0x10u
        && ((v5 >> SBYTE2(a2)) & 1) != 0
        && *(unsigned __int8 *)(v3 + 12) >= BYTE2(a2))
      {
        uint64_t v6 = *(void *)(*(void *)v3 + 8LL * (BYTE2(a2) - 1));
        if (v6)
        {
          a2 = (unsigned __int16)a2;
          a1 = v6;
          goto LABEL_10;
        }
      }

      if (v5) {
        return v4;
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    char v11 = atomic_load((unint64_t *)(a1 + 8));
    if ((v11 & 0x70) == 0x10LL)
    {
      unsigned int v12 = atomic_load((unint64_t *)(a1 + 8));
      uint64_t v4 = (v12 >> 3) & 1;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        uint64_t v14 = *(unsigned int *)(a1 + 24);
      }
    }

    return v4;
  }

  LODWORD(v4) = 0;
LABEL_10:
  unsigned int v7 = atomic_load((unint64_t *)(a1 + 8));
  unsigned int v8 = atomic_load((unint64_t *)(a1 + 8));
  int v9 = (v7 >> 3) & 1;
  switch((v8 >> 4) & 7)
  {
    case 0u:
      v9 ^= CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
      return v4 ^ v9;
    case 1u:
      uint64_t v25 = *(void *)(a1 + 32);
      if (v25)
      {
        uint64_t v26 = *(unsigned int *)(a1 + 24);
      }

      return v4 ^ v9;
    case 2u:
      uint64_t v15 = *(void *)(a1 + 32);
      if (!v15) {
        return v4 ^ v9;
      }
      uint64_t v16 = *(unsigned __int16 **)(a1 + 24);
      uint64_t v17 = &v16[v15];
      unsigned int v19 = *(v17 - 1);
      uint64_t v18 = v17 - 1;
      break;
    case 3u:
      uint64_t v27 = *(void *)(a1 + 24);
      if (!v27) {
        return v4 ^ v9;
      }
      unsigned int v28 = *(unsigned __int8 *)(v27 + ((unsigned __int16)a2 >> 3));
      goto LABEL_44;
    case 4u:
      uint64_t v23 = *(void *)(a1 + 24);
      if (!v23) {
        return v4 ^ v9;
      }
      uint64_t v24 = *(unsigned __int8 *)(v23 + BYTE1(a2));
      if (*(_BYTE *)(v23 + BYTE1(a2)))
      {
        if ((_DWORD)v24 == 255)
        {
          int v9 = 1;
        }

        else
        {
          unsigned int v28 = *(unsigned __int8 *)(v23 + 32 * v24 + (a2 >> 3) + 224);
LABEL_44:
          int v9 = (v28 >> (a2 & 7)) & 1;
        }
      }

      else
      {
        int v9 = 0;
      }

      return v4 ^ v9;
    default:
      return 0LL;
  }

  while (1)
  {
    uint64_t v21 = &v16[((char *)v18 - (char *)v16) >> 2];
    unsigned int v22 = *v21;
    uint64_t v18 = v21 - 1;
LABEL_30:
    if (v16 > v18) {
      return v4 ^ v9;
    }
  }

  if (v22 < (unsigned __int16)a2)
  {
    uint64_t v16 = v21 + 1;
    goto LABEL_30;
  }

  int v9 = (v7 & 8) == 0;
  return v4 ^ v9;
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  uint64_t v2 = *(void *)&theChar;
  else {
    return _CFCharacterSetIsLongCharacterMember((uint64_t)theSet, v2);
  }
}

uint64_t CFCharacterSetIsSurrogatePairMember(const __CFCharacterSet *a1, int a2, int a3)
{
  return CFCharacterSetIsLongCharacterMember(a1, a3 + (a2 << 10) - 56613888);
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  uint64_t v2 = (__objc2_class **)MEMORY[0x1895F8858](theSet, theOtherset);
  uint64_t v4 = v3;
  unsigned int v5 = (unint64_t *)v2;
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    uint64_t v6 = [v5 _expandedCFCharacterSet];
    if (!v6) {
      goto LABEL_47;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    uint64_t v7 = [v4 _expandedCFCharacterSet];
    if (!v7) {
      goto LABEL_47;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if (v6) {
    unsigned int v5 = (unint64_t *)v6;
  }
  if (v7) {
    uint64_t v4 = (unint64_t *)v7;
  }
  unint64_t v8 = v5[5];
  if (!v8 || !*(_DWORD *)(v8 + 8) && !*(_BYTE *)(v8 + 13))
  {
    unsigned int v9 = atomic_load(v5 + 1);
    switch((v9 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v5[4]) {
          goto LABEL_18;
        }
        break;
      case 3u:
      case 4u:
        if (v5[3]) {
          goto LABEL_18;
        }
        break;
      default:
        goto LABEL_18;
    }

    char v12 = atomic_load(v5 + 1);
    if ((v12 & 8) == 0)
    {
      unint64_t v13 = v4[5];
      if (!v13 || !*(_DWORD *)(v13 + 8) && !*(_BYTE *)(v13 + 13))
      {
        unsigned int v14 = atomic_load(v4 + 1);
        switch((v14 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (v4[4]) {
              goto LABEL_103;
            }
            break;
          case 3u:
          case 4u:
            if (v4[3]) {
              goto LABEL_103;
            }
            break;
          default:
            goto LABEL_103;
        }

        char v59 = atomic_load(v4 + 1);
        if ((v59 & 8) == 0) {
          goto LABEL_47;
        }
      }

LABEL_103:
      LOBYTE(IsEqualBitmap) = 0;
      return IsEqualBitmap;
    }

    goto LABEL_97;
  }

  *a6 = v11;
  return v12;
}

LABEL_18:
  unint64_t v10 = v4[5];
  if (!v10 || !*(_DWORD *)(v10 + 8) && !*(_BYTE *)(v10 + 13))
  {
    unsigned int v11 = atomic_load(v4 + 1);
    switch((v11 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v4[4]) {
          goto LABEL_34;
        }
        break;
      case 3u:
      case 4u:
        if (v4[3]) {
          goto LABEL_34;
        }
        break;
      default:
        goto LABEL_34;
    }

    char v15 = atomic_load(v4 + 1);
    if ((v15 & 8) == 0) {
      goto LABEL_97;
    }
  }

  if (!CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    unsigned __int8 v27 = 0LL;
    goto LABEL_34;
  }

  unsigned __int8 v27 = [(id)v4 _expandedCFCharacterSet];
  if (v27)
  {
LABEL_34:
    if (v27) {
      uint64_t v4 = v27;
    }
    int64_t v37 = *(void *)(v4 + 40);
    if (!v37 || !*(_DWORD *)(v37 + 8) && !*(_BYTE *)(v37 + 13))
    {
      int64_t v38 = atomic_load((unint64_t *)(v4 + 8));
      switch((v38 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v4 + 32)) {
            goto LABEL_41;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(v4 + 24)) {
            goto LABEL_41;
          }
          break;
        default:
          goto LABEL_41;
      }

      __int32 v55 = atomic_load((unint64_t *)(v4 + 8));
      if ((v55 & 8) == 0)
      {
LABEL_196:
        if (__CFCheckForExapendedSet == 1) {
          __CFCheckForExpandedSet((const char *)v5, v20, v21, v22, v23, v24, v25, v26);
        }
        return;
      }

      uint64_t v56 = atomic_load(v12);
      if ((v56 & 0x70) == 0x20LL && v5[3]
        || (int64_t v57 = atomic_load(v12), (v57 & 0x70) == 0x30LL) && v5[3]
        || (uint64_t v58 = atomic_load(v12), (v58 & 0x70) == 0x40LL) && v5[3])
      {
        char v59 = CFGetAllocator(v5);
        CFAllocatorDeallocate(v59, v5[3]);
      }

      char v60 = atomic_load(v12);
      while (1)
      {
        uint64_t v61 = __ldaxr(v12);
        if (v61 != v60) {
          break;
        }
        if (__stlxr(v60 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v12)) {
          goto LABEL_75;
        }
        unint64_t v62 = 1;
LABEL_76:
        char v60 = v61;
        if (v62)
        {
          v5[4] = 0LL;
          char v63 = atomic_load((unint64_t *)v5 + 1);
          while (1)
          {
            uint64_t v64 = __ldaxr(v12);
            if (v64 != v63) {
              break;
            }
            if (__stlxr(v63 | 8, v12)) {
              goto LABEL_82;
            }
            uint64_t v65 = 1;
LABEL_83:
            char v63 = v64;
            if (v65)
            {
              unint64_t v66 = atomic_load(v12);
              while (1)
              {
                unint64_t v67 = __ldaxr(v12);
                if (v67 != v66) {
                  break;
                }
                if (__stlxr(v66 & 0xFFFFFFFFFFFFFFFBLL, v12)) {
                  goto LABEL_89;
                }
                char v68 = 1;
LABEL_90:
                unint64_t v66 = v67;
                if (v68)
                {
                  if (v5[5])
                  {
                    for (uint64_t i = 0LL; i != 16; ++i)
                    {
                      unint64_t v70 = v5[5];
                      if (((LODWORD(v70->superclass) >> i) & 2) != 0) {
                        CFRelease(*((CFTypeRef *)&v70->isa->isa + i));
                      }
                    }

                    int v71 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v71, v5[5]->isa);
                    uint64_t v72 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v72, v5[5]);
                    uint64_t v5[5] = 0LL;
                  }

                  goto LABEL_196;
                }
              }

              __clrex();
LABEL_89:
              char v68 = 0;
              goto LABEL_90;
            }
          }

          __clrex();
LABEL_82:
          uint64_t v65 = 0;
          goto LABEL_83;
        }
      }

      __clrex();
LABEL_75:
      unint64_t v62 = 0;
      goto LABEL_76;
    }

  uint64_t v25 = (const __CFDate *)*((void *)formatter + 15);
  if (v25)
  {
    AbsoluteTime = CFDateGetAbsoluteTime(v25);
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, (AbsoluteTime + 978307200.0) * 1000.0);
  }

  __cficu_udat_parseCalendar((uint64_t)v17, (uint64_t)v19, v16, v11, (unsigned int *)&v61 + 1, (int *)&v61);
  Millis = __cficu_ucal_getMillis((uint64_t)v19, (int *)&v61);
  if (rangep) {
    rangep->CFIndex length = SHIDWORD(v61);
  }
  valuePtr[0] = 1LL;
  unsigned __int8 v28 = (const __CFNumber *)*((void *)formatter + 37);
  if (v28) {
    CFNumberGetValue(v28, kCFNumberSInt64Type, valuePtr);
  }
  if (CFEqual(v20, @"chinese"))
  {
    switch(valuePtr[0])
    {
      case 0LL:
        goto LABEL_74;
      case 2LL:
        char v29 = __cficu_ucal_getNow();
        __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v29);
        char v30 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
        goto LABEL_66;
      case 3LL:
        int v43 = (uint64_t)v19;
        uint64_t v44 = Millis;
        __int32 v45 = 60LL;
        __int32 v46 = 29LL;
        int v47 = 30LL;
        break;
      case 4LL:
        int v43 = (uint64_t)v19;
        uint64_t v44 = Millis;
        __int32 v45 = 60LL;
        __int32 v46 = 0LL;
        int v47 = 59LL;
        break;
      case 5LL:
        int v43 = (uint64_t)v19;
        uint64_t v44 = Millis;
        __int32 v45 = 60LL;
        __int32 v46 = 59LL;
        int v47 = 0LL;
        break;
      case 6LL:
        int v43 = (uint64_t)v19;
        uint64_t v44 = Millis;
        __int32 v45 = 60LL;
        __int32 v46 = 10LL;
        int v47 = 49LL;
        break;
      case 7LL:
        int v43 = (uint64_t)v19;
        uint64_t v44 = Millis;
        __int32 v45 = 60LL;
        __int32 v46 = 49LL;
        int v47 = 10LL;
        break;
      default:
        goto LABEL_73;
    }

    uint64_t v48 = 1;
LABEL_45:
    unint64_t v49 = __CFDateFormatterCorrectTimeToARangeAroundCurrentDate(v43, v45, v46, v47, v48, (int *)&v61, v44);
  }

  else if (CFEqual(v20, @"japanese"))
  {
    __cficu_ucal_clear((uint64_t)v19);
    __cficu_ucal_set((uint64_t)v19, 0, 1);
    __cficu_udat_parseCalendar((uint64_t)v17, (uint64_t)v19, v16, v11, 0LL, (int *)&v61);
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, Millis);
    int32x4_t v31 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    char v32 = __cficu_ucal_getNow();
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v32);
    char v33 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    unint64_t v34 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
    char v30 = v34;
    switch(valuePtr[0])
    {
      case 0LL:
        goto LABEL_74;
      case 2LL:
        goto LABEL_66;
      case 4LL:
        if (v31 < v33) {
          goto LABEL_74;
        }
        goto LABEL_66;
      case 5LL:
        if (v31 <= v33) {
          goto LABEL_66;
        }
        if (v34 < 235) {
          goto LABEL_74;
        }
        unint64_t v51 = (v34 - 1);
        break;
      case 6LL:
        if (v31 < v33 - 10) {
          goto LABEL_74;
        }
        goto LABEL_66;
      case 7LL:
        if (v31 <= v33 + 10)
        {
LABEL_66:
          unint64_t v53 = (uint64_t)v19;
          __int32 v54 = Millis;
          goto LABEL_67;
        }

        if (v34 < 235) {
          goto LABEL_74;
        }
        unint64_t v51 = (v34 - 1);
        do
        {
          uint64_t v52 = v51-- < 235;
        }

        while (!v52);
        goto LABEL_74;
      default:
        goto LABEL_73;
    }

    while (v31 > (int)__CFDateFormatterGetMaxYearGivenJapaneseEra((uint64_t)v19, v51, (int *)&v61))
    {
      uint64_t v52 = v51-- < 235;
      if (v52) {
        goto LABEL_74;
      }
    }

  if (!CFURLGetFileSystemRepresentation(v7, 1u, v52, 1024LL))
  {
    if ((v19 & 1) != 0) {
      return 0LL;
    }
    int v40 = v12;
LABEL_90:
    CFRelease(v40);
    return 0LL;
  }

  unint64_t v8 = v52;
  unint64_t v10 = strlen((const char *)v52);
LABEL_20:
  __int32 v46 = v19;
  if (__CFProphylacticAutofsAccess) {
    __int32 v45 = open("/dev/autofs_nowait", 0);
  }
  else {
    __int32 v45 = -1;
  }
  unsigned __int8 v20 = opendir((const char *)v8);
  if (!v20)
  {
    if ((v19 & 1) == 0) {
      CFRelease(v12);
    }
    if (v45 != -1) {
      close(v45);
    }
    return 0LL;
  }

  unsigned __int8 v21 = v20;
  CFMutableDictionaryRef cf = v12;
  CFMutableCharacterSetRef Mutable = CFArrayCreateMutable(v9, 0LL, &kCFTypeArrayCallBacks);
  if (!readdir_r(v21, &v51, &v47))
  {
    bufLen = v10;
    char v23 = v47;
    if (v47)
    {
      uint64_t v44 = 0;
      while (1)
      {
        uint64_t v24 = strlen(v23->d_name);
        if (v23->d_name[0] != 46 || v24 != 1 && (v24 != 2 || v23->d_name[1] != 46))
        {
          uint64_t v25 = usedBufLen;
          if (usedBufLen <= v24)
          {
            if (usedBufLen < 1) {
              goto LABEL_52;
            }
            if (v23->d_name[v24 - 1] != 46)
            {
              d_name = v23->d_name;
              if (!v18)
              {
                char v30 = strrchr(d_name, 46);
                goto LABEL_47;
              }

              unsigned __int8 v27 = strchr(d_name, 46);
              if (v27)
              {
                do
                {
                  unsigned __int8 v28 = 0;
                  char v29 = v27;
                  while (1)
                  {
                    char v29 = strchr(v29, 46);
                    if (!v29) {
                      break;
                    }
                    if (v18 == ++v28)
                    {
                      unsigned __int8 v28 = v18;
                      break;
                    }
                  }

                  if (v28 == v18) {
                    char v30 = v27;
                  }
                  else {
                    char v30 = 0LL;
                  }
                  int32x4_t v31 = strchr(v27, 46);
                  if (!v31) {
                    break;
                  }
                  unsigned __int8 v27 = v31;
                }

                while (!v30);
LABEL_47:
                if (!v30) {
                  goto LABEL_69;
                }
                if (buffer != 46) {
                  ++v30;
                }
LABEL_52:
                if (!v7)
                {
                  uint64_t v44 = 1;
                  uint64_t v7 = CFURLCreateFromFileSystemRepresentation(v9, v8, bufLen, 1u);
                  char v23 = v47;
                }

                char v32 = ((v23->d_type >> 1) | (v23->d_type << 7));
                char v33 = v32 > 7;
                unint64_t v34 = (1 << v32) & 0xA5;
                if (v33 || v34 == 0)
                {
                  int64_t v36 = 0;
                }

                else if (v23->d_type == 4)
                {
                  int64_t v36 = 1;
                }

                else
                {
                  __strlcpy_chk();
                  __strlcat_chk();
                  __strlcat_chk();
                  if (stat(v50, &v49)) {
                    int64_t v37 = 0;
                  }
                  else {
                    int64_t v37 = (v49.st_mode & 0xF000) == 0x4000;
                  }
                  int64_t v36 = v37;
                  char v23 = v47;
                }

                int64_t v38 = CFURLCreateFromFileSystemRepresentationRelativeToBase( v9,  (const UInt8 *)v23->d_name,  v23->d_namlen,  v36,  v7);
                CFArrayAppendValue(Mutable, v38);
                CFRelease(v38);
              }
            }
          }
        }

        uint64_t v7 = (dispatch_source_s *)*((void *)port + 3);
        if (v7)
        {
          dispatch_source_cancel(v7);
          *((void *)port + 3) = 0LL;
        }

        uint64_t v3 = (__CFRunLoopSource *)*((void *)port + 5);
        *((void *)port + 5) = 0LL;
      }

      os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      if (!v2)
      {
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        unint64_t v8 = (void (*)(CFMachPortRef, uint64_t))*((void *)port + 4);
        unsigned int v9 = *((void *)port + 8);
        unint64_t v10 = (void (*)(uint64_t))*((void *)port + 14);
        *((void *)port + 8) = 0LL;
        if (v8)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          v8(port, v9);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }

        if (v3)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          CFRunLoopSourceInvalidate(v3);
          CFRelease(v3);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }

        if (v10)
        {
          if (v9)
          {
            os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
            v10(v9);
            os_unfair_lock_lock((os_unfair_lock_t)port + 24);
          }
        }

        *((_DWORD *)port + 4) = 2;
        __dmb(0xBu);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      }

      CFRelease(port);
    }
  }

  char v18 = CFDataGetLength(v20);
  CFRelease(v20);
  return v18;
}

    unsigned int v14 = 0;
    unint64_t v13 = v10 >= 8 && (v11 & 0x800) == 0;
LABEL_21:
    char v15 = v7 & v10 & 3;
    char v16 = v11 & 0x100;
    char v17 = v16 == 0;
    char v18 = v16 >> 8;
    char v19 = v15 == 0;
    if (v15) {
      unsigned __int8 v20 = v17;
    }
    else {
      unsigned __int8 v20 = 0;
    }
    if (v19) {
      LOBYTE(v18) = 1;
    }
    unsigned __int8 v21 = v8 == 0;
    if (v8) {
      char v22 = v20;
    }
    else {
      char v22 = 0;
    }
    if (v21) {
      char v23 = 1;
    }
    else {
      char v23 = v18;
    }
    if (v14 || v13 || v22)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      if (v14 || v13)
      {
        if (a3)
        {
          uint64_t v24 = (const __CFArray *)__CFWriteSockets;
          v41.CFIndex length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
          v41.int location = 0LL;
        }

        uint64_t v25 = *(unsigned int *)(a1 + 152);
        if ((v25 & 0x80000000) == 0)
        {
          uint64_t v26 = (__CFData *)__CFWriteSocketsFds;
          unsigned __int8 v27 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
          if ((uint64_t)v27 <= v25)
          {
            char v29 = v27 >> 5;
            char v30 = 4 * (((unint64_t)(v25 + 32) >> 5) - (v27 >> 5));
            CFDataIncreaseLength(v26, v30);
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
            bzero(&MutableBytePtr[4 * v29], v30);
          }

          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
          }

          if (!__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v25 >> 3) & 0x1FFFFFFC] >> v25) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1)) {
              *(_DWORD *)&MutableBytePtr[4 * (v25 >> 5)] |= 1 << v25;
            }
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              int64_t v38 = 119;
              send(__CFWakeupSocketPair, &v38, 1uLL, 0);
            }
          }
        }
      }

      if ((v23 & 1) == 0)
      {
        if (a3)
        {
          int32x4_t v31 = (const __CFArray *)__CFReadSockets;
          v42.CFIndex length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
          v42.int location = 0LL;
        }

        __CFReadSocketsTimeoutInvalid = 0;
        char v32 = *(unsigned int *)(a1 + 152);
        if ((v32 & 0x80000000) == 0)
        {
          char v33 = (__CFData *)__CFReadSocketsFds;
          unint64_t v34 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
          if ((uint64_t)v34 <= v32)
          {
            int64_t v36 = v34 >> 5;
            int64_t v37 = 4 * (((unint64_t)(v32 + 32) >> 5) - (v34 >> 5));
            CFDataIncreaseLength(v33, v37);
            int v35 = CFDataGetMutableBytePtr(v33);
            bzero(&v35[4 * v36], v37);
          }

          else
          {
            int v35 = CFDataGetMutableBytePtr(v33);
          }

          if (!__darwin_check_fd_set_overflow(v32, v35, 1)
            || ((*(_DWORD *)&v35[((unint64_t)v32 >> 3) & 0x1FFFFFFC] >> v32) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v32, v35, 1)) {
              *(_DWORD *)&v35[4 * (v32 >> 5)] |= 1 << v32;
            }
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              unint64_t v39 = 114;
              send(__CFWakeupSocketPair, &v39, 1uLL, 0);
            }
          }
        }
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    }
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    if (v12)
    {
      if (v13)
      {
        CFRetain((CFTypeRef)v12);
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___signalEventQueue_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = v12;
        dispatch_async(v13, block);
        dispatch_release(v13);
      }

      else
      {
        _signalEventSync(v12);
      }

      CFRelease((CFTypeRef)v12);
    }
  }

  else
  {
    CFLog(3LL, (uint64_t)@"Expected an array for %p", v3, v4, v5, v6, v7, v8, (uint64_t)a1);
  }

    char v19 = v7;
    unsigned __int8 v20 = _os_log_pack_size();
    char v22 = (char *)v26 - ((MEMORY[0x1895F8858](v20, v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    char v23 = _os_log_pack_fill();
    uint64_t v24 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0(v23, (uint64_t)"-[NSArray subarrayWithRange:]", location, length, --v19);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v24,  "-[NSArray subarrayWithRange:]",  location,  length,  v19);
    uint64_t v25 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v22,  v20);
    objc_exception_throw(v25);
    goto LABEL_19;
  }

  if (!__cf_tsanReadFunction)
  {
    if (length) {
      goto LABEL_6;
    }
    return +[NSArray array](&OBJC_CLASS___NSArray, "array");
  }

  __cf_tsanReadFunction(self, v3, __CFTSANTagMutableArray);
  if (!length) {
    return +[NSArray array](&OBJC_CLASS___NSArray, "array");
  }
LABEL_6:
  if (length >> 60)
  {
    CFIndex length = (unint64_t)CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  length);
    int location = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  length,  0LL);
    CFRelease((CFTypeRef)length);
    objc_exception_throw((id)location);
    goto LABEL_18;
  }

  unint64_t v8 = (id *)_CFCreateArrayStorage(length, 0, v26);
  -[NSArray getObjects:range:](self, "getObjects:range:", v8, location, length);
  if (v8)
  {
    for (uint64_t i = 0LL; i != length; ++i)
      unint64_t v10 = v8[i];
    unsigned int v11 = -[NSArray _initByAdoptingBuffer:count:size:]( objc_alloc(&OBJC_CLASS___NSArray),  "_initByAdoptingBuffer:count:size:",  v8,  length,  length);
  }

  else
  {
    unsigned int v11 = -[NSArray initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSArray), "initWithObjects:count:", 0LL, length);
  }

  return v11;
}

            LOBYTE(v11) = 0;
            return v11;
          }

          if (!-[NSCalendar gregorianStartDate](self, "gregorianStartDate", v6, v15, v16, v17, v7, v8)
            || (unsigned int v11 = [a3 gregorianStartDate]) != 0)
          {
            if (-[NSCalendar gregorianStartDate](self, "gregorianStartDate") || ![a3 gregorianStartDate]) {
              goto LABEL_20;
            }
            goto LABEL_18;
          }
        }
      }
    }
  }

  return v11;
}

    if (++v12 == 256) {
      return result;
    }
  }

  unsigned __int8 v20 = *(void *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
  unsigned __int8 v21 = v15;
  if (*(_DWORD *)(v20 + 32))
  {
    CFCharacterSetRef result = a6(a5, (uint64_t)v23);
    if ((result & 1) != 0) {
      return result;
    }
    unsigned __int8 v21 = a3[6];
  }

  if (v21 != a3[5] || (a4 & 1) == 0)
  {
    CFCharacterSetRef result = traverseCFBurstTrieCompactMappedLevel(v11, v20, a3, a4, a5, a6);
    goto LABEL_18;
  }

  return result;
}

  uint64_t v3 = v4[2 * v6 + 1];
LABEL_19:
  *a3 = v3;
  return 1LL;
}

LABEL_64:
      if (v41) {
        int v43 = ~v35 & 0x1FFFE;
      }
      else {
        int v43 = v35;
      }
      BOOL v42 = 1;
LABEL_68:
      __CFCSetGetBitmap((uint64_t)v5, v63);
      __CFCSetGetBitmap((uint64_t)v4, __b);
      uint64_t v44 = 0LL;
      while (v44 != 2048)
      {
        __int32 v45 = __b[0].i32[v44];
        __int32 v46 = v63[0].i32[v44++];
        if ((v45 & ~v46) != 0) {
          goto LABEL_103;
        }
      }

      if (v40)
      {
        if ((v40 & ~v43) == 0)
        {
          uint64_t v61 = v41 - 1LL;
          int v47 = (int)(v41 << 31) >> 31;
          uint64_t v48 = 1LL;
          while (1)
          {
            unint64_t v49 = v5[5];
            if (v49)
            {
              if ((*(_DWORD *)(v49 + 8) & (1 << v48)) != 0
                && *(unsigned __int8 *)(v49 + 12) >= v48)
              {
                uint64_t v50 = *(void *)(*(void *)v49 + 8 * (v48 - 1));
                if (v50)
                {
                  unint64_t v51 = v4[5];
                  if (v51
                    && (*(_DWORD *)(v51 + 8) & (1 << v48)) != 0
                    && *(unsigned __int8 *)(v51 + 12) >= v48
                    && (uint64_t v52 = *(void *)(*(void *)v51 + 8 * (v48 - 1))) != 0)
                  {
                    __CFCSetGetBitmap(v50, v63);
                    __CFCSetGetBitmap(v52, __b);
                    for (uint64_t i = 0LL; i != 2048; ++i)
                    {
                      LOBYTE(IsEqualBitmap) = 0;
                      __int32 v54 = __b[0].i32[i] ^ (v42 - 1);
                      __int32 v55 = v63[0].i32[i] ^ v47;
                      if ((v54 & ~v55) != 0) {
                        return IsEqualBitmap;
                      }
                    }
                  }

                  else if (!v42)
                  {
                    __CFCSetGetBitmap(v50, v63);
                    int IsEqualBitmap = __CFCSetIsEqualBitmap((uint64_t)v63, v61);
                    if (!IsEqualBitmap) {
                      return IsEqualBitmap;
                    }
                  }
                }
              }
            }

            if (++v48 == 17) {
              goto LABEL_97;
            }
          }
        }

        goto LABEL_103;
      }

      goto LABEL_97;
    }
  }

  unsigned __int8 v20 = atomic_load(v5 + 1);
  unsigned __int8 v21 = atomic_load(v4 + 1);
  if (((v21 ^ v20) & 0x70) != 0)
  {
LABEL_47:
    CFStringRef Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 1, 1);
    CFCharacterSetIntersect((CFMutableCharacterSetRef)Copy, (CFCharacterSetRef)v4);
    __CFCharacterSetEqual((uint64_t)Copy, (uint64_t)v4);
    char v33 = v32;
    CFRelease(Copy);
    LOBYTE(IsEqualBitmap) = v33;
    return IsEqualBitmap;
  }

  char v22 = atomic_load(v5 + 1);
  char v23 = atomic_load(v4 + 1);
  if ((v22 & 8) != 0)
  {
    int64_t v36 = *((unsigned int *)v4 + 6);
    if ((v23 & 8) != 0)
    {
      uint64_t v58 = *((unsigned int *)v5 + 6);
      int64_t v38 = v5[4] + v58;
      v36 += v4[4];
    }

    else
    {
      int64_t v37 = *((unsigned int *)v5 + 6);
      int64_t v38 = v5[4] + v37;
    }

    LOBYTE(IsEqualBitmap) = v38 <= v36;
    return IsEqualBitmap;
  }

  if ((v23 & 8) != 0)
  {
    uint64_t v56 = *((unsigned int *)v5 + 6);
    if ((_DWORD)v56 || v5[4] != 1114112)
    {
      int64_t v57 = *((unsigned int *)v4 + 6);
      if ((_DWORD)v57 || v56 < *((_DWORD *)v4 + 8))
      {
        if ((uint64_t)(v5[4] + v56) <= v57)
        {
          LOBYTE(IsEqualBitmap) = v4[4] + v57 == 1114112;
          return IsEqualBitmap;
        }

        goto LABEL_103;
      }
    }

  CFRelease(v4);
  CFRelease(v5);
  return CFDateFormatter;
}

            char v15 = -[__CFString _cfTypeID](v1, "_cfTypeID");
            break;
        }

        break;
    }
  }

  else
  {
    unint64_t v13 = atomic_load((unint64_t *)&cf->info);
    unsigned int v14 = atomic_load((unint64_t *)&v1->info);
    char v15 = (v14 >> 8) & 0x3FF;
  }

  if (v15 > 0x47)
  {
    char v18 = v15 - 72;
    if ((int)v15 - 72 >= dword_18C45D280 || (char v19 = __CFRuntimeClassTables[v18 >> 6]) == 0)
    {
      char v17 = 0LL;
      goto LABEL_28;
    }

    char v16 = (uint64_t *)(v19 + 8LL * (v18 & 0x3F));
  }

  else
  {
LABEL_18:
    char v16 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + v15);
  }

  char v17 = *v16;
LABEL_28:
  unsigned __int8 v20 = *(uint64_t (**)(__CFString *))(v17 + 64);
  if (!v20 || (CFMutableDictionaryRef cf = (CFStringRef)v20(v1)) == 0LL)
  {
    unsigned __int8 v21 = *(void *)(v17 + 8);
    char v22 = CFGetAllocator(v1);
    return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<%s %p [%p]>",  v21,  v1,  v22);
  }

  return cf;
}

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
  CFRelease(s);
}

LABEL_97:
    LOBYTE(IsEqualBitmap) = 1;
    return IsEqualBitmap;
  }

  uint64_t v24 = *((unsigned int *)v4 + 6);
  uint64_t v25 = *((unsigned int *)v5 + 6);
  LOBYTE(IsEqualBitmap) = (uint64_t)(v5[4] + v25) >= (uint64_t)(v4[4] + v24);
  return IsEqualBitmap;
}

      CFCharacterSetRef result = 4LL;
      if ((_DWORD)v47 == 230) {
        return result;
      }
    }

    LODWORD(v47) = 0;
    goto LABEL_97;
  }

  if (v31 != 27758)
  {
    if (v31 != 29300)
    {
LABEL_45:
      if ((a7 & 0x10) != 0 && (CFUniCharIsMemberOf(a1, 8u) & 1) != 0
        || (a1 - 880 < 0x90 || a1 >> 8 == 31) && a5 == 1 && (CFUniCharIsMemberOf(a1, 5u) & 1) != 0)
      {
        return 16LL;
      }

      return 0LL;
    }

void __CFCSetGetBitmap(uint64_t a1, int8x16_t *__b)
{
  char v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) == 0x30LL && (unsigned int v5 = *(const void **)(a1 + 24)) != 0LL)
  {
    memmove(__b, v5, 0x2000uLL);
  }

  else
  {
    unint64_t v6 = atomic_load((unint64_t *)(a1 + 8));
    if ((v6 & 8) != 0) {
      int v7 = -1;
    }
    else {
      int v7 = 0;
    }
    memset(__b, v7, 0x2000uLL);
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8 && (*(_DWORD *)(v8 + 8) || *(_BYTE *)(v8 + 13)))
    {
LABEL_14:
      unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
      switch((v10 >> 4) & 7)
      {
        case 0u:
          int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(a1 + 24), 0, __b, (v6 >> 3) & 1);
          if (BitmapForPlane == 255 && (v6 & 8) != 0)
          {
            char v33 = (char *)__b;
            size_t v34 = 0x2000LL;
            goto LABEL_42;
          }

          if (BitmapForPlane == 1 && (v6 & 8) == 0)
          {
            unint64_t v13 = (char *)__b;
            size_t v14 = 0x2000LL;
            goto LABEL_23;
          }

          break;
        case 1u:
          unint64_t v23 = *(unsigned int *)(a1 + 24);
          if (!WORD1(v23))
          {
            uint64_t v24 = *(void *)(a1 + 32);
            unsigned __int16 v25 = v23 + v24 - 1;
            if ((v6 & 8) != 0)
            {
              uint64_t v35 = (unsigned __int16)v23 >> 3;
              int v36 = v25 >> 3;
              int v37 = 255 << (v23 & 7);
              if (v36 == (_DWORD)v35)
              {
                __b->i8[v35] &= ~((0xFFu >> (~(_BYTE)v25 & 7)) & v37);
              }

              else
              {
                __b->i8[v35] &= ~(_BYTE)v37;
                __b->i8[v25 >> 3] &= -256 >> (~(_BYTE)v25 & 7);
                if (((unint64_t)(unsigned __int16)v23 >> 3) + 1 < v36)
                {
                  char v33 = &__b->i8[(v23 >> 3) + 1];
                  size_t v34 = v36 - (v23 >> 3) - 2 + 1LL;
LABEL_42:
                  bzero(v33, v34);
                }
              }
            }

            else if (v25 == (unsigned __int16)v23)
            {
              __b->i8[v23 >> 3] |= 1 << (v23 & 7);
            }

            else
            {
              unint64_t v38 = v23 >> 3;
              uint64_t v39 = v25 >> 3;
              int v40 = 255 << (v23 & 7);
              if (*(_DWORD *)(a1 + 24) >> 3 == (_DWORD)v39)
              {
                __b->i8[v39] |= (0xFFu >> (~(_BYTE)v25 & 7)) & v40;
              }

              else
              {
                __b->i8[v38] |= v40;
                __b->i8[v25 >> 3] |= 0xFFu >> (~(_BYTE)v25 & 7);
                if ((int)v38 + 1 < v39)
                {
                  unint64_t v13 = &__b->i8[(v38 + 1)];
                  size_t v14 = (v39 - v38 - 2) + 1LL;
LABEL_23:
                  memset(v13, 255, v14);
                }
              }
            }
          }

          break;
        case 2u:
          uint64_t v15 = *(void *)(a1 + 32);
          if (v15)
          {
            char v16 = *(unsigned __int16 **)(a1 + 24);
            do
            {
              unsigned int v17 = *v16++;
              int v18 = 1 << (v17 & 7);
              unint64_t v19 = (unint64_t)v17 >> 3;
              char v20 = __b->i8[v19];
              char v21 = v20 | v18;
              char v22 = v20 & ~(_BYTE)v18;
              if ((v6 & 8) == 0) {
                char v22 = v21;
              }
              __b->i8[v19] = v22;
              --v15;
            }

            while (v15);
          }

          break;
        case 4u:
          uint64_t v26 = 0LL;
          unsigned __int8 v27 = *(int8x16_t **)(a1 + 24);
          unsigned __int8 v28 = v27 + 16;
          do
          {
            unsigned int v29 = v27->u8[v26];
            if ((v29 + 1) > 1u)
            {
              int8x16_t v31 = *v28;
              int8x16_t v32 = v28[1];
              v28 += 2;
              *__b = v31;
              __b[1] = v32;
            }

            else
            {
              int8x16_t v30 = vdupq_n_s8(v29);
              *__b = v30;
              __b[1] = v30;
            }

            ++v26;
            __b += 2;
          }

          while ((_DWORD)v26 != 256);
          break;
        default:
          return;
      }
    }

    else
    {
      unsigned int v9 = atomic_load((unint64_t *)(a1 + 8));
      switch((v9 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(a1 + 32)) {
            goto LABEL_14;
          }
          break;
        case 3u:
        case 4u:
          if (*(void *)(a1 + 24)) {
            goto LABEL_14;
          }
          break;
        default:
          goto LABEL_14;
      }
    }
  }

uint64_t __CFCSetIsEqualBitmap(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (a1 && a2)
    {
      if (a1 == -1)
      {
        for (uint64_t i = 0LL; i != 0x2000; i += 4LL)
        {
          int v9 = *(_DWORD *)(a2 + i);
          if (v9 != -1) {
            return 0LL;
          }
        }
      }

      else if (a2 == -1)
      {
        for (uint64_t j = 0LL; j != 0x2000; j += 4LL)
        {
          int v11 = *(_DWORD *)(a1 + j);
          if (v11 != -1) {
            return 0LL;
          }
        }
      }

      else
      {
        for (uint64_t k = 0LL; k != 0x2000; k += 4LL)
        {
          int v3 = *(_DWORD *)(a1 + k);
          int v4 = *(_DWORD *)(a2 + k);
          if (v3 != v4) {
            return 0LL;
          }
        }
      }
    }

    else if (a1 | a2)
    {
      if (a2) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = a1;
      }
      if (v5 == -1) {
        return 0LL;
      }
      for (uint64_t m = 0LL; m != 0x2000; m += 4LL)
      {
        if (*(_DWORD *)(v5 + m)) {
          return 0LL;
        }
      }
    }
  }

  return 1LL;
}

void CFCharacterSetIntersect(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  uint64_t v2 = (__objc2_class **)MEMORY[0x1895F8858](theSet, theOtherSet);
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v242 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    [v5 formIntersectionWithCharacterSet:v4];
    return;
  }

  char v12 = (unint64_t *)(v5 + 1);
  char v13 = atomic_load((unint64_t *)v5 + 1);
  if ((v13 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)"void CFCharacterSetIntersect(CFMutableCharacterSetRef, CFCharacterSetRef)");
  }

  char v14 = atomic_load(v12);
  if ((v14 & 0x70) == 0)
  {
    char v15 = atomic_load(v12);
    if ((v15 & 1) == 0)
    {
      char v16 = atomic_load(v12);
      if ((v16 & 8) == 0 && CFCharacterSetGetPredefined((CFCharacterSetPredefinedSet)v5[3]) == (CFCharacterSetRef)v5) {
        return;
      }
    }
  }

  unsigned int v17 = v5[5];
  if (!v17 || !LODWORD(v17->superclass) && !BYTE5(v17->superclass))
  {
    unsigned int v18 = atomic_load(v12);
    switch((v18 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (!v5[4]) {
          goto LABEL_17;
        }
        break;
      case 3u:
      case 4u:
        if (v5[3]) {
          break;
        }
LABEL_17:
        char v19 = atomic_load(v12);
        if ((v19 & 8) != 0) {
          break;
        }
        return;
      default:
        break;
    }
  }

  if (!CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    uint64_t v27 = 0LL;
    goto LABEL_34;
  }

  uint64_t v27 = [(id)v4 _expandedCFCharacterSet];
  if (v27)
  {
LABEL_34:
    if (v27) {
      uint64_t v4 = v27;
    }
    uint64_t v37 = *(void *)(v4 + 40);
    if (!v37 || !*(_DWORD *)(v37 + 8) && !*(_BYTE *)(v37 + 13))
    {
      unsigned int v38 = atomic_load((unint64_t *)(v4 + 8));
      switch((v38 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(void *)(v4 + 32)) {
            goto LABEL_41;
          }
          goto LABEL_141;
        case 3u:
        case 4u:
          if (*(void *)(v4 + 24)) {
            goto LABEL_41;
          }
LABEL_141:
          char v95 = atomic_load((unint64_t *)(v4 + 8));
          if ((v95 & 8) != 0) {
            goto LABEL_360;
          }
          char v96 = atomic_load(v12);
          if ((v96 & 0x70) == 0x20LL && v5[3]
            || (char v97 = atomic_load(v12), (v97 & 0x70) == 0x30LL) && v5[3]
            || (char v98 = atomic_load(v12), (v98 & 0x70) == 0x40LL) && v5[3])
          {
            uint64_t v99 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v99, v5[3]);
          }

          unint64_t v100 = atomic_load(v12);
          break;
        default:
          goto LABEL_41;
      }

      while (1)
      {
        unint64_t v101 = __ldaxr(v12);
        if (v101 != v100) {
          break;
        }
        if (__stlxr(v100 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v12)) {
          goto LABEL_154;
        }
        int v102 = 1;
LABEL_155:
        unint64_t v100 = v101;
        if (v102)
        {
          v5[3] = 0LL;
          unint64_t v103 = atomic_load((unint64_t *)v5 + 1);
          while (1)
          {
            unint64_t v104 = __ldaxr(v12);
            if (v104 != v103) {
              break;
            }
            if (__stlxr(v103 & 0xFFFFFFFFFFFFFFF7LL, v12)) {
              goto LABEL_161;
            }
            int v105 = 1;
LABEL_162:
            unint64_t v103 = v104;
            if (v105)
            {
              v5[2] = 0LL;
              unint64_t v106 = atomic_load((unint64_t *)v5 + 1);
              while (1)
              {
                unint64_t v107 = __ldaxr(v12);
                if (v107 != v106) {
                  break;
                }
                if (__stlxr(v106 | 4, v12)) {
                  goto LABEL_168;
                }
                int v108 = 1;
LABEL_169:
                unint64_t v106 = v107;
                if (v108)
                {
                  if (v5[5])
                  {
                    for (uint64_t i = 0LL; i != 16; ++i)
                    {
                      unint64_t v110 = v5[5];
                      if (((LODWORD(v110->superclass) >> i) & 2) != 0) {
                        CFRelease(*((CFTypeRef *)&v110->isa->isa + i));
                      }
                    }

LABEL_218:
                    uint64_t v136 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v136, v5[5]->isa);
                    unsigned int v137 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v137, v5[5]);
                    uint64_t v5[5] = 0LL;
                  }

                  goto LABEL_360;
                }
              }

              __clrex();
LABEL_168:
              int v108 = 0;
              goto LABEL_169;
            }
          }

          __clrex();
LABEL_161:
          int v105 = 0;
          goto LABEL_162;
        }
      }

      __clrex();
LABEL_154:
      int v102 = 0;
      goto LABEL_155;
    }

LABEL_41:
    uint64_t v39 = v5[5];
    if (!v39 || !LODWORD(v39->superclass) && !BYTE5(v39->superclass))
    {
      unsigned int v40 = atomic_load(v12);
      switch((v40 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (v5[4]) {
            goto LABEL_46;
          }
          goto LABEL_220;
        case 3u:
        case 4u:
          if (v5[3]) {
            goto LABEL_46;
          }
LABEL_220:
          char v138 = atomic_load((unint64_t *)(v4 + 8));
          uint64_t v139 = v138 & 0x70;
          unint64_t v140 = atomic_load(v12);
          break;
        default:
          goto LABEL_46;
      }

      while (1)
      {
        unint64_t v141 = __ldaxr(v12);
        if (v141 != v140) {
          break;
        }
        if (__stlxr(v140 & 0xFFFFFFFFFFFFFF8FLL | v139, v12)) {
          goto LABEL_225;
        }
        int v142 = 1;
LABEL_226:
        unint64_t v140 = v141;
        if (v142)
        {
          char v143 = atomic_load((unint64_t *)(v4 + 8));
          unint64_t v144 = atomic_load(v12);
          uint64_t v145 = v143 & 4;
          while (1)
          {
            unint64_t v146 = __ldaxr(v12);
            if (v146 != v144) {
              break;
            }
            if (__stlxr(v144 & 0xFFFFFFFFFFFFFFFBLL | v145, v12)) {
              goto LABEL_232;
            }
            int v147 = 1;
LABEL_233:
            unint64_t v144 = v146;
            if (v147)
            {
              char v148 = atomic_load((unint64_t *)(v4 + 8));
              unint64_t v149 = atomic_load(v12);
              uint64_t v150 = v148 & 8;
              while (1)
              {
                unint64_t v151 = __ldaxr(v12);
                if (v151 != v149) {
                  break;
                }
                if (__stlxr(v149 & 0xFFFFFFFFFFFFFFF7LL | v150, v12)) {
                  goto LABEL_239;
                }
                int v152 = 1;
LABEL_240:
                unint64_t v149 = v151;
                if (v152)
                {
                  v5[2] = *(__objc2_class **)(v4 + 16);
                  uint64_t v153 = *(void *)(v4 + 40);
                  if (!v153 || !*(_DWORD *)(v153 + 8)) {
                    goto LABEL_349;
                  }
                  uint64_t v154 = 0LL;
                  uint64_t v155 = 1LL;
                  while (1)
                  {
                    uint64_t v156 = *(void *)(v4 + 40);
                    if (v156)
                    {
                      int v157 = 1 << v155;
                      if ((*(_DWORD *)(v156 + 8) & (1 << v155)) != 0
                        && *(unsigned __int8 *)(v156 + 12) >= v155)
                      {
                        v158 = *(unint64_t **)(*(void *)v156 + v154);
                        if (v158) {
                          break;
                        }
                      }
                    }

    uint64_t v39 = (unint64_t *)(v4 + 8);
    unsigned int v40 = atomic_load((unint64_t *)(v4 + 8));
    if ((v40 & 0x70) == 0)
    {
      int v48 = v5[5];
      if (!v48 || !LODWORD(v48->superclass) && !BYTE5(v48->superclass))
      {
        uint64_t v49 = atomic_load(v12);
        switch((v49 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (v5[4]) {
              goto LABEL_42;
            }
            break;
          case 3u:
          case 4u:
            if (v5[3]) {
              goto LABEL_42;
            }
            break;
          default:
            goto LABEL_42;
        }

        unint64_t v107 = atomic_load(v12);
        while (1)
        {
          int v108 = __ldaxr(v12);
          if (v108 != v107) {
            break;
          }
          if (__stlxr(v107 & 0xFFFFFFFFFFFFFF8FLL, v12)) {
            goto LABEL_155;
          }
          uint64_t v109 = 1;
LABEL_156:
          unint64_t v107 = v108;
          if (v109)
          {
            v5[3] = *(__objc2_class **)(v4 + 24);
            unint64_t v110 = atomic_load((unint64_t *)(v4 + 8));
            if ((v110 & 8) != 0)
            {
              uint64_t v111 = atomic_load(v12);
              while (1)
              {
                uint64_t v112 = __ldaxr(v12);
                if (v112 != v111) {
                  break;
                }
                if (__stlxr(v111 | 8, v12)) {
                  goto LABEL_163;
                }
                int v113 = 1;
LABEL_164:
                uint64_t v111 = v112;
                if (v113) {
                  goto LABEL_165;
                }
              }

              __clrex();
LABEL_163:
              int v113 = 0;
              goto LABEL_164;
            }

    if (v14 < v19 && v21 <= 0xF) {
      break;
    }
    if (v14 < v19) {
      uint64_t v26 = v13;
    }
    else {
      uint64_t v26 = v13 + 1;
    }
    mdict_rehashd((uint64_t)v44, v26);
    char v13 = (unint64_t)v9[1] >> 58;
    LODWORD(v14) = __NSDictionarySizes_0[v13];
  }

  uint64_t v27 = *(void **)(v18 + 8 * v14);
  unsigned __int8 v28 = v18 + 8 * v19;
  if ((v43 & 0x200000000000000LL) != 0) {
    [v44 willChangeValueForKey:a4];
  }
  unsigned int v29 = *(void *)(v28 + 8 * v14);
  if (v27 == &___NSDictionaryM_DeletedMarker || v27 == 0LL)
  {
    if ((v41 & 0x80000000) != 0)
    {
      int8x16_t v31 = (id)[a4 copyWithZone:0];
    }

    else
    {
      int8x16_t v31 = a4;
      if (((unint64_t)a4 & 0x8000000000000000LL) == 0)
      {
        uint64_t v32 = a4;
        int8x16_t v31 = a4;
      }
    }

    *(void *)(v18 + 8 * v14) = v31;
    *(void *)(v28 + 8 * v14) = v42;
    char v33 = v9[1];
    unint64_t v34 = (v33 + 0x100000000LL) & 0x1FFFFFF00000000LL;
    v9[1] = v34 | v33 & 0xFE000000FFFFFFFFLL;
  }

  else
  {
    *(void *)(v28 + 8 * v14) = v42;
  }

  if ((v43 & 0x200000000000000LL) != 0) {
    [v44 didChangeValueForKey:a4];
  }
  if (v29 >= 1) {
}
  }

LABEL_261:
                    ++v155;
                    v154 += 8LL;
                    if (v155 == 17)
                    {
                      uint64_t v169 = *(void *)(v4 + 40);
                      if (v169)
                      {
                        uint64_t v170 = v5[5];
                        if (*(_BYTE *)(v169 + 13))
                        {
                          if (!v170)
                          {
                            uint64_t v171 = CFGetAllocator(v5);
                            uint64_t v170 = (__objc2_class *)CFAllocatorAllocate(v171, 16LL, 0LL);
                            uint64_t v5[5] = v170;
                            v170->isa = 0LL;
                            *(__objc2_class **)((char *)&v170->isa + 6) = 0LL;
                          }

                          char v172 = 1;
LABEL_348:
                          BYTE5(v170->superclass) = v172;
                          goto LABEL_349;
                        }
                      }

                      else
                      {
                        uint64_t v170 = v5[5];
                      }

                      if (v170)
                      {
                        char v172 = 0;
                        goto LABEL_348;
                      }

LABEL_349:
                      unsigned int v218 = atomic_load((unint64_t *)(v4 + 8));
                      switch((v218 >> 4) & 7)
                      {
                        case 0u:
                          v5[3] = *(__objc2_class **)(v4 + 24);
                          goto LABEL_360;
                        case 1u:
                          *((_DWORD *)v5 + 6) = *(_DWORD *)(v4 + 24);
                          v5[4] = *(__objc2_class **)(v4 + 32);
                          goto LABEL_360;
                        case 2u:
                          uint64_t v219 = *(__objc2_class **)(v4 + 32);
                          v5[4] = v219;
                          CFRange v220 = v5[3];
                          if (!v220)
                          {
                            CFRange v221 = CFGetAllocator(v5);
                            CFRange v220 = (__objc2_class *)CFAllocatorAllocate(v221, 128LL, 0LL);
                            v5[3] = v220;
                            uint64_t v219 = v5[4];
                          }

                          CFRange v222 = *(const void **)(v4 + 24);
                          size_t v223 = 2LL * (void)v219;
                          goto LABEL_359;
                        case 3u:
                          CFRange v224 = CFGetAllocator(v5);
                          CFRange v220 = (__objc2_class *)CFAllocatorAllocate(v224, 0x2000LL, 0LL);
                          v5[3] = v220;
                          CFRange v222 = *(const void **)(v4 + 24);
                          size_t v223 = 0x2000LL;
                          goto LABEL_359;
                        case 4u:
                          uint64_t v225 = 0LL;
                          int32x4_t v226 = (int32x4_t)xmmword_180C336A0;
                          v227 = *(char **)(v4 + 24);
                          int32x4_t v228 = 0uLL;
                          v229.i64[0] = -1LL;
                          v229.i64[1] = -1LL;
                          v230.i64[0] = 0xFEFEFEFEFEFEFEFELL;
                          v230.i64[1] = 0xFEFEFEFEFEFEFEFELL;
                          v231.i64[0] = 0x2000000020LL;
                          v231.i64[1] = 0x2000000020LL;
                          int32x4_t v232 = 0uLL;
                          int32x4_t v233 = 0uLL;
                          do
                          {
                            int8x16_t v234 = (int8x16_t)vcgtq_u8(v230, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v227[v225], v229));
                            int16x8_t v235 = vmovl_s8(*(int8x8_t *)v234.i8);
                            int16x8_t v236 = vmovl_high_s8(v234);
                            int32x4_t v233 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_high_s16(v236),  (int8x16_t)vaddq_s32(v233, v231),  (int8x16_t)v233);
                            int32x4_t v232 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_s16(*(int16x4_t *)v236.i8),  (int8x16_t)vaddq_s32(v232, v231),  (int8x16_t)v232);
                            int32x4_t v228 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_high_s16(v235),  (int8x16_t)vaddq_s32(v228, v231),  (int8x16_t)v228);
                            int32x4_t v226 = (int32x4_t)vbslq_s8( (int8x16_t)vmovl_s16(*(int16x4_t *)v235.i8),  (int8x16_t)vaddq_s32(v226, v231),  (int8x16_t)v226);
                            v225 += 16LL;
                          }

                          while (v225 != 256);
                          CFIndex v237 = vaddvq_s32(vaddq_s32(vaddq_s32(v226, v232), vaddq_s32(v228, v233)));
                          v238 = CFGetAllocator(v5);
                          CFRange v220 = (__objc2_class *)CFAllocatorAllocate(v238, v237, 0LL);
                          v5[3] = v220;
                          CFRange v222 = v227;
                          size_t v223 = v237;
LABEL_359:
                          memmove(v220, v222, v223);
                          break;
                        default:
                          goto LABEL_360;
                      }

                      goto LABEL_360;
                    }
                  }

                  uint64_t v159 = CFGetAllocator(v5);
                  CFStringRef Copy = __CFCharacterSetCreateCopy(v159, v158, 1, 1);
                  int64_t v161 = v5[5];
                  if (v161)
                  {
                    if (BYTE4(v161->superclass) < v155)
                    {
                      BYTE4(v161->superclass) = v155;
                      isa = v161->isa;
                      uint64_t v163 = (malloc_zone_t *)CFGetAllocator(v5);
                      if (isa)
                      {
                        uint64_t v164 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v163, v5[5]->isa, v154 + 8, 0LL, 0LL);
                        goto LABEL_254;
                      }

LABEL_253:
                      uint64_t v164 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v163, v154 + 8, 0LL);
LABEL_254:
                      int64_t v161 = v5[5];
                      v161->isa = v164;
                    }

                    if (Copy)
                    {
                      *(__objc2_class **)((char *)&v5[5]->isa->isa + v154) = (__objc2_class *)CFRetain(Copy);
                      uint64_t v167 = v5[5];
                      int v168 = LODWORD(v167->superclass) | v157;
                    }

                    else
                    {
                      uint64_t v167 = v5[5];
                      int v168 = (uint64_t)v167->superclass & ~v157;
                    }

                    LODWORD(v167->superclass) = v168;
                    CFRelease(Copy);
                    goto LABEL_261;
                  }

                  char v165 = CFGetAllocator(v5);
                  CFDictionaryRef v166 = (__objc2_class *)CFAllocatorAllocate(v165, 16LL, 0LL);
                  uint64_t v5[5] = v166;
                  WORD2(v166->superclass) = v155;
                  LODWORD(v166->superclass) = 0;
                  uint64_t v163 = (malloc_zone_t *)CFGetAllocator(v5);
                  goto LABEL_253;
                }
              }

              __clrex();
LABEL_239:
              int v152 = 0;
              goto LABEL_240;
            }
          }

          __clrex();
LABEL_232:
          int v147 = 0;
          goto LABEL_233;
        }
      }

      __clrex();
LABEL_225:
      int v142 = 0;
      goto LABEL_226;
    }

LABEL_121:
            ++v52;
            v51 += 8LL;
            if (v51 == 128)
            {
              CFRelease(Mutable);
              char v92 = v5[5];
              if (v92 && !LODWORD(v92->superclass))
              {
                for (uint64_t k = 0LL; k != 16; ++k)
                {
                  uint64_t v94 = v5[5];
                  if (((LODWORD(v94->superclass) >> k) & 2) != 0) {
                    CFRelease(*((CFTypeRef *)&v94->isa->isa + k));
                  }
                }

                goto LABEL_218;
              }

              goto LABEL_360;
            }
          }

          if (*(_BYTE *)(v53 + 13)) {
            CFCharacterSetInvert(v55);
          }
          uint64_t v56 = v5[5];
          if (v56)
          {
            if (BYTE4(v56->superclass) < v52)
            {
              BYTE4(v56->superclass) = v52;
              int64_t v57 = v56->isa;
              uint64_t v58 = (malloc_zone_t *)CFGetAllocator(v5);
              if (v57)
              {
                char v59 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v58, v5[5]->isa, v51 + 8, 0LL, 0LL);
                goto LABEL_86;
              }

LABEL_85:
              char v59 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v58, v51 + 8, 0LL);
LABEL_86:
              uint64_t v56 = v5[5];
              v56->isa = v59;
            }

            if (((uint64_t)v56->superclass & v54) == 0)
            {
              char v68 = CFGetAllocator(v5);
              *(__objc2_class **)((char *)&v5[5]->isa->isa + v51) = (__objc2_class *)CFCharacterSetCreateMutable(v68);
              uint64_t v56 = v5[5];
              LODWORD(v56->superclass) |= v54;
            }

            BOOL v69 = *(unint64_t **)((char *)&v56->isa->isa + v51);
            if (BYTE5(v56->superclass)) {
              CFCharacterSetInvert((CFMutableCharacterSetRef)v69);
            }
            CFCharacterSetIntersect((CFMutableCharacterSetRef)v69, v55);
            unint64_t v70 = v5[5];
            if (v70 && BYTE5(v70->superclass)) {
              CFCharacterSetInvert((CFMutableCharacterSetRef)v69);
            }
            uint64_t v71 = *(void *)(v4 + 40);
            if (v71 && *(_BYTE *)(v71 + 13)) {
              CFCharacterSetInvert(v55);
            }
            unint64_t v72 = v69[5];
            if (!v72 || !*(_DWORD *)(v72 + 8) && !*(_BYTE *)(v72 + 13))
            {
              unsigned int v73 = atomic_load(v69 + 1);
              switch((v73 >> 4) & 7)
              {
                case 1u:
                case 2u:
                  if (!v69[4]) {
                    goto LABEL_116;
                  }
                  goto LABEL_121;
                case 3u:
                case 4u:
                  if (v69[3]) {
                    goto LABEL_121;
                  }
LABEL_116:
                  char v79 = atomic_load(v69 + 1);
                  if ((v79 & 8) != 0) {
                    goto LABEL_121;
                  }
                  CFIndex v77 = v5[5];
                  if (v77)
                  {
                    if (BYTE4(v77->superclass) >= v52)
                    {
LABEL_126:
                      int superclass = (int)v77->superclass;
                      if ((superclass & v54) != 0)
                      {
                        CFRelease(*(CFTypeRef *)((char *)&v77->isa->isa + v51));
                        CFIndex v77 = v5[5];
                        int superclass = (int)v77->superclass;
                      }

                      int v78 = superclass & ~v54;
                      goto LABEL_114;
                    }

                    BYTE4(v77->superclass) = v52;
                    uint64_t v80 = v77->isa;
                    CFRange v81 = (malloc_zone_t *)CFGetAllocator(v5);
                    if (v80)
                    {
                      CFRange v82 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v81, v5[5]->isa, v51 + 8, 0LL, 0LL);
LABEL_125:
                      CFIndex v77 = v5[5];
                      v77->isa = v82;
                      goto LABEL_126;
                    }
                  }

                  else
                  {
                    char v83 = CFGetAllocator(v5);
                    BOOL v84 = (__objc2_class *)CFAllocatorAllocate(v83, 16LL, 0LL);
                    uint64_t v5[5] = v84;
                    WORD2(v84->superclass) = v52;
                    LODWORD(v84->superclass) = 0;
                    CFRange v81 = (malloc_zone_t *)CFGetAllocator(v5);
                  }

                  CFRange v82 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v81, v51 + 8, 0LL);
                  goto LABEL_125;
                default:
                  goto LABEL_121;
              }
            }

            goto LABEL_121;
          }

          unint64_t v66 = CFGetAllocator(v5);
          unint64_t v67 = (__objc2_class *)CFAllocatorAllocate(v66, 16LL, 0LL);
          uint64_t v5[5] = v67;
          WORD2(v67->superclass) = v52;
          LODWORD(v67->superclass) = 0;
          uint64_t v58 = (malloc_zone_t *)CFGetAllocator(v5);
          goto LABEL_85;
        }

        char v86 = atomic_load((unint64_t *)(v4 + 8));
        if ((v86 & 0x70) == 0)
        {
          uint64_t v115 = *(void *)(v4 + 40);
          if (!v115 || !*(_BYTE *)(v115 + 13))
          {
            unint64_t v116 = 1LL;
            while (1)
            {
              uint64_t v117 = v5[5];
              if (v117)
              {
                int v118 = 1 << v116;
                if (((uint64_t)v117->superclass & (1 << v116)) != 0 && v116 <= BYTE4(v117->superclass))
                {
                  uint64_t v119 = *((void *)v117->isa + v116 - 1);
                  if (v119)
                  {
                    int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v116, __b, 0);
                    if (!BitmapForPlane)
                    {
                      __CFCSetMakeBitmap((char *)v119);
                      uint64_t v121 = 0LL;
                      uint64_t v122 = *(void *)(v119 + 24);
                      char v123 = 1;
                      do
                      {
                        int v124 = *(_DWORD *)(v122 + v121 * 4);
                        BOOL v125 = (v124 & __b[0].i32[v121]) == 0;
                        *(_DWORD *)(v122 + v121 * 4) = v124 & __b[0].i32[v121];
                        if (!v125) {
                          char v123 = 0;
                        }
                        ++v121;
                      }

                      while (v121 != 2048);
                      if (!v123) {
                        goto LABEL_211;
                      }
LABEL_201:
                      uint64_t v126 = v5[5];
                      if (v126)
                      {
                        if (v116 > BYTE4(v126->superclass))
                        {
                          BYTE4(v126->superclass) = v116;
                          char v127 = v126->isa;
                          uint64_t v128 = (malloc_zone_t *)CFGetAllocator(v5);
                          if (v127)
                          {
                            uint64_t v129 = (__objc2_class *)__CFSafelyReallocateWithAllocator( v128,  v5[5]->isa,  8 * v116,  0LL,  0LL);
                            goto LABEL_207;
                          }

      v328 = 1LL;
      if (!v61 && (v46 & 0x40) != 0 && !v53 && v67 <= 0x39 && v67 >= 0x30 && v68 <= 0x39 && v68 >= 0x30)
      {
        v135 = 0LL;
        uint64_t v136 = 0LL;
        unsigned int v137 = &v338[v59 + 1];
        v285 = v51;
        do
        {
          char v138 = v135;
          uint64_t v139 = v59 + v135;
          uint64_t v136 = v67 - 48 + 10 * v136;
          uint64_t v22 = v139 + 1;
          if (v139 < -1) {
            break;
          }
          unint64_t v140 = v343;
          if (v343 <= v22) {
            break;
          }
          if (v340)
          {
            unint64_t v141 = v340[v59 + 1 + v138 + v342];
          }

          else if (v341)
          {
            unint64_t v141 = *(char *)(v341 + v342 + v59 + v138 + 1);
          }

          else
          {
            if (v345 <= v22 || (int v142 = v344, v344 > v22))
            {
              char v143 = v59 + v138 - 3;
              if (v143 + 64 < v343) {
                unint64_t v140 = v143 + 64;
              }
              v344 = v143;
              v345 = v140;
              v353.int location = v342 + v143;
              v353.CFIndex length = v140 - v143;
              unint64_t v144 = v48;
              uint64_t v145 = v55;
              unint64_t v146 = v50;
              v319 = v137;
              CFStringGetCharacters(v339, v353, v338);
              unsigned int v137 = v319;
              unint64_t v46 = v321;
              uint64_t v56 = v317 ^ 1;
              uint64_t v51 = v285;
              uint64_t v58 = v303;
              unint64_t v47 = v304;
              uint64_t v50 = v146;
              __int32 v55 = v145;
              uint64_t v49 = v317;
              int v48 = v144;
              int v142 = v344;
            }

            unint64_t v141 = v137[v138 - v142];
          }

          unint64_t v67 = v141;
          int v147 = (unsigned __int16)(v141 - 48);
          v135 = v138 + 1;
        }

        while (v147 < 0xA);
        char v148 = 0LL;
        unint64_t v149 = 0LL;
        uint64_t v150 = &buffer[v60 + 1];
        do
        {
          unint64_t v151 = v148;
          unint64_t v149 = v68 - 48 + 10 * v149;
          int64_t v57 = v60 + v148 + 1;
          if (v60 < -1) {
            break;
          }
          int v152 = v335;
          if (v335 <= v57) {
            break;
          }
          if (v332)
          {
            uint64_t v153 = v332[v60 + 1 + v151 + v334];
          }

          else if (v333)
          {
            uint64_t v153 = *(char *)(v333 + v334 + v60 + v151 + 1);
          }

          else
          {
            if (v337 <= v57 || (uint64_t v154 = v336, v336 > v57))
            {
              uint64_t v155 = v60 + v151 - 3;
              if (v155 + 64 < v335) {
                int v152 = v155 + 64;
              }
              v336 = v155;
              v337 = v152;
              v354.int location = v334 + v155;
              v354.CFIndex length = v152 - v155;
              uint64_t v156 = v48;
              v293 = v55;
              int v157 = v50;
              v307 = v57;
              v320 = v150;
              CFStringGetCharacters(v331, v354, buffer);
              uint64_t v150 = v320;
              unint64_t v46 = v321;
              int64_t v57 = v307;
              uint64_t v56 = v317 ^ 1;
              uint64_t v51 = v285;
              uint64_t v58 = v303;
              unint64_t v47 = v304;
              uint64_t v50 = v157;
              __int32 v55 = v293;
              uint64_t v49 = v317;
              int v48 = v156;
              uint64_t v154 = v336;
            }

            uint64_t v153 = v150[v151 - v154];
          }

          char v68 = v153;
          v158 = (unsigned __int16)(v153 - 48);
          char v148 = v151 + 1;
        }

        while (v158 < 0xA);
        if (v136 != v149)
        {
          v278 = v297;
          if (!cf) {
            v278 = 0;
          }
          if (v136 >= v149)
          {
            if (v278) {
              CFRelease(cf);
            }
            return 1LL;
          }

          else
          {
            if (v278) {
              CFRelease(cf);
            }
            return -1LL;
          }
        }

        if ((v46 & 0x200) != 0)
        {
          CFIndex length = v315;
          char v13 = v294;
          if (!v48)
          {
            uint64_t v159 = -1LL;
            if (v138 + 1 >= v151 + 1) {
              uint64_t v159 = 1LL;
            }
            int v160 = v296;
            if (v138 != v151) {
              int v160 = 1;
            }
            v296 = v160;
            if (v138 == v151) {
              int v48 = 0LL;
            }
            else {
              int v48 = v159;
            }
            if (v138 != v151)
            {
              uint64_t v50 = v60;
              __int32 v55 = v59;
            }
          }
        }

        else
        {
          CFIndex length = v315;
          char v13 = v294;
        }

        if (v22 >= length || (v298 = 0LL, v300 = 0LL, v57 >= v13))
        {
          uint64_t v22 = v59 + v138 + 1;
          int64_t v57 = v60 + v151 + 1;
          goto LABEL_407;
        }

        goto LABEL_60;
      }

LABEL_206:
                          uint64_t v129 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v128, 8 * v116, 0LL);
LABEL_207:
                          uint64_t v126 = v5[5];
                          v126->isa = v129;
                        }

                        int v132 = (int)v126->superclass;
                        if ((v132 & v118) != 0)
                        {
                          CFRelease(*((CFTypeRef *)v126->isa + v116 - 1));
                          uint64_t v126 = v5[5];
                          int v132 = (int)v126->superclass;
                        }

                        LODWORD(v126->superclass) = v132 & ~v118;
                        goto LABEL_211;
                      }

                      uint64_t v130 = CFGetAllocator(v5);
                      uint64_t v131 = (__objc2_class *)CFAllocatorAllocate(v130, 16LL, 0LL);
                      uint64_t v5[5] = v131;
                      BYTE4(v131->superclass) = v116;
                      BYTE5(v131->superclass) = 0;
                      LODWORD(v131->superclass) = 0;
                      uint64_t v128 = (malloc_zone_t *)CFGetAllocator(v5);
                      goto LABEL_206;
                    }

                    if (BitmapForPlane == 255) {
                      goto LABEL_201;
                    }
                  }
                }
              }

              uint64_t v126 = atomic_load(v69);
              while (2)
              {
                char v127 = __ldaxr(v69);
                if (v127 == v126)
                {
                  if (!__stlxr(v126 | 0x20, v69))
                  {
                    uint64_t v128 = 1;
                    goto LABEL_212;
                  }
                }

                else
                {
                  __clrex();
                }

                uint64_t v128 = 0;
LABEL_212:
                uint64_t v126 = v127;
                if (v128) {
                  goto LABEL_238;
                }
                continue;
              }
            }

            BOOL v125 = v67[37];
            if (!v125) {
              goto LABEL_206;
            }
            if (*((_BYTE *)v67 + 320)) {
              goto LABEL_206;
            }
            char v143 = (char *)v125 - (char *)v67[38];
            if (v143 < 1) {
              goto LABEL_206;
            }
            unint64_t v144 = CFDataGetMutableBytePtr((CFMutableDataRef)v67[36]);
            Native = CFSocketGetNative((CFSocketRef)v67);
            unint64_t v146 = read(Native, (char *)v67[38] + (void)v144, v143);
            if (!v146)
            {
LABEL_256:
              *((_BYTE *)v67 + 32_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
              goto LABEL_206;
            }

            if (v146 == -1)
            {
              if (*__error() != 35)
              {
                *((_DWORD *)v67 + 81) = *__error();
                goto LABEL_256;
              }

LABEL_211:
              if (++v116 == 17)
              {
                __int32 v133 = v5[5];
                if (v133 && !LODWORD(v133->superclass))
                {
                  for (uint64_t m = 0LL; m != 16; ++m)
                  {
                    v135 = v5[5];
                    if (((LODWORD(v135->superclass) >> m) & 2) != 0) {
                      CFRelease(*((CFTypeRef *)&v135->isa->isa + m));
                    }
                  }

                  goto LABEL_218;
                }

                goto LABEL_360;
              }
            }
          }
        }

        char v87 = atomic_load((unint64_t *)(v4 + 8));
        if ((v87 & 0x70) != 0x10LL)
        {
          uint64_t v111 = v5[5];
          if (v111 && (LODWORD(v111->superclass) || BYTE5(v111->superclass)))
          {
            uint64_t v112 = *(void *)(v4 + 40);
            if (!v112 || !*(_BYTE *)(v112 + 13))
            {
              for (uint64_t n = 0LL; n != 16; ++n)
              {
                unsigned __int8 v114 = v5[5];
                if (((LODWORD(v114->superclass) >> n) & 2) != 0) {
                  CFRelease(*((CFTypeRef *)&v114->isa->isa + n));
                }
              }

              goto LABEL_218;
            }
          }

LABEL_360:
          if (__CFCheckForExapendedSet == 1) {
            __CFCheckForExpandedSet((const char *)v5, v20, v21, v22, v23, v24, v25, v26);
          }
          return;
        }

        uint64_t v88 = CFGetAllocator(v5);
        CFMutableCharacterSetRef v89 = CFCharacterSetCreateMutable(v88);
        CFCharacterSetRef theOtherSeta = CFCharacterSetCreateMutable(0LL);
        __CFCSetAddNonBMPPlanesInRange(v89, *(unsigned int *)(v4 + 24), *(void *)(v4 + 32));
        char v90 = v5[5];
        if (v90) {
          BOOL v91 = BYTE5(v90->superclass) != 0;
        }
        else {
          BOOL v91 = 0;
        }
        uint64_t v173 = *((void *)v89 + 5);
        if (v173) {
          BOOL v239 = *(unsigned __int8 *)(v173 + 13) != 0;
        }
        else {
          BOOL v239 = 0;
        }
        uint64_t v174 = 0LL;
        int64_t v175 = 8LL;
        uint64_t v176 = 1LL;
        while (2)
        {
          char v177 = v174 + 1;
          unsigned int v178 = (v174 + 1);
          uint64_t v179 = *((void *)v89 + 5);
          if (v179)
          {
            int v180 = 1 << v177;
            if ((*(_DWORD *)(v179 + 8) & (1 << v177)) != 0 && *(unsigned __int8 *)(v179 + 12) >= v178)
            {
              CFIndex v181 = *(__CFCharacterSet **)(*(void *)v179 + 8 * v174);
              if (v181)
              {
                char v182 = v5[5];
                if (!v182)
                {
                  v201 = CFGetAllocator(v5);
                  v202 = (__objc2_class *)CFAllocatorAllocate(v201, 16LL, 0LL);
                  uint64_t v5[5] = v202;
                  WORD2(v202->superclass) = v178;
                  LODWORD(v202->superclass) = 0;
                  char v184 = (malloc_zone_t *)CFGetAllocator(v5);
                  goto LABEL_309;
                }

                if (BYTE4(v182->superclass) < v178)
                {
                  BYTE4(v182->superclass) = v178;
                  uint64_t v183 = v182->isa;
                  char v184 = (malloc_zone_t *)CFGetAllocator(v5);
                  if (v183)
                  {
                    uint64_t v185 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v184, v5[5]->isa, v175, 0LL, 0LL);
                    goto LABEL_310;
                  }

LABEL_309:
                  uint64_t v185 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v184, v175, 0LL);
LABEL_310:
                  char v182 = v5[5];
                  v182->isa = v185;
                }

                if (((uint64_t)v182->superclass & v180) == 0)
                {
                  v203 = CFGetAllocator(v5);
                  *((void *)&v5[5]->isa->isa + v174) = CFCharacterSetCreateMutable(v203);
                  char v182 = v5[5];
                  LODWORD(v182->superclass) |= v180;
                }

                CFRange v204 = (unint64_t *)*((void *)&v182->isa->isa + v174);
                if (v239) {
                  CFCharacterSetInvert(v181);
                }
                if (v91)
                {
                  CFCharacterSetInvert((CFMutableCharacterSetRef)v204);
                  CFCharacterSetIntersect((CFMutableCharacterSetRef)v204, v181);
                  CFCharacterSetInvert((CFMutableCharacterSetRef)v204);
                }

                else
                {
                  CFCharacterSetIntersect((CFMutableCharacterSetRef)v204, v181);
                }

                if (v239) {
                  CFCharacterSetInvert(v181);
                }
                unint64_t v205 = v204[5];
                if (!v205 || !*(_DWORD *)(v205 + 8) && !*(_BYTE *)(v205 + 13))
                {
                  unsigned int v206 = atomic_load(v204 + 1);
                  switch((v206 >> 4) & 7)
                  {
                    case 1u:
                    case 2u:
                      if (!v204[4]) {
                        goto LABEL_327;
                      }
                      break;
                    case 3u:
                    case 4u:
                      if (v204[3]) {
                        break;
                      }
LABEL_327:
                      char v207 = atomic_load(v204 + 1);
                      if ((v207 & 8) != 0) {
                        break;
                      }
                      uint64_t v189 = v5[5];
                      if (v189)
                      {
                        if (BYTE4(v189->superclass) >= v178)
                        {
LABEL_335:
                          int v190 = (int)v189->superclass;
                          if ((v190 & v180) == 0) {
                            goto LABEL_287;
                          }
                          int v188 = (const void *)*((void *)&v189->isa->isa + v174);
                          goto LABEL_286;
                        }

                        BYTE4(v189->superclass) = v178;
                        int64_t v208 = v189->isa;
                        int64_t v209 = (malloc_zone_t *)CFGetAllocator(v5);
                        if (v208)
                        {
                          v210 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v209, v5[5]->isa, v175, 0LL, 0LL);
LABEL_334:
                          uint64_t v189 = v5[5];
                          v189->isa = v210;
                          goto LABEL_335;
                        }
                      }

                      else
                      {
                        int v211 = CFGetAllocator(v5);
                        v212 = (__objc2_class *)CFAllocatorAllocate(v211, 16LL, 0LL);
                        uint64_t v5[5] = v212;
                        WORD2(v212->superclass) = v178;
                        LODWORD(v212->superclass) = 0;
                        int64_t v209 = (malloc_zone_t *)CFGetAllocator(v5);
                      }

                      v210 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v209, v175, 0LL);
                      goto LABEL_334;
                    default:
                      break;
                  }
                }

LABEL_306:
                ++v176;
                ++v174;
                v175 += 8LL;
                if (v174 == 16)
                {
                  int v213 = v5[5];
                  if (v213 && !LODWORD(v213->superclass))
                  {
                    for (iuint64_t i = 0LL; ii != 16; ++ii)
                    {
                      int v215 = v5[5];
                      if (((LODWORD(v215->superclass) >> ii) & 2) != 0) {
                        CFRelease(*((CFTypeRef *)&v215->isa->isa + ii));
                      }
                    }

                    v216 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v216, v5[5]->isa);
                    v217 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v217, v5[5]);
                    uint64_t v5[5] = 0LL;
                  }

                  CFRelease(v89);
                  CFRelease(theOtherSeta);
                  goto LABEL_360;
                }

                continue;
              }
            }
          }

          break;
        }

        v186 = v5[5];
        if (v186)
        {
          int v180 = 1 << v177;
          if (BYTE4(v186->superclass) >= v178)
          {
            uint64_t v187 = (__CFCharacterSet *)*((void *)&v186->isa->isa + v174);
            if (v187)
            {
              if (!v91)
              {
                int v188 = (const void *)*((void *)&v186->isa->isa + v174);
LABEL_286:
                CFRelease(v188);
                uint64_t v189 = v5[5];
                int v190 = (int)v189->superclass;
LABEL_287:
                LODWORD(v189->superclass) = v190 & ~v180;
                goto LABEL_306;
              }

LABEL_305:
              CFCharacterSetInvert(v187);
              CFCharacterSetIntersect(v187, theOtherSeta);
              CFCharacterSetInvert(v187);
              goto LABEL_306;
            }
          }

          if (BYTE4(v186->superclass) >= v178) {
            uint64_t v194 = *((void *)&v186->isa->isa + v174);
          }
          else {
LABEL_291:
          }
            uint64_t v194 = 0LL;
          if (v194) {
            BOOL v195 = 0;
          }
          else {
            BOOL v195 = v91;
          }
          if (!v195) {
            goto LABEL_306;
          }
          if (BYTE4(v186->superclass) < v178)
          {
            BYTE4(v186->superclass) = v178;
            v196 = v186->isa;
            CFMutableDictionaryRef v193 = (malloc_zone_t *)CFGetAllocator(v5);
            if (v196)
            {
              unint64_t v197 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v193, v5[5]->isa, v175, 0LL, 0LL);
              goto LABEL_301;
            }

LABEL_300:
            unint64_t v197 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v193, v175, 0LL);
LABEL_301:
            v186 = v5[5];
            v186->isa = v197;
          }

          uint64_t v198 = v174;
          if (((uint64_t)v186->superclass & (1 << v177)) == 0)
          {
            v199 = CFGetAllocator(v5);
            CFMutableCharacterSetRef v200 = CFCharacterSetCreateMutable(v199);
            uint64_t v198 = v176 - 1;
            *((void *)&v5[5]->isa->isa + v174) = v200;
            v186 = v5[5];
            LODWORD(v186->superclass) |= 1 << v177;
          }

          uint64_t v187 = (__CFCharacterSet *)*((void *)&v186->isa->isa + v198);
          goto LABEL_305;
        }

        if (!v91) {
          goto LABEL_306;
        }
        uint64_t v191 = CFGetAllocator(v5);
        v192 = (__objc2_class *)CFAllocatorAllocate(v191, 16LL, 0LL);
        uint64_t v5[5] = v192;
        WORD2(v192->superclass) = v178;
        LODWORD(v192->superclass) = 0;
        CFMutableDictionaryRef v193 = (malloc_zone_t *)CFGetAllocator(v5);
        goto LABEL_300;
      }
    }

    __clrex();
LABEL_57:
    int v48 = 0;
    goto LABEL_58;
  }

  BitmapRepresentatiouint64_t n = CFCharacterSetCreateBitmapRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (CFCharacterSetRef)v4);
  if (BitmapRepresentation)
  {
    unsigned int v29 = BitmapRepresentation;
    if (CFDataGetLength(BitmapRepresentation))
    {
      BytePtr = CFDataGetBytePtr(v29);
      if (BytePtr)
      {
        int8x16_t v31 = BytePtr;
        __CFCSetMakeBitmap((char *)v5);
        uint64_t v32 = 0LL;
        char v33 = v5[3];
        do
        {
          *(_DWORD *)((char *)&v33->isa + v32) &= *(_DWORD *)&v31[v32];
          v32 += 4LL;
        }

        while (v32 != 0x2000);
        unint64_t v34 = atomic_load(v12);
        while (1)
        {
          unint64_t v35 = __ldaxr(v12);
          if (v35 != v34) {
            break;
          }
          if (__stlxr(v34 & 0xFFFFFFFFFFFFFFFBLL, v12)) {
            goto LABEL_30;
          }
          int v36 = 1;
LABEL_31:
          unint64_t v34 = v35;
          if (v36) {
            goto LABEL_32;
          }
        }

        __clrex();
LABEL_30:
        int v36 = 0;
        goto LABEL_31;
      }
    }

Boolean CFCharacterSetHasMemberInPlane(CFCharacterSetRef theSet, CFIndex thePlane)
{
  uint64_t v2 = MEMORY[0x1895F8858](theSet, thePlane);
  uint64_t v37 = *MEMORY[0x1895F89C0];
  unint64_t v4 = atomic_load((unint64_t *)(v2 + 8));
  if (v3 > 0x10) {
    goto LABEL_2;
  }
  unint64_t v6 = v3;
  uint64_t v7 = v2;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)v2))
  {
    LOBYTE(v5) = [(id)v7 hasMemberInPlane:v6];
    return v5;
  }

  uint64_t v5 = (v4 >> 3) & 1;
  uint64_t v8 = *(void *)(v7 + 40);
  if (v8 && (*(_DWORD *)(v8 + 8) || *(_BYTE *)(v8 + 13)))
  {
LABEL_13:
    unint64_t v10 = v4 & 8;
    char v11 = atomic_load((unint64_t *)(v7 + 8));
    if ((v11 & 0x70) != 0)
    {
      char v12 = atomic_load((unint64_t *)(v7 + 8));
      if ((v12 & 0x70) == 0x10LL)
      {
        unint64_t v13 = v10 >> 3;
        unint64_t v14 = *(unsigned int *)(v7 + 24);
        unint64_t v15 = v14 >> 16;
        unint64_t v16 = (v14 + *(_DWORD *)(v7 + 32) - 1) >> 16;
        if (!(_DWORD)v13)
        {
          LOBYTE(v5) = v15 <= v6 && v16 >= v6;
          return v5;
        }

        LOBYTE(v5) = 1;
        if (v15 > v6 || v16 < v6) {
          return v5;
        }
        if (v15 >= v6 || v16 <= v6)
        {
          int v17 = (unsigned __int16)(v14 + *(_WORD *)(v7 + 32) - 1);
          if (v15 == v6)
          {
            if (!(unsigned __int16)*(_DWORD *)(v7 + 24))
            {
              BOOL v18 = (_DWORD)v15 != (_DWORD)v16 || v17 == 0xFFFF;
              goto LABEL_65;
            }

LABEL_88:
            LOBYTE(v5) = 1;
            return v5;
          }

          if (v17 != 0xFFFF) {
            goto LABEL_88;
          }
          else {
            BOOL v28 = 0;
          }
LABEL_74:
          LOBYTE(v5) = v28;
          return v5;
        }

        goto LABEL_2;
      }

      if (v6)
      {
        uint64_t v19 = *(void *)(v7 + 40);
        if (!v19) {
          goto LABEL_2;
        }
        if (((*(_DWORD *)(v19 + 8) >> v6) & 1) != 0
          && *(unsigned __int8 *)(v19 + 12) >= v6
          && (uint64_t v20 = *(void **)(*(void *)v19 + 8LL * (v6 - 1))) != 0LL)
        {
          char v21 = atomic_load(v20 + 1);
          if ((v21 & 0x70) != 0x10LL)
          {
            char v29 = atomic_load(v20 + 1);
            if ((v29 & 0x70) == 0x30LL)
            {
              uint64_t v30 = *(void *)(v7 + 40);
              if (!v30 || !*(_BYTE *)(v30 + 13)) {
                goto LABEL_88;
              }
              BOOL v28 = __CFCSetIsEqualBitmap(v20[3], -1LL) == 0;
              goto LABEL_74;
            }

            __CFCSetGetBitmap((uint64_t)v20, __b);
            uint64_t v31 = *(void *)(v7 + 40);
            if (!v31 || !*(_BYTE *)(v31 + 13)) {
              goto LABEL_88;
            }
            if (&v35 != (uint64_t *)-9LL)
            {
              uint64_t v32 = 0LL;
              do
              {
                LOBYTE(v5) = v32 != 2048;
                if (v32 == 2048) {
                  break;
                }
                __int32 v33 = __b[0].i32[v32++];
              }

              while (v33 == -1);
              return v5;
            }

      *((void *)theSet + 4) = v25;
      qsort(v58, v25, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
      CFMutableCharacterSetRef v62 = *((void *)theSet + 4);
      if (v62 >= 2)
      {
        char v63 = 0LL;
        uint64_t v64 = *((void *)theSet + 3);
        uint64_t v65 = v62 - 1;
        unint64_t v66 = (unsigned __int16 *)(v64 + 2);
        do
        {
          char v68 = *v66++;
          unint64_t v67 = v68;
          if (*(unsigned __int16 *)(v64 + 2 * v63) != v68)
          {
            ++v63;
            *(_WORD *)(v64 + 2 * v63) = v67;
          }

          --v65;
        }

        while (v65);
        CFMutableCharacterSetRef v62 = v63 + 1;
      }

      *((void *)theSet + 4) = v62;
      BOOL v69 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        unint64_t v70 = __ldaxr(v10);
        if (v70 != v69) {
          break;
        }
        if (__stlxr(v69 & 0xFFFFFFFFFFFFFFFBLL, v10)) {
          goto LABEL_99;
        }
        uint64_t v71 = 1;
LABEL_100:
        BOOL v69 = v70;
        if (v71)
        {
          if ((v54 & 1) != 0) {
            __CFApplySurrogatesInString( (uint64_t)theSet,  theString,  (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
          }
          return;
        }
      }

      __clrex();
LABEL_99:
      uint64_t v71 = 0;
      goto LABEL_100;
    }
  }

LABEL_65:
    LOBYTE(v5) = !v18;
    return v5;
  }

  unsigned int v9 = atomic_load((unint64_t *)(v7 + 8));
  switch((v9 >> 4) & 7)
  {
    case 1u:
    case 2u:
      if (*(void *)(v7 + 32)) {
        goto LABEL_13;
      }
      break;
    case 3u:
    case 4u:
      if (*(void *)(v7 + 24)) {
        goto LABEL_13;
      }
      break;
    default:
      goto LABEL_13;
  }

  return v5;
}

  InfoDictFromData = 0LL;
LABEL_66:
  if (v58) {
    munmap((void *)v58, v65.st_size);
  }
  return InfoDictFromData;
}

CFDataRef CFCharacterSetCreateBitmapRepresentation(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *((void *)theSet + 5);
  if (v5)
  {
    int v6 = *(unsigned __int8 *)(v5 + 13);
    BOOL v7 = *(_BYTE *)(v5 + 13) != 0;
    unsigned int v8 = *(_DWORD *)(v5 + 8);
    if (v8)
    {
      uint64_t v9 = 0LL;
      int v10 = 0;
      do
      {
        unint64_t v11 = v9 + 1;
        if (v6
          || ((v8 >> (v9 + 1)) & 1) != 0 && v11 <= *(unsigned __int8 *)(v5 + 12) && *(void *)(*(void *)v5 + 8 * v9))
        {
          v90[v10++] = v11;
        }

        ++v9;
      }

      while (v9 != 16);
      CFIndex v12 = 8193 * v10 + 0x2000;
      CFMutableCharacterSetRef Mutable = CFDataCreateMutable(alloc, v12);
      CFDataSetLength(Mutable, v12);
      MutableBytePtr = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
      __CFCSetGetBitmap((uint64_t)theSet, MutableBytePtr);
      if (v10 > 0)
      {
        unint64_t v15 = CFDataGetMutableBytePtr(Mutable);
        uint64_t v16 = *((void *)theSet + 5);
        if (v16)
        {
          if (*(_DWORD *)(v16 + 8))
          {
            int v17 = (int8x16_t *)v15;
            uint64_t v18 = 0LL;
            if (v6) {
              unsigned int v19 = -1;
            }
            else {
              unsigned int v19 = 0;
            }
            int32x4_t v20 = vdupq_n_s32(v19);
            char v21 = v15 + 8193;
            int32x4_t v89 = v20;
            do
            {
              unsigned int v22 = v90[v18];
              v17[512].i8[0] = v22;
              if (!v22) {
                __break(1u);
              }
              int v17 = (int8x16_t *)((char *)v17 + 8193);
              if (v22 <= 0x10
                && (uint64_t v23 = *((void *)theSet + 5)) != 0
                && ((*(_DWORD *)(v23 + 8) >> v22) & 1) != 0
                && *(unsigned __int8 *)(v23 + 12) >= v22
                && (uint64_t v24 = *(void *)(*(void *)v23 + 8LL * (v22 - 1))) != 0)
              {
                __CFCSetGetBitmap(v24, v17);
                int32x4_t v20 = v89;
                if (v6)
                {
                  for (uint64_t i = 0LL; i != 0x2000; i += 16LL)
                    *(int8x16_t *)&v21[i] = vmvnq_s8(*(int8x16_t *)&v21[i]);
                }
              }

              else
              {
                for (uint64_t j = 0LL; j != 0x2000; j += 16LL)
                  *(int32x4_t *)&v21[j] = v20;
              }

              ++v18;
              v21 += 8193;
            }

            while (v18 != v10);
          }
        }
      }

      return Mutable;
    }
  }

  else
  {
    BOOL v7 = 0;
  }

  char v27 = atomic_load((unint64_t *)theSet + 1);
  char v28 = atomic_load((unint64_t *)theSet + 1);
  if ((v27 & 0x70) == 0)
  {
    if ((v28 & 8) != 0) {
      int v34 = 16;
    }
    else {
      int v34 = CFUniCharGetNumberOfPlanes(*((_DWORD *)theSet + 6)) - 1;
    }
    CFIndex v39 = 8193 * v34 + 0x2000;
    CFMutableCharacterSetRef Mutable = CFDataCreateMutable(alloc, v39);
    CFDataSetLength(Mutable, v39);
    unsigned int v40 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v40);
    if (v34 >= 1)
    {
      int v41 = 0;
      BOOL v42 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
      unint64_t v43 = atomic_load((unint64_t *)theSet + 1);
      uint64_t v44 = (v43 >> 3) & 1;
      do
      {
        int BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)theSet + 6), ++v41, v42 + 1, v44);
        if (BitmapForPlane != 255)
        {
          *BOOL v42 = v41;
          if (BitmapForPlane == 1) {
            memset(v42 + 1, 255, 0x2000uLL);
          }
          v42 += 8193;
        }
      }

      while (v34 != v41);
      CFIndex v46 = v42 - CFDataGetBytePtr(Mutable);
      if (v46 < v39) {
        CFDataSetLength(Mutable, v46);
      }
    }

    return Mutable;
  }

  if ((v28 & 0x70) == 0x10LL)
  {
    unsigned int v29 = *((_DWORD *)theSet + 6);
    unsigned int v30 = v29 + *((_DWORD *)theSet + 8) - 1;
    char v31 = atomic_load((unint64_t *)theSet + 1);
    uint64_t v32 = v31 & 8;
    if (v30 >= 0x10000)
    {
      unsigned int v47 = HIWORD(v30);
      int v48 = HIWORD(v29);
      if (v29 < 0x10000) {
        int v48 = 1;
      }
      unsigned int v49 = v47 - v48;
      if (v29 <= 0x10000) {
        LOWORD(v29) = 0;
      }
      if ((_WORD)v29) {
        int v50 = 16 - v49;
      }
      else {
        int v50 = 15 - v49;
      }
      if ((_WORD)v30 != 0xFFFF) {
        ++v50;
      }
      else {
        int v51 = 15 - v49;
      }
      if (v47 != v48) {
        int v51 = v50;
      }
      if (v32) {
        int v33 = v51;
      }
      else {
        int v33 = v49 + 1;
      }
    }

    else
    {
      int v33 = 2 * v32;
    }

    CFIndex v52 = 8193 * v33 + 0x2000;
    CFMutableCharacterSetRef Mutable = CFDataCreateMutable(alloc, v52);
    CFDataSetLength(Mutable, v52);
    uint64_t v53 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v53);
    if (v33 < 1) {
      return Mutable;
    }
    int v54 = CFDataGetMutableBytePtr(Mutable);
    unsigned int v55 = *((_DWORD *)theSet + 6);
    unsigned int v56 = v55 + *((_DWORD *)theSet + 8) - 1;
    unsigned int v57 = HIWORD(v56);
    if (v55 <= 0x10000) {
      unsigned __int16 v58 = 0;
    }
    else {
      unsigned __int16 v58 = *((_DWORD *)theSet + 6);
    }
    if (v55 < 0x10000) {
      unsigned int v59 = 1;
    }
    else {
      unsigned int v59 = HIWORD(v55);
    }
    char v60 = atomic_load((unint64_t *)theSet + 1);
    if ((v60 & 8) == 0)
    {
      unsigned int v61 = v57 - v59;
      if (v57 >= v59)
      {
        uint64_t v62 = 0LL;
        char v63 = v54 + 8194;
        do
        {
          *(v63 - 2) = v59 + v62;
          if ((_DWORD)v62) {
            unsigned __int16 v64 = 0;
          }
          else {
            unsigned __int16 v64 = v58;
          }
          if (v61 == (_DWORD)v62) {
            unsigned __int16 v65 = v56;
          }
          else {
            unsigned __int16 v65 = -1;
          }
          char v66 = v64;
          if (v64 == v65)
          {
            v63[(v64 >> 3) - 1] |= 1 << (v64 & 7);
          }

          else
          {
            uint64_t v67 = v64 >> 3;
            unsigned int v68 = v65 >> 3;
            int v69 = 255 << (v66 & 7);
            if ((_DWORD)v67 == v68)
            {
              v63[v67 - 1] |= (0xFFu >> (~(_BYTE)v65 & 7)) & v69;
            }

            else
            {
              v63[v67 - 1] |= v69;
              v63[(v65 >> 3) - 1] |= 0xFFu >> (~(_BYTE)v65 & 7);
            }
          }

          ++v62;
          v63 += 8193;
        }

        while (v61 + 1 != v62);
      }

      return Mutable;
    }

    uint64_t v71 = (char *)(v54 + 0x2000);
    if (v59 < 2)
    {
      char v73 = 1;
    }

    else
    {
      uint64_t v72 = 0LL;
      do
      {
        *uint64_t v71 = ++v72;
        memset(v71 + 1, 255, 0x2000uLL);
        v71 += 8193;
      }

      while (v59 - 1 != v72);
      char v73 = v59;
    }

    if (v57 == v59)
    {
      if (v58 || (unsigned __int16)v56 != 0xFFFF)
      {
        *uint64_t v71 = v73;
        unint64_t v74 = v71 + 1;
        memset(v71 + 1, 255, 0x2000uLL);
        uint64_t v75 = v58 >> 3;
        int v76 = (unsigned __int16)v56 >> 3;
        int v77 = 255 << (v58 & 7);
        if (v76 == (_DWORD)v75)
        {
          v74[v75] &= ~((0xFFu >> (~(_BYTE)v56 & 7)) & v77);
        }

        else
        {
          v74[v75] &= ~(_BYTE)v77;
          v74[(unsigned __int16)v56 >> 3] &= -256 >> (~(_BYTE)v56 & 7);
        }

        v71 += 8193;
      }

      goto LABEL_132;
    }

    if (v57 <= v59)
    {
LABEL_132:
      if (!(v56 >> 20))
      {
        unsigned int v86 = 15 - v57;
        if (v57 > 0xF) {
          unsigned int v86 = 0;
        }
        uint64_t v87 = -(uint64_t)(v86 + 1);
        unsigned int v88 = v57 + 1;
        do
        {
          *uint64_t v71 = v88;
          memset(v71 + 1, 255, 0x2000uLL);
          v71 += 8193;
          ++v88;
          BOOL v38 = __CFADD__(v87++, 1LL);
        }

        while (!v38);
      }

      return Mutable;
    }

    if (!v58)
    {
LABEL_120:
      if ((unsigned __int16)v56 != 0xFFFF)
      {
        CFRange v81 = v71 + 0x2000;
        *uint64_t v71 = v73;
        bzero(v71 + 1, 0x2000uLL);
        unint64_t v82 = (unint64_t)(unsigned __int16)v56 >> 3;
        int v83 = 255 << (v56 & 7);
        if ((_DWORD)v82 == 0x1FFF)
        {
          *CFRange v81 = v83;
        }

        else
        {
          v71[v82 + 1] |= v83;
          *CFRange v81 = -1;
          if ((unsigned __int16)v56 >> 4 <= 0xFFEu)
          {
            BOOL v38 = v82 <= 0x1FFD;
            int v85 = 8189 - v82;
            if (!v38) {
              int v85 = 0;
            }
            memset(&v71[((unsigned __int16)v56 >> 3) + 2], 255, (v85 + 1));
          }
        }

        v71 += 8193;
      }

      goto LABEL_132;
    }

    *uint64_t v71 = v73;
    int v78 = v71 + 1;
    bzero(v71 + 1, 0x2000uLL);
    unsigned __int16 v79 = v58 - 1;
    if (v58 == 1)
    {
      LOBYTE(v8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
    }

    else
    {
      if ((unsigned __int16)(v58 - 1) > 7u)
      {
        uint64_t v84 = v79 >> 3;
        *int v78 = -1;
        v78[v84] |= 0xFFu >> (~(_BYTE)v79 & 7);
        if ((unsigned __int16)(v58 - 1) >= 0x10u)
        {
          memset(v71 + 2, 255, (v84 - 1));
        }

        goto LABEL_119;
      }

      unsigned int v80 = 0xFFu >> (v79 ^ 7);
    }

    *int v78 = v80;
LABEL_119:
    v71 += 8193;
    goto LABEL_120;
  }

  if (v7)
  {
    CFMutableCharacterSetRef Mutable = CFDataCreateMutable(alloc, 139280LL);
    CFDataSetLength(Mutable, 139280LL);
    uint64_t v35 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v35);
    int v36 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
    uint64_t v37 = -16LL;
    do
    {
      *int v36 = v37 + 17;
      memset(v36 + 1, 255, 0x2000uLL);
      v36 += 8193;
      BOOL v38 = __CFADD__(v37++, 1LL);
    }

    while (!v38);
  }

  else
  {
    CFMutableCharacterSetRef Mutable = CFDataCreateMutable(alloc, 0x2000LL);
    CFDataSetLength(Mutable, 0x2000LL);
    unint64_t v70 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v70);
  }

  return Mutable;
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length = theRange.length;
  unint64_t location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet addCharactersInRange:](theSet, "addCharactersInRange:", location, length);
    return;
  }

  unint64_t v11 = (unint64_t *)((char *)theSet + 8);
  char v12 = atomic_load((unint64_t *)theSet + 1);
  if ((v12 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)"void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef, CFRange)");
  }

  if (location >> 16 > 0x10 || length >= 1114113 || (unint64_t v13 = location + length, location + length >= 0x110001))
  {
    CFLog( 3LL,  (uint64_t)@"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)",  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)"void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef, CFRange)");
    qword_18C539A70 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
    return;
  }

  char v14 = atomic_load(v11);
  if ((v14 & 0x70) != 0
    || (char v15 = atomic_load(v11), (v15 & 1) != 0)
    || (char v16 = atomic_load(v11), (v16 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    if (length)
    {
      char v17 = atomic_load(v11);
      if ((v17 & 8) != 0)
      {
        uint64_t v18 = *((void *)theSet + 5);
        if (!v18 || !*(_DWORD *)(v18 + 8) && !*(_BYTE *)(v18 + 13))
        {
          unsigned int v19 = atomic_load(v11);
          switch((v19 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*((void *)theSet + 4)) {
                goto LABEL_22;
              }
              break;
            case 3u:
            case 4u:
              if (*((void *)theSet + 3)) {
                goto LABEL_22;
              }
              break;
            default:
              goto LABEL_22;
          }

          return;
        }
      }

LABEL_28:
      char v23 = atomic_load(v11);
      if ((v23 & 0x70) == 0x10LL)
      {
        unint64_t v24 = *((unsigned int *)theSet + 6);
        CFIndex v25 = *((void *)theSet + 4);
        if (location == v24)
        {
          if (v25 <= length) {
            CFIndex v26 = length;
          }
          else {
            CFIndex v26 = *((void *)theSet + 4);
          }
          *((void *)theSet + 4) = v26;
          unint64_t v27 = atomic_load((unint64_t *)theSet + 1);
          while (1)
          {
            unint64_t v28 = __ldaxr(v11);
            if (v28 != v27) {
              break;
            }
            if (__stlxr(v27 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
              goto LABEL_38;
            }
            char v29 = 1;
LABEL_39:
            unint64_t v27 = v28;
            if ((v29 & 1) != 0) {
              return;
            }
          }

          __clrex();
LABEL_38:
          char v29 = 0;
          goto LABEL_39;
        }

        if (location <= v24 || (uint64_t)location > (uint64_t)(v25 + v24))
        {
          if (location < v24 && v13 >= v24)
          {
            *((_DWORD *)theSet + 6) = location;
            int64_t v46 = v25 + v24;
            *((void *)theSet + 4) = v46 - location;
            unint64_t v47 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              unint64_t v48 = __ldaxr(v11);
              if (v48 != v47) {
                break;
              }
              if (__stlxr(v47 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
                goto LABEL_72;
              }
              char v49 = 1;
LABEL_73:
              unint64_t v47 = v48;
              if ((v49 & 1) != 0) {
                return;
              }
            }

            __clrex();
LABEL_72:
            char v49 = 0;
            goto LABEL_73;
          }

          goto LABEL_75;
        }

        unint64_t v72 = atomic_load(v11);
        while (1)
        {
          unint64_t v73 = __ldaxr(v11);
          if (v73 != v72) {
            break;
          }
          if (__stlxr(v72 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
            goto LABEL_117;
          }
          char v74 = 1;
LABEL_118:
          unint64_t v72 = v73;
          if ((v74 & 1) != 0) {
            return;
          }
        }

        __clrex();
LABEL_117:
        char v74 = 0;
        goto LABEL_118;
      }

      char v30 = atomic_load(v11);
      if ((v30 & 0x70) != 0x20LL || (uint64_t v31 = *((void *)theSet + 4), v32 = v31 + length, v31 + length > 63))
      {
LABEL_75:
        __CFCSetMakeBitmap((char *)theSet);
        __CFCSetAddNonBMPPlanesInRange(theSet, location, length);
        if (!(location >> 16))
        {
          uint64_t v57 = *((void *)theSet + 3);
          if (v13 >> 16) {
            int v58 = -(int)location;
          }
          else {
            LOWORD(v58) = length;
          }
          unsigned __int16 v59 = v58 + location - 1;
          if (v59 == (unsigned __int16)location)
          {
            *(_BYTE *)(v57 + (location >> 3)) |= 1 << (location & 7);
          }

          else
          {
            uint64_t v60 = location >> 3;
            unsigned int v61 = v59 >> 3;
            int v62 = 255 << (location & 7);
            if ((_DWORD)v60 == v61)
            {
              *(_BYTE *)(v57 + v60) |= (0xFFu >> (~(_BYTE)v59 & 7)) & v62;
            }

            else
            {
              *(_BYTE *)(v57 + v60) |= v62;
              *(_BYTE *)(v57 + (v59 >> 3)) |= 0xFFu >> (~(_BYTE)v59 & 7);
            }
          }
        }

        unint64_t v69 = atomic_load(v11);
        while (1)
        {
          unint64_t v70 = __ldaxr(v11);
          if (v70 != v69) {
            break;
          }
          if (__stlxr(v69 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
            goto LABEL_106;
          }
          int v71 = 1;
LABEL_107:
          unint64_t v69 = v70;
          if (v71)
          {
            if (__CFCheckForExapendedSet == 1) {
              __CFCheckForExpandedSet((const char *)theSet, v50, v51, v52, v53, v54, v55, v56);
            }
            return;
          }
        }

        __clrex();
LABEL_106:
        int v71 = 0;
        goto LABEL_107;
      }

      int v33 = (char *)*((void *)theSet + 3);
      if (!v33)
      {
        int v34 = CFGetAllocator(theSet);
        int v33 = (char *)CFAllocatorAllocate(v34, 128LL, 0LL);
        *((void *)theSet + 3) = v33;
        uint64_t v31 = *((void *)theSet + 4);
        CFIndex v32 = v31 + length;
      }

      *((void *)theSet + 4) = v32;
      uint64_t v35 = &v33[2 * v31];
      do
      {
        *(_WORD *)uint64_t v35 = location;
        v35 += 2;
        ++location;
        --length;
      }

      while (length);
      qsort( *((void **)theSet + 3),  *((void *)theSet + 4),  2uLL,  (int (__cdecl *)(const void *, const void *))chcompar);
      uint64_t v36 = *((void *)theSet + 4);
      if (v36 >= 2)
      {
        uint64_t v37 = 0LL;
        uint64_t v38 = *((void *)theSet + 3);
        uint64_t v39 = v36 - 1;
        unsigned int v40 = (unsigned __int16 *)(v38 + 2);
        do
        {
          int v42 = *v40++;
          __int16 v41 = v42;
          if (*(unsigned __int16 *)(v38 + 2 * v37) != v42)
          {
            ++v37;
            *(_WORD *)(v38 + 2 * v37) = v41;
          }

          --v39;
        }

        while (v39);
        uint64_t v36 = v37 + 1;
      }

      *((void *)theSet + 4) = v36;
      unint64_t v43 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        unint64_t v44 = __ldaxr(v11);
        if (v44 != v43) {
          break;
        }
        if (__stlxr(v43 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
          goto LABEL_58;
        }
        char v45 = 1;
LABEL_59:
        unint64_t v43 = v44;
        if ((v45 & 1) != 0) {
          return;
        }
      }

      __clrex();
LABEL_58:
      char v45 = 0;
      goto LABEL_59;
    }
  }

  CFCharacterSetRef result = 0LL;
  switch(v9)
  {
    case 1LL:
      unsigned int v19 = __CFNumberTypeTable[v10];
      if ((v19 & 0x20) == 0)
      {
        if ((v19 & 0x40) == 0)
        {
          char v20 = *(double *)v11;
          *(_BYTE *)a3 = *v11;
          uint64_t v21 = _CFExecutableLinkedOnOrAfter(6uLL);
          unsigned int v22 = *(void *)&v20 == SLOBYTE(v20);
          char v23 = *(void *)&v20 >= 0x100uLL;
          goto LABEL_35;
        }

        uint64_t v50 = v11[1];
        *(_BYTE *)a3 = v50;
        return v50 == (char)v50;
      }

      if ((v19 & 0x40) == 0)
      {
        uint64_t v37 = *(float *)v11;
        uint64_t v38 = (int)*(float *)v11;
        *(_BYTE *)a3 = v38;
        goto LABEL_64;
      }

      unint64_t v48 = *(double *)v11;
      char v49 = (int)*(double *)v11;
      *(_BYTE *)a3 = v49;
      goto LABEL_106;
    case 2LL:
      unint64_t v24 = __CFNumberTypeTable[v10];
      if ((v24 & 0x20) == 0)
      {
        if ((v24 & 0x40) != 0)
        {
          unint64_t v43 = v11[1];
          *(_WORD *)a3 = v43;
          return v43 == (__int16)v43;
        }

        CFIndex v25 = *v11;
        *(_WORD *)a3 = *v11;
        uint64_t v21 = _CFExecutableLinkedOnOrAfter(6uLL);
        unsigned int v22 = v25 == (__int16)v25;
        char v23 = v25 >= 0x10000;
LABEL_35:
        if (!v23) {
          unsigned int v22 = 1;
        }
        return !v21 || v22;
      }

      if ((v24 & 0x40) != 0)
      {
        unint64_t v48 = *(double *)v11;
        char v49 = (int)*(double *)v11;
        *(_WORD *)a3 = v49;
        goto LABEL_106;
      }

      uint64_t v37 = *(float *)v11;
      uint64_t v38 = (int)*(float *)v11;
      *(_WORD *)a3 = v38;
LABEL_64:
      uint64_t v39 = (float)v38;
      return v37 == v39;
    case 3LL:
      char v29 = __CFNumberTypeTable[v10];
      if ((v29 & 0x20) == 0)
      {
        if ((v29 & 0x40) != 0) {
          char v30 = v11[1];
        }
        else {
          char v30 = *v11;
        }
        *(_DWORD *)a3 = v30;
        return v30 == (int)v30;
      }

      if ((v29 & 0x40) == 0)
      {
        uint64_t v37 = *(float *)v11;
        *(_DWORD *)a3 = (int)*(float *)v11;
        uint64_t v39 = (float)(int)v37;
        return v37 == v39;
      }

      unint64_t v48 = *(double *)v11;
      char v49 = (int)*(double *)v11;
      *(_DWORD *)a3 = v49;
LABEL_106:
      uint64_t v57 = (double)v49;
      return v48 == v57;
    case 4LL:
      uint64_t v31 = __CFNumberTypeTable[v10];
      if ((v31 & 0x20) == 0)
      {
        if ((v31 & 0x40) == 0) {
          goto LABEL_60;
        }
        CFIndex v32 = v11[1];
        goto LABEL_61;
      }

      if ((v31 & 0x40) == 0)
      {
        uint64_t v37 = *(float *)v11;
        unsigned int v40 = (uint64_t)*(float *)v11;
        *(void *)a3 = v40;
        uint64_t v39 = (float)v40;
        return v37 == v39;
      }

      unint64_t v48 = *(double *)v11;
      *(void *)a3 = (uint64_t)*(double *)v11;
      uint64_t v57 = (double)(uint64_t)v48;
      return v48 == v57;
    case 5LL:
      int v33 = __CFNumberTypeTable[v10];
      if ((v33 & 0x20) != 0)
      {
        if ((v33 & 0x40) == 0)
        {
          *(_DWORD *)a3 = *(_DWORD *)v11;
          return 1LL;
        }

        unint64_t v48 = *(double *)v11;
        int v58 = *(double *)v11;
        *(float *)a3 = v58;
        uint64_t v57 = v58;
        return v48 == v57;
      }

      unint64_t v27 = *v11;
      if ((v33 & 0x40) == 0)
      {
        *(float *)a3 = (float)v27;
        unint64_t v28 = (uint64_t)(float)v27;
        return v27 == v28;
      }

      unint64_t v44 = v11[1];
      uint64_t v51 = -v27;
      if (v44) {
        uint64_t v51 = ~v27;
      }
      if (v27 >= 0) {
        uint64_t v52 = v44;
      }
      else {
        uint64_t v52 = -(uint64_t)v44;
      }
      if (v27 >= 0) {
        uint64_t v51 = v27;
      }
      uint64_t v53 = -((double)v52 + (double)v51 * 1.84467441e19);
      if (v27 >= 0) {
        uint64_t v53 = (double)v52 + (double)v51 * 1.84467441e19;
      }
      uint64_t v54 = v53;
      *(float *)a3 = v54;
      if (v54 < -1.7014e38) {
        goto LABEL_101;
      }
      if (v54 >= 1.7014e38) {
        goto LABEL_121;
      }
      unint64_t v47 = v54;
      goto LABEL_116;
    case 6LL:
      CFIndex v26 = __CFNumberTypeTable[v10];
      if ((v26 & 0x20) != 0)
      {
        if ((v26 & 0x40) == 0)
        {
          *(double *)a3 = *(float *)v11;
          return 1LL;
        }

  os_unfair_recursive_lock_unlock();
  return v13;
}

  char v30 = v20;
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  v339 = theString;
  v342 = location;
  v343 = length;
  v340 = CFStringGetCharactersPtr(theString);
  if (v340) {
    uint64_t v31 = 0LL;
  }
  else {
    uint64_t v31 = _CFStringGetCStringPtrInternal((unint64_t *)theString, 0x600u, 0, 1);
  }
  v341 = v31;
  v344 = 0LL;
  v345 = 0LL;
  v331 = theString2;
  v334 = 0LL;
  v335 = v13;
  unint64_t v44 = CFStringGetCharactersPtr(theString2);
  char v45 = 0LL;
  v332 = (UniChar *)v44;
  if (!v44) {
    char v45 = _CFStringGetCStringPtrInternal((unint64_t *)theString2, 0x600u, 0, 1);
  }
  v333 = v45;
  v336 = 0LL;
  v337 = 0LL;
  if (locale)
  {
    int64_t v46 = v321;
    LODWORD(v313) = ((v321 & 0x200) == 0) & (v321 >> 7);
    if ((v321 & 0x200) != 0) {
      v19 &= ~0x80uLL;
    }
    unint64_t v47 = v22;
  }

  else
  {
    unint64_t v47 = 0LL;
    int64_t v46 = v321;
    v313 = (v321 >> 7) & 1;
  }

  unint64_t v48 = v30;
  char v49 = v317;
  uint64_t v50 = 0LL;
  CFMutableDictionaryRef cf = locale;
  v297 = v14;
  v295 = v19;
  if (v22 >= length || v22 >= v13)
  {
    LOBYTE(v296) = 0;
    uint64_t v57 = v22;
    uint64_t v55 = 0LL;
    goto LABEL_407;
  }

  v280 = (__CFString *)theString2;
  uint64_t v51 = 0LL;
  uint64_t v52 = 0LL;
  uint64_t v53 = 0LL;
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v50 = 0LL;
  v296 = 0;
  v286 = 0LL;
  uint64_t v56 = v317 ^ 1;
  v281 = 0LL;
  uint64_t v57 = v22;
  int v58 = v47;
  v315 = length;
  v294 = v13;
LABEL_59:
  v298 = v53;
  v300 = v54;
  v303 = v58;
  v304 = v47;
LABEL_60:
  unsigned __int16 v59 = v22;
  uint64_t v60 = v57;
  uint64_t v53 = v298;
  unsigned int v61 = v300;
  int v62 = v311;
  v306 = v57;
  while (2)
  {
    unint64_t v63 = v60 - 4;
    v288 = v63;
    v287 = v63 + 64;
    unint64_t v64 = v60 + 1;
    int v65 = v60 - 3;
    v290 = v65;
    v289 = v65 + 64;
    if (v61 <= 0) {
      unint64_t v66 = 0LL;
    }
    else {
      unint64_t v66 = -1LL;
    }
    v314 = v66;
    v302 = v60;
    v318 = v61;
    v316 = v60 + 1;
    while (1)
    {
      if (v53)
      {
        unint64_t v67 = v347[v51++];
        if (v61) {
          goto LABEL_71;
        }
        goto LABEL_79;
      }

      if (v59 < 0 || (unint64_t v69 = v343, v343 <= v59))
      {
        unint64_t v67 = 0;
        goto LABEL_78;
      }

      unint64_t v70 = (UniChar *)v340;
      if (v340)
      {
        int v71 = v342 + v59;
      }

      else
      {
        if (v341)
        {
          unint64_t v72 = *(char *)(v341 + v342 + v59);
          goto LABEL_116;
        }

        if (v345 <= v59 || (uint64_t v109 = v344, v344 > v59))
        {
          unint64_t v110 = v59 - 4;
          if (v110 + 64 < v343) {
            unint64_t v69 = v110 + 64;
          }
          v344 = v110;
          v345 = v69;
          v350.unint64_t location = v342 + v110;
          v350.CFIndex length = v69 - v110;
          uint64_t v111 = v51;
          uint64_t v112 = v48;
          int v113 = v50;
          CFStringGetCharacters(v339, v350, v338);
          unint64_t v64 = v316;
          unsigned int v61 = v318;
          int64_t v46 = v321;
          uint64_t v57 = v306;
          uint64_t v56 = v317 ^ 1;
          uint64_t v51 = v111;
          int v58 = v303;
          unint64_t v47 = v304;
          uint64_t v50 = v113;
          char v49 = v317;
          unint64_t v48 = v112;
          uint64_t v109 = v344;
        }

        int v71 = v59 - v109;
        unint64_t v70 = v338;
      }

      unint64_t v72 = v70[v71];
LABEL_116:
      unint64_t v67 = v72;
      if ((v46 & 1) != 0 && v72 >= 0x41u && v72 <= 0x5Au)
      {
        if (__s1 && v72 == 73)
        {
          unint64_t v67 = 73;
        }

        else
        {
          if (v48) {
            int v105 = 1;
          }
          else {
            int v105 = (v46 & 0x200) == 0LL;
          }
          if (v105) {
            unint64_t v67 = v72 + 32;
          }
        }
      }

      Format = CFNumberFormatterGetFormat(v17);
      CFStringRef Copy = CFStringCreateCopy(0LL, Format);
      if (!a7)
      {
        if (*(_WORD *)(a4 + 2) == 33) {
          a6 = 0;
        }
        else {
          a6 = 6;
        }
      }

      unsigned int v61 = a6;
      if (*(_BYTE *)(a4 + 28) == 3)
      {
        if (!a6)
        {
          a6 = 1;
          unsigned int v61 = 1;
        }

        CFMutableCharacterSetRef Mutable = CFStringCreateMutable(0LL, 0LL);
        CFStringAppendCString(Mutable, "@", 0x600u);
        CFStringPad(Mutable, @"#", a6, 0LL);
        CFIndex v25 = *(double *)(a3 + 16LL * *(char *)(a4 + 24) + 8);
        CFIndex v26 = __exp10((double)a6);
        if (v25 > 0.0 && (v25 < 0.0001 || v25 > v26) || v25 < 0.0 && (v25 > -0.0001 || v25 < -v26))
        {
          CFStringAppendCString(Mutable, "E+00", 0x600u);
        }

        else if (a6 > __CFStringFormatLocalizedNumber_groupingSize)
        {
          if (__CFStringFormatLocalizedNumber_groupingSize)
          {
            CFStringInsert(Mutable, a6 - __CFStringFormatLocalizedNumber_groupingSize, @",");
            if (__CFStringFormatLocalizedNumber_secondaryGroupingSize)
            {
              if (a6 > __CFStringFormatLocalizedNumber_groupingSize
                      + __CFStringFormatLocalizedNumber_secondaryGroupingSize)
                CFStringInsert( Mutable,  a6 - (__CFStringFormatLocalizedNumber_groupingSize + __CFStringFormatLocalizedNumber_secondaryGroupingSize),  @",");
            }
          }
        }

        CFNumberFormatterSetFormat(v17, Mutable);
        CFRelease(Mutable);
      }

      int valuePtr = 0;
      unint64_t v27 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v27);
      unint64_t v28 = CFNumberCreate(0LL, kCFNumberSInt32Type, &v61);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMaxFractionDigitsKey", v28);
      if (*(_WORD *)(a4 + 2) == 34) {
        char v29 = v28;
      }
      else {
        char v29 = v27;
      }
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinFractionDigitsKey", v29);
      CFRelease(v28);
      CFRelease(v27);
      char v30 = *(char *)(a4 + 24);
      uint64_t v31 = *(__int16 *)(a3 + 16 * v30);
      if (v31 == 34)
      {
        LOBYTE(v32) = *(double *)(a3 + 16 * v30 + 8) < 0.0;
      }

      else
      {
        LOBYTE(v32) = 0;
        if (v31 == 33) {
          CFIndex v32 = *(void *)(a3 + 16 * v30 + 8) >> 63;
        }
      }

      int v33 = CFNumberFormatterGetFormat(v17);
      int v34 = *(_DWORD *)(a4 + 20);
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v33, 0LL);
      if ((v32 & 1) != 0 || (v34 & 4) == 0)
      {
        if (CharacterAtIndex == 43)
        {
          v63.CFIndex length = CFStringGetLength(v33) - 1;
          v63.unint64_t location = 1LL;
          MutableCFStringRef Copy = (__CFString *)CFStringCreateWithSubstring(0LL, v33, v63);
          goto LABEL_62;
        }
      }

      else if (CharacterAtIndex != 43)
      {
        MutableCFStringRef Copy = CFStringCreateMutableCopy(0LL, 0LL, @"+");
        CFStringAppend(MutableCopy, v33);
LABEL_62:
        CFNumberFormatterSetFormat(v17, MutableCopy);
        CFRelease(MutableCopy);
      }

      uint64_t v37 = *(_BYTE *)(a4 + 20) & 1;
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        uint64_t v38 = CFNumberCreate(0LL, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v38);
      }

      else
      {
        uint64_t v38 = CFNumberCreate(0LL, kCFNumberSInt32Type, length);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterFormatWidthKey", v38);
        if (!a7) {
          goto LABEL_69;
        }
      }

      if (*(_WORD *)(a4 + 2) == 33) {
        uint64_t v37 = 1;
      }
LABEL_69:
      if ((*(_DWORD *)(a4 + 20) & 2) != 0) {
        uint64_t v39 = 3;
      }
      else {
        uint64_t v39 = v37;
      }
      int v58 = 0;
      unsigned __int16 v59 = v39;
      CFNumberGetValue(v38, kCFNumberSInt32Type, &v58);
      if (v37 && v58 >= 1 && v59 && *(_WORD *)(a4 + 2) != 34) {
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinIntegerDigitsKey", v38);
      }
      CFRelease(v38);
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        LODWORD(v57[0]) = 1;
        unsigned int v40 = (int *)v57;
      }

      else
      {
        unsigned int v40 = &v59;
      }

      __int16 v41 = CFNumberCreate(0LL, kCFNumberSInt32Type, v40);
      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterPaddingPositionKey", v41);
      CFRelease(v41);
      if (v37)
      {
        int v42 = *(unsigned __int8 *)(a4 + 28);
        if (v42 != 3) {
          goto LABEL_86;
        }
        unint64_t v43 = @"0";
      }

      else
      {
        unint64_t v43 = @" ";
      }

      CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterPaddingCharacterKey", v43);
      int v42 = *(unsigned __int8 *)(a4 + 28);
LABEL_86:
      if (v42 == 2)
      {
        ++v61;
        unint64_t v44 = CFNumberCreate(0LL, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMinSignificantDigitsKey", v44);
        CFNumberFormatterSetProperty(v17, @"kCFNumberFormatterMaxSignificantDigitsKey", v44);
        CFRelease(v44);
      }

      char v45 = *(__int16 *)(a4 + 2);
      if (v45 == 34)
      {
        char v49 = a3 + 16LL * *(char *)(a4 + 24);
        if (*(_WORD *)(v49 + 2) == 5)
        {
          v57[0] = *(void *)(v49 + 8);
          int64_t v46 = v57;
        }

        else
        {
          int64_t v46 = (void *)(v49 + 8);
        }

        unint64_t v47 = v17;
        unint64_t v48 = kCFNumberDoubleType;
      }

      else
      {
        if (v45 != 33)
        {
          StringWithValue = 0LL;
          goto LABEL_99;
        }

        if ((*(_BYTE *)(a4 + 28) & 4) != 0)
        {
          uint64_t v51 = *(void *)(a3 + 16LL * *(char *)(a4 + 24) + 8);
          v57[0] = 0LL;
          v57[1] = v51;
          int64_t v46 = v57;
          unint64_t v47 = v17;
          unint64_t v48 = kCFNumberMaxType|kCFNumberSInt8Type;
        }

        else
        {
          int64_t v46 = (void *)(a3 + 16LL * *(char *)(a4 + 24) + 8);
          unint64_t v47 = v17;
          unint64_t v48 = kCFNumberSInt64Type;
        }
      }

      StringWithValue = CFNumberFormatterCreateStringWithValue(0LL, v47, v48, v46);
LABEL_99:
      CFNumberFormatterSetFormat(v17, Copy);
      CFRelease(Copy);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
      if (!StringWithValue) {
        return 0LL;
      }
      if (a7)
      {
        if (*(_WORD *)(a4 + 2) == 33)
        {
          uint64_t v52 = CFStringGetLength(StringWithValue);
          if (v52 < length[0])
          {
            if (v59 == 3)
            {
              uint64_t v53 = CFStringCreateMutableCopy(0LL, 0LL, StringWithValue);
              CFStringPad(v53, @" ", length[0], 0LL);
            }

            else
            {
              uint64_t v53 = CFStringCreateMutable(0LL, 0LL);
              uint64_t v55 = length[0];
              uint64_t v56 = CFStringGetLength(StringWithValue);
              CFStringPad(v53, @" ", v55 - v56, 0LL);
              CFStringAppend(v53, StringWithValue);
            }

            CFRelease(StringWithValue);
            StringWithValue = v53;
          }
        }
      }

      CFStringAppend(a1, StringWithValue);
      CFRelease(StringWithValue);
      return 1LL;
    default:
      __CFStringFormatLocalizedNumber_cold_1();
  }

  unint64_t v28 = &a2[v24];
LABEL_29:
  if (v24 < a3)
  {
    while (!*v28)
    {
      ++v24;
      ++v28;
      if (a3 == v24) {
        goto LABEL_34;
      }
    }
  }

  if (v24 != a3)
  {
    CFIndex v32 = 0LL;
    goto LABEL_60;
  }

        unint64_t v24 = 1LL;
        goto LABEL_31;
      }
    }

    else
    {
LABEL_41:
      LOWORD(v25) = -3;
    }

        CFIndex v25 = 1LL;
        goto LABEL_31;
      }
    }

    else
    {
LABEL_41:
      LOWORD(v26) = -3;
    }

    v14[3] = 8LL;
    *((_BYTE *)v14 + 32) = 0;
    *((_BYTE *)v14 + 33) = *((_BYTE *)v14 + 16) - 8;
LABEL_29:
    if (*v34)
    {
      uint64_t v18 = 0LL;
      do
      {
        uint64_t v37 = parseFrameArgumentInfo((uint64_t *)&v34, 0LL, 0, 0LL);
        if (!v37) {
          break;
        }
        ++v13[4];
        v13[5] = computeReturnFrameExtent((uint64_t *)&v37, (uint64_t *)keyCallBacks);
        unsigned int v19 = v37;
        if (!*((void *)v13 + 1)) {
          *((void *)v13 + 1) = v37;
        }
        if (v18) {
          v18[1] = (uint64_t)v19;
        }
        uint64_t v18 = v19;
      }

      while (*v34);
    }

    char v20 = objc_alloc((Class)a1);
    v20[1] = v13;
    is_memory_immutable = _dyld_is_memory_immutable();
    unsigned int v22 = (void *)types;
    if ((is_memory_immutable & 1) == 0) {
      unsigned int v22 = strdup(types);
    }
    v20[2] = v22;
    char v23 = v13[4];
    if (v23)
    {
      unint64_t v24 = *(void *)(*((void *)v13 + 1) + 8LL);
      if (v23 == 1 || *(_BYTE *)(v24 + 36) != 58)
      {
        CFIndex v25 = 1;
      }

      else
      {
        unint64_t v24 = *(void *)(v24 + 8);
        CFIndex v25 = 2;
      }

      CFIndex v26 = v23 >= v25;
      unint64_t v27 = v23 - v25;
      if (v27 != 0 && v26)
      {
        while ((*(_WORD *)(v24 + 34) & 0x2000) != 0)
        {
          unint64_t v24 = *(void *)(v24 + 8);
          if (!--v27) {
            goto LABEL_48;
          }
        }
      }

      else
      {
LABEL_48:
        v20[3] |= 2uLL;
      }
    }

    os_unfair_lock_lock_with_options();
    Value = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)signatureWithObjCTypes__cache, types);
    if (!Value)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)signatureWithObjCTypes__cache, types, v20);
      Value = (unint64_t)v20;
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&signatureWithObjCTypes__lock);

    return (NSMethodSignature *)Value;
  }

  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'",  types);
  CFIndex v32 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
  objc_exception_throw(v32);
LABEL_60:
  __break(1u);
  return result;
}

        if (!v10[v15])
        {
          char v20 = *(void *)(a1 + 8 * v11);
          v10[v15] = v20;
          if ((a3 & 1) == 0 && v20 >= 1) {
            uint64_t v21 = (id)v20;
          }
          *(_DWORD *)(v23 + 28) = *(_DWORD *)(v23 + 28) & 0xFC000000 | (*(_DWORD *)(v23 + 28) + 1) & 0x3FFFFFF;
        }

        ++v11;
      }

      while (v11 != a2);
    }
  }

  return v23;
}

        __break(1u);
      }

      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v10);
    }
  }

  else
  {
    uint64_t v10 = xmmword_180D7EA48;
    unint64_t v11 = unk_180D7EA58;
  }

    unsigned int v19 = v13 + v18 * v10;
    if (v7 <= v19) {
      v19 %= v7;
    }
    v18 *= v14;
    if (v7 <= v18) {
      v18 %= v7;
    }
    if (!--v17) {
      goto LABEL_35;
    }
  }

  uint64_t v21 = v30;
LABEL_42:
  unint64_t v24 = v28;
  *unint64_t v28 = v19;
  CFIndex v26 = *(void *)(*(void *)(a1 + 40) + 8 * v19);
  if (v26 == 2814029233LL)
  {
    CFIndex v26 = 0LL;
  }

  else if (v26 == 2780474809LL)
  {
    CFIndex v26 = -1LL;
  }

  v28[1] = v21;
  v28[2] = v26;
  unint64_t v27 = *(unsigned __int16 *)(a1 + 18);
  if ((v27 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  char v20 = 1LL;
LABEL_36:
  v24[3] = v20;
  return result;
}

void __CFCSetMakeBitmap(char *cf)
{
  uint64_t v2 = (unint64_t *)(cf + 8);
  char v3 = atomic_load((unint64_t *)cf + 1);
  if ((v3 & 0x70) != 0x30LL || !*((void *)cf + 3))
  {
    unint64_t v4 = CFGetAllocator(cf);
    uint64_t v5 = (int8x16_t *)CFAllocatorAllocate(v4, 0x2000LL, 0LL);
    __CFCSetGetBitmap((uint64_t)cf, v5);
    char v6 = atomic_load(v2);
    if ((v6 & 0x70) != 0)
    {
      char v7 = atomic_load(v2);
      if ((v7 & 0x70) == 0x40LL && (uint64_t v8 = (void *)*((void *)cf + 3)) != 0LL
        || (char v9 = atomic_load(v2), (v9 & 0x70) == 0x20LL) && (v8 = (void *)*((void *)cf + 3)) != 0LL)
      {
        CFAllocatorDeallocate(v4, v8);
        *((void *)cf + 3) = 0LL;
      }

      else
      {
        char v17 = atomic_load(v2);
        if ((v17 & 0x70) == 0x10LL)
        {
          uint64_t v18 = *((void *)cf + 5);
          if (v18 && *(_DWORD *)(v18 + 8))
          {
            __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((void *)cf + 4));
          }

          else
          {
            char v19 = atomic_load((unint64_t *)cf + 1);
            __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((void *)cf + 4));
            if ((v19 & 8) != 0)
            {
              char v20 = (char *)*((void *)cf + 5);
              if (!v20)
              {
                uint64_t v21 = CFGetAllocator(cf);
                char v20 = (char *)CFAllocatorAllocate(v21, 16LL, 0LL);
                *((void *)cf + 5) = v20;
                *(void *)char v20 = 0LL;
                *(void *)(v20 + 6) = 0LL;
              }

              v20[13] = 1;
            }
          }
        }
      }

      goto LABEL_73;
    }

    unsigned int NumberOfPlanes = CFUniCharGetNumberOfPlanes(*((_DWORD *)cf + 6));
    if (NumberOfPlanes < 2)
    {
LABEL_73:
      unint64_t v50 = atomic_load(v2);
      while (1)
      {
        unint64_t v51 = __ldaxr(v2);
        if (v51 != v50) {
          break;
        }
        if (__stlxr(v50 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v2)) {
          goto LABEL_78;
        }
        int v52 = 1;
LABEL_79:
        unint64_t v50 = v51;
        if (v52)
        {
          *((void *)cf + 3) = v5;
          unint64_t v53 = atomic_load((unint64_t *)cf + 1);
          while (1)
          {
            unint64_t v54 = __ldaxr(v2);
            if (v54 != v53) {
              break;
            }
            if (__stlxr(v53 & 0xFFFFFFFFFFFFFFF7LL, v2)) {
              goto LABEL_85;
            }
            int v55 = 1;
LABEL_86:
            unint64_t v53 = v54;
            if (v55) {
              return;
            }
          }

          __clrex();
LABEL_85:
          int v55 = 0;
          goto LABEL_86;
        }
      }

      __clrex();
LABEL_78:
      int v52 = 0;
      goto LABEL_79;
    }

    unsigned int v11 = NumberOfPlanes;
    unsigned __int8 v12 = NumberOfPlanes - 1;
    unint64_t v13 = (uint64_t *)*((void *)cf + 5);
    if (v13)
    {
      if (*((unsigned __int8 *)v13 + 12) < v12)
      {
        *((_BYTE *)v13 + 12) = v12;
        uint64_t v14 = *v13;
        char v15 = (malloc_zone_t *)CFGetAllocator(cf);
        if (v14) {
          char v16 = __CFSafelyReallocateWithAllocator(v15, **((void ***)cf + 5), 8LL * v12, 0LL, 0LL);
        }
        else {
          char v16 = CFAllocatorAllocate((CFAllocatorRef)v15, 8LL * v12, 0LL);
        }
        **((void **)cf + 5) = v16;
      }
    }

    else
    {
      unsigned int v22 = CFGetAllocator(cf);
      char v23 = CFAllocatorAllocate(v22, 16LL, 0LL);
      *((void *)cf + 5) = v23;
      v23[12] = v12;
      v23[13] = 0;
      *((_DWORD *)v23 + 2) = 0;
      if (v12)
      {
        unint64_t v24 = CFGetAllocator(cf);
        CFIndex v25 = CFAllocatorAllocate(v24, 8LL * v12, 0LL);
        char v23 = (_BYTE *)*((void *)cf + 5);
      }

      else
      {
        CFIndex v25 = 0LL;
      }

      *(void *)char v23 = v25;
    }

    CFIndex v26 = 0LL;
    unsigned int v27 = 1;
    while (1)
    {
      if (!v26) {
        CFIndex v26 = CFAllocatorAllocate(v4, 0x2000LL, 0LL);
      }
      int BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)cf + 6), v27, v26, 0);
      if (BitmapForPlane == 255) {
        goto LABEL_70;
      }
      if (BitmapForPlane == 1) {
        memset(v26, 255, 0x2000uLL);
      }
      if (!(_BYTE)v27)
      {
        __break(1u);
        return;
      }

LABEL_69:
      CFIndex v26 = 0LL;
LABEL_70:
      if (++v27 == v11)
      {
        if (v26) {
          CFAllocatorDeallocate(v4, v26);
        }
        goto LABEL_73;
      }
    }

    char v29 = (uint64_t *)*((void *)cf + 5);
    if (v29)
    {
      *((_BYTE *)v29 + 12) = v27;
      uint64_t v30 = *v29;
      uint64_t v31 = (malloc_zone_t *)CFGetAllocator(cf);
      if (v30)
      {
        CFIndex v32 = __CFSafelyReallocateWithAllocator( v31,  **((void ***)cf + 5),  8 * v27,  0LL,  0LL);
LABEL_43:
        char v29 = (uint64_t *)*((void *)cf + 5);
        *char v29 = (uint64_t)v32;
LABEL_44:
        if (((_DWORD)v29[1] & (1 << v27)) != 0)
        {
          uint64_t v36 = v27 - 1;
        }

        else
        {
          uint64_t v37 = CFGetAllocator(cf);
          CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v37);
          uint64_t v36 = v27 - 1;
          *(void *)(**((void **)cf + 5) + 8LL * v36) = Mutable;
          char v29 = (uint64_t *)*((void *)cf + 5);
          *((_DWORD *)v29 + 2) |= 1 << v27;
        }

        uint64_t v39 = *(void *)(*v29 + 8 * v36);
        if (v39)
        {
          unsigned int v40 = (unint64_t *)(v39 + 8);
          unint64_t v41 = atomic_load((unint64_t *)(v39 + 8));
          while (1)
          {
            unint64_t v42 = __ldaxr(v40);
            if (v42 != v41) {
              break;
            }
            if (__stlxr(v41 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v40)) {
              goto LABEL_53;
            }
            int v43 = 1;
LABEL_54:
            unint64_t v41 = v42;
            if (v43)
            {
              *(void *)(v39 + 24) = v26;
              unint64_t v44 = atomic_load((unint64_t *)(v39 + 8));
              while (1)
              {
                unint64_t v45 = __ldaxr(v40);
                if (v45 != v44) {
                  break;
                }
                if (__stlxr(v44 & 0xFFFFFFFFFFFFFFF7LL, v40)) {
                  goto LABEL_60;
                }
                int v46 = 1;
LABEL_61:
                unint64_t v44 = v45;
                if (v46)
                {
                  unint64_t v47 = atomic_load(v40);
                  while (1)
                  {
                    unint64_t v48 = __ldaxr(v40);
                    if (v48 != v47) {
                      break;
                    }
                    if (__stlxr(v47 & 0xFFFFFFFFFFFFFFFBLL, v40)) {
                      goto LABEL_67;
                    }
                    int v49 = 1;
LABEL_68:
                    unint64_t v47 = v48;
                    if (v49) {
                      goto LABEL_69;
                    }
                  }

                  __clrex();
LABEL_67:
                  int v49 = 0;
                  goto LABEL_68;
                }
              }

              __clrex();
LABEL_60:
              int v46 = 0;
              goto LABEL_61;
            }
          }

          __clrex();
LABEL_53:
          int v43 = 0;
          goto LABEL_54;
        }

        goto LABEL_69;
      }

      CFIndex v35 = 8 * v27;
    }

    else
    {
      int v33 = CFGetAllocator(cf);
      int v34 = CFAllocatorAllocate(v33, 16LL, 0LL);
      *((void *)cf + 5) = v34;
      v34[6] = v27;
      *((_DWORD *)v34 + 2) = 0;
      uint64_t v31 = (malloc_zone_t *)CFGetAllocator(cf);
      CFIndex v35 = 8 * v27;
    }

    CFIndex v32 = CFAllocatorAllocate((CFAllocatorRef)v31, v35, 0LL);
    goto LABEL_43;
  }

        if (!readdir_r(v21, &v51, &v47))
        {
          char v23 = v47;
          if (v47) {
            continue;
          }
        }

        goto LABEL_77;
      }
    }
  }

  unint64_t v44 = 0;
LABEL_77:
  uint64_t v39 = closedir(v21);
  if (v45 != -1) {
    close(v45);
  }
  if (v39)
  {
    CFRelease(Mutable);
    if (v44) {
      CFRelease(v7);
    }
    unsigned int v40 = cf;
    if ((v46 & 1) != 0) {
      return 0LL;
    }
    goto LABEL_90;
  }

  if ((v46 & 1) == 0) {
    CFRelease(cf);
  }
  if (v44) {
    CFRelease(v7);
  }
  return Mutable;
}

        int v33 = 1;
      }

      break;
    case 1:
      int v34 = v15;
      CFIndex v35 = theData;
      if ((v46 & 0x20) != 0)
      {
        if (v30)
        {
          int v33 = 1;
          if (!CFSocketIsValid((CFSocketRef)a1) || !v29) {
            break;
          }
        }

        else if (!v29)
        {
          goto LABEL_69;
        }

        int v33 = 1;
        v29(a1, 1LL, 0LL, 0LL, v48);
      }

      break;
    default:
      int v34 = v15;
      CFIndex v35 = theData;
      break;
  }

  if ((v18 & 8) != 0 && (v21 & 0x40) != 0 && !v53 && (!v33 || CFSocketIsValid((CFSocketRef)a1)) && v29) {
    v29(a1, 8LL, 0LL, 0LL, v48);
  }
  if (v50) {
    v50(v47);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v34) {
    CFRelease(v34);
  }
  pthread_mutex_lock(v2);
  uint64_t v37 = 0LL;
  uint64_t v38 = atomic_load(v3);
  if ((v52 & 2) != 0)
  {
    uint64_t v39 = v51;
    if ((v38 & 0x10) != 0)
    {
      unsigned int v40 = *(const __CFArray **)(a1 + 256);
      if (v40 && CFArrayGetCount(v40) >= 1)
      {
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 192));
        unint64_t v41 = CFRetain(*(CFTypeRef *)(a1 + 200));
        MutableCFStringRef Copy = CFArrayCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  *(CFArrayRef *)(a1 + 200));
        int v43 = *(void **)(a1 + 192);
        if (v43)
        {
          if (CFRunLoopSourceIsValid(*(CFRunLoopSourceRef *)(a1 + 192)))
          {
            CFRetain(v43);
            unint64_t v44 = 0;
            goto LABEL_94;
          }

          int v43 = 0LL;
        }

        unint64_t v44 = 1;
LABEL_94:
        pthread_mutex_unlock(v2);
        uint64_t v37 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v43, MutableCopy);
        if ((v44 & 1) == 0) {
          CFRelease(v43);
        }
        pthread_mutex_lock(v2);
        if (v41 == *(CFTypeRef *)(a1 + 200))
        {
          *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = MutableCopy;
          CFRelease(v41);
          unint64_t v45 = (const __CFArray *)v41;
LABEL_100:
          CFRelease(v45);
        }

        else
        {
          CFRelease(v41);
          if (MutableCopy)
          {
            unint64_t v45 = MutableCopy;
            goto LABEL_100;
          }
        }
      }

      else
      {
        uint64_t v37 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v39 = v51;
  }

  __CFSocketEnableCallBacks(a1, *(_DWORD *)(a1 + 16) & v39, 0);
  if (v37)
  {
    CFRunLoopWakeUp((CFRunLoopRef)v37);
    CFRelease(v37);
  }

  int v33 = v13 - 44032;
  if (v13 - 4352 >= 0xFA && v33 >> 4 > 0x2BA) {
    goto LABEL_160;
  }
  if (v13 >> 5 >= 0x8B)
  {
    if (v13 >> 3 >= 0x235)
    {
      if (v13 >> 10 >= 0x2B)
      {
        HIDWORD(v38) = -1227133513 * v33;
        LODWORD(v38) = -1227133513 * v33;
        else {
          int v34 = 4;
        }
      }

      else
      {
        int v34 = 2;
      }
    }

    else
    {
      int v34 = 1;
    }
  }

  else
  {
    int v34 = 0;
  }

  if (v7 >= 1)
  {
    uint64_t v39 = -v7;
    unsigned int v40 = v7 + 64;
    unint64_t v41 = v34;
    while (1)
    {
      else {
        unint64_t v42 = v7;
      }
      int v43 = *((void *)buffer + 20);
      if (v43 < v7) {
        goto LABEL_123;
      }
      unint64_t v44 = *((void *)buffer + 17);
      if (v44)
      {
        unint64_t v45 = *(_WORD *)(v44 + 2 * (v7 + *((void *)buffer + 19)) - 2);
      }

      else
      {
        int v46 = *((void *)buffer + 18);
        if (v46)
        {
          unint64_t v45 = *(char *)(v46 + *((void *)buffer + 19) + v7 - 1);
        }

        else
        {
          if (*((void *)buffer + 22) < v7 || (unint64_t v47 = *((void *)buffer + 21), v47 >= v7))
          {
            unint64_t v48 = -v42;
            int v49 = v42 + v39;
            unint64_t v50 = v40 - v42;
            unint64_t v51 = v7 + v48;
            int v52 = v51 + 64;
            if (v51 + 64 >= v43) {
              int v52 = *((void *)buffer + 20);
            }
            *((void *)buffer + 21) = v51;
            *((void *)buffer + 22) = v52;
            if (v43 >= v50) {
              int v43 = v50;
            }
            v99.CFIndex length = v43 + v49;
            v99.unint64_t location = v51 + *((void *)buffer + 19);
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v99, buffer);
            unint64_t v47 = *((void *)buffer + 21);
          }

          unint64_t v45 = buffer[v7 - 1 - v47];
        }
      }

      if (v41 == 2) {
        break;
      }
      unint64_t v53 = v45 >> 5;
      if (v41 == 1)
      {
        if (v53 >= 0x8B)
        {
          if (v45 >> 10 >= 0x2Bu)
          {
            HIDWORD(v54) = -1840706560 - 1227133513 * v45;
            LODWORD(v54) = HIDWORD(v54);
            unint64_t v41 = 3;
            goto LABEL_121;
          }

          if (v45 > 0x11A2u) {
            goto LABEL_123;
          }
          goto LABEL_118;
        }
      }

      else if (v53 > 0x8A)
      {
        goto LABEL_123;
      }

      unint64_t v41 = 0;
LABEL_121:
      --v7;
      ++v39;
      --v40;
      if ((unint64_t)(v7 + 1) <= 1)
      {
        char v7 = 0LL;
        goto LABEL_123;
      }
    }

    if (v45 - 4448 >= 0x43)
    {
      if (v45 >> 10 < 0x2Bu)
      {
        if (v45 >> 5 < 0x8Bu) {
          goto LABEL_123;
        }
        unint64_t v41 = 2;
      }

      else
      {
        HIDWORD(v55) = -1840706560 - 1227133513 * v45;
        LODWORD(v55) = HIDWORD(v55);
        else {
          unint64_t v41 = 4;
        }
      }

      goto LABEL_121;
    }

  if (v41[1])
  {
    int v33 = *(__CFSet **)(a1 + 152);
    if (!v33)
    {
      int v33 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFCopyStringSetCallBacks);
      *(void *)(a1 + 152) = v33;
    }

    CFSetAddValue(v33, a2);
  }

  if (v27) {
    uint64_t v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFDictionaryRef)v27);
  }
  else {
    uint64_t v21 = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  CFRelease(Mutable);
LABEL_77:
  int v52 = v37;
  unint64_t v53 = v38;
  unint64_t v54 = v39;
  unint64_t v50 = v35;
  unint64_t v51 = v36;
  _CFBundleReleaseStringsSources((uint64_t)&v50);
  CFRelease(cfa);
  if (v42) {
    CFRelease(v42);
  }
  if (v12) {
LABEL_80:
  }
    CFRelease(v12);
  return v21;
}

    char v16 = 0;
LABEL_70:
    unsigned int v40 = 1;
    goto LABEL_71;
  }

  uint64_t v37 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
  {
    if (v17) {
      uint64_t v38 = "create";
    }
    else {
      uint64_t v38 = "open";
    }
    uint64_t v39 = *__error();
    *(_DWORD *)buf = 136446723;
    uint64_t v60 = v38;
    unsigned int v61 = 2081;
    int v62 = __s2;
    unint64_t v63 = 1024;
    LODWORD(v64) = v39;
    _os_log_impl( &dword_180A4C000,  v37,  OS_LOG_TYPE_INFO,  "Couldn't %{public}s %{private}s due to %{darwin.errno}d. Asking client to create directory.",  buf,  0x1Cu);
  }

  unsigned int v40 = 0;
  char v16 = 5;
LABEL_71:
  if ((v57 & 0x80000000) == 0) {
    close(v57);
  }
  if (v40)
  {
    unint64_t v42 = *__error();
    int v43 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      if (v17) {
        unint64_t v53 = "create";
      }
      else {
        unint64_t v53 = "open";
      }
      unint64_t v54 = strerror(v42);
      *(_DWORD *)buf = 136446723;
      uint64_t v60 = v53;
      unsigned int v61 = 2081;
      int v62 = __s2;
      unint64_t v63 = 2082;
      unint64_t v64 = v54;
      _os_log_debug_impl( &dword_180A4C000,  v43,  OS_LOG_TYPE_DEBUG,  "Couldn't %{public}s %{private}s due to %{public}s",  buf,  0x20u);
    }

    if (v42 == 1
      && (cacheFileInfoForWriting_euid_egid_didCreate__deviceEverUnlocked & 1) == 0
      && (*(_BYTE *)(v11 + 142) & 0x20) == 0)
    {
      *(_BYTE *)(v11 + 142) |= 0x20u;
      out_token.st_dev = 0;
      objc_initWeak((id *)buf, (id)v11);
      unint64_t v44 = qos_class_main();
      global_queue = dispatch_get_global_queue(v44, 2uLL);
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3221225472LL;
      handler[2] = __58__CFPDSource_cacheFileInfoForWriting_euid_egid_didCreate___block_invoke;
      handler[3] = &unk_1899ED530;
      objc_copyWeak(&v56, (id *)buf);
      notify_register_dispatch("com.apple.mobile.keybagd.lock_status", &out_token.st_dev, global_queue, handler);
      objc_destroyWeak(&v56);
      objc_destroyWeak((id *)buf);
    }

    return 7;
  }

  return v16;
}

                char v29 = a1[6];
                CFMutableCharacterSetRef Mutable = CFArrayCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeArrayCallBacks);
                unsigned int v40 = v29;
                if (_CFGetProductName_onceToken != -1) {
                  dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
                }
                uint64_t v31 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@-%@~%@",  v23,  @"tvos",  _CFGetProductName__cfBundlePlatform);
                if (_CFGetProductName_onceToken != -1) {
                  dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
                }
                CFIndex v32 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@~%@",  v23,  _CFGetProductName__cfBundlePlatform);
                int v33 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@-%@",  v23,  @"tvos");
                CFArrayAppendValue(Mutable, v31);
                CFArrayAppendValue(Mutable, v32);
                CFArrayAppendValue(Mutable, v33);
                CFRelease(v31);
                CFRelease(v32);
                CFRelease(v33);
                int v34 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
                CFIndex Count = CFArrayGetCount(Mutable);
                v41[0] = MEMORY[0x1895F87A8];
                v41[1] = 0x40000000LL;
                v41[2] = ___CopySortedOverridesForBaseKey_block_invoke;
                v41[3] = &__block_descriptor_tmp_65;
                v41[4] = v40;
                v41[5] = v34;
                CFArrayApply((uint64_t)Mutable, 0LL, Count, (uint64_t)v41);
                CFRelease(Mutable);
                ValueAtIndex = CFArrayGetValueAtIndex(v34, 0LL);
                uint64_t v37 = a1[5];
                uint64_t v38 = CFDictionaryGetValue(a1[6], ValueAtIndex);
                CFDictionarySetValue(v37, v23, v38);
                uint64_t v39 = CFArrayGetCount(v34);
                if (v39 >= 1)
                {
                  v49.unint64_t location = 1LL;
                  v49.CFIndex length = v39 - 1;
                  CFArrayAppendArray(a1[4], v34, v49);
                }

                CFRelease(v34);
                if (!v24) {
                  goto LABEL_77;
                }
LABEL_76:
                CFRelease(v24);
LABEL_77:
                if (v25) {
                  CFRelease(v25);
                }
                CFRelease(v23);
                return;
              }

              unsigned int v27 = @"tvos";
              unint64_t v28 = v24;
            }

            else
            {
              if (_CFGetProductName_onceToken != -1) {
                dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
              }
              unsigned int v27 = (const __CFString *)_CFGetProductName__cfBundlePlatform;
              unint64_t v28 = v25;
            }

            CFIndex v26 = CFEqual(v27, v28);
            goto LABEL_68;
          }

          char v19 = @"tvos";
          char v20 = cf;
          v21.unint64_t location = v18;
          v21.CFIndex length = v17;
        }

        else
        {
          char v19 = @"appletv";
          char v20 = cf;
          v21.unint64_t location = v14;
          v21.CFIndex length = v16;
        }

        unsigned int v22 = CFStringFindWithOptions(v20, v19, v21, 8uLL, 0LL);
        goto LABEL_46;
      }
    }
  }

void __CFCSetAddNonBMPPlanesInRange(CFTypeRef cf, unint64_t a2, int a3)
{
  unint64_t v3 = a2 >> 16;
  else {
    int v4 = ((int)a2 + a3 - 1) >> 16;
  }
  if ((int)v3 <= 16)
  {
    uint64_t v6 = *((void *)cf + 5);
    if (v6) {
      BOOL v46 = *(_BYTE *)(v6 + 13) != 0;
    }
    else {
      BOOL v46 = 0;
    }
    else {
      int v7 = a2 >> 16;
    }
    if (v7 <= v4)
    {
      CFIndex v8 = (unsigned __int16)a2;
      int v45 = (unsigned __int16)(a2 + a3);
      uint64_t v9 = (unsigned __int16)(a2 + a3);
      __int16 v10 = 8 * v7;
      while (1)
      {
        if (v45) {
          BOOL v11 = v4 == v7;
        }
        else {
          BOOL v11 = 0;
        }
        uint64_t v12 = 0x10000LL;
        if (v11) {
          uint64_t v12 = v9;
        }
        CFIndex v13 = v12 - v8;
        if (v46)
        {
          if (!(_BYTE)v7) {
            goto LABEL_72;
          }
          if (v7 > 0x10u
            || (uint64_t v14 = (uint64_t *)*((void *)cf + 5)) == 0LL
            || ((*((_DWORD *)v14 + 2) >> v7) & 1) == 0
            || *((unsigned __int8 *)v14 + 12) < v7
            || (uint64_t v15 = *v14, (v16 = *(unint64_t **)(v15 + 8LL * (v7 - 1))) == 0LL))
          {
            char v23 = CFGetAllocator(cf);
            CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v23);
            v48.unint64_t location = v8;
            v48.CFIndex length = v13;
            CFCharacterSetAddCharactersInRange(Mutable, v48);
            CFIndex v25 = (uint64_t *)*((void *)cf + 5);
            if (v25)
            {
              if (*((unsigned __int8 *)v25 + 12) < v7)
              {
                *((_BYTE *)v25 + 12) = v7;
                uint64_t v26 = *v25;
                unsigned int v27 = (malloc_zone_t *)CFGetAllocator(cf);
                if (v26)
                {
                  unint64_t v28 = __CFSafelyReallocateWithAllocator(v27, **((void ***)cf + 5), v10 & 0x7F8, 0LL, 0LL);
                  goto LABEL_43;
                }

LABEL_42:
                unint64_t v28 = CFAllocatorAllocate((CFAllocatorRef)v27, v10 & 0x7F8, 0LL);
LABEL_43:
                CFIndex v25 = (uint64_t *)*((void *)cf + 5);
                *CFIndex v25 = (uint64_t)v28;
              }

              int v31 = 1 << v7;
              if (((_DWORD)v25[1] & (1 << v7)) != 0) {
                CFRelease(*(CFTypeRef *)(*v25 + 8LL * (v7 - 1)));
              }
              if (Mutable)
              {
                *(void *)(**((void **)cf + 5) + 8LL * (v7 - 1)) = CFRetain(Mutable);
                uint64_t v32 = *((void *)cf + 5);
                int v33 = *(_DWORD *)(v32 + 8) | v31;
              }

              else
              {
                uint64_t v32 = *((void *)cf + 5);
                int v33 = *(_DWORD *)(v32 + 8) & ~v31;
              }

              *(_DWORD *)(v32 + 8) = v33;
              CFRelease(Mutable);
              goto LABEL_58;
            }

            char v29 = CFGetAllocator(cf);
            uint64_t v30 = CFAllocatorAllocate(v29, 16LL, 0LL);
            *((void *)cf + 5) = v30;
            v30[6] = v7;
            *((_DWORD *)v30 + 2) = 0;
            unsigned int v27 = (malloc_zone_t *)CFGetAllocator(cf);
            goto LABEL_42;
          }

          v47.unint64_t location = v8;
          v47.CFIndex length = v13;
          CFCharacterSetRemoveCharactersInRange( *(CFMutableCharacterSetRef *)(v15 + 8LL * (v7 - 1)),  v47);
          unint64_t v17 = v16[5];
          if (!v17 || !*(_DWORD *)(v17 + 8) && !*(_BYTE *)(v17 + 13))
          {
            unsigned int v18 = atomic_load(v16 + 1);
            switch((v18 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (!v16[4]) {
                  goto LABEL_61;
                }
                break;
              case 3u:
              case 4u:
                if (!v16[3])
                {
LABEL_61:
                  char v40 = atomic_load(v16 + 1);
                  if ((v40 & 8) == 0)
                  {
                    CFRelease(v16);
                    *(_DWORD *)(*((void *)cf + 5) + 8LL) &= ~(1 << v7);
                  }
                }

                break;
              default:
                break;
            }
          }
        }

        else
        {
          if (!(_BYTE)v7)
          {
LABEL_72:
            __break(1u);
            return;
          }

          if (v7 <= 0x10u)
          {
            char v19 = (uint64_t *)*((void *)cf + 5);
            if (v19)
            {
              if (*((unsigned __int8 *)v19 + 12) < v7)
              {
                *((_BYTE *)v19 + 12) = v7;
                uint64_t v20 = *v19;
                uint64_t v21 = (malloc_zone_t *)CFGetAllocator(cf);
                if (v20)
                {
                  unsigned int v22 = __CFSafelyReallocateWithAllocator(v21, **((void ***)cf + 5), v10 & 0x7F8, 0LL, 0LL);
                  goto LABEL_52;
                }

    unint64_t v41 = atomic_load(v39);
    uint64_t v42 = atomic_load(v39);
    if ((v41 & 0x70) == 0x10LL)
    {
      int v43 = *(_DWORD *)(v4 + 24);
      if ((v42 & 8) != 0)
      {
        unint64_t v50 = *(void *)(v4 + 32);
        if (v43)
        {
          v138.unint64_t location = 0LL;
          v138.CFIndex length = *(unsigned int *)(v4 + 24);
          CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)v5, v138);
        }

        v45.unint64_t location = (v43 + v50);
        v45.CFIndex length = (1114112 - LODWORD(v45.location));
        unint64_t v44 = (__CFCharacterSet *)v5;
      }

      else
      {
        v45.CFIndex length = *(void *)(v4 + 32);
        unint64_t v44 = (__CFCharacterSet *)v5;
        v45.unint64_t location = *(unsigned int *)(v4 + 24);
      }

      CFCharacterSetAddCharactersInRange(v44, v45);
LABEL_106:
      int v77 = *(void *)(v4 + 40);
      if (v77)
      {
        int v78 = *(unsigned __int8 *)(v77 + 13);
        if (*(_DWORD *)(v77 + 8))
        {
          unsigned __int16 v79 = 0LL;
          unsigned int v80 = 8LL;
          while (1)
          {
            CFRange v81 = *(void *)(v4 + 40);
            if (v81)
            {
              unint64_t v82 = 1 << (v79 + 1);
              if ((*(_DWORD *)(v81 + 8) & v82) != 0)
              {
                int v83 = (v79 + 1);
                if (*(unsigned __int8 *)(v81 + 12) >= v83)
                {
                  uint64_t v84 = *(const __CFCharacterSet **)(*(void *)v81 + 8 * v79);
                  if (v84) {
                    break;
                  }
                }
              }
            }

  CFRelease(v8);
  CFCharacterSetRef result = v10;
LABEL_43:
  if (a2)
  {
    if (!(_DWORD)result) {
      *a2 = Error;
    }
  }

  return result;
}

    uint64_t v21 = v19 == 0;
    unsigned int v22 = kCFCompareLessThan;
    goto LABEL_64;
  }

  if (!v19) {
    goto LABEL_36;
  }
  __CFNumberGetValue((uint64_t)number, 6LL, (uint64_t)&v36);
  __CFNumberGetValue((uint64_t)otherNumber, 6LL, (uint64_t)&v34);
  *(double *)v23.i64 = v36;
  v24.i64[0] = 1.0;
  v25.f64[0] = NAN;
  v25.f64[1] = NAN;
  uint64_t v26 = (int8x16_t)vnegq_f64(v25);
  v25.f64[0] = v34;
  unsigned int v27 = *(double *)vbslq_s8(v26, v24, (int8x16_t)v25).i64;
  unint64_t v28 = *(double *)vbslq_s8(v26, v24, v23).i64;
  if (v28 < v27) {
    return -1LL;
  }
  if (v27 < v28) {
    return 1LL;
  }
  if (v36 < v34) {
    return -1LL;
  }
  return (unint64_t)(v34 < v36);
}

  CFRelease(v15);
  CFRelease(Mutable);
  return v25 != 0;
}

        *(void *)(a1 + 8) = v21;
        usedBufLenb = (CFIndex *)lineNumber((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Could not find end of CDATA started on line %u",  usedBufLenb,  v53,  *(void *)bytes);
LABEL_81:
        *(void *)(a1 + 24) = Error;
LABEL_82:
        uint64_t v6 = *(const UInt8 **)(a1 + 8);
        int v7 = v6;
        goto LABEL_83;
      }

    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      if (a5)
      {
        if (v11 + 2 > a5) {
          break;
        }
        if (v14 >= 0xE05E) {
          uint64_t v30 = -2;
        }
        else {
          uint64_t v30 = -55;
        }
        *a4 = v30;
        if (v14 >= 0xE05E) {
          int v31 = 67;
        }
        else {
          int v31 = -95;
        }
        a4[1] = v31 + v14;
        a4 += 2;
      }

      unint64_t v50 = 0;
      ++a2;
      ++v12;
      v11 += 2LL;
      continue;
    }

    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
      ++a2;
      ++v12;
      continue;
    }

    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      v11 += 2LL;
      if (!a5) {
        goto LABEL_52;
      }
      if (v11 <= a5)
      {
        if (v14 >= 0xE05E) {
          uint64_t v30 = -2;
        }
        else {
          uint64_t v30 = -55;
        }
        *a4 = v30;
        if (v14 >= 0xE05E) {
          int v31 = 67;
        }
        else {
          int v31 = -95;
        }
        a4[1] = v31 + v14;
        a4 += 2;
        goto LABEL_52;
      }

      goto LABEL_103;
    }

    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
LABEL_54:
      ++a2;
      ++v12;
      goto LABEL_58;
    }

    if ((a1 & 0x10) == 0) {
      goto LABEL_46;
    }
    int v31 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    uint64_t v32 = (unsigned __int16 *)&__CFToJISCharMap;
    int v33 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      int v34 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v33 - v32)) >> 1;
      CFIndex v35 = &v32[17 * v34];
      uint64_t v36 = *v35;
      if (v36 > v31)
      {
        int v33 = v35 - 17;
        goto LABEL_56;
      }

      if (v36 + 16 <= v31)
      {
        uint64_t v32 = v35 + 17;
LABEL_56:
        if (v32 > v33) {
          goto LABEL_82;
        }
        continue;
      }

      break;
    }

    BOOL v46 = (__int16)v32[17 * v34 + 1 + (int)(v31 - v36)];
    if (v46 < 1) {
      goto LABEL_82;
    }
    if (a5)
    {
      CFRange v47 = -2LL;
      if (*(a4 - 1) == 61) {
        CFRange v47 = -1LL;
      }
      CFRange v48 = &a4[v47];
      CFRange v49 = BYTE1(v46);
      unint64_t v50 = v46 & 0x7F;
      if ((v46 & 0x100) != 0) {
        unint64_t v51 = 31;
      }
      else {
        unint64_t v51 = 125;
      }
      int v52 = v51 + v50;
      unint64_t v53 = (v49 + 479) >> 1;
      unint64_t v54 = v53 - 127;
      int v55 = (v53 - 127);
      if (v52 > 0x7E) {
        LOBYTE(v52) = v52 + 1;
      }
      uint64_t v56 = v53 - 63;
      if (v55 <= 0x9F) {
        uint64_t v56 = v54;
      }
      *CFRange v48 = v56;
      v48[1] = v52;
    }

    if ((a1 & 0x10) == 0) {
      goto LABEL_46;
    }
    uint64_t v32 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    int v33 = (unsigned __int16 *)&__CFToJISCharMap;
    int v34 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      CFIndex v35 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v34 - v33)) >> 1;
      uint64_t v36 = &v33[17 * v35];
      uint64_t v37 = *v36;
      if (v37 > v32)
      {
        int v34 = v36 - 17;
        goto LABEL_56;
      }

      if (v37 + 16 <= v32)
      {
        int v33 = v36 + 17;
LABEL_56:
        if (v33 > v34) {
          goto LABEL_82;
        }
        continue;
      }

      break;
    }

    CFRange v47 = (__int16)v33[17 * v35 + 1 + (int)(v32 - v37)];
    if (v47 < 1) {
      goto LABEL_82;
    }
    if (a5)
    {
      CFRange v48 = -2LL;
      if (*(a4 - 1) == 61) {
        CFRange v48 = -1LL;
      }
      CFRange v49 = &a4[v48];
      unint64_t v50 = BYTE1(v47);
      unint64_t v51 = v47 & 0x7F;
      if ((v47 & 0x100) != 0) {
        int v52 = 31;
      }
      else {
        int v52 = 125;
      }
      unint64_t v53 = v52 + v51;
      unint64_t v54 = (v50 + 479) >> 1;
      int v55 = v54 - 127;
      uint64_t v56 = (v54 - 127);
      if (v53 > 0x7E) {
        LOBYTE(v53) = v53 + 1;
      }
      uint64_t v57 = v54 - 63;
      if (v56 <= 0x9F) {
        uint64_t v57 = v55;
      }
      const void *v49 = v57;
      v49[1] = v53;
    }

  switch(v18)
  {
    case 0:
      -[CFPDSource acceptMessage:].cold.3();
    case 1:
      if (v8)
      {
        uint64_t v36 = -[CFPDSource approximatePlistSizeIncludingPendingChanges]((uint64_t)self);
        if (-[CFPDSource enqueueNewKey:value:encoding:inBatch:fromMessage:]( self,  "enqueueNewKey:value:encoding:inBatch:fromMessage:",  v75,  v74,  v73,  0LL,  a3))
        {
          uint64_t v37 = -[CFPDSource approximatePlistSizeIncludingPendingChanges]((uint64_t)self);
          if (v37 > v36) {
            -[CFPDSource attachSizeWarningsToReply:forByteCount:]((uint64_t)self, reply, v37);
          }
          if (xpc_dictionary_get_BOOL(a3, "CFPreferencesShouldWriteSynchronously") || v72) {
            -[CFPDSource syncWriteToDisk](self, "syncWriteToDisk");
          }
          unint64_t v66 = v73;
          unint64_t v54 = v74;
          int v65 = v75;
          int v55 = (os_log_s *)_CFPrefsDaemonLog();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
          {
            if (v66) {
              uint64_t v56 = v54;
            }
            else {
              uint64_t v56 = v65;
            }
            _extractCFPDBits(a3, v56, self, (uint64_t)&__block_literal_global_350);
          }

          -[CFPDSource asyncNotifyObserversOfWriteFromConnection:message:]( self,  "asyncNotifyObserversOfWriteFromConnection:message:",  remote_connection,  a3);
        }

        else
        {
          char v40 = "Couldn't enqueue updated values";
          unint64_t v41 = reply;
          uint64_t v42 = 2;
LABEL_83:
          populateErrorReply(v40, v41, v42);
        }
      }

      else if ((unint64_t)(int64 - 7) > 1)
      {
        if (v32 != -1 || v31 || (int v45 = self->_pendingChangesQueue) != 0LL && xpc_array_get_count(v45))
        {
          BOOL v46 = MEMORY[0x1895F87A8];
          v68[0] = MEMORY[0x1895F87A8];
          v68[1] = 3221225472LL;
          v68[2] = __28__CFPDSource_acceptMessage___block_invoke_2;
          v68[3] = &unk_18999B4C8;
          v68[4] = self;
          [v31 quicklyValidatePlistAndOnFailureInvokeBlock:v68];
          CFRange v47 = (void *)[v31 copyXPCData];
          if (v47)
          {
            xpc_dictionary_set_value(reply, "CFPreferencesPropertyList", v47);
            xpc_release(v47);
          }

          if (v32 != -1) {
            xpc_dictionary_set_fd(reply, "PlistFD", v32);
          }
          pendingChangesQueue = self->_pendingChangesQueue;
          if (pendingChangesQueue && xpc_array_get_count(pendingChangesQueue))
          {
            CFRange v49 = xpc_array_create(0LL, 0LL);
            unint64_t v50 = v46;
            unint64_t v51 = v49;
            int v52 = self->_pendingChangesQueue;
            v67[0] = v50;
            v67[1] = 3221225472LL;
            v67[2] = __28__CFPDSource_acceptMessage___block_invoke_122;
            v67[3] = &unk_1899ED6E8;
            v67[4] = v51;
            xpc_array_apply(v52, v67);
            xpc_dictionary_set_value(reply, "PlistDiff", v51);
            xpc_release(v51);
          }

          unint64_t v53 = self->_actualPath;
          if (v47) {
            DEBUG_READ(a3, self, (uint64_t)v53);
          }
          else {
            DEBUG_READ_EMPTY(a3, self, (uint64_t)v53);
          }
        }

        xpc_dictionary_set_int64(reply, "CFPreferencesShmemIndex", self->_generationShmemIndex);
        bzero(&v81, 0x400uLL);
        -[CFPrefsDaemon getShmemName:bufLen:]((uint64_t)self->_cfprefsd, (char *)&v81);
        uint64_t v39 = "CFPreferencesShmemName";
LABEL_115:
        CFMutableCharacterSetRef v38 = (char *)&v81;
LABEL_116:
        xpc_dictionary_set_string(reply, v39, v38);
      }

      else
      {
        -[CFPDSource setObserved:bySenderOfMessage:]((os_unfair_lock_s *)self, int64 == 7, a3);
      }

  unint64_t v24 = (os_log_s *)_CFBundleResourceLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
    ___CFGetProductName_block_invoke_cold_1(v24);
  }
}

  return 0LL;
}

LABEL_51:
                unsigned int v22 = CFAllocatorAllocate((CFAllocatorRef)v21, v10 & 0x7F8, 0LL);
LABEL_52:
                char v19 = (uint64_t *)*((void *)cf + 5);
                *char v19 = (uint64_t)v22;
              }

              if (((_DWORD)v19[1] & (1 << v7)) != 0)
              {
                uint64_t v36 = v7 - 1;
              }

              else
              {
                uint64_t v37 = CFGetAllocator(cf);
                CFMutableCharacterSetRef v38 = CFCharacterSetCreateMutable(v37);
                uint64_t v36 = v7 - 1;
                *(void *)(**((void **)cf + 5) + 8LL * v36) = v38;
                char v19 = (uint64_t *)*((void *)cf + 5);
                *((_DWORD *)v19 + 2) |= 1 << v7;
              }

              uint64_t v39 = *(__CFCharacterSet **)(*v19 + 8 * v36);
              if (v39)
              {
                v49.unint64_t location = v8;
                v49.CFIndex length = v13;
                CFCharacterSetAddCharactersInRange(v39, v49);
              }

              goto LABEL_58;
            }

            int v34 = CFGetAllocator(cf);
            CFIndex v35 = CFAllocatorAllocate(v34, 16LL, 0LL);
            *((void *)cf + 5) = v35;
            v35[6] = v7;
            *((_DWORD *)v35 + 2) = 0;
            uint64_t v21 = (malloc_zone_t *)CFGetAllocator(cf);
            goto LABEL_51;
          }
        }

  if ((a1 & 8) != 0 || v12 < 1) {
    goto LABEL_170;
  }
  if ((a1 & 0x10) == 0)
  {
LABEL_54:
    char v19 = v11;
    goto LABEL_55;
  }

  uint64_t v56 = a4;
  if ((int)v14 > 823)
  {
  }

  else
  {
    if ((_DWORD)v14 == 768)
    {
      if (*(a2 - 1) == 110)
      {
        char v19 = v11 + 1;
        if (a5) {
          *(_WORD *)(a4++ - 1) = -16472;
        }
        goto LABEL_55;
      }

      goto LABEL_71;
    }

    if ((_DWORD)v14 != 774 && (_DWORD)v14 != 776)
    {
LABEL_71:
      uint64_t v30 = (char *)v13;
      int v31 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v14, 1LL, 0x4000000000005LL);
      CFIndex v13 = (unsigned __int16 *)v30;
      a4 = v56;
      if (!v31)
      {
        if ((_DWORD)v14 == 63615)
        {
          if (*(a2 - 1) != 252) {
            goto LABEL_170;
          }
          char v19 = v11 - 1;
          if (a5) {
            *(v56 - 2) = 0x80;
          }
          a4 = v56 - 1;
          goto LABEL_55;
        }

        if ((_DWORD)v14 != 63614) {
          goto LABEL_170;
        }
        int v52 = *(a2 - 1);
        if (v52 > 0xFF00)
        {
          if (*(a2 - 1) <= 0xFF19u)
          {
            if (v52 == 65281)
            {
              unint64_t v53 = -34;
            }

            else
            {
              if (v52 != 65292) {
                goto LABEL_170;
              }
              unint64_t v53 = -39;
            }
          }

          else
          {
            switch(v52)
            {
              case 0xFF1Au:
                unint64_t v53 = -36;
                break;
              case 0xFF1Bu:
                unint64_t v53 = -35;
                break;
              case 0xFF1Fu:
                unint64_t v53 = -33;
                break;
              default:
                goto LABEL_170;
            }
          }
        }

        else if (*(a2 - 1) <= 0x3001u)
        {
          if (v52 == 8943)
          {
            unint64_t v53 = -13;
          }

          else
          {
            if (v52 != 12289) {
              goto LABEL_170;
            }
            unint64_t v53 = -37;
          }
        }

        else
        {
          switch(v52)
          {
            case 0x3002u:
              unint64_t v53 = -38;
              break;
            case 0x3016u:
              unint64_t v53 = -20;
              break;
            case 0x3017u:
              unint64_t v53 = -19;
              break;
            default:
              goto LABEL_170;
          }
        }

        if (a5)
        {
          *(v56 - 2) = -90;
          *(v56 - 1) = v53;
        }

        goto LABEL_54;
      }
    }
  }

  v58[0] = 2LL;
  int v33 = a2 - 1;
  uint64_t v32 = *(a2 - 1);
  if (v32 < 0x80)
  {
    int v34 = (char *)v13;
    CFIndex v35 = __CFStringEncodingPrecomposeLatinCharacter_3(a2 - 1, v55 - v12, v58);
    CFIndex v13 = (unsigned __int16 *)v34;
    uint64_t v36 = v58[0] - 2LL;
    if (v58[0] <= 2LL) {
      uint64_t v37 = 0LL;
    }
    else {
      uint64_t v37 = v58[0] - 2LL;
    }
    goto LABEL_76;
  }

  CFMutableCharacterSetRef v38 = *a2;
  if (v38 > 0x3098)
  {
    if (v38 != 12441)
    {
      if (v38 == 12442)
      {
        uint64_t v36 = 0LL;
        uint64_t v37 = 0LL;
        CFIndex v35 = v32 + 2;
        goto LABEL_76;
      }

      goto LABEL_172;
    }

    uint64_t v36 = 0LL;
    uint64_t v37 = 0LL;
    if (v32 == 12454) {
      CFIndex v35 = 12532;
    }
    else {
      CFIndex v35 = v32 + 1;
    }
LABEL_76:
    v12 += v37;
    if (v35 != 252)
    {
      a4 = v56;
      goto LABEL_95;
    }

    a4 = v56;
    if (v12 >= a3) {
      goto LABEL_95;
    }
    if ((__int16)a2[1] == -1921)
    {
      if (a5) {
        *(v56 - 1) = 0x80;
      }
      ++v12;
      goto LABEL_54;
    }

    CFIndex v35 = 252;
LABEL_98:
    char v40 = v13 + 78;
    unint64_t v41 = v13;
    while (1)
    {
      uint64_t v42 = ((char *)v40 - (char *)v41) >> 3;
      int v43 = &v41[2 * v42];
      unint64_t v44 = *v43;
      if (v44 <= v35)
      {
        if (v44 >= v35)
        {
          if (a5)
          {
            if (v11 >= a5) {
              goto LABEL_170;
            }
            *(_WORD *)(a4++ - 1) = __rev16(v41[2 * v42 + 1]);
          }

          char v19 = v11 + 1;
          goto LABEL_55;
        }

        unint64_t v41 = v43 + 2;
      }

      else
      {
        char v40 = v43 - 2;
      }

      if (v41 > v40) {
        goto LABEL_104;
      }
    }
  }

  if (v38 == 774)
  {
    uint64_t v36 = 0LL;
    uint64_t v37 = 0LL;
    if ((v32 & 0xFFFFFFDF) == 0x418) {
      CFIndex v35 = v32 + 1;
    }
    else {
      CFIndex v35 = -3;
    }
    goto LABEL_76;
  }

  if (v38 != 776)
  {
LABEL_172:
    uint64_t v36 = 0LL;
    goto LABEL_173;
  }

  uint64_t v36 = 0LL;
  if (v32 == 1077) {
    uint64_t v39 = 1105;
  }
  else {
    uint64_t v39 = -3;
  }
  if (v32 == 1045) {
    CFIndex v35 = 1025;
  }
  else {
    CFIndex v35 = v39;
  }
LABEL_95:
LABEL_104:
  int v45 = (unsigned __int16 *)&__CFToGB2312CharMap;
  BOOL v46 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    CFRange v47 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v46 - v45)) >> 1;
    CFRange v48 = &v45[17 * v47];
    CFRange v49 = *v48;
    if (v49 <= v35) {
      break;
    }
    BOOL v46 = v48 - 17;
LABEL_110:
    if (v45 > v46) {
      goto LABEL_173;
    }
  }

  if (v49 + 16 <= v35)
  {
    int v45 = v48 + 17;
    goto LABEL_110;
  }

  unint64_t v50 = v45[17 * v47 + 1 + (int)(v35 - v49)];
  if (!v50 || v50 == 65533)
  {
LABEL_173:
    v12 -= v36;
    *a6 = v11;
    return v12;
  }

  if (!a5)
  {
LABEL_147:
    if (*v33 >= 0x80u) {
      char v19 = v11;
    }
    else {
      char v19 = v11 + 1;
    }
    goto LABEL_55;
  }

  if (*v33 > 0x7Fu)
  {
    *(a4 - 2) = HIBYTE(v50) | 0x80;
    *(a4 - 1) = v50 | 0x80;
    goto LABEL_147;
  }

  if (v11 < a5)
  {
    *(a4 - 1) = HIBYTE(v50) | 0x80;
    *a4 = v50 | 0x80;
    goto LABEL_147;
  }

  if ((a1 & 0x10) == 0) {
    goto LABEL_110;
  }
  if (((v17 - 774) > 0x32 || ((1LL << (v17 - 6)) & 0x4000000000005LL) == 0)
    && (v17 - 12441) >= 2)
  {
    unint64_t v41 = v11;
    int v78 = v7;
    CFRange v81 = v10;
    uint64_t v42 = v16;
    int v43 = a1;
    unint64_t v44 = a5;
    int v45 = v14;
    BOOL v46 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
    uint64_t v14 = v45;
    a5 = v44;
    a1 = v43;
    char v16 = v42;
    int v7 = v78;
    __int16 v10 = v81;
    CFIndex v13 = 36516LL;
    BOOL v11 = v41;
    if (!v46) {
      goto LABEL_114;
    }
  }

  CFRange v47 = *(v15 - 1);
  if (v47 <= 0x7F)
  {
    unsigned __int16 v79 = v11;
    unint64_t v82 = v10;
    CFRange v48 = v16;
    CFRange v49 = v7;
    unint64_t v50 = a1;
    unint64_t v51 = a5;
    int v52 = v14;
    unint64_t v53 = __CFStringEncodingPrecomposeLatinCharacter_3(v15 - 1, (uint64_t)(v11 - (void)(v15 - 1)) >> 1, v83);
    uint64_t v14 = v52;
    a5 = v51;
    a1 = v50;
    int v7 = v49;
    char v16 = v48;
    BOOL v11 = v79;
    __int16 v10 = v82;
    CFIndex v13 = 0x8EA4u;
    goto LABEL_60;
  }

  uint64_t v60 = *v15;
  if (v60 <= 0x3098)
  {
    if (v60 == 774)
    {
      if ((v47 & 0xFFFFFFDF) != 0x418) {
        goto LABEL_114;
      }
      unint64_t v53 = v47 + 1;
    }

    else
    {
      if (v60 != 776) {
        goto LABEL_114;
      }
      if (v47 == 1077) {
        unsigned int v61 = 1105;
      }
      else {
        unsigned int v61 = -3;
      }
      if (v47 == 1045) {
        unint64_t v53 = 1025;
      }
      else {
        unint64_t v53 = v61;
      }
    }

    goto LABEL_61;
  }

  if (v60 == 12441)
  {
    if (v47 != 12454)
    {
      unint64_t v53 = v47 + 1;
      goto LABEL_60;
    }

    unint64_t v54 = 12532;
    unint64_t v53 = 12532;
  }

  else
  {
    if (v60 != 12442) {
      goto LABEL_114;
    }
    unint64_t v53 = v47 + 2;
LABEL_60:
    if (!v53) {
      goto LABEL_114;
    }
LABEL_61:
    unint64_t v54 = v53;
  }

  int v55 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
  uint64_t v56 = (unsigned __int16 *)&__CFToGB2312CharMap;
  while (2)
  {
    uint64_t v57 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v55 - v56)) >> 1;
    int v58 = &v56[17 * v57];
    unsigned __int16 v59 = *v58;
    if (v59 > v53)
    {
      int v55 = v58 - 17;
      goto LABEL_68;
    }

    if (v59 + 16 <= v54)
    {
      uint64_t v56 = v58 + 17;
LABEL_68:
      if (v56 > v55) {
        goto LABEL_114;
      }
      continue;
    }

    break;
  }

  int v62 = v56[17 * v57 + 1 + (int)(v54 - v59)];
  if (v62) {
    unint64_t v63 = v62 == 65533;
  }
  else {
    unint64_t v63 = 1;
  }
  if (v63) {
    goto LABEL_114;
  }
  if ((v14 & 1) == 0) {
    goto LABEL_87;
  }
  if ((unint64_t)(v15 - 2) >= v7 && *(v15 - 2) >= 0x80u)
  {
    --v10;
    a4 += v76;
LABEL_87:
    unint64_t v64 = v10;
    if (!a5)
    {
LABEL_109:
      __int16 v10 = v64;
      goto LABEL_110;
    }

  uint64_t v30 = (v12 & 1) == 0;
  if ((_DWORD)a4 != 256) {
    uint64_t v30 = v20;
  }
  if (!v30)
  {
    LOBYTE(v106) = 0;
    allocatora = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    unint64_t v107 = 0LL;
    uint64_t v20 = v108;
    if (v108) {
      LODWORD(a4) = 1536;
    }
    else {
      LODWORD(a4) = 256;
    }
    if (!(_BYTE)v106)
    {
      uint64_t v14 = v111 << (v108 == 0);
      if (v102 && v18 != (const __CFAllocator *)&__kCFAllocatorNull) {
        CFAllocatorDeallocate(v18, ptr);
      }
      if (v109 && v16 == (__objc2_class **)allocatora && !v20)
      {
        uint64_t v109 = 0;
        ptr = (int8x16_t *)__CFSafelyReallocateWithAllocator((malloc_zone_t *)v16, v107, v14, 0LL, 0LL);
        unint64_t v104 = 0;
        LODWORD(v8) = 0;
        int v105 = 1;
      }

      else
      {
        int v105 = 0;
        unint64_t v104 = 0;
        LODWORD(v8) = 0;
        ptr = v107;
      }

      unsigned int v18 = (const __CFAllocator *)v16;
    }

    goto LABEL_109;
  }

  if ((_DWORD)a4 == 256 && (v12 & 2) != 0)
  {
    int v31 = v14 >> 1;
    if (v14 >= 2)
    {
      uint64_t v32 = 0LL;
      if (v31 <= 1) {
        int v33 = 1LL;
      }
      else {
        int v33 = v14 >> 1;
      }
      while (ptr->u16[v32] <= 0x7Fu)
      {
        if (v33 == ++v32) {
          goto LABEL_62;
        }
      }

      LODWORD(a4) = 256;
      goto LABEL_109;
    }

  if ((a4 & 1) == 0)
  {
LABEL_52:
    char v19 = 0;
    goto LABEL_118;
  }

  int v31 = v113;
  int v33 = (a4 & 0x80) == 0 || v113 > 0x50F;
  if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_lowerBMP = CFUniCharGetBitmapPtrForPlane(0x67u, 0);
    __CFStringFoldCharacterClusterAtIndex_caseFoldBMP = CFUniCharGetBitmapPtrForPlane(0x6Au, 0);
    int v31 = v113;
  }

  if (__s1 && v31 == 73)
  {
    if (!strcmp(__s1, "tr") || !strcmp(__s1, "az"))
    {
      if (v18 >= 2)
      {
        if (a6[1] == 775)
        {
          *a6 = 105;
          int v113 = 105;
          char v19 = 1;
          --v18;
          goto LABEL_118;
        }

        goto LABEL_78;
      }

      if ((v17 & 0x8000000000000000LL) == 0)
      {
        int v34 = *((void *)buffer + 20);
        if (v34 > v17)
        {
          CFIndex v35 = *((void *)buffer + 17);
          if (v35)
          {
            uint64_t v36 = (UniChar *)(v35 + 2 * (*((void *)buffer + 19) + v17));
LABEL_74:
            if (*v36 != 775)
            {
              LOWORD(v31) = v113;
              goto LABEL_79;
            }

            *a6 = 105;
            int v113 = 105;
            ++v17;
            char v19 = 1;
LABEL_17:
            unsigned int v18 = 1LL;
            goto LABEL_118;
          }

          if (!*((void *)buffer + 18))
          {
            if (*((void *)buffer + 22) <= v17 || (unsigned int v86 = *((void *)buffer + 21), v86 > v17))
            {
              uint64_t v87 = v17 - 4;
              if (v87 + 64 < v34) {
                int v34 = v87 + 64;
              }
              *((void *)buffer + 21) = v87;
              *((void *)buffer + 22) = v34;
              v118.unint64_t location = *((void *)buffer + 19) + v87;
              v118.CFIndex length = v34 - v87;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v118, buffer);
              unsigned int v86 = *((void *)buffer + 21);
            }

            uint64_t v36 = &buffer[v17 - v86];
            goto LABEL_74;
          }
        }
      }
    }

    uint64_t v14 = 0;
    ++v12;
LABEL_52:
    *a6 = v12;
    goto LABEL_53;
  }

    else {
      unint64_t v24 = v8 + 188;
    }
    if ((_DWORD)v8 == -102) {
      CFIndex v25 = 108;
    }
    else {
      CFIndex v25 = v24;
    }
    if (v25 > 0x63) {
      v25 -= 85;
    }
    uint64_t v26 = v25 - 4;
    if (v14 < LODWORD(v16[2 * v26]))
    {
      unsigned int v27 = *(void *)(v16[2 * v26 + 1] + 8 * v14);
      if (v27)
      {
        if ((v15 & *(_BYTE *)(v27 + v60)) != 0)
        {
          int v34 = (&__CFUniCharCaseMappingTable)[v8];
          if (*v34 <= a1)
          {
            CFIndex v35 = &v34[2 * (__CFUniCharCaseMappingTableCounts[v8] - 1)];
            if (*v35 >= a1)
            {
              do
              {
                uint64_t v36 = (unsigned int *)&v34[2 * (((char *)v35 - (char *)v34) >> 4)];
                if (*v36 <= a1)
                {
                  if (*v36 >= a1)
                  {
                    uint64_t v37 = v36[1];
LABEL_89:
                    if ((_DWORD)v8 != 2 || v37)
                    {
                      if (!v37) {
                        goto LABEL_63;
                      }
                      goto LABEL_107;
                    }

                    if (a1 - 125252 < 0xFFFE171D) {
                      goto LABEL_63;
                    }
                    CFMutableCharacterSetRef v38 = (unsigned int *)&__CFUniCharToUppercaseMappingTable;
                    uint64_t v39 = (unsigned int *)((char *)&__CFUniCharToUppercaseMappingTable + 12192);
                    while (1)
                    {
                      char v40 = &v38[2 * (((char *)v39 - (char *)v38) >> 4)];
                      if (*v40 <= a1)
                      {
                        if (*v40 >= a1)
                        {
                          uint64_t v37 = v40[1];
                          if (!v37) {
                            goto LABEL_63;
                          }
                          LODWORD(v8) = 1;
LABEL_107:
                          CFCharacterSetRef result = HIBYTE(v37) & 0x1F;
                          if ((_DWORD)result == 1)
                          {
                            if ((v37 & 0x80000000) != 0)
                            {
                              if (a3 < 2) {
                                goto LABEL_63;
                              }
                              *a2 = (((v37 & 0xFFFC00) + 67043328) >> 10) - 10240;
                              a2[1] = v37 & 0x3FF | 0xDC00;
                              return 2LL;
                            }

                            *a2 = v37;
                            return 1LL;
                          }

                          if (result >= a3) {
                            goto LABEL_63;
                          }
                          if ((v37 & 0x80000000) != 0)
                          {
                            if (!(_DWORD)result) {
                              goto LABEL_63;
                            }
                            CFRange v49 = result + 1;
                            CFCharacterSetRef result = 0LL;
                            while (1)
                            {
                              unint64_t v51 = *v42++;
                              unint64_t v50 = v51;
                              if (v51 < 0x10000)
                              {
                                int v52 = result + 1;
                                unint64_t v53 = a2;
                                if (result + 1 >= a3)
                                {
LABEL_147:
                                  if (v49 == 2) {
                                    return result;
                                  }
LABEL_63:
                                  if (a1 >= 0x10000)
                                  {
                                    *a2 = (((a1 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                    a2[1] = a1 & 0x3FF | 0xDC00;
                                    return 2LL;
                                  }

                                  *a2 = a1;
                                  return 1LL;
                                }

                                unint64_t v54 = v50;
                              }

                              else
                              {
                                int v52 = result + 2;
                                unint64_t v53 = a2;
                                if (result + 2 >= a3) {
                                  goto LABEL_147;
                                }
                                a2[result++] = (((v50 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                unint64_t v54 = v50 & 0x3FF | 0xDC00;
                              }

                              v53[result] = v54;
                              --v49;
                              CFCharacterSetRef result = v52;
                              if (v49 <= 1) {
                                goto LABEL_63;
                              }
                            }
                          }

                          if ((_DWORD)result)
                          {
                            int v43 = HIBYTE(v37) & 0x1F;
                            unint64_t v44 = a2;
                            do
                            {
                              int v45 = *v42++;
                              *v44++ = v45;
                              --v43;
                            }

                            while (v43);
                            return result;
                          }

                          return 0LL;
                        }

                        CFMutableCharacterSetRef v38 = v40 + 2;
                      }

                      else
                      {
                        uint64_t v39 = v40 - 2;
                      }

                      if (v38 > v39) {
                        goto LABEL_63;
                      }
                    }
                  }

                  int v34 = (int *)(v36 + 2);
                }

                else
                {
                  CFIndex v35 = (int *)(v36 - 2);
                }
              }

              while (v34 <= v35);
            }
          }

          uint64_t v37 = 0;
          goto LABEL_89;
        }
      }
    }

    uint64_t v12 = (_DWORD)v8 == 3;
    CFIndex v8 = 0LL;
    if (!v12) {
      goto LABEL_63;
    }
  }

  uint64_t v57 = v15;
  uint64_t v20 = CFUniCharDecomposeCharacter(a1, &v61, 10LL);
  if (v20 < 2)
  {
LABEL_18:
    uint64_t v15 = v57;
    char v16 = v17;
    __int16 v10 = v18;
    goto LABEL_19;
  }

  uint64_t v21 = (unsigned int *)&v62[4 * v20 - 4];
  unsigned int v22 = v62;
  while (*v22 != 769)
  {
    if (++v22 >= v21) {
      goto LABEL_18;
    }
  }

  CFCharacterSetRef result = CFUniCharMapCaseTo(v61, a2, a3, v8, 0LL, a6);
  if (!result)
  {
    *a2 = v61;
    CFCharacterSetRef result = 1LL;
  }

  do
  {
    char v29 = *v11;
    if (*v11 != 769)
    {
      if (HIWORD(v29))
      {
        uint64_t v30 = &a2[result];
        *uint64_t v30 = ((v29 + 67043328) >> 10) - 10240;
        result += 2LL;
        v30[1] = v29 & 0x3FF | 0xDC00;
      }

      else
      {
        a2[result++] = v29;
      }
    }

    ++v11;
  }

  while (v11 < v21);
  return result;
}

  -[CFPrefsSource setValues:forKeys:count:copyValues:from:]( (os_unfair_lock_s *)*p_standardSetTarget,  (uint64_t)v88,  (uint64_t)a4,  v32,  0,  (uint64_t)self);
  if ((v19 & 1) == 0) {
    return;
  }
LABEL_69:
  if (v32 >= 1)
  {
    for (uint64_t i = 0LL; i != v32; ++i)
    {
      if (v93[i])
      {
        uint64_t v60 = a4[i];
        if (v60)
        {
          unsigned int v61 = v88[i];
          if (v61)
          {
            CFDictionarySetValue((CFMutableDictionaryRef)(&self->super.super.isa)[v95 / 8], v60, v61);
            p_cloudSetTarget = (CFPrefsCloudSource **)p_standardSetTarget;
            if (v89[i]) {
              p_cloudSetTarget = &self->_cloudSetTarget;
            }
            CFDictionarySetValue(self->_keysToSources, a4[i], *p_cloudSetTarget);
          }

          else
          {
            unint64_t v63 = (const __CFArray *)(&self->super.super.isa)[v94 / 8];
            if (v63)
            {
              CFIndex Count = CFArrayGetCount(v63);
              int v85 = &v84;
              unint64_t v66 = MEMORY[0x1895F8858](Count, v65);
              char v68 = (const void **)((char *)&v84 - v67);
              if (v66 >= 1)
              {
                v100.unint64_t location = 0LL;
                v100.CFIndex length = Count;
                CFArrayGetValues((CFArrayRef)(&self->super.super.isa)[v94 / 8], v100, v68);
              }
            }

            else
            {
              int v85 = &v84;
              MEMORY[0x1895F8858](0LL, v60);
              char v68 = (const void **)&v83;
              CFIndex Count = 0LL;
            }

            unint64_t v69 = FirstIndexOfValue;
            if (v89[i]) {
              unint64_t v69 = v91;
            }
            if (v69 + 1 < Count)
            {
              unint64_t v70 = (id *)&v68[v69 + 1];
              int v71 = ~v69 + Count;
              while (1)
              {
                unint64_t v72 = &a4[i];
                unint64_t v73 = (const void *)[*v70 copyValueForKey:*v72];
                char v74 = (__CFDictionary *)(&self->super.super.isa)[v95 / 8];
                uint64_t v75 = *v72;
                if (v73) {
                  break;
                }
                CFDictionaryRemoveValue(v74, v75);
                CFDictionaryRemoveValue(self->_keysToSources, a4[i]);
                ++v70;
                if (!--v71) {
                  goto LABEL_89;
                }
              }

              CFDictionarySetValue(v74, v75, v73);
              CFDictionarySetValue(self->_keysToSources, a4[i], *v70);
              CFRelease(v73);
            }
          }

    if (*v90) {
      goto LABEL_142;
    }
    if (*(void *)(a5 + 56))
    {
      if (CFArrayGetCount(a4) >= 2 && CFArrayGetCount(a4) >= 1)
      {
        char v40 = 0LL;
        while (1)
        {
          *(void *)unint64_t v101 = 0LL;
          CFMutableDictionaryRef cf = 0LL;
          unint64_t v41 = *(const __CFData **)(a5 + 56);
          uint64_t v42 = (const __CFString *)CFArrayGetValueAtIndex(a4, v40);
          _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v41, v42, v101, &v97, &cf, &v98);
          int v43 = cf;
          if (++v40 >= CFArrayGetCount(a4)) {
            goto LABEL_140;
          }
        }

        *char v90 = *(CFTypeRef *)v101;
        CFArrayRef theArray = v43;
      }

const char *__CFCheckForExpandedSet( const char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v8 = result;
  char v9 = __CFCheckForExpandedSet___CFNumberOfPlanesForLogging;
  if (__CFCheckForExpandedSet___CFNumberOfPlanesForLogging < 0)
  {
    CFCharacterSetRef result = getenv("CFCharacterSetCheckForExpandedSet");
    if (result) {
      CFCharacterSetRef result = (const char *)strtol_l(result, 0LL, 0, 0LL);
    }
    else {
      char v9 = (char)result;
    }
    __CFCheckForExpandedSet___CFNumberOfPlanesForLogging = v9;
  }

  if (v9)
  {
    uint64_t v10 = *((void *)v8 + 5);
    if (v10)
    {
      unsigned int v11 = *(_DWORD *)(v10 + 8);
      if (v11)
      {
        int v12 = 0;
        while ((v11 & 1) == 0 || ++v12 < v9)
        {
          BOOL v13 = v11 > 1;
          v11 >>= 1;
          if (!v13) {
            return result;
          }
        }

        if ((__CFCheckForExpandedSet_warnedOnce & 1) == 0)
        {
          CFCharacterSetRef result = (const char *)CFLog( 4LL,  (uint64_t)@"An expanded CFMutableCharacter has been detected.  Recommend to compact with CFCharacterSetCreateCopy",  a3,  a4,  a5,  a6,  a7,  a8,  v14);
          __CFCheckForExpandedSet_warnedOnce = 1;
        }
      }
    }
  }

  return result;
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length = theRange.length;
  unint64_t location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet removeCharactersInRange:](theSet, "removeCharactersInRange:", location, length);
    return;
  }

  unsigned int v11 = (unint64_t *)((char *)theSet + 8);
  char v12 = atomic_load((unint64_t *)theSet + 1);
  if ((v12 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)"void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef, CFRange)");
  }

  if (location >> 16 > 0x10 || length >= 1114113 || (unint64_t v13 = location + length, location + length >= 0x110001))
  {
    CFLog( 3LL,  (uint64_t)@"%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)",  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)"void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef, CFRange)");
    qword_18C539A70 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
LABEL_169:
    __break(1u);
    return;
  }

  char v14 = atomic_load(v11);
  if ((v14 & 0x70) != 0
    || (char v15 = atomic_load(v11), (v15 & 1) != 0)
    || (char v16 = atomic_load(v11), (v16 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    if (length)
    {
      char v17 = atomic_load(v11);
      if ((v17 & 8) == 0)
      {
        uint64_t v18 = *((void *)theSet + 5);
        if (!v18 || !*(_DWORD *)(v18 + 8) && !*(_BYTE *)(v18 + 13))
        {
          unsigned int v19 = atomic_load(v11);
          switch((v19 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*((void *)theSet + 4)) {
                goto LABEL_22;
              }
              break;
            case 3u:
            case 4u:
              if (*((void *)theSet + 3)) {
                goto LABEL_22;
              }
              break;
            default:
              goto LABEL_22;
          }

          return;
        }
      }

LABEL_47:
      char v39 = atomic_load(v11);
      if ((v39 & 0x70) == 0x10LL)
      {
        unint64_t v40 = *((unsigned int *)theSet + 6);
        CFIndex v41 = *((void *)theSet + 4);
        if (v40 == location)
        {
          if (v41 >= length) {
            CFIndex v41 = length;
          }
          *((void *)theSet + 4) = v41;
          unint64_t v42 = atomic_load((unint64_t *)theSet + 1);
          while (1)
          {
            unint64_t v43 = __ldaxr(v11);
            if (v43 != v42) {
              break;
            }
            if (__stlxr(v42 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
              goto LABEL_56;
            }
            char v44 = 1;
LABEL_57:
            unint64_t v42 = v43;
            if ((v44 & 1) != 0) {
              return;
            }
          }

          __clrex();
LABEL_56:
          char v44 = 0;
          goto LABEL_57;
        }

        if (v40 >= location || (uint64_t)location > (uint64_t)(v41 + v40))
        {
          if (v40 > location && v13 >= v40)
          {
            *((_DWORD *)theSet + 6) = location;
            *((void *)theSet + 4) = v40 - location + v41;
            unint64_t v90 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              unint64_t v91 = __ldaxr(v11);
              if (v91 != v90) {
                break;
              }
              if (__stlxr(v90 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
                goto LABEL_128;
              }
              char v92 = 1;
LABEL_129:
              unint64_t v90 = v91;
              if ((v92 & 1) != 0) {
                return;
              }
            }

            __clrex();
LABEL_128:
            char v92 = 0;
            goto LABEL_129;
          }

            uint64_t v37 = (unsigned __int16)v34;
            unsigned int v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
            if (CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
              && *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8))
              && *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                          + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8)) << 8)
                          - 256
                          + v37
                          + 256) == 9)
            {
              goto LABEL_67;
            }

            if ((_DWORD)v37 != 8205) {
              goto LABEL_121;
            }
            char v39 = v180;
            if (v180 <= v31)
            {
              unint64_t v43 = 0;
              if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP) {
                goto LABEL_64;
              }
              goto LABEL_61;
            }

            if (v177)
            {
              unint64_t v40 = &v177[v179 + v31];
            }

            else
            {
              if (v178)
              {
                LOWORD(v41) = *(char *)(v178 + v179 + v31);
LABEL_60:
                unint64_t v43 = (unsigned __int16)v41;
                unsigned int v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
                if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP)
                {
LABEL_64:
                  unint64_t v42 = v38 == 9;
                  goto LABEL_65;
                }

    uint64_t v23 = 1LL;
    char v20 = v11;
LABEL_32:
    a2 += v23;
    v12 += v23;
    unsigned int v11 = v20;
  }

  while (v12 < a3);
LABEL_85:
  *a6 = v20;
  return v12;
}

LABEL_23:
          CFIndex v105 = length;
          uint64_t v107 = location;
          __CFCSetMakeBitmap(theSet);
          uint64_t v106 = location + length;
          int v28 = v13 - 1;
          else {
            int v29 = location >> 16;
          }
          if (v29 <= v28 >> 16)
          {
            CFIndex v45 = (unsigned __int16)location;
            int v46 = v28 >> 16;
            int v47 = (unsigned __int16)v106;
            uint64_t v48 = (unsigned __int16)v106;
            __int16 v49 = 8 * v29;
            int v50 = (v28 >> 16) + 1;
            do
            {
              if (v47) {
                BOOL v51 = v46 == v29;
              }
              else {
                BOOL v51 = 0;
              }
              if (v51) {
                uint64_t v52 = v48;
              }
              else {
                uint64_t v52 = 0x10000LL;
              }
              CFIndex v53 = v52 - v45;
              unint64_t v54 = (uint64_t *)*((void *)theSet + 5);
              if (v54 && *((_BYTE *)v54 + 13))
              {
                if (!(_BYTE)v29) {
                  goto LABEL_169;
                }
                if (v29 <= 0x10u)
                {
                  if (*((unsigned __int8 *)v54 + 12) < v29)
                  {
                    *((_BYTE *)v54 + 12) = v29;
                    uint64_t v55 = *v54;
                    uint64_t v56 = (malloc_zone_t *)CFGetAllocator(theSet);
                    if (v55) {
                      uint64_t v57 = __CFSafelyReallocateWithAllocator(v56, **((void ***)theSet + 5), v49 & 0x7F8, 0LL, 0LL);
                    }
                    else {
                      uint64_t v57 = CFAllocatorAllocate((CFAllocatorRef)v56, v49 & 0x7F8, 0LL);
                    }
                    unint64_t v54 = (uint64_t *)*((void *)theSet + 5);
                    *unint64_t v54 = (uint64_t)v57;
                    uint64_t v48 = (unsigned __int16)v106;
                  }

                  if (((_DWORD)v54[1] & (1 << v29)) != 0)
                  {
                    uint64_t v63 = v29 - 1;
                  }

                  else
                  {
                    unint64_t v64 = CFGetAllocator(theSet);
                    CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v64);
                    uint64_t v48 = (unsigned __int16)v106;
                    uint64_t v63 = v29 - 1;
                    *(void *)(**((void **)theSet + 5) + 8LL * v63) = Mutable;
                    unint64_t v54 = (uint64_t *)*((void *)theSet + 5);
                    *((_DWORD *)v54 + 2) |= 1 << v29;
                  }

                  int v47 = (unsigned __int16)v106;
                  unint64_t v66 = *(__CFCharacterSet **)(*v54 + 8 * v63);
                  if (v66)
                  {
                    v109.unint64_t location = v45;
                    v109.CFIndex length = v53;
                    CFCharacterSetAddCharactersInRange(v66, v109);
                    uint64_t v48 = (unsigned __int16)v106;
                  }
                }
              }

              else
              {
                if (!(_BYTE)v29) {
                  goto LABEL_169;
                }
                if (v29 <= 0x10u)
                {
                  if (v54)
                  {
                    if (((*((_DWORD *)v54 + 2) >> v29) & 1) != 0
                      && *((unsigned __int8 *)v54 + 12) >= v29)
                    {
                      uint64_t v58 = *v54;
                      unsigned int v59 = v29 - 1;
                      uint64_t v60 = *(unint64_t **)(v58 + 8LL * v59);
                      if (v60)
                      {
                        v108.unint64_t location = v45;
                        v108.CFIndex length = v53;
                        CFCharacterSetRemoveCharactersInRange(*(CFMutableCharacterSetRef *)(v58 + 8LL * v59), v108);
                        uint64_t v48 = (unsigned __int16)v106;
                        unint64_t v61 = v60[5];
                        if (!v61 || !*(_DWORD *)(v61 + 8) && !*(_BYTE *)(v61 + 13))
                        {
                          unsigned int v62 = atomic_load(v60 + 1);
                          switch((v62 >> 4) & 7)
                          {
                            case 1u:
                            case 2u:
                              if (!v60[4]) {
                                goto LABEL_95;
                              }
                              break;
                            case 3u:
                            case 4u:
                              if (!v60[3])
                              {
LABEL_95:
                                char v67 = atomic_load(v60 + 1);
                                if ((v67 & 8) == 0)
                                {
                                  CFRelease(v60);
                                  uint64_t v48 = (unsigned __int16)v106;
                                  *(_DWORD *)(*((void *)theSet + 5) + 8LL) &= ~(1 << v29);
                                }
                              }

                              break;
                            default:
                              break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              ++v29;
              v49 += 8;
            }

            while (v50 != v29);
          }

          uint64_t v30 = *((void *)theSet + 5);
          if (v30 && !*(_DWORD *)(v30 + 8) && !*(_BYTE *)(v30 + 13))
          {
            for (uint64_t i = 0LL; i != 16; ++i)
            {
              uint64_t v32 = *((void *)theSet + 5);
              if (((*(_DWORD *)(v32 + 8) >> i) & 2) != 0) {
                CFRelease(*(CFTypeRef *)(*(void *)v32 + 8 * i));
              }
            }

            int v33 = CFGetAllocator(theSet);
            CFAllocatorDeallocate(v33, **((void ***)theSet + 5));
            int v34 = CFGetAllocator(theSet);
            CFAllocatorDeallocate(v34, *((void **)theSet + 5));
            *((void *)theSet + 5) = 0LL;
          }

          if (v107 < 0x10000)
          {
            if (v106 <= 0x10000) {
              uint64_t v35 = v105;
            }
            else {
              uint64_t v35 = 0x10000 - v107;
            }
            if (v107 || v35 != 0x10000)
            {
              uint64_t v84 = *((void *)theSet + 3);
              unsigned __int16 v85 = v35 + v107 - 1;
              uint64_t v86 = (unsigned __int16)v107 >> 3;
              unint64_t v87 = v85;
              uint64_t v88 = v85 >> 3;
              int v89 = 255 << (v107 & 7);
              if ((_DWORD)v88 == (_DWORD)v86)
              {
                *(_BYTE *)(v84 + v86) &= ~((0xFFu >> (~(_BYTE)v87 & 7)) & v89);
              }

              else
              {
                *(_BYTE *)(v84 + v86) &= ~(_BYTE)v89;
                *(_BYTE *)(v84 + v88) &= -256 >> (~(_BYTE)v87 & 7);
              }
            }

            else
            {
              uint64_t v36 = CFGetAllocator(theSet);
              CFAllocatorDeallocate(v36, *((void **)theSet + 3));
              *((void *)theSet + 3) = 0LL;
            }
          }

          unint64_t v99 = atomic_load(v11);
          while (1)
          {
            unint64_t v100 = __ldaxr(v11);
            if (v100 != v99) {
              break;
            }
            if (__stlxr(v99 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
              goto LABEL_154;
            }
            int v101 = 1;
LABEL_155:
            unint64_t v99 = v100;
            if (v101)
            {
              if (__CFCheckForExapendedSet == 1) {
                __CFCheckForExpandedSet((const char *)theSet, v21, v22, v23, v24, v25, v26, v27);
              }
              return;
            }
          }

          __clrex();
LABEL_154:
          int v101 = 0;
          goto LABEL_155;
        }

        unint64_t v102 = atomic_load(v11);
        while (1)
        {
          unint64_t v103 = __ldaxr(v11);
          if (v103 != v102) {
            break;
          }
          if (__stlxr(v102 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
            goto LABEL_165;
          }
          char v104 = 1;
LABEL_166:
          unint64_t v102 = v103;
          if ((v104 & 1) != 0) {
            return;
          }
        }

        __clrex();
LABEL_165:
        char v104 = 0;
        goto LABEL_166;
      }

      char v68 = atomic_load(v11);
      if ((v68 & 0x70) != 0x20LL) {
        goto LABEL_23;
      }
      uint64_t v69 = *((void *)theSet + 4);
      CFIndex v70 = v69 + length;
      if (v69 + length > 63) {
        goto LABEL_23;
      }
      int v71 = (char *)*((void *)theSet + 3);
      if (!v71)
      {
        unint64_t v72 = CFGetAllocator(theSet);
        int v71 = (char *)CFAllocatorAllocate(v72, 128LL, 0LL);
        *((void *)theSet + 3) = v71;
        uint64_t v69 = *((void *)theSet + 4);
        CFIndex v70 = v69 + length;
      }

      *((void *)theSet + 4) = v70;
      unint64_t v73 = &v71[2 * v69];
      do
      {
        *(_WORD *)unint64_t v73 = location;
        v73 += 2;
        ++location;
        --length;
      }

      while (length);
      qsort( *((void **)theSet + 3),  *((void *)theSet + 4),  2uLL,  (int (__cdecl *)(const void *, const void *))chcompar);
      uint64_t v74 = *((void *)theSet + 4);
      if (v74 >= 2)
      {
        uint64_t v75 = 0LL;
        uint64_t v76 = *((void *)theSet + 3);
        uint64_t v77 = v74 - 1;
        int v78 = (unsigned __int16 *)(v76 + 2);
        do
        {
          int v80 = *v78++;
          __int16 v79 = v80;
          if (*(unsigned __int16 *)(v76 + 2 * v75) != v80)
          {
            ++v75;
            *(_WORD *)(v76 + 2 * v75) = v79;
          }

          --v77;
        }

        while (v77);
        uint64_t v74 = v75 + 1;
      }

      *((void *)theSet + 4) = v74;
      unint64_t v81 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        unint64_t v82 = __ldaxr(v11);
        if (v82 != v81) {
          break;
        }
        if (__stlxr(v81 & 0xFFFFFFFFFFFFFFFBLL, v11)) {
          goto LABEL_114;
        }
        char v83 = 1;
LABEL_115:
        unint64_t v81 = v82;
        if ((v83 & 1) != 0) {
          return;
        }
      }

      __clrex();
LABEL_114:
      char v83 = 0;
      goto LABEL_115;
    }
  }

  *((void *)theData + 2) = length;
}

  CFCharacterSetRef result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, 16LL);
LABEL_25:
  *(void *)(a2 + 16) = result;
  return result;
}

    uint64_t v130 = v19;
    if (__CFDefaultCollatorsCount <= 0)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    }

    else
    {
      uint64_t v24 = __CFDefaultCollators[--__CFDefaultCollatorsCount];
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
      Collator = v24;
      if (v24)
      {
        if (v20) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }

    Collator = __CFStringCreateCollator(cf);
    if (v20)
    {
LABEL_27:
      a8 = cf;
      if (Collator)
      {
        uint64_t v126 = 0;
        if (v15 < 0) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }

      goto LABEL_30;
    }

    if (v6 <= v11 + 1) {
      unsigned int v19 = v6;
    }
    else {
      unsigned int v19 = 0LL;
    }
    unsigned int v11 = v11 + 1 - v19;
    if (!--v14) {
      goto LABEL_29;
    }
  }

  char v16 = a2;
LABEL_36:
  char v20 = v24;
  *uint64_t v24 = v11;
  uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8 * v11);
  if (v22 == 2814029233LL)
  {
    uint64_t v22 = 0LL;
  }

  else if (v22 == 2780474809LL)
  {
    uint64_t v22 = -1LL;
  }

  v24[1] = v16;
  void v24[2] = v22;
  uint64_t v23 = *(unsigned __int16 *)(a1 + 18);
  if ((v23 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  char v15 = 1LL;
LABEL_30:
  v20[3] = v15;
  return result;
}

void __CFApplySurrogatesInString( uint64_t a1, CFStringRef theString, void (*a3)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(theString);
  CFStringRef theStringa = theString;
  uint64_t v28 = 0LL;
  CFIndex v29 = Length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0LL;
  uint64_t v26 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  }
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v27 = CStringPtr;
  if (Length >= 1)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    do
    {
      if (v26)
      {
        UniChar v12 = v26[v28 + v9];
      }

      else if (v27)
      {
        UniChar v12 = v27[v28 + v9];
      }

      else
      {
        uint64_t v13 = v30;
        if (v31 <= v9 || v30 > v9)
        {
          uint64_t v15 = v9 - 4;
          if (v9 < 4) {
            uint64_t v15 = 0LL;
          }
          CFIndex v16 = v15 + 64;
          if (v15 + 64 >= v29) {
            CFIndex v16 = v29;
          }
          uint64_t v30 = v15;
          uint64_t v31 = v16;
          v33.unint64_t location = v28 + v15;
          v33.CFIndex length = v16 - v15;
          CFStringGetCharacters(theStringa, v33, buffer);
          uint64_t v13 = v30;
        }

        UniChar v12 = buffer[v9 - v13];
      }

      CFIndex v17 = v9 + 1;
      if (v12 >> 10 == 54 && v17 < Length)
      {
        if (v26)
        {
          UniChar v19 = v26[v28 + v17];
        }

        else if (v27)
        {
          UniChar v19 = v27[v28 + v17];
        }

        else
        {
          if (v31 <= v17 || (uint64_t v20 = v30, v30 > v17))
          {
            uint64_t v21 = v9 - 3;
            if (v9 < 3) {
              uint64_t v21 = 0LL;
            }
            CFIndex v22 = v21 + 64;
            if (v21 + 64 >= v29) {
              CFIndex v22 = v29;
            }
            uint64_t v30 = v21;
            uint64_t v31 = v22;
            v34.unint64_t location = v28 + v21;
            v34.CFIndex length = v22 - v21;
            CFStringGetCharacters(theStringa, v34, buffer);
            uint64_t v20 = v30;
          }

          UniChar v19 = buffer[v17 - v20];
        }

        if (v19 >> 10 == 55)
        {
          uint64_t v23 = (v12 << 10) + v19 - 56613888;
          if (v10 + v11 == v23)
          {
            ++v10;
          }

          else
          {
            if (v10 >= 1) {
              a3(a1, v11, v10);
            }
            uint64_t v11 = v23;
            uint64_t v10 = 1LL;
          }
        }
      }

      else
      {
        CFIndex v17 = v9;
      }

      uint64_t v9 = v17 + 1;
    }

    while (v17 + 1 < Length);
    if (v10 >= 1) {
      a3(a1, v11, v10);
    }
  }

void CFCharacterSetRemoveCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet removeCharactersInString:](theSet, "removeCharactersInString:", theString);
    return;
  }

  uint64_t v10 = (unint64_t *)((char *)theSet + 8);
  char v11 = atomic_load((unint64_t *)theSet + 1);
  if ((v11 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFCharacterSetRemoveCharactersInString(CFMutableCharacterSetRef, CFStringRef)");
  }

  char v12 = atomic_load(v10);
  if ((v12 & 0x70) != 0
    || (char v13 = atomic_load(v10), (v13 & 1) != 0)
    || (char v14 = atomic_load(v10), (v14 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    uint64_t v15 = *((void *)theSet + 5);
    if (v15)
    {
      if (*(_DWORD *)(v15 + 8) || *(_BYTE *)(v15 + 13)) {
        goto LABEL_18;
      }
    }

    unsigned int v16 = atomic_load(v10);
    switch((v16 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*((void *)theSet + 4)) {
          goto LABEL_18;
        }
        break;
      case 3u:
      case 4u:
        if (*((void *)theSet + 3)) {
          goto LABEL_18;
        }
        break;
      default:
        goto LABEL_18;
    }

    char v17 = atomic_load(v10);
    if ((v17 & 8) != 0)
    {
LABEL_18:
      CFIndex Length = CFStringGetLength(theString);
      if (!Length) {
        return;
      }
      CFIndex v19 = Length;
      char v20 = atomic_load(v10);
      if ((v20 & 8) == 0) {
        goto LABEL_31;
      }
      uint64_t v21 = *((void *)theSet + 5);
      if (v21 && (*(_DWORD *)(v21 + 8) || *(_BYTE *)(v21 + 13)))
      {
LABEL_27:
        char v24 = atomic_load(v10);
        uint64_t v23 = (v24 & 0x70) == 0x20LL ? *((void *)theSet + 4) : 64LL;
      }

      else
      {
        unsigned int v22 = atomic_load(v10);
        switch((v22 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((void *)theSet + 4)) {
              goto LABEL_27;
            }
            break;
          case 3u:
          case 4u:
            if (*((void *)theSet + 3)) {
              goto LABEL_27;
            }
            break;
          default:
            goto LABEL_27;
        }

        uint64_t v23 = 0LL;
      }

      size_t v25 = v23 + Length;
      if (v23 + Length > 63)
      {
LABEL_31:
        __CFCSetMakeBitmap((char *)theSet);
        CFStringRef theStringa = theString;
        uint64_t v76 = 0LL;
        CFIndex v77 = v19;
        CharactersPtr = CFStringGetCharactersPtr(theString);
        CStringPtr = 0LL;
        uint64_t v74 = CharactersPtr;
        if (!CharactersPtr) {
          CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
        }
        int64_t v78 = 0LL;
        int64_t v79 = 0LL;
        uint64_t v75 = CStringPtr;
        if (v19 < 1)
        {
          char v36 = 0;
        }

        else
        {
          uint64_t v35 = 0LL;
          char v36 = 0;
          int64_t v37 = 0LL;
          uint64_t v38 = 64LL;
          do
          {
            else {
              uint64_t v39 = v37;
            }
            if (v74)
            {
              UniChar v40 = v74[v37 + v76];
            }

            else if (v75)
            {
              UniChar v40 = v75[v76 + v37];
            }

            else
            {
              int64_t v41 = v78;
              if (v79 <= v37 || v78 > v37)
              {
                uint64_t v43 = -v39;
                uint64_t v44 = v39 + v35;
                uint64_t v45 = v38 - v39;
                int64_t v46 = v37 + v43;
                CFIndex v47 = v46 + 64;
                if (v46 + 64 >= v77) {
                  CFIndex v47 = v77;
                }
                int64_t v78 = v46;
                int64_t v79 = v47;
                if (v77 < v45) {
                  uint64_t v45 = v77;
                }
                v81.CFIndex length = v45 + v44;
                v81.unint64_t location = v46 + v76;
                CFStringGetCharacters(theStringa, v81, buffer);
                int64_t v41 = v78;
              }

              UniChar v40 = buffer[v37 - v41];
            }

            if ((v40 & 0xF800 | 0x400) == 0xDC00) {
              char v36 = 1;
            }
            else {
              *(_BYTE *)(*((void *)theSet + 3) + (v40 >> 3)) &= ~(1 << (v40 & 7));
            }
            ++v37;
            --v35;
            ++v38;
          }

          while (v19 != v37);
        }

        unint64_t v48 = atomic_load(v10);
        while (1)
        {
          unint64_t v49 = __ldaxr(v10);
          if (v49 != v48) {
            break;
          }
          if (__stlxr(v48 & 0xFFFFFFFFFFFFFFFBLL, v10)) {
            goto LABEL_63;
          }
          int v50 = 1;
LABEL_64:
          unint64_t v48 = v49;
          if (v50)
          {
            if (__CFCheckForExapendedSet == 1) {
              __CFCheckForExpandedSet((const char *)theSet, v26, v27, v28, v29, v30, v31, v32);
            }
            if ((v36 & 1) != 0) {
              __CFApplySurrogatesInString( (uint64_t)theSet,  theString,  (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
            }
            return;
          }
        }

        __clrex();
LABEL_63:
        int v50 = 0;
        goto LABEL_64;
      }

      uint64_t v51 = *((void *)theSet + 3);
      if (v51)
      {
        uint64_t v52 = (UniChar *)(v51 + 2LL * *((void *)theSet + 4));
      }

      else
      {
        CFIndex v53 = CFGetAllocator(theSet);
        uint64_t v52 = (UniChar *)CFAllocatorAllocate(v53, 128LL, 0LL);
      }

      v82.unint64_t location = 0LL;
      v82.CFIndex length = v19;
      CFStringGetCharacters(theString, v82, v52);
      if (v19 < 2)
      {
        char v54 = 0;
      }

      else
      {
        char v54 = 0;
        uint64_t v55 = &v52[v19];
        uint64_t v56 = -2LL - (void)v52;
        uint64_t v57 = v52;
        do
        {
          if ((*v57 & 0xF800 | 0x400) == 0xDC00)
          {
            memmove(v57, v57 + 1, ((uint64_t)v55-- + v56) >> 1);
            char v54 = 1;
          }

          ++v57;
          v56 -= 2LL;
        }

        while (v57 < v55);
        size_t v25 = v23 + v55 - v52;
      }

      uint64_t v58 = (UniChar *)*((void *)theSet + 3);
      if (!v58)
      {
        unint64_t v59 = atomic_load(v10);
        while (1)
        {
          unint64_t v60 = __ldaxr(v10);
          if (v60 != v59) {
            break;
          }
          if (__stlxr(v59 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v10)) {
            goto LABEL_85;
          }
          int v61 = 1;
LABEL_86:
          unint64_t v59 = v60;
          if (v61)
          {
            *((void *)theSet + 3) = v52;
            uint64_t v58 = v52;
            goto LABEL_88;
          }
        }

        __clrex();
LABEL_85:
        int v61 = 0;
        goto LABEL_86;
      }

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  uint64_t v2 = (__objc2_class **)MEMORY[0x1895F8858](theSet, theOtherSet);
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v137 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    [v5 formUnionWithCharacterSet:v4];
    return;
  }

  char v12 = (unint64_t *)(v5 + 1);
  char v13 = atomic_load((unint64_t *)v5 + 1);
  if ((v13 & 1) == 0)
  {
    CFLog( 3LL,  (uint64_t)@"%s: Immutable character set passed to mutable function",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)"void CFCharacterSetUnion(CFMutableCharacterSetRef, CFCharacterSetRef)");
  }

  char v14 = atomic_load(v12);
  if ((v14 & 0x70) == 0)
  {
    char v15 = atomic_load(v12);
    if ((v15 & 1) == 0)
    {
      char v16 = atomic_load(v12);
      if ((v16 & 8) == 0 && CFCharacterSetGetPredefined((CFCharacterSetPredefinedSet)v5[3]) == (CFCharacterSetRef)v5) {
        return;
      }
    }
  }

  char v17 = v5[5];
  if (!v17 || !LODWORD(v17->superclass) && !BYTE5(v17->superclass))
  {
    unsigned int v18 = atomic_load(v12);
    switch((v18 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v5[4]) {
          goto LABEL_18;
        }
        break;
      case 3u:
      case 4u:
        if (v5[3]) {
          goto LABEL_18;
        }
        break;
      default:
        goto LABEL_18;
    }

    char v19 = atomic_load(v12);
    if ((v19 & 8) != 0) {
      return;
    }
  }

LABEL_165:
            uint64_t v114 = *(void *)(v4 + 40);
            if (v114 && *(_BYTE *)(v114 + 13))
            {
              uint64_t v115 = v5[5];
              if (!v115)
              {
                unint64_t v116 = CFGetAllocator(v5);
                uint64_t v115 = (__objc2_class *)CFAllocatorAllocate(v116, 16LL, 0LL);
                uint64_t v5[5] = v115;
                v115->isa = 0LL;
                *(__objc2_class **)((char *)&v115->isa + 6) = 0LL;
              }

              BYTE5(v115->superclass) = 1;
            }

            unint64_t v117 = atomic_load(v12);
            while (2)
            {
              unint64_t v118 = __ldaxr(v12);
              if (v118 == v117)
              {
                if (!__stlxr(v117 & 0xFFFFFFFFFFFFFFFBLL, v12))
                {
                  char v119 = 1;
                  goto LABEL_176;
                }
              }

              else
              {
                __clrex();
              }

              char v119 = 0;
LABEL_176:
              unint64_t v117 = v118;
              if ((v119 & 1) != 0) {
                goto LABEL_196;
              }
              continue;
            }
          }
        }

        __clrex();
LABEL_155:
        int v109 = 0;
        goto LABEL_156;
      }
    }

          int v95 = CFUniCharPrecomposeCharacter(v49, v91);
          if (v95 == 65533) {
            goto LABEL_228;
          }
          unsigned int v49 = v95;
          unint64_t v96 = 1LL;
          v155 += v96;
          uint64_t i = &v92[v96];
          *int v43 = v95;
          uint64_t v52 = 1LL;
        }

        LODWORD(v91) = ((_DWORD)v91 << 10) - 56613888 + v97;
        char v98 = CFUniCharGetBitmapPtrForPlane(8u, WORD1(v91));
        if (v98 && ((*(unsigned __int8 *)(v98 + ((unsigned __int16)v91 >> 3)) >> (v97 & 7)) & 1) != 0)
        {
          unint64_t v99 = CFUniCharGetUnicodePropertyDataForPlane(0, WORD1(v91));
          if (v99)
          {
            char v42 = v156;
            if (*(_BYTE *)(v99 + BYTE1(v91))
              && *(_BYTE *)(v99 + (*(unsigned __int8 *)(v99 + BYTE1(v91)) << 8) - 256 + v97 + 256))
            {
              goto LABEL_228;
            }
          }

          else
          {
            char v42 = v156;
          }

          goto LABEL_165;
        }

        char v42 = v156;
LABEL_228:
        uint64_t i = v92;
LABEL_229:
        if (v52 < 1)
        {
          BOOL v106 = v153;
          unint64_t v107 = v155;
        }

        else
        {
          uint64_t v105 = &v43[v52];
          unint64_t v107 = v155;
          if ((_DWORD)v52)
          {
            BOOL v106 = v153;
            goto LABEL_232;
          }

          char v119 = 0;
          char v123 = 1;
          BOOL v106 = v153;
LABEL_240:
          int v124 = v119;
          if (v107 != v119)
          {
            v159[0] = v106;
            v159[1] = v107;
            __CFStringChangeSizeMultiple((char *)v2, (uint64_t)v159, 1LL, v119, 1);
            unint64_t v107 = v124;
          }

          BOOL v125 = atomic_load((unint64_t *)&v2->info);
          if ((v125 & 0x60) != 0)
          {
            uint64_t v126 = *v144;
          }

          else
          {
            char v127 = atomic_load((unint64_t *)&v2->info);
            uint64_t v126 = (char *)&v144[(v127 & 5) != 4LL];
          }

          uint64_t v128 = atomic_load((unint64_t *)&v2->info);
          uint64_t v129 = atomic_load((unint64_t *)&v2->info);
          uint64_t v130 = v129 & 0x60;
          if ((v128 & 5) == 4LL)
          {
            if (v130)
            {
              uint64_t v131 = *v144;
            }

            else
            {
              uint64_t v133 = atomic_load((unint64_t *)&v2->info);
              uint64_t v131 = (char *)&v144[(v133 & 5) != 4LL];
            }

            int v132 = *v131;
          }

          else if (v130)
          {
            int v132 = v2->length;
          }

          else
          {
            int v132 = (uint64_t)*v144;
          }

          if ((v123 & 1) == 0)
          {
            uint64_t v134 = v43;
            uint64_t v135 = &v126[2 * v106];
            do
            {
              uint64_t v137 = *v134++;
              uint64_t v136 = v137;
              if (v137 < 0x10000)
              {
                CFRange v139 = v135 + 2;
                LOWORD(v138) = v136;
              }

              else
              {
                CFRange v138 = ((v136 + 67043328) >> 10) - 10240;
                CFRange v139 = v135 + 4;
                *((_WORD *)v135 + 1) = v136 & 0x3FF | 0xDC00;
              }

              *(_WORD *)uint64_t v135 = v138;
              uint64_t v135 = v139;
            }

            while (v134 < v105);
          }

          unint64_t v35 = (unint64_t)&v126[2 * v132];
          uint64_t i = (unsigned __int16 *)&v126[2 * v106 + 2 * v124];
        }

        uint64_t v28 = v107 + v106;
        if ((unint64_t)i >= v35)
        {
          return;
        }
      }

      if (v52 < 1)
      {
        uint64_t v54 = (unsigned __int16)v49;
        if (v49 >= 0x10000)
        {
LABEL_68:
          char v57 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v49));
          char v56 = 0;
          if (!v57) {
            goto LABEL_75;
          }
          goto LABEL_69;
        }

        char v56 = 1;
      }

      else
      {
        uint64_t v54 = *i;
        if ((v54 & 0xFC00) == 0xD800 && (unint64_t)(i + 1) < v154)
        {
          char v55 = i[1];
          if ((v55 & 0xFC00) == 0xDC00)
          {
            unsigned int v49 = (v54 << 10) - 56613888 + v55;
            uint64_t v54 = (unsigned __int16)(((_WORD)v54 << 10) + 9216 + v55);
            goto LABEL_68;
          }
        }

        char v56 = 1;
        unsigned int v49 = *i;
      }

      char v57 = v42;
      if (!v42) {
        goto LABEL_75;
      }
LABEL_69:
      if (*(_BYTE *)(v57 + ((unint64_t)v54 >> 8))
        && *(_BYTE *)(v57
                    + (*(unsigned __int8 *)(v57 + ((unint64_t)v54 >> 8)) << 8)
                    - 256
                    + v54
                    + 256))
      {
        if (v52)
        {
          char v58 = i;
          unint64_t v59 = 1LL;
          if (!v56) {
            unint64_t v59 = 2LL;
          }
          v155 += v59;
        }

        else
        {
          unint64_t v100 = 0x7FFFFFFFFFFFFFFELL;
          if (v56) {
            unint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
          }
          int v101 = &i[v100];
          unint64_t v102 = v28 - 1;
          if (v28 < 1)
          {
            char v58 = v101;
            uint64_t v52 = 0LL;
          }

          else
          {
            unint64_t v103 = *(v101 - 1);
            if ((v103 & 0xFC00) == 0xDC00 && v28 != 1 && (char v104 = *(v101 - 2), (v104 & 0xFC00) == 0xD800))
            {
              char v58 = v101;
              *int v43 = v103 - 56613888 + (v104 << 10);
              v153 -= 2LL;
              v155 += 2LL;
              uint64_t v52 = 1LL;
            }

            else
            {
              char v58 = v101;
              *int v43 = v103;
              ++v155;
              uint64_t v52 = 1LL;
              uint64_t v153 = v102;
            }
          }
        }

        if (v56) {
          unint64_t v108 = 1LL;
        }
        else {
          unint64_t v108 = 2LL;
        }
        int v109 = BitmapPtrForPlane;
        if ((v56 & 1) == 0) {
          int v109 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v49));
        }
        if (v109 && ((*(unsigned __int8 *)(v109 + ((unint64_t)v54 >> 3)) >> (v54 & 7)) & 1) != 0)
        {
          char v110 = CFUniCharDecomposeCharacter(v49, &v43[v52], 64 - v52);
        }

        else
        {
          v43[v52] = v49;
          char v110 = 1LL;
        }

        for (uint64_t i = &v58[v108]; ; uint64_t i = &v152[v116])
        {
          v52 += v110;
          unint64_t v35 = v154;
          unint64_t v111 = *i;
          int v152 = i;
          unint64_t v112 = i + 1;
          int v113 = (v111 & 0xFC00) != 0xD800 || (unint64_t)v112 >= v154;
          if (v113 || (unint64_t v117 = *v112, (v117 & 0xFC00) != 0xDC00))
          {
            uint64_t v114 = 1;
            unsigned int v49 = v111;
            uint64_t v115 = v42;
            if (!v42) {
              break;
            }
          }

          else
          {
            unsigned int v49 = (v111 << 10) - 56613888 + v117;
            unint64_t v111 = (unsigned __int16)(((_WORD)v111 << 10) + 9216 + v117);
            uint64_t v115 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v49));
            uint64_t v114 = 0;
            if (!v115) {
              break;
            }
          }

          if (!*(_BYTE *)(v115 + ((unint64_t)v111 >> 8))
            || !*(_BYTE *)(v115
                         + (*(unsigned __int8 *)(v115 + ((unint64_t)v111 >> 8)) << 8)
                         - 256
                         + v111
                         + 256))
          {
            break;
          }

          if (v114) {
            unint64_t v116 = 1LL;
          }
          else {
            unint64_t v116 = 2LL;
          }
          if (v52 == v44)
          {
            v44 += 64LL;
            if (v43 == (unsigned int *)__src)
            {
              int v43 = (unsigned int *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 4 * v44, 0LL);
              memmove(v43, __src, 0x100uLL);
            }

            else
            {
              int v43 = (unsigned int *)__CFSafelyReallocateWithAllocator( (malloc_zone_t *)&__kCFAllocatorSystemDefault,  v43,  4 * v44,  0LL,  0LL);
            }
          }

          unint64_t v118 = BitmapPtrForPlane;
          if ((v114 & 1) == 0) {
            unint64_t v118 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v49));
          }
          if (v118 && ((*(unsigned __int8 *)(v118 + ((unint64_t)v111 >> 3)) >> (v111 & 7)) & 1) != 0)
          {
            char v110 = CFUniCharDecomposeCharacter(v49, &v43[v52], 64 - v52);
          }

          else
          {
            v43[v52] = v49;
            char v110 = 1LL;
          }

          v155 += v116;
        }

        uint64_t i = v152;
        goto LABEL_76;
      }

            unint64_t v66 = -3LL;
            if (!v12) {
              unint64_t v66 = -2LL;
            }
            v13 += v66;
LABEL_168:
            uint64_t v8 = v13 + 1;
            goto LABEL_142;
          }

LABEL_134:
            ++v79;
            v80 += 8LL;
            if (v79 == 16) {
              goto LABEL_196;
            }
          }

          unsigned __int16 v85 = v5[5];
          if (!v78)
          {
            if (v85)
            {
              if (BYTE4(v85->superclass) < v83)
              {
                BYTE4(v85->superclass) = v83;
                isa = v85->isa;
                unint64_t v90 = (malloc_zone_t *)CFGetAllocator(v5);
                if (isa)
                {
                  unint64_t v91 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v90, v5[5]->isa, v80, 0LL, 0LL);
                  goto LABEL_130;
                }

      if ((v68 & 0xFC00) != 0xD800) {
        goto LABEL_144;
      }
      if (v60 < -1) {
        goto LABEL_144;
      }
      unsigned __int16 v85 = v335;
      if (v335 <= v64) {
        goto LABEL_144;
      }
      uint64_t v86 = v332;
      if (v332)
      {
        unint64_t v87 = v334 + v64;
LABEL_139:
        uint64_t v88 = v86[v87];
        goto LABEL_142;
      }

      if (!v333)
      {
        if (v337 <= v64 || (unint64_t v102 = v336, v336 > v64))
        {
          if (v289 < v335) {
            unsigned __int16 v85 = v289;
          }
          v336 = v290;
          v337 = v85;
          v349.unint64_t location = v334 + v290;
          v349.CFIndex length = v85 - v290;
          v282 = v51;
          unint64_t v103 = v48;
          v291 = v55;
          char v104 = v50;
          CFStringGetCharacters(v331, v349, buffer);
          unint64_t v64 = v316;
          unint64_t v61 = v318;
          int64_t v46 = v321;
          char v57 = v306;
          char v56 = v317 ^ 1;
          char v51 = v282;
          char v58 = v303;
          CFIndex v47 = v304;
          uint64_t v50 = v104;
          char v55 = v291;
          unsigned int v49 = v317;
          unint64_t v48 = v103;
          unint64_t v102 = v336;
        }

        unint64_t v87 = v64 - v102;
        uint64_t v86 = buffer;
        goto LABEL_139;
      }

      uint64_t v88 = *(char *)(v333 + v334 + v64);
LABEL_142:
      if (v88 >> 10 == 55)
      {
        int v68 = ((unsigned __int16)v68 << 10) - 56613888 + v88;
        v328 = 2LL;
      }

  int v68 = 1LL;
  if (!a6) {
    goto LABEL_136;
  }
LABEL_135:
  *a6 = v64;
LABEL_136:
  if (a5) {
    *(void *)a5 = v68 + v64;
  }
}

            if (a1 >= v17) {
              goto LABEL_138;
            }
          }
        }

        goto LABEL_60;
      }

      goto LABEL_24;
    }

    if ((_DWORD)a3 != 134217984)
    {
      uint64_t v25 = 201326848;
      goto LABEL_34;
    }

    if (v12 >= 3 && *a1 == 239 && a1[1] == 187 && a1[2] == 191)
    {
      v12 -= 3LL;
      if (!v12) {
        return 1LL;
      }
      a1 += 3;
    }

    if (!*(_BYTE *)(a5 + 8))
    {
LABEL_91:
      if (__CFStringDecodeByteStream3_onceToken != -1) {
        dispatch_once(&__CFStringDecodeByteStream3_onceToken, &__block_literal_global_19);
      }
      unsigned int v49 = *(void **)a5;
      char v51 = (unint64_t)v12 > 0x1F8 || v49 != 0LL;
      *(_BYTE *)(a5 + 9) = v51;
      if (!v49)
      {
        if ((unint64_t)v12 > 0x1F8)
        {
          uint64_t v52 = CFAllocatorAllocate(*(CFAllocatorRef *)(a5 + 16), 2 * v12, 0LL);
          *(void *)a5 = v52;
          if (!v52) {
            goto LABEL_204;
          }
LABEL_186:
          uint64_t *v14 = 0LL;
          if (a1 < v17)
          {
            unint64_t v74 = 0LL;
            while (1)
            {
              v109[0] = 0LL;
              unint64_t v75 = __CFStringDecodeByteStream3___CFFromUTF8(a7, a1, v17 - a1, *(void *)a5 + 2 * v74, v12 - v74, v109);
              int v76 = v109[0];
              if (!v109[0]) {
                break;
              }
              a1 += v75;
              unint64_t v74 = *v14 + v109[0];
              uint64_t *v14 = v74;
              if (a1 >= v17) {
                goto LABEL_202;
              }
            }

LABEL_129:
                unint64_t v91 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v90, v80, 0LL);
LABEL_130:
                unsigned __int16 v85 = v5[5];
                v85->isa = v91;
              }

              if (((uint64_t)v85->superclass & v82) == 0)
              {
                unint64_t v97 = CFGetAllocator(v5);
                *((void *)&v5[5]->isa->isa + v79) = CFCharacterSetCreateMutable(v97);
                unsigned __int16 v85 = v5[5];
                LODWORD(v85->superclass) |= v82;
              }

              CFCharacterSetUnion(*((CFMutableCharacterSetRef *)&v85->isa->isa + v79), v84);
              goto LABEL_134;
            }

            int v95 = CFGetAllocator(v5);
            unint64_t v96 = (__objc2_class *)CFAllocatorAllocate(v95, 16LL, 0LL);
            uint64_t v5[5] = v96;
            WORD2(v96->superclass) = v83;
            LODWORD(v96->superclass) = 0;
            unint64_t v90 = (malloc_zone_t *)CFGetAllocator(v5);
            goto LABEL_129;
          }

          if (v85)
          {
            if (BYTE4(v85->superclass) >= v83)
            {
LABEL_125:
              if (((uint64_t)v85->superclass & v82) == 0)
              {
                unint64_t v94 = CFGetAllocator(v5);
                *((void *)&v5[5]->isa->isa + v79) = CFCharacterSetCreateMutable(v94);
                unsigned __int16 v85 = v5[5];
                LODWORD(v85->superclass) |= v82;
              }

              CFCharacterSetIntersect(*((CFMutableCharacterSetRef *)&v85->isa->isa + v79), v84);
              goto LABEL_134;
            }

            BYTE4(v85->superclass) = v83;
            uint64_t v86 = v85->isa;
            unint64_t v87 = (malloc_zone_t *)CFGetAllocator(v5);
            if (v86)
            {
              uint64_t v88 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v87, v5[5]->isa, v80, 0LL, 0LL);
LABEL_124:
              unsigned __int16 v85 = v5[5];
              v85->isa = v88;
              goto LABEL_125;
            }
          }

          else
          {
            char v92 = CFGetAllocator(v5);
            unint64_t v93 = (__objc2_class *)CFAllocatorAllocate(v92, 16LL, 0LL);
            uint64_t v5[5] = v93;
            WORD2(v93->superclass) = v83;
            LODWORD(v93->superclass) = 0;
            unint64_t v87 = (malloc_zone_t *)CFGetAllocator(v5);
          }

          uint64_t v88 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v87, v80, 0LL);
          goto LABEL_124;
        }

        if (*(_BYTE *)(v77 + 13))
        {
          char v98 = v5[5];
          if (v98)
          {
            if (!LODWORD(v98->superclass))
            {
LABEL_145:
              BYTE5(v98->superclass) = 1;
              goto LABEL_196;
            }

            for (uint64_t j = 0LL; j != 16; ++j)
            {
              unint64_t v100 = v5[5];
              if (((LODWORD(v100->superclass) >> j) & 2) != 0) {
                CFRelease(*((CFTypeRef *)&v100->isa->isa + j));
              }
            }

            int v101 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v101, v5[5]->isa);
            unint64_t v102 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v102, v5[5]);
            uint64_t v5[5] = 0LL;
          }

          unint64_t v103 = CFGetAllocator(v5);
          char v98 = (__objc2_class *)CFAllocatorAllocate(v103, 16LL, 0LL);
          uint64_t v5[5] = v98;
          v98->isa = 0LL;
          *(__objc2_class **)((char *)&v98->isa + 6) = 0LL;
          goto LABEL_145;
        }
      }

      char v104 = atomic_load((unint64_t *)(v4 + 8));
      if ((v104 & 0x70) != 0) {
        goto LABEL_196;
      }
      uint64_t v105 = *(void *)(v4 + 40);
      if (v105) {
        BOOL v106 = *(unsigned __int8 *)(v105 + 13) != 0;
      }
      else {
        BOOL v106 = 0;
      }
      unint64_t v120 = 1LL;
      while (1)
      {
        int BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v120, __b, v106);
        if (BitmapForPlane != 255) {
          break;
        }
LABEL_195:
        if (++v120 == 17) {
          goto LABEL_196;
        }
      }

      int v122 = BitmapForPlane;
      char v123 = v5[5];
      if (v123)
      {
        if (v120 <= BYTE4(v123->superclass))
        {
LABEL_188:
          if (((uint64_t)v123->superclass & (1 << v120)) != 0)
          {
            uint64_t v129 = (v120 - 1);
          }

          else
          {
            uint64_t v130 = CFGetAllocator(v5);
            CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(v130);
            uint64_t v129 = (v120 - 1);
            *((void *)&v5[5]->isa->isa + v129) = Mutable;
            char v123 = v5[5];
            LODWORD(v123->superclass) |= 1 << v120;
          }

          int v132 = v123->isa;
          uint64_t v133 = *((void *)&v132->isa + v129);
          if (v122 == 1)
          {
            v139.unint64_t location = 0LL;
            v139.CFIndex length = 0x10000LL;
            CFCharacterSetAddCharactersInRange(*((CFMutableCharacterSetRef *)&v132->isa + v129), v139);
          }

          else
          {
            __CFCSetMakeBitmap(*((char **)&v132->isa + v129));
            uint64_t v134 = 0LL;
            uint64_t v135 = *(void *)(v133 + 24);
            do
            {
              *(_DWORD *)(v135 + v134 * 4) |= __b[0].u32[v134];
              ++v134;
            }

            while (v134 != 2048);
          }

          goto LABEL_195;
        }

        BYTE4(v123->superclass) = v120;
        int v124 = v123->isa;
        BOOL v125 = (malloc_zone_t *)CFGetAllocator(v5);
        if (v124)
        {
          uint64_t v126 = (__objc2_class *)__CFSafelyReallocateWithAllocator(v125, v5[5]->isa, 8 * v120, 0LL, 0LL);
LABEL_187:
          char v123 = v5[5];
          v123->isa = v126;
          goto LABEL_188;
        }
      }

      else
      {
        char v127 = CFGetAllocator(v5);
        uint64_t v128 = (__objc2_class *)CFAllocatorAllocate(v127, 16LL, 0LL);
        uint64_t v5[5] = v128;
        BYTE4(v128->superclass) = v120;
        BYTE5(v128->superclass) = 0;
        LODWORD(v128->superclass) = 0;
        BOOL v125 = (malloc_zone_t *)CFGetAllocator(v5);
      }

      uint64_t v126 = (__objc2_class *)CFAllocatorAllocate((CFAllocatorRef)v125, 8 * v120, 0LL);
      goto LABEL_187;
    }

    if ((v42 & 0x70) == 0x20LL)
    {
      int64_t v46 = CFGetAllocator(v5);
      CFIndex v47 = CFStringCreateWithCharactersNoCopy( v46,  *(const UniChar **)(v4 + 24),  *(void *)(v4 + 32),  (CFAllocatorRef)&__kCFAllocatorNull);
      CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)v5, v47);
      CFRelease(v47);
      goto LABEL_106;
    }

    __CFCSetMakeBitmap((char *)v5);
    char v51 = atomic_load((unint64_t *)(v4 + 8));
    uint64_t v52 = v5[3];
    if ((v51 & 0x70) == 0x30LL)
    {
      uint64_t v53 = 0LL;
      uint64_t v54 = *(void *)(v4 + 24);
      do
      {
        *(_DWORD *)((char *)&v52->isa + v53) |= *(_DWORD *)(v54 + v53);
        v53 += 4LL;
      }

      while (v53 != 0x2000);
    }

    else
    {
      __CFCSetGetBitmap(v4, __b);
      for (uint64_t k = 0LL; k != 2048; ++k)
        *(_DWORD *)((char *)&v52->isa + k * 4) |= __b[0].u32[k];
    }

    unint64_t v74 = atomic_load(v12);
    while (1)
    {
      unint64_t v75 = __ldaxr(v12);
      if (v75 != v74) {
        break;
      }
      if (__stlxr(v74 & 0xFFFFFFFFFFFFFFFBLL, v12)) {
        goto LABEL_104;
      }
      int v76 = 1;
LABEL_105:
      unint64_t v74 = v75;
      if (v76) {
        goto LABEL_106;
      }
    }

    __clrex();
LABEL_104:
    int v76 = 0;
    goto LABEL_105;
  }

  BitmapRepresentatiouint64_t n = CFCharacterSetCreateBitmapRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (CFCharacterSetRef)v4);
  if (BitmapRepresentation)
  {
    uint64_t v29 = BitmapRepresentation;
    if (CFDataGetLength(BitmapRepresentation))
    {
      BytePtr = CFDataGetBytePtr(v29);
      if (BytePtr)
      {
        uint64_t v31 = BytePtr;
        __CFCSetMakeBitmap((char *)v5);
        uint64_t v32 = 0LL;
        CFRange v33 = v5[3];
        do
        {
          *(_DWORD *)((char *)&v33->isa + v32) |= *(_DWORD *)&v31[v32];
          v32 += 4LL;
        }

        while (v32 != 0x2000);
        unint64_t v34 = atomic_load(v12);
        while (1)
        {
          unint64_t v35 = __ldaxr(v12);
          if (v35 != v34) {
            break;
          }
          if (__stlxr(v34 & 0xFFFFFFFFFFFFFFFBLL, v12)) {
            goto LABEL_30;
          }
          int v36 = 1;
LABEL_31:
          unint64_t v34 = v35;
          if (v36) {
            goto LABEL_32;
          }
        }

        __clrex();
LABEL_30:
        int v36 = 0;
        goto LABEL_31;
      }
    }

void _CFCharacterSetCompact(unint64_t *cf)
{
  char v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x30LL && cf[3]) {
    __CFCSetMakeCompact(cf);
  }
  unint64_t v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (uint64_t i = 0LL; i != 16; ++i)
    {
      unint64_t v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          uint64_t v6 = *(unint64_t **)(*(void *)v5 + 8 * i);
          if (v6)
          {
            char v7 = atomic_load(v6 + 1);
            if ((v7 & 0x70) == 0x30LL)
            {
              if (v6[3]) {
                __CFCSetMakeCompact(v6);
              }
            }
          }
        }
      }
    }
  }

void _CFCharacterSetFast(unint64_t *cf)
{
  char v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x40LL && cf[3]) {
    __CFCSetMakeBitmap((char *)cf);
  }
  unint64_t v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (uint64_t i = 0LL; i != 16; ++i)
    {
      unint64_t v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          uint64_t v6 = *(void *)(*(void *)v5 + 8 * i);
          if (v6)
          {
            char v7 = atomic_load((unint64_t *)(v6 + 8));
            if ((v7 & 0x70) == 0x40LL)
            {
              if (*(void *)(v6 + 24)) {
                __CFCSetMakeBitmap((char *)v6);
              }
            }
          }
        }
      }
    }
  }

uint64_t _CFCharacterSetGetKeyedCodingType(uint64_t a1)
{
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  int v4 = (v3 >> 4) & 7;
  if (v4 == 2)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    if (!v5 || !*(_DWORD *)(v5 + 8) && !*(_BYTE *)(v5 + 13)) {
      return 4LL;
    }
    return 1LL;
  }

  if (v4 == 1) {
    return 3LL;
  }
  if (v4) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

uint64_t _CFCharacterSetIsMutable(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFCharacterSetGetKeyedCodingBuiltinType(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t _CFCharacterSetGetKeyedCodingRange(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

CFStringRef _CFCharacterSetCreateKeyedCodingString(uint64_t a1)
{
  return CFStringCreateWithCharacters( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  *(const UniChar **)(a1 + 24),  *(void *)(a1 + 32));
}

uint64_t _CFCharacterSetIsInverted(uint64_t a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 >> 3) & 1;
}

uint64_t _CFCharacterSetSetIsInverted(uint64_t result, int a2)
{
  char v2 = (unint64_t *)(result + 8);
  unint64_t v3 = atomic_load((unint64_t *)(result + 8));
  uint64_t v4 = 8LL;
  if (!a2) {
    uint64_t v4 = 0LL;
  }
  do
  {
    unint64_t v5 = __ldaxr(v2);
    if (v5 == v3)
    {
      if (!__stlxr(v3 & 0xFFFFFFFFFFFFFFF7LL | v4, v2))
      {
        int v6 = 1;
        goto LABEL_8;
      }
    }

    else
    {
      __clrex();
    }

    int v6 = 0;
LABEL_8:
    unint64_t v3 = v5;
  }

  while (!v6);
  return result;
}

uint64_t CFCharacterSetInitInlineBuffer(__objc2_class **a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t)a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)a2 = a1;
  *(_DWORD *)(a2 + 16) = 0x10000;
  uint64_t result = CF_IS_OBJC(0x19uLL, a1);
  if ((_DWORD)result && (uint64_t result = [(id)v3 _expandedCFCharacterSet], (v3 = result) == 0))
  {
    *(_DWORD *)(a2 + 8) = 2;
LABEL_24:
    *(_DWORD *)(a2 + 16) = 1114112;
  }

  else
  {
    unsigned int v5 = atomic_load((unint64_t *)(v3 + 8));
    switch((v5 >> 4) & 7)
    {
      case 0u:
        uint64_t result = CFUniCharGetBitmapPtrForPlane(*(_DWORD *)(v3 + 24), 0);
        *(void *)(a2 + 24) = result;
        *(_DWORD *)(a2 + 16) = 1114112;
        if (result)
        {
          char v9 = atomic_load((unint64_t *)(v3 + 8));
          if ((v9 & 8) == 0) {
            goto LABEL_22;
          }
          int v8 = 4;
        }

        else
        {
          int v8 = 2;
        }

        goto LABEL_21;
      case 1u:
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(v3 + 24);
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 24) + *(_DWORD *)(v3 + 32);
        char v10 = atomic_load((unint64_t *)(v3 + 8));
        if ((v10 & 8) != 0) {
          *(_DWORD *)(a2 + 8) = 4;
        }
        return result;
      case 2u:
        *(_DWORD *)(a2 + 8) = 2;
        if (*(uint64_t *)(v3 + 32) >= 1)
        {
          *(_DWORD *)(a2 + 12) = **(unsigned __int16 **)(v3 + 24);
          *(_DWORD *)(a2 + 16) = *(unsigned __int16 *)(*(void *)(v3 + 24) + 2LL * *(void *)(v3 + 32) - 2) + 1;
          char v11 = atomic_load((unint64_t *)(v3 + 8));
          if ((v11 & 8) != 0)
          {
            int v12 = *(_DWORD *)(a2 + 12);
            int v13 = *(_DWORD *)(a2 + 16);
            if (v12)
            {
              if (v13 == 0x10000)
              {
                *(_DWORD *)(a2 + 12) = 0;
                *(_DWORD *)(a2 + 16) = v12;
              }

              else
              {
                *(void *)(a2 + 12) = 0x1000000000000LL;
              }
            }

            else
            {
              *(_DWORD *)(a2 + 12) = v13;
              *(_DWORD *)(a2 + 16) = 0x10000;
            }
          }
        }

        goto LABEL_22;
      case 3u:
      case 4u:
        uint64_t v6 = *(void *)(v3 + 24);
        *(void *)(a2 + 24) = v6;
        if (v6)
        {
          char v7 = atomic_load((unint64_t *)(v3 + 8));
          if ((v7 & 0x70) != 0x40LL) {
            goto LABEL_22;
          }
          int v8 = 1;
        }

        else
        {
          *(_DWORD *)(a2 + 8) = 1;
          uint64_t v14 = atomic_load((unint64_t *)(v3 + 8));
          if ((v14 & 8) == 0) {
            goto LABEL_22;
          }
          int v8 = *(_DWORD *)(a2 + 8) | 4;
        }

char *_CFCreateCharacterSetFromUSet(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable(0LL);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v3 = Mutable;
  ItemCFIndex Count = uset_getItemCount();
  if (ItemCount >= 1)
  {
    int v5 = ItemCount;
    for (int i = 0; i != v5; ++i)
    {
      Iteuint64_t m = uset_getItem();
      if (Item <= 0)
      {
        v15.unint64_t location = v12;
        v15.CFIndex length = v11 - v12 + 1;
        CFCharacterSetAddCharactersInRange(v3, v15);
      }

      else
      {
        int v8 = CFStringCreateWithCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v13,  Item,  (CFAllocatorRef)&__kCFAllocatorNull);
        CFCharacterSetAddCharactersInString(v3, v8);
        CFRelease(v8);
      }
    }
  }

  CFStringRef Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (unint64_t *)v3, 0, 1);
  CFRelease(v3);
  return Copy;
}

uint64_t __CFCSetIsEqualAnnex(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(v3 + 40);
  if (!v4)
  {
    uint64_t v6 = (uint64_t *)(v2 + 40);
    uint64_t v7 = *(void *)(v2 + 40);
    if (!v7)
    {
LABEL_66:
      uint64_t v36 = 0LL;
      while (1)
      {
        char v37 = v36 + 1;
        unsigned int v38 = (v36 + 1);
        uint64_t v39 = *(void *)(v3 + 40);
        else {
          uint64_t v40 = 0LL;
        }
        uint64_t v41 = *v6;
        if (*v6 && ((*(_DWORD *)(v41 + 8) >> v37) & 1) != 0 && *(unsigned __int8 *)(v41 + 12) >= v38)
        {
          uint64_t v42 = *(void *)(*(void *)v41 + 8 * v36);
          if (v40)
          {
LABEL_75:
            uint64_t result = __CFCharacterSetEqual(v40, v42);
            if (!(_DWORD)result) {
              return result;
            }
          }
        }

        else
        {
          uint64_t v42 = 0LL;
          if (v40) {
            goto LABEL_75;
          }
        }

        if (++v36 == 16) {
          return 1LL;
        }
      }
    }

    int v8 = *(unsigned __int8 *)(v7 + 13);
    if (!*(_BYTE *)(v7 + 13)) {
      goto LABEL_63;
    }
    goto LABEL_9;
  }

  uint64_t v6 = (uint64_t *)(v2 + 40);
  uint64_t v5 = *(void *)(v2 + 40);
  if (!v5)
  {
    if (!*(_BYTE *)(v4 + 13))
    {
      uint64_t v7 = 0LL;
      goto LABEL_62;
    }

    goto LABEL_9;
  }

  uint64_t v7 = *(void *)(v2 + 40);
  if ((*(_BYTE *)(v4 + 13) != 0) != (*(_BYTE *)(v5 + 13) != 0))
  {
LABEL_9:
    uint64_t v9 = 1LL;
    while (1)
    {
      uint64_t v10 = *(void *)(v3 + 40);
      if (v10
        && ((*(_DWORD *)(v10 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v10 + 12) >= v9)
      {
        uint64_t v11 = *(void *)(*(void *)v10 + 8 * v9 - 8);
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      uint64_t v12 = *v6;
      if (*v6
        && ((*(_DWORD *)(v12 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v12 + 12) >= v9)
      {
        uint64_t v13 = *(void *)(*(void *)v12 + 8 * v9 - 8);
      }

      else
      {
        uint64_t v13 = 0LL;
      }

      if (!(v11 | v13)) {
        return 0LL;
      }
      if (v11)
      {
        char v14 = atomic_load((unint64_t *)(v11 + 8));
        uint64_t v15 = v14 & 0x70;
        if (v13)
        {
          char v16 = atomic_load((unint64_t *)(v13 + 8));
          uint64_t v17 = v16 & 0x70;
          if (v15 == 48 && v17 == 48)
          {
            for (uint64_t i = 0LL; i != 0x2000; i += 4LL)
            {
              int v19 = *(_DWORD *)(*(void *)(v11 + 24) + i);
              int v20 = ~*(_DWORD *)(*(void *)(v13 + 24) + i);
              if (v19 != v20) {
                return 0LL;
              }
            }
          }

          else if (v15 == 48 || v17 == 48)
          {
            BOOL v30 = v17 == 48;
            if (v17 == 48) {
              uint64_t v31 = v11;
            }
            else {
              uint64_t v31 = v13;
            }
            if (!v30) {
              uint64_t v13 = v11;
            }
            __CFCSetGetBitmap(v31, v45);
            for (uint64_t j = 0LL; j != 2048; ++j)
            {
              int v33 = *(_DWORD *)(*(void *)(v13 + 24) + j * 4);
              __int32 v34 = ~v45[0].i32[j];
              if (v33 != v34) {
                return 0LL;
              }
            }
          }

          else
          {
            __CFCSetGetBitmap(v11, v45);
            __CFCSetGetBitmap(v13, __b);
            for (uint64_t k = 0LL; k != 2048; ++k)
            {
              __int32 v24 = v45[0].i32[k];
              __int32 v25 = ~__b[0].i32[k];
              if (v24 != v25) {
                return 0LL;
              }
            }
          }
        }

        else
        {
          if (v15 == 48)
          {
            uint64_t v22 = *(void *)(v11 + 24);
LABEL_31:
            goto LABEL_32;
          }

          __CFCSetGetBitmap(v11, v45);
          if (v45 != (int8x16_t *)-1LL)
          {
            for (uint64_t m = 0LL; m != 2048; ++m)
            {
              __int32 v29 = v45[0].i32[m];
              if (v29 != -1) {
                return 0LL;
              }
            }
          }
        }
      }

      else
      {
        char v21 = atomic_load((unint64_t *)(v13 + 8));
        if ((v21 & 0x70) == 0x30LL)
        {
          uint64_t v22 = *(void *)(v13 + 24);
          goto LABEL_31;
        }

        __CFCSetGetBitmap(v13, v45);
        if (v45 != (int8x16_t *)-1LL)
        {
          for (uint64_t n = 0LL; n != 2048; ++n)
          {
            __int32 v27 = v45[0].i32[n];
            if (v27 != -1) {
              return 0LL;
            }
          }
        }
      }

LABEL_62:
  int v8 = *(_DWORD *)(v4 + 8);
  if (v5)
  {
LABEL_63:
    int v35 = *(_DWORD *)(v7 + 8);
    goto LABEL_65;
  }

  int v35 = 0;
LABEL_65:
  if (v8 == v35) {
    goto LABEL_66;
  }
  return 0LL;
}

  if (v11)
  {
    CFDateFormatterSetFormat(CFDateFormatter, v11);
    CFRelease(v11);
  }

    unsigned int v49 = CFArrayCreateMutableCopy(0LL, 0LL, Copy);
    CFRelease(Copy);
    CFArrayAppendValue(v49, v24);
    return v49;
  }

  __int32 v29 = CFGetAllocator(a1);
  if (!v24) {
    return CFArrayCreate(v29, 0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  return CFArrayCreate(v29, v50, 1LL, &kCFTypeArrayCallBacks);
}

    a4 = v14 < 0x200;
    if (v14 >= 0x200) {
      __int32 v34 = v14 >> 1;
    }
    else {
      __int32 v34 = v31 + 1;
    }
    int v35 = v34 + 1;
    if (v34 + 1 < 0x3F0)
    {
      char v37 = (int8x16_t *)v112;
    }

    else
    {
      uint64_t v36 = (int8x16_t *)CFAllocatorAllocate((CFAllocatorRef)v16, v34 + 1, 0LL);
      char v37 = v36;
      if (__CFOASafe)
      {
        int v101 = v36;
        __CFSetLastAllocationEventName();
        char v37 = v101;
      }

      if (!v37)
      {
        LODWORD(a4) = 256;
        char v14 = v35;
        goto LABEL_109;
      }
    }

    uint64_t v44 = v37;
    if (v14 > 0x1FF || (v37->i8[0] = v31, uint64_t v44 = (int8x16_t *)&v37->i8[1], v14 >= 2))
    {
      CFRange v45 = 0LL;
      if (v31 <= 1) {
        uint64_t v46 = 1LL;
      }
      else {
        uint64_t v46 = v14 >> 1;
      }
      do
      {
        v44->i8[v45] = ptr->i16[v45];
        ++v45;
      }

      while (v46 != v45);
    }

    v44->i8[v31] = 0;
    if (v102 && v18 != (const __CFAllocator *)&__kCFAllocatorNull)
    {
      CFIndex v47 = v37;
      CFAllocatorDeallocate(v18, ptr);
      char v37 = v47;
    }

    uint64_t v105 = v35 > 0x3EF;
    char v14 = v31 + a4;
    unint64_t v48 = &v37->u8[a4];
    LODWORD(v8) = a4;
    LODWORD(a4) = 1536;
    uint64_t v18 = (const __CFAllocator *)v16;
    unint64_t v103 = v8;
    char v104 = 1;
    goto LABEL_111;
  }

    int v43 = [a3 decodeInt64ForKey:@"NS.count"];
    uint64_t v44 = v43;
    if ((v43 & 0x8000000000000000LL) != 0)
    {
      CFIndex v47 = __CFExceptionProem((objc_class *)self, a2);
      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@: negative count", v47);
      uint64_t v46 = _CFAutoreleasePoolAddObject();
      if ([a3 decodingFailurePolicy] == 1) {
    }
      }

    else
    {
      if (!v43) {
        goto LABEL_12;
      }
      if (v43 < 0x1000001)
      {
        if ((&self->super.super.super.isa)[v83 / 8])
        {
          unint64_t v48 = [v25 setByAddingObject:v21];
          unsigned int v49 = (void *)[a3 decodeObjectOfClasses:v48 forKey:@"NS.keys"];
          uint64_t v50 = [a3 decodeObjectOfClasses:v48 forKey:@"NS.values"];
          else {
            char v51 = 0LL;
          }
          uint64_t v52 = [v49 count];
          uint64_t v53 = [v51 count];
          if (v52 && v53)
          {
            if (v52 == v53)
            {
              if (v52 == v44)
              {
                int v82 = &v77;
                char v55 = MEMORY[0x1895F8858](v53, v54);
                char v58 = (char *)&v77 - v57;
                if (v44 > 0x100)
                {
                  char v58 = (char *)_CFCreateArrayStorage(v44, 0, &v85);
                  MEMORY[0x1895F8858](v58, v69);
                  unint64_t v60 = &v76;
                  unint64_t v61 = _CFCreateArrayStorage(v44, 0, &v84);
                  uint64_t v81 = v58;
                }

                else
                {
                  MEMORY[0x1895F8858](v55, v56);
                  unint64_t v60 = (uint64_t *)((char *)&v77 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0LL));
                  uint64_t v81 = 0LL;
                  unint64_t v61 = 0LL;
                }

                uint64_t v79 = v51;
                int64_t v80 = v61;
                if (v44 >= 0x101) {
                  unint64_t v60 = (uint64_t *)v61;
                }
                objc_msgSend(v49, "getObjects:range:", v58, 0, v44);
                int v78 = v58;
                unint64_t v70 = v44;
                do
                {
                  if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_isKindOfClass() & 1) != 0)
                  {
                    unint64_t v73 = objc_opt_class();
                    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"unexpected recursive keys (%@)",  v73);
                    unint64_t v74 = _CFAutoreleasePoolAddObject();
                    if ([a3 decodingFailurePolicy] == 1) {

                    }
                    goto LABEL_112;
                  }

                  v58 += 8;
                  --v70;
                }

                while (v70);
                objc_msgSend(v79, "getObjects:range:", v60, 0, v44);
                int v71 = v78;
                while (1)
                {
                  unint64_t v72 = *(void *)v71;
                  if (((uint64_t (*)(Class, char *, void))self->_ifkIMP)( (&self->super.super.super.isa)[v83 / 8],  sel_indexForKey_,  *(void *)v71) == 0x7FFFFFFFFFFFFFFFLL) {
                    break;
                  }
                  -[NSSharedKeyDictionary setObject:forKey:](self, "setObject:forKey:", *v60++, v72);
                  v71 += 8;
                  if (!--v44)
                  {
                    free(v80);
                    free(v81);
                    goto LABEL_12;
                  }
                }

                unint64_t v75 = __CFExceptionProem((objc_class *)self, a2);
                CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: encoded key not present in keyset",  v75);
                unint64_t v74 = _CFAutoreleasePoolAddObject();
                if ([a3 decodingFailurePolicy] == 1) {

                }
LABEL_112:
                [a3 failWithError:__archiveIsCorrupt(v74)];
                free(v80);
                int v65 = v81;
                goto LABEL_89;
              }

              int v68 = __CFExceptionProem((objc_class *)self, a2);
              CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: more entries than expected",  v68);
              uint64_t v46 = _CFAutoreleasePoolAddObject();
              if ([a3 decodingFailurePolicy] == 1) {
            }
              }

            else
            {
              unint64_t v67 = __CFExceptionProem((objc_class *)self, a2);
              CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: encoded keys/values length does not match",  v67);
              uint64_t v46 = _CFAutoreleasePoolAddObject();
              if ([a3 decodingFailurePolicy] == 1) {
            }
              }
          }

          else
          {
            unint64_t v66 = __CFExceptionProem((objc_class *)self, a2);
            CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: encoded keys/values are empty",  v66);
            uint64_t v46 = _CFAutoreleasePoolAddObject();
            if ([a3 decodingFailurePolicy] == 1) {
          }
            }
        }

        else
        {
          int v62 = __CFExceptionProem((objc_class *)self, a2);
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: invalid archive (encoded count but missing keyset)",  v62);
          uint64_t v46 = _CFAutoreleasePoolAddObject();
          if ([a3 decodingFailurePolicy] == 1) {
        }
          }
      }

      else
      {
        CFRange v45 = __CFExceptionProem((objc_class *)self, a2);
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: unreasonably sized collection",  v45);
        uint64_t v46 = _CFAutoreleasePoolAddObject();
        if ([a3 decodingFailurePolicy] == 1) {
      }
        }
    }

    [a3 failWithError:__archiveIsCorrupt(v46)];
    goto LABEL_11;
  }

  uint64_t v13 = __CFExceptionProem((objc_class *)self, a2);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: invalid archive (unexpected keyset: %@)",  v13,  v12);
  char v14 = _CFAutoreleasePoolAddObject();
  if ([a3 decodingFailurePolicy] == 1) {

  }
LABEL_10:
  [a3 failWithError:__archiveIsCorrupt(v14)];
LABEL_11:
  self = 0LL;
LABEL_12:
  cleanup_sentinel_pair((uint64_t)&v87);
  cleanup_sentinel_pair((uint64_t)&v90);
  return self;
}

    BOOL v30 = 0LL;
    goto LABEL_63;
  }

  if (v6) {
    CFRelease(v6);
  }
  uint64_t v18 = createErrorReply("Domain not found", a2);
  (*(void (**)(uint64_t, xpc_object_t))(a3 + 16))(a3, v18);
  xpc_release(v18);
  xpc_release(a2);
}

uint64_t __CFCSetIsBitmapEqualToRange(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if ((a3 ^ a2) <= 7)
  {
    if (a4) {
      unsigned int v4 = ~(((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18));
    }
    else {
      unsigned int v4 = ((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18);
    }
    uint64_t v5 = a2 >> 5;
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
    if (*(_DWORD *)(a1 + 4LL * v5) == v4)
    {
      uint64_t v7 = a2 >> 5;
      goto LABEL_26;
    }

    return 0LL;
  }

  unsigned int v8 = ((255 << (a2 & 7)) << (a2 & 0x18 ^ 0x18)) | (0xFFFFFFu >> (a2 & 0x18));
  unsigned int v9 = (0xFFu >> (~(_BYTE)a3 & 7) << (a3 & 0x18 ^ 0x18)) | (0xFFFFFFFFLL << (32 - (a3 & 0x18)));
  uint64_t v5 = a2 >> 5;
  uint64_t v7 = a3 >> 5;
  if ((_DWORD)v5 == a3 >> 5)
  {
    unsigned int v10 = bswap32(v9 & v8);
    if (a4) {
      unsigned int v11 = ~v10;
    }
    else {
      unsigned int v11 = v10;
    }
    int v12 = *(_DWORD *)(a1 + 4 * v5);
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
  }

  else
  {
    unsigned int v13 = bswap32(v8);
    if (a4) {
      int v14 = ~v13;
    }
    else {
      int v14 = v13;
    }
    if (a4) {
      int v6 = -1;
    }
    else {
      int v6 = 0;
    }
    if (*(_DWORD *)(a1 + 4 * v5) != v14) {
      return 0LL;
    }
    int v12 = *(_DWORD *)(a1 + 4 * v7);
    unsigned int v11 = bswap32(v9) ^ v6;
  }

  if (v12 != v11) {
    return 0LL;
  }
LABEL_26:
  uint64_t v15 = 0LL;
  while (v5 != v15)
  {
    int v16 = *(_DWORD *)(a1 + 4 * v15++);
    if (v16 != v6) {
      return 0LL;
    }
  }

  uint64_t v17 = v7 + ~v5;
  if (a4) {
    int v18 = 0;
  }
  else {
    int v18 = -1;
  }
  int v19 = (int *)(4 * v5 + a1 + 4);
  while (v17-- >= 1)
  {
    int v21 = *v19++;
    if (v21 != v18) {
      return 0LL;
    }
  }

  if (v5 == v7) {
    uint64_t v22 = v19;
  }
  else {
    uint64_t v22 = v19 + 1;
  }
  for (uint64_t i = v7 - 2047; i; ++i)
  {
    int v24 = *v22++;
    if (v24 != v6) {
      return 0LL;
    }
  }

  return 1LL;
}

ssize_t fdRead(int a1, void *a2, size_t a3, uint64_t a4, BOOL *a5)
{
  ssize_t result = read(a1, a2, a3);
  if (result < 0)
  {
    int v8 = *__error();
    *(void *)a4 = 1LL;
    ssize_t result = -1LL;
  }

  else
  {
    int v8 = 0;
    *a5 = result == 0;
  }

  *(_DWORD *)(a4 + 8) = v8;
  return result;
}

BOOL fdCanRead(int a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1 > 1023)
  {
    unsigned int v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0) {
      ++v3;
    }
    size_t v4 = 4 * v3;
    uint64_t v2 = malloc(v4);
    bzero(v2, v4);
  }

  else
  {
    uint64_t v2 = v7;
    memset(v7, 0, sizeof(v7));
  }

  if (__darwin_check_fd_set_overflow(a1, v2, 1)) {
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  int v5 = select_DARWIN_EXTSN();
  if (v2 != v7) {
    free(v2);
  }
  return v5 == 1;
}

ssize_t fdWrite(int a1, const void *a2, size_t a3, uint64_t a4)
{
  ssize_t result = write(a1, a2, a3);
  if (result < 0)
  {
    int v6 = *__error();
    *(void *)a4 = 1LL;
    ssize_t result = -1LL;
  }

  else
  {
    int v6 = 0;
  }

  *(_DWORD *)(a4 + 8) = v6;
  return result;
}

BOOL fdCanWrite(int a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1 > 1023)
  {
    unsigned int v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0) {
      ++v3;
    }
    size_t v4 = 4 * v3;
    uint64_t v2 = malloc(v4);
    bzero(v2, v4);
  }

  else
  {
    uint64_t v2 = v7;
    memset(v7, 0, sizeof(v7));
  }

  if (__darwin_check_fd_set_overflow(a1, v2, 1)) {
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  }
  int v5 = select_DARWIN_EXTSN();
  if (v2 != v7) {
    free(v2);
  }
  return v5 == 1;
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)_CFStreamCreateWithFile(alloc, fileURL, 1LL);
}

CFStringRef _CFStreamCreateWithFile(const __CFAllocator *a1, CFURLRef anURL, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!anURL) {
    return 0LL;
  }
  CFStringRef result = CFURLCopyScheme(anURL);
  if (!result) {
    return result;
  }
  CFStringRef v7 = result;
  int v8 = CFEqual(result, @"file");
  CFRelease(v7);
  if (!v8) {
    return 0LL;
  }
  CFURLRef v13 = anURL;
  int v14 = -1;
  return (CFStringRef)_CFStreamCreateWithConstantCallbacks(a1, (uint64_t)&v13, fileCallBacks, a3, v9, v10, v11, v12);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)_CFStreamCreateWithFile(alloc, fileURL, 0LL);
}

uint64_t _CFReadStreamCreateFromFileDescriptor( const __CFAllocator *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  int v10 = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)&v9, fileCallBacks, 1LL, a5, a6, a7, a8);
}

uint64_t _CFWriteStreamCreateFromFileDescriptor( const __CFAllocator *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  int v10 = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)&v9, fileCallBacks, 0LL, a5, a6, a7, a8);
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy( CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  cf[3] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  cf[0] = CFDataCreateWithBytesNoCopy(alloc, bytes, length, bytesDeallocator);
  uint64_t v9 = (__CFReadStream *)_CFStreamCreateWithConstantCallbacks( alloc,  (uint64_t)cf,  readDataCallBacks,  1LL,  v5,  v6,  v7,  v8);
  CFRelease(cf[0]);
  return v9;
}

uint64_t CFReadStreamCreateWithData(const __CFAllocator *a1, const __CFData *a2)
{
  v10[3] = *MEMORY[0x1895F89C0];
  CFDataRef Copy = CFDataCreateCopy(a1, a2);
  v10[0] = Copy;
  uint64_t v8 = _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)v10, readDataCallBacks, 1LL, v4, v5, v6, v7);
  CFRelease(Copy);
  return v8;
}

CFWriteStreamRef CFWriteStreamCreateWithBuffer(CFAllocatorRef alloc, UInt8 *buffer, CFIndex bufferCapacity)
{
  v9[4] = *MEMORY[0x1895F89C0];
  v8[0] = buffer;
  v8[1] = bufferCapacity;
  v8[2] = 0LL;
  v8[3] = 0LL;
  v9[0] = v8;
  v9[1] = v8;
  v9[2] = &__kCFAllocatorNull;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks( alloc,  (uint64_t)v9,  writeDataCallBacks,  0LL,  v3,  v4,  v5,  v6);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  v7[4] = *MEMORY[0x1895F89C0];
  v7[0] = 0LL;
  v7[1] = 0LL;
  void v7[2] = bufferAllocator;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks( alloc,  (uint64_t)v7,  writeDataCallBacks,  0LL,  v2,  v3,  v4,  v5);
}

_DWORD *fileCreate(const void *a1, uint64_t a2)
{
  uint64_t v3 = CFGetAllocator(a1);
  uint64_t v4 = CFAllocatorAllocate(v3, 40LL, 0LL);
  if (v4)
  {
    uint64_t v5 = *(const void **)a2;
    *(void *)uint64_t v4 = *(void *)a2;
    if (v5) {
      CFRetain(v5);
    }
    void v4[2] = *(_DWORD *)(a2 + 8);
    *((void *)v4 + 2) = 0LL;
    *((void *)v4 + 3) = 0LL;
    *((void *)v4 + 4) = -1LL;
  }

  return v4;
}

void fileFinalize(const void *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  if (v4 < 1)
  {
    if (v5) {
      CFRelease(*(CFTypeRef *)(a2 + 16));
    }
  }

  else
  {
    if (v5)
    {
      CFFileDescriptorInvalidate(*(CFFileDescriptorRef *)(a2 + 16));
      CFRelease(*(CFTypeRef *)(a2 + 16));
      *(void *)(a2 + 16) = 0LL;
      int v4 = *(_DWORD *)(a2 + 8);
    }

    close(v4);
  }

  if (*(void *)a2) {
    CFRelease(*(CFTypeRef *)a2);
  }
  uint64_t v6 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v6, (void *)a2);
}

CFStringRef fileCopyDescription(const void *a1, uint64_t a2)
{
  if (*(void *)a2) {
    return CFCopyDescription(*(CFTypeRef *)a2);
  }
  int v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, 0LL, @"fd = %d", *(unsigned int *)(a2 + 8));
}

uint64_t fileOpen(void *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  CFTypeID v8 = CFGetTypeID(a1);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  BOOL v10 = v8 == TypeID;
  *a3 = 1;
  if (!*(void *)a4)
  {
    if (*(void *)(a4 + 16)) {
      constructCFFD(a4, v10, a1);
    }
    return 1LL;
  }

  if (!CFURLGetFileSystemRepresentation(*(CFURLRef *)a4, 1u, buffer, 1026LL))
  {
    int v14 = 2;
    goto LABEL_19;
  }

  if (v8 == TypeID) {
    int v11 = 0;
  }
  else {
    int v11 = 1537;
  }
  if ((*(void *)(a4 + 24) & 8LL) != 0) {
    int v12 = open((const char *)buffer, v11 & 0x3F7 | 8, 438LL);
  }
  else {
    int v12 = open((const char *)buffer, v11, 438LL);
  }
  *(_DWORD *)(a4 + 8) = v12;
  if ((v12 & 0x80000000) == 0)
  {
    off_t v13 = *(void *)(a4 + 32);
  }

  *(void *)(a4 + 24) |= 0x20uLL;
  int v14 = *__error();
LABEL_19:
  uint64_t result = 0LL;
  *(_DWORD *)(a2 + 8) = v14;
  *(void *)a2 = 1LL;
  return result;
}

ssize_t fileRead(uint64_t a1, void *a2, size_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  ssize_t v8 = fdRead(*(_DWORD *)(a6 + 8), a2, a3, a4, a5);
  uint64_t v9 = *(void *)(a6 + 24);
  if ((v9 & 2) != 0)
  {
    *(void *)(a6 + 24) = v9 & 0xFFFFFFFFFFFFFFFDLL;
    if (!*a5)
    {
      if (*(void *)(a6 + 16))
      {
        if ((fstat(*(_DWORD *)(a6 + 8), &v13) & 0x80000000) == 0 && (v13.st_mode & 0xF000) == 0x8000)
        {
          off_t v12 = lseek(*(_DWORD *)(a6 + 8), 0LL, 1);
          if (v13.st_size == v12) {
            _CFFileDescriptorInduceFakeReadCallBack(*(void *)(a6 + 16));
          }
        }
      }
    }

    BOOL v10 = *(__CFFileDescriptor **)(a6 + 16);
    if (v10) {
      CFFileDescriptorEnableCallBacks(v10, 1uLL);
    }
  }

  return v8;
}

BOOL fileCanRead(uint64_t a1, uint64_t a2)
{
  return fdCanRead(*(_DWORD *)(a2 + 8));
}

ssize_t fileWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  ssize_t v6 = fdWrite(*(_DWORD *)(a5 + 8), a2, a3, a4);
  uint64_t v7 = *(void *)(a5 + 24);
  if ((v7 & 1) != 0)
  {
    *(void *)(a5 + 24) = v7 & 0xFFFFFFFFFFFFFFFELL;
    ssize_t v8 = *(__CFFileDescriptor **)(a5 + 16);
    if (v8) {
      CFFileDescriptorEnableCallBacks(v8, 2uLL);
    }
  }

  return v6;
}

BOOL fileCanWrite(uint64_t a1, uint64_t a2)
{
  return fdCanWrite(*(_DWORD *)(a2 + 8));
}

void fileClose(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 < 0)
  {
    uint64_t v5 = (const void **)(a2 + 16);
    uint64_t v7 = *(const void **)(a2 + 16);
    if (!v7) {
      return;
    }
  }

  else
  {
    close(v3);
    ssize_t v6 = *(__CFFileDescriptor **)(a2 + 16);
    uint64_t v5 = (const void **)(a2 + 16);
    int v4 = v6;
    *((_DWORD *)v5 - 2) = -1;
    if (!v6) {
      return;
    }
    CFFileDescriptorInvalidate(v4);
    uint64_t v7 = *v5;
  }

  CFRelease(v7);
  *uint64_t v5 = 0LL;
}

CFDataRef fileCopyProperty(const void *a1, CFTypeRef cf1, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (CFEqual(cf1, @"kCFStreamPropertyFileCurrentOffset"))
  {
    if ((*(_BYTE *)(a3 + 24) & 8) == 0)
    {
      int v6 = *(_DWORD *)(a3 + 8);
      if (v6 != -1) {
        *(void *)(a3 + 32) = lseek(v6, 0LL, 1);
      }
    }

    uint64_t v8 = *(void *)(a3 + 32);
    uint64_t v7 = (const void *)(a3 + 32);
    if (v8 != -1)
    {
      uint64_t v9 = CFGetAllocator(a1);
      return CFNumberCreate(v9, kCFNumberSInt64Type, v7);
    }
  }

  else if (CFEqual(cf1, @"_kCFStreamPropertyFileNativeHandle"))
  {
    *(_DWORD *)bytes = *(_DWORD *)(a3 + 8);
    if (*(_DWORD *)bytes != -1)
    {
      int v11 = CFGetAllocator(a1);
      return CFDataCreate(v11, bytes, 4LL);
    }
  }

  return 0LL;
}

uint64_t fileSetProperty(void *a1, CFTypeRef cf1, __objc2_class **a3, uint64_t a4)
{
  if (CFEqual(cf1, @"kCFStreamPropertyAppendToFile")
    && (CFTypeID v8 = CFGetTypeID(a1), v8 == CFWriteStreamGetTypeID())
    && CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusNotOpen)
  {
    uint64_t v11 = *(void *)(a4 + 24);
    if (&__kCFBooleanTrue == a3)
    {
      *(void *)(a4 + 24) = v11 | 8;
      *(void *)(a4 + 32) = -1LL;
    }

    else
    {
      *(void *)(a4 + 24) = v11 & 0xFFFFFFFFFFFFFFF7LL;
    }

    return 1LL;
  }

  else if (CFEqual(cf1, @"kCFStreamPropertyFileCurrentOffset"))
  {
    if ((*(_BYTE *)(a4 + 24) & 8) != 0) {
      uint64_t Value = 0LL;
    }
    else {
      uint64_t Value = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, (void *)(a4 + 32));
    }
    int v10 = *(_DWORD *)(a4 + 8);
    if (v10 != -1)
    {
      if (lseek(v10, *(void *)(a4 + 32), 0) == -1) {
        return 0LL;
      }
      else {
        return Value;
      }
    }
  }

  else
  {
    return 0LL;
  }

  return Value;
}

void fileSchedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  BOOL v9 = v8 == CFReadStreamGetTypeID();
  int v10 = v9;
  if (v9) {
    CFStreamStatus Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  }
  else {
    CFStreamStatus Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  }
  if ((*(_DWORD *)(a4 + 8) & 0x80000000) == 0 || Status == kCFStreamStatusNotOpen)
  {
    CFMutableCharacterSetRef Mutable = *(__CFArray **)(a4 + 16);
    if (Status)
    {
      if (!Mutable) {
        constructCFFD(a4, v10, a1);
      }
      uint64_t v13 = CFGetAllocator(a1);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v13, *(CFFileDescriptorRef *)(a4 + 16), 0LL);
      CFRunLoopAddSource(a2, RunLoopSource, a3);
      CFRelease(RunLoopSource);
    }

    else
    {
      if (!Mutable)
      {
        uint64_t v15 = CFGetAllocator(a1);
        CFMutableCharacterSetRef Mutable = CFArrayCreateMutable(v15, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(a4 + 16) = Mutable;
      }

      CFArrayAppendValue(Mutable, a2);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a4 + 16), a3);
    }
  }

void fileUnschedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8 = CFGetTypeID(a1);
  if (v8 == CFReadStreamGetTypeID()) {
    CFStreamStatus Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  }
  else {
    CFStreamStatus Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  }
  int v10 = *(const __CFArray **)(a4 + 16);
  if (Status)
  {
    if (v10)
    {
      if ((*(_BYTE *)(a4 + 24) & 0x20) == 0)
      {
        uint64_t v11 = CFGetAllocator(a1);
        RunLoopSource = CFFileDescriptorCreateRunLoopSource(v11, *(CFFileDescriptorRef *)(a4 + 16), 0LL);
        CFRunLoopRemoveSource(a2, RunLoopSource, a3);
        CFRelease(RunLoopSource);
        return;
      }

      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
      if (Count >= 2)
      {
        CFIndex v20 = Count;
        CFIndex v21 = 1LL;
        while (1)
        {
          CFIndex v16 = v21 - 1;
          ValueAtIndex = CFArrayGetValueAtIndex(v10, v21 - 1);
          if (CFEqual(ValueAtIndex, a2))
          {
            uint64_t v23 = CFArrayGetValueAtIndex(v10, v21);
            if (CFEqual(v23, a3)) {
              break;
            }
          }

          v21 += 2LL;
          if (v21 >= v20) {
            return;
          }
        }

uint64_t constructCFFD(uint64_t a1, int a2, void *cf)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  v18.CFIndex version = 0LL;
  v18.info = cf;
  v18.CFAllocatorRetainCallBack retain = (void *(__cdecl *)(void *))_fs_retain;
  v18.CFArrayReleaseCallBack release = (void (__cdecl *)(void *))_fs_release;
  v18.copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(void *))CFCopyDescription;
  int v6 = CFGetAllocator(cf);
  uint64_t v7 = CFFileDescriptorCreate(v6, *(_DWORD *)(a1 + 8), 0, (CFFileDescriptorCallBack)fileCallBack, &v18);
  if (v7)
  {
    CFTypeID v8 = v7;
    if (a2) {
      CFOptionFlags v9 = 1LL;
    }
    else {
      CFOptionFlags v9 = 2LL;
    }
    CFFileDescriptorEnableCallBacks(v7, v9);
    int v10 = *(const __CFArray **)(a1 + 16);
    if (v10)
    {
      CFIndex Count = CFArrayGetCount(v10);
      off_t v12 = CFGetAllocator(cf);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v12, v8, 0LL);
      if (Count >= 2)
      {
        for (CFIndex i = 1LL; i < Count; i += 2LL)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i - 1);
          CFIndex v16 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i);
          CFRunLoopAddSource(ValueAtIndex, RunLoopSource, v16);
        }
      }

      CFRelease(*(CFTypeRef *)(a1 + 16));
      CFRelease(RunLoopSource);
    }

    *(void *)(a1 + 16) = v8;
    return 1LL;
  }

  else
  {
    uint64_t result = *(void *)(a1 + 16);
    if (result)
    {
      CFRelease((CFTypeRef)result);
      uint64_t result = 0LL;
      *(void *)(a1 + 16) = 0LL;
    }
  }

  return result;
}

CFTypeRef _fs_retain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void _fs_release(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void fileCallBack(int a1, uint64_t a2, void *cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFReadStreamGetTypeID())
    {
      uint64_t InfoPointer = CFReadStreamGetInfoPointer((uint64_t)cf);
    }

    else
    {
      uint64_t InfoPointer = CFWriteStreamGetInfoPointer((uint64_t)cf);
    }

    uint64_t v12 = *(void *)(InfoPointer + 24);
    if (a2 == 2)
    {
      *(void *)(InfoPointer + 24) = v12 | 1;
      CFWriteStreamSignalEvent((char *)cf, 4uLL, 0LL, v7, v8, v9, v10, v11);
    }

    else
    {
      *(void *)(InfoPointer + 24) = v12 | 2;
      CFReadStreamSignalEvent((char *)cf, 2uLL, 0LL, v7, v8, v9, v10, v11);
    }
  }

void *readDataCreate(const void *a1, CFTypeRef *a2)
{
  int v3 = CFGetAllocator(a1);
  int v4 = CFAllocatorAllocate(v3, 24LL, 0LL);
  if (v4)
  {
    CFTypeID v5 = (const __CFData *)CFRetain(*a2);
    *int v4 = v5;
    v4[1] = CFDataGetBytePtr(v5);
    *((_BYTE *)v4 + 16) = 0;
  }

  return v4;
}

void readDataFinalize(const void *a1, CFTypeRef *a2)
{
  int v4 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v4, a2);
}

CFStringRef readDataCopyDescription(uint64_t a1, CFTypeRef *a2)
{
  return CFCopyDescription(*a2);
}

uint64_t readDataOpen(char *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  if (*(_BYTE *)(a4 + 16))
  {
    if (CFDataGetLength(*(CFDataRef *)a4)) {
      unint64_t v12 = 2LL;
    }
    else {
      unint64_t v12 = 16LL;
    }
    CFReadStreamSignalEvent(a1, v12, 0LL, v7, v8, v9, v10, v11);
  }

  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1LL;
}

uint64_t dataRead(char *a1, void *a2, uint64_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  CFFileDescriptorContext v18 = &BytePtr[CFDataGetLength(*(CFDataRef *)a6)];
  uint64_t v19 = *(const UInt8 **)(a6 + 8);
  uint64_t v20 = v18 - v19;
  if (v18 - v19 >= a3) {
    uint64_t v20 = a3;
  }
  uint64_t v21 = v20 & ~(v20 >> 63);
  if (v20 >= 1)
  {
    memmove(a2, v19, v20 & ~(v20 >> 63));
    uint64_t v19 = (const UInt8 *)(*(void *)(a6 + 8) + v21);
    *(void *)(a6 + 8) = v19;
  }

  *(_DWORD *)(a4 + 8) = 0;
  *a5 = v19 >= v18;
  if (*(_BYTE *)(a6 + 16) && v19 < v18) {
    CFReadStreamSignalEvent(a1, 2uLL, 0LL, v13, v14, v15, v16, v17);
  }
  return v21;
}

uint64_t dataGetBuffer(char *a1, CFIndex a2, CFIndex *a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  CFIndex v18 = (CFIndex)&BytePtr[CFDataGetLength(*(CFDataRef *)a6) - *(void *)(a6 + 8)];
  BOOL v19 = v18 <= a2;
  if (v18 >= a2) {
    CFIndex v18 = a2;
  }
  *a3 = v18;
  *a5 = v19;
  *(_DWORD *)(a4 + 8) = 0;
  uint64_t v20 = *(void *)(a6 + 8);
  *(void *)(a6 + 8) = v20 + *a3;
  if (*(_BYTE *)(a6 + 16) && !*a5) {
    CFReadStreamSignalEvent(a1, 2uLL, 0LL, v13, v14, v15, v16, v17);
  }
  return v20;
}

BOOL dataCanRead(uint64_t a1, uint64_t a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a2);
  return (unint64_t)&BytePtr[CFDataGetLength(*(CFDataRef *)a2)] > *(void *)(a2 + 8);
}

void readDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(_BYTE *)(a4 + 16))
  {
    *(_BYTE *)(a4 + 16) = 1;
    if (CFReadStreamGetStatus((CFReadStreamRef)a1) == kCFStreamStatusOpen)
    {
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)a4);
      else {
        unint64_t v12 = 2LL;
      }
      CFReadStreamSignalEvent(a1, v12, 0LL, v7, v8, v9, v10, v11);
    }
  }

void *writeDataCreate(CFTypeRef cf, void *a2)
{
  CFAllocatorRef Default = (CFAllocatorRef)a2[2];
  if (Default == (CFAllocatorRef)&__kCFAllocatorNull)
  {
    uint64_t v7 = CFGetAllocator(cf);
    uint64_t result = CFAllocatorAllocate(v7, 64LL, 0LL);
    *uint64_t result = result + 4;
    uint64_t v8 = *(void *)(*a2 + 8LL);
    result[4] = *(void *)*a2;
    result[5] = v8;
    result[6] = 0LL;
    result[7] = 0LL;
    result[1] = result + 4;
  }

  else
  {
    if (!Default)
    {
      CFAllocatorRef Default = CFAllocatorGetDefault();
      a2[2] = Default;
    }

    CFRetain(Default);
    CFTypeID v5 = CFGetAllocator(cf);
    uint64_t result = CFAllocatorAllocate(v5, 1088LL, 0LL);
    result[4] = result + 8;
    result[6] = 0LL;
    result[7] = 0LL;
    result[5] = 1024LL;
    *uint64_t result = result + 4;
    result[1] = result + 4;
    CFAllocatorRef Default = (CFAllocatorRef)a2[2];
  }

  result[2] = Default;
  *((_BYTE *)result + 24) = 0;
  return result;
}

void writeDataFinalize(CFTypeRef cf, CFAllocatorRef *a2)
{
  int v4 = (__objc2_class **)a2[2];
  if (v4 != &__kCFAllocatorNull)
  {
    CFTypeID v5 = (void *)*((void *)*a2 + 3);
    if (v5)
    {
      do
      {
        int v6 = (void *)v5[3];
        CFAllocatorDeallocate(a2[2], v5);
        CFTypeID v5 = v6;
      }

      while (v6);
      int v4 = (__objc2_class **)a2[2];
    }

    CFRelease(v4);
  }

  uint64_t v7 = CFGetAllocator(cf);
  CFAllocatorDeallocate(v7, a2);
}

CFStringRef writeDataCopyDescription(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFWriteDataContext %p>",  a2);
}

uint64_t writeDataOpen( char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)(a4 + 24))
  {
    if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
    {
      if (*(void *)(*(void *)(a4 + 8) + 8LL) <= *(void *)(*(void *)(a4 + 8) + 16LL)) {
        unint64_t v10 = 16LL;
      }
      else {
        unint64_t v10 = 4LL;
      }
    }

    else
    {
      unint64_t v10 = 4LL;
    }

    CFWriteStreamSignalEvent(a1, v10, 0LL, a4, a5, a6, a7, a8);
  }

  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1LL;
}

uint64_t dataWrite( char *a1, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = *(void **)(a5 + 8);
  int64_t v11 = v10[1] - v10[2];
  if (*(__objc2_class ***)(a5 + 16) == &__kCFAllocatorNull && v11 < a3)
  {
LABEL_17:
    *(_DWORD *)(a4 + 8) = 12;
    *(void *)a4 = 1LL;
    return -1LL;
  }

  else
  {
    uint64_t v14 = a3;
    if (a3 >= 1)
    {
      uint64_t v16 = a3;
      while (1)
      {
        if (v11 >= 1)
        {
          if (v16 < v11) {
            int64_t v11 = v16;
          }
          memmove((void *)(*v10 + v10[2]), __src, v11);
          v16 -= v11;
          unint64_t v10 = *(void **)(a5 + 8);
          v10[2] += v11;
          if (v16 < 1) {
            break;
          }
          __src += v11;
        }

        if (v16 <= 1024) {
          int64_t v11 = 1024LL;
        }
        else {
          int64_t v11 = v16;
        }
        unint64_t v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a5 + 16), v11 + 32, 0LL);
        if (!v10) {
          goto LABEL_17;
        }
        *unint64_t v10 = v10 + 4;
        v10[1] = v11;
        v10[2] = 0LL;
        v10[3] = 0LL;
        *(void *)(*(void *)(a5 + 8) + 24LL) = v10;
        *(void *)(a5 + 8) = v10;
      }
    }

    *(_DWORD *)(a4 + 8) = 0;
    if (*(_BYTE *)(a5 + 24) && (*(__objc2_class ***)(a5 + 16) != &__kCFAllocatorNull || v10[1] > v10[2])) {
      CFWriteStreamSignalEvent(a1, 4uLL, 0LL, a4, a5, a6, a7, a8);
    }
  }

  return v14;
}

BOOL dataCanWrite(uint64_t a1, uint64_t a2)
{
  return *(__objc2_class ***)(a2 + 16) != &__kCFAllocatorNull
      || *(void *)(*(void *)(a2 + 8) + 8LL) > *(void *)(*(void *)(a2 + 8) + 16LL);
}

CFDataRef dataCopyProperty(int a1, CFTypeRef cf1, uint64_t *a3)
{
  if (!CFEqual(cf1, @"kCFStreamPropertyDataWritten")) {
    return 0LL;
  }
  int v4 = (__objc2_class **)a3[2];
  if (v4 == &__kCFAllocatorNull) {
    return 0LL;
  }
  uint64_t v5 = *a3;
  if (*a3)
  {
    CFIndex v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(v5 + 16);
      uint64_t v5 = *(void *)(v5 + 24);
      v6 += v7;
    }

    while (v5);
    if (v6 >= 1)
    {
      uint64_t v8 = (const UInt8 *)CFAllocatorAllocate((CFAllocatorRef)a3[2], v6, 0LL);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = *a3;
        if (*a3)
        {
          int64_t v11 = (UInt8 *)v8;
          do
          {
            memmove(v11, *(const void **)v10, *(void *)(v10 + 16));
            uint64_t v12 = *(void *)(v10 + 16);
            uint64_t v10 = *(void *)(v10 + 24);
            v11 += v12;
          }

          while (v10);
        }

        return CFDataCreateWithBytesNoCopy((CFAllocatorRef)v4, v9, v6, (CFAllocatorRef)v4);
      }

      return 0LL;
    }
  }

  else
  {
    CFIndex v6 = 0LL;
  }

  uint64_t v9 = 0LL;
  return CFDataCreateWithBytesNoCopy((CFAllocatorRef)v4, v9, v6, (CFAllocatorRef)v4);
}

void writeDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(_BYTE *)(a4 + 24))
  {
    *(_BYTE *)(a4 + 24) = 1;
    if (CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusOpen)
    {
      if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
      {
        if (*(void *)(*(void *)(a4 + 8) + 8LL) <= *(void *)(*(void *)(a4 + 8) + 16LL)) {
          unint64_t v11 = 16LL;
        }
        else {
          unint64_t v11 = 4LL;
        }
      }

      else
      {
        unint64_t v11 = 4LL;
      }

      CFWriteStreamSignalEvent(a1, v11, 0LL, v6, v7, v8, v9, v10);
    }
  }

void sub_180A7E874(_Unwind_Exception *a1)
{
}

void sub_180A7ECD0(_Unwind_Exception *a1)
{
}

void sub_180A7F308(_Unwind_Exception *a1)
{
}

void sub_180A7F764(_Unwind_Exception *a1)
{
}

void sub_180A7FBBC(_Unwind_Exception *a1)
{
}

void sub_180A80288(_Unwind_Exception *a1)
{
}

void sub_180A80900(_Unwind_Exception *a1)
{
}

void sub_180A81078(_Unwind_Exception *a1)
{
}

void sub_180A832CC(_Unwind_Exception *a1)
{
}

LABEL_10:
  if (v9)
  {
    uint64_t v17 = v9;
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFIndex v18 = _os_log_pack_fill();
    BOOL v19 = __os_log_helper_1_2_4_8_32_8_0_8_0_8_0( v18,  (uint64_t)"-[NSMutableOrderedSet replaceObject:inRange:]",  location,  length,  --v17);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds [0 .. %lu]",  v19,  "-[NSMutableOrderedSet replaceObject:inRange:]",  location,  length,  v17);
  }

  else
  {
    uint64_t v13 = _os_log_pack_size();
    uint64_t v14 = (char *)v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    uint64_t v16 = __os_log_helper_1_2_3_8_32_8_0_8_0( v15,  (uint64_t)"-[NSMutableOrderedSet replaceObject:inRange:]",  location,  length);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: range {%lu, %lu} extends beyond bounds for empty ordered set",  v16,  "-[NSMutableOrderedSet replaceObject:inRange:]",  location,  length);
  }

  uint64_t v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v14,  v13);
  objc_exception_throw(v20);
  -[NSMutableOrderedSet replaceObject:](v21, v22, v23);
}

  if (v8)
  {
    uint64_t v14 = v8;
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    uint64_t v16 = __os_log_helper_1_2_3_8_32_8_0_8_0(v15, (uint64_t)"-[NSMutableOrderedSet setObject:atIndex:]", idx, --v14);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v16,  "-[NSMutableOrderedSet setObject:atIndex:]",  idx,  v14);
  }

  else
  {
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v13 = 136315394;
    *(void *)(v13 + 4) = "-[NSMutableOrderedSet setObject:atIndex:]";
    *(_WORD *)(v13 + 12) = 2048;
    *(void *)(v13 + 14) = idx;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty ordered set",  "-[NSMutableOrderedSet setObject:atIndex:]",  idx);
  }

  uint64_t v17 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v11);
  objc_exception_throw(v17);
  -[NSMutableOrderedSet setObject:atIndexedSubscript:](v18, v19, v20, v21);
}

  *(void *)(v7 + 8) = a2;
  if ((a2 & 0x8000000000000000LL) == 0 && (a3 & 4) == 0) {
    uint64_t v10 = (id)a2;
  }
}

  uint64_t v6 = atomic_load((unint64_t *)&theString->info);
  uint64_t v7 = v6 & 5;
  uint64_t v8 = atomic_load((unint64_t *)&theString->info);
  uint64_t v9 = v8 & 0x60;
  if (v7 == 4)
  {
    p_data = &theString->data;
    if (v9)
    {
      unint64_t v11 = *p_data;
    }

    else
    {
      uint64_t v12 = atomic_load((unint64_t *)&theString->info);
      unint64_t v11 = (char *)&p_data[(v12 & 5) != 4];
    }

    return *v11;
  }

  else if ((v8 & 0x60) != 0)
  {
    return theString->length;
  }

  else
  {
    return (CFIndex)theString->data;
  }

  unint64_t v11 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    unint64_t v11 = __CFDefaultEightBitStringEncoding;
  }

  if (v11 != a2)
  {
    if (v11 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      unint64_t v11 = __CFDefaultEightBitStringEncoding;
    }

    if (v11 == 1536)
    {
      uint64_t result = 0LL;
      switch(BYTE1(a2))
      {
        case 0:
          uint64_t result = 0LL;
          if ((a2 > 0x22 || ((1LL << a2) & 0x600000032LL) == 0) && a2 != 152)
          {
            uint64_t v13 = 1;
            goto LABEL_49;
          }

          return result;
        case 1:
          uint64_t v21 = a2 == 134217984;
          goto LABEL_38;
        case 2:
          uint64_t v13 = a2 != 518;
          goto LABEL_49;
        case 6:
          uint64_t v21 = a2 == 1536;
LABEL_38:
          uint64_t v13 = v21;
          goto LABEL_49;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          uint64_t v13 = 1;
          if (a2 - 2561 <= 0xF && ((1 << (a2 - 1)) & 0x8011) != 0) {
            return 0LL;
          }
          goto LABEL_49;
        case 0xB:
          if (a2 == 3071) {
            return 0LL;
          }
          uint64_t v22 = __CFADD__(a2 - 3061, 2);
          goto LABEL_46;
        default:
          uint64_t v22 = (a2 & 0xFF00) >= 0xC01;
LABEL_46:
          uint64_t v13 = !v22;
LABEL_49:
          uint64_t result = 0LL;
          if (!a1 || !v13) {
            return result;
          }
          goto LABEL_14;
      }
    }

    return 0LL;
  }

  if (!a1) {
    return 0LL;
  }
LABEL_14:
  if (a3 || (uint64_t v14 = atomic_load(a1 + 1), (v14 & 0x10) != 0))
  {
    uint64_t v15 = atomic_load(a1 + 1);
    if ((v15 & 8) == 0) {
      return 0LL;
    }
  }

  uint64_t v16 = atomic_load(a1 + 1);
  uint64_t v17 = a1 + 2;
  if ((v16 & 0x60) != 0)
  {
    CFIndex v18 = (void *)*v17;
  }

  else
  {
    BOOL v19 = atomic_load(a1 + 1);
    CFIndex v18 = &v17[(v19 & 5) != 4LL];
  }

  uint64_t v20 = atomic_load(a1 + 1);
  return (uint64_t)v18 + ((v20 >> 2) & 1);
}

          if (a4) {
            goto LABEL_11;
          }
          return v11;
        }

        uint64_t v22 = v5 + 1;
        uint64_t v23 = *((void *)buffer + 20);
        if (v23 > v5 + 1)
        {
          int v24 = *((void *)buffer + 17);
          if (v24)
          {
            __int32 v25 = *(_WORD *)(v24 + 2 * (*((void *)buffer + 19) + v22));
          }

          else
          {
            uint64_t v26 = *((void *)buffer + 18);
            if (v26)
            {
              __int32 v25 = *(char *)(v26 + *((void *)buffer + 19) + v22);
            }

            else
            {
              if (*((void *)buffer + 22) <= v22 || (uint64_t v28 = *((void *)buffer + 21), v28 > v22))
              {
                __int32 v29 = v5 - 3;
                if (v29 + 64 < v23) {
                  uint64_t v23 = v29 + 64;
                }
                *((void *)buffer + 21) = v29;
                *((void *)buffer + 22) = v23;
                v33.unint64_t location = *((void *)buffer + 19) + v29;
                v33.CFIndex length = v23 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                uint64_t v28 = *((void *)buffer + 21);
              }

              __int32 v25 = buffer[v22 - v28];
            }
          }

          if (v25 >> 10 == 55)
          {
            unint64_t v11 = ((_DWORD)v11 << 10) + v25 - 56613888;
            uint64_t v12 = 2LL;
            goto LABEL_10;
          }
        }
      }

  if (size == 1)
  {
    uint64_t v13 = v10 + a4 - *(void *)(a2 + 8);
  }

  else
  {
    uint64_t v13 = v10 + a4 * size;
    if (size >= 1)
    {
      uint64_t v14 = (uint64_t *)(a2 + 8);
      uint64_t v15 = size;
      do
      {
        uint64_t v16 = *v14;
        v14 += 2;
        v13 -= v16;
        --v15;
      }

      while (v15);
    }
  }

  uint64_t v155 = result;
  if (!v13)
  {
    int v24 = *((void *)result + 4);
    if (!v24
      || ((unint64_t)(v24 - 2) <= 0xFFFFFFFFFFFFFFFCLL ? (__int32 v25 = (*((void *)result + 5) & 8LL) == 0) : (__int32 v25 = 0),
          !v25
       || ((uint64_t v26 = *((void *)result + 5) >> 4, v27 = atomic_load(v5), (~v27 & 0x60) != 0)
         ? (PreferredSizeForSize = malloc_good_size(v26))
         : (PreferredSizeForSize = CFAllocatorGetPreferredSizeForSize(*((CFAllocatorRef *)result + 6), v26, 0LL)),
           PreferredSizeForSize < 0 ? (uint64_t v54 = -1LL) : (uint64_t v54 = PreferredSizeForSize),
           uint64_t result = v155,
           v54 == v24)))
    {
      if ((result[40] & 4) != 0)
      {
LABEL_140:
        int64_t v80 = atomic_load(v5);
        if ((v80 & 0x60) != 0) {
          *((void *)result + 3) = 0LL;
        }
        else {
          CFAllocatorRef v7 = 0LL;
        }
        return result;
      }

      char v55 = atomic_load(v5);
      while (1)
      {
        char v56 = __ldaxr(v5);
        if (v56 != v55) {
          break;
        }
        if (__stlxr(v55 & 0xFFFFFFFFFFFFFFEFLL, v5)) {
          goto LABEL_82;
        }
        char v57 = 1;
LABEL_83:
        char v55 = v56;
        if (v57)
        {
          if (v24 >= 2)
          {
            if (!v8) {
              __CFStringChangeSizeMultiple_cold_1();
            }
            char v58 = atomic_load(v5);
            while (2)
            {
              unint64_t v59 = __ldaxr(v5);
              if (v59 == v58)
              {
                if (!__stlxr(v58 | 4, v5))
                {
                  unint64_t v60 = 1;
                  goto LABEL_92;
                }
              }

              else
              {
                __clrex();
              }

              unint64_t v60 = 0;
LABEL_92:
              char v58 = v59;
              if (!v60) {
                continue;
              }
              break;
            }

            unint64_t v61 = atomic_load(v5);
            while (2)
            {
              int v62 = __ldaxr(v5);
              if (v62 == v61)
              {
                if (!__stlxr(v61 | 8, v5))
                {
                  unint64_t v63 = 1;
                  goto LABEL_99;
                }
              }

              else
              {
                __clrex();
              }

              unint64_t v63 = 0;
LABEL_99:
              unint64_t v61 = v62;
              if (v63)
              {
                *(_WORD *)uint64_t v8 = 0;
                goto LABEL_140;
              }

              continue;
            }
          }

          unint64_t v64 = atomic_load(v5);
          while (2)
          {
            int v65 = __ldaxr(v5);
            if (v65 == v64)
            {
              if (!__stlxr(v64 & 0xFFFFFFFFFFFFFFFBLL, v5))
              {
                unint64_t v66 = 1;
                goto LABEL_107;
              }
            }

            else
            {
              __clrex();
            }

            unint64_t v66 = 0;
LABEL_107:
            unint64_t v64 = v65;
            if (!v66) {
              continue;
            }
            break;
          }

          unint64_t v67 = atomic_load(v5);
          while (2)
          {
            int v68 = __ldaxr(v5);
            if (v68 == v67)
            {
              if (!__stlxr(v67 & 0xFFFFFFFFFFFFFFF7LL, v5))
              {
                unint64_t v69 = 1;
                goto LABEL_114;
              }
            }

            else
            {
              __clrex();
            }

            unint64_t v69 = 0;
LABEL_114:
            unint64_t v67 = v68;
            if (v69) {
              goto LABEL_140;
            }
            continue;
          }
        }
      }

      __clrex();
LABEL_82:
      char v57 = 0;
      goto LABEL_83;
    }

    if (v8)
    {
      __CFStrDeallocateMutableContents((uint64_t)v155, v8);
      uint64_t result = v155;
    }

    *((void *)result + 2) = 0LL;
    unint64_t v70 = *((void *)result + 5) & 0xFFFFFFFFFFFFFFF7LL;
    *((void *)result + 4) = 0LL;
    *((void *)result + 5) = v70;
    int v71 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      unint64_t v72 = __ldaxr(v5);
      if (v72 != v71) {
        break;
      }
      if (__stlxr(v71 & 0xFFFFFFFFFFFFFFFBLL, v5)) {
        goto LABEL_123;
      }
      unint64_t v73 = 1;
LABEL_124:
      int v71 = v72;
      if (v73)
      {
        unint64_t v74 = atomic_load(v5);
        while (1)
        {
          unint64_t v75 = __ldaxr(v5);
          if (v75 != v74) {
            break;
          }
          if (__stlxr(v74 & 0xFFFFFFFFFFFFFFF7LL, v5)) {
            goto LABEL_130;
          }
          int v76 = 1;
LABEL_131:
          unint64_t v74 = v75;
          if (v76)
          {
            if ((result[40] & 4) != 0) {
              goto LABEL_140;
            }
            uint64_t v77 = atomic_load(v5);
            while (2)
            {
              int v78 = __ldaxr(v5);
              if (v78 == v77)
              {
                if (!__stlxr(v77 & 0xFFFFFFFFFFFFFFEFLL, v5))
                {
                  uint64_t v79 = 1;
                  goto LABEL_139;
                }
              }

              else
              {
                __clrex();
              }

              uint64_t v79 = 0;
LABEL_139:
              uint64_t v77 = v78;
              if ((v79 & 1) != 0) {
                goto LABEL_140;
              }
              continue;
            }
          }
        }

        __clrex();
LABEL_130:
        int v76 = 0;
        goto LABEL_131;
      }
    }

    __clrex();
LABEL_123:
    unint64_t v73 = 0;
    goto LABEL_124;
  }

  uint64_t v17 = 0LL;
  CFIndex v18 = atomic_load(v5);
  BOOL v19 = 1;
  uint64_t v156 = 2LL;
  LODWORD(v2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
  uint64_t v21 = 0LL;
  if (!a5 && (v18 & 0x10) == 0)
  {
    uint64_t v22 = *((void *)result + 5);
    uint64_t v20 = (v22 >> 2) & 1;
    if ((v22 & 4) != 0)
    {
      uint64_t v17 = 0LL;
      uint64_t v21 = 0LL;
      BOOL v19 = 1;
      uint64_t v23 = 2LL;
    }

    else
    {
      BOOL v19 = 0;
      uint64_t v21 = 2LL;
      uint64_t v17 = 1LL;
      uint64_t v23 = 1LL;
    }

    uint64_t v156 = v23;
  }

  uint64_t v145 = v20;
  unint64_t v149 = v10;
  uint64_t v154 = size;
  int v152 = (char *)v8;
  __int32 v29 = *((void *)result + 4);
  BOOL v30 = v29;
  if (v13 > (v21 ^ 0x7FFFFFFFFFFFFFFFuLL) >> v19) {
    __CFStringHandleOutOfMemory();
  }
  unint64_t v151 = v19;
  uint64_t v31 = (v13 << v19) + v21;
  uint64_t v32 = *((void *)result + 4);
  int v33 = v29 | v31;
  __int32 v34 = v156;
  if (v29 | v31)
  {
    if (v29 < v31
      || (v29 >= 0 ? (int v35 = *((void *)result + 4)) : (int v35 = v29 + 1),
          (uint64_t v32 = *((void *)result + 4), (result[40] & 8) == 0) && (uint64_t v32 = *((void *)result + 4), v35 >> 1 > v31)))
    {
      if ((v31 & 0x8000000000000000LL) != 0) {
        goto LABEL_150;
      }
      uint64_t v36 = *((void *)result + 5);
      char v37 = (v36 >> 4) * v156;
      if (v37 <= v31) {
        unsigned int v38 = v31;
      }
      else {
        unsigned int v38 = (v36 >> 4) * v156;
      }
      if ((v36 & 2) != 0) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = (3 * v31 + 1) >> 1;
      }
      if ((3 * v31 + 1) >> 1 >= v37) {
        uint64_t v40 = v39;
      }
      else {
        uint64_t v40 = v37;
      }
      uint64_t v41 = atomic_load(v5);
      if ((~v41 & 0x60) != 0) {
        uint64_t v42 = malloc_good_size(v40);
      }
      else {
        uint64_t v42 = CFAllocatorGetPreferredSizeForSize(*((CFAllocatorRef *)result + 6), v40, 0LL);
      }
      if (v42 < 0) {
        uint64_t v32 = -1LL;
      }
      else {
        uint64_t v32 = v42;
      }
      uint64_t result = v155;
      __int32 v34 = v156;
      __int32 v29 = v30;
    }
  }

  if (v32 == -1) {
LABEL_150:
  }
    __CFStringHandleOutOfMemory();
  char v148 = (v18 & 0x10) >> 4;
  if (!v152 || v32 != v29 || v151 && v149 >= 1 && (v18 & 0x10) == 0)
  {
    uint64_t result = (char *)__CFStrAllocateMutableContents((uint64_t)result, v32);
    if (result) {
      goto LABEL_159;
    }
    if (v33)
    {
      int v43 = (uint64_t)v155;
      if (v30 >= v31)
      {
        if ((v155[40] & 8) != 0 || (v30 >= 0 ? (uint64_t v81 = v30) : (uint64_t v81 = v30 + 1), v31 >= v30 && v81 >> 1 <= v31))
        {
LABEL_157:
          uint64_t v32 = v30;
          if (v30 != -1)
          {
            uint64_t result = (char *)__CFStrAllocateMutableContents(v43, v30);
            if (!result) {
              __CFStringHandleOutOfMemory();
            }
LABEL_159:
            int v82 = atomic_load(v5);
            unsigned int v49 = (v82 >> 2) & 1;
            uint64_t v52 = (uint64_t)&result[v17];
            CFIndex v47 = 1;
            __int32 v29 = v32;
            uint64_t v50 = v151;
            char v51 = v152;
            uint64_t v53 = (v18 & 0x10) >> 4;
            __int32 v34 = v156;
            if (!v152) {
              goto LABEL_171;
            }
            goto LABEL_160;
          }

  *a8 = v16 == 0;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    CFIndex v18 = ucol_strcoll();
    if (v18)
    {
      if (v18 == -1) {
        BOOL v19 = -1;
      }
      else {
        BOOL v19 = 1;
      }
    }

    else
    {
      if (a5 >= a7) {
        uint64_t v22 = a7;
      }
      else {
        uint64_t v22 = a5;
      }
      if (v22)
      {
        while (1)
        {
          uint64_t v23 = *a4;
          int v24 = *a6;
          if (v23 != v24) {
            break;
          }
          ++a4;
          ++a6;
          if (!--v22) {
            goto LABEL_30;
          }
        }

        if (v23 < v24) {
          BOOL v19 = -1;
        }
        else {
          BOOL v19 = 1;
        }
      }

      else
      {
LABEL_30:
        if (a5 < a7) {
          BOOL v19 = -1;
        }
        else {
          BOOL v19 = 1;
        }
        if (a5 == a7) {
          BOOL v19 = 0;
        }
      }
    }

    *a9 = v19;
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
  }

  return 0LL;
}

  switch(v9 >> 29)
  {
    case 1u:
      uint64_t v17 = @"http";
      break;
    case 2u:
      uint64_t v17 = @"https";
      break;
    case 3u:
      uint64_t v17 = @"file";
      break;
    case 4u:
      uint64_t v17 = @"data";
      break;
    case 5u:
      uint64_t v17 = @"ftp";
      break;
    default:
      goto LABEL_13;
  }

  uint64_t v20 = (const __CFString *)CFRetain(v17);
LABEL_19:
  uint64_t v21 = v20;
  if (a4 | a3 || !v20 || (*(_BYTE *)(a1 + 18) & 1) != 0) {
    goto LABEL_29;
  }
  uint64_t v22 = *(void *)(a1 + 40);
  if (v22) {
    LODWORD(v22) = *(_DWORD *)(v22 + 16);
  }
  if ((v22 & a2) == 0)
  {
LABEL_29:
    CFIndex v18 = v20;
    if (!a4) {
      return v18;
    }
    goto LABEL_30;
  }

  uint64_t v23 = *(_DWORD *)(a1 + 20);
  int v24 = CFGetAllocator(v20);
  CFIndex Length = CFStringGetLength(v21);
  v36[2] = (CFMutableStringRef)v36;
  CFStringRef theString = 0LL;
  uint64_t v39 = 0LL;
  uint64_t v40 = 0LL;
  unsigned int v38 = 0LL;
  constructBuffers(v21, v43, &v40, &v39, (char *)&v42, &v41);
  uint64_t v26 = v40;
  __int32 v27 = v42;
  uint64_t v28 = v24;
  __int32 v29 = v39;
  scanCharacters(v28, &theString, 0LL, v40, v39, v42, 0LL, Length, &v38, a2, v23);
  CFIndex v18 = theString;
  if (theString)
  {
    BOOL v30 = Length - v38;
    if (Length > v38)
    {
      if (v27) {
        __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)(v26 + v38), v30, 513LL);
      }
      else {
        CFStringAppendCharacters(theString, (const UniChar *)(v29 + 2 * v38), v30);
      }
    }
  }

  else
  {
    CFRetain(v21);
    CFIndex v18 = v21;
  }

  if (v41)
  {
    if (v27) {
      int v35 = (void *)v26;
    }
    else {
      int v35 = (void *)v29;
    }
    free(v35);
  }

  CFRelease(v21);
  if (a4)
  {
LABEL_30:
    if (v18)
    {
      uint64_t v31 = *(_DWORD *)(a1 + 20);
      if (v31 == 134217984) {
        uint64_t v32 = CFURLCreateStringByReplacingPercentEscapes(v10, v18, &stru_1899EF170);
      }
      else {
        uint64_t v32 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v10, v18, &stru_1899EF170, v31);
      }
      int v33 = v32;
      CFRelease(v18);
      return v33;
    }
  }

  return v18;
}

        CFIndex Length = CFStringGetLength(v13);
        CFIndex v18 = CFStringGetCharacterAtIndex(v13, Length - 1) == 47;
        BOOL v19 = v15;
        if (!v15)
        {
          if (!v14 || CFEqual(v14, @"localhost"))
          {
            uint64_t v23 = URLPathToPOSIXPath(v13, allocator, v6[5], 1);
            if (!v23)
            {
              uint64_t v22 = 0LL;
LABEL_30:
              CFRelease(v13);
              if (!v14) {
                goto LABEL_32;
              }
              goto LABEL_31;
            }

            int v24 = v23;
            uint64_t v22 = (const __CFURL *)_CFURLCreateWithFileSystemPath(allocator, v23, 0LL, v18, 0LL);
            __int32 v25 = v24;
LABEL_29:
            CFRelease(v25);
            goto LABEL_30;
          }

          BOOL v19 = &stru_1899EF170;
        }

        uint64_t v20 = &stru_1899EF170;
        if (v14) {
          uint64_t v20 = v14;
        }
        uint64_t v21 = CFStringCreateWithFormat(allocator, 0LL, @"file://%@%@%@", v20, v13, v19);
        if (v21) {
          uint64_t v22 = (const __CFURL *)_CFURLCreateWithURLString(allocator, v21, 1, 0LL);
        }
        else {
          uint64_t v22 = 0LL;
        }
        __int32 v25 = v21;
        goto LABEL_29;
      }

      if (v28)
      {
        if (error)
        {
LABEL_18:
          uint64_t v22 = 0LL;
          *error = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 262LL, 0LL);
LABEL_34:
          CFRelease(v6);
          return v22;
        }
      }

      else
      {
        CFLog( 4LL,  (uint64_t)@"CFURLCreateFileReferenceURL failed because it was passed a URL which has no scheme",  v7,  v8,  v9,  v10,  v11,  v12,  v27);
        if (error) {
          goto LABEL_18;
        }
      }

      uint64_t v22 = 0LL;
      goto LABEL_34;
    }
  }

  return 0LL;
}

  if (v8)
  {
    uint64_t v14 = v8;
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = _os_log_pack_fill();
    uint64_t v16 = __os_log_helper_1_2_3_8_32_8_0_8_0(v15, (uint64_t)"-[NSMutableArray setObject:atIndex:]", a4, --v14);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v16,  "-[NSMutableArray setObject:atIndex:]",  a4,  v14);
  }

  else
  {
    unint64_t v11 = _os_log_pack_size();
    uint64_t v12 = (char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v13 = 136315394;
    *(void *)(v13 + 4) = "-[NSMutableArray setObject:atIndex:]";
    *(_WORD *)(v13 + 12) = 2048;
    *(void *)(v13 + 14) = a4;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray setObject:atIndex:]",  a4);
  }

  uint64_t v17 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v12,  v11);
  objc_exception_throw(v17);
  -[NSMutableArray setObject:atIndexedSubscript:](v18, v19, v20, v21);
}

  v9[a3] = 0;
  uint64_t v13 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), (const UInt8 *)v9, a3, 0x600u, 0);
  if (v13) {
    goto LABEL_13;
  }
  CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate ascii string while parsing plist");
LABEL_20:
  uint64_t v16 = Error;
  uint64_t v17 = *(const void **)(a1 + 24);
  if (v17) {
    CFRelease(v17);
  }
  uint64_t Value = 0LL;
  *(void *)(a1 + 24) = v16;
  return Value;
}

  uint64_t v9 = (objc_class *)objc_opt_self();
  uint64_t v8 = (void *)__CFAllocateObject(v9, 0LL);
  uint64_t v10 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v10, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v8, 0LL);
  return v8;
}

  uint64_t v10 = (objc_class *)objc_opt_self();
  uint64_t v9 = (void *)__CFAllocateObject(v10, 0LL);
  unint64_t v11 = (os_unfair_lock_s *)atomic_load((unint64_t *)&self->cow);
  _cow_copy((uint64_t)self, 1LL, v11, (uint64_t)__NSDictionary_cowCallbacks, (uint64_t)v9, 0LL);
  return v9;
}

void sub_180A85748(_Unwind_Exception *a1)
{
}

void sub_180A85DA0(_Unwind_Exception *a1)
{
}

void sub_180A86214(_Unwind_Exception *a1)
{
}

void sub_180A8685C(_Unwind_Exception *a1)
{
}

void sub_180A86CD0(_Unwind_Exception *a1)
{
}

void sub_180A87140(_Unwind_Exception *a1)
{
}

void sub_180A886E8(_Unwind_Exception *a1)
{
}

NSUInteger OUTLINED_FUNCTION_0_2(objc_class *a1, uint64_t a2)
{
  return __CFRequireConcreteImplementation(a1, a2);
}

  ;
}

  ;
}

void __CFDataDeallocate(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) == 0)
  {
    char v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x10) == 0)
    {
      int v4 = *(const void **)(a1 + 32);
      if (v4)
      {
        uint64_t v5 = (void *)(a1 + 40);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), *(void **)(a1 + 40));
        CFRelease(v4);
      }

      else
      {
        char v6 = atomic_load((unint64_t *)(a1 + 8));
        if ((v6 & 8) != 0)
        {
          if (a1 < 0)
          {
            uint64_t v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
          }

          else
          {
            char v9 = atomic_load((unint64_t *)(a1 + 8));
            if (v9 < 0) {
              uint64_t v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
            }
            else {
              uint64_t v8 = (CFAllocatorRef *)(a1 - 16);
            }
          }

          CFAllocatorDeallocate(*v8, *(void **)(a1 + 40));
        }

        else
        {
          uint64_t v7 = *(void **)(a1 + 40);
          if (v7) {
            free(v7);
          }
        }

        uint64_t v5 = (void *)(a1 + 40);
      }

      *uint64_t v5 = 0LL;
    }
  }

BOOL __CFDataEqual(unint64_t *a1, unint64_t *a2)
{
  size_t v2 = a1[2];
  if (v2 != a2[2]) {
    return 0LL;
  }
  char v3 = atomic_load(a1 + 1);
  if ((v3 & 4) != 0) {
    int v4 = (const void *)(((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else {
    int v4 = (const void *)a1[5];
  }
  char v6 = atomic_load(a2 + 1);
  if ((v6 & 4) != 0) {
    uint64_t v7 = (const void *)(((unint64_t)a2 + 63) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else {
    uint64_t v7 = (const void *)a2[5];
  }
  return v4 == v7 || memcmp(v4, v7, v2) == 0;
}

uint64_t __CFDataHash(unint64_t *a1)
{
  char v1 = atomic_load(a1 + 1);
  if ((v1 & 4) != 0) {
    unint64_t v2 = ((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0LL;
  }
  else {
    unint64_t v2 = a1[5];
  }
  else {
    uint64_t v3 = a1[2];
  }
  return CFHashBytes(v2, v3);
}

__CFString *__CFDataCopyDescription(unint64_t *cf)
{
  uint64_t v2 = cf[2];
  char v3 = atomic_load(cf + 1);
  if ((v3 & 4) != 0) {
    int v4 = (unsigned __int8 *)(((unint64_t)cf + 63) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else {
    int v4 = (unsigned __int8 *)cf[5];
  }
  uint64_t v5 = CFGetAllocator(cf);
  CFMutableCharacterSetRef Mutable = CFStringCreateMutable(v5, 0LL);
  CFAllocatorRef v7 = CFGetAllocator(cf);
  CFStringAppendFormat( Mutable,  0LL,  @"<CFData %p [%p]>{CFIndex length = %lu, capacity = %lu, bytes = 0x",  cf,  v7,  v2,  cf[3]);
  if (v2 < 25)
  {
    if (v2 >= 1)
    {
      do
      {
        unsigned int v11 = *v4++;
        CFStringAppendFormat(Mutable, 0LL, @"%02x", v11);
        --v2;
      }

      while (v2);
    }
  }

  else
  {
    unint64_t v8 = 0LL;
    do
    {
      CFStringAppendFormat(Mutable, 0LL, @"%02x%02x%02x%02x", v4[v8], v4[v8 + 1], v4[v8 + 2], v4[v8 + 3]);
      BOOL v9 = v8 >= 0xC;
      v8 += 4LL;
    }

    while (!v9);
    CFStringAppend(Mutable, @" ... ");
    uint64_t v10 = v2 - 8;
    do
    {
      CFStringAppendFormat(Mutable, 0LL, @"%02x%02x%02x%02x", v4[v10], v4[v10 + 1], v4[v10 + 2], v4[v10 + 3]);
      v10 += 4LL;
    }

    while (v10 < v2);
  }

  CFStringAppend(Mutable, @"}");
  return Mutable;
}

CFTypeID CFDataGetTypeID(void)
{
  return 20LL;
}

void _CFDataInit(unint64_t *a1, int a2, unint64_t a3, const UInt8 *a4, CFIndex a5, int a6)
{
  char v8 = a2;
  a1[2] = 0LL;
  uint64_t v10 = a1 + 1;
  unint64_t v11 = atomic_load(a1 + 1);
  do
  {
    unint64_t v12 = __ldaxr(v10);
    if (v12 == v11)
    {
      if (!__stlxr(v11 & 0xFFFFFFFFFFFFFFEFLL | (4 * a2) & 0x10LL, v10))
      {
        int v13 = 1;
        goto LABEL_7;
      }
    }

    else
    {
      __clrex();
    }

    int v13 = 0;
LABEL_7:
    unint64_t v11 = v12;
  }

  while (!v13);
  if ((a2 & 2) != 0 && (a2 & 1) != 0)
  {
    a1[3] = 16LL;
    unint64_t v14 = atomic_load(a1 + 1);
    while (1)
    {
      unint64_t v15 = __ldaxr(v10);
      if (v15 != v14) {
        break;
      }
      if (__stlxr(v14 | 3, v10)) {
        goto LABEL_15;
      }
      char v16 = 1;
LABEL_16:
      unint64_t v14 = v15;
      if ((v16 & 1) != 0) {
        goto LABEL_25;
      }
    }

    __clrex();
LABEL_15:
    char v16 = 0;
    goto LABEL_16;
  }

  a1[3] = a3;
  unint64_t v17 = atomic_load(a1 + 1);
  while (2)
  {
    unint64_t v18 = __ldaxr(v10);
    if (v18 == v17)
    {
      if (!__stlxr(v17 & 0xFFFFFFFFFFFFFFFCLL | 1, v10))
      {
        int v19 = 1;
        goto LABEL_24;
      }
    }

    else
    {
      __clrex();
    }

    int v19 = 0;
LABEL_24:
    unint64_t v17 = v18;
    if (!v19) {
      continue;
    }
    break;
  }

void *__CFDataAllocate(uint64_t a1, size_t __size, int a3)
{
  char v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 8) != 0)
  {
    if (a1 < 0)
    {
      CFAllocatorRef v7 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }

    else
    {
      char v8 = atomic_load((unint64_t *)(a1 + 8));
      if (v8 < 0) {
        CFAllocatorRef v7 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }
      else {
        CFAllocatorRef v7 = (CFAllocatorRef *)(a1 - 16);
      }
    }

    BOOL v9 = CFAllocatorAllocate(*v7, __size, 0LL);
    uint64_t v10 = v9;
    if (a3) {
      bzero(v9, __size);
    }
    return v10;
  }

  else if (a3)
  {
    return calloc(1uLL, __size);
  }

  else
  {
    return malloc(__size);
  }

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  char v8 = (unint64_t *)theData;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    objc_msgSend(v8, "replaceBytesInRange:withBytes:length:", location, length, newBytes, newLength);
    return;
  }

  CFIndex v9 = v8[2];
  int64_t v10 = v8[3];
  if (location < 0)
  {
    uint64_t v14 = dyld_program_sdk_at_least();
    if ((_DWORD)v14) {
      CFDataReplaceBytes_cold_11(v14, v15, v16);
    }
    uint64_t v23 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      CFDataReplaceBytes_cold_12();
    }
  }

  else
  {
    if (location <= v9)
    {
      if (length < 0)
      {
        uint64_t v20 = dyld_program_sdk_at_least();
        if ((_DWORD)v20) {
          CFDataReplaceBytes_cold_9(v20, v21, v22);
        }
        char v8 = (unint64_t *)_CFOSLog();
        if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT)) {
          CFDataReplaceBytes_cold_10();
        }
        goto LABEL_59;
      }

      if (location + length > v9)
      {
        uint64_t v17 = dyld_program_sdk_at_least();
        if ((_DWORD)v17) {
          CFDataReplaceBytes_cold_7(v17, v18, v19);
        }
        uint64_t v36 = (os_log_s *)_CFOSLog();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
          CFDataReplaceBytes_cold_8();
        }
      }

      goto LABEL_19;
    }

    uint64_t v11 = dyld_program_sdk_at_least();
    if ((_DWORD)v11) {
      CFDataReplaceBytes_cold_1(v11, v12, v13);
    }
    unint64_t v24 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_60;
    }
  }

  while (length < 0)
  {
LABEL_59:
    qword_18C539A70 = (uint64_t)"Negative range.length passed to CFDataReplaceBytes";
    __break(1u);
LABEL_60:
    CFDataReplaceBytes_cold_6();
  }

uint64_t __CFDataMtbl(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

dispatch_data_t _CFDataCreateDispatchData(void *a1)
{
  void v7[5] = *MEMORY[0x1895F89C0];
  char v3 = CFGetAllocator(a1);
  CFDataRef Copy = CFDataCreateCopy(v3, (CFDataRef)a1);
  BytePtr = CFDataGetBytePtr(Copy);
  else {
    size_t v6 = *((void *)Copy + 2);
  }
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  void v7[2] = ___CFDataCreateDispatchData_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = Copy;
  return dispatch_data_create(BytePtr, v6, 0LL, v7);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  char v5 = atomic_load((unint64_t *)theData + 1);
  if ((v5 & 1) == 0)
  {
    BOOL ShouldUseAllocator = __CFDataShouldUseAllocator((__objc2_class **)allocator);
    CFAllocatorRef v7 = 0LL;
    if (ShouldUseAllocator) {
      CFAllocatorRef v8 = allocator;
    }
    else {
      CFAllocatorRef v8 = 0LL;
    }
    char v9 = atomic_load((unint64_t *)theData + 1);
    if ((v9 & 8) != 0)
    {
      if (((unint64_t)theData & 0x8000000000000000LL) != 0)
      {
        int64_t v10 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v11 = atomic_load((unint64_t *)theData + 1);
        if (v11 < 0) {
          int64_t v10 = &kCFAllocatorSystemDefault;
        }
        else {
          int64_t v10 = (const CFAllocatorRef *)((char *)theData - 16);
        }
      }

      CFAllocatorRef v7 = *v10;
    }

    if (v8 == v7)
    {
      char v14 = atomic_load((unint64_t *)theData + 1);
      if ((v14 & 4) != 0 || !*((void *)theData + 4)) {
        return (CFDataRef)CFRetain(theData);
      }
    }
  }

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  char v3 = atomic_load((unint64_t *)theData + 1);
  if ((v3 & 4) != 0) {
    return (const UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else {
    return (const UInt8 *)*((void *)theData + 5);
  }
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  else {
    return *((void *)theData + 2);
  }
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, 0LL);
}

unint64_t *__CFDataInit( __objc2_class **a1, char a2, unint64_t a3, const UInt8 *a4, CFIndex a5, const void *a6)
{
  size_t v6 = a6;
  char v11 = a1;
  BOOL v12 = 0;
  if ((a2 & 2) == 0 && !a6) {
    BOOL v12 = 4LL * *MEMORY[0x1895FD590] - 63 > a3;
  }
  if (!a1)
  {
    uint64_t v13 = _CFGetTSD(1u);
    if (v13) {
      char v11 = (__objc2_class **)v13;
    }
    else {
      char v11 = &__kCFAllocatorSystemDefault;
    }
  }

  BOOL ShouldUseAllocator = __CFDataShouldUseAllocator(v11);
  if (v12) {
    uint64_t v19 = a3 + 47;
  }
  else {
    uint64_t v19 = 32LL;
  }
  uint64_t Instance = (unint64_t *)_CFRuntimeCreateInstance( (const __CFAllocator *)v11,  0x14uLL,  v19,  0LL,  v14,  v15,  v16,  v17);
  uint64_t v21 = Instance;
  if (!Instance) {
    return v21;
  }
  Instance[2] = 0LL;
  uint64_t v22 = Instance + 1;
  unint64_t v23 = atomic_load(Instance + 1);
  uint64_t v24 = 4LL;
  if (!v12) {
    uint64_t v24 = 0LL;
  }
  do
  {
    unint64_t v25 = __ldaxr(v22);
    if (v25 == v23)
    {
      if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFFBLL | v24, v22))
      {
        int v26 = 1;
        goto LABEL_19;
      }
    }

    else
    {
      __clrex();
    }

    int v26 = 0;
LABEL_19:
    unint64_t v23 = v25;
  }

  while (!v26);
  unint64_t v27 = atomic_load(v22);
  do
  {
    unint64_t v28 = __ldaxr(v22);
    if (v28 == v27)
    {
      if (!__stlxr(v27 & 0xFFFFFFFFFFFFFFF7LL | (8LL * (ShouldUseAllocator & 0x1F)), v22))
      {
        int v29 = 1;
        goto LABEL_26;
      }
    }

    else
    {
      __clrex();
    }

    int v29 = 0;
LABEL_26:
    unint64_t v27 = v28;
  }

  while (!v29);
  if ((a2 & 1) != 0 && (a2 & 2) != 0)
  {
    Instance[3] = 16LL;
    unint64_t v30 = atomic_load(Instance + 1);
    while (1)
    {
      unint64_t v31 = __ldaxr(v22);
      if (v31 != v30) {
        break;
      }
      if (__stlxr(v30 | 3, v22)) {
        goto LABEL_34;
      }
      char v32 = 1;
LABEL_35:
      unint64_t v30 = v31;
      if ((v32 & 1) != 0) {
        goto LABEL_44;
      }
    }

    __clrex();
LABEL_34:
    char v32 = 0;
    goto LABEL_35;
  }

  Instance[3] = a3;
  unint64_t v33 = atomic_load(Instance + 1);
  while (2)
  {
    unint64_t v34 = __ldaxr(v22);
    if (v34 == v33)
    {
      if (!__stlxr(v33 & 0xFFFFFFFFFFFFFFFCLL | 1, v22))
      {
        int v35 = 1;
        goto LABEL_43;
      }
    }

    else
    {
      __clrex();
    }

    int v35 = 0;
LABEL_43:
    unint64_t v33 = v34;
    if (!v35) {
      continue;
    }
    break;
  }

LABEL_75:
            __CFDataInit_didChecuint64_t k = 1;
          }

          if (__CFDataInit_setToNull == 1)
          {
            v21[5] = ((unint64_t)v21 + 63) & 0xFFFFFFFFFFFFFFF0LL;
            unint64_t v44 = atomic_load(v21 + 1);
            while (1)
            {
              unint64_t v45 = __ldaxr(v22);
              if (v45 != v44) {
                break;
              }
              if (__stlxr(v44 | 4, v22)) {
                goto LABEL_82;
              }
              int v46 = 1;
LABEL_83:
              unint64_t v44 = v45;
              if (v46) {
                goto LABEL_84;
              }
            }

            __clrex();
LABEL_82:
            int v46 = 0;
            goto LABEL_83;
          }

      CFIndex location = CFStringFind(Mutable, @"j", 1uLL).location;
      if (location == -1)
      {
        unint64_t v30 = 0;
        unint64_t v31 = 0LL;
      }

      else
      {
        CFStringGetCharacterAtIndex(Mutable, location);
        if (location + 1 < CFStringGetLength(Mutable)
          && (CFStringGetCharacterAtIndex(Mutable, location + 1) == 106
           || CFStringGetCharacterAtIndex(Mutable, location + 1) == 74))
        {
          CFStringGetCharacterAtIndex(Mutable, location + 1);
          unint64_t v30 = 1;
          unint64_t v31 = 2LL;
        }

        else
        {
          unint64_t v30 = 0;
          unint64_t v31 = 1LL;
        }
      }

      bzero(chars, 0x600uLL);
      bzero(v67, 0x600uLL);
      bzero(v66, 0x600uLL);
      char v32 = CFStringGetLength(Mutable);
      if (v32 >= 768) {
        unint64_t v33 = 768LL;
      }
      else {
        unint64_t v33 = v32;
      }
      v70.CFIndex location = 0LL;
      v70.CFIndex length = v33;
      CFStringGetCharacters(Mutable, v70, chars);
      CFRelease(Mutable);
      int v65 = 0;
      Skeletouint64_t n = __cficu_udatpg_getSkeleton(v61, chars, v33, v67, 768LL, &v65);
      int v35 = 0LL;
      if (v65 <= 0)
      {
        if (location == -1)
        {
          unint64_t v36 = Skeleton;
        }

        else
        {
          unint64_t v36 = Skeleton;
          if ((unint64_t)(v31 + (int)Skeleton) <= 0x2FF)
          {
            unint64_t v36 = (int)Skeleton + 1LL;
            v67[(int)Skeleton] = 106;
            if (v30)
            {
              v67[v36] = 106;
              unint64_t v36 = (Skeleton + 2);
            }
          }
        }

        int v65 = 0;
        BestPatteruint64_t n = __cficu_udatpg_getBestPattern(v61, v67, v36, v66, 768LL, &v65);
        if (v65 <= 0)
        {
          int v38 = BestPattern;
          if (v8.location != -1)
          {
            Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
            if (v38 >= 1)
            {
              uint64_t v40 = Predefined;
              for (CFIndex i = 0LL; i < v38; ++i)
              {
                unint64_t v42 = v66[i] - 66;
                uint64_t v43 = v42 > 0x20;
                unint64_t v44 = (1LL << v42) & 0x180000003LL;
                if (!v43 && v44 != 0)
                {
                  int v46 = i - 1;
                  do
                  {
                    unint64_t v47 = v46;
                    int v48 = i - 1;
                    IsCharacterMember = CFCharacterSetIsCharacterMember(v40, v66[i - 1]);
                    int v46 = v47 - 1;
                    --i;
                  }

                  while (IsCharacterMember);
                  CFIndex i = v48 + 1;
                  while (1)
                  {
                    unint64_t v50 = v66[v48 + 1];
                    int v51 = (v50 - 66) > 0x20 || ((1LL << (v50 - 66)) & 0x180000003LL) == 0;
                    if (v51 && !CFCharacterSetIsCharacterMember(v40, v50)) {
                      break;
                    }
                    if (v38 >= 767) {
                      uint64_t v52 = 767;
                    }
                    else {
                      uint64_t v52 = v38;
                    }
                    if (i < v52)
                    {
                      CFRange v53 = v47;
                      do
                      {
                        v66[v53 + 1] = v66[v53 + 2];
                        uint64_t v54 = v53 + 2;
                        ++v53;
                      }

                      while (v54 < v52);
                    }

                    --v38;
                  }
                }
              }
            }
          }

          int v35 = CFStringCreateWithCharacters(*(CFAllocatorRef *)(v62 + 64), v66, v38);
        }

        else
        {
          int v35 = 0LL;
        }
      }

      int v4 = v62;
      char v55 = *(void *)(*(void *)(v62 + 32) + 8LL);
      if (*(_BYTE *)(v62 + 72))
      {
        *(void *)(v55 + 24) = v35;
        char v56 = v64;
      }

      else
      {
        if (v35) {
          char v57 = (__objc2_class **)v35;
        }
        else {
          char v57 = &__kCFNull;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v55 + 24), v57);
        char v56 = v64;
        if (v35) {
          CFRelease(v35);
        }
      }

      char v5 = v56 + 1;
      if (v5 == Count) {
        return;
      }
    }
  }

  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 40));
  if (Count >= 1) {
    goto LABEL_4;
  }
}

  CFBurstTrieRelease(v76);
  CFRelease(cf);
  if (TopLevelKeyPaths) {
    CFRelease(TopLevelKeyPaths);
  }
  CFRelease(theData);
  unint64_t v27 = a9;
  if (v52)
  {
    *a11 = v51;
    return 1LL;
  }

      int v35 = v154;
LABEL_76:
      unint64_t v60 = v141;
      if (v52 <= 1) {
        unint64_t v60 = 0;
      }
      if (v60) {
        CFUniCharPrioritySort(v43, v52);
      }
      goto LABEL_80;
    }
  }

          if ((a1 & 8) != 0 || v9 < 1) {
            goto LABEL_132;
          }
          if ((a1 & 0x10) == 0) {
            goto LABEL_73;
          }
          unint64_t v34 = v12;
          int v35 = v13;
          int v68 = a3;
          unint64_t v69 = a1;
          unint64_t v36 = v10;
          unint64_t v37 = a4;
          int v38 = a6;
          uint64_t v39 = __CFPrecomposeCharKorean(a2 - 1);
          if (!v39)
          {
            a6 = v38;
            a4 = v37;
LABEL_140:
            int64_t v10 = v36;
            uint64_t v13 = v35;
            if (v34) {
              goto LABEL_133;
            }
            goto LABEL_141;
          }

          a6 = v38;
          a4 = v37;
          if (v39 < 0xA1) {
            goto LABEL_140;
          }
          char v11 = 0xF73Eu;
          uint64_t v40 = (unsigned __int16 *)&KSX1001_from_uni;
          uint64_t v41 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
          BOOL v12 = v34;
          while (2)
          {
            unint64_t v42 = (0xF83E0F83E0F83E1LL * (v41 - v40)) >> 1;
            uint64_t v43 = &v40[33 * v42];
            unint64_t v44 = *v43;
            if (v44 > v39)
            {
              uint64_t v41 = v43 - 33;
              goto LABEL_88;
            }

            if (v44 + 32 <= v39)
            {
              uint64_t v40 = v43 + 33;
LABEL_88:
              if (v40 > v41) {
                goto LABEL_130;
              }
              continue;
            }

            break;
          }

          unint64_t v49 = v40[33 * v42 + 1 + (int)(v39 - v44)];
          else {
            unint64_t v50 = 1;
          }
          if (v50)
          {
LABEL_130:
            int64_t v10 = v36;
LABEL_131:
            uint64_t v13 = v35;
            goto LABEL_132;
          }

          int64_t v10 = v36;
          if (v49 >> 8 < 0xA1) {
            goto LABEL_131;
          }
          uint64_t v13 = v35;
          if (v49 >> 8 == 255
            || v40[33 * v42 + 1 + (int)(v39 - v44)] < 0xA1u
            || v40[33 * v42 + 1 + (int)(v39 - v44)] == 255)
          {
            goto LABEL_132;
          }

          int64_t v10 = v34 != 0;
          if (v34) {
            int v51 = v35 + 1;
          }
          else {
            int v51 = v35;
          }
          uint64_t v52 = -2LL;
          if (v34 != 0 && !v36) {
            uint64_t v52 = -1LL;
          }
          uint64_t v13 = v51 + ((v34 != 0) & !v36);
          if (!a5)
          {
            a1 = v69;
            a3 = v68;
            goto LABEL_71;
          }

          a1 = v69;
          if (v13 > a5)
          {
            if (v34) {
              unint64_t v67 = -1LL;
            }
            else {
              unint64_t v67 = 0LL;
            }
            v13 += v67 - ((v34 != 0) & !v36);
            goto LABEL_168;
          }

          CFRange v53 = &a4[v52];
          if (v34) {
            *v53++ = 14;
          }
          a3 = v68;
          CFAllocatorRef v53 = BYTE1(v49) & 0x7F;
          a4 = v53 + 2;
          v53[1] = v49 & 0x7F;
LABEL_71:
          BOOL v12 = 0;
LABEL_72:
          ++a2;
          ++v9;
LABEL_73:
          if (v9 >= a3)
          {
LABEL_132:
            if (v12)
            {
LABEL_133:
              CFAllocatorRef v8 = v13;
              goto LABEL_134;
            }

        int64_t v10 = (char *)v157;
        char v9 = v154;
        int v4 = v148;
LABEL_230:
        *char v9 = 0;
        *int v4 = (uint64_t)v5;
        if (!*((_BYTE *)v8 + 36))
        {
          __NSMethodFrameArgInfoDestroy(v8);
          return 0LL;
        }

        return v8;
      case '^':
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v17 = v154;
        *uint64_t v154 = v15;
        uint64_t v18 = v154 + 1;
        uint64_t v19 = *v13;
        if (v19 == 118 || v19 == 63)
        {
          int v157 = (unint64_t)(v10 + 2);
          v154 += 2;
          v17[1] = v19;
        }

        else
        {
          unint64_t v87 = parseFrameArgumentInfo(&v157, 0LL, a3, a4 + 1);
          if (!v87)
          {
            CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'",  *v148);
            unint64_t v141 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
            objc_exception_throw(v141);
            goto LABEL_263;
          }

          LOBYTE(v88) = *(_BYTE *)(v87 + 37);
          if ((_BYTE)v88)
          {
            int v89 = 0LL;
            do
            {
              v18[v89] = v88;
              uint64_t v88 = *(unsigned __int8 *)(v87 + v89++ + 38);
            }

            while (v88);
            v18 += v89;
          }

          uint64_t v154 = v18;
          if (*(_DWORD *)(v87 + 16))
          {
            *CFAllocatorRef v8 = v87;
            *((_WORD *)v8 + 17) |= 0x1000u;
          }

          else
          {
            __NSMethodFrameArgInfoDestroy((void *)v87);
          }
        }

        goto LABEL_75;
      case 'c':
      case 'i':
      case 'l':
      case 'q':
      case 's':
      case 't':
        *((_WORD *)v8 + 17) |= 0x100u;
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'n':
        *((_WORD *)v8 + 17) |= 1u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'o':
        *((_WORD *)v8 + 17) |= 2u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'r':
        *((_WORD *)v8 + 17) |= 0x10u;
        uint64_t v16 = v154;
LABEL_74:
        *uint64_t v16 = v14;
        uint64_t v154 = v16 + 1;
        goto LABEL_75;
      case '{':
        *((_BYTE *)v8 + 36) = v14;
        *uint64_t v154 = v14;
        unint64_t v27 = v154 + 1;
        *((_WORD *)v8 + 17) |= 0x400u;
        if (a4 >= 0x400)
        {
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'; exceeded maximum nesting depth %d",
            v10,
            1024LL);
        }

        else
        {
          unint64_t v28 = *v13;
          if (*v13)
          {
            int v29 = 0LL;
            unint64_t v30 = (unsigned __int8 *)(v10 + 2);
            unint64_t v31 = *v13;
            do
            {
              if (v31 == 125)
              {
                if (!v29)
                {
                  unint64_t v63 = (unint64_t)(v30 - 1);
                  for (CFIndex i = 1LL; ; v28 = v10[i])
                  {
                    if (v28 > 60)
                    {
                      if (v28 == 61)
                      {
                        unint64_t v66 = &v10[i];
                        if (i >= 2)
                        {
                          unint64_t v97 = v10 + 1;
                          do
                          {
                            uint64_t v13 = v97 + 1;
                            if ((unint64_t)v27 >= v11)
                            {
                              int v157 = (unint64_t)(v97 + 1);
                              goto LABEL_237;
                            }

                            *v27++ = *v97++;
                          }

                          while (v13 < v66);
                        }

LABEL_84:
          uint64_t v43 = 0LL;
          unint64_t v42 = atomic_load(v22);
          goto LABEL_85;
        }
      }

      __clrex();
LABEL_58:
      int v38 = 0;
      goto LABEL_59;
    }

    uint64_t v41 = __CFDataAllocate((uint64_t)v21, v21[3], (int)v6);
    v21[5] = (unint64_t)v41;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      uint64_t v41 = (void *)v21[5];
    }

    if (!v41)
    {
      CFRelease(v21);
      return 0LL;
    }

    unint64_t v42 = atomic_load(v22);
    uint64_t v43 = 64LL;
    if ((_DWORD)v6) {
      uint64_t v43 = 0LL;
    }
LABEL_85:
    while (1)
    {
      unint64_t v47 = __ldaxr(v22);
      if (v47 != v42) {
        break;
      }
      if (__stlxr(v42 & 0xFFFFFFFFFFFFFFBFLL | v43, v22)) {
        goto LABEL_89;
      }
      int v48 = 1;
LABEL_90:
      unint64_t v42 = v47;
      if (v48)
      {
        v21[4] = 0LL;
        v53.CFIndex location = 0LL;
        v53.CFIndex length = 0LL;
        CFDataReplaceBytes((CFMutableDataRef)v21, v53, a4, a5);
        if ((a2 & 1) != 0) {
          return v21;
        }
LABEL_92:
        unint64_t v49 = atomic_load(v22);
        while (2)
        {
          unint64_t v50 = __ldaxr(v22);
          if (v50 == v49)
          {
            if (!__stlxr(v49 & 0xFFFFFFFFFFFFFFFCLL, v22))
            {
              int v51 = 1;
              goto LABEL_98;
            }
          }

          else
          {
            __clrex();
          }

          int v51 = 0;
LABEL_98:
          unint64_t v49 = v50;
          if (v51) {
            return v21;
          }
          continue;
        }
      }
    }

    __clrex();
LABEL_89:
    int v48 = 0;
    goto LABEL_90;
  }

  Instance[5] = (unint64_t)a4;
  Instance[4] = (unint64_t)CFRetain(v6);
  v21[2] = a5;
  if ((a2 & 1) == 0) {
    goto LABEL_92;
  }
  return v21;
}

    unint64_t v33 = 0LL;
    goto LABEL_96;
  }

  uint64_t v43 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], @"default");
  unint64_t v33 = v43;
  if (!v43) {
    goto LABEL_96;
  }
  unint64_t v44 = CFGetTypeID(v43);
  if (v44 != CFDictionaryGetTypeID()) {
    goto LABEL_84;
  }
  unint64_t v45 = (const __CFDictionary *)CFDictionaryGetValue(v33, @"default");
  unint64_t v33 = v45;
  if (v45)
  {
    int v38 = CFGetTypeID(v45);
    uint64_t v39 = CFStringGetTypeID();
LABEL_81:
    if (v38 != v39) {
      unint64_t v33 = 0LL;
    }
  }

CFDataRef CFDataCreateWithBytesNoCopy( CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  CFAllocatorRef v4 = bytesDeallocator;
  if (!bytesDeallocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      CFAllocatorRef v4 = (CFAllocatorRef)v8;
    }
    else {
      CFAllocatorRef v4 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, v4);
}

BOOL __CFDataShouldUseAllocator(__objc2_class **a1)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1) {
      a1 = &__kCFAllocatorSystemDefault;
    }
  }

  return a1 != &__kCFAllocatorSystemDefault && a1 != &__kCFAllocatorMalloc && a1 != &__kCFAllocatorMallocZone;
}

unint64_t *_CFDataCreateFixedMutableWithBuffer( __objc2_class **a1, unint64_t a2, const UInt8 *a3, const void *a4)
{
  return __CFDataInit(a1, 1, a2, a3, 0LL, a4);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  if (capacity) {
    char v3 = 1;
  }
  else {
    char v3 = 3;
  }
  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v3, capacity, 0LL, 0LL, 0LL);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  else {
    CFIndex v7 = *((void *)theData + 2);
  }
  if (capacity) {
    char v8 = 1;
  }
  else {
    char v8 = 3;
  }
  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v8, capacity, BytePtr, v7, 0LL);
}

unint64_t _CFDataGetBytePtrNonObjC(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) != 0) {
    return (a1 + 63) & 0xFFFFFFFFFFFFFFF0LL;
  }
  else {
    return *(void *)(a1 + 40);
  }
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  char v3 = atomic_load((unint64_t *)theData + 1);
  if ((v3 & 4) != 0) {
    return (UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0LL);
  }
  else {
    return (UInt8 *)*((void *)theData + 5);
  }
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  size_t length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData getBytes:range:](theData, "getBytes:range:", buffer, location, length);
  }

  else
  {
    if (location < 0)
    {
      uint64_t v11 = dyld_program_sdk_at_least();
      if ((_DWORD)v11) {
        CFDataGetBytes_cold_7(v11, v12, v13);
      }
      uint64_t v20 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
        CFDataGetBytes_cold_8();
      }
    }

    else
    {
      CFIndex v7 = *((void *)theData + 2);
      if (location <= v7)
      {
        if ((length & 0x8000000000000000LL) != 0)
        {
          uint64_t v17 = dyld_program_sdk_at_least();
          if ((_DWORD)v17) {
            CFDataGetBytes_cold_5(v17, v18, v19);
          }
          uint64_t v22 = (os_log_s *)_CFOSLog();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
            CFDataGetBytes_cold_6();
          }
        }

        else if ((uint64_t)(location + length) > v7)
        {
          uint64_t v14 = dyld_program_sdk_at_least();
          if ((_DWORD)v14) {
            CFDataGetBytes_cold_3(v14, v15, v16);
          }
          unint64_t v23 = (os_log_s *)_CFOSLog();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
            CFDataGetBytes_cold_4();
          }
        }
      }

      else
      {
        uint64_t v8 = dyld_program_sdk_at_least();
        if ((_DWORD)v8) {
          CFDataGetBytes_cold_1(v8, v9, v10);
        }
        uint64_t v21 = (os_log_s *)_CFOSLog();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
          CFDataGetBytes_cold_2();
        }
      }
    }

    char v24 = atomic_load((unint64_t *)theData + 1);
    if ((v24 & 4) != 0) {
      unint64_t v25 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0LL;
    }
    else {
      unint64_t v25 = *((void *)theData + 5);
    }
    memmove(buffer, (const void *)(v25 + location), length);
  }

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData setLength:](theData, "setLength:", length);
    return;
  }

  uint64_t v4 = *((void *)theData + 2);
  char v5 = (unint64_t *)((char *)theData + 8);
  char v6 = atomic_load((unint64_t *)theData + 1);
  char v7 = atomic_load((unint64_t *)theData + 1);
  if ((v7 & 1) != 0)
  {
    if (length < 0)
    {
      if ((v6 & 2) != 0) {
        __CFDataHandleOutOfMemory(length);
      }
      __break(1u);
      goto LABEL_26;
    }

    if (*((void *)theData + 3) < length)
    {
      if ((v6 & 2) != 0)
      {
        __CFDataGrow((unint64_t *)theData, length - v4, 1);
        goto LABEL_23;
      }

LABEL_26:
      CFDataSetLength_cold_1();
    }

    if (length > v4)
    {
      char v8 = atomic_load(v5);
      if ((v8 & 0x40) != 0)
      {
        char v12 = atomic_load(v5);
        if ((v12 & 4) != 0) {
          unint64_t v13 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0LL;
        }
        else {
          unint64_t v13 = *((void *)theData + 5);
        }
        bzero((void *)(v13 + v4), length - v4);
        goto LABEL_23;
      }
    }

    if (length < v4)
    {
      unint64_t v9 = atomic_load(v5);
      while (1)
      {
        unint64_t v10 = __ldaxr(v5);
        if (v10 != v9) {
          break;
        }
        if (__stlxr(v9 | 0x40, v5)) {
          goto LABEL_16;
        }
        int v11 = 1;
LABEL_17:
        unint64_t v9 = v10;
        if (v11) {
          goto LABEL_23;
        }
      }

      __clrex();
LABEL_16:
      int v11 = 0;
      goto LABEL_17;
    }
  }

  if (v11)
  {
    uint64_t v20 = CFURLCopyAbsoluteURL(v10);
    uint64_t v21 = CFURLCopyFileSystemPath(v20, kCFURLPOSIXPathStyle);
    CFRelease(v20);
    os_unfair_lock_lock_with_options();
    if (!*((void *)bundle + 13)) {
      *((void *)bundle + 13) = CFRetain(v21);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    CFRelease(v21);
  }

  if (!a6)
  {
    if (!a7) {
      goto LABEL_36;
    }
    if (v15) {
      goto LABEL_32;
    }
LABEL_34:
    st_uid = v22.st_uid;
    goto LABEL_35;
  }

  if (!v15)
  {
    *a6 = CFDateCreate( a1,  (double)v22.st_mtimespec.tv_sec - 978307200.0 + (double)v22.st_mtimespec.tv_nsec * 0.000000001);
    if (!a7) {
      goto LABEL_36;
    }
    goto LABEL_34;
  }

  *a6 = 0LL;
  if (a7)
  {
LABEL_32:
    st_uid = -1;
LABEL_35:
    *a7 = st_uid;
  }

  switch(v10)
  {
    case 1LL:
      if (v12)
      {
        if (v13)
        {
          uint64_t v20 = *(double *)v11;
          uint64_t v21 = 127.0;
          LODWORD(v22) = (int)v21;
          unint64_t v23 = v20 < -128.0;
        }

        else
        {
          uint64_t v52 = *(float *)v11;
          CFRange v53 = 127.0;
          LODWORD(v22) = (int)v53;
          unint64_t v23 = v52 < -128.0;
        }

        if (v23) {
          LOBYTE(v22) = 0x80;
        }
LABEL_108:
        *(_BYTE *)a3 = v22;
        return result;
      }

      uint64_t v40 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v40 > 0 || (uint64_t v22 = *(void *)(v11 + 8), v40 == 0.0) && v22 > 0x7F)
        {
          LOBYTE(v22) = 127;
        }

        else
        {
          if (v22 < 0xFFFFFFFFFFFFFF80LL && *(void *)&v40 == -1LL) {
            LOBYTE(v22) = 0x80;
          }
        }

        goto LABEL_108;
      }

      int v68 = 127LL;
      if (v68 <= -128) {
        LOBYTE(v68) = 0x80;
      }
      *(_BYTE *)a3 = v68;
      return result;
    case 2LL:
      if (v12)
      {
        if (v13)
        {
          char v24 = *(double *)v11;
          unint64_t v25 = 32767.0;
          LODWORD(v26) = (int)v25;
          unint64_t v27 = v24 < -32768.0;
        }

        else
        {
          uint64_t v54 = *(float *)v11;
          char v55 = 32767.0;
          LODWORD(v26) = (int)v55;
          unint64_t v27 = v54 < -32768.0;
        }

        if (v27) {
          LOWORD(v26) = 0x8000;
        }
LABEL_114:
        *(_WORD *)a3 = v26;
        return result;
      }

      uint64_t v41 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v41 > 0 || (int v26 = *(void *)(v11 + 8), v41 == 0.0) && v26 >> 15)
        {
          LOWORD(v26) = 0x7FFF;
        }

        else
        {
          if (v26 < 0xFFFFFFFFFFFF8000LL && *(void *)&v41 == -1LL) {
            LOWORD(v26) = 0x8000;
          }
        }

        goto LABEL_114;
      }

      unint64_t v69 = 0x7FFFLL;
      if (v69 <= -32768) {
        LOWORD(v69) = 0x8000;
      }
      *(_WORD *)a3 = v69;
      return result;
    case 3LL:
      if (v12)
      {
        if (v13)
        {
          unint64_t v28 = *(double *)v11;
          int v29 = 2147483650.0;
          LODWORD(v11) = (int)v29;
          unint64_t v30 = v28 < -2147483650.0;
        }

        else
        {
          char v56 = *(float *)v11;
          char v57 = 2147500000.0;
          LODWORD(v11) = (int)v57;
          unint64_t v30 = v56 < -2147500000.0;
        }

        char v58 = 0x80000000;
        goto LABEL_119;
      }

      unint64_t v42 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v42 > 0 || (int v11 = *(void *)(v11 + 8), v42 == 0.0) && v11 >> 31)
        {
          LODWORD(v11) = 0x7FFFFFFF;
        }

        else
        {
          if (v11 < 0xFFFFFFFF80000000LL && *(void *)&v42 == -1LL) {
            LODWORD(v11) = 0x80000000;
          }
        }

        goto LABEL_130;
      }

      unint64_t v70 = 0x7FFFFFFFLL;
      *(_DWORD *)a3 = v70;
      return result;
    case 4LL:
      if (v12)
      {
        if (v13)
        {
          unint64_t v31 = *(double *)v11;
          char v32 = 9.22337204e18;
          unint64_t v33 = (uint64_t)v32;
          unint64_t v34 = v31 < -9.22337204e18;
        }

        else
        {
          unint64_t v59 = *(float *)v11;
          unint64_t v60 = 9.2234e18;
          unint64_t v33 = (uint64_t)v60;
          unint64_t v34 = v59 < -9.2234e18;
        }

        unint64_t v61 = 0x8000000000000000LL;
        goto LABEL_126;
      }

      uint64_t v43 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v43 > 0 || (unint64_t v33 = *(void *)(v11 + 8), v43 == 0.0) && v33 < 0)
        {
          unint64_t v33 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else
        {
          if (v33 > -1 && *(void *)&v43 == -1LL) {
            unint64_t v33 = 0x8000000000000000LL;
          }
        }

        goto LABEL_128;
      }

      *(double *)a3 = v43;
      return result;
    case 5LL:
      if (v12)
      {
        if (v13)
        {
          int v35 = *(double *)v11;
          if (fabs(*(double *)v11) != INFINITY)
          {
            unint64_t v36 = 3.40282347e38;
            if (v35 <= 3.40282347e38) {
              unint64_t v36 = *(double *)v11;
            }
            unint64_t v37 = v36;
            unint64_t v23 = v35 < -3.40282347e38;
            int v38 = -3.4028e38;
            if (!v23) {
              int v38 = v37;
            }
LABEL_158:
            *(float *)a3 = v38;
            return result;
          }

          unint64_t v30 = v35 < 0.0;
          LODWORD(v11) = 2139095040;
          char v58 = -8388608;
LABEL_119:
          if (v30) {
            LODWORD(v11) = v58;
          }
        }

        else
        {
          LODWORD(v11) = *(_DWORD *)v11;
        }

  uint64_t v20 = _Block_copy(block);
  uint64_t v21 = v20;
  if (Copy && v20)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    uint64_t v22 = malloc(0x18uLL);
    *uint64_t v22 = 0LL;
    v22[1] = Copy;
    v22[2] = v21;
    unint64_t v23 = (void *)*((void *)rl + 81);
    if (!v23) {
      unint64_t v23 = (void *)((char *)rl + 640);
    }
    *unint64_t v23 = v22;
    *((void *)rl + 81) = v22;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }

  else
  {
    if (Copy) {
      CFRelease(Copy);
    }
    if (v21) {
      _Block_release(v21);
    }
  }

  __break(1u);
  return result;
}

    char v32 = *v30;
LABEL_32:
    memmove(&v32[2 * length], chars, 2 * numChars);
    return;
  }

  if (numChars < 1)
  {
    uint64_t v41 = length;
    unint64_t v42 = 0LL;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v41, 1LL, numChars, 0);
  }

  else
  {
    unint64_t v25 = 0LL;
    do
      int v26 = chars[v25++];
    while (v26 <= 0x7F && v25 < numChars);
    uint64_t v41 = length;
    unint64_t v42 = 0LL;
    __CFStringChangeSizeMultiple((char *)theString, (uint64_t)&v41, 1LL, numChars, v26 > 0x7F);
    if (v26 >= 0x80)
    {
      unint64_t v28 = &theString->info;
      int v29 = atomic_load((unint64_t *)&theString->info);
      unint64_t v30 = &theString->data;
      if ((v29 & 0x60) == 0) {
        goto LABEL_31;
      }
      goto LABEL_26;
    }
  }

  unint64_t v33 = atomic_load((unint64_t *)&theString->info);
  unint64_t v34 = &theString->data;
  if ((v33 & 0x60) != 0)
  {
    int v35 = *v34;
  }

  else
  {
    unint64_t v37 = atomic_load((unint64_t *)&theString->info);
    int v35 = (char *)&v34[(v37 & 5) != 4LL];
  }

  int v38 = atomic_load((unint64_t *)&theString->info);
  if (numChars >= 1)
  {
    uint64_t v39 = &v35[length + ((v38 >> 2) & 1)];
    do
    {
      uint64_t v40 = *(_BYTE *)chars++;
      *v39++ = v40;
      --numChars;
    }

    while (numChars);
  }

      __s1 += v9;
      unint64_t v13 = __OFADD__(v3, v8);
      v3 += v8;
      if ((v3 < 0) ^ v13 | (v3 == 0)) {
        return v5;
      }
    }
  }

  return 0LL;
}

    *(void *)&encoding = encoding | 0x80000000;
    goto LABEL_36;
  }

  if ((encoding & 0xFFF) > 0x81F)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v1 == 2817)
      {
        *(void *)&encoding = 2LL;
        goto LABEL_36;
      }

      if (v1 == 3071)
      {
        *(void *)&encoding = 7LL;
        goto LABEL_36;
      }
    }

    else
    {
      if (v1 == 2080)
      {
        *(void *)&encoding = 21LL;
        goto LABEL_36;
      }

      if (v1 == 2336)
      {
        *(void *)&encoding = 3LL;
        goto LABEL_36;
      }
    }

    goto LABEL_26;
  }

  *(void *)&encoding = 12LL;
  switch(v1)
  {
    case 0x500u:
      break;
    case 0x501u:
      *(void *)&encoding = 15LL;
      break;
    case 0x502u:
      *(void *)&encoding = 11LL;
      break;
    case 0x503u:
      *(void *)&encoding = 13LL;
      break;
    case 0x504u:
      *(void *)&encoding = 14LL;
      break;
    default:
      goto LABEL_26;
  }

    CFRelease(v130);
    goto LABEL_27;
  }

  CFRelease(v18);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
LABEL_30:
  Collator = __CFStringCreateCollator(a8);
  _CFSetTSD(0x11u, 0LL, 0LL);
  uint64_t v126 = 1;
  if (v15 < 0) {
    goto LABEL_32;
  }
LABEL_31:
  unint64_t v25 = *((void *)buffer + 20);
  if (v15 + a3 <= v25)
  {
    unint64_t v27 = *((void *)buffer + 17);
    if (v27)
    {
      p_dst = (UniChar *)(v27 + 2LL * *((void *)buffer + 19) + 2 * v15);
      if (v16 < 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }

    if (a3 <= 64)
    {
      if (v15 + a3 > *((void *)buffer + 22) || (unint64_t v28 = *((void *)buffer + 21), v15 < v28))
      {
        if (v15 + 64 < v25) {
          unint64_t v25 = v15 + 64;
        }
        *((void *)buffer + 21) = v15;
        *((void *)buffer + 22) = v25;
        v29.size_t length = v25 - v15;
        unint64_t v31 = *((void *)buffer + 18);
        unint64_t v30 = *((void *)buffer + 19);
        if (v31)
        {
          unint64_t v28 = v15;
          if (v29.length)
          {
            char v32 = v31 + v30;
            unint64_t v33 = buffer;
            do
            {
              *v33++ = *(char *)(v32 + v15);
              ++v32;
              --v25;
            }

            while (v15 != v25);
            unint64_t v28 = v15;
          }
        }

        else
        {
          v29.CFIndex location = v30 + v15;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v29, buffer);
          unint64_t v28 = *((void *)buffer + 21);
        }
      }

      p_dst = &buffer[v15 - v28];
      if (v16 < 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
  }

    uint64_t v14 = CFURLCreateStringWithFileSystemPath(v9, (__objc2_class **)url, 0LL, v6);
    if (v14)
    {
      uint64_t v15 = v14;
      FileSystemRepresentatiouint64_t n = CFStringGetFileSystemRepresentation(v14, (char *)buffer, maxBufLen);
      CFRelease(v15);
      return FileSystemRepresentation;
    }

    return 0;
  }

  uint64_t v18 = (const __CFString *)atomic_load((unint64_t *)url + 3);
  return CanonicalFileURLStringToFileSystemRepresentation(v18, buffer, maxBufLen);
}

  uint64_t v18 = &v9[v10];
  uint64_t v19 = v9;
  while (2)
  {
    uint64_t v20 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v18 - v19)) >> 1;
    uint64_t v21 = &v19[17 * v20];
    uint64_t v22 = *v21;
    if (v22 > v14)
    {
      uint64_t v18 = v21 - 17;
      goto LABEL_31;
    }

    if (v22 + 16 <= v14)
    {
      uint64_t v19 = v21 + 17;
LABEL_31:
      if (v19 > v18) {
        goto LABEL_32;
      }
      continue;
    }

    break;
  }

  int v26 = &v19[17 * v20];
  unint64_t v27 = v26[v14 - v22 + 1];
  if (!v26[v14 - v22 + 1])
  {
LABEL_32:
LABEL_83:
    uint64_t v41 = v14 - 57344;
    unint64_t v42 = (v14 - 57344) / 0xBC;
    uint64_t v43 = v14 + 68 * v42;
    if (v41 - 188 * v42 <= 0x3E) {
      unint64_t v44 = v43;
    }
    else {
      unint64_t v44 = v43 + 1;
    }
    char v7 = v12 + 2;
    if (a5)
    {
      if (v7 > a5) {
        goto LABEL_238;
      }
      *(_WORD *)a4 = bswap32(v44 + 4160) >> 16;
      a4 += 2;
    }

    goto LABEL_232;
  }

  if (v27 <= 0xFF)
  {
    char v7 = v12 + 1;
    if (a5) {
      *a4++ = v27;
    }
    goto LABEL_232;
  }

  if ((v27 & 0x8000) != 0)
  {
    if ((unsigned __int16)(v14 + 0x2000) >= 0x98Cu)
    {
      if (v27 == 65533) {
        goto LABEL_33;
      }
      goto LABEL_238;
    }

    goto LABEL_83;
  }

  char v7 = v12 + 2;
  if (!a5) {
    goto LABEL_232;
  }
  if (v7 <= a5)
  {
    if ((v27 & 0x100) != 0) {
      unint64_t v60 = 31;
    }
    else {
      unint64_t v60 = 125;
    }
    unint64_t v61 = v60 + (v27 & 0x7F);
    int v62 = ((v27 >> 8) + 479) >> 1;
    unint64_t v63 = v62 - 127;
    unint64_t v64 = (v62 - 127);
    if (v61 > 0x7E) {
      LOBYTE(v61) = v61 + 1;
    }
    int v65 = v62 - 63;
    if (v64 <= 0x9F) {
      int v65 = v63;
    }
    *a4 = v65;
    a4[1] = v61;
    a4 += 2;
    goto LABEL_232;
  }

    *((void *)v13 + v11) = a1;
    __dmb(0xBu);
    a1 = ((((unint64_t)(16 * v19) >> 4) & 0xFFFFFFF) << 7) | 0x8000000000000000LL;
    uint64_t v18 = *MEMORY[0x189616658] ^ a1;
    if ((~v18 & 0xC000000000000007LL) != 0) {
      return v18 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (*MEMORY[0x189616658] & 7LL));
    }
    return a1;
  }

  __break(1u);
  return result;
}

      v42[0] = xmmword_180D7E290;
      v42[1] = xmmword_180D7E2A0;
      uint64_t v43 = 16LL;
      uint64_t v39 = xmmword_180D7E290;
      uint64_t v40 = xmmword_180D7E2B0;
      uint64_t v41 = 512LL;
      if ((uint64_t)unit <= 4095)
      {
        if (unit != 512)
        {
          if (unit != 1024)
          {
LABEL_42:
            uint64_t v21 = &qword_180D7E2C0;
            uint64_t v22 = 4LL;
LABEL_43:
            int v26 = 0LL;
            unint64_t v27 = v21;
            unint64_t v28 = v22;
            do
            {
              int v29 = *v27++;
              v26 |= v29;
              --v28;
            }

            while (v28);
            unint64_t v30 = -[NSCalendar components:fromDate:](self, "components:fromDate:", v26, date1, v39, v40, v41);
            unint64_t v31 = -[NSCalendar components:fromDate:](self, "components:fromDate:", v26, date2);
            char v32 = v22 - 1;
            while (1)
            {
              unint64_t v33 = v32;
              unint64_t v34 = -[NSDateComponents valueForComponent:](v30, "valueForComponent:", *v21);
              int v35 = -[NSDateComponents valueForComponent:](v31, "valueForComponent:", *v21);
              if (v34 > v35) {
                return 1LL;
              }
              if (v34 < v35) {
                return -1LL;
              }
              if (*v21 == 8
                && -[NSString isEqualToString:]( -[NSCalendar calendarIdentifier](self, "calendarIdentifier"),  "isEqualToString:",  @"chinese"))
              {
                unint64_t v36 = -[NSDateComponents isLeapMonth](v30, "isLeapMonth");
                unint64_t v37 = -[NSDateComponents isLeapMonth](v31, "isLeapMonth");
                if (!v36 && v37) {
                  return -1LL;
                }
                if (v36 && !v37) {
                  return 1LL;
                }
              }

              uint64_t result = NSOrderedSame;
              int v38 = *v21++;
              if (v38 != unit)
              {
                char v32 = v33 - 1;
                if (v33) {
                  continue;
                }
              }

              return result;
            }
          }

          uint64_t v21 = (uint64_t *)v42;
LABEL_41:
          uint64_t v22 = 5LL;
          goto LABEL_43;
        }
      }

      else if (unit != 4096)
      {
        uint64_t v21 = &qword_180D7E2E0;
        uint64_t v22 = 4LL;
        if (unit == 0x2000 || unit == 0x4000) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }

      uint64_t v21 = (uint64_t *)&v39;
      goto LABEL_41;
    }

    *(void *)&v42[0] = 0LL;
    *(void *)&uint64_t v39 = 0LL;
    -[NSCalendar rangeOfUnit:startDate:interval:forDate:]( self,  "rangeOfUnit:startDate:interval:forDate:",  unit,  v42,  &v39,  date1);
    [*(id *)&v42[0] timeIntervalSinceReferenceDate];
    char v24 = v23;
    -[NSDate timeIntervalSinceReferenceDate](date2, "timeIntervalSinceReferenceDate");
    if (v24 > v25 || v25 >= v24 + *(double *)&v39)
    {
      if (v25 < v24) {
        return 1LL;
      }
      else {
        return -1LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    if ((uint64_t)unit < 0x100000)
    {
      if (unit == 128 || unit == 0x8000)
      {
        -[NSDate timeIntervalSinceReferenceDate](date1, "timeIntervalSinceReferenceDate");
        -[NSDate timeIntervalSinceReferenceDate](date2, "timeIntervalSinceReferenceDate", modf(v12, (double *)v42));
        modf(v13, (double *)&v39);
        uint64_t v14 = *(double *)v42;
        uint64_t v15 = *(double *)&v39;
LABEL_17:
        uint64_t v17 = NSOrderedAscending;
        if (v15 < v14) {
          uint64_t v17 = NSOrderedDescending;
        }
        uint64_t v16 = v14 == v15;
LABEL_20:
        if (v16) {
          return 0LL;
        }
        else {
          return v17;
        }
      }

      goto LABEL_26;
    }

    uint64_t result = NSOrderedSame;
    if (unit != 0x100000 && unit != 0x200000) {
      goto LABEL_26;
    }
  }

  return result;
}

  ucnv_close();
  return 0LL;
}

  __break(1u);
  return result;
}

    if (v6 <= v12 + v9) {
      uint64_t v20 = v6;
    }
    else {
      uint64_t v20 = 0LL;
    }
    char v12 = v12 + v9 - v20;
    if (!--v15) {
      goto LABEL_32;
    }
  }

  uint64_t v17 = a2;
LABEL_39:
  uint64_t v21 = v25;
  *unint64_t v25 = v12;
  unint64_t v23 = *(void *)(*(void *)(a1 + 40) + 8 * v12);
  if (v23 == 2814029233LL)
  {
    unint64_t v23 = 0LL;
  }

  else if (v23 == 2780474809LL)
  {
    unint64_t v23 = -1LL;
  }

  v25[1] = v17;
  v25[2] = v23;
  char v24 = *(unsigned __int16 *)(a1 + 18);
  if ((v24 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  uint64_t v16 = 1LL;
LABEL_33:
  void v21[3] = v16;
  return result;
}

    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = 0;
      return result;
    }

    return 0LL;
  }

  if (CFNumberIsFloatType((CFNumberRef)cf))
  {
    uint64_t Value = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, v9);
    if (a2) {
      *a2 = Value;
    }
    char v7 = v9[0] == 0.0;
  }

  else
  {
    char v8 = CFNumberGetValue((CFNumberRef)cf, kCFNumberCFIndexType, v9);
    if (a2) {
      *a2 = v8;
    }
    char v7 = *(void *)&v9[0] == 0LL;
  }

  return !v7;
}

void __CFDataGrow(unint64_t *cf, int64_t a2, int a3)
{
  int64_t v3 = cf[2];
  unint64_t v4 = v3 + a2;
  if (v4 >= 0x10)
  {
    if (v4 >> 20)
    {
      if (HIDWORD(v4))
      {
        char v10 = flsl(0x20000000LL);
        if ((v4 >> (v10 - 1) << 29) + 0x20000000 >= 0x3FFFFFFFFFFLL) {
          uint64_t v8 = 0x3FFFFFFFFFFLL;
        }
        else {
          uint64_t v8 = (v4 >> (v10 - 1) << 29) + 0x20000000;
        }
      }

      else
      {
        uint64_t v8 = 1LL << flsl(v3 + a2);
      }
    }

    else
    {
      char v9 = flsl(v3 + a2);
      uint64_t v8 = 1LL << ((v9 & 1u) + v9);
    }
  }

  else
  {
    uint64_t v8 = 16LL;
  }

  int v11 = (malloc_zone_t *)CFGetAllocator(cf);
  char v12 = (void *)cf[5];
  if (!a3
    || (char v13 = atomic_load(cf + 1), v8 <= 0x20000)
    || (v13 & 8) != 0
    || (char v14 = atomic_load(cf + 1), (v14 & 8) != 0)
    || v3 && (uint64_t)v4 / v3 < 5
    || (uint64_t v15 = (char *)__CFDataAllocate((uint64_t)cf, v8, 1)) == 0LL)
  {
    char v18 = atomic_load(cf + 1);
    if ((v18 & 8) != 0) {
      uint64_t v19 = (char *)__CFSafelyReallocateWithAllocator(v11, v12, v8, 0LL, 0LL);
    }
    else {
      uint64_t v19 = (char *)__CFSafelyReallocate(v12, v8, 0LL);
    }
    uint64_t v16 = v19;
    if (!v19) {
      __CFDataHandleOutOfMemory(v8);
    }
    uint64_t v17 = 64LL;
    if (a3 && a2 >= 1)
    {
      bzero(&v19[v3], a2);
      uint64_t v17 = 64LL;
    }
  }

  else
  {
    uint64_t v16 = v15;
    memmove(v15, v12, v3);
    __CFDataDeallocate((uint64_t)cf);
    uint64_t v17 = 0LL;
  }

  cf[3] = v8;
  uint64_t v20 = cf + 1;
  unint64_t v21 = atomic_load(cf + 1);
  do
  {
    unint64_t v22 = __ldaxr(v20);
    if (v22 == v21)
    {
      if (!__stlxr(v21 & 0xFFFFFFFFFFFFFFBFLL | v17, v20))
      {
        int v23 = 1;
        goto LABEL_32;
      }
    }

    else
    {
      __clrex();
    }

    int v23 = 0;
LABEL_32:
    unint64_t v21 = v22;
  }

  while (!v23);
  cf[5] = (unint64_t)v16;
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData increaseLengthBy:](theData, "increaseLengthBy:", extraLength);
  }

  else if (extraLength < 0)
  {
    __break(1u);
  }

  else
  {
    CFDataSetLength(theData, *((void *)theData + 2) + extraLength);
  }

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData appendBytes:length:](theData, "appendBytes:length:", bytes, length);
  }

  else
  {
    v6.CFIndex location = *((void *)theData + 2);
    v6.size_t length = 0LL;
    CFDataReplaceBytes(theData, v6, bytes, length);
  }

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData replaceBytesInRange:withBytes:length:]( theData,  "replaceBytesInRange:withBytes:length:",  location,  length,  0LL,  0LL);
  }

  else
  {
    v5.CFIndex location = location;
    v5.CFIndex length = length;
    CFDataReplaceBytes(theData, v5, 0LL, 0LL);
  }

uint64_t _CFDataFindBytes( const __CFData *a1, const __CFData *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  BytePtr = CFDataGetBytePtr(a1);
  int v11 = (unsigned __int8 *)CFDataGetBytePtr(a2);
  else {
    uint64_t v12 = *((void *)a1 + 2);
  }
  else {
    unint64_t v13 = *((void *)a2 + 2);
  }
  uint64_t v14 = ((a5 << 63 >> 63) & (a4 - v13)) + a3;
  if (a4 > v13)
  {
    unint64_t v15 = v13;
  }

  else
  {
    uint64_t v14 = a3;
    unint64_t v15 = a4;
  }

  if ((a5 & 2) != 0)
  {
    a3 = v14;
    unint64_t v16 = v15;
  }

  else
  {
    unint64_t v16 = a4;
  }

  if (v16 >= v12 - a3) {
    unint64_t v16 = v12 - a3;
  }
  uint64_t result = -1LL;
  if (v13 - 1 < v16 && v12)
  {
    unint64_t v18 = (unint64_t)&BytePtr[a3];
    uint64_t v19 = __CFDataSearchBoyerMoore(v18, v16, v11, v13, a5 & 1);
    if (v19) {
      return (uint64_t)&v19[a3 - v18];
    }
    else {
      return -1LL;
    }
  }

  return result;
}

unsigned __int8 *__CFDataSearchBoyerMoore( unint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  bzero(v52, 0x800uLL);
  if (a4 >> 60) {
    goto LABEL_65;
  }
  uint64_t v12 = MEMORY[0x1895F8858](v10, v11);
  unint64_t v15 = (uint64_t *)&v50[-v14];
  if (a4 <= 0x100)
  {
    MEMORY[0x1895F8858](v12, v13);
    unint64_t v16 = (uint64_t *)&v50[-((8 * a4 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    goto LABEL_7;
  }

  uint64_t v17 = (uint64_t *)malloc(8 * a4);
  if (!v17 || (unint64_t v15 = v17, (v18 = (uint64_t *)malloc(8 * a4)) == 0LL)) {
LABEL_65:
  }
    __CFDataHandleOutOfMemory(8 * a4);
  unint64_t v16 = v18;
LABEL_7:
  int64x2_t v19 = vdupq_n_s64(a4);
  uint64_t v20 = 0LL;
  if (a5)
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16LL;
    }

    while (v20 != 2048);
    int v51 = a5;
    uint64_t v21 = (a4 - 1);
    if ((int)a4 - 1 >= 0)
    {
      int v22 = a4;
      do
      {
        *(void *)&v52[8 * a3[v21]] = v21;
        --v21;
        --v22;
      }

      while (v22);
    }

    int v23 = malloc(a4);
    if (!v23) {
      __CFDataHandleOutOfMemory(a4);
    }
    char v24 = v23;
    memmove(v23, a3, a4);
    unint64_t v25 = a4 - 1;
    if (a4 > 1)
    {
      uint64_t v35 = 0LL;
      if (a4 >> 1 <= 1) {
        uint64_t v36 = 1LL;
      }
      else {
        uint64_t v36 = a4 >> 1;
      }
      do
      {
        char v37 = v24[v35];
        v24[v35] = v24[v25];
        v24[v25] = v37;
        ++v35;
        --v25;
      }

      while (v36 != v35);
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
      int v38 = &v15[a4 - 1];
      uint64_t v39 = v15;
      do
      {
        uint64_t v40 = *v39;
        *v39++ = *v38;
        *v38-- = v40;
        --v36;
      }

      while (v36);
    }

    else
    {
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
    }

    free(v24);
    if (v51)
    {
      uint64_t v41 = &a3[a4];
      unint64_t v42 = (unsigned __int8 *)(a1 + a2 - a4);
      if ((unint64_t)v42 < a1 || (uint64_t)a4 < 1)
      {
        uint64_t v43 = a3;
      }

      else
      {
        uint64_t v43 = a3;
        do
        {
          uint64_t v44 = *v42;
          if ((_DWORD)v44 == *v43)
          {
            ++v42;
            ++v43;
          }

          else
          {
            unint64_t v45 = *(void *)&v52[8 * v44];
            unint64_t v46 = v15[v43 - a3];
            if (v45 > v46) {
              unint64_t v46 = v45;
            }
            v42 -= v46;
            uint64_t v43 = a3;
          }
        }

        while ((unint64_t)v42 >= a1 && v43 < v41);
      }

      if (v43 == v41) {
        int v48 = &v42[-a4];
      }
      else {
        int v48 = 0LL;
      }
      goto LABEL_62;
    }
  }

  else
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16LL;
    }

    while (v20 != 2048);
    if (a4)
    {
      unint64_t v26 = a4 - 1;
      unint64_t v27 = a3;
      do
      {
        int v28 = *v27++;
        *(void *)&v52[8 * v28] = v26--;
      }

      while (v26 != -1LL);
    }

    _computeGoodSubstringShift((uint64_t)a3, a4, v15, v16);
  }

  int v29 = (unsigned __int8 *)(a1 + a4 - 1);
  if ((unint64_t)v29 >= a1 + a2 || &a3[a4 - 1] < a3)
  {
    unint64_t v30 = &a3[a4 - 1];
  }

  else
  {
    unint64_t v30 = &a3[a4 - 1];
    do
    {
      uint64_t v31 = *v29;
      if ((_DWORD)v31 == *v30)
      {
        --v29;
        --v30;
      }

      else
      {
        unint64_t v32 = *(void *)&v52[8 * v31];
        unint64_t v33 = v15[v30 - a3];
        if (v32 > v33) {
          unint64_t v33 = v32;
        }
        v29 += v33;
        unint64_t v30 = &a3[a4 - 1];
      }
    }

    while ((unint64_t)v29 < a1 + a2 && v30 >= a3);
  }

  if (v30 < a3) {
    int v48 = v29 + 1;
  }
  else {
    int v48 = 0LL;
  }
LABEL_62:
  if (a4 >= 0x101)
  {
    free(v15);
    free(v16);
  }

  return v48;
}

CFRange CFDataFind( CFDataRef theData, CFDataRef dataToFind, CFRange searchRange, CFDataSearchFlags compareOptions)
{
  CFIndex length = searchRange.length;
  CFIndex location = searchRange.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    uint64_t v9 = -[__CFData length](theData, "length");
    if ((location & 0x8000000000000000LL) == 0) {
      goto LABEL_3;
    }
  }

  else
  {
    uint64_t v9 = *((void *)theData + 2);
    if ((location & 0x8000000000000000LL) == 0)
    {
LABEL_3:
      if (location <= v9)
      {
        if (length < 0)
        {
          uint64_t v19 = dyld_program_sdk_at_least();
          if ((_DWORD)v19) {
            CFDataFind_cold_5(v19, v20, v21);
          }
          char v24 = (os_log_s *)_CFOSLog();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
            CFDataFind_cold_6();
          }
        }

        else if (location + length > v9)
        {
          uint64_t v16 = dyld_program_sdk_at_least();
          if ((_DWORD)v16) {
            CFDataFind_cold_3(v16, v17, v18);
          }
          unint64_t v25 = (os_log_s *)_CFOSLog();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
            CFDataFind_cold_4();
          }
        }
      }

      else
      {
        uint64_t v10 = dyld_program_sdk_at_least();
        if ((_DWORD)v10) {
          CFDataFind_cold_1(v10, v11, v12);
        }
        int v23 = (os_log_s *)_CFOSLog();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
          CFDataFind_cold_2();
        }
      }

      goto LABEL_23;
    }
  }

  uint64_t v13 = dyld_program_sdk_at_least();
  if ((_DWORD)v13) {
    CFDataFind_cold_7(v13, v14, v15);
  }
  int v22 = (os_log_s *)_CFOSLog();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
    CFDataFind_cold_8();
  }
LABEL_23:
  CFIndex Bytes = _CFDataFindBytes(theData, dataToFind, location, length, compareOptions);
  result.CFIndex length = v27;
  result.CFIndex location = Bytes;
  return result;
}

uint64_t __CFDataGetBinaryPlistTopLevelInfo(void *a1, _BYTE *a2, unint64_t *a3, uint64_t a4)
{
  BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)a1);
  else {
    unint64_t v10 = a1[2];
  }
  return __CFBinaryPlistGetTopLevelInfo(BytePtr, v10, a2, a3, a4);
}

uint64_t _computeGoodSubstringShift(uint64_t result, int a2, void *a3, uint64_t *a4)
{
  uint64_t v4 = (a2 - 1);
  a4[(int)v4] = a2;
  if (a2 > 1)
  {
    uint64_t v5 = (a2 - 2);
    LODWORD(v6) = a2 - 1;
    int v7 = a2 - 1;
    do
    {
      if (v5 <= (int)v6 || (unint64_t v8 = a4[~v7 + a2 + (int)v5], v8 >= (int)v5 - (int)v6))
      {
        else {
          int v9 = v5;
        }
        if (v9 < 0)
        {
          LODWORD(v6) = v9;
        }

        else
        {
          uint64_t v6 = (int)v6;
          while (*(unsigned __int8 *)(result + v6) == *(unsigned __int8 *)(result + a2 - 1 - (int)v5 + (int)v6))
          {
            BOOL v10 = v6-- <= 0;
            if (v10)
            {
              LODWORD(v6) = -1;
              break;
            }
          }
        }

        unint64_t v8 = (int)v5 - (int)v6;
        int v7 = v5;
      }

      a4[v5] = v8;
      BOOL v10 = v5-- <= 0;
    }

    while (!v10);
  }

  if (a2 >= 1)
  {
    uint64_t v11 = (int)v4;
    uint64_t v12 = a2;
    uint64_t v13 = a3;
    do
    {
      *v13++ = a2;
      --v12;
    }

    while (v12);
    LODWORD(v14) = 0;
    uint64_t v15 = a2;
    do
    {
      uint64_t v16 = v15--;
      if (a4[v15] == v16 && (int)v4 - v15 > (int)v14)
      {
        uint64_t v14 = (int)v14;
        do
        {
          if (a3[v14] == a2) {
            a3[v14] = (int)v4 - v15;
          }
          ++v14;
        }

        while (v12 != v14);
        LODWORD(v14) = v12;
      }

      ++v12;
    }

    while (v12 != a2);
    if (a2 >= 2)
    {
      uint64_t v17 = (a2 - 1);
      uint64_t v18 = (int)v4;
      do
      {
        uint64_t v19 = *a4++;
        a3[(int)v4 - v19] = v18--;
        --v17;
      }

      while (v17);
      do
      {
        *a3++ += v11--;
        --v4;
      }

      while (v4);
    }
  }

  return result;
}

void OUTLINED_FUNCTION_0_3( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_3_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_4(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_5(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_6(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void sub_180A8B720( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

uint64_t __NSDictionaryI_new(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  unint64_t v6 = a4;
  uint64_t v10 = 0LL;
  uint64_t v29 = *MEMORY[0x1895F89C0];
  int v28 = a3;
  while (__NSDictionaryCapacities[v10] < a4)
  {
    if (++v10 == 64)
    {
      __break(1u);
      break;
    }
  }

  uint64_t v11 = __NSDictionarySizes[v10];
  uint64_t v12 = (objc_class *)objc_opt_self();
  uint64_t v13 = __CFAllocateObject(v12, 16 * v11);
  uint64_t v14 = v13;
  *(_BYTE *)(v13 + 15) = *(_BYTE *)(v13 + 15) & 3 | (4 * v10);
  *(void *)(v13 + _Block_object_dispose(va, 8) = *(void *)(v13 + 8) & 0xFE00000000000000LL | v6 & 0x1FFFFFFFFFFFFFFLL;
  *(_BYTE *)(v13 + 15) = *(_BYTE *)(v13 + 15) & 0xFD | a5 & 2;
  if (v6)
  {
    v21[0] = MEMORY[0x1895F87A8];
    v21[1] = 3221225472LL;
    int v22 = ____NSDictionaryI_new_block_invoke;
    int v23 = &unk_189996378;
    uint64_t v26 = v11;
    uint64_t v27 = a5;
    uint64_t v24 = v13;
    uint64_t v25 = v13 + 16;
    if (a3)
    {
      uint64_t v15 = *a1;
      uint64_t v16 = v28++;
      ____NSDictionaryI_new_block_invoke(v21, *v16, v15);
      if (v6 >= 2)
      {
        unint64_t v17 = v6 - 1;
        do
        {
          uint64_t v18 = v28++;
          uint64_t v19 = *v18;
          int v28 = v18 + 2;
          v22(v21, v18[1], v19);
          --v17;
        }

        while (v17);
      }
    }

    else
    {
      do
      {
        v22(v21, *a1++, *a2++);
        --v6;
      }

      while (v6);
    }
  }

  return v14;
}

void sub_180A8BE08(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    if (v2) {

    }
    objc_exception_rethrow();
    JUMPOUT(0x180A8BC98LL);
  }

  _Unwind_Resume(exception_object);
}

uint64_t _NSDictionaryI_mutableCopyWithZone(void *a1, uint64_t a2)
{
  v12[1] = *MEMORY[0x1895F89C0];
  unint64_t v3 = a1[1] & 0x1FFFFFFFFFFFFFFLL;
  if (v3) {
    uint64_t v4 = 2 * v3;
  }
  else {
    uint64_t v4 = 1LL;
  }
  unint64_t v5 = MEMORY[0x1895F8858](v4, a2);
  int v7 = (char *)v12 - v6;
  if (v3 >= 0x81)
  {
    int v7 = (char *)_CFCreateArrayStorage(v5, 0, v12);
    unint64_t v8 = v7;
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  [a1 getObjects:&v7[8 * v3] andKeys:v7 count:v3];
  __NSDictionaryM_new((uint64_t)v7, (uint64_t)&v7[8 * v3], v3, 2uLL);
  uint64_t v10 = v9;
  free(v8);
  return v10;
}

void sub_180A8C264(_Unwind_Exception *exception_object)
{
}

void sub_180A8C4CC(_Unwind_Exception *exception_object)
{
}

uint64_t _compare_clumpiness(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

CFURLRef _CFBundleCopyExecutableURLInDirectory(const __CFURL *a1)
{
  return _CFBundleCopyExecutableURLInDirectory2(0LL, a1, 0LL, 1);
}

CFURLRef _CFBundleCopyExecutableURLInDirectory2( CFBundleRef bundle, const __CFURL *a2, const __CFString *a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  char v23 = 0;
  if (bundle)
  {
    InfoDictionary = CFBundleGetInfoDictionary(bundle);
    char v23 = *((_BYTE *)bundle + 53);
    if (!a3 && !a4)
    {
      os_unfair_lock_lock_with_options();
      uint64_t v9 = (const __CFString *)*((void *)bundle + 13);
      if (v9)
      {
        CFRetain(*((CFTypeRef *)bundle + 13));
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
        CFURLRef v10 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
        CFRelease(v9);
        if (v10) {
          return v10;
        }
      }

      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
      }

      int v11 = 1;
LABEL_13:
      uint64_t v13 = _CFBundleCopyExecutableName(bundle, a2, InfoDictionary);
      if (!v13)
      {
        CFURLRef v10 = 0LL;
        goto LABEL_36;
      }

      uint64_t v12 = v13;
      if (!a2) {
        goto LABEL_31;
      }
      goto LABEL_15;
    }
  }

  else
  {
    InfoDictionary = _CFBundleCopyInfoDictionaryInDirectory( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a2,  &v23);
  }

  int v11 = 0;
  uint64_t v12 = a3;
  if (!a3) {
    goto LABEL_13;
  }
  if (!a2) {
    goto LABEL_31;
  }
LABEL_15:
  uint64_t v14 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
  if (v14)
  {
    CFStringRef v15 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, 0x8000100u);
    if (CFStringHasSuffix(v12, @".dylib"))
    {
      v25.CFIndex length = CFStringGetLength(v12) - 6;
      v25.CFIndex location = 0LL;
      CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v25);
      unint64_t v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@%@.dylib", v12, v15);
      CFRelease(v16);
    }

    else
    {
      unint64_t v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@%@", v12, v15);
    }

    uint64_t v18 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v17,  kCFURLPOSIXPathStyle,  0,  a2);
    CFURLRef v10 = v18;
    if (v18 && !_binaryLoadable(v18))
    {
      CFRelease(v10);
      CFURLRef v10 = 0LL;
    }

    CFRelease(v17);
    CFRelease(v15);
    if (v10) {
      goto LABEL_26;
    }
  }

  uint64_t v19 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v12,  kCFURLPOSIXPathStyle,  0,  a2);
  if (!v19)
  {
LABEL_31:
    CFURLRef v10 = 0LL;
    if (bundle && !a3)
    {
      CFURLRef v10 = 0LL;
      *((_DWORD *)bundle + 12) = 7;
LABEL_35:
      CFRelease(v12);
      goto LABEL_36;
    }

    goto LABEL_34;
  }

  CFURLRef v10 = v19;
  if (!_binaryLoadable(v19))
  {
    CFRelease(v10);
    goto LABEL_31;
  }

CFURLRef _CFBundleCopyOtherExecutableURLInDirectory(const __CFURL *a1)
{
  return _CFBundleCopyExecutableURLInDirectory2(0LL, a1, 0LL, 1);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((const __CFURL **)bundle + 2), 0LL, 0);
}

CFURLRef CFBundleCopyAuxiliaryExecutableURL(CFBundleRef bundle, CFStringRef executableName)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((const __CFURL **)bundle + 2), executableName, 1);
}

CFURLRef _CFBundleCopyBundleURLForExecutableURL(const __CFURL *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  char v1 = _CFBundleCopyResolvedURLForExecutableURL(a1);
  uint64_t v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (v2)
  {
    unint64_t v3 = v2;
    CFIndex Length = CFStringGetLength(v2);
    if (Length >= 1026) {
      CFIndex v5 = 1026LL;
    }
    else {
      CFIndex v5 = Length;
    }
    v20.CFIndex location = 0LL;
    v20.CFIndex length = v5;
    CFStringGetCharacters(v3, v20, buffer);
    uint64_t PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
    if (PathComponent >= 1)
    {
      uint64_t v7 = PathComponent;
      uint64_t v8 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (v8 < 1 || v7 <= v8) {
        goto LABEL_21;
      }
      CFStringRef v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8], v7 - v8);
      PlatformExecutablesSubdirectoryName = _CFBundleGetPlatformExecutablesSubdirectoryName();
      if (!CFEqual(v10, PlatformExecutablesSubdirectoryName))
      {
        CFRelease(v10);
        goto LABEL_21;
      }

      uint64_t v12 = _CFLengthAfterDeletingLastPathComponent(buffer, v7);
      if (v12 < 1)
      {
LABEL_16:
        CFURLRef v16 = 0LL;
LABEL_22:
        CFRelease(v10);
LABEL_24:
        CFRelease(v3);
        goto LABEL_25;
      }

      uint64_t v13 = v12;
      uint64_t v14 = _CFStartOfLastPathComponent(buffer, v12);
      if (v14 >= 1 && v13 > v14)
      {
        CFStringRef v15 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v14], v13 - v14);
        if (CFEqual(v15, @"Executables"))
        {
          uint64_t v13 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
          CFRelease(v15);
          if (v13 < 1) {
            goto LABEL_16;
          }
        }

        else
        {
          CFRelease(v15);
        }
      }

      uint64_t v7 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
      CFRelease(v10);
      if (v7 >= 1)
      {
LABEL_21:
        CFStringRef v10 = CFStringCreateWithCharactersNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  buffer,  v7,  (CFAllocatorRef)&__kCFAllocatorNull);
        CFURLRef v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, kCFURLPOSIXPathStyle, 1u);
        goto LABEL_22;
      }
    }

    CFURLRef v16 = 0LL;
    goto LABEL_24;
  }

  CFURLRef v16 = 0LL;
LABEL_25:
  CFRelease(v1);
  return v16;
}

CFURLRef _CFBundleCopyResolvedURLForExecutableURL(const __CFURL *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  char v1 = CFURLCopyAbsoluteURL(a1);
  uint64_t v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (!v2) {
    return v1;
  }
  unint64_t v3 = v2;
  CFIndex Length = CFStringGetLength(v2);
  if (Length >= 1026) {
    CFIndex v5 = 1026LL;
  }
  else {
    CFIndex v5 = Length;
  }
  v21.CFIndex location = 0LL;
  v21.CFIndex length = v5;
  CFStringGetCharacters(v3, v21, buffer);
  CFIndex PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
  if (PathComponent < 1 || PathComponent + 1 >= v5)
  {
    CFRelease(v3);
    return v1;
  }

  CFIndex v8 = PathComponent;
  uint64_t v9 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, PathComponent);
  CFStringRef v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8 + 1], v5 + ~v8);
  int v11 = v10;
  if (v9) {
    BOOL v12 = v10 == 0LL;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    CFURLRef v13 = 0LL;
    if (!v9)
    {
      if (!v10) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }

  else
  {
    CFStringRef v15 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 1u);
    if (v15)
    {
      CFURLRef v16 = v15;
      unint64_t v17 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v11,  kCFURLPOSIXPathStyle,  0,  v15);
      if (v17)
      {
        uint64_t v18 = v17;
        CFURLRef v13 = CFURLCopyAbsoluteURL(v17);
        CFRelease(v18);
      }

      else
      {
        CFURLRef v13 = 0LL;
      }

      CFRelease(v16);
    }

    else
    {
      CFURLRef v13 = 0LL;
    }
  }

  CFRelease(v9);
  if (v11) {
LABEL_17:
  }
    CFRelease(v11);
LABEL_18:
  CFRelease(v3);
  if (v13)
  {
    CFRelease(v1);
    return v13;
  }

  return v1;
}

const __CFURL **_CFBundleCreateWithExecutableURLIfLooksLikeBundle( const __CFAllocator *a1, const __CFURL *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = _CFBundleCopyBundleURLForExecutableURL(a2);
  CFURLRef v5 = _CFBundleCopyResolvedURLForExecutableURL(a2);
  uint64_t v6 = v5;
  if (v4 && v5)
  {
    Unique = (const __CFURL **)_CFBundleCreateUnique(a1, v4);
    if (!Unique)
    {
      BOOL v12 = 0LL;
      goto LABEL_19;
    }

    CFIndex v8 = Unique;
    uint64_t v9 = _CFBundleCopyExecutableURLInDirectory2((CFBundleRef)Unique, Unique[2], 0LL, 1);
    CFURLRef NormalizedURL = _CFBundleCreateNormalizedURL(a1, v6);
    int v11 = NormalizedURL;
    if (v9 && NormalizedURL)
    {
      if (!CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026LL)
        || !CFURLGetFileSystemRepresentation(v11, 1u, v15, 1026LL)
        || strcmp((const char *)buffer, (const char *)v15))
      {
        CFRelease(v8);
        CFIndex v8 = 0LL;
      }
    }

    else
    {
      CFRelease(v8);
      CFIndex v8 = 0LL;
      BOOL v12 = 0LL;
      if (!v9) {
        goto LABEL_17;
      }
    }

    CFRelease(v9);
    BOOL v12 = v8;
LABEL_17:
    if (v11) {
      CFRelease(v11);
    }
LABEL_19:
    CFRelease(v4);
    CFURLRef v13 = v12;
    if (!v6) {
      return v13;
    }
    goto LABEL_12;
  }

  BOOL v12 = 0LL;
  CFURLRef v13 = 0LL;
  if (v4) {
    goto LABEL_19;
  }
  if (v5) {
LABEL_12:
  }
    CFRelease(v6);
  return v13;
}

__CFBundle *_CFBundleCreateWithExecutableURLIfMightBeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  uint64_t v2 = _CFBundleCreateWithExecutableURLIfLooksLikeBundle(a1, a2);
  unint64_t v3 = (__CFBundle *)v2;
  if (v2)
  {
    if (_CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
    {
      InfoDictionary = CFBundleGetInfoDictionary(v3);
      if (!InfoDictionary || !CFDictionaryGetCount(InfoDictionary))
      {
        CFRelease(v3);
        return 0LL;
      }
    }
  }

  return v3;
}

uint64_t _binaryLoadable(const __CFURL *a1)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024LL);
  if ((_DWORD)result) {
    return _dyld_shared_cache_contains_path((const char *)buffer);
  }
  return result;
}

uint64_t __NSSingleObjectSetI_new(uint64_t a1, char a2)
{
  uint64_t v4 = (objc_class *)objc_opt_self();
  uint64_t v5 = __CFAllocateObject(v4, 0LL);
  uint64_t v6 = v5;
  if (v5)
  {
    *(void *)(v5 + _Block_object_dispose(va, 8) = a1;
    if (a1 >= 1 && (a2 & 1) == 0) {
      id v7 = (id)a1;
    }
  }

  return v6;
}

Boolean CFGregorianDateIsValid(CFGregorianDate gdate, CFOptionFlags unitFlags)
{
  uint64_t v2 = *(void *)&gdate.year;
  if ((unitFlags & 1) != 0 && gdate.year < 1) {
    return 0;
  }
  SInt8 month = gdate.month;
  uint64_t v4 = *(void *)&gdate.year >> 40;
  if ((unitFlags & 0x10) == 0
    || (LOBYTE(gdate.year) = 0, (v2 & 0x8000000000000000LL) == 0) && *(int *)&gdate.month <= 1006632959)
  {
    if ((unitFlags & 0x20) == 0 || (LOBYTE(gdate.year) = 0, gdate.second >= 0.0) && gdate.second < 60.0)
    {
      if ((~(_BYTE)unitFlags & 7) != 0)
      {
        LOBYTE(gdate.year) = 1;
      }

      else
      {
        if ((gdate.month - 1) >= 0xCu)
        {
          gdate.year = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR);
          if (gdate.year) {
            CFGregorianDateIsValid_cold_1(month);
          }
        }

        uint64_t v5 = ((int)v2 - 2001 + 1LL) % 400;
        if (v5 >= 0) {
          uint64_t v6 = ((int)v2 - 2001 + 1LL) % 400;
        }
        else {
          uint64_t v6 = -v5;
        }
        if ((v6 & 3) != 0)
        {
          BOOL v7 = 0;
        }

        else
        {
          BOOL v7 = 0;
          if (v6 != 100 && v6 != 200) {
            BOOL v7 = v6 != 300;
          }
        }

        if (BYTE4(v2) >= 0x10u)
        {
          __break(1u);
        }

        else
        {
          if (BYTE4(v2) != 2) {
            BOOL v7 = 0;
          }
          LOBYTE(gdate.year) = (daysInMonth[BYTE4(v2)] + v7) >= (char)v4;
        }
      }
    }
  }

  return gdate.year;
}

CFAbsoluteTime CFGregorianDateGetAbsoluteTime(CFGregorianDate gdate, CFTimeZoneRef tz)
{
  unint64_t v3 = *(void *)&gdate.year;
  double second = gdate.second;
  double v5 = __CFAbsoluteFromYMD(gdate.year - 2001, (int)(v3 >> 8) >> 24, (int)(v3 >> 16) >> 24) * 86400.0;
  double v6 = (double)((uint64_t)v3 >> 56) * 60.0 + (double)((int)(v3 >> 24) >> 24) * 3600.0 + second;
  double v7 = v6 + v5;
  if (tz)
  {
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, v6 + v5);
    return v7 - CFTimeZoneGetSecondsFromGMT(tz, v7 - SecondsFromGMT);
  }

  return v7;
}

double __CFAbsoluteFromYMD(uint64_t a1, unsigned int a2, int a3)
{
  double v3 = (double)(a1 / 400) * 146097.0 + 0.0;
  uint64_t v4 = a1 % 400;
  if (a1 % 400 < 0)
  {
    unint64_t v9 = ~a1 + 400 * (a1 / 400);
    uint64_t v10 = a1 % 400;
    do
    {
      unint64_t v11 = v9 % 0x190;
      if (((v9 % 0x190) & 3) != 0 || v11 == 100 || v11 == 300 || (double v12 = 366.0, v11 == 200)) {
        double v12 = 365.0;
      }
      double v3 = v3 - v12;
      --v9;
      ++v10;
    }

    while (v10);
  }

  else if (v4)
  {
    unint64_t v5 = 1LL;
    uint64_t v6 = a1 % 400;
    do
    {
      unint64_t v7 = v5 % 0x190;
      if (((v5 % 0x190) & 3) != 0 || v7 == 100 || v7 == 300 || (double v8 = 366.0, v7 == 200)) {
        double v8 = 365.0;
      }
      double v3 = v3 + v8;
      ++v5;
      --v6;
    }

    while (v6);
  }

  uint64_t v13 = (v4 + 1) % 400;
  if (v13 >= 0) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = -v13;
  }
  if ((v14 & 3) != 0)
  {
    __int16 v15 = 0;
  }

  else
  {
    __int16 v15 = 0;
    if (v14 != 100 && v14 != 200) {
      __int16 v15 = v14 != 300;
    }
  }

  if (a2 <= 0xF)
  {
    if (a2 <= 2) {
      __int16 v15 = 0;
    }
    unsigned int v16 = (unsigned __int16)(daysBeforeMonth[a2] + v15);
    if (v16 != 0xFFFF) {
      double v3 = v3 + (double)v16;
    }
  }

  return v3 + (double)(a3 - 1);
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  v22[1] = *MEMORY[0x1895F89C0];
  double SecondsFromGMT = 0.0;
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  double v19 = SecondsFromGMT + at;
  __CFYMDFromAbsolute( vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0),  v22,  (unint64_t)&v21,  (unint64_t)&v20);
  if (v22[0] >= 2147481646) {
    int v4 = 2147481646;
  }
  else {
    int v4 = v22[0];
  }
  _Q1 = vrndmq_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0), (float64x2_t)xmmword_180C33980));
  _D0 = 0x404E000000000000LL;
  __asm { FMLS            D2, D0, V1.D[0] }

  double v12 = _D2 + 60.0;
  if (_D2 >= 0.0) {
    double v12 = _D2;
  }
  if (v12 == 0.0) {
    double v12 = 0.0;
  }
  int32x2_t v13 = vcvt_s32_f32(vcvt_f32_f64(vrndmq_f64(vmlsq_f64(_Q1, (float64x2_t)xmmword_180C33990, vrndmq_f64(vdivq_f64(_Q1, (float64x2_t)xmmword_180C33990))))));
  int8x8_t v14 = vand_s8( vbsl_s8((int8x8_t)vcltz_s32(v13), (int8x8_t)vadd_s32(v13, (int32x2_t)0x180000003CLL), (int8x8_t)v13),  (int8x8_t)0xFF000000FFLL);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int64x2_t v16 = (int64x2_t)vshlq_u64(v15, (uint64x2_t)xmmword_180C339A0);
  unint64_t v17 = vorrq_s8((int8x16_t)v16, (int8x16_t)vdupq_laneq_s64(v16, 1)).u64[0] | ((unint64_t)v20 << 40) | ((unint64_t)v21 << 32) | (v4 + 2001);
  double v18 = v12;
  result.double second = v18;
  result.year = v17;
  result.SInt8 month = BYTE4(v17);
  result.day = BYTE5(v17);
  result.hour = BYTE6(v17);
  result.minute = HIBYTE(v17);
  return result;
}

uint64_t __CFYMDFromAbsolute(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = 400 * (result / 146097);
  for (uint64_t i = result % 146097; i < 0; --v4)
  {
    uint64_t v21 = v4 % 400;
    if (v4 % 400 < 0) {
      uint64_t v21 = -v21;
    }
    if ((v21 & 3) != 0 || v21 == 100 || v21 == 300 || v21 == 200) {
      uint64_t v22 = 365LL;
    }
    else {
      uint64_t v22 = 366LL;
    }
    i += v22;
  }

  uint64_t v6 = (v4 + 1) % 400;
  if (v6 < 0) {
    uint64_t v6 = -v6;
  }
  if ((v6 & 3) != 0 || v6 == 100 || v6 == 300 || v6 == 200) {
    unint64_t v7 = 365LL;
  }
  else {
    unint64_t v7 = 366LL;
  }
  if (i >= v7)
  {
    do
    {
      uint64_t v19 = (v4 + 2) % 400;
      if (v19 < 0) {
        uint64_t v19 = 400 * ((v4 + 2) / 400) - (v4 + 2);
      }
      if ((v19 & 3) != 0 || v19 == 100 || v19 == 300 || v19 == 200) {
        uint64_t v20 = 365LL;
      }
      else {
        uint64_t v20 = 366LL;
      }
      i -= v7;
      ++v4;
      unint64_t v7 = v20;
    }

    while (i >= v20);
  }

  if (a2) {
    *a2 = v4;
  }
  if (a3 | a4)
  {
    uint64_t v8 = (v4 + 1) % 400;
    if (v8 >= 0) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = -v8;
    }
    if ((v9 & 3) != 0)
    {
      __int16 v10 = 0;
    }

    else
    {
      __int16 v10 = 0;
      if (v9 != 100 && v9 != 200) {
        __int16 v10 = v9 != 300;
      }
    }

    int v11 = (int)i / 33;
    else {
      char v12 = (int)i / 33 + 1;
    }
    while (1)
    {
      int v13 = v11 + 1;
      unsigned __int8 v14 = v11 + 2;
      __int16 v15 = daysBeforeMonth[v14];
      if (v14 > 2u) {
        __int16 v16 = v10;
      }
      else {
        __int16 v16 = 0;
      }
      BOOL v17 = i < (unsigned __int16)(v15 + v16);
      int v11 = v13;
      if (v17)
      {
        if (!a3) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }

    LOBYTE(v13) = v12;
    if (a3) {
LABEL_25:
    }
      *(_BYTE *)a3 = v13;
LABEL_26:
    if (a4)
    {
      if (v13 > 0xFu)
      {
        char v18 = -1;
      }

      else
      {
        char v18 = daysBeforeMonth[v13] + v10;
      }

      *(_BYTE *)a4 = i - v18 + 1;
    }
  }

  return result;
}

CFAbsoluteTime CFAbsoluteTimeAddGregorianUnits(CFAbsoluteTime at, CFTimeZoneRef tz, CFGregorianUnits *units)
{
  CFGregorianDate GregorianDate = CFAbsoluteTimeGetGregorianDate(at, tz);
  unsigned int v7 = units->years + GregorianDate.year;
  int v8 = units->months + ((int)(*(void *)&GregorianDate.year >> 8) >> 24);
  if (v8 >= 13)
  {
    if (v8 >= 24) {
      int v9 = 24;
    }
    else {
      int v9 = units->months + ((int)(*(void *)&GregorianDate.year >> 8) >> 24);
    }
    unsigned int v10 = (v8 - v9 + 11) / 0xCu;
    int v8 = v8 - 12 * v10 - 12;
    v7 += v10 + 1;
  }

  int v11 = (int)(*(void *)&GregorianDate.year >> 16) >> 24;
  if (v8 <= 0)
  {
    if (v8 <= -11) {
      int v12 = -11;
    }
    else {
      int v12 = v8;
    }
    if (v8 >= -11) {
      int v13 = v8;
    }
    else {
      int v13 = v8 + 1;
    }
    unsigned int v14 = (v12 - v13) / 0xCu;
    if (v8 < -11) {
      ++v14;
    }
    v8 += 12 * v14 + 12;
    v7 += ~v14;
  }

  int v15 = (int)(v7 - 2000) % 400;
  if (v15 < 0) {
    int v15 = -v15;
  }
  BOOL v16 = v15 != 300;
  if (v15 == 200) {
    BOOL v16 = 0;
  }
  if (v15 == 100) {
    BOOL v16 = 0;
  }
  if ((v15 & 3) != 0) {
    BOOL v16 = 0;
  }
  char v17 = daysInMonth[v8];
  unsigned __int8 v18 = v17 + v16;
  int v19 = (v17 + v16);
  if (v11 >= v18) {
    int v11 = v19;
  }
  int v20 = v11 + units->days;
  while (v20 > v18)
  {
    if (v8 <= 11)
    {
      ++v8;
    }

    else
    {
      ++v7;
      int v8 = 1;
    }

    int v21 = (int)(v7 - 2000) % 400;
    if (v21 < 0) {
      int v21 = -v21;
    }
    BOOL v22 = v21 != 300;
    if (v21 == 200) {
      BOOL v22 = 0;
    }
    if (v21 == 100) {
      BOOL v22 = 0;
    }
    BOOL v23 = (v21 & 3) == 0 && v22;
    char v24 = daysInMonth[v8];
    v20 -= v19;
    BOOL v25 = v8 == 2 && v23;
    unsigned __int8 v18 = v24 + v25;
    int v19 = (v24 + v25);
  }

  if (v20 <= 0)
  {
    while (1)
    {
      int v27 = v8 < 2;
      if (v8 >= 2) {
        --v8;
      }
      else {
        int v8 = 12;
      }
      v7 -= v27;
      int v28 = (int)(v7 - 2000) % 400;
      if (v28 < 0) {
        int v28 = -v28;
      }
      BOOL v29 = v28 != 300;
      if (v28 == 200) {
        BOOL v29 = 0;
      }
      if (v28 == 100) {
        BOOL v29 = 0;
      }
      if ((v28 & 3) != 0) {
        BOOL v29 = 0;
      }
      uint64_t v26 = v8;
      BOOL v30 = v8 == 2 && v29;
      v20 += (daysInMonth[v8] + v30);
      if (v20 >= 1) {
        goto LABEL_65;
      }
    }

CFGregorianUnits *__cdecl CFAbsoluteTimeGetDifferenceAsGregorianUnits( CFGregorianUnits *__return_ptr retstr, CFAbsoluteTime at1, CFAbsoluteTime at2, CFGregorianUnits *tz, CFOptionFlags unitFlags)
{
  int v5 = unitFlags;
  uint64_t v6 = tz;
  uint64_t v10 = 0LL;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (at2 < at1) {
    int v11 = 1;
  }
  else {
    int v11 = -1;
  }
  *(_OWORD *)&retstr->years = 0uLL;
  *(_OWORD *)&retstr->minutes = 0uLL;
  double v12 = at2;
  do
  {
    if (((1 << v10) & v5) != 0)
    {
      int v13 = (int)((at1 - v12) / (double)dword_180C339B0[v10]);
      *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -3 * v11 + v13;
      do
      {
        double v14 = v12;
        *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -2 * v11 + v13;
        __int128 v15 = *(_OWORD *)&retstr->minutes;
        *(_OWORD *)&v18.years = *(_OWORD *)&retstr->years;
        *(_OWORD *)&v18.minutes = v15;
        double v12 = CFAbsoluteTimeAddGregorianUnits(at2, (CFTimeZoneRef)v6, &v18);
        BOOL v16 = v12 <= at1;
        if (at2 >= at1) {
          BOOL v16 = v12 >= at1;
        }
        v13 += v11;
      }

      while (v16);
      *(&retstr->years + v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = -4 * v11 + v13;
      double v12 = v14;
    }

    ++v10;
  }

  while (v10 != 5);
  if ((v5 & 0x20) == 0 || (double v17 = at1 - v12, retstr->seconds = v17, v17 == 0.0)) {
    retstr->seconds = 0.0;
  }
  return tz;
}

SInt32 CFAbsoluteTimeGetDayOfWeek(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  uint64_t v4 = vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0);
  uint64_t v5 = ((unint64_t)~v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
  uint64_t v6 = (~v4 - 7 * ((v5 + ((unint64_t)(~v4 - v5) >> 1)) >> 2)) ^ 7;
  if (v4 >= 0) {
    return v4 % 7uLL + 1;
  }
  else {
    LODWORD(v7) = v6;
  }
  return v7;
}

SInt32 CFAbsoluteTimeGetDayOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  __CFYMDFromAbsolute( vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0),  &v13,  (unint64_t)&v12,  (unint64_t)&v11);
  int v4 = (char)v12;
  unsigned int v5 = v12;
  if (((char)v12 - 1) >= 0xC && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    int v15 = v4;
    _os_log_error_impl(&dword_180A4C000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
    unsigned int v5 = v12;
  }

  uint64_t v6 = (v13 + 1) % 400;
  if (v6 >= 0) {
    uint64_t v7 = (v13 + 1) % 400;
  }
  else {
    uint64_t v7 = -v6;
  }
  if ((v7 & 3) != 0)
  {
    __int16 v8 = 0;
  }

  else
  {
    __int16 v8 = 0;
    if (v7 != 100 && v7 != 200) {
      __int16 v8 = v7 != 300;
    }
  }

  if (v5 > 0xF)
  {
    int v9 = 0xFFFF;
  }

  else
  {
    if (v5 <= 2) {
      __int16 v8 = 0;
    }
    int v9 = (unsigned __int16)(daysBeforeMonth[v5] + v8);
  }

  return v9 + v11;
}

SInt32 CFAbsoluteTimeGetWeekOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (tz) {
    double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  }
  else {
    double SecondsFromGMT = 0.0;
  }
  __CFYMDFromAbsolute( vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0),  &v22,  (unint64_t)&v21,  (unint64_t)&v20);
  uint64_t v4 = v22;
  double v5 = __CFAbsoluteFromYMD(v22, 1u, 1);
  float v6 = floor(v5 - floor(v5 / 7.0) * 7.0);
  else {
    int v7 = (int)v6 + 7;
  }
  int v8 = (char)v21;
  unsigned int v9 = v20;
  if (v21 == 1 && (char)v20 <= 3)
  {
    unsigned int v10 = 1;
  }

  else
  {
    unsigned int v10 = v21;
    if (v21 == 12 && (char)v20 >= 29)
    {
      SInt32 v11 = 1;
      double v12 = __CFAbsoluteFromYMD(v4 + 1, 1u, 1);
      float v13 = floor(v12 - floor(v12 / 7.0) * 7.0);
      unsigned int v10 = 12;
    }

    else if (v21 - 1 >= 0xC && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v24 = v8;
      _os_log_error_impl(&dword_180A4C000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
      unsigned int v10 = v21;
      uint64_t v4 = v22;
    }
  }

  uint64_t v14 = (v4 + 1) % 400;
  if (v14 >= 0) {
    uint64_t v15 = (v4 + 1) % 400;
  }
  else {
    uint64_t v15 = -v14;
  }
  if ((v15 & 3) != 0)
  {
    __int16 v16 = 0;
  }

  else
  {
    __int16 v16 = 0;
    if (v15 != 100 && v15 != 200) {
      __int16 v16 = v15 != 300;
    }
  }

  if (v10 > 0xF)
  {
    int v17 = 0xFFFF;
  }

  else
  {
    if (v10 <= 2) {
      __int16 v16 = 0;
    }
    int v17 = (unsigned __int16)(daysBeforeMonth[v10] + v16);
  }

  int v18 = (unint64_t)(2454267027LL * (v17 + v7 - 10 + (char)v20 - 7 * ((v7 - 10) / 7) + 2)) >> 32;
  return (v18 >> 2) + (v18 >> 31) + 1;
}

CFStringRef CFDateFormatterCreateDateFormatFromTemplate( CFAllocatorRef allocator, CFStringRef tmplate, CFOptionFlags options, CFLocaleRef locale)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v9 = CFGetTypeID(tmplate);
  CFMutableArrayRef Mutable = 0LL;
  uint64_t v18 = 0LL;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  BOOL v11 = TypeID == v9;
  if (!v11) {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0LL, &kCFTypeArrayCallBacks);
  }
  CFMutableArrayRef v21 = Mutable;
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 3221225472LL;
  v16[2] = __CFDateFormatterCreateDateFormatFromTemplate_block_invoke;
  v16[3] = &unk_1899963A0;
  BOOL v17 = v11;
  v16[6] = locale;
  v16[7] = options;
  v16[8] = allocator;
  v16[4] = &v18;
  v16[5] = tmplate;
  int v12 = useTemplatePatternGenerator(locale, (uint64_t)v16);
  float v13 = v19;
  uint64_t v14 = (const __CFString *)v19[3];
  if (!v12)
  {
    if (v14)
    {
      CFRelease((CFTypeRef)v19[3]);
      float v13 = v19;
    }

    uint64_t v14 = 0LL;
    v13[3] = 0LL;
  }

  _Block_object_dispose(&v18, 8);
  return v14;
}

void sub_180A8E8D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

uint64_t useTemplatePatternGenerator(const __CFLocale *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    CFStringRef Identifier = CFLocaleGetIdentifier(a1);
  }
  else {
    CFStringRef Identifier = &stru_1899EF170;
  }
  CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 768LL, 0x600u)) {
      CStringPtr = 0LL;
    }
  }

  os_unfair_lock_lock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  if (!useTemplatePatternGenerator_ptgLocaleName
    || !strcmp((const char *)useTemplatePatternGenerator_ptgLocaleName, CStringPtr))
  {
    uint64_t v5 = useTemplatePatternGenerator_ptg;
    int v13 = 0;
    if (useTemplatePatternGenerator_ptg)
    {
      int v6 = 0;
      goto LABEL_16;
    }
  }

  else
  {
    __cficu_udatpg_close((const void *)useTemplatePatternGenerator_ptg);
    useTemplatePatternGenerator_ptg = 0LL;
    free((void *)useTemplatePatternGenerator_ptgLocaleName);
    useTemplatePatternGenerator_ptgLocaleName = 0LL;
    int v13 = 0;
  }

  uint64_t v5 = __cficu_udatpg_open((uint64_t)CStringPtr, &v13);
  useTemplatePatternGenerator_ptg = v5;
  int v6 = v13;
  if (v5)
  {
    if (v13 <= 0)
    {
      useTemplatePatternGenerator_ptgLocaleName = (uint64_t)strdup(CStringPtr);
      if (!useTemplatePatternGenerator_pressureSrc)
      {
        qos_class_t v7 = qos_class_main();
        dispatch_queue_global_t global_queue = dispatch_get_global_queue(v7, 2uLL);
        useTemplatePatternGenerator_pressureSrc = (uint64_t)dispatch_source_create( MEMORY[0x1895F8B50],  0LL,  6uLL,  global_queue);
        handler[0] = MEMORY[0x1895F87A8];
        handler[1] = 3221225472LL;
        handler[2] = __useTemplatePatternGenerator_block_invoke_2;
        handler[3] = &unk_189996470;
        handler[4] = &__block_literal_global_1;
        dispatch_source_set_event_handler((dispatch_source_t)useTemplatePatternGenerator_pressureSrc, handler);
        dispatch_resume((dispatch_object_t)useTemplatePatternGenerator_pressureSrc);
        uint64_t v5 = useTemplatePatternGenerator_ptg;
        int v6 = v13;
      }
    }
  }

LABEL_16:
  if (v5) {
    BOOL v9 = v6 < 1;
  }
  else {
    BOOL v9 = 0;
  }
  uint64_t v10 = v9;
  if (a2 && (_DWORD)v10) {
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  return v10;
}

  CFAbsoluteTime result = -[__CFNumber _cfNumberType](number, "_cfNumberType");
LABEL_27:
  if (result == (kCFNumberMaxType|kCFNumberSInt8Type)) {
    return 4LL;
  }
  return result;
}

  for (uint64_t i = 0LL; i != 7; ++i)
  {
  }

  LOBYTE(v9) = 0;
  if ((~(_BYTE)i & 7) == 0 && ((i | v7) & 0x7F80000000000000LL) == 0x700000000000000LL) {
    goto LABEL_21;
  }
  return v9;
}

  for (uint64_t i = 0LL; i != 7; ++i)
  {
  }

  LOBYTE(v9) = 0;
  if ((~(_BYTE)i & 7) == 0 && ((i | v7) & 0x7F80000000000000LL) == 0x700000000000000LL) {
    goto LABEL_21;
  }
  return v9;
}

  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
  CFRelease(source);
}

      uint64_t v5 = _os_log_pack_size();
      uint64_t v14 = _os_log_pack_fill();
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "-[NSMutableDictionary initWithObjects:forKeys:count:]";
      *(_WORD *)(v14 + 12) = 2048;
      *(void *)(v14 + 14) = i;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[NSMutableDictionary initWithObjects:forKeys:count:]",  i);
      uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  (char *)v24 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v5);
      objc_exception_throw(v15);
      goto LABEL_17;
    }

    __int16 v16 = _os_log_pack_size();
    BOOL v17 = (char *)v24 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    goto LABEL_20;
  }

  __int16 v16 = _os_log_pack_size();
  BOOL v17 = (char *)v24 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = _os_log_pack_fill();
  *(_DWORD *)uint64_t v18 = 136315394;
  *(void *)(v18 + 4) = "-[NSMutableDictionary initWithObjects:forKeys:count:]";
  *(_WORD *)(v18 + 12) = 2048;
  *(void *)(v18 + 14) = v5;
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: count (%lu) of objects array is ridiculous",  "-[NSMutableDictionary initWithObjects:forKeys:count:]",  v5);
LABEL_21:
  uint64_t v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v17,  v16);
  objc_exception_throw(v20);
  return +[NSMutableDictionary dictionaryWithCapacity:](v21, v22, v23);
}

    if (a1 < 0 && (unsigned __int16)(v14 - 131) <= 0x1Cu)
    {
LABEL_18:
      uint64_t v19 = v11 + 1;
      if (a5) {
        *a4++ = v14;
      }
      goto LABEL_55;
    }

    if (v12 + 1 < a3 && (_DWORD)v14 == 252)
    {
      if ((__int16)a2[1] == -1921)
      {
        uint64_t v19 = v11 + 1;
        if (a5) {
          *a4++ = 0x80;
        }
        ++a2;
        ++v12;
        goto LABEL_55;
      }

      goto LABEL_27;
    }

  if (a2 < 1) {
    goto LABEL_39;
  }
  BOOL v30 = 0;
  do
  {
    uint64_t v31 = *v28++;
    if (v31 == 37) {
      ++v30;
    }
    --a2;
  }

  while (a2);
LABEL_28:
  unint64_t v34 = (2 * v30) | 1u;
  uint64_t v35 = CFAllocatorAllocate(allocator, 32LL * ((2 * v30) | 1u), 0LL);
  *a7 = v35;
  if (v35 != a8 && __CFOASafe != 0) {
    __CFSetLastAllocationEventName();
  }
  char v37 = CFAllocatorAllocate(allocator, 8 * v34, 0LL);
  *a9 = v37;
  if (v37 != a10 && __CFOASafe != 0) {
    __CFSetLastAllocationEventName();
  }
}

    uint64_t v15 = CFAllocatorAllocate(v11, 24LL, 0LL);
    *((void *)tree + 7) = v15;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      uint64_t v15 = (void *)*((void *)tree + 7);
    }

    *(_OWORD *)uint64_t v15 = *(_OWORD *)&context->retain;
    void v15[2] = context->copyDescription;
    copyDescriptiouint64_t n = 3LL;
    goto LABEL_19;
  }

  if (retain != CFRetain || context->release != CFRelease || context->copyDescription != CFCopyDescription) {
    goto LABEL_16;
  }
  copyDescriptiouint64_t n = 1LL;
LABEL_19:
  __int16 v16 = atomic_load(v5);
  do
  {
    BOOL v17 = __ldaxr(v5);
    if (v17 == v16)
    {
      if (!__stlxr(v16 & 0xFFFFFFFFFFFFFFFCLL | copyDescription, v5))
      {
        uint64_t v18 = 1;
        goto LABEL_25;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v18 = 0;
LABEL_25:
    __int16 v16 = v17;
  }

  while (!v18);
  uint64_t v19 = atomic_load(v5);
  uint64_t v20 = v19 & 3;
  if (v20)
  {
    if (v20 == 1) {
      CFMutableArrayRef v21 = (__int128 *)&__kCFTypeTreeCallBacks;
    }
    else {
      CFMutableArrayRef v21 = (__int128 *)*((void *)tree + 7);
    }
  }

  else
  {
    CFMutableArrayRef v21 = &__kCFNullTreeCallBacks;
  }

  uint64_t v22 = *(uint64_t (**)(void *))v21;
  info = context->info;
  if (v22) {
    info = (void *)v22(info);
  }
  *((void *)tree + 6) = info;
  int v24 = (void (*)(uint64_t))*((void *)v9 + 1);
  if (v24) {
    v24(v10);
  }
  if ((~v6 & 3) == 0) {
    CFAllocatorDeallocate(v12, v9);
  }
}

        CFIndex Length = location - 1;
        if (v5 >= 1)
        {
          CFIndex usedBufLen = 0LL;
          v21.CFIndex location = location;
          v21.CFIndex length = v5;
          if (CFStringGetBytes(v3, v21, 0x8000100u, 0, 0, 0LL, 0LL, &usedBufLen) <= 0) {
            BOOL v9 = 248LL;
          }
          else {
            BOOL v9 = 247 - usedBufLen;
          }
LABEL_21:
          bytes[0] = 46;
          if (CFStringGetCharacterAtIndex(v3, 0LL) == 95)
          {
            bytes[1] = 46;
            uint64_t v10 = 2LL;
          }

          else
          {
            uint64_t v10 = 1LL;
          }

          CFIndex usedBufLen = 0LL;
          v22.CFIndex location = 0LL;
          v22.CFIndex length = Length;
          CFStringGetBytes(v3, v22, 0x8000100u, 0, 0, &bytes[v10], v9 - v10, &usedBufLen);
          BOOL v11 = usedBufLen + v10;
          if (location != -1)
          {
            int v12 = v11 + 1;
            bytes[v11] = 46;
            v23.CFIndex location = location;
            v23.CFIndex length = v5;
            CFStringGetBytes(v3, v23, 0x8000100u, 0, 0, &bytes[v11 + 1], 254 - v11, &usedBufLen);
            BOOL v11 = usedBufLen + v12;
          }

          int v13 = &bytes[v11];
          *(_DWORD *)(v13 + 3) = 1685417836;
          *(_DWORD *)int v13 = 1818454318;
          qos_class_t v7 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, v11 + 7, 0x8000100u, 0);
          goto LABEL_27;
        }
      }

      BOOL v9 = 248LL;
      goto LABEL_21;
    }
  }

  return 0LL;
}

  if (v6 == @"NSStringPluralRuleType" || CFEqual(v6, @"NSStringPluralRuleType"))
  {
    uint64_t v14 = CFGetTypeID(a1);
    if (v14 != CFNumberGetTypeID()) {
      return;
    }
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &v76))
    {
      uint64_t v15 = v76;
      if (v76)
      {
        __int16 v16 = 0LL;
      }

      else
      {
        if (CFNumberIsFloatType((CFNumberRef)a1)) {
          __int16 v16 = 0LL;
        }
        else {
          __int16 v16 = CFDictionaryGetValue(theDict, @"zero");
        }
        uint64_t v15 = v76;
      }

      if (v15 == 0x7FFFFFFFFFFFFFFFLL) {
        __int16 v16 = CFDictionaryGetValue(theDict, @"other");
      }
      if (v16) {
        goto LABEL_64;
      }
    }

    else
    {
      int v76 = -1LL;
    }

    unint64_t v75 = 0;
    CFStringRef Identifier = CFLocaleGetIdentifier((CFLocaleRef)v7);
    if (!Identifier) {
      CFStringRef Identifier = @"en";
    }
    uplrules_open();
    unint64_t v75 = 0;
    unint64_t v74 = 0LL;
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &v74)) {
      BOOL v23 = uplrules_select();
    }
    else {
      BOOL v23 = 0;
    }
    uplrules_close();
    __int16 v16 = 0LL;
    if (v75 <= 0 && v23 >= 1)
    {
      int v24 = CFStringCreateWithCharactersNoCopy( 0LL,  (const UniChar *)v77,  v23,  (CFAllocatorRef)&__kCFAllocatorNull);
      __int16 v16 = CFDictionaryGetValue(theDict, v24);
      CFRelease(v24);
    }

    if (!v16 && v76 == 1)
    {
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
LABEL_63:
        __int16 v16 = CFDictionaryGetValue(theDict, @"other");
        if (v16) {
          goto LABEL_64;
        }
        return;
      }

      __int16 v16 = CFDictionaryGetValue(theDict, @"one");
    }

    if (v16)
    {
LABEL_64:
      CFRetain(v16);
      return;
    }

    goto LABEL_63;
  }

  if (v6 == @"NSStringDirectRuleType" || CFEqual(v6, @"NSStringDirectRuleType"))
  {
    BOOL v17 = CFGetTypeID(a1);
    CFTypeID TypeID = CFStringGetTypeID();
    if (!a1 || v17 != TypeID) {
      return;
    }
    uint64_t v19 = a1;
    goto LABEL_27;
  }

  if (v6 == @"NSStringGenderRuleType" || CFEqual(v6, @"NSStringGenderRuleType"))
  {
    value[0] = 0LL;
    uint64_t v20 = CFGetTypeID(a1);
    if (v20 == CFNumberGetTypeID())
    {
      LODWORD(v76) = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &v76))
      {
        v77[0] = 0LL;
        v77[1] = 0LL;
        int v78 = 0;
        if ((v76 & 0x80000000) == 0 && snprintf((char *)v77, 0x14uLL, "%d", v76) >= 1)
        {
          if (LOBYTE(v77[0]))
          {
            CFMutableArrayRef v21 = CFStringCreateWithCStringNoCopy(0LL, (const char *)v77, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
            if (v21)
            {
              CFRelease(v21);
              if (value[0]) {
                CFRetain(value[0]);
              }
            }
          }
        }
      }
    }

    return;
  }

  if (v6 != @"NSStringEntityFormattingRuleType" && !CFEqual(v6, @"NSStringEntityFormattingRuleType"))
  {
    if (v6 != @"NSStringAffixRuleType" && !CFEqual(v6, @"NSStringAffixRuleType"))
    {
      if (v6 == @"NSStringVocativeNameFormattingRuleType"
        || CFEqual(v6, @"NSStringVocativeNameFormattingRuleType"))
      {
        unint64_t v63 = CFGetTypeID(a1);
        unint64_t v64 = a1;
        if (v63 == 7) {
          goto LABEL_130;
        }
        if (_CFCopyResolvedFormatStringWithConfiguration_onceToken != -1) {
          dispatch_once(&_CFCopyResolvedFormatStringWithConfiguration_onceToken, &__block_literal_global_39);
        }
        if (__NSPersonNameComponentsClass)
        {
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            unint64_t v64 = (const __CFString *)-[__CFString givenName](a1, "givenName");
            if (CFGetTypeID(v64) == 7)
            {
LABEL_130:
              if (v64)
              {
                int v65 = _CFStringCopyVocativeCaseOfGivenName(v64, (CFLocaleRef)v7);
                unint64_t v66 = v65;
                if (v63 != 7)
                {
                  if (v65)
                  {
                    unint64_t v67 = (void *)-[__CFString copy](a1, "copy");
                    [v67 setGivenName:v66];
                    if (_CFCopyResolvedFormatStringWithConfiguration_onceToken_44 != -1) {
                      dispatch_once( &_CFCopyResolvedFormatStringWithConfiguration_onceToken_44,  &__block_literal_global_45);
                    }
                    CFRelease(v66);
                    objc_msgSend( (id)objc_msgSend( (id)_CFCopyResolvedFormatStringWithConfiguration_formatter,  "stringFromPersonNameComponents:",  v67),  "copy");
                    CFRelease(v67);
                  }
                }
              }
            }
          }
        }
      }

      return;
    }

    unint64_t v46 = (const __CFString *)CFLocaleGetValue((CFLocaleRef)v7, @"kCFLocaleLanguageCodeKey");
    unint64_t v47 = CFGetTypeID(a1);
    if (v47 != CFStringGetTypeID()
      || (v46 ? (int v48 = v46) : (int v48 = @"en"),
          AffixRuleFormat = _CFStringFindAffixRuleFormat(v48, a1),
          (uint64_t v19 = CFDictionaryGetValue(theDict, AffixRuleFormat)) == 0LL))
    {
      uint64_t v19 = CFDictionaryGetValue(theDict, @"other");
      if (!v19) {
        return;
      }
    }

void __CFDateFormatterCreateDateFormatFromTemplate_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v61 = v3;
  uint64_t v4 = v2;
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(v2 + 72))
  {
    CFIndex Count = 1LL;
LABEL_4:
    CFIndex v5 = 0LL;
    uint64_t v62 = v4;
    while (1)
    {
      ValueAtIndex = *(const __CFArray **)(v4 + 40);
      CFIndex v64 = v5;
      if (!*(_BYTE *)(v4 + 72)) {
        ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v5);
      }
      CFRange v8 = CFStringFind((CFStringRef)ValueAtIndex, @"J", 0LL);
      CFIndex length = (const char *)v8.length;
      Systeuint64_t m = *(CFLocaleRef *)(v4 + 48);
      if (System)
      {
        if (!ValueAtIndex) {
          goto LABEL_15;
        }
      }

      else
      {
        Systeuint64_t m = CFLocaleGetSystem();
        if (!ValueAtIndex)
        {
LABEL_15:
          CFMutableArrayRef Mutable = 0LL;
          goto LABEL_75;
        }
      }

      uint64_t v10 = *(void *)(v62 + 56);
      if ((v10 & 1) != 0)
      {
        int Value = 1;
        if ((v10 & 2) == 0) {
          goto LABEL_17;
        }
      }

      else
      {
        AppleICUForce24HourTimePref = (const __CFBoolean *)_CFLocaleGetAppleICUForce24HourTimePref(System, length);
        if (AppleICUForce24HourTimePref
          && (int v12 = AppleICUForce24HourTimePref,
              CFTypeID v13 = CFGetTypeID(AppleICUForce24HourTimePref),
              v13 == CFBooleanGetTypeID()))
        {
          int Value = CFBooleanGetValue(v12);
          if ((v10 & 2) == 0) {
            goto LABEL_17;
          }
        }

        else
        {
          int Value = 0;
          if ((v10 & 2) == 0)
          {
LABEL_17:
            AppleICUForce12HourTimePref = (const __CFBoolean *)_CFLocaleGetAppleICUForce12HourTimePref(System, length);
            BOOL v19 = AppleICUForce12HourTimePref
               && (BOOL v17 = AppleICUForce12HourTimePref,
                   CFTypeID v18 = CFGetTypeID(AppleICUForce12HourTimePref),
                   v18 == CFBooleanGetTypeID())
               && CFBooleanGetValue(v17) != 0;
            BOOL v63 = Value != 0;
            if (Value) {
              BOOL v20 = 0;
            }
            else {
              BOOL v20 = v19;
            }
            BOOL v60 = v20;
            if (!Value && !v19)
            {
              CFMutableArrayRef Mutable = (__CFString *)CFRetain(ValueAtIndex);
              goto LABEL_75;
            }

            goto LABEL_29;
          }
        }
      }

      BOOL v63 = Value != 0;
      BOOL v60 = Value == 0;
LABEL_29:
      CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
      CFIndex v21 = CFStringGetLength((CFStringRef)ValueAtIndex);
      if (v21 >= 1)
      {
        CFIndex v22 = v21;
        CFIndex v23 = 0LL;
        BOOL v24 = 0;
        int v58 = Value | (v8.location != -1);
        CFIndex v25 = -1LL;
        while (1)
        {
          int CharacterAtIndex = CFStringGetCharacterAtIndex((CFStringRef)ValueAtIndex, v23);
          chars[0] = CharacterAtIndex;
          if (CharacterAtIndex > 74) {
            break;
          }
          switch(CharacterAtIndex)
          {
            case '\'':
              BOOL v24 = !v24;
              break;
            case 'H':
              if (v24) {
                goto LABEL_67;
              }
              if (v25 == -1) {
                CFIndex v25 = CFStringGetLength(Mutable);
              }
              if (v60) {
                goto LABEL_54;
              }
              goto LABEL_72;
            case 'J':
LABEL_39:
              if (!v24)
              {
                if (v25 == -1) {
                  CFIndex v25 = CFStringGetLength(Mutable);
                }
                if (v63)
                {
LABEL_59:
                  BOOL v24 = 0;
                  UniChar v28 = 72;
                }

                else
                {
LABEL_54:
                  BOOL v24 = 0;
                  UniChar v28 = 104;
                }

LABEL_60:
                chars[0] = v28;
                break;
              }

        CFIndex v32 = *v11;
LABEL_61:
        *(void *)a3 = v32;
        return 1LL;
      }

      BOOL v27 = *v11;
      if ((v26 & 0x40) != 0)
      {
        uint64_t v44 = v11[1];
        unint64_t v45 = -v27;
        if (v44) {
          unint64_t v45 = ~v27;
        }
        if (v27 >= 0) {
          uint64_t v46 = v44;
        }
        else {
          uint64_t v46 = -(uint64_t)v44;
        }
        if (v27 >= 0) {
          unint64_t v45 = v27;
        }
        uint64_t v47 = -((double)v46 + (double)v45 * 1.84467441e19);
        if (v27 >= 0) {
          uint64_t v47 = (double)v46 + (double)v45 * 1.84467441e19;
        }
        *(double *)a3 = v47;
        if (v47 < -1.70141183e38)
        {
LABEL_101:
          uint64_t v55 = 0LL;
          CFIndex v56 = 0x8000000000000000LL;
        }

        else
        {
          if (v47 >= 1.70141183e38)
          {
LABEL_121:
            CFIndex v56 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v55 = -1LL;
LABEL_122:
            BOOL v63 = v56 <= v27;
            CFIndex v64 = v55 > v44;
            int v65 = v55 >= v44 && v63;
            return !v64 && v65;
          }

  CFAbsoluteTime result = (uint64_t)CFStringEncodingGetConverter(a3);
  if (!result) {
    return result;
  }
  CFStringRef v35 = result;
  switch(BYTE1(a3))
  {
    case 0:
      goto LABEL_240;
    case 1:
    case 8:
    case 0xC:
      goto LABEL_230;
    case 2:
      if ((_DWORD)a3 != 518) {
        goto LABEL_240;
      }
      goto LABEL_230;
    case 6:
      if ((_DWORD)a3 == 1536) {
        goto LABEL_240;
      }
      goto LABEL_230;
    case 0xA:
      goto LABEL_240;
    case 0xB:
      goto LABEL_230;
    default:
      if (((unsigned __int16)a3 & 0xFF00u) >= 0xC01)
      {
LABEL_230:
        int v82 = 0;
        *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = 0;
      }

      else
      {
LABEL_240:
        if (*(_BYTE *)(a5 + 8))
        {
          if (v12 < 1)
          {
LABEL_245:
            unsigned int v83 = 0;
            int v82 = 1;
            goto LABEL_249;
          }

          uint64_t v88 = a1;
          int v89 = v12;
          while (1)
          {
            unint64_t v90 = *v88++;
            if (v90 < 0) {
              break;
            }
            if (!--v89) {
              goto LABEL_245;
            }
          }

          int v82 = 1;
          goto LABEL_248;
        }

        int v82 = 1;
      }

      unsigned int v83 = 1;
      if ((_DWORD)a3 == 1 && !a4)
      {
        *(_BYTE *)(a5 + _Block_object_dispose(va, 8) = 1;
        if (v12 < 1)
        {
LABEL_238:
          unsigned int v83 = 0;
          goto LABEL_249;
        }

        uint64_t v84 = a1;
        unsigned __int16 v85 = v12;
        while (1)
        {
          unint64_t v87 = *v84++;
          uint64_t v86 = v87;
          if (v87 < 0 || v86 == 92) {
            break;
          }
          if (!--v85) {
            goto LABEL_238;
          }
        }

        if (v22) {
          return v11;
        }
        goto LABEL_61;
      }

      CFMutableDictionaryRef cf = url;
      BOOL v20 = Count;
      CFIndex v21 = (const void **)keys;
    }

    CFIndex v25 = 0LL;
    CFIndex v22 = 1;
    do
    {
      uint64_t v26 = (__CFString *)v21[v25];
      BOOL v27 = (const __CFNumber *)v19[v25];
      if (v26 == @"kCFURLFilePOSIXMode" || CFEqual(@"kCFURLFilePOSIXMode", v26))
      {
        CFTypeID TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID(v27))
        {
          CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr);
          BOOL v29 = valuePtr;
        }

        else
        {
          BOOL v29 = *(_WORD *)CFDataGetBytePtr(v27);
          int valuePtr = v29;
        }
      }

      else
      {
        CFIndex v22 = 0;
      }

      ++v25;
    }

    while (v20 != v25);
    if (v21 != (const void **)keys)
    {
      int v30 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v30, v21);
    }

    if (errorCode) {
      goto LABEL_56;
    }
    goto LABEL_60;
  }

  if (__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken != -1) {
    dispatch_once(&__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken, &__block_literal_global_39);
  }
  if (!__CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc)
  {
    if (errorCode)
    {
      BOOL v11 = 0;
      *errorCode = -15;
      goto LABEL_20;
    }

  CFIndex v32 = 0LL;
LABEL_61:
  uint64_t v39 = 0LL;
  unint64_t v34 = -1LL;
LABEL_62:
  int v38 = -1LL;
LABEL_63:
  if (a2)
  {
    *a2 = v38;
    a2[1] = v39;
  }

  if (a3)
  {
    *a3 = v34;
    a3[1] = v32;
  }
    }

    if (v14 != 255) {
      goto LABEL_66;
    }
    v12 += 2LL;
    if (a5)
    {
      if (v12 > a5) {
        return v13;
      }
      *(_DWORD *)a4 = -125886426;
      a4 += 2;
    }

    *a6 = v12;
    ++v13;
    ++a2;
    --v9;
LABEL_35:
    if (v9 <= 0) {
      return v13;
    }
  }

  if (v23 != 127 && (v23 + 3) >= 0x43u)
  {
    uint64_t v15 = (v23 | ((_WORD)v14 << 8)) - 68 * (v14 & 0xF) + ((char)v23 >> 7) - 4160;
    goto LABEL_64;
  }

        __break(1u);
        return result;
      }
    }

    else
    {
      if (v7 == 1028)
      {
        uint64_t v10 = *(float *)a2;
        goto LABEL_42;
      }

      if (v7 != 1032) {
        goto LABEL_60;
      }
    }

    BOOL v9 = *(float *)a2;
    goto LABEL_31;
  }

  CFIndex v5 = a5 + (a3 << 8);
  if ((*(_WORD *)(result + 34) & 0x100) == 0)
  {
    if (v5 <= 1024)
    {
      switch(v5)
      {
        case 257:
          goto LABEL_35;
        case 258:
          LOWORD(v_Block_object_dispose(va, 8) = *(unsigned __int8 *)a2;
          goto LABEL_54;
        case 259:
        case 261:
        case 262:
        case 263:
          goto LABEL_60;
        case 260:
          LODWORD(v6) = *(unsigned __int8 *)a2;
          goto LABEL_56;
        case 264:
          *(void *)&int v12 = *(unsigned __int8 *)a2;
          goto LABEL_59;
        default:
          switch(v5)
          {
            case 513:
              goto LABEL_35;
            case 514:
              goto LABEL_16;
            case 516:
              LODWORD(v6) = *(unsigned __int16 *)a2;
              goto LABEL_56;
            case 520:
              *(void *)&int v12 = *(unsigned __int16 *)a2;
              goto LABEL_59;
            default:
              goto LABEL_60;
          }
      }
    }

    switch(v5)
    {
      case 1025:
        goto LABEL_39;
      case 1026:
        goto LABEL_46;
      case 1027:
      case 1029:
      case 1030:
      case 1031:
        goto LABEL_60;
      case 1028:
        goto LABEL_47;
      case 1032:
        *(void *)&int v12 = *(unsigned int *)a2;
        goto LABEL_59;
      default:
        switch(v5)
        {
          case 2049:
            goto LABEL_23;
          case 2050:
            goto LABEL_43;
          case 2052:
            goto LABEL_44;
          case 2056:
            goto LABEL_45;
          default:
            goto LABEL_60;
        }
    }
  }

  if (v5 <= 1024)
  {
    switch(v5)
    {
      case 257:
LABEL_35:
        LOBYTE(v11) = *(_BYTE *)a2;
        goto LABEL_40;
      case 258:
        LOWORD(v_Block_object_dispose(va, 8) = *(char *)a2;
        goto LABEL_54;
      case 259:
      case 261:
      case 262:
      case 263:
        goto LABEL_60;
      case 260:
        LODWORD(v6) = *(char *)a2;
        goto LABEL_56;
      case 264:
        *(void *)&int v12 = *(char *)a2;
        goto LABEL_59;
      default:
        switch(v5)
        {
          case 513:
            goto LABEL_35;
          case 514:
LABEL_16:
            LOWORD(v_Block_object_dispose(va, 8) = *(_WORD *)a2;
            goto LABEL_54;
          case 516:
            LODWORD(v6) = *(__int16 *)a2;
            goto LABEL_56;
          case 520:
            *(void *)&int v12 = *(__int16 *)a2;
            goto LABEL_59;
          default:
            goto LABEL_60;
        }
    }
  }

  switch(v5)
  {
    case 1025:
LABEL_39:
      BOOL v11 = *(float *)a2;
LABEL_40:
      *(_BYTE *)a4 = LOBYTE(v11);
      break;
    case 1026:
LABEL_46:
      CFRange v8 = *(float *)a2;
LABEL_54:
      *(_WORD *)a4 = LOWORD(v8);
      break;
    case 1027:
    case 1029:
    case 1030:
    case 1031:
      goto LABEL_60;
    case 1028:
LABEL_47:
      int v6 = *(float *)a2;
LABEL_56:
      *(float *)a4 = v6;
      break;
    case 1032:
      *(void *)&int v12 = *(int *)a2;
LABEL_59:
      *a4 = v12;
      break;
    default:
      switch(v5)
      {
        case 2049:
LABEL_23:
          *(_BYTE *)a4 = *(void *)a2;
          break;
        case 2050:
LABEL_43:
          *(_WORD *)a4 = *(void *)a2;
          break;
        case 2052:
LABEL_44:
          *(_DWORD *)a4 = *(void *)a2;
          break;
        case 2056:
LABEL_45:
          int v12 = *a2;
          goto LABEL_59;
        default:
          goto LABEL_60;
      }

      break;
  }

  return result;
}

LABEL_67:
              BOOL v24 = 1;
              break;
          }

  uint64_t v26 = -1;
LABEL_77:
  __int16 v16 = v26 >= 0;
LABEL_78:
  v8 += (v18 + v15 - 1);
  if (!v16) {
    goto LABEL_13;
  }
LABEL_124:
  qos_class_t v7 = a1;
  CFIndex v33 = v55;
  if (!v16)
  {
LABEL_125:
    unint64_t v34 = a4 < 1024;
    CFStringRef v35 = a4 - 1024;
    if (!v34)
    {
      if (v7 < 0 || lseek(v7, v35, 0) != v35)
      {
        if (a3 >= 1024)
        {
          uint64_t v39 = 0LL;
          char v37 = a2 + a3 - 1024;
          goto LABEL_133;
        }
      }

      else
      {
        uint64_t v36 = malloc(0x400uLL);
        if (v36)
        {
          char v37 = (uint64_t)v36;
          int v38 = read(v7, v36, 0x400uLL);
          uint64_t v39 = (void *)v37;
          if (v38 <= 1023)
          {
            uint64_t v39 = (void *)v37;
            goto LABEL_192;
          }

LABEL_72:
        BOOL v24 = 0;
        goto LABEL_73;
      }

  CFMachPortSetInvalidationCallBack(v43, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  *(void *)(v30 + 24) = v43;
LABEL_73:
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  CFRange v70 = atomic_load(v31);
  while (2)
  {
    int v71 = __ldaxr(v31);
    if (v71 == v70)
    {
      if (!__stlxr(v70 | 1, v31))
      {
        unint64_t v72 = 1;
        goto LABEL_79;
      }
    }

    else
    {
      __clrex();
    }

    unint64_t v72 = 0;
LABEL_79:
    CFRange v70 = v71;
    if (!v72) {
      continue;
    }
    break;
  }

  if (a4)
  {
    unint64_t v73 = *a4;
    unint64_t v74 = a4[1];
    *(void *)(v30 + 152) = *((void *)a4 + 4);
    *(_OWORD *)(v30 + 136) = v74;
    *(_OWORD *)(v30 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v73;
    unint64_t v75 = *((void *)a4 + 1);
    int v76 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
    if (v76) {
      unint64_t v75 = v76(v75);
    }
    *(void *)(v30 + 12_Block_object_dispose(va, 8) = v75;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!v15)
  {
LABEL_92:
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    if (a5) {
      *a5 = 0;
    }
    return (CFTypeRef)v30;
  }

  if (!__CFAllLocalMessagePorts) {
    goto LABEL_90;
  }
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
  {
    CFMutableArrayRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
    if (__CFAllLocalMessagePorts)
    {
LABEL_91:
      CFDictionaryAddValue(Mutable, SanitizedStringName, (const void *)v30);
      goto LABEL_92;
    }

      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Encountered unexpected EOF",  usedBufLen,  v53,  *(void *)bytes);
      goto LABEL_81;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = ++v6;
LABEL_83:
    if (*(void *)(a1 + 24))
    {
      if (Mutable) {
        CFRelease(Mutable);
      }
      return 0LL;
    }
  }

  if (!Mutable)
  {
    if (*(_BYTE *)(a1 + 80))
    {
      *a2 = 0LL;
      return 1LL;
    }

    if (*(_DWORD *)(a1 + 40) != 2)
    {
      UniqueStringWithUTF8CFIndex Bytes = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, v7, v6 - v7);
      if (!UniqueStringWithUTF8Bytes) {
        goto LABEL_112;
      }
      *a2 = UniqueStringWithUTF8Bytes;
      return 1LL;
    }

    uint64_t v41 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v7, v6 - v7, 0x8000100u, 0);
    if (!v41) {
      goto LABEL_112;
    }
    CFMutableArrayRef Mutable = (__CFData *)v41;
    MutableCFDataRef Copy = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0LL, v41);
LABEL_105:
    *a2 = MutableCopy;
LABEL_106:
    CFRelease(Mutable);
    return 1LL;
  }

  if (*(_BYTE *)(a1 + 80))
  {
    *a2 = 0LL;
    goto LABEL_106;
  }

  CFDataAppendBytes(Mutable, v7, v6 - v7);
  if (*(_DWORD *)(a1 + 40) != 2)
  {
    BytePtr = CFDataGetBytePtr(Mutable);
    CFIndex Length = CFDataGetLength(Mutable);
    MutableCFDataRef Copy = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, BytePtr, Length);
    if (!MutableCopy) {
      goto LABEL_109;
    }
    goto LABEL_105;
  }

  uint64_t v36 = *(const __CFAllocator **)(a1 + 32);
  char v37 = CFDataGetBytePtr(Mutable);
  int v38 = CFDataGetLength(Mutable);
  uint64_t v39 = CFStringCreateWithBytes(v36, v37, v38, 0x8000100u, 0);
  if (v39)
  {
    uint64_t v40 = v39;
    *a2 = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0LL, v39);
    CFRelease(v40);
    goto LABEL_106;
  }

  uint64_t v14 = 0;
LABEL_73:
  CFIndex v22 = v21;
LABEL_74:
  if (a5)
  {
LABEL_75:
    if ((v14 & 1) == 0 && v12 == a5 && v9 - (void)v22 == 2 && *v22 == 126) {
      v22 += 2 * (v22[1] == 125);
    }
  }

      if (++v23 >= length) {
        return;
      }
    }
  }

  BOOL v24 = atomic_load((unint64_t *)&theString->info);
  CFIndex v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    uint64_t v26 = *v25;
  }

  else
  {
    BOOL v27 = atomic_load((unint64_t *)&theString->info);
    uint64_t v26 = (char *)&v25[(v27 & 5) != 4LL];
  }

  UniChar v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    CFIndex v23 = 0LL;
    BOOL v29 = &v26[(v28 >> 2) & 1];
    do
    {
      int v30 = v29[v23];
      if ((v30 - 97) > 0x19)
      {
        if (v30 < 0) {
          goto LABEL_28;
        }
      }

      else
      {
        v29[v23] = v30 - 32;
      }

      ++v23;
    }

    while (length != v23);
  }

    if ((a1 & 8) != 0) {
      goto LABEL_116;
    }
    if ((v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0) && v14 - 12441 >= 2)
    {
      IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
      a2 = v54;
      if (!IsValidCombiningCharacterForLatin1_4) {
        goto LABEL_116;
      }
    }

    if ((a1 & 0x10) == 0)
    {
      BOOL v17 = 0LL;
      goto LABEL_114;
    }

    if (!v12)
    {
      CFRange v8 = 0LL;
      goto LABEL_117;
    }

    BOOL v27 = a2 + 2 * v12;
    BOOL v29 = *(unsigned __int16 *)(v27 - 2);
    UniChar v28 = (unsigned __int16 *)(v27 - 2);
    if (v29 > 0x7F) {
      int v30 = __CFPrecomposeCharJapanese(v28, 0);
    }
    else {
      int v30 = __CFStringEncodingPrecomposeLatinCharacter_6(v28, v8 + 1 - v12, 0LL);
    }
    uint64_t v31 = __CFToJIS(v30, 1);
    if (v31 && v31 != 65533)
    {
      CFIndex v32 = v31;
      a2 = v54;
      if (((__int16)v31 & 0x80000000) == 0)
      {
        if (v13 == 1)
        {
          BOOL v17 = 0LL;
          CFIndex v33 = 0LL;
          uint64_t v10 = 0;
          unint64_t v34 = 2LL;
          if (!a5) {
            goto LABEL_102;
          }
        }

        else
        {
          if (v13) {
            unint64_t v34 = 2LL;
          }
          else {
            unint64_t v34 = 1LL;
          }
          if (v10) {
            v34 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1LL;
          }
          BOOL v17 = 5 - v34;
          uint64_t v10 = 1;
          CFIndex v33 = &off_1899EA8D8;
          if (!a5) {
            goto LABEL_102;
          }
        }

        if (a5 - v11 >= v17)
        {
          char v37 = &a4[-v34];
          if (v13 != 1)
          {
            *char v37 = 27;
            int v38 = v32;
            uint64_t v39 = v33;
            uint64_t v40 = strncpy(v37 + 1, *v33, *((unsigned __int8 *)v33 + 8));
            CFIndex v32 = v38;
            a2 = v54;
            char v37 = &v40[*((unsigned __int8 *)v39 + 8)];
          }

          *char v37 = HIBYTE(v32);
          a4 = v37 + 2;
          v37[1] = v32 & 0x7F;
          goto LABEL_102;
        }

        goto LABEL_116;
      }

      if (v13 == 4)
      {
        BOOL v17 = 0LL;
        CFStringRef v35 = 0LL;
        uint64_t v10 = 0;
        uint64_t v36 = 2LL;
        if (!a5)
        {
LABEL_113:
          CFTypeID v13 = 4;
          goto LABEL_114;
        }
      }

      else
      {
        if (v13) {
          uint64_t v36 = 2LL;
        }
        else {
          uint64_t v36 = 1LL;
        }
        if (v10) {
          v36 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1LL;
        }
        BOOL v17 = 6 - v36;
        uint64_t v10 = 1;
        CFStringRef v35 = &off_1899EA908;
        if (!a5) {
          goto LABEL_113;
        }
      }

      if (a5 - v11 >= v17)
      {
        uint64_t v41 = &a4[-v36];
        if (v13 != 4)
        {
          *uint64_t v41 = 27;
          unsigned int v42 = v32;
          BOOL v43 = v35;
          uint64_t v44 = strncpy(v41 + 1, *v35, *((unsigned __int8 *)v35 + 8));
          CFIndex v32 = v42;
          a2 = v54;
          uint64_t v41 = &v44[*((unsigned __int8 *)v43 + 8)];
        }

        *uint64_t v41 = HIBYTE(v32) & 0x7F;
        a4 = v41 + 2;
        v41[1] = v32 & 0x7F;
        goto LABEL_113;
      }

void __CFDateFormatterDeallocate(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    __cficu_udat_close(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  CFIndex v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  int v6 = (const void *)a1[8];
  if (v6) {
    CFRelease(v6);
  }
  qos_class_t v7 = (const void *)a1[9];
  if (v7) {
    CFRelease(v7);
  }
  CFRange v8 = (const void *)a1[11];
  if (v8) {
    CFRelease(v8);
  }
  BOOL v9 = (const void *)a1[12];
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)a1[13];
  if (v10) {
    CFRelease(v10);
  }
  BOOL v11 = (const void *)a1[14];
  if (v11) {
    CFRelease(v11);
  }
  int v12 = (const void *)a1[15];
  if (v12) {
    CFRelease(v12);
  }
  CFTypeID v13 = (const void *)a1[16];
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = (const void *)a1[17];
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (const void *)a1[18];
  if (v15) {
    CFRelease(v15);
  }
  __int16 v16 = (const void *)a1[19];
  if (v16) {
    CFRelease(v16);
  }
  BOOL v17 = (const void *)a1[20];
  if (v17) {
    CFRelease(v17);
  }
  CFTypeID v18 = (const void *)a1[21];
  if (v18) {
    CFRelease(v18);
  }
  BOOL v19 = (const void *)a1[22];
  if (v19) {
    CFRelease(v19);
  }
  BOOL v20 = (const void *)a1[23];
  if (v20) {
    CFRelease(v20);
  }
  CFIndex v21 = (const void *)a1[24];
  if (v21) {
    CFRelease(v21);
  }
  CFIndex v22 = (const void *)a1[25];
  if (v22) {
    CFRelease(v22);
  }
  CFIndex v23 = (const void *)a1[26];
  if (v23) {
    CFRelease(v23);
  }
  BOOL v24 = (const void *)a1[27];
  if (v24) {
    CFRelease(v24);
  }
  CFIndex v25 = (const void *)a1[28];
  if (v25) {
    CFRelease(v25);
  }
  uint64_t v26 = (const void *)a1[29];
  if (v26) {
    CFRelease(v26);
  }
  BOOL v27 = (const void *)a1[30];
  if (v27) {
    CFRelease(v27);
  }
  UniChar v28 = (const void *)a1[31];
  if (v28) {
    CFRelease(v28);
  }
  BOOL v29 = (const void *)a1[32];
  if (v29) {
    CFRelease(v29);
  }
  int v30 = (const void *)a1[33];
  if (v30) {
    CFRelease(v30);
  }
  uint64_t v31 = (const void *)a1[34];
  if (v31) {
    CFRelease(v31);
  }
  CFIndex v32 = (const void *)a1[35];
  if (v32) {
    CFRelease(v32);
  }
  CFIndex v33 = (const void *)a1[36];
  if (v33) {
    CFRelease(v33);
  }
  unint64_t v34 = (const void *)a1[37];
  if (v34) {
    CFRelease(v34);
  }
  CFStringRef v35 = (const void *)a1[38];
  if (v35) {
    CFRelease(v35);
  }
  uint64_t v36 = (const void *)a1[39];
  if (v36) {
    CFRelease(v36);
  }
  char v37 = (const void *)a1[40];
  if (v37) {
    CFRelease(v37);
  }
  int v38 = (const void *)a1[42];
  if (v38) {
    CFRelease(v38);
  }
  uint64_t v39 = (const void *)a1[43];
  if (v39) {
    CFRelease(v39);
  }
  uint64_t v40 = (const void *)a1[48];
  if (v40) {
    CFRelease(v40);
  }
  uint64_t v41 = (const void *)a1[49];
  if (v41) {
    CFRelease(v41);
  }
  unsigned int v42 = (const void *)a1[41];
  if (v42) {
    CFRelease(v42);
  }
  BOOL v43 = (const void *)a1[44];
  if (v43) {
    CFRelease(v43);
  }
  uint64_t v44 = (const void *)a1[50];
  if (v44) {
    CFRelease(v44);
  }
  unint64_t v45 = (const void *)a1[45];
  if (v45) {
    CFRelease(v45);
  }
  uint64_t v46 = (const void *)a1[46];
  if (v46) {
    CFRelease(v46);
  }
  uint64_t v47 = (const void *)a1[47];
  if (v47) {
    CFRelease(v47);
  }
  uint64_t v48 = (const void *)a1[51];
  if (v48) {
    CFRelease(v48);
  }
  unint64_t v49 = (const void *)a1[52];
  if (v49) {
    CFRelease(v49);
  }
  int v50 = (const void *)a1[53];
  if (v50) {
    CFRelease(v50);
  }
  BOOL v51 = (const void *)a1[54];
  if (v51) {
    CFRelease(v51);
  }
  int v52 = (const void *)a1[55];
  if (v52) {
    CFRelease(v52);
  }
  uint64_t v53 = (const void *)a1[57];
  if (v53) {
    CFRelease(v53);
  }
  uint64_t v54 = (const void *)a1[58];
  if (v54) {
    CFRelease(v54);
  }
  uint64_t v55 = (const void *)a1[59];
  if (v55) {
    CFRelease(v55);
  }
  CFIndex v56 = (const void *)a1[60];
  if (v56) {
    CFRelease(v56);
  }
  char v57 = (const void *)a1[61];
  if (v57) {
    CFRelease(v57);
  }
  int v58 = (const void *)a1[62];
  if (v58) {
    CFRelease(v58);
  }
  unint64_t v59 = (const void *)a1[63];
  if (v59) {
    CFRelease(v59);
  }
  BOOL v60 = (const void *)a1[64];
  if (v60) {
    CFRelease(v60);
  }
  uint64_t v61 = (const void *)a1[65];
  if (v61) {
    CFRelease(v61);
  }
}

CFStringRef __CFDateFormatterCopyDescription(const void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFDateFormatter %p [%p]>", a1, v3);
}

CFTypeID CFDateFormatterGetTypeID(void)
{
  return 56LL;
}

CFDateFormatterRef CFDateFormatterCreateISO8601Formatter( CFAllocatorRef allocator, CFISO8601DateFormatOptions formatOptions)
{
  uint64_t v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, "en_US_POSIX", 0x8000100u);
  CFIndex v5 = CFLocaleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
  CFDateFormatter = (__CFDateFormatter *)__CreateCFDateFormatter(allocator, v5, 0LL, 0LL, &__kCFBooleanTrue, v6, v7, v8);
  if (!formatOptions) {
    goto LABEL_64;
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 33LL);
  BOOL v11 = Mutable;
  if ((~(_WORD)formatOptions & 0x773) == 0)
  {
    if ((formatOptions & 0x100) != 0) {
      int v12 = "yyyy-MM-dd";
    }
    else {
      int v12 = "yyyyMMdd";
    }
    CFStringAppendCString(Mutable, v12, 0x8000100u);
    if ((formatOptions & 0x80) != 0) {
      CFTypeID v13 = " ";
    }
    else {
      CFTypeID v13 = "'T'";
    }
    CFStringAppendCString(v11, v13, 0x8000100u);
    if ((formatOptions & 0x200) != 0) {
      uint64_t v14 = "HH:mm:ss";
    }
    else {
      uint64_t v14 = "HHmmss";
    }
    CFStringAppendCString(v11, v14, 0x8000100u);
    if ((formatOptions & 0x800) != 0) {
      CFStringAppendCString(v11, ".SSS", 0x8000100u);
    }
    if ((formatOptions & 0x400) != 0) {
      uint64_t v15 = "XXXXX";
    }
    else {
      uint64_t v15 = "XXXX";
    }
    CFStringAppendCString(v11, v15, 0x8000100u);
    goto LABEL_62;
  }

  if ((_DWORD)formatOptions)
  {
    int v16 = 0;
    int v17 = 0;
    if ((formatOptions & 0x400) != 0) {
      CFTypeID v18 = "XXXXX";
    }
    else {
      CFTypeID v18 = "XXXX";
    }
    if ((formatOptions & 0x80) != 0) {
      BOOL v19 = " ";
    }
    else {
      BOOL v19 = "'T'";
    }
    BOOL v20 = "HH:mm:ss";
    if ((formatOptions & 0x200) == 0) {
      BOOL v20 = "HHmmss";
    }
    cStr = (char *)v19;
    BOOL v27 = (char *)v20;
    CFIndex v21 = "dd";
    if ((formatOptions & 2) == 0) {
      CFIndex v21 = "DDD";
    }
    if ((formatOptions & 4) != 0) {
      CFIndex v21 = "ee";
    }
    UniChar v28 = v21;
    if ((formatOptions & 4) != 0) {
      CFIndex v22 = "YYYY";
    }
    else {
      CFIndex v22 = "yyyy";
    }
    do
    {
      CFIndex Length = CFStringGetLength(v11);
      if (v16 > 15)
      {
        if (v16 != 16)
        {
          if (v16 == 32)
          {
            if ((formatOptions & 0x20) == 0) {
              goto LABEL_61;
            }
            if (Length >= 1) {
              CFStringAppendCString(v11, cStr, 0x8000100u);
            }
            CFStringAppendCString(v11, v27, 0x8000100u);
            BOOL v24 = ".SSS";
            if ((formatOptions & 0x800) == 0) {
              goto LABEL_61;
            }
          }

          else
          {
            if (v16 != 64) {
              goto LABEL_61;
            }
            BOOL v24 = v18;
            if ((formatOptions & 0x40) == 0) {
              goto LABEL_61;
            }
          }

          goto LABEL_60;
        }

        if ((formatOptions & 0x10) != 0)
        {
          BOOL v24 = v28;
          if ((formatOptions & 0x100) != 0)
          {
            BOOL v24 = v28;
            goto LABEL_54;
          }

          goto LABEL_60;
        }
      }

      else
      {
        if (v16 == 1)
        {
          BOOL v24 = v22;
          if ((formatOptions & 1) == 0) {
            goto LABEL_61;
          }
          goto LABEL_60;
        }

        if (v16 != 2)
        {
          if (v16 != 4 || (formatOptions & 4) == 0) {
            goto LABEL_61;
          }
          BOOL v24 = "'W'ww";
          if ((formatOptions & 0x100) == 0) {
            goto LABEL_60;
          }
LABEL_54:
          if (Length >= 1) {
            CFStringAppendCString(v11, "-", 0x8000100u);
          }
LABEL_60:
          CFStringAppendCString(v11, v24, 0x8000100u);
          goto LABEL_61;
        }

        if ((formatOptions & 2) != 0)
        {
          BOOL v24 = "MM";
          if ((formatOptions & 0x100) != 0) {
            goto LABEL_54;
          }
          goto LABEL_60;
        }
      }

LABEL_61:
      int v16 = 1 << v17++;
    }

    while (v16 < formatOptions);
  }

                if (*(_BYTE *)(v38 + ((unint64_t)v43 >> 8))) {
                  LODWORD(v3_Block_object_dispose(va, 8) = *(unsigned __int8 *)(v38
                }
                                                    + (*(unsigned __int8 *)(v38 + ((unint64_t)v43 >> 8)) << 8)
                                                    - 256
                                                    + v43
                                                    + 256);
                else {
                  LODWORD(v3_Block_object_dispose(va, 8) = 0;
                }
                goto LABEL_64;
              }

              if (v182 <= v31 || (int v58 = v181, v181 > v31))
              {
                unint64_t v59 = a2 - 6;
                if (v59 + 64 < v180) {
                  uint64_t v39 = v59 + 64;
                }
                CFIndex v181 = v59;
                char v182 = v39;
                v185.CFIndex location = v179 + v59;
                v185.CFIndex length = v39 - v59;
                CFStringGetCharacters(theString, v185, buffer);
                int v58 = v181;
              }

              uint64_t v40 = &buffer[v31 - v58];
            }

            uint64_t v41 = *v40;
            if (v41 != 847) {
              goto LABEL_60;
            }
            unsigned int v42 = 1;
LABEL_65:
            CFIndex v32 = v31;
            if (!v42) {
              goto LABEL_121;
            }
LABEL_67:
            uint64_t v44 = _CFStringInlineBufferGetComposedRange(buffer, v32 - 1, v164, BitmapPtrForPlane, v7);
            int v30 = v44;
            if (v44 < 0 || (unint64_t v45 = v180, v180 <= v44))
            {
              LOWORD(v49) = 0;
              goto LABEL_73;
            }

            uint64_t v46 = v177;
            if (v177)
            {
              uint64_t v47 = v179 + v44;
            }

            else
            {
              if (v178)
              {
                uint64_t v48 = *(char *)(v178 + v179 + v44);
                goto LABEL_79;
              }

              if (v182 <= v44 || (BOOL v60 = v181, v181 > v44))
              {
                uint64_t v61 = v44 - 4;
                if (v61 + 64 < v180) {
                  unint64_t v45 = v61 + 64;
                }
                CFIndex v181 = v61;
                char v182 = v45;
                v186.CFIndex location = v179 + v61;
                v186.CFIndex length = v45 - v61;
                CFStringGetCharacters(theString, v186, buffer);
                BOOL v60 = v181;
              }

              uint64_t v47 = v30 - v60;
              uint64_t v46 = buffer;
            }

            uint64_t v48 = v46[v47];
LABEL_79:
            unint64_t v49 = v48;
            if (v48 >> 10 == 55)
            {
              if (v30)
              {
                BOOL v51 = v180;
                if (v180 >= v30)
                {
                  int v52 = v30 - 1;
                  uint64_t v53 = v177;
                  if (v177)
                  {
                    uint64_t v54 = v179 + v52;
                    goto LABEL_84;
                  }

                  if (v178)
                  {
                    uint64_t v55 = *(char *)(v178 + v179 + v52);
                  }

                  else
                  {
                    if (v182 < v30 || (uint64_t v62 = v181, v181 >= v30))
                    {
                      BOOL v63 = v30 - 5;
                      if (v63 + 64 < v180) {
                        BOOL v51 = v63 + 64;
                      }
                      CFIndex v181 = v63;
                      char v182 = v51;
                      v187.CFIndex location = v179 + v63;
                      v187.CFIndex length = v51 - v63;
                      CFStringGetCharacters(theString, v187, buffer);
                      uint64_t v62 = v181;
                    }

                    uint64_t v54 = v52 - v62;
                    uint64_t v53 = buffer;
LABEL_84:
                    uint64_t v55 = v53[v54];
                  }

                  int v50 = v11;
                  if (v55 >> 10 == 54)
                  {
                    unint64_t v49 = (v49 << 10) + v55 - 56613888;
                    int v50 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v49));
                    --v30;
                  }

                  goto LABEL_74;
                }
              }
            }

      uint64_t v14 = 0;
LABEL_53:
      int v17 = 2LL;
LABEL_36:
      v13 += v17;
      __s1 += v17;
      uint64_t v26 = (uint64_t)v9 <= v17;
      v9 -= v17;
      if (v26) {
        return v13;
      }
      continue;
    }

    break;
  }

    LOBYTE(v11) = 0;
    return v11;
  }

  BOOL v11 = __CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc(url, dataToWrite, propertiesToWrite, errorCode);
  if (!errorCode) {
    return v11;
  }
LABEL_20:
  if (!v11)
  {
    int v12 = -11;
    goto LABEL_22;
  }

  return v11;
}

        UniChar v28 = *(const void **)(a1 + 24);
        if (v28)
        {
          CFRelease(v28);
          *(void *)(a1 + 24) = 0LL;
          uint64_t v14 = *(__int16 **)(a1 + 8);
          CFIndex v22 = *(void *)(a1 + 16);
        }

        if ((unint64_t)v14 < v22 && *v14 == 62)
        {
LABEL_65:
          *(void *)(a1 + _Block_object_dispose(va, 8) = v14 + 1;
          return (__CFString *)v7;
        }

        CFRelease(v7);
        uint64_t v39 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Expected terminating '>' for data at line %d", v39);
        goto LABEL_3;
      }

      if ((v24 & 0xFE) - 48 <= 9) {
        break;
      }
      if ((v24 - 97) <= 5u)
      {
        CFIndex v25 = v24 - 87;
LABEL_41:
        *(void *)(a1 + _Block_object_dispose(va, 8) = ++v14;
        uint64_t v26 = *v14;
        if ((*v14 & 0xFEu) - 48 > 9)
        {
          if ((v26 - 97) > 5u)
          {
            BOOL v27 = v26 - 55;
            goto LABEL_54;
          }

          BOOL v27 = v26 - 87;
        }

        else
        {
          BOOL v27 = v26 - 48;
LABEL_54:
          if (v27 == -1)
          {
LABEL_79:
            CFRelease(v7);
            goto LABEL_80;
          }
        }

        bytes[v23++] = v27 + 16 * v25;
        goto LABEL_56;
      }

      if ((v24 - 65) <= 5u)
      {
        CFIndex v25 = v24 - 55;
LABEL_37:
        if (v25 != -1) {
          goto LABEL_41;
        }
      }

      if ((v24 > 0x20 || ((1LL << v24) & 0x100002600LL) == 0) && v24 - 8232 >= 2)
      {
        CFRelease(v7);
        goto LABEL_90;
      }

uint64_t __CreateCFDateFormatter( const __CFAllocator *a1, const __CFLocale *a2, unint64_t a3, unint64_t a4, __objc2_class **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    a1 = (const __CFAllocator *)_CFGetTSD(1u);
    if (!a1) {
      a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x38uLL, 512LL, 0LL, (uint64_t)a5, a6, a7, a8);
  uint64_t v13 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 32) = a4;
    *(void *)(Instance + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a3;
    if (a3 >= 5) {
      *(void *)(Instance + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 2LL;
    }
    if (a4 >= 5) {
      *(void *)(Instance + 32) = 2LL;
    }
    if (a2) {
      Systeuint64_t m = a2;
    }
    else {
      Systeuint64_t m = CFLocaleGetSystem();
    }
    *(void *)(v13 + 24) = CFRetain(System);
    if (&__kCFBooleanTrue == a5)
    {
      uint64_t v15 = CFCalendarCreateWithIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"gregorian");
      CFCalendarSetFirstWeekday(v15, 2LL);
      CFCalendarSetMinimumDaysInFirstWeek(v15, 4LL);
      *(void *)(v13 + 96) = v15;
    }

    *(void *)(v13 + 8_Block_object_dispose(va, 8) = CFTimeZoneCopyDefault();
    CFTypeRef Value = CFLocaleGetValue(*(CFLocaleRef *)(v13 + 24), @"calendar");
    if (Value && CFEqual(Value, @"gregorian")) {
      *(void *)(v13 + 112) = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, -1609459200.0);
    }
    __ResetUDateFormat(v13, 0LL);
    if (!*(void *)(v13 + 16))
    {
      CFRelease((CFTypeRef)v13);
      return 0LL;
    }
  }

  return v13;
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  v14[1] = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  }
  ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString(formatter, formatString);
  CFIndex Length = CFStringGetLength(ForcedString);
  if (*((const __CFString **)formatter + 6) != ForcedString)
  {
    CFIndex v8 = Length;
    if (Length <= 1024)
    {
      if (*((__objc2_class ***)formatter + 10) != &__kCFBooleanTrue
        && *((__objc2_class ***)formatter + 9) == &__kCFBooleanTrue)
      {
        __ResetUDateFormat((uint64_t)formatter, 1LL);
      }

      unint64_t v9 = 2 * v8;
      if ((unint64_t)(2 * v8) < 0x101)
      {
        if (v8 < 1)
        {
          uint64_t v10 = 0LL;
        }

        else
        {
          MEMORY[0x1895F8858](Length, v7);
          uint64_t v10 = (UniChar *)((char *)v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
        }
      }

      else
      {
        uint64_t v10 = (UniChar *)malloc(2 * v8);
      }

      CharactersPtr = (UChar *)CFStringGetCharactersPtr(ForcedString);
      if (!CharactersPtr)
      {
        v15.CFIndex location = 0LL;
        v15.CFIndex length = v8;
        CFStringGetCharacters(ForcedString, v15, v10);
        CharactersPtr = v10;
      }

      __cficu_udat_applyPattern(*((void *)formatter + 2), 0, CharactersPtr, v8);
      int v12 = (const void *)*((void *)formatter + 6);
      if (v12) {
        CFRelease(v12);
      }
      uint64_t v13 = CFGetAllocator(formatter);
      *((void *)formatter + 6) = CFStringCreateCopy(v13, ForcedString);
      *((void *)formatter + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = &__kCFBooleanTrue;
      if (v9 >= 0x101) {
        free(v10);
      }
    }
  }

  if (ForcedString) {
    CFRelease(ForcedString);
  }
}

CFDateFormatterRef CFDateFormatterCreate( CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)__CreateCFDateFormatter( allocator,  locale,  dateStyle,  timeStyle,  &__kCFBooleanFalse,  v4,  v5,  v6);
}

CFLocaleRef CFDateFormatterGetLocale(CFDateFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return (CFLocaleRef)*((void *)formatter + 3);
}

CFDateFormatterStyle CFDateFormatterGetDateStyle(CFDateFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return *((void *)formatter + 5);
}

CFDateFormatterStyle CFDateFormatterGetTimeStyle(CFDateFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return *((void *)formatter + 4);
}

CFStringRef CFDateFormatterGetFormat(CFDateFormatterRef formatter)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  }
  return (CFStringRef)*((void *)formatter + 6);
}

CFTypeRef __CFDateFormatterCreateForcedString(void *a1, const __CFString *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = (const __CFBoolean *)a1[61];
  if (v4) {
    int v5 = (CFBooleanGetValue(v4) != 0) << 29;
  }
  else {
    int v5 = 0;
  }
  uint64_t v7 = (const __CFBoolean *)a1[60];
  if (v7 && CFBooleanGetValue(v7))
  {
    int v5 = 0x40000000;
  }

  else if (!v5)
  {
    return CFRetain(a2);
  }

  if (__CFDateFormatterCreateForcedString_onceToken != -1) {
    dispatch_once(&__CFDateFormatterCreateForcedString_onceToken, &__block_literal_global_31);
  }
  CFRange result = (CFRange)xmmword_180C33AB0;
  CFIndex v8 = (const __CFCharacterSet *)__CFDateFormatterCreateForcedString_hourCharacters;
  v24.CFIndex length = CFStringGetLength(a2);
  v24.CFIndex location = 0LL;
  if (CFStringFindCharacterFromSet(a2, v8, v24, 0LL, &result) && result.location != -1)
  {
    uint64_t v18 = 0LL;
    BOOL v19 = &v18;
    uint64_t v20 = 0x2020000000LL;
    uint64_t v21 = 0LL;
    uint64_t v14 = 0LL;
    CFRange v15 = (int *)&v14;
    uint64_t v16 = 0x2020000000LL;
    int v17 = 0;
    unint64_t v9 = (const __CFLocale *)a1[3];
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    size_t v12[2] = ____CFDateFormatterCreateForcedString_block_invoke_2;
    v12[3] = &unk_1899964B8;
    v12[5] = &v18;
    v12[6] = a2;
    int v13 = v5;
    v12[4] = &v14;
    int v10 = useTemplatePatternGenerator(v9, (uint64_t)v12);
    CFTypeRef v6 = (CFTypeRef)v19[3];
    if (v10)
    {
      if (v6)
      {
        if (v15[6] > 0)
        {
LABEL_23:
          _Block_object_dispose(&v14, 8);
          _Block_object_dispose(&v18, 8);
          return v6;
        }

        goto LABEL_21;
      }
    }

    else if (v6)
    {
LABEL_21:
      CFRelease((CFTypeRef)v19[3]);
    }

    CFTypeRef v6 = CFRetain(a2);
    goto LABEL_23;
  }

  return CFRetain(a2);
}

void sub_180A8FEB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void __ResetUDateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  int v4 = v3;
  uint64_t v5 = v2;
  uint64_t v165 = *MEMORY[0x1895F89C0];
  CFTypeRef v6 = (void *)MEMORY[0x186E03CAC]();
  uint64_t v7 = *(const void **)(v5 + 16);
  if (v7) {
    __cficu_udat_close(v7);
  }
  *(void *)(v5 + 16) = 0LL;
  v162[0] = 0;
  CFIndex v8 = *(const __CFLocale **)(v5 + 24);
  if (v8) {
    CFStringRef Identifier = CFLocaleGetIdentifier(v8);
  }
  else {
    CFStringRef Identifier = &stru_1899EF170;
  }
  CFStringGetCString(Identifier, v162, 768LL, 0x600u);
  v161[0] = 0;
  BOOL v11 = (uint64_t *)(v5 + 88);
  uint64_t v10 = *(const __CFTimeZone **)(v5 + 88);
  if (v10)
  {
    Name = CFTimeZoneGetName(v10);
    if (!Name)
    {
      uint64_t v13 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        __ResetUDateFormat_cold_1(v11, v13);
      }
      goto LABEL_233;
    }
  }

  else
  {
    Name = @"GMT";
  }

  if (CFStringGetLength(Name) <= 768) {
    CFIndex Length = CFStringGetLength(Name);
  }
  else {
    CFIndex Length = 768LL;
  }
  v166.CFIndex location = 0LL;
  v166.CFIndex length = Length;
  CFStringGetCharacters(Name, v166, v161);
  unint64_t v15 = *(void *)(v5 + 40);
  if (v15 > 3) {
    int v16 = 0;
  }
  else {
    int v16 = dword_180C33AC0[v15];
  }
  switch(*(void *)(v5 + 32))
  {
    case 0LL:
      int v17 = -1;
      char v18 = 1;
      break;
    case 1LL:
      char v18 = 0;
      int v17 = 3;
      break;
    case 2LL:
      char v18 = 0;
      int v17 = 2;
      break;
    case 3LL:
      char v18 = 0;
      int v17 = 1;
      break;
    default:
      char v18 = 0;
      int v17 = 0;
      break;
  }

  BOOL v19 = *(__objc2_class ***)(v5 + 72);
  uint64_t v20 = *(__objc2_class ***)(v5 + 80);
  if (v19) {
    BOOL v21 = v19 == &__kCFBooleanTrue;
  }
  else {
    BOOL v21 = 0;
  }
  int v22 = !v21;
  if (v20) {
    BOOL v23 = v20 == &__kCFBooleanTrue;
  }
  else {
    BOOL v23 = 0;
  }
  if (!v23 && v4 == 0) {
    int v25 = v22;
  }
  else {
    int v25 = 1;
  }
  if (v15) {
    int v26 = v25;
  }
  else {
    int v26 = 1;
  }
  if (v26) {
    int v27 = v16;
  }
  else {
    int v27 = v16 | 0x80;
  }
  int v159 = 0;
  uint64_t v28 = __cficu_udat_open(v17, v27, (uint64_t)v162, v161, Length, 0LL, 0LL, &v159);
  if (v28) {
    BOOL v29 = v159 <= 0;
  }
  else {
    BOOL v29 = 0;
  }
  if (v29)
  {
    uint64_t v30 = v28;
    if ((v22 & 1) == 0) {
      __cficu_udat_setContext(v28, 259, &v159);
    }
    int v158 = v25;
    uint64_t v31 = *(__objc2_class ***)(v5 + 64);
    if (v31) {
      BOOL v32 = &__kCFBooleanTrue == v31;
    }
    else {
      BOOL v32 = 0;
    }
    int v33 = v32;
    __cficu_udat_setLenient(v30, v33);
    if (!*(void *)(v5 + 40) && !*(void *)(v5 + 32)) {
      __cficu_udat_applyPattern(v30, 0, 0LL, 0LL);
    }
    if (v22 && *(__objc2_class ***)(v5 + 80) == &__kCFBooleanTrue)
    {
      CFIndex v34 = CFStringGetLength(*(CFStringRef *)(v5 + 48));
      CFIndex v36 = v34;
      unint64_t v37 = 2 * v34;
      if ((unint64_t)(2 * v34) < 0x101)
      {
        if (v34 < 1)
        {
          int v38 = 0LL;
        }

        else
        {
          MEMORY[0x1895F8858](v34, v35);
          int v38 = (UniChar *)((char *)&v157 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL));
        }
      }

      else
      {
        int v38 = (UniChar *)malloc(2 * v34);
      }

      CharactersPtr = (UChar *)CFStringGetCharactersPtr(*(CFStringRef *)(v5 + 48));
      if (!CharactersPtr)
      {
        v167.CFIndex location = 0LL;
        v167.CFIndex length = v36;
        CFStringGetCharacters(*(CFStringRef *)(v5 + 48), v167, v38);
        CharactersPtr = v38;
      }

      __cficu_udat_applyPattern(v30, 0, CharactersPtr, v36);
      if (v37 >= 0x101) {
        free(v38);
      }
    }

    CFTypeRef Value = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), @"calendar");
    if (Value && CFEqual(Value, @"gregorian"))
    {
      int v159 = 0;
      __cficu_udat_set2DigitYearStart(v30, &v159, -6.31152e11);
    }

    *(void *)(v5 + 16) = v30;
    AppleICUDateTimeSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateTimeSymbolsPref( *(void **)(v5 + 24),  v41);
    if (AppleICUDateTimeSymbolsPref)
    {
      uint64_t v44 = AppleICUDateTimeSymbolsPref;
      CFTypeID v45 = CFGetTypeID(AppleICUDateTimeSymbolsPref);
      if (v45 == CFDictionaryGetTypeID()) {
        CFDictionaryApplyFunction(v44, (CFDictionaryApplierFunction)__CFDateFormatterStoreSymbolPrefs, (void *)v5);
      }
    }

    AppleFirstWeekdayPref = (const void *)_CFLocaleGetAppleFirstWeekdayPref(*(void **)(v5 + 24), v43);
    if (AppleFirstWeekdayPref)
    {
      uint64_t v48 = AppleFirstWeekdayPref;
      CFTypeID v49 = CFGetTypeID(AppleFirstWeekdayPref);
      if (v49 == CFDictionaryGetTypeID())
      {
        int v50 = *(const void **)(v5 + 512);
        if (v50) {
          CFRelease(v50);
        }
        *(void *)(v5 + 512) = CFRetain(v48);
      }
    }

    AppleMinDaysInFirstWeekPref = (const void *)_CFLocaleGetAppleMinDaysInFirstWeekPref(*(void **)(v5 + 24), v47);
    if (AppleMinDaysInFirstWeekPref)
    {
      uint64_t v53 = AppleMinDaysInFirstWeekPref;
      CFTypeID v54 = CFGetTypeID(AppleMinDaysInFirstWeekPref);
      if (v54 == CFDictionaryGetTypeID())
      {
        uint64_t v55 = *(const void **)(v5 + 520);
        if (v55) {
          CFRelease(v55);
        }
        *(void *)(v5 + 52_CFBundleUnloadExecutable((uint64_t)bundle, 0) = CFRetain(v53);
      }
    }

    AppleICUForce24HourTimePref = (const void *)_CFLocaleGetAppleICUForce24HourTimePref(*(void **)(v5 + 24), v52);
    if (AppleICUForce24HourTimePref)
    {
      int v58 = AppleICUForce24HourTimePref;
      CFTypeID v59 = CFGetTypeID(AppleICUForce24HourTimePref);
      if (v59 == CFBooleanGetTypeID())
      {
        BOOL v60 = *(const void **)(v5 + 480);
        if (v60) {
          CFRelease(v60);
        }
        *(void *)(v5 + 48_CFBundleUnloadExecutable((uint64_t)bundle, 0) = CFRetain(v58);
      }
    }

    AppleICUForce12HourTimePref = (const void *)_CFLocaleGetAppleICUForce12HourTimePref(*(void **)(v5 + 24), v57);
    if (AppleICUForce12HourTimePref)
    {
      BOOL v63 = AppleICUForce12HourTimePref;
      CFTypeID v64 = CFGetTypeID(AppleICUForce12HourTimePref);
      if (v64 == CFBooleanGetTypeID())
      {
        int v65 = *(const void **)(v5 + 488);
        if (v65) {
          CFRelease(v65);
        }
        *(void *)(v5 + 48_Block_object_dispose(va, 8) = CFRetain(v63);
      }
    }

    AppleICUDateFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateFormatStringsPref( *(void **)(v5 + 24),  v62);
    if (AppleICUDateFormatStringsPref)
    {
      int v68 = AppleICUDateFormatStringsPref;
      CFTypeID v69 = CFGetTypeID(AppleICUDateFormatStringsPref);
      if (v69 == CFDictionaryGetTypeID())
      {
        unint64_t v70 = *(void *)(v5 + 40) - 1LL;
        int v71 = v70 > 3 ? @"0" : *(&off_1899964D8 + v70);
        unint64_t v72 = CFDictionaryGetValue(v68, v71);
        if (v72)
        {
          unint64_t v73 = v72;
          CFTypeID v74 = CFGetTypeID(v72);
          if (v74 == CFStringGetTypeID())
          {
            unint64_t v75 = *(const void **)(v5 + 464);
            if (v75) {
              CFRelease(v75);
            }
            *(void *)(v5 + 464) = CFRetain(v73);
          }
        }
      }
    }

    AppleICUTimeFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUTimeFormatStringsPref( *(void **)(v5 + 24),  v67);
    if (AppleICUTimeFormatStringsPref)
    {
      uint64_t v77 = AppleICUTimeFormatStringsPref;
      CFTypeID v78 = CFGetTypeID(AppleICUTimeFormatStringsPref);
      if (v78 == CFDictionaryGetTypeID())
      {
        unint64_t v79 = *(void *)(v5 + 32) - 1LL;
        int64_t v80 = v79 > 3 ? @"0" : *(&off_1899964D8 + v79);
        uint64_t v81 = CFDictionaryGetValue(v77, v80);
        if (v81)
        {
          int v82 = v81;
          CFTypeID v83 = CFGetTypeID(v81);
          if (v83 == CFStringGetTypeID())
          {
            uint64_t v84 = *(const void **)(v5 + 472);
            if (v84) {
              CFRelease(v84);
            }
            *(void *)(v5 + 472) = CFRetain(v82);
          }
        }
      }
    }

    CFTypeRef v85 = *(CFTypeRef *)(v5 + 104);
    if (!v85) {
      CFTypeRef v85 = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), @"calendar");
    }
    v163[0] = 0;
    uint64_t Calendar = __cficu_udat_getCalendar(*(void *)(v5 + 16));
    if (!*(void *)(v5 + 96) && !*(void *)(v5 + 104)
      || (unint64_t v87 = CFLocaleGetIdentifier(*(CFLocaleRef *)(v5 + 24)),
          (Uuint64_t Calendar = (const void *)__CFCalendarCreateUCalendar(0LL, v87, *(const __CFTimeZone **)(v5 + 88))) == 0LL))
    {
      Uuint64_t Calendar = (const void *)__cficu_ucal_clone(Calendar, v163);
    }

    CFTypeRef v157 = v85;
    int v89 = *(__objc2_class ***)(v5 + 64);
    if (v89)
    {
      v163[0] = 0;
      __cficu_ucal_setAttribute((uint64_t)UCalendar, 0, &__kCFBooleanTrue == v89);
    }

    unint64_t v90 = (const __CFTimeZone *)*v11;
    if (*v11)
    {
      v163[0] = 0;
      unint64_t v91 = CFTimeZoneGetName(v90);
      CFIndex v92 = CFStringGetLength(v91);
      char v93 = v18;
      unint64_t v94 = v6;
      if (v92 >= 768) {
        CFIndex v95 = 768LL;
      }
      else {
        CFIndex v95 = v92;
      }
      v168.CFIndex location = 0LL;
      v168.CFIndex length = v95;
      CFStringGetCharacters(v91, v168, (UniChar *)v164);
      int32_t v96 = v95;
      CFTypeRef v6 = v94;
      char v18 = v93;
      BOOL v11 = (uint64_t *)(v5 + 88);
      __cficu_ucal_setTimeZone((uint64_t)UCalendar, (UChar *)v164, v96, v163);
    }

    unint64_t v97 = *(const __CFDate **)(v5 + 128);
    if (v97)
    {
      v163[0] = 0;
      double v98 = CFDateGetAbsoluteTime(v97) + 978307200.0;
      CFTypeRef v99 = v157;
    }

    else
    {
      CFTypeRef v99 = v157;
      if (!v157 || !CFEqual(v157, @"gregorian"))
      {
LABEL_133:
        unint64_t v100 = *(__CFCalendar **)(v5 + 96);
        if (v100)
        {
          int FirstWeekday = CFCalendarGetFirstWeekday(v100);
          uint64_t v102 = (uint64_t)UCalendar;
        }

        else
        {
          char v110 = *(const __CFDictionary **)(v5 + 512);
          if (!v110
            || (unint64_t v111 = (const __CFNumber *)CFDictionaryGetValue(v110, v99)) == 0LL
            || (unint64_t v112 = v111, v113 = CFGetTypeID(v111), v113 != CFNumberGetTypeID())
            || !CFNumberGetValue(v112, kCFNumberCFIndexType, v164))
          {
LABEL_136:
            unint64_t v103 = *(__CFCalendar **)(v5 + 96);
            if (v103)
            {
              MinimumDaysInFirstWeeuint64_t k = CFCalendarGetMinimumDaysInFirstWeek(v103);
              __cficu_ucal_setAttribute((uint64_t)UCalendar, 2u, MinimumDaysInFirstWeek);
              char v105 = v158;
            }

            else
            {
              uint64_t v114 = *(const __CFDictionary **)(v5 + 520);
              char v105 = v158;
              if (v114)
              {
                uint64_t v115 = (const __CFNumber *)CFDictionaryGetValue(v114, v99);
                if (v115)
                {
                  unint64_t v116 = v115;
                  CFTypeID v117 = CFGetTypeID(v115);
                  BOOL v21 = v117 == CFNumberGetTypeID();
                  char v105 = v158;
                  if (v21)
                  {
                    if (CFNumberGetValue(v116, kCFNumberCFIndexType, v164))
                    {
                      v163[0] = 0;
                      __cficu_ucal_setAttribute((uint64_t)UCalendar, 2u, v164[0]);
                    }
                  }
                }
              }
            }

            __cficu_udat_setCalendar(*(void *)(v5 + 16), (uint64_t)UCalendar);
            __cficu_ucal_close(UCalendar);
            if ((v105 & 1) != 0)
            {
              __substituteFormatStringFromPrefsDF(v5, 0);
              __substituteFormatStringFromPrefsDF(v5, 1);
              __ApplyUDateFormatSymbol(v5);
            }

            else
            {
              if (*(void *)(v5 + 40))
              {
                BOOL v106 = *(const __CFString **)(v5 + 464);
                if (!v106
                  || (CFStringGetLength(v106) > 767
                    ? (uint64_t v107 = 768LL)
                    : (uint64_t v107 = CFStringGetLength(*(CFStringRef *)(v5 + 464))),
                      v169.CFIndex location = 0LL,
                      v169.CFIndex length = v107,
                      CFStringGetCharacters(*(CFStringRef *)(v5 + 464), v169, (UniChar *)v164),
                      v107 == -1))
                {
                  v163[0] = 0;
                  int v118 = __cficu_udat_toPatternRelativeDate(*(void *)(v5 + 16), (const UniChar *)v164, 768LL, v163);
                  if (v163[0] > 0) {
                    int v119 = -1;
                  }
                  else {
                    int v119 = v118;
                  }
                  uint64_t v107 = v119;
                }

                if (!*(void *)(v5 + 32)
                  || (unint64_t v120 = *(const __CFString **)(v5 + 472)) == 0LL
                  || (CFStringGetLength(v120) > 767
                    ? (uint64_t v121 = 768LL)
                    : (uint64_t v121 = CFStringGetLength(*(CFStringRef *)(v5 + 472))),
                      v170.CFIndex location = 0LL,
                      v170.CFIndex length = v121,
                      CFStringGetCharacters(*(CFStringRef *)(v5 + 472), v170, (UniChar *)v163),
                      v121 == -1))
                {
                  v160[0] = 0;
                  int v122 = __cficu_udat_toPatternRelativeTime(*(void *)(v5 + 16), (const UniChar *)v163, 768LL, v160);
                  if (v160[0] > 0) {
                    int v123 = -1;
                  }
                  else {
                    int v123 = v122;
                  }
                  uint64_t v121 = v123;
                }

                v160[0] = 0;
                __cficu_udat_applyPatternRelative( *(void *)(v5 + 16),  (UChar *)((unint64_t)v164 & ~(v107 >> 63)),  v107 & ~(v107 >> 63),  (UChar *)((unint64_t)v163 & ~(v121 >> 63)),  v121 & ~(v121 >> 63),  v160);
              }

              else
              {
                __substituteFormatStringFromPrefsDF(v5, 0);
                __substituteFormatStringFromPrefsDF(v5, 1);
              }

              __ApplyUDateFormatSymbol(v5);
              if (*(void *)(v5 + 40))
              {
                int v159 = 0;
                uint64_t v124 = __cficu_udat_toPatternRelativeDate(v30, (const UniChar *)v164, 768LL, &v159);
                int v125 = 0;
                if ((v18 & 1) == 0) {
                  int v125 = __cficu_udat_toPatternRelativeTime(v30, (const UniChar *)v163, 768LL, &v159);
                }
                if (v159 <= 0 && (int)v124 <= 768 && v125 <= 768)
                {
                  uint64_t v126 = v6;
                  char v127 = CFStringCreateWithCharacters( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UniChar *)v163,  v125);
                  ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString((void *)v5, v127);
                  uint64_t v129 = CFStringGetLength(ForcedString);
                  if (v129 <= 768)
                  {
                    uint64_t v130 = v129;
                    v171.CFIndex location = 0LL;
                    v171.CFIndex length = v129;
                    CFStringGetCharacters(ForcedString, v171, (UniChar *)v163);
                    int v159 = 0;
                    __cficu_udat_applyPatternRelative(v30, (UChar *)v164, v124, (UChar *)v163, v130, &v159);
                    int v159 = 0;
                    int v131 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v160, 768LL, &v159);
                    if (v159 <= 0)
                    {
                      int v132 = v131;
                      if (v131 <= 768)
                      {
                        uint64_t v133 = *(const void **)(v5 + 48);
                        if (v133) {
                          CFRelease(v133);
                        }
                        *(void *)(v5 + 4_Block_object_dispose(va, 8) = CFStringCreateWithCharacters( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UniChar *)v160,  v132);
                      }
                    }
                  }

                  CFRelease(ForcedString);
                  CFRelease(v127);
                  CFTypeRef v6 = v126;
                }

                goto LABEL_207;
              }
            }

            int v159 = 0;
            int v134 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v164, 768LL, &v159);
            if (v159 <= 0 && v134 <= 768)
            {
              uint64_t v135 = CFStringCreateWithCharacters( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UniChar *)v164,  v134);
              uint64_t v136 = (const __CFString *)__CFDateFormatterCreateForcedString((void *)v5, v135);
              CFIndex v137 = CFStringGetLength(v136);
              if (v137 <= 1024)
              {
                CFIndex v139 = v137;
                unint64_t v140 = 2 * v137;
                if ((unint64_t)(2 * v137) < 0x101)
                {
                  if (v137 < 1)
                  {
                    unint64_t v141 = 0LL;
                  }

                  else
                  {
                    MEMORY[0x1895F8858](v137, v138);
                    unint64_t v141 = (UniChar *)((char *)&v157 - ((v140 + 15) & 0xFFFFFFFFFFFFFFF0LL));
                  }
                }

                else
                {
                  unint64_t v141 = (UniChar *)malloc(2 * v137);
                }

                int v142 = (UChar *)CFStringGetCharactersPtr(v136);
                if (!v142)
                {
                  v172.CFIndex location = 0LL;
                  v172.CFIndex length = v139;
                  CFStringGetCharacters(v136, v172, v141);
                  int v142 = v141;
                }

                __cficu_udat_applyPattern(*(void *)(v5 + 16), 0, v142, v139);
                char v143 = *(const void **)(v5 + 48);
                if (v143) {
                  CFRelease(v143);
                }
                unint64_t v144 = CFGetAllocator((CFTypeRef)v5);
                *(void *)(v5 + 4_Block_object_dispose(va, 8) = CFStringCreateCopy(v144, v136);
                if (v140 >= 0x101) {
                  free(v141);
                }
              }

              CFRelease(v136);
              CFRelease(v135);
            }

LABEL_207:
            uint64_t v145 = *(const void **)(v5 + 56);
            if (v145) {
              CFRelease(v145);
            }
            CFTypeRef v146 = *(CFTypeRef *)(v5 + 48);
            if (v146) {
              CFTypeRef v146 = CFRetain(v146);
            }
            *(void *)(v5 + 56) = v146;
            int v147 = *(__CFString **)(v5 + 64);
            if (v147) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterIsLenientKey", v147, 1);
            }
            char v148 = *(__CFString **)(v5 + 72);
            if (v148) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterDoesRelativeDateFormattingKey", v148, 1);
            }
            unint64_t v149 = *(__CFString **)(v5 + 96);
            if (v149) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterCalendarKey", v149, 1);
            }
            uint64_t v150 = *(__CFString **)(v5 + 104);
            if (v150) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterCalendarIdentifierKey", v150, 1);
            }
            if (*v11) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterTimeZoneKey", (__CFString *)*v11, 1);
            }
            unint64_t v151 = *(__CFString **)(v5 + 112);
            if (v151) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterTwoDigitStartDateKey", v151, 1);
            }
            int v152 = *(__CFString **)(v5 + 120);
            if (v152) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterDefaultDateKey", v152, 1);
            }
            uint64_t v153 = *(__CFString **)(v5 + 128);
            if (v153) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterGregorianStartDateKey", v153, 1);
            }
            uint64_t v154 = *(__CFString **)(v5 + 296);
            if (v154) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterAmbiguousYearStrategyKey", v154, 1);
            }
            uint64_t v155 = *(__CFString **)(v5 + 304);
            if (v155) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterUsesCharacterDirectionKey", v155, 1);
            }
            uint64_t v156 = *(__CFString **)(v5 + 312);
            if (v156) {
              __CFDateFormatterSetProperty(v5, @"kCFDateFormatterFormattingContextKey", v156, 1);
            }
            goto LABEL_233;
          }

          v163[0] = 0;
          int FirstWeekday = v164[0];
          uint64_t v102 = (uint64_t)UCalendar;
        }

        __cficu_ucal_setAttribute(v102, 1u, FirstWeekday);
        goto LABEL_136;
      }

      v163[0] = 0;
      double v108 = __cficu_ucal_getGregorianChange(Calendar, v163);
      if (v163[0] <= 0) {
        double v109 = v108 / 1000.0 - 978307200.0;
      }
      else {
        double v109 = -1.31976e10;
      }
      double v98 = v109 + 978307200.0;
      v163[0] = 0;
    }

    __cficu_ucal_setGregorianChange((uint64_t)UCalendar, v163, v98 * 1000.0);
    goto LABEL_133;
  }

LABEL_233:
  objc_autoreleasePoolPop(v6);
}

                if (v18 == 2)
                {
                  if (!__CFStringIsRegionalIndicatorAtIndex(buffer, a2)) {
                    goto LABEL_242;
                  }
                  unint64_t v111 = v8;
                  unint64_t v112 = 0LL;
                  do
                  {
                    CFTypeID v113 = v112;
                    uint64_t v114 = a2 + v112;
                    if (a2 + v112 < 2) {
                      break;
                    }
                    v112 -= 2LL;
                  }

                  while (__CFStringIsRegionalIndicatorAtIndex(buffer, v113 - 2 + a2));
                  if (a2 > v114 && (-(int)v113 & 3LL) != 0)
                  {
                    a2 -= 2LL;
                    char v18 = 4LL;
                    CFIndex v8 = v111;
                    goto LABEL_252;
                  }

                  CFIndex v8 = v111;
                  if (a2 + 4 > v111)
                  {
LABEL_242:
                    char v18 = 2LL;
                    goto LABEL_252;
                  }

                  if (__CFStringIsRegionalIndicatorAtIndex(buffer, a2 + 2)) {
                    char v18 = 4LL;
                  }
                  else {
                    char v18 = 2LL;
                  }
                }

CFStringRef CFDateFormatterCreateStringWithDate( CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  uint64_t v5 = allocator;
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      uint64_t v5 = (const __CFAllocator *)v6;
    }
    else {
      uint64_t v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(date);
  return CFDateFormatterCreateStringWithAbsoluteTime(v5, formatter, AbsoluteTime);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime( CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  uint64_t v5 = allocator;
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      uint64_t v5 = (const __CFAllocator *)v6;
    }
    else {
      uint64_t v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  int v18 = 0;
  double v8 = (at + 978307200.0) * 1000.0 + 0.5;
  int v9 = __cficu_udat_format(*((void *)formatter + 2), v20, 768LL, 0LL, &v18, v8);
  CFIndex v10 = v9;
  int v11 = v18;
  if (v18 == 15 || v9 >= 769)
  {
    uint64_t v13 = v9 + 2LL;
    uint64_t v12 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * v13, 0LL);
    int v18 = 0;
    CFIndex v10 = (int)__cficu_udat_format(*((void *)formatter + 2), v12 + 1, v13, 0LL, &v18, v8);
    int v11 = v18;
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  if (v11 <= 0)
  {
    if (v12) {
      int v16 = v12;
    }
    else {
      int v16 = (UniChar *)&v19;
    }
    if (*((__objc2_class ***)formatter + 38) == &__kCFBooleanTrue
      && (CFStringRef Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
          CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
    {
      *int v16 = 8207;
      ++v10;
    }

    else if (v12)
    {
      int v16 = v12 + 1;
    }

    else
    {
      int v16 = v20;
    }

    uint64_t v14 = CFStringCreateWithCharacters(v5, v16, v10);
    if (v12) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    if (v12) {
LABEL_12:
    }
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
  }

  return v14;
}

__CFAttributedString *_CFDateFormatterCreateAttributedStringAndFieldsWithAbsoluteTime( const __CFAllocator *a1, uint64_t a2, double a3)
{
  uint64_t v5 = a1;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v6 = _CFGetTSD(1u);
    if (v6) {
      uint64_t v5 = (const __CFAllocator *)v6;
    }
    else {
      uint64_t v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v7 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v7 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  }
  int v25 = 0;
  double v8 = (a3 + 978307200.0) * 1000.0 + 0.5;
  uint64_t v9 = ufieldpositer_open();
  int v10 = __cficu_udat_formatForFields(*(void *)(a2 + 16), v27, 768LL, v9, &v25, v8);
  CFIndex v11 = v10;
  int v12 = v25;
  if (v25 == 15 || v10 >= 769)
  {
    uint64_t v14 = v10 + 2LL;
    uint64_t v13 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2 * v14, 0LL);
    int v25 = 0;
    ufieldpositer_close();
    uint64_t v9 = ufieldpositer_open();
    CFIndex v11 = (int)__cficu_udat_formatForFields(*(void *)(a2 + 16), v13 + 1, v14, v9, &v25, v8);
    int v12 = v25;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  if (v12 > 0)
  {
    unint64_t v15 = 0LL;
    if (!v13) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  if (v13) {
    uint64_t v21 = v13;
  }
  else {
    uint64_t v21 = (UniChar *)&v26;
  }
  if (*(__objc2_class ***)(a2 + 304) == &__kCFBooleanTrue
    && (CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 24)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    *uint64_t v21 = 8207;
    ++v11;
  }

  else if (v13)
  {
    uint64_t v21 = v13 + 1;
  }

  else
  {
    uint64_t v21 = v27;
  }

  unint64_t v15 = CFStringCreateWithCharacters(v5, v21, v11);
  if (v13) {
LABEL_12:
  }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
LABEL_13:
  if (!v15)
  {
    CFMutableArrayRef Mutable = 0LL;
    if (!v9) {
      return Mutable;
    }
    goto LABEL_19;
  }

  CFIndex Length = CFStringGetLength(v15);
  CFMutableArrayRef Mutable = CFAttributedStringCreateMutable(v5, Length);
  v29.CFIndex location = 0LL;
  v29.CFIndex length = 0LL;
  CFAttributedStringReplaceString(Mutable, v29, v15);
  CFRelease(v15);
  for (unsigned int i = ufieldpositer_next(); (i & 0x80000000) == 0; unsigned int i = ufieldpositer_next())
  {
    if (i <= 0x23)
    {
      CFStringRef v19 = CFStringCreateWithBytes(v5, (const UInt8 *)&aGymdkhmssedfww[i], 1LL, 0x600u, 0);
      v30.CFIndex location = v24;
      v30.CFIndex length = v23 - (uint64_t)v24;
      CFAttributedStringSetAttribute(Mutable, v30, @"kCFDateFormatterPatternCharacterKey", v19);
      CFRelease(v19);
    }
  }

  if (v9) {
LABEL_19:
  }
    ufieldpositer_close();
  return Mutable;
}

CFDateRef CFDateFormatterCreateDateFromString( CFAllocatorRef allocator, CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep)
{
  unint64_t v7 = allocator;
  at[1] = *(CFAbsoluteTime *)MEMORY[0x1895F89C0];
  if (!allocator)
  {
    uint64_t v8 = _CFGetTSD(1u);
    if (v8) {
      unint64_t v7 = (const __CFAllocator *)v8;
    }
    else {
      unint64_t v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  unint64_t v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v9);
  }
  if (CFDateFormatterGetAbsoluteTimeFromString(formatter, string, rangep, at)) {
    return CFDateCreate(v7, at[0]);
  }
  else {
    return 0LL;
  }
}

Boolean CFDateFormatterGetAbsoluteTimeFromString( CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  valuePtr[1] = *MEMORY[0x1895F89C0];
  unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v8);
  }
  if (rangep)
  {
    CFIndex location = rangep->location;
    CFIndex length = rangep->length;
  }

  else
  {
    CFIndex length = CFStringGetLength(string);
    CFIndex location = 0LL;
  }

  if (length >= 1024) {
    CFIndex v11 = 1024LL;
  }
  else {
    CFIndex v11 = length;
  }
  CharactersPtr = CFStringGetCharactersPtr(string);
  uint64_t v14 = MEMORY[0x1895F8858](CharactersPtr, v13);
  int v16 = (UChar *)((char *)&v60 - v15);
  if (v14)
  {
    int v16 = (UChar *)(v14 + 2 * location);
  }

  else
  {
    v63.CFIndex location = location;
    v63.CFIndex length = v11;
    CFStringGetCharacters(string, v63, (UniChar *)((char *)&v60 - v15));
  }

  uint64_t v61 = 0LL;
  int v17 = (const void *)__cficu_udat_clone(*((void *)formatter + 2), (int *)&v61);
  uint64_t Calendar = __cficu_udat_getCalendar((uint64_t)v17);
  CFStringRef v19 = (const void *)__cficu_ucal_clone(Calendar, (int *)&v61);
  CFTypeRef v20 = CFDateFormatterCopyProperty(formatter, @"kCFDateFormatterCalendarIdentifierKey");
  if (CFEqual(v20, @"chinese") || CFEqual(v20, @"japanese"))
  {
    if (CFEqual(v20, @"chinese"))
    {
      __cficu_ucal_clear((uint64_t)v19);
      uint64_t v21 = (uint64_t)v19;
      int v22 = 1;
    }

    else
    {
      if (!CFEqual(v20, @"japanese")) {
        goto LABEL_18;
      }
      double Now = __cficu_ucal_getNow();
      __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, Now);
      int v24 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
      __cficu_ucal_clear((uint64_t)v19);
      uint64_t v21 = (uint64_t)v19;
      int v22 = v24;
    }

    __cficu_ucal_set(v21, 0, v22);
  }

  else
  {
    __cficu_ucal_clear((uint64_t)v19);
    __cficu_ucal_set((uint64_t)v19, 1u, 12000);
    __cficu_udat_set2DigitYearStart((uint64_t)v17, (int *)&v61, 3.16516205e14);
  }

LABEL_81:
    uint64_t v53 = (uint64_t)v19;
    double v54 = Millis;
    int v30 = v51;
LABEL_67:
    int v55 = 1;
LABEL_68:
    double v49 = __CFDateFormatterCorrectTimeWithTarget(v53, v30, v55, (int *)&v61, v54);
  }

  else
  {
    int v35 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    int v36 = v35 - 12000;
    int v37 = v35;
    if (!*((void *)formatter + 14))
    {
      switch(valuePtr[0])
      {
        case 0LL:
          goto LABEL_74;
        case 2LL:
          double v50 = __cficu_ucal_getNow();
          __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v50);
          int v30 = (unsigned __int16)v37 % 0x64u + 100 * ((int)__cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61) / 100);
          goto LABEL_87;
        case 3LL:
          uint64_t v43 = (uint64_t)v19;
          double v44 = Millis;
          uint64_t v45 = 100LL;
          uint64_t v46 = 50LL;
          int v48 = 0;
          uint64_t v47 = 49LL;
          goto LABEL_45;
        case 4LL:
          uint64_t v43 = (uint64_t)v19;
          double v44 = Millis;
          uint64_t v45 = 100LL;
          uint64_t v46 = 0LL;
          uint64_t v47 = 99LL;
          goto LABEL_92;
        case 5LL:
          uint64_t v43 = (uint64_t)v19;
          double v44 = Millis;
          uint64_t v45 = 100LL;
          uint64_t v46 = 99LL;
          uint64_t v47 = 0LL;
LABEL_92:
          int v48 = 0;
          goto LABEL_45;
        case 6LL:
          uint64_t v43 = (uint64_t)v19;
          double v44 = Millis;
          uint64_t v45 = 100LL;
          uint64_t v46 = 9LL;
          int v48 = 0;
          uint64_t v47 = 90LL;
          goto LABEL_45;
        case 7LL:
          uint64_t v43 = (uint64_t)v19;
          double v44 = Millis;
          uint64_t v45 = 100LL;
          uint64_t v46 = 90LL;
          int v48 = 0;
          uint64_t v47 = 9LL;
          goto LABEL_45;
        default:
          if (!CFEqual(v20, @"gregorian")) {
            goto LABEL_73;
          }
          unsigned int v58 = (unsigned __int16)v37 % 0x64u;
          if (v58 >= 0x32) {
            int v59 = 1900;
          }
          else {
            int v59 = 2000;
          }
          int v30 = v59 + v58;
LABEL_87:
          uint64_t v53 = (uint64_t)v19;
          double v54 = Millis;
          int v55 = 0;
          goto LABEL_68;
      }
    }

    int v38 = (const void *)__cficu_ucal_clone((uint64_t)v19, (int *)&v61);
    __cficu_ucal_clear((uint64_t)v38);
    double v39 = (CFDateGetAbsoluteTime(*((CFDateRef *)formatter + 14)) + 978307200.0) * 1000.0;
    __cficu_ucal_setMillis((uint64_t)v38, (int *)&v61, v39);
    int v40 = __cficu_ucal_get((uint64_t)v38, 1u, (int *)&v61);
    int v41 = v40;
    int v42 = v40 % 100;
    if (v40 % 100 >= v36)
    {
      if (v36 >= v42)
      {
        __cficu_ucal_set((uint64_t)v19, 1u, v40);
      }

      else
      {
        int v41 = v37 + v40 - v42 - 11900;
      }
    }

    else
    {
      int v41 = v40 + v36 - v42;
    }

    __cficu_ucal_close(v38);
    __cficu_ucal_set((uint64_t)v19, 1u, v41);
    double v49 = __cficu_ucal_getMillis((uint64_t)v19, (int *)&v61);
  }

  double Millis = v49;
LABEL_73:
  if ((int)v61 <= 0)
  {
    if (atp) {
      *atp = Millis / 1000.0 - 978307200.0;
    }
    Boolean v56 = 1;
    if (v20) {
      goto LABEL_75;
    }
    goto LABEL_76;
  }

        if (v31) {
          *a3 |= a10;
        }
        CFMutableArrayRef Mutable = *a2;
        if (!*a2)
        {
          CFMutableArrayRef Mutable = CFStringCreateMutable(a1, 0LL);
          *a2 = Mutable;
        }

        CFStringAppendCharacters(Mutable, (const UniChar *)(a5 + 2LL * *a9), v32 - *a9);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v32 + 1;
        }

        else if (a11 == 134217984)
        {
          int v36 = v32 + 1;
          if (v32 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            int v41 = *(_WORD *)(a5 + 2 * v36);
            if ((v41 & 0xFC00) == 0xDC00)
            {
              double v50 = v49;
              uint64_t v51 = v41;
              else {
                int v36 = v32;
              }
              uint64_t v15 = 1;
              goto LABEL_95;
            }
          }
        }

        uint64_t v15 = 1;
LABEL_94:
        int v36 = v32;
        goto LABEL_95;
      }

      int v36 = a7;
LABEL_95:
      double v32 = v36 + 1;
      if (v36 + 1 >= a8) {
        return v15;
      }
    }
  }

  if (a7 < a8)
  {
    uint64_t v15 = 0;
    uint64_t v45 = a8 - 1;
    if (a3) {
      int v16 = a10 == 0;
    }
    else {
      int v16 = 1;
    }
    int v17 = !v16;
    int v18 = a7;
    while (1)
    {
      CFStringRef v19 = *(char *)(a4 + v18);
      double v49 = *(char *)(a4 + v18);
      if ((v19 & 0x80000000) == 0)
      {
        if ((sURLValidCharacters[(unsigned __int16)v19] & 1) != 0)
        {
          if (a10 == 4 || a10 == 2)
          {
            int v23 = (unsigned __int16)v19 - 47;
            uint64_t v21 = v23 > 0x11;
            int v24 = (1 << v23) & 0x30001;
            if (!v21 && v24 != 0) {
              goto LABEL_30;
            }
          }

          goto LABEL_43;
        }

        CFTypeRef v20 = v18 + 2;
        uint64_t v21 = v19 == 37 && v20 < a8;
        if (v21
          && (*(char *)(v18 + a4 + 1) & 0x80000000) == 0
          && (sURLValidCharacters[*(unsigned __int8 *)(v18 + a4 + 1)] & 0x10) != 0)
        {
          uint64_t v28 = *(char *)(a4 + v20);
        }
      }

      if (a10 != 8) {
        goto LABEL_30;
      }
      if (v18 != a7 || v19 != 91)
      {
        if (v18 == v45)
        {
          int v22 = v45;
          if (v19 == 93) {
            goto LABEL_44;
          }
        }

    if ((*((_WORD *)a2 + 17) & 0x2000) != 0) {
      CFStringAppendFormat(a1, 0LL, @"class '%s'\n", (char *)a2 + 37);
    }
    else {
      CFStringAppendFormat(a1, 0LL, @"conforms to protocol '%s'\n", (char *)a2 + 37);
    }
    goto LABEL_112;
  }

  uint64_t v6 = a3;
  do
  {
    CFStringAppendFormat(a1, 0LL, @"    ");
    --v6;
  }

  while (v6);
  if (!*((_BYTE *)a2 + 36)) {
    goto LABEL_81;
  }
  CFStringAppendFormat(a1, 0LL, @"type encoding (%c) '%s'\n", *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
  if (a3)
  {
    unint64_t v7 = a3;
    do
    {
      CFStringAppendFormat(a1, 0LL, @"    ");
      --v7;
    }

    while (v7);
  }

    if (v48 < v44 && v46 <= 0xF) {
      break;
    }
    if (v48 < v44) {
      uint64_t v51 = v40;
    }
    else {
      uint64_t v51 = v40 + 1;
    }
    mdict_rehashd((uint64_t)v78, v51);
    int v40 = (unint64_t)v9[1] >> 58;
    LODWORD(v41) = __NSDictionarySizes_0[v40];
  }

  BOOL v52 = *(void **)(v43 + 8 * v48);
  uint64_t v53 = v43 + 8 * v44;
  double v54 = v77;
  if ((v77 & 0x200000000000000LL) != 0) {
    [v78 willChangeValueForKey:a4];
  }
  int v55 = *(void *)(v53 + 8 * v48);
  if (v52 == &___NSDictionaryM_DeletedMarker || v52 == 0LL)
  {
    *(void *)(v43 + 8 * v4_Block_object_dispose(va, 8) = a4;
    *(void *)(v53 + 8 * v4_Block_object_dispose(va, 8) = v76;
    unsigned int v58 = v9[1];
    int v59 = (v58 + 0x100000000LL) & 0x1FFFFFF00000000LL;
    v9[1] = v59 | v58 & 0xFE000000FFFFFFFFLL;
  }

  else
  {
    *(void *)(v53 + 8 * v4_Block_object_dispose(va, 8) = v76;
  }

  if ((v54 & 0x200000000000000LL) != 0) {
    [v78 didChangeValueForKey:a4];
  }
  if (v55 >= 1) {

  }
  if (getenv("__setObject_throw_on_warning")) {
    goto LABEL_119;
  }
}

LABEL_74:
  Boolean v56 = 0;
  if (v20) {
LABEL_75:
  }
    CFRelease(v20);
LABEL_76:
  __cficu_udat_close(v17);
  __cficu_ucal_close(v19);
  return v56;
}

        double v29 = v58;
        int v23 = v55;
        int v27 = v53;
      }

      v29->CFIndex length = v38 - v29->location;
    }

    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 5));
    uint64_t v46 = (const void *)*((void *)formatter + 8);
    if (v46) {
      CFRelease(v46);
    }
  }

  else if (v29)
  {
    v29->CFIndex length = location - v29->location + SHIDWORD(v61);
  }

  *int v23 = v57;
  CFRelease(v10);
  int v48 = *v23;
  if (*v23)
  {
    v62[0] = 0x3FF0000000000000LL;
    CFTypeRef Value = CFNumberGetValue(v48, kCFNumberFloat64Type, v62);
    double v50 = *(double *)v62;
    if (!Value) {
      double v50 = 1.0;
    }
    int v27 = (uint64_t)((double)v27 / v50);
    uint64_t v28 = v28 / v50;
  }

  switch(numberType)
  {
    case kCFNumberSInt8Type:
    case kCFNumberCharType:
      *Boolean v56 = v27;
      return 1;
    case kCFNumberSInt16Type:
    case kCFNumberShortType:
      *(_WORD *)Boolean v56 = v27;
      return 1;
    case kCFNumberSInt32Type:
    case kCFNumberIntType:
      *(_DWORD *)Boolean v56 = v27;
      return 1;
    case kCFNumberSInt64Type:
    case kCFNumberLongType:
    case kCFNumberLongLongType:
    case kCFNumberCFIndexType:
      *(void *)Boolean v56 = v27;
      return 1;
    case kCFNumberFloat32Type:
    case kCFNumberFloatType:
      CFRange result = 0;
      if (v28 < -3.40282347e38 || v28 > 3.40282347e38) {
        return result;
      }
      uint64_t v51 = v28;
      *(float *)Boolean v56 = v51;
      break;
    case kCFNumberFloat64Type:
    case kCFNumberDoubleType:
      CFRange result = 0;
      if (v28 < -1.79769313e308 || v28 > 1.79769313e308) {
        return result;
      }
      *(double *)Boolean v56 = v28;
      break;
    default:
      return 0;
  }

  return 1;
}

                __cficu_unum_setAttribute(v11, v12, v10);
                goto LABEL_110;
              }

              int v40 = CFStringGetLength((CFStringRef)value);
              if (v40 >= 768) {
                int v18 = 768LL;
              }
              else {
                int v18 = v40;
              }
              v63.CFIndex location = 0LL;
              v63.CFIndex length = v18;
              CFStringGetCharacters((CFStringRef)value, v63, buffer);
              CFStringRef v19 = *((void *)formatter + 2);
              CFTypeRef v20 = 17;
            }

CFTypeRef CFDateFormatterCopyProperty(CFDateFormatterRef formatter, CFDateFormatterKey key)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  }
  int v26 = 0;
  if (@"kCFDateFormatterIsLenientKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 8);
    if (result) {
      return CFRetain(result);
    }
    int isLenient = __cficu_udat_isLenient(*((void *)formatter + 2));
    unint64_t v8 = (CFTypeRef *)&kCFBooleanTrue;
    if (!isLenient) {
      unint64_t v8 = (CFTypeRef *)&kCFBooleanFalse;
    }
LABEL_42:
    CFTypeRef result = *v8;
    return CFRetain(result);
  }

  if (@"kCFDateFormatterDoesRelativeDateFormattingKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 9);
    if (result) {
      return CFRetain(result);
    }
LABEL_41:
    unint64_t v8 = (CFTypeRef *)&kCFBooleanFalse;
    goto LABEL_42;
  }

  if (@"kCFDateFormatterCalendarKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 12);
    if (result) {
      return CFRetain(result);
    }
    unint64_t v9 = (const __CFLocale *)*((void *)formatter + 3);
    int v10 = (CFLocaleKey *)&kCFLocaleCalendarKey;
    goto LABEL_47;
  }

  if (@"kCFDateFormatterCalendarIdentifierKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 13);
    if (result) {
      return CFRetain(result);
    }
    unint64_t v9 = (const __CFLocale *)*((void *)formatter + 3);
    int v10 = (CFLocaleKey *)&kCFLocaleCalendarIdentifierKey;
LABEL_47:
    CFTypeRef result = CFLocaleGetValue(v9, *v10);
    if (result) {
      return CFRetain(result);
    }
    return result;
  }

  if (@"kCFDateFormatterTimeZoneKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 11);
    if (result) {
      return CFRetain(result);
    }
    return result;
  }

  if (@"kCFDateFormatterDefaultFormatKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 7);
    if (result) {
      return CFRetain(result);
    }
    return result;
  }

  if (@"kCFDateFormatterTwoDigitStartDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 14);
    if (result) {
      return CFRetain(result);
    }
    return result;
  }

  if (@"kCFDateFormatterDefaultDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 15);
    if (result) {
      return CFRetain(result);
    }
    return result;
  }

  if (@"kCFDateFormatterGregorianStartDateKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 16);
    if (result) {
      return CFRetain(result);
    }
    uint64_t Calendar = __cficu_udat_getCalendar(*((void *)formatter + 2));
    double v12 = __cficu_ucal_getGregorianChange(Calendar, &v26);
    if (v26 > 0) {
      return 0LL;
    }
    CFAbsoluteTime v15 = v12 / 1000.0 - 978307200.0;
    int v16 = CFGetAllocator(formatter);
    return CFDateCreate(v16, v15);
  }

  if (@"kCFDateFormatterEraSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 17);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 0;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterLongEraSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 18);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 7;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 19);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 1;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterShortMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 20);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 2;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterVeryShortMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 21);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 8;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 22);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 10;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterShortStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 23);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 11;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterVeryShortStandaloneMonthSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 24);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 12;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 25);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 3;
    goto LABEL_93;
  }

  if (@"kCFDateFormatterShortWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 26);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 4;
    goto LABEL_93;
  }

  if (@"kCFDateFormatterVeryShortWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 27);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 9;
    goto LABEL_93;
  }

  if (@"kCFDateFormatterStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 28);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 13;
    goto LABEL_93;
  }

  if (@"kCFDateFormatterShortStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 29);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 14;
    goto LABEL_93;
  }

  if (@"kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 30);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 15;
LABEL_93:
    unsigned int v17 = 1;
    return __CFDateFormatterCopySymbolsArray(v13, v14, v17);
  }

  if (@"kCFDateFormatterQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 31);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 16;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterShortQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 32);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 17;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterStandaloneQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 33);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 18;
    goto LABEL_79;
  }

  if (@"kCFDateFormatterShortStandaloneQuarterSymbolsKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 34);
    if (result) {
      return CFRetain(result);
    }
    uint64_t v13 = *((void *)formatter + 2);
    unsigned int v14 = 19;
LABEL_79:
    unsigned int v17 = 0;
    return __CFDateFormatterCopySymbolsArray(v13, v14, v17);
  }

  if (@"kCFDateFormatterAMSymbolKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 35);
    if (result) {
      return CFRetain(result);
    }
    int v18 = __cficu_udat_countSymbols(*((void *)formatter + 2), 5u);
    if (v18 < 2) {
      return 0LL;
    }
    unsigned int v19 = v18;
    uint64_t v20 = *((void *)formatter + 2);
    uint64_t v21 = 0LL;
    goto LABEL_108;
  }

  if (@"kCFDateFormatterPMSymbolKey" == key)
  {
    CFTypeRef result = (CFTypeRef)*((void *)formatter + 36);
    if (result) {
      return CFRetain(result);
    }
    int v22 = __cficu_udat_countSymbols(*((void *)formatter + 2), 5u);
    if (v22 < 2) {
      return 0LL;
    }
    unsigned int v19 = v22;
    uint64_t v20 = *((void *)formatter + 2);
    uint64_t v21 = 1LL;
LABEL_108:
    int Symbols = __cficu_udat_getSymbols(v20, 5u, v21, valuePtr, 768LL, &v26);
    CFTypeRef result = 0LL;
    if (v19 <= 0x300 && v26 <= 0)
    {
      CFIndex v24 = Symbols;
      int v25 = CFGetAllocator(formatter);
      return CFStringCreateWithCharacters(v25, valuePtr, v24);
    }

    return result;
  }

  if (@"kCFDateFormatterAmbiguousYearStrategyKey" != key)
  {
    if (@"kCFDateFormatterUsesCharacterDirectionKey" != key)
    {
      if (CFEqual(key, @"kCFDateFormatterFormattingContextKey"))
      {
        CFTypeRef result = (CFTypeRef)*((void *)formatter + 39);
        if (!result)
        {
          *(_DWORD *)int valuePtr = __cficu_udat_getContext(*((void *)formatter + 2), 1, &v26);
          uint64_t v6 = CFGetAllocator(formatter);
          return CFNumberCreate(v6, kCFNumberIntType, valuePtr);
        }

        return CFRetain(result);
      }

      return 0LL;
    }

    CFTypeRef result = (CFTypeRef)*((void *)formatter + 38);
    if (result) {
      return CFRetain(result);
    }
    goto LABEL_41;
  }

  CFTypeRef result = (CFTypeRef)*((void *)formatter + 37);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 56) {
    _CFAssertMismatchedTypeID(0x38uLL, v6);
  }
  __CFDateFormatterSetProperty((uint64_t)formatter, key, (__CFString *)value, 0);
}

void __CFDateFormatterSetProperty(uint64_t a1, const __CFString *cf1, __CFString *theArray, int a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  int v49 = 0;
  if (@"kCFDateFormatterIsLenientKey" == cf1)
  {
    if (a4) {
      return;
    }
    unint64_t v8 = *(const __CFArray **)(a1 + 64);
    *(void *)(a1 + 64) = 0LL;
    if (theArray) {
      CFTypeRef v9 = CFRetain(theArray);
    }
    else {
      CFTypeRef v9 = 0LL;
    }
    *(void *)(a1 + 64) = v9;
LABEL_59:
    __ResetUDateFormat(a1, 0LL);
    goto LABEL_60;
  }

  if (@"kCFDateFormatterDoesRelativeDateFormattingKey" == cf1)
  {
    if (a4) {
      return;
    }
    unint64_t v8 = *(const __CFArray **)(a1 + 72);
    *(void *)(a1 + 72) = 0LL;
    if (&__kCFBooleanTrue == (__objc2_class **)theArray) {
      int v10 = (__objc2_class **)theArray;
    }
    else {
      int v10 = &__kCFBooleanFalse;
    }
    if (v10) {
      int v10 = (__objc2_class **)CFRetain(v10);
    }
    *(void *)(a1 + 72) = v10;
    goto LABEL_59;
  }

  if (@"kCFDateFormatterCalendarKey" == cf1)
  {
    if (a4)
    {
      unint64_t v8 = 0LL;
    }

    else
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 96);
      *(void *)(a1 + 96) = 0LL;
    }

    CFAllocatorRef v12 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    uint64_t v13 = *(void **)(a1 + 24);
    CFCalendarGetIdentifier((CFCalendarRef)theArray);
    CopyWithNewCalendarCFStringRef Identifier = _CFLocaleCreateCopyWithNewCalendarIdentifier((uint64_t)v12, v13);
    CFAbsoluteTime v15 = *(const void **)(a1 + 24);
    if (v15) {
      CFRelease(v15);
    }
    *(void *)(a1 + 24) = CopyWithNewCalendarIdentifier;
    if (a4) {
      goto LABEL_60;
    }
    *(void *)(a1 + 96) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }

  if (@"kCFDateFormatterCalendarIdentifierKey" == cf1)
  {
    if (a4)
    {
      unint64_t v8 = 0LL;
    }

    else
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 104);
      *(void *)(a1 + 104) = 0LL;
    }

    CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Identifier);
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, @"calendar", theArray);
    LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
    uint64_t v20 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    CFLocaleRef v21 = CFLocaleCreate(v20, LocaleIdentifierFromComponents);
    CFRelease(LocaleIdentifierFromComponents);
    CFRelease(*(CFTypeRef *)(a1 + 24));
    *(void *)(a1 + 24) = v21;
    if (a4) {
      goto LABEL_60;
    }
    *(void *)(a1 + 104) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }

  if (@"kCFDateFormatterTimeZoneKey" == cf1)
  {
    unint64_t v8 = *(const __CFArray **)(a1 + 88);
    if (v8 == (const __CFArray *)theArray) {
      return;
    }
    if (a4)
    {
      CFIndex v11 = *(const void **)(a1 + 88);
      unint64_t v8 = 0LL;
    }

    else
    {
      CFIndex v11 = 0LL;
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    }

    if (theArray) {
      CFIndex v24 = (void *)CFRetain(theArray);
    }
    else {
      CFIndex v24 = CFTimeZoneCopyDefault();
    }
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v24;
    if (v11) {
      CFRelease(v11);
    }
    if (!a4)
    {
      int v25 = *(const void **)(a1 + 88);
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
      __ResetUDateFormat(a1, 0LL);
      if (v25) {
        CFRelease(v25);
      }
    }

    goto LABEL_60;
  }

  if (@"kCFDateFormatterDefaultFormatKey" == cf1) {
    return;
  }
  if (@"kCFDateFormatterTwoDigitStartDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    unint64_t v8 = *(const __CFArray **)(a1 + 112);
    *(void *)(a1 + 112) = 0LL;
    if (theArray) {
      CFTypeRef v22 = CFRetain(theArray);
    }
    else {
      CFTypeRef v22 = 0LL;
    }
    *(void *)(a1 + 112) = v22;
    goto LABEL_60;
  }

  if (@"kCFDateFormatterDefaultDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    unint64_t v8 = *(const __CFArray **)(a1 + 120);
    *(void *)(a1 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
    if (theArray) {
      CFTypeRef v23 = CFRetain(theArray);
    }
    else {
      CFTypeRef v23 = 0LL;
    }
    *(void *)(a1 + 12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v23;
    goto LABEL_60;
  }

  if (@"kCFDateFormatterGregorianStartDateKey" == cf1)
  {
    if (a4) {
      return;
    }
    unint64_t v8 = *(const __CFArray **)(a1 + 128);
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
    if (theArray) {
      CFTypeRef v26 = CFRetain(theArray);
    }
    else {
      CFTypeRef v26 = 0LL;
    }
    *(void *)(a1 + 12_Block_object_dispose(va, 8) = v26;
    goto LABEL_59;
  }

  if (@"kCFDateFormatterEraSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 136);
      *(void *)(a1 + 136) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 136) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 0;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterLongEraSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 144);
      *(void *)(a1 + 144) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 7u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 144) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 7u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 7;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 152);
      *(void *)(a1 + 152) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 1u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 152) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 1u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 1;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterShortMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 160);
      *(void *)(a1 + 16_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 2u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 16_CFBundleUnloadExecutable((uint64_t)bundle, 0) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 2u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 2;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterVeryShortMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 168);
      *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 8u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 16_Block_object_dispose(va, 8) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 8u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 8;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 176);
      *(void *)(a1 + 176) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xAu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 176) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xAu, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 10;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterShortStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 184);
      *(void *)(a1 + 184) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xBu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 184) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xBu, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 11;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterVeryShortStandaloneMonthSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 192);
      *(void *)(a1 + 192) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xCu, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 192) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xCu, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 12;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 200);
      *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 3u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 20_CFBundleUnloadExecutable((uint64_t)bundle, 0) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 3u, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 3;
    goto LABEL_131;
  }

  if (@"kCFDateFormatterShortWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 208);
      *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 4u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 20_Block_object_dispose(va, 8) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 4u, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 4;
    goto LABEL_131;
  }

  if (@"kCFDateFormatterVeryShortWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 216);
      *(void *)(a1 + 216) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 9u, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 216) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 9u, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 9;
    goto LABEL_131;
  }

  if (@"kCFDateFormatterStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 224);
      *(void *)(a1 + 224) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xDu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 224) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xDu, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 13;
    goto LABEL_131;
  }

  if (@"kCFDateFormatterShortStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 232);
      *(void *)(a1 + 232) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xEu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 232) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xEu, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 14;
    goto LABEL_131;
  }

  if (@"kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 240);
      *(void *)(a1 + 24_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0xFu, 1, (CFArrayRef)theArray);
      *(void *)(a1 + 24_CFBundleUnloadExecutable((uint64_t)bundle, 0) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0xFu, 1u);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 15;
LABEL_131:
    int v29 = 1;
    goto LABEL_112;
  }

  if (@"kCFDateFormatterQuarterSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 248);
      *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x10u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 24_Block_object_dispose(va, 8) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x10u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 16;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterShortQuarterSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 256);
      *(void *)(a1 + 256) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x11u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 256) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x11u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 17;
    goto LABEL_111;
  }

  if (@"kCFDateFormatterStandaloneQuarterSymbolsKey" == cf1)
  {
    if (!a4)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 264);
      *(void *)(a1 + 264) = 0LL;
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x12u, 0, (CFArrayRef)theArray);
      *(void *)(a1 + 264) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x12u, 0);
      goto LABEL_60;
    }

    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 18;
LABEL_111:
    int v29 = 0;
LABEL_112:
    __CFDateFormatterSetSymbolsArray(v27, v28, v29, (CFArrayRef)theArray);
    return;
  }

  if (@"kCFDateFormatterShortStandaloneQuarterSymbolsKey" != cf1)
  {
    if (@"kCFDateFormatterAMSymbolKey" == cf1)
    {
      if (a4)
      {
        unint64_t v8 = 0LL;
      }

      else
      {
        unint64_t v8 = *(const __CFArray **)(a1 + 280);
        *(void *)(a1 + 28_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      }

      CFIndex Length = CFStringGetLength(theArray);
      uint64_t v32 = Length;
      if (Length >= 768) {
        CFIndex v33 = 768LL;
      }
      else {
        CFIndex v33 = Length;
      }
      MEMORY[0x1895F8858](Length, v31);
      int v35 = (UniChar *)((char *)&valuePtr - v34);
      CharactersPtr = CFStringGetCharactersPtr(theArray);
      if (CharactersPtr)
      {
        int v37 = (UChar *)CharactersPtr;
      }

      else
      {
        v51.CFIndex location = 0LL;
        v51.CFIndex length = v33;
        CFStringGetCharacters(theArray, v51, v35);
        int v37 = v35;
        uint64_t v32 = v33;
      }

      __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, 0LL, v37, v32, &v49);
      if (!a4)
      {
        CFStringRef Copy = 0LL;
        if (theArray) {
          CFStringRef Copy = CFStringCreateCopy(0LL, theArray);
        }
        *(void *)(a1 + 28_CFBundleUnloadExecutable((uint64_t)bundle, 0) = Copy;
      }
    }

    else if (@"kCFDateFormatterPMSymbolKey" == cf1)
    {
      if (a4)
      {
        unint64_t v8 = 0LL;
      }

      else
      {
        unint64_t v8 = *(const __CFArray **)(a1 + 288);
        *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
      }

      CFIndex v39 = CFStringGetLength(theArray);
      uint64_t v41 = v39;
      if (v39 >= 768) {
        CFIndex v42 = 768LL;
      }
      else {
        CFIndex v42 = v39;
      }
      MEMORY[0x1895F8858](v39, v40);
      double v44 = (UniChar *)((char *)&valuePtr - v43);
      uint64_t v45 = CFStringGetCharactersPtr(theArray);
      if (v45)
      {
        uint64_t v46 = (UChar *)v45;
      }

      else
      {
        v52.CFIndex location = 0LL;
        v52.CFIndex length = v42;
        CFStringGetCharacters(theArray, v52, v44);
        uint64_t v41 = v42;
        uint64_t v46 = v44;
      }

      __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, 1LL, v46, v41, &v49);
      if (!a4)
      {
        CFStringRef v47 = 0LL;
        if (theArray) {
          CFStringRef v47 = CFStringCreateCopy(0LL, theArray);
        }
        *(void *)(a1 + 28_Block_object_dispose(va, 8) = v47;
      }
    }

    else if (@"kCFDateFormatterAmbiguousYearStrategyKey" == cf1)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 296);
      *(void *)(a1 + 296) = 0LL;
      *(void *)(a1 + 296) = CFRetain(theArray);
    }

    else if (@"kCFDateFormatterUsesCharacterDirectionKey" == cf1)
    {
      unint64_t v8 = *(const __CFArray **)(a1 + 304);
      *(void *)(a1 + 304) = CFRetain(theArray);
    }

    else
    {
      if (!CFEqual(cf1, @"kCFDateFormatterFormattingContextKey")) {
        return;
      }
      if (a4)
      {
        unint64_t v8 = 0LL;
      }

      else
      {
        unint64_t v8 = *(const __CFArray **)(a1 + 312);
        *(void *)(a1 + 312) = 0LL;
      }

      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)theArray, kCFNumberIntType, &valuePtr);
      __cficu_udat_setContext(*(void *)(a1 + 16), valuePtr, &v49);
      if (!a4) {
        *(void *)(a1 + 312) = CFRetain(theArray);
      }
    }

    goto LABEL_60;
  }

  if (a4)
  {
    uint64_t v27 = *(void *)(a1 + 16);
    unsigned int v28 = 19;
    goto LABEL_111;
  }

  unint64_t v8 = *(const __CFArray **)(a1 + 272);
  *(void *)(a1 + 272) = 0LL;
  __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), 0x13u, 0, (CFArrayRef)theArray);
  *(void *)(a1 + 272) = __CFDateFormatterCopySymbolsArray(*(void *)(a1 + 16), 0x13u, 0);
LABEL_60:
  if (v8) {
    CFRelease(v8);
  }
}

CFArrayRef __CFDateFormatterCopySymbolsArray(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v19 = 0;
  uint64_t v6 = __cficu_udat_countSymbols(a1, a2);
  uint64_t v8 = (int)v6;
  uint64_t v18 = (uint64_t)&v18;
  uint64_t v9 = a3;
  CFIndex v10 = (int)v6 - (unint64_t)a3;
  MEMORY[0x1895F8858](v6, v7);
  CFAllocatorRef v12 = (const void **)((char *)&v18 - v11);
  if (v10 >= 1)
  {
    uint64_t v13 = (uint64_t *)((char *)&v18 - v11);
    do
    {
      int v19 = 0;
      int Symbols = __cficu_udat_getSymbols(a1, a2, v9, v20, 768LL, &v19);
      if ((unint64_t)v10 > 0x300
        || v19 > 0
        || (CFAbsoluteTime v15 = (void *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, Symbols)) == 0LL)
      {
        CFAbsoluteTime v15 = (void *)CFRetain(@"<error>");
      }

      *v13++ = v15;
      ++v9;
    }

    while (v8 != v9);
  }

  for (CFArrayRef i = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v10, &kCFTypeArrayCallBacks); v10; --v10)
    CFRelease(v12[v10 - 1]);
  return i;
}

uint64_t _CFDateFormatterCreateSkeletonFromTemplate(const __CFString *a1, const __CFLocale *a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  if (Length)
  {
    uint64_t v11 = 0LL;
    CFAllocatorRef v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    uint64_t v14 = 0LL;
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 3221225472LL;
    v10[2] = ___CFDateFormatterCreateSkeletonFromTemplate_block_invoke;
    v10[3] = &unk_189996428;
    void v10[4] = &v11;
    v10[5] = Length;
    v10[6] = a1;
    v10[7] = a3;
    int v7 = useTemplatePatternGenerator(a2, (uint64_t)v10);
    uint64_t v8 = v12[3];
    if (!v7 && v8)
    {
      CFRelease((CFTypeRef)v12[3]);
      uint64_t v8 = 0LL;
      v12[3] = 0LL;
    }

    _Block_object_dispose(&v11, 8);
  }

  else
  {
    uint64_t v8 = 0LL;
    if (a3) {
      *a3 = 1;
    }
  }

  return v8;
}

void sub_180A93558( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void __useTemplatePatternGenerator_block_invoke()
{
  useTemplatePatternGenerator_ptg = 0LL;
  free((void *)useTemplatePatternGenerator_ptgLocaleName);
  useTemplatePatternGenerator_ptgLocaleName = 0LL;
}

void __useTemplatePatternGenerator_block_invoke_2(uint64_t a1)
{
  useTemplatePatternGenerator_pressureSrc = 0LL;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
}

void __substituteFormatStringFromPrefsDF(uint64_t a1, int a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v2 = 40LL;
  if (a2) {
    uint64_t v2 = 32LL;
  }
  unint64_t v3 = *(void *)(a1 + v2);
  uint64_t v4 = 464LL;
  if (a2) {
    uint64_t v4 = 472LL;
  }
  uint64_t v5 = *(const __CFString **)(a1 + v4);
  if (v3) {
    BOOL v6 = v5 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v3 >= 5) {
      int v9 = -1;
    }
    else {
      int v9 = 4 - v3;
    }
    CFStringRef Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(Identifier, v29, 768LL, 0x600u)) {
        CStringPtr = v29;
      }
      else {
        CStringPtr = 0LL;
      }
    }

    int v27 = 0;
    if (a2) {
      int v12 = v9;
    }
    else {
      int v12 = -1;
    }
    if (a2) {
      int v13 = -1;
    }
    else {
      int v13 = v9;
    }
    uint64_t v14 = __cficu_udat_open(v12, v13, (uint64_t)CStringPtr, 0LL, 0LL, 0LL, 0LL, &v27);
    if (v14)
    {
      uint64_t v15 = (const void *)v14;
      int v27 = 0;
      int v16 = __cficu_udat_toPattern(v14, 0, v28, 768LL, &v27);
      if (v27 <= 0 && v16 <= 768)
      {
        unsigned int v17 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, v16);
        int v27 = 0;
        int v18 = __cficu_udat_toPattern(*(void *)(a1 + 16), 0, v28, 768LL, &v27);
        if (v27 <= 0)
        {
          int v19 = v18;
          if (v18 <= 768)
          {
            CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
            CFStringAppendCharacters(Mutable, v28, v19);
            v32.CFIndex location = 0LL;
            v32.CFIndex length = v19;
            if (CFStringFindWithOptions(Mutable, v17, v32, 0LL, &v26))
            {
              CFStringReplace(Mutable, v26, v5);
              CFIndex Length = CFStringGetLength(Mutable);
              MEMORY[0x1895F8858](Length, v22);
              CFIndex v24 = (UniChar *)((char *)&v26 - ((v23 + 15) & 0x3FFFFFFF0LL));
              CharactersPtr = (UChar *)CFStringGetCharactersPtr(Mutable);
              if (!CharactersPtr)
              {
                v31.CFIndex length = (int)Length;
                v31.CFIndex location = 0LL;
                CFStringGetCharacters(Mutable, v31, v24);
                CharactersPtr = v24;
              }

              int v27 = 0;
              __cficu_udat_applyPattern(*(void *)(a1 + 16), 0, CharactersPtr, Length);
            }

            CFRelease(Mutable);
          }
        }

        CFRelease(v17);
      }

      __cficu_udat_close(v15);
    }
  }

void __ApplyUDateFormatSymbol(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v37 = 0LL;
  *(void *)&__int128 v3 = 0x100000001LL;
  *((void *)&v3 + 1) = 0x100000001LL;
  __int128 v35 = v3;
  __int128 v36 = 0u;
  *(void *)&__int128 v36 = 0x100000001LL;
  __int128 v4 = *(_OWORD *)(a1 + 152);
  v33[0] = *(_OWORD *)(a1 + 136);
  v33[1] = v4;
  __int128 v5 = *(_OWORD *)(a1 + 184);
  v33[2] = *(_OWORD *)(a1 + 168);
  v33[3] = v5;
  __int128 v6 = *(_OWORD *)(a1 + 216);
  v33[4] = *(_OWORD *)(a1 + 200);
  v33[5] = v6;
  __int128 v7 = *(_OWORD *)(a1 + 248);
  v33[6] = *(_OWORD *)(a1 + 232);
  v33[7] = v7;
  v33[8] = *(_OWORD *)(a1 + 264);
  memset(v34, 0, sizeof(v34));
  __int128 v8 = *(_OWORD *)(a1 + 336);
  v32[0] = *(_OWORD *)(a1 + 320);
  v32[1] = v8;
  __int128 v9 = *(_OWORD *)(a1 + 368);
  v32[2] = *(_OWORD *)(a1 + 352);
  v32[3] = v9;
  __int128 v10 = *(_OWORD *)(a1 + 400);
  v32[4] = *(_OWORD *)(a1 + 384);
  v32[5] = v10;
  __int128 v11 = *(_OWORD *)(a1 + 432);
  v32[6] = *(_OWORD *)(a1 + 416);
  __int128 v12 = *(_OWORD *)(a1 + 448);
  v32[7] = v11;
  v32[8] = v12;
  do
  {
    int v13 = (const __CFArray *)*((void *)v33 + v2);
    if (v13 || (int v13 = (const __CFArray *)*((void *)v32 + v2)) != 0LL) {
      __CFDateFormatterSetSymbolsArray(*(void *)(a1 + 16), dword_180C33A64[v2], v34[v2], v13);
    }
    ++v2;
  }

  while (v2 != 18);
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v14 = *(void *)(a1 + 280);
  if (v14 || (uint64_t v14 = *(void *)(a1 + 496)) != 0) {
    uint64_t v30 = v14;
  }
  uint64_t v15 = *(void *)(a1 + 288);
  if (v15 || (uint64_t v15 = *(void *)(a1 + 504)) != 0) {
    uint64_t v31 = v15;
  }
  uint64_t v16 = 0LL;
  char v17 = 1;
  do
  {
    char v18 = v17;
    int v19 = (const __CFString *)*(&v30 + v16);
    if (v19)
    {
      CFIndex Length = CFStringGetLength((CFStringRef)*(&v30 + v16));
      uint64_t v22 = Length;
      if (Length >= 768) {
        CFIndex v23 = 768LL;
      }
      else {
        CFIndex v23 = Length;
      }
      MEMORY[0x1895F8858](Length, v21);
      int v25 = (UniChar *)((char *)&v28 - v24);
      CharactersPtr = CFStringGetCharactersPtr(v19);
      if (CharactersPtr)
      {
        int v27 = (UChar *)CharactersPtr;
      }

      else
      {
        v39.CFIndex location = 0LL;
        v39.CFIndex length = v23;
        CFStringGetCharacters(v19, v39, v25);
        uint64_t v22 = v23;
        int v27 = v25;
      }

      int v29 = 0;
      __cficu_udat_setSymbols(*(void *)(a1 + 16), 5u, v16, v27, v22, &v29);
    }

    char v17 = 0;
    uint64_t v16 = 1LL;
  }

  while ((v18 & 1) != 0);
}

uint64_t __CFDateFormatterStoreSymbolPrefs(const __CFString *a1, const void *a2, void *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  uint64_t result = CFStringGetTypeID();
  if (v6 == result)
  {
    CFTypeID v8 = CFGetTypeID(a2);
    uint64_t result = CFArrayGetTypeID();
    if (v8 == result)
    {
      SInt32 IntValue = CFStringGetIntValue(a1);
      uint64_t result = CFArrayGetCount((CFArrayRef)a2);
      switch(IntValue)
      {
        case 0:
          __int128 v10 = a3 + 40;
          __int128 v11 = (const void *)a3[40];
          if (v11) {
            goto LABEL_51;
          }
          goto LABEL_52;
        case 1:
          __int128 v10 = a3 + 42;
          __int128 v11 = (const void *)a3[42];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 2:
          __int128 v10 = a3 + 43;
          __int128 v11 = (const void *)a3[43];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 3:
          __int128 v10 = a3 + 48;
          __int128 v11 = (const void *)a3[48];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 4:
          __int128 v10 = a3 + 49;
          __int128 v11 = (const void *)a3[49];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 5:
          uint64_t v12 = result;
          if (result < 1) {
            return result;
          }
          CFIndex v13 = 0LL;
          uint64_t v14 = (const void **)(a3 + 63);
          uint64_t v15 = (const void **)(a3 + 62);
          break;
        case 7:
          __int128 v10 = a3 + 41;
          __int128 v11 = (const void *)a3[41];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 8:
          __int128 v10 = a3 + 44;
          __int128 v11 = (const void *)a3[44];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 9:
          __int128 v10 = a3 + 50;
          __int128 v11 = (const void *)a3[50];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 10:
          __int128 v10 = a3 + 45;
          __int128 v11 = (const void *)a3[45];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 11:
          __int128 v10 = a3 + 46;
          __int128 v11 = (const void *)a3[46];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 12:
          __int128 v10 = a3 + 47;
          __int128 v11 = (const void *)a3[47];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 13:
          __int128 v10 = a3 + 51;
          __int128 v11 = (const void *)a3[51];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 14:
          __int128 v10 = a3 + 52;
          __int128 v11 = (const void *)a3[52];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 15:
          __int128 v10 = a3 + 53;
          __int128 v11 = (const void *)a3[53];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 16:
          __int128 v10 = a3 + 54;
          __int128 v11 = (const void *)a3[54];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 17:
          __int128 v10 = a3 + 55;
          __int128 v11 = (const void *)a3[55];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 18:
          __int128 v10 = a3 + 56;
          __int128 v11 = (const void *)a3[56];
          if (!v11) {
            goto LABEL_52;
          }
          goto LABEL_51;
        case 19:
          __int128 v10 = a3 + 57;
          __int128 v11 = (const void *)a3[57];
          if (v11) {
LABEL_51:
          }
            CFRelease(v11);
LABEL_52:
          uint64_t result = (uint64_t)CFRetain(a2);
          *__int128 v10 = result;
          return result;
        default:
          return result;
      }

      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v13);
        CFTypeID v17 = CFGetTypeID(ValueAtIndex);
        uint64_t result = CFStringGetTypeID();
        if (v17 == result)
        {
          if (v13 == 1)
          {
            char v18 = *v14;
            int v19 = v14;
            if (*v14) {
              goto LABEL_22;
            }
            goto LABEL_23;
          }

          if (!v13)
          {
            char v18 = *v15;
            int v19 = v15;
            if (!*v15) {
              goto LABEL_23;
            }
LABEL_22:
            CFRelease(v18);
LABEL_23:
            uint64_t result = (uint64_t)CFRetain(ValueAtIndex);
            *int v19 = result;
          }
        }

        ++v13;
      }

      while (v12 != v13);
    }
  }

  return result;
}

void __CFDateFormatterSetSymbolsArray(uint64_t a1, unsigned int a2, int a3, CFArrayRef theArray)
{
  unsigned int v20 = a2;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v21 = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0LL;
    int v10 = a3;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
      CFIndex Length = CFStringGetLength(ValueAtIndex);
      uint64_t v14 = Length;
      if (Length >= 768) {
        CFIndex v15 = 768LL;
      }
      else {
        CFIndex v15 = Length;
      }
      MEMORY[0x1895F8858](Length, v13);
      CFTypeID v17 = (UniChar *)((char *)&v20 - v16);
      CharactersPtr = CFStringGetCharactersPtr(ValueAtIndex);
      if (CharactersPtr)
      {
        int v19 = (UChar *)CharactersPtr;
      }

      else
      {
        v23.CFIndex location = 0LL;
        v23.CFIndex length = v15;
        CFStringGetCharacters(ValueAtIndex, v23, v17);
        int v19 = v17;
        uint64_t v14 = v15;
      }

      int v21 = 0;
      __cficu_udat_setSymbols(a1, v20, (v10 + v9++), v19, v14, &v21);
    }

    while (v8 != v9);
  }

double __CFDateFormatterCorrectTimeWithTarget(uint64_t a1, int a2, int a3, int *a4, double a5)
{
  __cficu_ucal_set(a1, a3 == 0, a2);
  return __cficu_ucal_getMillis(a1, a4);
}

double __CFDateFormatterCorrectTimeToARangeAroundCurrentDate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6, double a7)
{
  double Now = __cficu_ucal_getNow();
  __cficu_ucal_setMillis(a1, a6, Now);
  int v15 = __cficu_ucal_get(a1, 1u, a6);
  int v16 = __cficu_ucal_get(a1, a5 == 0, a6);
  int v17 = v16;
  if (a5)
  {
    uint64_t v18 = a4 + v15;
    uint64_t v19 = v15 - a3;
    BOOL v20 = v18 <= a2;
    uint64_t v21 = v18 - a2;
    if (v20) {
      uint64_t v22 = 0LL;
    }
    else {
      uint64_t v22 = v21;
    }
    if (v20) {
      uint64_t v23 = -1LL;
    }
    else {
      uint64_t v23 = 1LL;
    }
    uint64_t v24 = v19 + a2;
    if (v19 >= 1) {
      uint64_t v25 = 0LL;
    }
    else {
      uint64_t v25 = 1 - v19;
    }
    if (v19 >= 1) {
      uint64_t v26 = -1LL;
    }
    else {
      uint64_t v26 = v24;
    }
  }

  else
  {
    int v17 = 100 * (v16 / 100);
    uint64_t v27 = a4 + v15 % 100;
    uint64_t v28 = v15 % 100 - a3;
    BOOL v29 = v27 < a2;
    uint64_t v30 = v27 - a2;
    if (v29) {
      uint64_t v22 = 0LL;
    }
    else {
      uint64_t v22 = v30 + 1;
    }
    if (v29) {
      uint64_t v23 = -1LL;
    }
    else {
      uint64_t v23 = 0LL;
    }
    uint64_t v31 = v28 + a2;
    uint64_t v25 = -v28 & (v28 >> 63);
    if (v28 >= 0) {
      uint64_t v26 = -1LL;
    }
    else {
      uint64_t v26 = v31;
    }
  }

  __cficu_ucal_setMillis(a1, a6, a7);
  int v32 = __cficu_ucal_get(a1, 1u, a6);
  int v33 = v32 % 100;
  int v34 = v32 % 100 + v17;
  if (a5)
  {
    int v34 = v17;
    int v33 = v32;
  }

  if (v26 == -1 || v33 < v26 || v33 - v26 >= v25)
  {
    if (v23 == -1)
    {
      int v35 = 0;
    }

    else
    {
      BOOL v20 = v33 < v23;
      uint64_t v36 = v33 - v23;
      int v35 = !v20 && v36 < v22;
    }
  }

  else
  {
    int v35 = -1;
  }

  if (!a5) {
    v35 *= 100;
  }
  return __CFDateFormatterCorrectTimeWithTarget(a1, v35 + v34, a5, a6, a7);
}

uint64_t __CFDateFormatterGetMaxYearGivenJapaneseEra(uint64_t a1, int a2, int *a3)
{
  double Millis = __cficu_ucal_getMillis(a1, a3);
  __cficu_ucal_set(a1, 0, a2);
  return __cficu_ucal_getFieldDifference(a1, 1u, a3, Millis) + 1;
}

double __CFDictionaryGetKeyCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  __CFBasicHashGetCallbacks(a1, v7);
  uint64_t v3 = v7[1];
  uint64_t v4 = v7[3];
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v3;
  uint64_t v5 = v9;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  double result = v8[0];
  *(_OWORD *)(a2 + 32) = *(_OWORD *)v8;
  return result;
}

uint64_t __CFDictionaryGetValueCallbacks@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v8[10] = *MEMORY[0x1895F89C0];
  uint64_t result = __CFBasicHashGetCallbacks(a1, v8);
  uint64_t v4 = v8[0];
  uint64_t v5 = v8[2];
  *a2 = 0LL;
  a2[1] = v4;
  uint64_t v6 = v8[8];
  uint64_t v7 = v8[4];
  a2[2] = v5;
  a2[3] = v6;
  a2[4] = v7;
  return result;
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return 18LL;
}

uint64_t __CFDictionaryCreateTransfer( __objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = (uint64_t *)a3;
  uint64_t v6 = a2;
  v18[10] = *MEMORY[0x1895F89C0];
  __NSCFDictionaryCreateTransfer(a1, a2, a3, a4);
  uint64_t v9 = v8;
  if (v8) {
    return v9;
  }
  v18[6] = (uint64_t)CFHash;
  v18[7] = 0LL;
  v18[0] = (uint64_t)__CFTypeCollectionRetain;
  v18[1] = (uint64_t)__CFTypeCollectionRetain;
  void v18[2] = (uint64_t)__CFTypeCollectionRelease;
  v18[3] = (uint64_t)__CFTypeCollectionRelease;
  v18[4] = (uint64_t)CFEqual;
  v18[5] = (uint64_t)CFEqual;
  v18[8] = (uint64_t)CFCopyDescription;
  v18[9] = (uint64_t)CFCopyDescription;
  uint64_t v9 = CFBasicHashCreate((uint64_t)a1, 0x2001u, v18);
  CFBasicHashSuppressRC(v9);
  if (v4 >= 1)
  {
    CFBasicHashSetCapacity(v9, v4);
    do
    {
      unint64_t v11 = *v6++;
      unint64_t v10 = v11;
      uint64_t v12 = *v5++;
      CFBasicHashAddValue(v9, v10, v12);
      --v4;
    }

    while (v4);
  }

  CFBasicHashUnsuppressRC(v9);
  uint64_t v13 = (unint64_t *)(v9 + 8);
  unint64_t v14 = atomic_load((unint64_t *)(v9 + 8));
  do
  {
    unint64_t v15 = __ldaxr(v13);
    if (v15 == v14)
    {
      if (!__stlxr(v14 | 0x40, v13))
      {
        int v16 = 1;
        goto LABEL_11;
      }
    }

    else
    {
      __clrex();
    }

    int v16 = 0;
LABEL_11:
    unint64_t v14 = v15;
  }

  while (!v16);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v9, 0x12uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v9;
}

CFDictionaryRef CFDictionaryCreate( CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  CFIndex v8 = numValues;
  uint64_t v9 = values;
  unint64_t v10 = keys;
  __NSCFDictionaryCreate( (__objc2_class **)allocator,  (unint64_t *)keys,  (unint64_t *)values,  numValues,  keyCallBacks,  valueCallBacks);
  uint64_t v13 = v12;
  if (v12) {
    return (CFDictionaryRef)v13;
  }
  uint64_t Generic = __CFDictionaryCreateGeneric((uint64_t)allocator, (uint64_t)keyCallBacks, valueCallBacks);
  uint64_t v13 = (unint64_t *)Generic;
  if (!Generic) {
    return (CFDictionaryRef)v13;
  }
  if (v8 >= 1)
  {
    CFBasicHashSetCapacity(Generic, v8);
    do
    {
      unint64_t v16 = (unint64_t)*v10++;
      unint64_t v15 = v16;
      uint64_t v17 = (uint64_t)*v9++;
      CFBasicHashAddValue((uint64_t)v13, v15, v17);
      --v8;
    }

    while (v8);
  }

  uint64_t v18 = v13 + 1;
  unint64_t v19 = atomic_load(v13 + 1);
  do
  {
    unint64_t v20 = __ldaxr(v18);
    if (v20 == v19)
    {
      if (!__stlxr(v19 | 0x40, v18))
      {
        int v21 = 1;
        goto LABEL_12;
      }
    }

    else
    {
      __clrex();
    }

    int v21 = 0;
LABEL_12:
    unint64_t v19 = v20;
  }

  while (!v21);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v13, 0x12uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return (CFDictionaryRef)v13;
}

uint64_t __CFDictionaryCreateGeneric(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 8);
    uint64_t v4 = *(void *)(a2 + 16);
    __int128 v5 = *(_OWORD *)(a2 + 32);
    uint64_t v6 = *(void *)(a2 + 24);
  }

  else
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 0LL;
    uint64_t v6 = 0LL;
    __int128 v5 = 0uLL;
  }

  v12[1] = v3;
  v12[3] = v4;
  __int128 v13 = v5;
  uint64_t v14 = 0LL;
  uint64_t v16 = v6;
  if (a3)
  {
    uint64_t v7 = a3[1];
    uint64_t v8 = a3[2];
    uint64_t v10 = a3[3];
    uint64_t v9 = a3[4];
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
  }

  v12[0] = v7;
  size_t v12[2] = v8;
  v12[4] = v9;
  uint64_t v15 = v10;
  return CFBasicHashCreate(a1, 0x2001u, v12);
}

CFMutableDictionaryRef CFDictionaryCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  uint64_t v9 = v8;
  if (!v8)
  {
    uint64_t Generic = __CFDictionaryCreateGeneric((uint64_t)allocator, (uint64_t)keyCallBacks, valueCallBacks);
    uint64_t v9 = (objc_class **)Generic;
    if (Generic)
    {
      if (capacity >= 1)
      {
        if (capacity >= 1000) {
          CFIndex v11 = 1000LL;
        }
        else {
          CFIndex v11 = capacity;
        }
        CFBasicHashSetCapacity(Generic, v11);
      }

      _CFRuntimeSetInstanceTypeIDAndIsa(v9, 0x12uLL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
    }
  }

  return (CFMutableDictionaryRef)v9;
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  uint64_t Copy = CFBasicHashCreateCopy(allocator, (uint64_t)theDict, v4, v5, v6, v7, v8, v9);
  uint64_t v12 = (const __CFDictionary *)Copy;
  if (!Copy) {
    return v12;
  }
  __int128 v13 = (unint64_t *)(Copy + 8);
  unint64_t v14 = atomic_load((unint64_t *)(Copy + 8));
  do
  {
    unint64_t v15 = __ldaxr(v13);
    if (v15 == v14)
    {
      if (!__stlxr(v14 | 0x40, v13))
      {
        int v16 = 1;
        goto LABEL_10;
      }
    }

    else
    {
      __clrex();
    }

    int v16 = 0;
LABEL_10:
    unint64_t v14 = v15;
  }

  while (!v16);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 0x12uLL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  return v12;
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy( CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  uint64_t v3 = MEMORY[0x1895F8858](allocator, capacity);
  uint64_t v5 = v4;
  uint64_t v6 = (__objc2_class **)v3;
  values[256] = *(void **)MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x12uLL, v4))
  {
    if (&__kCFAllocatorSystemDefault == v6
      || !v6 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
    {
      return (CFMutableDictionaryRef)[v5 _cfMutableCopy];
    }

    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v5);
    if (Count >= 257)
    {
      unint64_t v15 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
      unint64_t v14 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    }

    else
    {
      unint64_t v14 = (const void **)keys;
      unint64_t v15 = (const void **)values;
    }

    CFDictionaryGetKeysAndValues((CFDictionaryRef)v5, v14, v15);
    uint64_t Generic = __CFDictionaryCreateGeneric( (uint64_t)v6,  (uint64_t)&kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (CFIndex i = 0LL; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)v14[i], (uint64_t)v15[i]);
    }
  }

  else
  {
    uint64_t Copy = (objc_class **)CFBasicHashCreateCopy((CFAllocatorRef)v6, (uint64_t)v5, v7, v8, v9, v10, v11, v12);
  }

  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x12uLL);
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  return (CFMutableDictionaryRef)Copy;
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  else {
    return CFBasicHashGetCount((uint64_t)theDict);
  }
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary getObjects:andKeys:](theDict, "getObjects:andKeys:", values, keys);
  }

  else
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFBasicHashGetElements((uint64_t)theDict, Count, (uint64_t)values, (uint64_t)keys);
  }

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key);
  }
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  else {
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key) > 0;
  }
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  v5[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, v5);
  if (v5[3]) {
    return (const void *)v5[2];
  }
  else {
    return 0LL;
  }
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  v7[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, v7);
  if (!v7[3]) {
    return 0;
  }
  if (value) {
    *value = (const void *)v7[2];
  }
  return 1;
}

CFIndex CFDictionaryGetCountOfValue(CFDictionaryRef theDict, const void *value)
{
  else {
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value);
  }
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  else {
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value) > 0;
  }
}

uint64_t CFDictionaryGetKeyIfPresent(uint64_t a1, unint64_t a2, void *a3)
{
  v5[4] = *MEMORY[0x1895F89C0];
  CFBasicHashFindBucket(a1, a2, v5);
  if (!v5[3]) {
    return 0LL;
  }
  if (a3) {
    *a3 = v5[1];
  }
  return 1LL;
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  v6[6] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __apply:context:](theDict, "__apply:context:", applier, context);
  }

  else
  {
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    void v6[2] = __CFDictionaryApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    v6[5] = context;
    CFBasicHashApply((uint64_t)theDict, (uint64_t)v6);
  }

uint64_t __CFDictionaryApplyFunction_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t CFDictionaryApply(void *a1, uint64_t a2)
{
  uint64_t v5[5] = *MEMORY[0x1895F89C0];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __CFDictionaryApply_block_invoke;
  v5[3] = &unk_1899965E8;
  v5[4] = a2;
  return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
}

BOOL __CFDictionaryApply_block_invoke(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  char v2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  return v2 == 0;
}

uint64_t _CFDictionaryFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  else {
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
  }
}

BOOL _CFDictionaryIsMutable(uint64_t a1)
{
  unsigned int v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

void _CFDictionarySetCapacity(__objc2_class **a1, uint64_t a2)
{
}

uint64_t _CFDictionaryGetKVOBit(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFDictionarySetKVOBit(uint64_t result, char a2)
{
  char v2 = (unint64_t *)(result + 8);
  unint64_t v3 = atomic_load((unint64_t *)(result + 8));
  do
  {
    unint64_t v4 = __ldaxr(v2);
    if (v4 == v3)
    {
      if (!__stlxr(v3 & 0xFFFFFFFFFFFFFFFELL | a2 & 1, v2))
      {
        int v5 = 1;
        goto LABEL_7;
      }
    }

    else
    {
      __clrex();
    }

    int v5 = 0;
LABEL_7:
    unint64_t v3 = v4;
  }

  while (!v5);
  return result;
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __addObject:forKey:](theDict, "__addObject:forKey:", value, key);
  }

  else
  {
    char v12 = atomic_load((unint64_t *)theDict + 1);
    if ((v12 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)"void CFDictionaryAddValue(CFMutableDictionaryRef, const void *, const void *)");
    }
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      unint64_t v14 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        unint64_t v14 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v14;
      }

      objc_msgSend(theDict, v14, key);
    }

    CFBasicHashAddValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v15 = atomic_load((unint64_t *)theDict + 1);
    if ((v15 & 1) != 0)
    {
      int v16 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        int v16 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v16;
      }

      objc_msgSend(theDict, v16, key);
    }
  }

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary replaceObject:forKey:](theDict, "replaceObject:forKey:", value, key);
  }

  else
  {
    char v12 = atomic_load((unint64_t *)theDict + 1);
    if ((v12 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)"void CFDictionaryReplaceValue(CFMutableDictionaryRef, const void *, const void *)");
    }
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      unint64_t v14 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        unint64_t v14 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v14;
      }

      objc_msgSend(theDict, v14, key);
    }

    CFBasicHashReplaceValue((unint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v15 = atomic_load((unint64_t *)theDict + 1);
    if ((v15 & 1) != 0)
    {
      int v16 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        int v16 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v16;
      }

      objc_msgSend(theDict, v16, key);
    }
  }

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __setObject:forKey:](theDict, "__setObject:forKey:", value, key);
  }

  else
  {
    char v6 = atomic_load((unint64_t *)theDict + 1);
    if ((v6 & 0x40) != 0)
    {
      uint64_t v11 = "void CFDictionarySetValue(CFMutableDictionaryRef, const void *, const void *)";
      CFMutableDictionaryRef v12 = theDict;
      CFLog(3LL, @"%s(): immutable collection %p given to mutating function");
    }

    char v7 = atomic_load((unint64_t *)theDict + 1);
    if ((v7 & 1) != 0)
    {
      uint64_t v8 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        uint64_t v8 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v8;
      }

      objc_msgSend(theDict, v8, key, v11, v12);
    }

    CFBasicHashSetValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    char v9 = atomic_load((unint64_t *)theDict + 1);
    if ((v9 & 1) != 0)
    {
      uint64_t v10 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        uint64_t v10 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v10;
      }

      objc_msgSend(theDict, v10, key);
    }
  }

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary removeObjectForKey:](theDict, "removeObjectForKey:", key);
  }

  else
  {
    char v10 = atomic_load((unint64_t *)theDict + 1);
    if ((v10 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"void CFDictionaryRemoveValue(CFMutableDictionaryRef, const void *)");
    }
    char v11 = atomic_load((unint64_t *)theDict + 1);
    if ((v11 & 1) != 0)
    {
      CFMutableDictionaryRef v12 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        CFMutableDictionaryRef v12 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v12;
      }

      objc_msgSend(theDict, v12, key);
    }

    CFBasicHashRemoveValue((uint64_t)theDict, (unint64_t)key);
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      unint64_t v14 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        unint64_t v14 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v14;
      }

      objc_msgSend(theDict, v14, key);
    }
  }

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary removeAllObjects](theDict, "removeAllObjects");
  }

  else
  {
    char v8 = atomic_load((unint64_t *)theDict + 1);
    if ((v8 & 0x40) != 0) {
      CFLog( 3LL,  (uint64_t)@"%s(): immutable collection %p given to mutating function",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)"void CFDictionaryRemoveAllValues(CFMutableDictionaryRef)");
    }
    char v9 = atomic_load((unint64_t *)theDict + 1);
    if ((v9 & 1) != 0)
    {
      if (!__CF_KVO_WillChangeKeysSelector_hc) {
        __CF_KVO_WillChangeKeysSelector_hc = (uint64_t)sel_registerName("_willChangeValuesForKeys:");
      }
      CFIndex Count = CFDictionaryGetCount(theDict);
      CFMutableDictionaryRef v12 = (const void **)malloc(8 * Count);
      CFDictionaryGetKeysAndValues(theDict, v12, 0LL);
      CFSetRef v10 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, Count, &kCFTypeSetCallBacks);
      free(v12);
      objc_msgSend(theDict, (SEL)__CF_KVO_WillChangeKeysSelector_hc, v10);
    }

    else
    {
      CFSetRef v10 = 0LL;
    }

    CFBasicHashRemoveAllValues((uint64_t)theDict);
    char v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      unint64_t v14 = (const char *)__CF_KVO_DidChangeKeysSelector_hc;
      if (!__CF_KVO_DidChangeKeysSelector_hc)
      {
        unint64_t v14 = sel_registerName("_didChangeValuesForKeys:");
        __CF_KVO_DidChangeKeysSelector_hc = (uint64_t)v14;
      }

      objc_msgSend(theDict, v14, v10);
      if (v10) {
        CFRelease(v10);
      }
    }
  }

uint64_t __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void __NSSetEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ([a1 count])
  {
    if ((a2 & 1) != 0)
    {
      uint64_t v6 = __CFActiveProcessorCount();
      if (v6 < 2) {
        a2 = 0;
      }
    }

    else
    {
      uint64_t v6 = 1LL;
    }

    if ((a2 & 1) != 0)
    {
      unint64_t v8 = [a1 count];
      uint64_t v9 = 32LL;
      uint64_t v10 = 16LL;
      uint64_t v11 = 4LL;
      if (v8 < 4 * v6) {
        uint64_t v11 = 1LL;
      }
      if (v8 < 16 * v6) {
        uint64_t v10 = v11;
      }
      if (v8 < 32 * v6) {
        uint64_t v9 = v10;
      }
      if (48 * v6 > v8) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 48LL;
      }
      if (v8 < v6 << 6) {
        unint64_t v13 = v12;
      }
      else {
        unint64_t v13 = 64LL;
      }
      size_t v14 = (v8 + v13 - 1) / v13;
      char v15 = (void *)_CFAutoreleasePoolPush();
      uint64_t v16 = [a1 objectEnumerator];
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v30 = 0u;
      uint64_t v33 = 0LL;
      uint64_t v29 = 850045857LL;
      v22[0] = 0LL;
      v22[1] = v22;
      uint64_t v22[2] = 0x2020000000LL;
      char v23 = 0;
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = ____NSSetEnumerate_block_invoke;
      block[3] = &unk_189996610;
      block[6] = v22;
      block[7] = v13;
      block[8] = &v29;
      block[4] = v16;
      block[5] = a3;
      dispatch_apply(v14, 0LL, block);
      _CFAutoreleasePoolPop(v15);
      _Block_object_dispose(v22, 8);
    }

    else
    {
      uint64_t v7 = (void *)_CFAutoreleasePoolPush();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v29 = 0LL;
        *(void *)&__int128 v30 = &v29;
        *((void *)&v30 + 1) = 0x2020000000LL;
        LOBYTE(v31) = 0;
        v20[0] = MEMORY[0x1895F87A8];
        v20[1] = 3221225472LL;
        v20[2] = ____NSSetEnumerate_block_invoke_2;
        v20[3] = &unk_189996638;
        v20[4] = a3;
        v20[5] = &v29;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v20);
        _Block_object_dispose(&v29, 8);
      }

      else
      {
        LOBYTE(v29) = 0;
        __int128 v25 = 0u;
        __int128 v26 = 0u;
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        uint64_t v17 = [a1 countByEnumeratingWithState:&v25 objects:v24 count:16];
        if (v17)
        {
          uint64_t v18 = *(void *)v26;
LABEL_24:
          uint64_t v19 = 0LL;
          while (1)
          {
            if (*(void *)v26 != v18) {
              objc_enumerationMutation(a1);
            }
            __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(a3);
            if ((_BYTE)v29) {
              break;
            }
            if (v17 == ++v19)
            {
              uint64_t v17 = [a1 countByEnumeratingWithState:&v25 objects:v24 count:16];
              if (v17) {
                goto LABEL_24;
              }
              break;
            }
          }
        }
      }

      _CFAutoreleasePoolPop(v7);
    }
  }

void sub_180A95CCC(_Unwind_Exception *a1)
{
}

_WORD *_cow_create(uint64_t a1, int a2)
{
  uint64_t result = calloc(8uLL, 1uLL);
  if (!result) {
    _cow_create_cold_1();
  }
  *(_DWORD *)uint64_t result = 0;
  result[2] = a2 != 1;
  result[3] = a2 == 1;
  return result;
}

void _cow_copy(uint64_t a1, uint64_t a2, os_unfair_lock_t lock, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int os_unfair_lock_opaque_low = LOWORD(lock[1]._os_unfair_lock_opaque);
  int os_unfair_lock_opaque_high = HIWORD(lock[1]._os_unfair_lock_opaque);
  if ((_DWORD)a6 == 1)
  {
    if (os_unfair_lock_opaque_high != 0xFFFF)
    {
      LOWORD(os_unfair_lock_opaque_high) = os_unfair_lock_opaque_high + 1;
LABEL_8:
      LOWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_low;
      HIWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_high;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
      goto LABEL_9;
    }
  }

  else if (os_unfair_lock_opaque_low != 0xFFFF)
  {
    LOWORD(os_unfair_lock_opaque_low) = os_unfair_lock_opaque_low + 1;
    goto LABEL_8;
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
  (*(void (**)(uint64_t, void))(a4 + 16))(a5, 0LL);
LABEL_9:
  os_unfair_lock_unlock(lock);
}

uint64_t _cow_mutate_slow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 16))(a1, 0LL);
}

CFMutableStringRef _CFDoubledStringCreate(const __CFString *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  CFStringAppend(Mutable, a1);
  v4.CFIndex length = CFStringGetLength(Mutable);
  v4.CFIndex location = 0LL;
  CFStringFindAndReplace(Mutable, @"%", &stru_1899EF170, v4, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @" %@", a1);
  return Mutable;
}

CFStringRef _CFAffixedStringCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@", a2, a1, a3);
}

CFStringRef _CFRLORightToLeftStringCreate(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%C%@%C", 8238LL, a1, 8236LL);
}

CFStringRef _CFAccentuatedStringCreate(const __CFString *a1)
{
  if (_CFAccentuatedStringCreate_onceToken != -1) {
    dispatch_once(&_CFAccentuatedStringCreate_onceToken, &__block_literal_global_2);
  }
  return __CFPseudoLanguageStringCreateWithTransform( a1,  2LL,  (const __CFCharacterSet *)_CFAccentuatedStringCreate_charsToSkip,  (uint64_t)&__block_literal_global_12);
}

CFStringRef __CFPseudoLanguageStringCreateWithTransform( const __CFString *a1, uint64_t a2, const __CFCharacterSet *a3, uint64_t a4)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  MutableCFStringRef Copy = CFStringCreateMutableCopy(0LL, Length, a1);
  CFIndex v10 = CFStringGetLength(MutableCopy);
  CFStringRef theString = MutableCopy;
  uint64_t v32 = 0LL;
  CFIndex v33 = v10;
  CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0LL;
  __int128 v30 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
  }
  __int128 v31 = CStringPtr;
  unint64_t v13 = (UniChar *)malloc(2 * a2 * v10 + 2);
  CFIndex v34 = 0LL;
  CFIndex v35 = 0LL;
  CFIndex capacity = 0LL;
  if (v10 < 1)
  {
    CFIndex v23 = 0LL;
  }

  else
  {
    CFIndex v14 = 0LL;
    do
    {
      CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(MutableCopy, v14);
      if (RangeOfComposedCharactersAtIndex.length < 1)
      {
        CFIndex v16 = v14;
      }

      else
      {
        CFIndex v16 = RangeOfComposedCharactersAtIndex.length + v14;
        do
        {
          if (v14 < 0 || (CFIndex v17 = v33, v33 <= v14))
          {
            UniChar v18 = 0;
          }

          else if (v30)
          {
            UniChar v18 = v30[v32 + v14];
          }

          else if (v31)
          {
            UniChar v18 = v31[v32 + v14];
          }

          else
          {
            if (v35 <= v14 || (CFIndex v20 = v34, v34 > v14))
            {
              CFIndex v21 = v14 - 4;
              if (v21 + 64 < v33) {
                CFIndex v17 = v21 + 64;
              }
              CFIndex v34 = v21;
              CFIndex v35 = v17;
              v37.CFIndex location = v32 + v21;
              v37.CFIndex length = v17 - v21;
              CFStringGetCharacters(theString, v37, buffer);
              CFIndex v20 = v34;
            }

            UniChar v18 = buffer[v14 - v20];
          }

          ++v14;
          CFIndex v19 = capacity++;
          v13[v19] = v18;
        }

        while (v14 != v16);
        if (RangeOfComposedCharactersAtIndex.length == 1)
        {
          uint64_t v22 = v18;
          if (!CFCharacterSetIsCharacterMember(a3, v18)) {
            (*(void (**)(uint64_t, UniChar *, CFIndex *, uint64_t))(a4 + 16))(a4, v13, &capacity, v22);
          }
        }
      }

      CFIndex v14 = v16;
    }

    while (v16 < v10);
    CFIndex v23 = capacity;
  }

  v13[v23] = 0;
  MutableWithExternalCharactersNoCFStringRef Copy = CFStringCreateMutableWithExternalCharactersNoCopy( 0LL,  v13,  v23,  v23,  (CFAllocatorRef)&__kCFAllocatorNull);
  CFStringRef Copy = CFStringCreateCopy(0LL, MutableWithExternalCharactersNoCopy);
  CFRelease(MutableCopy);
  CFRelease(MutableWithExternalCharactersNoCopy);
  free(v13);
  return Copy;
}

CFStringRef _CFTallStringCreate(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithCharacters(0LL, _CFTallStringCreate_tallCharacters, 7LL);
  uint64_t v3 = CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@", v2, a1, v2);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetNonBase);
  CFStringRef v5 = __CFPseudoLanguageStringCreateWithTransform(v3, 7LL, Predefined, (uint64_t)&__block_literal_global_14);
  CFRelease(v2);
  CFRelease(v3);
  return v5;
}

__objc2_class **__NSSetImmutablePlaceholder()
{
  return &___immutablePlaceholderSet;
}

__objc2_class **__NSSetMutablePlaceholder()
{
  return &___mutablePlaceholderSet;
}

void __CFErrorDeallocate(uint64_t a1)
{
}

BOOL __CFErrorEqual(void *a1, void *a2)
{
  else {
    uint64_t v4 = a1[2];
  }
  else {
    uint64_t v5 = a2[2];
  }
  if (v4 != v5) {
    return 0LL;
  }
  uint64_t v6 = (const void *)(CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1) ? [a1 domain] : a1[3]);
  uint64_t v7 = (const void *)(CF_IS_OBJC(0x1BuLL, (__objc2_class **)a2) ? [a2 domain] : a2[3]);
  if (!CFEqual(v6, v7)) {
    return 0LL;
  }
  CFDictionaryRef v8 = CFErrorCopyUserInfo((CFErrorRef)a1);
  CFDictionaryRef v9 = CFErrorCopyUserInfo((CFErrorRef)a2);
  CFDictionaryRef v10 = v9;
  if (v8 == v9)
  {
    BOOL v11 = 1LL;
    goto LABEL_21;
  }

  BOOL v11 = 0LL;
  if (!v8 || !v9)
  {
LABEL_21:
    if (!v8) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  BOOL v11 = CFEqual(v8, v9) != 0;
LABEL_22:
  CFRelease(v8);
LABEL_23:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

CFHashCode __CFErrorHash(uint64_t a1)
{
  return *(void *)(a1 + 16) + CFHash(*(CFTypeRef *)(a1 + 24));
}

CFStringRef __CFErrorCopyFormattingDescription(__CFError *a1)
{
  else {
    return CFErrorCopyDescription(a1);
  }
}

CFTypeID CFErrorGetTypeID(void)
{
  return 27LL;
}

CFStringRef _CFErrorCreateLocalizedDescription(void *a1)
{
  char v2 = 1;
  do
  {
    char v3 = v2;
    if ((v2 & 1) != 0)
    {
      uint64_t v4 = (uint64_t (*)(void *, const __CFString *))_CFErrorCopyUserInfoKeyFromUserInfo;
      uint64_t v5 = _CFErrorCopyUserInfoKeyFromUserInfo(a1, @"NSLocalizedDescription");
    }

    else
    {
      uint64_t v4 = (uint64_t (*)(void *, const __CFString *))_CFErrorCopyUserInfoKeyFromCallBack;
      uint64_t v5 = _CFErrorCopyUserInfoKeyFromCallBack(a1, (uint64_t)@"NSLocalizedDescription");
    }

    if (v5) {
      return (CFStringRef)v5;
    }
    uint64_t v6 = v4(a1, @"NSLocalizedFailure");
    if (v6)
    {
      CFStringRef v11 = (CFStringRef)v6;
      unint64_t v13 = _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
      if (v13)
      {
        CFIndex v14 = v13;
        BundleWithCFStringRef Identifier = CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation");
        if (!BundleWithIdentifier
          || (CFIndex v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"%@ %@", @"%@ %@", @"Error"),
              CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v16, v11, v14),
              CFRelease(v16),
              !v17))
        {
          CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@ %@", v11, v14);
        }

        CFRelease(v11);
        CFRelease(v14);
        return v17;
      }

      return v11;
    }

    char v2 = 0;
  }

  while ((v3 & 1) != 0);
  uint64_t v7 = CFBundleGetBundleWithIdentifier(@"com.apple.CoreFoundation");
  CFDictionaryRef v8 = _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
  CFDictionaryRef v9 = v8;
  if (v7)
  {
    if (v8)
    {
      CFDictionaryRef v10 = CFBundleCopyLocalizedString( v7,  @"The operation couldn\\U2019t be completed. %@",  @"The operation couldn\\U2019t be completed. %@",  @"Error");
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v10, v9);
      uint64_t v12 = v10;
    }

    else
    {
      CFIndex v19 = (const __CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDescription");
      else {
        CFIndex v20 = (const __CFString *)a1[3];
      }
      else {
        CFIndex v23 = (const __CFString *)a1[3];
      }
      CFDictionaryRef v9 = CFBundleCopyLocalizedString(v7, v20, v23, @"Error");
      if (v19)
      {
        uint64_t v24 = CFBundleCopyLocalizedString( v7,  @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)",  @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)",  @"Error");
        else {
          uint64_t v25 = a1[2];
        }
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v24, v9, v25, v19);
        CFRelease(v24);
      }

      else
      {
        CFIndex v19 = CFBundleCopyLocalizedString( v7,  @"The operation couldn\\U2019t be completed. (%@ error %ld.)",  @"The operation couldn\\U2019t be completed. (%@ error %ld.)",  @"Error");
        else {
          uint64_t v26 = a1[2];
        }
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v19, v9, v26);
      }

      uint64_t v12 = v19;
    }

    CFRelease(v12);
LABEL_48:
    CFRelease(v9);
    return v11;
  }

  if (v8)
  {
    CFStringRef v18 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"The operation couldn\\U2019t be completed. %@",  v8);
LABEL_47:
    CFStringRef v11 = v18;
    goto LABEL_48;
  }

  CFDictionaryRef v9 = _CFErrorCopyUserInfoKey(a1, @"NSDescription");
  int v21 = CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1);
  if (v9)
  {
    if (v21) {
      uint64_t v22 = [a1 domain];
    }
    else {
      uint64_t v22 = a1[3];
    }
    else {
      uint64_t v28 = a1[2];
    }
    CFStringRef v18 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"The operation couldn\\U2019t be completed. (%@ error %ld - %@)",  v22,  v28,  v9);
    goto LABEL_47;
  }

  if (v21) {
    uint64_t v27 = [a1 domain];
  }
  else {
    uint64_t v27 = a1[3];
  }
  else {
    uint64_t v30 = a1[2];
  }
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"The operation couldn\\U2019t be completed. (%@ error %ld.)",  v27,  v30);
}

const void *_CFErrorCopyUserInfoKeyFromUserInfo(void *a1, const void *a2)
{
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
  {
    uint64_t v4 = (const __CFDictionary *)[a1 userInfo];
    if (v4) {
      goto LABEL_3;
    }
    return 0LL;
  }

  uint64_t v4 = (const __CFDictionary *)a1[4];
  if (!v4) {
    return 0LL;
  }
LABEL_3:
  CFTypeRef Value = CFDictionaryGetValue(v4, a2);
  uint64_t v6 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v6;
}

const void *_CFErrorCopyUserInfoKeyFromCallBack(void *a1, uint64_t a2)
{
  else {
    uint64_t v4 = (const void *)a1[3];
  }
  uint64_t v5 = CFErrorCopyCallBackBlockForDomain(v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (const void *)(*((uint64_t (**)(const void *, void *, uint64_t))v5 + 2))(v5, a1, a2);
  CFDictionaryRef v8 = v7;
  if (v7) {
    CFRetain(v7);
  }
  CFRelease(v6);
  return v8;
}

const void *_CFErrorCopyUserInfoKey(void *a1, const void *a2)
{
  uint64_t result = _CFErrorCopyUserInfoKeyFromUserInfo(a1, a2);
  if (!result) {
    return _CFErrorCopyUserInfoKeyFromCallBack(a1, (uint64_t)a2);
  }
  return result;
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  else {
    return (CFErrorDomain)*((void *)err + 3);
  }
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  else {
    return *((void *)err + 2);
  }
}

const void *_CFErrorCreateLocalizedFailureReason(void *a1)
{
  return _CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
}

const void *_CFErrorCreateLocalizedRecoverySuggestion(void *a1)
{
  return _CFErrorCopyUserInfoKey(a1, @"NSLocalizedRecoverySuggestion");
}

uint64_t _CFErrorCreateDebugDescription(void *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  v3[1] = 0LL;
  __int16 v4 = 1;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

void _CFErrorFormatDebugDescriptionAux(void *a1, uint64_t a2)
{
  __int16 v4 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDebugDescription");
  uint64_t v5 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSDescription");
  if (v5)
  {
    uint64_t v6 = v5;
  }

  else
  {
    if (v4)
    {
      uint64_t v6 = v4;
    }

    else if (*(_BYTE *)(a2 + 16))
    {
      uint64_t v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSLocalizedDescription");
      if (!v7) {
        uint64_t v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, @"NSLocalizedFailureReason");
      }
      uint64_t v6 = v7;
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    __int16 v4 = 0LL;
  }

  else {
    CFDictionaryRef v8 = (const __CFDictionary *)a1[4];
  }
  CFDictionaryRef v9 = *(__CFString **)a2;
  else {
    uint64_t v10 = a1[3];
  }
  else {
    uint64_t v11 = a1[2];
  }
  CFStringAppendFormat(v9, 0LL, @"Error Domain=%@ Code=%ld", v10, v11);
  if (*(_BYTE *)(a2 + 17))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0) {
      CFStringAppendFormat( *(CFMutableStringRef *)a2,  0LL,  @" %@",  -[__CFString redactedDescription](v6, "redactedDescription"));
    }
  }

  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a2, 0LL, @" %@", v6);
  }

  if (v6 && v4 && CFStringGetLength(v4) >= 1 && !CFEqual(v6, v4))
  {
    if (*(_BYTE *)(a2 + 17))
    {
      if ((objc_opt_respondsToSelector() & 1) != 0) {
        CFStringAppendFormat( *(CFMutableStringRef *)a2,  0LL,  @" (%@)",  -[__CFString redactedDescription](v4, "redactedDescription"));
      }
    }

    else
    {
      CFStringAppendFormat(*(CFMutableStringRef *)a2, 0LL, @" (%@)", v4);
    }
  }

  if (!v8 || !CFDictionaryGetCount(v8))
  {
LABEL_36:
    if (!v4) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  uint64_t v12 = *(void *)(a2 + 8);
  if (v12 <= 2)
  {
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 136), 8) = v12 + 1;
    CFStringAppend(*(CFMutableStringRef *)a2, @" UserInfo={");
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)userInfoKeyValueShow, (void *)a2);
    BOOL v13 = CFStringHasSuffix(*(CFStringRef *)a2, @", ") != 0;
    CFIndex v14 = *(__CFString **)a2;
    v15.CFIndex location = CFStringGetLength(*(CFStringRef *)a2) - 2LL * v13;
    v15.CFIndex length = 2LL * v13;
    CFStringReplace(v14, v15, @"}");
    --*(void *)(a2 + 8);
    goto LABEL_36;
  }

  CFStringAppendFormat(*(CFMutableStringRef *)a2, 0LL, @" UserInfo=%p (not displayed)", v8);
  if (v4) {
LABEL_37:
  }
    CFRelease(v4);
LABEL_38:
  if (v6) {
    CFRelease(v6);
  }
}

uint64_t _CFErrorCreateUnlocalizedDebugDescription(void *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  v3[1] = 0LL;
  __int16 v4 = 0;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

uint64_t _CFErrorCreateRedactedDescription(void *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  v3[1] = 0LL;
  __int16 v4 = 257;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

CFErrorRef CFErrorCreate( CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  uint64_t Instance = (__CFError *)_CFRuntimeCreateInstance(allocator, 0x1BuLL, 24LL, 0LL, v4, v5, v6, v7);
  if (Instance)
  {
    CFStringRef Copy = CFStringCreateCopy(allocator, domain);
    *((void *)Instance + 2) = code;
    *((void *)Instance + 3) = Copy;
    CFArrayRef v14 = _CFErrorCreateCallStackReturnAddresses(allocator);
    if (v14)
    {
      CFArrayRef v15 = v14;
      if (userInfo) {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(allocator, 0LL, userInfo);
      }
      else {
        MutableCFStringRef Copy = CFDictionaryCreateMutable( allocator,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      CFStringRef v17 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, @"NSCallStackReturnAddresses", v15);
        userInfo = v17;
      }

      CFRelease(v15);
    }

    else
    {
      CFStringRef v17 = 0LL;
    }

    if (userInfo) {
      CFDictionaryRef EmptyDictionary = CFDictionaryCreateCopy(allocator, userInfo);
    }
    else {
      CFDictionaryRef EmptyDictionary = _CFErrorCreateEmptyDictionary(allocator);
    }
    *((void *)Instance + 4) = EmptyDictionary;
    if (v17) {
      CFRelease(v17);
    }
  }

  return Instance;
}

CFArrayRef _CFErrorCreateCallStackReturnAddresses(const __CFAllocator *a1)
{
  unsigned __int8 v1 = atomic_load(_CFErrorCallStackCaptureEnabled);
  if ((v1 & 1) == 0) {
    return 0LL;
  }
  uint64_t v5 = (void *)MEMORY[0x186E03CAC]();
  uint64_t v6 = (const __CFArray *)unk_18C545A6C(&off_18C546258, "callStackReturnAddresses");
  if (v6) {
    CFArrayRef Copy = CFArrayCreateCopy(a1, v6);
  }
  else {
    CFArrayRef Copy = 0LL;
  }
  objc_autoreleasePoolPop(v5);
  return Copy;
}

CFDictionaryRef _CFErrorCreateEmptyDictionary(CFAllocatorRef allocator)
{
  if (allocator)
  {
    unsigned __int8 v1 = allocator;
  }

  else
  {
    uint64_t v2 = _CFGetTSD(1u);
    if (v2) {
      unsigned __int8 v1 = (const __CFAllocator *)v2;
    }
    else {
      unsigned __int8 v1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
    }
  }

  if (&__kCFAllocatorSystemDefault == (__objc2_class **)v1
    || !v1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
  {
    return (CFDictionaryRef)CFRetain(&__NSDictionary0__struct);
  }

  else
  {
    return CFDictionaryCreate(v1, 0LL, 0LL, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues( CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  CFErrorRef result = CFDictionaryCreate( allocator,  (const void **)userInfoKeys,  (const void **)userInfoValues,  numUserInfoValues,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (result)
  {
    CFErrorRef v10 = result;
    uint64_t v11 = CFErrorCreate(allocator, domain, code, result);
    CFRelease(v10);
    return v11;
  }

  return result;
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
  {
    uint64_t v2 = (const void *)-[__CFError userInfo](err, "userInfo");
    if (v2) {
      return (CFDictionaryRef)CFRetain(v2);
    }
  }

  else
  {
    uint64_t v2 = (const void *)*((void *)err + 4);
    if (v2) {
      return (CFDictionaryRef)CFRetain(v2);
    }
  }

  uint64_t v4 = CFGetAllocator(err);
  return _CFErrorCreateEmptyDictionary(v4);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  CFStringRef result = (CFStringRef)-[__CFError localizedDescription](err, "localizedDescription");
  if (result) {
    return (CFStringRef)CFRetain(result);
  }
  return result;
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  CFStringRef result = (CFStringRef)-[__CFError localizedFailureReason](err, "localizedFailureReason");
  if (result) {
    return (CFStringRef)CFRetain(result);
  }
  return result;
}

CFStringRef CFErrorCopyRecoverySuggestion(CFErrorRef err)
{
  CFStringRef result = (CFStringRef)-[__CFError localizedRecoverySuggestion](err, "localizedRecoverySuggestion");
  if (result) {
    return (CFStringRef)CFRetain(result);
  }
  return result;
}

void CFErrorSetCallBackBlockForDomain(const void *a1, const void *a2)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (a2) {
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1, a2);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
}

void _CFErrorInitializeCallBackTable()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  v2.equal = CFEqual;
  v2.CFIndex version = kCFTypeDictionaryValueCallBacks.version;
  v2.copyDescriptiouint64_t n = kCFTypeDictionaryValueCallBacks.copyDescription;
  v2.CFAllocatorRetainCallBack retain = (CFDictionaryRetainCallBack)blockCopyValueCallBack;
  v2.CFArrayReleaseCallBack release = (CFDictionaryReleaseCallBack)blockReleaseValueCallBack;
  CFMutableDictionaryRef v0 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &v2);
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
    CFRelease(v0);
  }

  else
  {
    _CFErrorCallBackTable = (uint64_t)v0;
    uint64_t v1 = MEMORY[0x1895F87A8];
    uint64_t value = MEMORY[0x1895F87A8];
    uint64_t v4 = 3221225472LL;
    uint64_t v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    uint64_t v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    uint64_t v7 = _CFErrorPOSIXCallBack;
    CFDictionarySetValue(v0, @"NSPOSIXErrorDomain", &value);
    uint64_t value = v1;
    uint64_t v4 = 3221225472LL;
    uint64_t v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    uint64_t v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    uint64_t v7 = _CFErrorMachCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, @"NSMachErrorDomain", &value);
    uint64_t value = v1;
    uint64_t v4 = 3221225472LL;
    uint64_t v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    uint64_t v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    uint64_t v7 = _CFErrorCocoaCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, @"NSCocoaErrorDomain", &value);
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  }

const void *CFErrorGetCallBackBlockForDomain(const void *a1)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable) {
    CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
  }
  else {
    CFTypeRef Value = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return Value;
}

const void *CFErrorCopyCallBackBlockForDomain(const void *a1)
{
  if (!_CFErrorCallBackTable) {
    _CFErrorInitializeCallBackTable();
  }
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
    char v3 = Value;
    if (Value) {
      CFRetain(Value);
    }
  }

  else
  {
    char v3 = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return v3;
}

void CFErrorSetCallBackForDomain(const void *a1, void *a2)
{
  v2[5] = *MEMORY[0x1895F89C0];
  if (a2)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 3221225472LL;
    v2[2] = __CFErrorSetCallBackForDomain_block_invoke;
    v2[3] = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    v2[4] = a2;
    a2 = v2;
  }

  CFErrorSetCallBackBlockForDomain(a1, a2);
}

const void *__CFErrorSetCallBackForDomain_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 32))(a2, a3);
  uint64_t v4 = v3;
  if (v3) {
    CFAutorelease(v3);
  }
  return v4;
}

uint64_t CFErrorGetCallBackForDomain()
{
  return 0LL;
}

void userInfoKeyValueShow(const void *a1, void *a2, uint64_t a3)
{
  if (!a3) {
    userInfoKeyValueShow_cold_1();
  }
  int v6 = CFEqual(a1, @"NSUnderlyingError");
  if (a2 && v6 && CFGetTypeID(a2) == 27)
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0LL, @"%@=%p {", a1, a2);
    _CFErrorFormatDebugDescriptionAux(a2, a3);
    CFStringAppend(*(CFMutableStringRef *)a3, @"}, ");
  }

  else if (*(_BYTE *)(a3 + 17))
  {
    char v7 = objc_opt_respondsToSelector();
    uint64_t v8 = *(__CFString **)a3;
    if ((v7 & 1) != 0)
    {
      CFErrorRef v10 = a1;
      uint64_t v11 = [a2 redactedDescription];
      CFDictionaryRef v9 = @"%@=%@, ";
    }

    else
    {
      CFErrorRef v10 = a1;
      CFDictionaryRef v9 = @"%@=<private>, ";
    }

    CFStringAppendFormat(v8, 0LL, v9, v10, v11);
  }

  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0LL, @"%@=%@, ", a1, a2);
  }

void *blockCopyValueCallBack(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void blockReleaseValueCallBack(int a1, void *aBlock)
{
}

CFStringRef _CFErrorPOSIXCallBack(void *a1, CFTypeRef cf1)
{
  if (!CFEqual(cf1, @"NSDescription") && !CFEqual(cf1, @"NSLocalizedFailureReason")) {
    return 0LL;
  }
  else {
    uint64_t v4 = a1[2];
  }
  uint64_t v5 = strerror(v4);
  if (!v5 || !*v5) {
    return 0LL;
  }
  int v6 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 0x8000100u);
  if (v6)
  {
    if (!CFEqual(cf1, @"NSDescription"))
    {
      char v7 = CFCopySearchPathForDirectoriesInDomains(5LL, 8LL, 0);
      if (v7)
      {
        uint64_t v8 = v7;
        if (CFArrayGetCount(v7) >= 1)
        {
          ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v8, 0LL);
          CFStringRef v10 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
          if (v10)
          {
            CFStringRef v11 = v10;
            uint64_t v12 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@/CoreServices/CoreTypes.bundle",  v10);
            BOOL v13 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v12,  kCFURLPOSIXPathStyle,  0);
            CFRelease(v11);
            if (v13)
            {
              CFArrayRef v14 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
              if (v14)
              {
                CFArrayRef v15 = v14;
                CFIndex v16 = (__CFString *)CFBundleCopyLocalizedString(v14, v6, @"%%NOTFOUND%%", @"ErrnoErrors");
                if (v16 == @"%%NOTFOUND%%")
                {
                  CFRelease(@"%%NOTFOUND%%");
                  CFIndex v16 = 0LL;
                }

                CFRelease(v6);
                CFRelease(v15);
                int v6 = v16;
              }

              CFRelease(v13);
            }

            CFRelease(v12);
          }
        }

        CFRelease(v8);
      }
    }
  }

  return v6;
}

CFStringRef _CFErrorMachCallBack(uint64_t a1, CFTypeRef cf1)
{
  if (CFEqual(cf1, @"NSDescription")
    && (!CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1)
      ? (uint64_t v3 = *(void *)(a1 + 16))
      : (LODWORD(v3) = [(id)a1 code]),
        (uint64_t v4 = mach_error_string(v3)) != 0LL && *v4))
  {
    return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 0x8000100u);
  }

  else
  {
    return 0LL;
  }

IMP _CFErrorCocoaCallBack(uint64_t a1, uint64_t a2)
{
  IMP result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
  if (_CFErrorCocoaCallBack_cocoaCallBack) {
    goto LABEL_4;
  }
  Class v5 = objc_lookUpClass("NSError");
  if (v5)
  {
    int v6 = v5;
    char v7 = sel_registerName("_retainedUserInfoCallBackForKey:");
    IMP result = class_getMethodImplementation(v6, v7);
    _CFErrorCocoaCallBack_cocoaCallBacuint64_t k = result;
    if (!result) {
      return result;
    }
    goto LABEL_4;
  }

  IMP result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
  if (_CFErrorCocoaCallBack_cocoaCallBack)
  {
LABEL_4:
    CFDictionaryRef v9 = (uint64_t (*)(uint64_t, SEL, uint64_t))result;
    SEL v8 = sel_registerName("_retainedUserInfoCallBackForKey:");
    return (IMP)v9(a1, v8, a2);
  }

  return result;
}

uint64_t _CFPrefsDomainSizeAcceptabilityForByteCount(unint64_t a1)
{
  if (a1 < 0x100001) {
    unsigned int v1 = 1;
  }
  else {
    unsigned int v1 = 2;
  }
  if (a1 > 0x80000) {
    return v1;
  }
  else {
    return 0LL;
  }
}

uint64_t _CFPrefsSizeOfValue(xpc_object_t xdict, int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v10 = 0LL;
  CFStringRef v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  uint64_t v13 = 0LL;
  if (a2 == 1)
  {
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = ___CFPrefsSizeOfValue_block_invoke;
    v9[3] = &unk_189996830;
    v9[4] = &v10;
    xpc_dictionary_apply(xdict, v9);
  }

  else if (!a2)
  {
    Class Class = object_getClass(xdict);
    if (Class == (Class)MEMORY[0x1895F9228])
    {
      Class v5 = v11;
      uint64_t v6 = v11[3] + 1;
LABEL_12:
      v5[3] = v6;
      goto LABEL_13;
    }

    if (Class == (Class)MEMORY[0x1895F92E8])
    {
      size_t length = xpc_string_get_length(xdict);
      goto LABEL_11;
    }

    if (Class == (Class)MEMORY[0x1895F92A8])
    {
      v11[3] = 0LL;
      goto LABEL_13;
    }

    if (Class == (Class)MEMORY[0x1895F9240])
    {
      size_t length = xpc_data_get_length(xdict);
LABEL_11:
      Class v5 = v11;
      uint64_t v6 = v11[3] + length;
      goto LABEL_12;
    }
  }

void sub_180A98A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t _CFPrefsDecodeKeyValuePairFromXPCMessage(void *a1, void *a2, void *a3, int *a4)
{
  if (xpc_dictionary_get_BOOL(a1, "MultiKeySet"))
  {
    uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
    if (!result) {
      return result;
    }
    CFDictionaryRef v9 = (void *)result;
    xpc_object_t v10 = xpc_string_create("MultipleKeys");
    int v11 = 1;
    if (a2) {
      goto LABEL_4;
    }
LABEL_12:
    xpc_release(v10);
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Key");
  if (!result) {
    return result;
  }
  xpc_object_t v10 = (xpc_object_t)result;
  xpc_retain((xpc_object_t)result);
  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
  if (!result) {
    return result;
  }
  CFDictionaryRef v9 = (void *)result;
  int v11 = 0;
  if (!a2) {
    goto LABEL_12;
  }
LABEL_4:
  *a2 = v10;
  if (a3)
  {
LABEL_5:
    xpc_retain(v9);
    *a3 = v9;
  }

uint64_t _CFPrefsEncodeValueIntoMessage(xpc_object_t xdict, char *key, __objc2_class **cf, void *a4)
{
  uint64_t v4 = 0LL;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!key || !cf) {
    return v4;
  }
  if (&__kCFBooleanTrue == cf || &__kCFBooleanFalse == cf)
  {
    xpc_dictionary_set_BOOL(xdict, key, &__kCFBooleanTrue == cf);
    CFIndex Length = 1LL;
  }

  else
  {
    if (&__kCFNull == cf)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_dictionary_set_value(xdict, key, v11);
      xpc_release(v11);
      return 1LL;
    }

    if (CFGetTypeID(cf) == 7)
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString((CFStringRef)cf, buffer, 1024LL, 0x8000100u))
      {
        xpc_dictionary_set_string(xdict, key, buffer);
      }

      else
      {
        uint64_t v4 = (uint64_t)_CFXPCCreateXPCObjectFromCFObject((__CFString *)cf);
        if (!v4) {
          goto LABEL_24;
        }
        xpc_dictionary_set_value(xdict, key, (xpc_object_t)v4);
        xpc_release((xpc_object_t)v4);
      }

      uint64_t v4 = 1LL;
LABEL_24:
      CFIndex Length = CFStringGetLength((CFStringRef)cf);
      if (!a4) {
        return v4;
      }
      goto LABEL_25;
    }

    Data = CFPropertyListCreateData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  cf,  kCFPropertyListBinaryFormat_v1_0,  0LL,  0LL);
    if (!Data)
    {
      size_t v16 = strlen(key);
      CFStringRef v17 = CFStringCreateWithBytes( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)key,  v16,  0x8000100u,  0);
      _CFPrefsValidateValueForKey(cf, (uint64_t)v17);
      if (v17) {
        CFRelease(v17);
      }
      return 0LL;
    }

    uint64_t v13 = Data;
    BytePtr = CFDataGetBytePtr(Data);
    size_t v15 = CFDataGetLength(v13);
    xpc_dictionary_set_data(xdict, key, BytePtr, v15);
    CFIndex Length = CFDataGetLength(v13);
    CFRelease(v13);
  }

  uint64_t v4 = 1LL;
  if (!a4) {
    return v4;
  }
LABEL_25:
  if ((_DWORD)v4 && Length)
  {
    *a4 += Length;
    return 1LL;
  }

  return v4;
}

void sub_180A98E14(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) != 0) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFPrefsEncodeKeyValuePairsIntoMessage( xpc_object_t xdict, __objc2_class ***a2, __objc2_class ***a3, uint64_t a4, void *a5)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a4 <= 0) {
    _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1();
  }
  uint64_t v6 = a4;
  SEL v8 = (const __CFString **)a2;
  uint64_t v16 = 0LL;
  if (a4 == 1)
  {
    uint64_t result = _CFPrefsEncodeValueIntoMessage(xdict, "Key", *a2, &v16);
    if ((_DWORD)result)
    {
      if (*a3) {
        xpc_object_t v11 = *a3;
      }
      else {
        xpc_object_t v11 = &__kCFNull;
      }
      uint64_t result = _CFPrefsEncodeValueIntoMessage(xdict, "Value", v11, &v16);
    }
  }

  else
  {
    xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
    char v13 = 1;
    do
    {
      uint64_t v14 = *v8;
      if (*v8)
      {
        bzero(buffer, 0x402uLL);
        if ((v13 & 1) != 0 && CFStringGetCString(v14, buffer, 1026LL, 0x8000100u))
        {
          if (*a3) {
            size_t v15 = *a3;
          }
          else {
            size_t v15 = &__kCFNull;
          }
          char v13 = _CFPrefsEncodeValueIntoMessage(v12, buffer, v15, &v16);
        }

        else
        {
          char v13 = 0;
        }
      }

      ++a3;
      ++v8;
      --v6;
    }

    while (v6);
    xpc_dictionary_set_BOOL(xdict, "MultiKeySet", 1);
    xpc_dictionary_set_value(xdict, "Value", v12);
    xpc_release(v12);
    uint64_t result = v13 & 1;
  }

  if (a5) {
    *a5 = v16;
  }
  return result;
}

void sub_180A99024(_Unwind_Exception *a1)
{
}

void *allocatePurgeable(int64_t a1, uint64_t a2, uint64_t a3)
{
  v8[1] = *MEMORY[0x1895F89C0];
  v8[0] = 0LL;
  if (a1 <= 0) {
    int64_t v5 = *MEMORY[0x1895FD590];
  }
  else {
    int64_t v5 = a1;
  }
  vm_size_t v6 = (*MEMORY[0x1895FD590] + v5 - 1) & -*MEMORY[0x1895FD590];
  if (vm_allocate(*MEMORY[0x1895FBBE0], v8, v6, -268435453))
  {
    *(_BYTE *)(a3 + 25) = 1;
    *(void *)(a3 + 16) = a1;
    return malloc(a1);
  }

  else
  {
    *(void *)(a3 + 16) = v6;
    return (void *)v8[0];
  }

void deallocatePurgeable(void *a1, uint64_t a2)
{
  kern_return_t v5;
  int v6;
  os_log_s *v7;
  if (*(_BYTE *)(a2 + 25))
  {
    free(a1);
  }

  else
  {
    vm_map_t v3 = *MEMORY[0x1895FBBE0];
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a2 + 8));
    int64_t v5 = mach_vm_deallocate(v3, (mach_vm_address_t)BytePtr, *(void *)(a2 + 16));
    if (v5)
    {
      vm_size_t v6 = v5;
      uint64_t v7 = (os_log_s *)_CFPrefsDaemonLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
        deallocatePurgeable_cold_1(v6, v7);
      }
    }
  }

void __CFFileDescriptorDeallocate(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v11 = 0LL;
    xpc_object_t v12 = &v11;
    uint64_t v13 = 0x2000000000LL;
    uint64_t v14 = 0LL;
    uint64_t v7 = 0LL;
    SEL v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    char v10 = 0;
    CFDictionaryValueCallBacks v2 = (dispatch_queue_s *)__fdQueue();
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    void v6[2] = ____CFFileDescriptorDeallocate_block_invoke;
    v6[3] = &unk_189996A78;
    v6[5] = &v11;
    v6[6] = a1;
    v6[4] = &v7;
    dispatch_sync(v2, v6);
    if (*((_BYTE *)v8 + 24))
    {
      vm_map_t v3 = (__CFRunLoopSource *)v12[3];
      if (v3)
      {
        CFRunLoopSourceInvalidate(v3);
        CFRelease((CFTypeRef)v12[3]);
      }

      uint64_t v4 = *(void *)(a1 + 80);
      *(void *)(a1 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      int64_t v5 = *(void (**)(uint64_t))(a1 + 96);
      if (v5) {
        v5(v4);
      }
      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }

    *(_DWORD *)(a1 + 16) = 3;
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
  }

void sub_180A9A0A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

CFStringRef __CFFileDescriptorCopyDescription(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  if (!v2) {
    goto LABEL_5;
  }
  vm_map_t v3 = *(uint64_t (**)(void))(a1 + 104);
  if (!v3) {
    goto LABEL_5;
  }
  CFStringRef v4 = (CFStringRef)v3();
  if (!v4)
  {
    uint64_t v2 = *(void *)(a1 + 80);
LABEL_5:
    CFStringRef v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFFileDescriptor context %p>",  v2);
  }

  int64_t v5 = *(void **)(a1 + 64);
  dli_sname = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5) {
      dli_sname = v12.dli_sname;
    }
  }

  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = "No";
  if (!*(_DWORD *)(a1 + 16)) {
    uint64_t v9 = "Yes";
  }
  CFStringRef v10 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFFileDescriptor %p [%p]>{valid = %s, fd = %x, source = %p, callout = %s (%p), context = %@}",  a1,  v8,  v9,  *(unsigned int *)(a1 + 20),  *(void *)(a1 + 56),  dli_sname,  v5,  v4);
  if (v4) {
    CFRelease(v4);
  }
  return v10;
}

CFTypeID CFFileDescriptorGetTypeID(void)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  return 60LL;
}

uint64_t __CFFileDescriptorGetTypeID_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v0 = getrlimit(8, &v6);
  *(void *)uint64_t v7 = 0x1D00000001LL;
  int rlim_max = 0;
  size_t v4 = 4LL;
  uint64_t result = sysctl(v7, 2u, &rlim_max, &v4, 0LL, 0LL);
  if (result | v0)
  {
    if (v0) {
      return result;
    }
    LODWORD(v2) = rlim_max;
  }

  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      int rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }

  if (v6.rlim_cur < (int)v2)
  {
    rlim_t v2 = (int)v2;
    rlimit v3 = v6;
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }

  return result;
}

CFFileDescriptorRef CFFileDescriptorCreate( CFAllocatorRef allocator, CFFileDescriptorNativeDescriptor fd, Boolean closeOnInvalidate, CFFileDescriptorCallBack callout, const CFFileDescriptorContext *context)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0 || fstat(fd, &v27) < 0) {
    return 0LL;
  }
  unsigned int st_mode = v27.st_mode;
  int v11 = v27.st_mode & 0x180;
  if (v11 == 128)
  {
    int v12 = -1;
    if ((v27.st_mode & 0x80) == 0) {
      goto LABEL_9;
    }
  }

  else
  {
    int v12 = fcntl(fd, 67, 3LL);
    if ((st_mode & 0x80) == 0)
    {
LABEL_9:
      int v13 = -1;
      goto LABEL_12;
    }
  }

  int v13 = fcntl(fd, 67, 3LL);
LABEL_12:
  BOOL v14 = v12 >= 0 || v11 == 128;
  if (!v14 || ((v13 < 0) & (st_mode >> 7)) != 0)
  {
    if ((v12 & 0x80000000) == 0) {
      close(v12);
    }
    if ((v13 & 0x80000000) == 0) {
      close(v13);
    }
    return 0LL;
  }

  uint64_t v23 = 0LL;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000LL;
  uint64_t v26 = 0LL;
  uint64_t v15 = (dispatch_queue_s *)__fdQueue();
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __CFFileDescriptorCreate_block_invoke;
  block[3] = &unk_1899969A0;
  Boolean v22 = closeOnInvalidate;
  CFFileDescriptorNativeDescriptor v19 = fd;
  int v20 = v12;
  int v21 = v13;
  block[6] = callout;
  block[7] = context;
  block[4] = &v23;
  block[5] = allocator;
  dispatch_sync(v15, block);
  uint64_t v16 = (__CFFileDescriptor *)v24[3];
  if (!v16)
  {
    close(v12);
    close(v13);
    uint64_t v16 = (__CFFileDescriptor *)v24[3];
  }

  _Block_object_dispose(&v23, 8);
  return v16;
}

void sub_180A9A510( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

uint64_t __fdQueue()
{
  if (!__fdQueue___fddq)
  {
    dispatch_queue_t v0 = dispatch_queue_create("com.apple.CFFileDescriptor", 0LL);
    while (!__ldaxr((unint64_t *)&__fdQueue___fddq))
    {
    }

    __clrex();
    dispatch_release(v0);
  }

  return __fdQueue___fddq;
}

void __CFFileDescriptorCreate_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  handler[6] = *MEMORY[0x1895F89C0];
  uint64_t v9 = *(const __CFAllocator **)(a1 + 40);
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  uint64_t Instance = _CFRuntimeCreateInstance(v9, 0x3CuLL, 96LL, 0LL, a5, a6, a7, a8);
  if (Instance)
  {
    uint64_t v11 = Instance;
    if (*(_BYTE *)(a1 + 76))
    {
      int v12 = (unint64_t *)(Instance + 8);
      unint64_t v13 = atomic_load((unint64_t *)(Instance + 8));
      while (1)
      {
        unint64_t v14 = __ldaxr(v12);
        if (v14 != v13) {
          break;
        }
        if (__stlxr(v13 | 2, v12)) {
          goto LABEL_10;
        }
        int v15 = 1;
LABEL_11:
        unint64_t v13 = v14;
        if (v15) {
          goto LABEL_12;
        }
      }

      __clrex();
LABEL_10:
      int v15 = 0;
      goto LABEL_11;
    }

void __CFFileDescriptorCreate_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_BYTE *)(v2 + 5_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
  if (!*(_BYTE *)(v2 + 48))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 40));
    uint64_t v2 = *(void *)(a1 + 32);
    *(_BYTE *)(v2 + 4_Block_object_dispose(va, 8) = 1;
  }

  rlimit v3 = *(__CFRunLoopSource **)(v2 + 56);
  if (v3)
  {
    CFRunLoopSourceSignal(v3);
    _CFRunLoopSourceWakeUpRunLoops(*(void *)(*(void *)(a1 + 32) + 56LL));
  }

uint64_t __CFFileDescriptorCreate_block_invoke_3(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 40));
}

void __CFFileDescriptorCreate_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_BYTE *)(v2 + 51) = 1;
  if (!*(_BYTE *)(v2 + 49))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 40));
    uint64_t v2 = *(void *)(a1 + 32);
    *(_BYTE *)(v2 + 49) = 1;
  }

  rlimit v3 = *(__CFRunLoopSource **)(v2 + 56);
  if (v3)
  {
    CFRunLoopSourceSignal(v3);
    _CFRunLoopSourceWakeUpRunLoops(*(void *)(*(void *)(a1 + 32) + 56LL));
  }

uint64_t __CFFileDescriptorCreate_block_invoke_5(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 40));
}

CFFileDescriptorNativeDescriptor CFFileDescriptorGetNativeDescriptor(CFFileDescriptorRef f)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return -1;
  }
  else {
    return *((_DWORD *)f + 5);
  }
}

void CFFileDescriptorGetContext(CFFileDescriptorRef f, CFFileDescriptorContext *context)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  __int128 v5 = *(_OWORD *)((char *)f + 72);
  __int128 v6 = *(_OWORD *)((char *)f + 88);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(void *))*((void *)f + 13);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

void _CFFileDescriptorInduceFakeReadCallBack(uint64_t a1)
{
  uint64_t v3[5] = *MEMORY[0x1895F89C0];
  unint64_t v2 = (dispatch_queue_s *)__fdQueue();
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = ___CFFileDescriptorInduceFakeReadCallBack_block_invoke;
  void v3[3] = &__block_descriptor_tmp_7;
  v3[4] = a1;
  dispatch_async(v2, v3);
}

void CFFileDescriptorEnableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  block[6] = *MEMORY[0x1895F89C0];
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    __int128 v5 = (dispatch_queue_s *)__fdQueue();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __CFFileDescriptorEnableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    block[4] = f;
    block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }

void __CFFileDescriptorEnableCallBacks_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 16))
  {
    if ((*(_BYTE *)(a1 + 40) & 1) != 0 && *(void *)(v1 + 32))
    {
      BOOL is_readable = cffd_is_readable(*(_DWORD *)(v1 + 20));
      uint64_t v4 = *(void *)(a1 + 32);
      if (is_readable)
      {
        *(_BYTE *)(v4 + 5_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1;
        if (!*(_BYTE *)(v4 + 48))
        {
          dispatch_suspend(*(dispatch_object_t *)(v4 + 32));
          uint64_t v4 = *(void *)(a1 + 32);
          *(_BYTE *)(v4 + 4_Block_object_dispose(va, 8) = 1;
        }

        __int128 v5 = *(__CFRunLoopSource **)(v4 + 56);
        if (v5)
        {
          CFRunLoopSourceSignal(v5);
          _CFRunLoopSourceWakeUpRunLoops(*(void *)(*(void *)(a1 + 32) + 56LL));
        }
      }

      else if (*(_BYTE *)(v4 + 48))
      {
        *(_BYTE *)(v4 + 4_Block_object_dispose(va, 8) = 0;
        dispatch_resume(*(dispatch_object_t *)(v4 + 32));
      }
    }

    if ((*(_BYTE *)(a1 + 40) & 2) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      if (*(void *)(v6 + 40))
      {
        BOOL is_writeable = cffd_is_writeable(*(_DWORD *)(v6 + 20));
        uint64_t v8 = *(void *)(a1 + 32);
        if (is_writeable)
        {
          *(_BYTE *)(v8 + 51) = 1;
          if (!*(_BYTE *)(v8 + 49))
          {
            dispatch_suspend(*(dispatch_object_t *)(v8 + 40));
            uint64_t v8 = *(void *)(a1 + 32);
            *(_BYTE *)(v8 + 49) = 1;
          }

          uint64_t v9 = *(__CFRunLoopSource **)(v8 + 56);
          if (v9)
          {
            CFRunLoopSourceSignal(v9);
            _CFRunLoopSourceWakeUpRunLoops(*(void *)(*(void *)(a1 + 32) + 56LL));
          }
        }

        else if (*(_BYTE *)(v8 + 49))
        {
          *(_BYTE *)(v8 + 49) = 0;
          dispatch_resume(*(dispatch_object_t *)(v8 + 40));
        }
      }
    }
  }

BOOL cffd_is_readable(unsigned int a1)
{
  if (a1 >= 0x100000) {
    __break(1u);
  }
  size_t v2 = ((a1 + 8) >> 3) + 7;
  rlimit v3 = malloc(v2);
  int v4 = 1 << a1;
  uint64_t v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1)) {
      *((_DWORD *)v3 + v5) |= v4;
    }
    int v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 4 && *__error() != 35) {
      goto LABEL_12;
    }
  }

  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    BOOL v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }

BOOL cffd_is_writeable(unsigned int a1)
{
  if (a1 >= 0x100000) {
    __break(1u);
  }
  size_t v2 = ((a1 + 8) >> 3) + 7;
  rlimit v3 = malloc(v2);
  int v4 = 1 << a1;
  uint64_t v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1)) {
      *((_DWORD *)v3 + v5) |= v4;
    }
    int v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0) {
      break;
    }
    if (*__error() != 4 && *__error() != 35) {
      goto LABEL_12;
    }
  }

  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    BOOL v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }

void CFFileDescriptorDisableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  block[6] = *MEMORY[0x1895F89C0];
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v5 = (dispatch_queue_s *)__fdQueue();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __CFFileDescriptorDisableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_9;
    block[4] = f;
    block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }

void __CFFileDescriptorDisableCallBacks_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 16))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if ((v3 & 1) != 0)
    {
      unint64_t v4 = *(dispatch_object_s **)(v1 + 32);
      if (v4)
      {
        if (!*(_BYTE *)(v1 + 48))
        {
          dispatch_suspend(v4);
          uint64_t v1 = *(void *)(a1 + 32);
          uint64_t v3 = *(void *)(a1 + 40);
          *(_BYTE *)(v1 + 4_Block_object_dispose(va, 8) = 1;
        }
      }
    }

    if ((v3 & 2) != 0)
    {
      uint64_t v5 = *(dispatch_object_s **)(v1 + 40);
      if (v5)
      {
        if (!*(_BYTE *)(v1 + 49))
        {
          dispatch_suspend(v5);
          *(_BYTE *)(*(void *)(a1 + 32) + 49LL) = 1;
        }
      }
    }
  }

void CFFileDescriptorInvalidate(CFFileDescriptorRef f)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    CFRetain(f);
    uint64_t v12 = 0LL;
    unint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000LL;
    uint64_t v15 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    char v11 = 0;
    uint64_t v3 = (dispatch_queue_s *)__fdQueue();
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    int v7[2] = __CFFileDescriptorInvalidate_block_invoke;
    v7[3] = &unk_189996A28;
    uint64_t v7[5] = &v12;
    void v7[6] = f;
    v7[4] = &v8;
    dispatch_sync(v3, v7);
    if (*((_BYTE *)v9 + 24))
    {
      unint64_t v4 = (__CFRunLoopSource *)v13[3];
      if (v4)
      {
        CFRunLoopSourceInvalidate(v4);
        CFRelease((CFTypeRef)v13[3]);
      }

      uint64_t v5 = *((void *)f + 10);
      *((void *)f + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      int v6 = (void (*)(uint64_t))*((void *)f + 12);
      if (v6) {
        v6(v5);
      }
      *((_DWORD *)f + 4) = 2;
      __dmb(0xBu);
    }

    CFRelease(f);
    _Block_object_dispose(&v8, 8);
    _Block_object_dispose(&v12, 8);
  }

void sub_180A9B2E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void __CFFileDescriptorInvalidate_block_invoke(void *a1)
{
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = *(_DWORD *)(a1[6] + 16LL) == 0;
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    *(_DWORD *)(a1[6] + 16LL) = 1;
    __dmb(0xBu);
    unint64_t v2 = (void *)a1[6];
    uint64_t v3 = (dispatch_source_s *)v2[4];
    if (v3)
    {
      dispatch_source_cancel(v3);
      uint64_t v4 = a1[6];
      if (*(_BYTE *)(v4 + 48))
      {
        *(_BYTE *)(v4 + 4_Block_object_dispose((const void *)(v8 - 72), 8) = 0;
        dispatch_resume(*(dispatch_object_t *)(v4 + 32));
        uint64_t v4 = a1[6];
      }

      *(void *)(v4 + 32) = 0LL;
      unint64_t v2 = (void *)a1[6];
    }

    uint64_t v5 = (dispatch_source_s *)v2[5];
    if (v5)
    {
      dispatch_source_cancel(v5);
      uint64_t v6 = a1[6];
      if (*(_BYTE *)(v6 + 49))
      {
        *(_BYTE *)(v6 + 49) = 0;
        dispatch_resume(*(dispatch_object_t *)(v6 + 40));
        uint64_t v6 = a1[6];
      }

      *(void *)(v6 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      unint64_t v2 = (void *)a1[6];
    }

    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = v2[7];
    *(void *)(a1[6] + 56LL) = 0LL;
    char v7 = atomic_load((unint64_t *)(a1[6] + 8LL));
    if ((v7 & 2) != 0)
    {
      shutdown(*(_DWORD *)(a1[6] + 20LL), 2);
      int v8 = open("/dev/null", 0);
      dup2(v8, *(_DWORD *)(a1[6] + 20LL));
      close(v8);
      close(*(_DWORD *)(a1[6] + 20LL));
    }

    *(_DWORD *)(a1[6] + 20LL) = -1;
  }

Boolean CFFileDescriptorIsValid(CFFileDescriptorRef f)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  }
  if (*((_DWORD *)f + 4)) {
    return 0;
  }
  if (fstat(*((_DWORD *)f + 5), &v4) < 0)
  {
    CFFileDescriptorInvalidate(f);
    return 0;
  }

  return 1;
}

CFRunLoopSourceRef CFFileDescriptorCreateRunLoopSource( CFAllocatorRef allocator, CFFileDescriptorRef f, CFIndex order)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (CFFileDescriptorGetTypeID_initOnce != -1) {
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  }
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v6 != 60) {
    _CFAssertMismatchedTypeID(0x3CuLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0 || !CFFileDescriptorIsValid(f)) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  char v7 = (dispatch_queue_s *)__fdQueue();
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __CFFileDescriptorCreateRunLoopSource_block_invoke;
  block[3] = &unk_189996A50;
  block[6] = allocator;
  void block[7] = order;
  block[4] = &v11;
  block[5] = f;
  dispatch_sync(v7, block);
  int v8 = (__CFRunLoopSource *)v12[3];
  _Block_object_dispose(&v11, 8);
  return v8;
}

void *__CFFileDescriptorCreateRunLoopSource_block_invoke(void *result)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v1 = result[5];
  if (!*(_DWORD *)(v1 + 16))
  {
    unint64_t v2 = result;
    uint64_t v3 = *(__CFRunLoopSource **)(v1 + 56);
    if (v3)
    {
      int IsValid = CFRunLoopSourceIsValid(v3);
      uint64_t v1 = v2[5];
      if (!IsValid)
      {
        CFRelease(*(CFTypeRef *)(v1 + 56));
        *(void *)(v2[5] + 56LL) = 0LL;
        uint64_t v1 = v2[5];
      }
    }

    uint64_t result = *(void **)(v1 + 56);
    if (result) {
      goto LABEL_12;
    }
    context.CFIndex version = 0LL;
    context.info = (void *)v1;
    context.CFAllocatorRetainCallBack retain = CFRetain;
    context.CFArrayReleaseCallBack release = CFRelease;
    context.copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))__CFFileDescriptorCopyDescription;
    context.equal = 0LL;
    context.hash = 0LL;
    context.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFFileDescriptorSchedule;
    context.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFFileDescriptorCancel;
    context.perforuint64_t m = (void (__cdecl *)(void *))__CFFileDescriptorPerform;
    *(void *)(v2[5] + 56LL) = CFRunLoopSourceCreate((CFAllocatorRef)v2[6], v2[7], &context);
    uint64_t v5 = v2[5];
    unint64_t v6 = *(__CFRunLoopSource **)(v5 + 56);
    if (v6)
    {
      if (*(_BYTE *)(v5 + 50))
      {
        CFRunLoopSourceSignal(v6);
        _CFRunLoopSourceWakeUpRunLoops(*(void *)(v2[5] + 56LL));
        uint64_t v5 = v2[5];
      }

      if (*(_BYTE *)(v5 + 51))
      {
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(v5 + 56));
        _CFRunLoopSourceWakeUpRunLoops(*(void *)(v2[5] + 56LL));
        uint64_t v5 = v2[5];
      }
    }

    uint64_t result = *(void **)(v5 + 56);
    if (result) {
LABEL_12:
    }
      uint64_t result = CFRetain(result);
    *(void *)(*(void *)(v2[4] + 8LL) + 24LL) = result;
  }

  return result;
}

void __CFFileDescriptorSchedule(int a1, CFRunLoopRef rl)
{
}

void __CFFileDescriptorPerform(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v22 = 0LL;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000LL;
    char v25 = 0;
    uint64_t v18 = 0LL;
    CFFileDescriptorNativeDescriptor v19 = &v18;
    uint64_t v20 = 0x2000000000LL;
    char v21 = 0;
    uint64_t v14 = 0LL;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2000000000LL;
    char v17 = 0;
    uint64_t v10 = 0LL;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2000000000LL;
    uint64_t v13 = 0LL;
    uint64_t v6 = 0LL;
    char v7 = &v6;
    uint64_t v8 = 0x2000000000LL;
    uint64_t v9 = 0LL;
    unint64_t v2 = (dispatch_queue_s *)__fdQueue();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = ____CFFileDescriptorPerform_block_invoke;
    block[3] = &unk_189996AA0;
    block[4] = &v14;
    block[5] = &v22;
    block[6] = &v18;
    void block[7] = &v10;
    void block[8] = &v6;
    void block[9] = a1;
    dispatch_sync(v2, block);
    if (*((_BYTE *)v15 + 24) && (*((_BYTE *)v23 + 24) || *((_BYTE *)v19 + 24)))
    {
      uint64_t v3 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
      if (v3) {
        v3(a1, (*((_BYTE *)v23 + 24) != 0) | (2LL * (*((_BYTE *)v19 + 24) != 0)), v11[3]);
      }
      stat v4 = (void (*)(uint64_t))v7[3];
      if (v4) {
        v4(v11[3]);
      }
      if ((__CF_FORK_STATE & 2) == 0) {
        __CF_USED();
      }
      if ((__CF_FORK_STATE & 1) != 0) {
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
      }
    }

    _Block_object_dispose(&v6, 8);
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v14, 8);
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }

void sub_180A9B9A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
}

CFTypeRef _CFCopyExtensionForAbstractType(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

BOOL _CFCreateDirectory(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = mkdir(a1, 0x1FFu);
    if (v2 != -1) {
      close(v2);
    }
  }

  else
  {
    int v3 = mkdir(a1, 0x1FFu);
  }

  return v3 == 0;
}

BOOL _CFRemoveDirectory(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = rmdir(a1);
    if (v2 != -1) {
      close(v2);
    }
  }

  else
  {
    int v3 = rmdir(a1);
  }

  return v3 == 0;
}

BOOL _CFDeleteFile(char *a1)
{
  if (__CFProphylacticAutofsAccess)
  {
    int v2 = open("/dev/autofs_nowait", 0);
    int v3 = unlink(a1);
    if (v2 != -1) {
      close(v2);
    }
  }

  else
  {
    int v3 = unlink(a1);
  }

  return v3 == 0;
}

uint64_t _CFReadBytesFromFile( const __CFAllocator *a1, CFURLRef url, void **a3, off_t *a4, off_t st_size, int a6)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t result = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL);
  if ((_DWORD)result)
  {
    *a3 = 0LL;
    if (__CFProphylacticAutofsAccess)
    {
      int v12 = open("/dev/autofs_nowait", 0);
      int v13 = open((const char *)buffer, a6, 438LL);
      if (v13 < 0) {
        goto LABEL_21;
      }
      int v14 = v13;
    }

    else
    {
      int v15 = open((const char *)buffer, a6, 438LL);
      if (v15 < 0) {
        return 0LL;
      }
      int v14 = v15;
      int v12 = -1;
    }

    if (fstat(v14, &v21) < 0)
    {
      int v19 = *__error();
      close(v14);
      if (v12 != -1) {
        close(v12);
      }
      *__error() = v19;
      return 0LL;
    }

    if ((v21.st_mode & 0xF000) != 0x8000)
    {
      close(v14);
      if (v12 != -1) {
        close(v12);
      }
      *__error() = 13;
      return 0LL;
    }

    if (v21.st_size)
    {
      if (v21.st_size <= st_size || st_size == 0) {
        st_size = v21.st_size;
      }
      char v17 = CFAllocatorAllocate(a1, st_size, 0LL);
      *a3 = v17;
      if (!v17) {
        goto LABEL_20;
      }
      uint64_t v18 = v17;
      if (__CFOASafe)
      {
        __CFSetLastAllocationEventName();
        uint64_t v18 = *a3;
      }

      if (read(v14, v18, st_size) < 0)
      {
        CFAllocatorDeallocate(a1, *a3);
LABEL_20:
        close(v14);
LABEL_21:
        if (v12 != -1) {
          close(v12);
        }
        return 0LL;
      }
    }

    else
    {
      *a3 = CFAllocatorAllocate(a1, 4LL, 0LL);
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
      st_size = 0LL;
    }

    *a4 = st_size;
    if (v12 != -1) {
      close(v12);
    }
    close(v14);
    return 1LL;
  }

  return result;
}

uint64_t _CFWriteBytesToFile(const __CFURL *a1, const void *a2, size_t a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026LL);
  if ((_DWORD)result)
  {
    if (__CFProphylacticAutofsAccess) {
      int v6 = open("/dev/autofs_nowait", 0);
    }
    else {
      int v6 = -1;
    }
    if (stat((const char *)buffer, &v12) && *__error() != 2 || (int v7 = open((const char *)buffer, 1537, 438LL), v7 < 0))
    {
      if (v6 != -1) {
        close(v6);
      }
      return 0LL;
    }

    else
    {
      int v8 = v7;
      if (a3 && write(v7, a2, a3) != a3)
      {
        int v9 = *__error();
        close(v8);
        if (v6 != -1) {
          close(v6);
        }
        uint64_t v10 = __error();
        uint64_t result = 0LL;
        *uint64_t v10 = v9;
      }

      else
      {
        fsync(v8);
        close(v8);
        if (v6 != -1) {
          close(v6);
        }
        return 1LL;
      }
    }
  }

  return result;
}

__CFArray *_CFCreateContentsOfDirectory(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  uint64_t v5 = v4;
  int v7 = v6;
  int v8 = (UInt8 *)v3;
  int v9 = (const __CFAllocator *)v2;
  *(void *)&v54[1025] = *MEMORY[0x1895F89C0];
  if (v3)
  {
    size_t v10 = strlen(v3);
    if (!v5)
    {
LABEL_15:
      stat v12 = 0LL;
      int v18 = 0;
      CFIndex usedBufLen = 0LL;
      char v19 = 1;
      if (v8) {
        goto LABEL_20;
      }
      goto LABEL_18;
    }
  }

  else
  {
    size_t v10 = 0LL;
    if (!v4) {
      goto LABEL_15;
    }
  }

  uint64_t v11 = (const __CFString *)CFRetain(v5);
  if (!v11) {
    goto LABEL_15;
  }
  stat v12 = v11;
  uint64_t Length = CFStringGetLength(v11);
  CFIndex usedBufLen = Length;
  if (Length < 1) {
    goto LABEL_17;
  }
  CFIndex v14 = Length;
  CFStringEncoding v15 = CFStringFileSystemEncoding();
  v55.CFIndex location = 0LL;
  v55.size_t length = v14;
  CFStringGetBytes(v12, v55, v15, 0, 0, &buffer, 1024LL, &usedBufLen);
  v54[usedBufLen - 1] = 0;
  uint64_t v16 = buffer == 46 ? v54 : (const char *)&buffer;
  char v17 = strchr(v16, 46);
  if (v17)
  {
    int v18 = 0;
    do
    {
      ++v18;
      char v17 = strchr(v17 + 1, 46);
    }

    while (v17);
    char v19 = 0;
    if (v8) {
      goto LABEL_20;
    }
  }

  else
  {
LABEL_17:
    char v19 = 0;
    int v18 = 0;
    if (v8) {
      goto LABEL_20;
    }
  }

uint64_t _CFGetFileProperties( const __CFAllocator *a1, CFURLRef url, char *a3, _DWORD *a4, off_t *a5, CFDateRef *a6, uid_t *a7, __CFArray **a8)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024LL)) {
    return 0xFFFFFFFFLL;
  }
  if (!a3 && !a4 && !a5 && !a6 && !a7 && !a8) {
    return 0LL;
  }
  int v15 = stat((const char *)buffer, &v22);
  if (!v15)
  {
    BOOL v16 = (v22.st_mode & 0xF000) == 0x4000;
    char v17 = 1;
    if (!a3) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  if (*__error() != 2) {
    return *__error();
  }
  BOOL v16 = 0;
  char v17 = 0;
  if (a3) {
LABEL_14:
  }
    *a3 = v17;
LABEL_15:
  if (!a4)
  {
    if (!a5) {
      goto LABEL_26;
    }
    if (v15) {
      goto LABEL_22;
    }
LABEL_24:
    off_t st_size = v22.st_size;
    goto LABEL_25;
  }

  if (!v15)
  {
    *a4 = v22.st_mode;
    if (!a5) {
      goto LABEL_26;
    }
    goto LABEL_24;
  }

  *a4 = 0;
  if (a5)
  {
LABEL_22:
    off_t st_size = 0LL;
LABEL_25:
    *a5 = st_size;
  }

LABEL_36:
  if (!a8) {
    return 0LL;
  }
  if (v15 || !v16)
  {
    uint64_t result = 0LL;
    *a8 = 0LL;
  }

  else
  {
    stat v21 = _CFCreateContentsOfDirectory((uint64_t)a1, (uint64_t)buffer);
    uint64_t result = 0LL;
    *a8 = v21;
  }

  return result;
}

      if (v9) {
        goto LABEL_37;
      }
LABEL_38:
      if (++v5 == v2) {
        goto LABEL_39;
      }
    }
  }

  return 0LL;
}

  uint64_t v24 = __CFNumberTypeTable[theType];
  if ((v24 & 0x20) != 0)
  {
    if ((v24 & 0x40) != 0)
    {
      int v28 = *(double *)valuePtr;
      if (!*(void *)valuePtr)
      {
        uint64_t v27 = &__kCFNumberFloat64Zero;
        return (CFNumberRef)CFRetain(v27);
      }

      if (*(void *)valuePtr == 0x3FF0000000000000LL)
      {
        uint64_t v27 = &__kCFNumberFloat64One;
        return (CFNumberRef)CFRetain(v27);
      }

      if (fabs(v28) != INFINITY) {
        goto LABEL_67;
      }
      __int128 v31 = v28 < 0.0;
    }

    else
    {
      uint64_t v26 = *(float *)valuePtr;
      if (!*(_DWORD *)valuePtr)
      {
        uint64_t v27 = &__kCFNumberFloat32Zero;
        return (CFNumberRef)CFRetain(v27);
      }

      if (*(_DWORD *)valuePtr == 1065353216)
      {
        uint64_t v27 = &__kCFNumberFloat32One;
        return (CFNumberRef)CFRetain(v27);
      }

      if (fabsf(v26) != INFINITY) {
        goto LABEL_67;
      }
      __int128 v31 = v26 < 0.0;
    }

    if (v31) {
      uint64_t v27 = &__kCFNumberNegativeInfinity;
    }
    else {
      uint64_t v27 = &__kCFNumberPositiveInfinity;
    }
    return (CFNumberRef)CFRetain(v27);
  }

  if (&__kCFAllocatorSystemDefault == v9)
  {
    size_t v25 = 1;
    goto LABEL_48;
  }

  if (v9)
  {
LABEL_67:
    uint64_t v29 = -2LL;
    goto LABEL_68;
  }

  size_t v25 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
LABEL_48:
  uint64_t v29 = -2LL;
  if (v25 && !__CFNumberCaching)
  {
    switch(v24 & 0x1F)
    {
      case 1u:
        uint64_t v29 = *(char *)valuePtr;
        int v30 = (v29 + 1);
        goto LABEL_63;
      case 2u:
        uint64_t v29 = *(__int16 *)valuePtr;
        int v30 = (unsigned __int16)(v29 + 1);
        goto LABEL_63;
      case 3u:
        uint64_t v29 = *(int *)valuePtr;
        int v30 = v29 + 1;
LABEL_63:
        if (v30 <= 0xD) {
          goto LABEL_64;
        }
        goto LABEL_67;
      case 4u:
        uint64_t v29 = *(void *)valuePtr;
LABEL_64:
        uint64_t v27 = (__objc2_class **)__CFNumberCache[v29 + 1];
        if (v27) {
          return (CFNumberRef)CFRetain(v27);
        }
        break;
      default:
        break;
    }
  }

    if (v19) {
      uint64_t v20 = number;
    }
    else {
      uint64_t v20 = otherNumber;
    }
    if (!v19) {
      otherNumber = number;
    }
    __CFNumberGetValue((uint64_t)otherNumber, 6LL, (uint64_t)&v33);
    if (v33 < -1.70141183e38) {
      goto LABEL_42;
    }
    if (v33 >= 1.70141183e38) {
      goto LABEL_63;
    }
    __CFNumberGetValue((uint64_t)otherNumber, 17LL, (uint64_t)&v36);
    __CFNumberGetValue((uint64_t)v20, 17LL, (uint64_t)&v34);
    if (*(uint64_t *)&v36 < *(uint64_t *)&v34)
    {
LABEL_47:
      stat v22 = kCFCompareLessThan;
LABEL_52:
      stat v21 = v19 == 0;
      goto LABEL_64;
    }

    if (v37 < v35) {
      goto LABEL_47;
    }
    if (v37 > v35)
    {
LABEL_51:
      stat v22 = kCFCompareGreaterThan;
      goto LABEL_52;
    }

    *(double *)v29.i64 = v33;
    v30.i64[0] = 1.0;
    v31.f64[0] = NAN;
    v31.f64[1] = NAN;
    v29.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v31), v30, v29).u64[0];
    if (v34 < 0.0) {
      *(double *)v30.i64 = -1.0;
    }
    if (*(double *)v29.i64 >= *(double *)v30.i64)
    {
      if (*(double *)v30.i64 < *(double *)v29.i64)
      {
LABEL_63:
        stat v21 = v19 == 0;
        stat v22 = kCFCompareGreaterThan;
LABEL_64:
        if (v21) {
          return v22;
        }
        else {
          return -(uint64_t)v22;
        }
      }

      __CFNumberGetValue((uint64_t)v20, 6LL, (uint64_t)&v32);
      if (v33 >= v32)
      {
        if (v32 >= v33) {
          return 0LL;
        }
        goto LABEL_63;
      }
    }

  if (v21 <= 5) {
    goto LABEL_38;
  }
  uint64_t v27 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)v16,  v21,  (CFAllocatorRef)&__kCFAllocatorSystemDefault);
  *(void *)UInt8 buffer = 0LL;
  _CFPropertyListCreateWithData(v29, v27, v30, v9, 1, v31, 0LL, buffer);
  CFRelease(v27);
  return *(CFPropertyListRef *)buffer;
}

  int v34 = (unint64_t *)((char *)value + 8);
  CFIndex v35 = atomic_load((unint64_t *)value + 1);
  while (2)
  {
    Boolean v36 = __ldaxr(v34);
    if (v36 == v35)
    {
      if (!__stlxr(v35 & 0xFFFFFFFFFFFFFFBFLL, v34))
      {
        BOOL v37 = 1;
        goto LABEL_42;
      }
    }

    else
    {
      __clrex();
    }

    BOOL v37 = 0;
LABEL_42:
    CFIndex v35 = v36;
    if (!v37) {
      continue;
    }
    break;
  }

  CFURLRef v38 = (unint64_t *)((char *)value + 8);
  int v39 = atomic_load((unint64_t *)value + 1);
  while (2)
  {
    uint64_t v40 = __ldaxr(v38);
    if (v40 == v39)
    {
      if (!__stlxr(v39 & 0xFFFFFFFFFFFFFFDFLL, v38))
      {
        uint64_t v41 = 1;
        goto LABEL_49;
      }
    }

    else
    {
      __clrex();
    }

    uint64_t v41 = 0;
LABEL_49:
    int v39 = v40;
    if (!v41) {
      continue;
    }
    break;
  }

  CFIndex v42 = value;
  *((_DWORD *)value + 4) = v7 & 0x73 | *((_DWORD *)value + 4) & 0xFFFFFF00 | 0x80;
  v42[3] = 850045857LL;
  *((_OWORD *)v42 + 2) = 0u;
  *((_OWORD *)v42 + 3) = 0u;
  *((_OWORD *)v42 + 4) = 0u;
  v42[10] = 0LL;
  v42[11] = 850045857LL;
  *((_OWORD *)v42 + 6) = 0u;
  *((_OWORD *)v42 + 7) = 0u;
  *((_OWORD *)v42 + _Block_object_dispose((const void *)(v28 - 104), 8) = 0u;
  v42[18] = 0LL;
  *((_DWORD *)v42 + 3_Block_object_dispose((const void *)(v28 - 104), 8) = sock;
  if (sock == -1)
  {
    *((_DWORD *)v42 + 39) = 0;
    v42[26] = callout;
    *((_DWORD *)v42 + 7_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    v42[34] = 0LL;
    *((_DWORD *)v42 + 86) = 0;
    v42[42] = 0LL;
  }

  else
  {
    *(_OWORD *)&callBacks.__sig = *(_OWORD *)&kCFTypeArrayCallBacks.version;
    *(void *)&callBacks.__opaque[8] = kCFTypeArrayCallBacks.release;
    *(void *)&callBacks.__opaque[16] = 0LL;
    *(void *)&callBacks.__opaque[24] = CFEqual;
    uint64_t v43 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (const CFArrayCallBacks *)&callBacks);
    int v44 = value;
    *((void *)value + 25) = v43;
    v44[26] = callout;
    *((_DWORD *)v44 + 7_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
    v44[34] = 0LL;
    *((_DWORD *)v44 + 86) = 0;
    v44[42] = 0LL;
    CFDictionaryAddValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)sock, v44);
  }

  if (!__CFSocketManagerThread)
  {
    uint64_t v53 = 0LL;
    pthread_attr_init(&callBacks);
    pthread_attr_setscope(&callBacks, 1);
    pthread_attr_setdetachstate(&callBacks, 2);
    char v46 = qos_class_main();
    pthread_attr_set_qos_class_np(&callBacks, v46, 0);
    pthread_create(&v53, &callBacks, (void *(__cdecl *)(void *))__CFSocketManager, 0LL);
    pthread_attr_destroy(&callBacks);
    __CFSocketManagerThread = (uint64_t)v53;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
  if (context)
  {
    info = context->info;
    CFAllocatorRetainCallBack retain = context->retain;
    if (retain) {
      info = (void *)((uint64_t (*)(void *))retain)(context->info);
    }
    pthread_mutex_lock((pthread_mutex_t *)((char *)value + 24));
    stat v49 = (char *)value;
    *(_OWORD *)((char *)value + 232) = *(_OWORD *)&context->retain;
    *((void *)v49 + 31) = context->copyDescription;
    *((void *)v49 + 2_Block_object_dispose((const void *)(v28 - 104), 8) = info;
    pthread_mutex_unlock((pthread_mutex_t *)(v49 + 24));
  }

  return (CFSocketRef)value;
}

  LODWORD(result) = encoding;
  return result;
}

  if ((unint64_t)v20 < 8)
  {
    int v65 = 0;
    unint64_t v66 = 0;
LABEL_187:
    int v18 = v141;
    goto LABEL_188;
  }

  BOOL v33 = *((_DWORD *)v19 + 1);
  uint64_t v27 = "mov";
  if (v33 <= 1952539752)
  {
    if (v33 == 1329745730)
    {
      uint64_t v27 = "cwk";
      goto LABEL_444;
    }

    if (v33 != 1668506729)
    {
      int v34 = 1701079415;
      goto LABEL_249;
    }

                  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'",  v9,  a4);
                  goto LABEL_174;
                }
              }

              CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s' -- size is too large",  v9,  a4);
              while (1)
              {
LABEL_174:
                uint64_t v62 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                objc_exception_throw(v62);
LABEL_175:
                CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): unsupported type encoding spec '%c' at '%s' in '%s'",  v11,  v9,  a4);
              }
            }

            int v18 = -1LL;
          }

          else
          {
            int v18 = v17 == 91;
          }

          v16 += v18;
          char v17 = v10[v15++ + 2];
          if (!v17) {
            goto LABEL_36;
          }
        }

      case '^':
        if (a6 >= 0x200) {
          goto LABEL_178;
        }
        char v19 = *result;
        if (v19 == 118 || v19 == 63)
        {
          uint64_t result = v10 + 2;
LABEL_41:
          if (a3) {
            *a3 = 8LL;
          }
          if (a2)
          {
            uint64_t v13 = 8LL;
            goto LABEL_45;
          }

    if (v20 < v15 && v17 <= 0xF) {
      break;
    }
    if (v20 < v15) {
      uint64_t v23 = v12;
    }
    else {
      uint64_t v23 = v12 + 1;
    }
    __rehashs((uint64_t)v35, v23);
    stat v12 = (unint64_t)*((unsigned int *)&p_storage->var0.var0 + 1) >> 26;
    uint64_t v13 = __NSSetSizes_0[2 * v12];
  }

  uint64_t v24 = objs[v20];
  if (v24 == (state *)&___NSSetM_DeletedMarker || v24 == 0LL)
  {
    uint64_t v26 = v34 & 0x3FFFFFF;
    objs[v20] = (state *)a3;
    *((_DWORD *)&p_storage->var0.var0 + 1) = *((_DWORD *)&p_storage->var0.var0 + 1) & 0xFC000000 | (*((_DWORD *)&p_storage->var0.var0 + 1)
                                                                                                  + 1) & 0x3FFFFFF;
  }

                uint64_t v11 = 0;
LABEL_37:
                char v19 = 0;
                uint64_t v20 = 0;
                stat v21 = 0x8000;
                goto LABEL_50;
              }

CFURLRef _CFURLExists(const __CFURL *url)
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  char v1 = 0;
  if (url)
  {
    if (_CFGetFileProperties( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  url,  &v1,  0LL,  0LL,  0LL,  0LL,  0LL)) {
      return 0LL;
    }
    else {
      return (const __CFURL *)(v1 != 0);
    }
  }

  return url;
}

uint64_t _CFGetSlash()
{
  return 47LL;
}

CFStringRef _CFGetSlashStr()
{
  return @"/";
}

BOOL _CFIsAbsolutePath(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 < 1) {
    return 0LL;
  }
  int v2 = *a1;
  return v2 == 126 || v2 == 47;
}

BOOL _CFStripTrailingPathSlashes(unsigned __int16 *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 >= 2 && a1[1] == 58)
  {
    int v3 = *a1;
    unsigned int v4 = v3 - 65;
    BOOL v5 = (v3 - 97) < 0x1A;
    if (v4 < 0x1A) {
      BOOL v5 = 1;
    }
  }

  else
  {
    BOOL v5 = 0;
  }

  for (uint64_t i = 0LL; ; --i)
  {
    uint64_t v7 = v2 + i;
    if (v5)
    {
      if (v7 <= 3) {
        return i != 0;
      }
    }

    else if (v7 < 2)
    {
      return i != 0;
    }

    if (a1[v2 - 1 + i] != 47) {
      break;
    }
    *a2 = v2 + i - 1;
  }

  return i != 0;
}

void _CFAppendTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length)
  {
    if (Length == 2)
    {
    }

    else if (Length != 1 || CFStringGetCharacterAtIndex(a1, 0LL) != 47)
    {
LABEL_9:
      CFStringAppendCharacters(a1, &_CFAppendTrailingPathSlash2_slash, 1LL);
    }
  }

BOOL _hasDrive(const __CFString *a1)
{
  BOOL result = 0;
  if (CFStringGetLength(a1) >= 2)
  {
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0LL);
    if (CFStringGetCharacterAtIndex(a1, 1LL) == 58 && (CharacterAtIndex & 0xFFFFFFDF) - 65 < 0x1A) {
      return 1;
    }
  }

  return result;
}

uint64_t _hasNet(const __CFString *a1)
{
  if (CFStringGetLength(a1) < 2) {
    return 0LL;
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0LL);
  uint64_t v3 = 1LL;
  int v4 = CFStringGetCharacterAtIndex(a1, 1LL);
  if (CharacterAtIndex != 92 || v4 != 92) {
    return 0LL;
  }
  return v3;
}

void _CFAppendConditionalTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (CFStringGetCharacterAtIndex(a1, Length - 1) != 47) {
    CFStringAppendCharacters(a1, &_CFAppendConditionalTrailingPathSlash2_slash, 1LL);
  }
}

void _CFAppendPathComponent2(__CFString *a1, const __CFString *a2)
{
}

uint64_t _CFAppendPathComponent(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, void *__src, uint64_t a5)
{
  if (!a5) {
    return 1LL;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = *a2 + 1;
  if (v8 + a5 > a3) {
    return 0LL;
  }
  if (v7 < a3 && v7 != 0)
  {
    if (v7 != 2)
    {
      if (v7 == 1 && *a1 == 47)
      {
        uint64_t v7 = 1LL;
        goto LABEL_20;
      }

LABEL_20:
  memmove(&a1[v7], __src, 2 * a5);
  *a2 += a5;
  return 1LL;
}

    memmove(&v16[v14], buffer, v20);
    v17 -= v20;
    v14 += v20;
  }

  while (v17 >= 1);
  if (!v16)
  {
LABEL_38:
    if (v16) {
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
    }
    if (v9)
    {
      int v28 = __CFPropertyListCreateError(3840LL, @"stream had too few bytes");
      BOOL result = 0LL;
      *int v9 = v28;
      return result;
    }

    return 0LL;
  }

          ++v6;
          goto LABEL_21;
        default:
          if (!v8) {
            return v6;
          }
LABEL_21:
          ++v5;
          int v4 = Length;
          continue;
      }
    }
  }

  return 0LL;
}

  int v12 = v6 + 1;
  if (v6 + 1 >= v5)
  {
    CFIndex v14 = 0;
    goto LABEL_32;
  }

  uint64_t v13 = 0LL;
  LOBYTE(v14) = 0;
  int v15 = 1;
  while (1)
  {
    BOOL v16 = v15;
    char v17 = v126[v6 + v13];
    int v18 = v17 - 48;
LABEL_27:
    int v15 = 0;
    CFIndex v14 = (v18 | (16 * v14));
    uint64_t v13 = 1LL;
    if ((v16 & 1) == 0) {
      goto LABEL_31;
    }
  }

  if ((v17 - 97) <= 5)
  {
    int v18 = v17 - 87;
    goto LABEL_27;
  }

  if ((v17 - 65) <= 5)
  {
    int v18 = v17 - 55;
    goto LABEL_27;
  }

  CFIndex v14 = 0;
LABEL_31:
  int v12 = v6 + 3;
  v6 += 2LL;
LABEL_32:
  if (v12 >= v5)
  {
    size_t v25 = 0LL;
    goto LABEL_44;
  }

  char v19 = 0LL;
  LOBYTE(v2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  stat v21 = 1;
  while (2)
  {
    stat v22 = v21;
    uint64_t v23 = v126[v6 + v19];
    uint64_t v24 = v23 - 48;
    if ((v23 - 48) < 0xA)
    {
LABEL_39:
      stat v21 = 0;
      uint64_t v20 = (v24 | (16 * v20));
      char v19 = 1LL;
      if ((v22 & 1) == 0) {
        goto LABEL_43;
      }
      continue;
    }

    break;
  }

  if ((v23 - 97) <= 5)
  {
    uint64_t v24 = v23 - 87;
    goto LABEL_39;
  }

  if ((v23 - 65) <= 5)
  {
    uint64_t v24 = v23 - 55;
    goto LABEL_39;
  }

  uint64_t v20 = 0;
LABEL_43:
  int v12 = v6 + 3;
  v6 += 2LL;
  size_t v25 = (unint64_t)v20 << 8;
LABEL_44:
  if (v12 >= v5)
  {
    unsigned int v32 = 0LL;
    goto LABEL_56;
  }

  uint64_t v26 = 0LL;
  LOBYTE(v27) = 0;
  int v28 = 1;
  while (2)
  {
    uint64_t v29 = v28;
    int v30 = v126[v6 + v26];
    __int128 v31 = v30 - 48;
    if ((v30 - 48) < 0xA)
    {
LABEL_51:
      int v28 = 0;
      uint64_t v27 = (v31 | (16 * v27));
      uint64_t v26 = 1LL;
      if ((v29 & 1) == 0) {
        goto LABEL_55;
      }
      continue;
    }

    break;
  }

  if ((v30 - 97) <= 5)
  {
    __int128 v31 = v30 - 87;
    goto LABEL_51;
  }

  if ((v30 - 65) <= 5)
  {
    __int128 v31 = v30 - 55;
    goto LABEL_51;
  }

  uint64_t v27 = 0;
LABEL_55:
  int v12 = v6 + 3;
  v6 += 2LL;
  unsigned int v32 = (unint64_t)v27 << 16;
LABEL_56:
  if (v12 >= v5)
  {
    int v39 = 0LL;
    goto LABEL_68;
  }

  BOOL v33 = 0LL;
  LOBYTE(v34) = 0;
  CFIndex v35 = 1;
  while (2)
  {
    Boolean v36 = v35;
    BOOL v37 = v126[v6 + v33];
    CFURLRef v38 = v37 - 48;
    if ((v37 - 48) < 0xA)
    {
LABEL_63:
      CFIndex v35 = 0;
      int v34 = (v38 | (16 * v34));
      BOOL v33 = 1LL;
      if ((v36 & 1) == 0) {
        goto LABEL_67;
      }
      continue;
    }

    break;
  }

  if ((v37 - 97) <= 5)
  {
    CFURLRef v38 = v37 - 87;
    goto LABEL_63;
  }

  if ((v37 - 65) <= 5)
  {
    CFURLRef v38 = v37 - 55;
    goto LABEL_63;
  }

  int v34 = 0;
LABEL_67:
  int v12 = v6 + 3;
  v6 += 2LL;
  int v39 = (unint64_t)v34 << 24;
LABEL_68:
  if (v6 + 2 >= v5)
  {
    CFStringRef v47 = 0LL;
    goto LABEL_80;
  }

  uint64_t v40 = 0LL;
  LOBYTE(v41) = 0;
  CFIndex v42 = &v126[v12];
  uint64_t v43 = 1;
  while (2)
  {
    int v44 = v43;
    int v45 = v42[v40];
    char v46 = v45 - 48;
    if ((v45 - 48) < 0xA)
    {
LABEL_75:
      uint64_t v43 = 0;
      uint64_t v41 = (v46 | (16 * v41));
      uint64_t v40 = 1LL;
      if ((v44 & 1) == 0) {
        goto LABEL_79;
      }
      continue;
    }

    break;
  }

  if ((v45 - 97) <= 5)
  {
    char v46 = v45 - 87;
    goto LABEL_75;
  }

  if ((v45 - 65) <= 5)
  {
    char v46 = v45 - 55;
    goto LABEL_75;
  }

  uint64_t v41 = 0LL;
LABEL_79:
  int v12 = v6 + 3;
  CFStringRef v47 = v41 << 32;
LABEL_80:
  int v48 = v12 + 1;
  if (v12 + 1 >= v5)
  {
    CFRange v55 = 0LL;
    goto LABEL_92;
  }

  stat v49 = 0LL;
  LOBYTE(v5_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  dirent v51 = 1;
  while (2)
  {
    CFRange v52 = v51;
    uint64_t v53 = v126[v12 + v49];
    double v54 = v53 - 48;
    if ((v53 - 48) < 0xA)
    {
LABEL_87:
      dirent v51 = 0;
      uint64_t v50 = (v54 | (16 * v50));
      stat v49 = 1LL;
      if ((v52 & 1) == 0) {
        goto LABEL_91;
      }
      continue;
    }

    break;
  }

  if ((v53 - 97) <= 5)
  {
    double v54 = v53 - 87;
    goto LABEL_87;
  }

  if ((v53 - 65) <= 5)
  {
    double v54 = v53 - 55;
    goto LABEL_87;
  }

  uint64_t v50 = 0LL;
LABEL_91:
  int v48 = v12 + 3;
  v12 += 2LL;
  CFRange v55 = v50 << 40;
LABEL_92:
  if (v12 + 2 >= v5)
  {
    CFRange v63 = 0LL;
    goto LABEL_104;
  }

  Boolean v56 = 0LL;
  LOBYTE(v57) = 0;
  unsigned int v58 = &v126[v48];
  int v59 = 1;
  while (2)
  {
    uint64_t v60 = v59;
    uint64_t v61 = v58[v56];
    uint64_t v62 = v61 - 48;
    if ((v61 - 48) < 0xA)
    {
LABEL_99:
      int v59 = 0;
      char v57 = (v62 | (16 * v57));
      Boolean v56 = 1LL;
      if ((v60 & 1) == 0) {
        goto LABEL_103;
      }
      continue;
    }

    break;
  }

  if ((v61 - 97) <= 5)
  {
    uint64_t v62 = v61 - 87;
    goto LABEL_99;
  }

  if ((v61 - 65) <= 5)
  {
    uint64_t v62 = v61 - 55;
    goto LABEL_99;
  }

  char v57 = 0LL;
LABEL_103:
  int v48 = v12 + 3;
  CFRange v63 = v57 << 48;
LABEL_104:
  CFTypeID v64 = v48 + 1;
  if (v48 + 1 >= v5)
  {
    int v71 = 0LL;
    goto LABEL_116;
  }

  int v65 = 0LL;
  LOBYTE(v66) = 0;
  unint64_t v67 = 1;
  while (2)
  {
    int v68 = v67;
    CFTypeID v69 = v126[v48 + v65];
    unint64_t v70 = v69 - 48;
    if ((v69 - 48) < 0xA)
    {
LABEL_111:
      unint64_t v67 = 0;
      unint64_t v66 = (v70 | (16 * v66));
      int v65 = 1LL;
      if ((v68 & 1) == 0) {
        goto LABEL_115;
      }
      continue;
    }

    break;
  }

  if ((v69 - 97) <= 5)
  {
    unint64_t v70 = v69 - 87;
    goto LABEL_111;
  }

  if ((v69 - 65) <= 5)
  {
    unint64_t v70 = v69 - 55;
    goto LABEL_111;
  }

  unint64_t v66 = 0LL;
LABEL_115:
  CFTypeID v64 = v48 + 3;
  v48 += 2LL;
  int v71 = v66 << 56;
LABEL_116:
  if (v48 + 2 >= v5)
  {
    unint64_t v79 = 0LL;
    goto LABEL_128;
  }

  unint64_t v72 = 0LL;
  LOBYTE(v73) = 0;
  CFTypeID v74 = &v126[v64];
  unint64_t v75 = 1;
  while (2)
  {
    int v76 = v75;
    uint64_t v77 = v74[v72];
    CFTypeID v78 = v77 - 48;
    if ((v77 - 48) < 0xA)
    {
LABEL_123:
      unint64_t v75 = 0;
      unint64_t v73 = (v78 | (16 * v73));
      unint64_t v72 = 1LL;
      if ((v76 & 1) == 0) {
        goto LABEL_127;
      }
      continue;
    }

    break;
  }

  if ((v77 - 97) <= 5)
  {
    CFTypeID v78 = v77 - 87;
    goto LABEL_123;
  }

  if ((v77 - 65) <= 5)
  {
    CFTypeID v78 = v77 - 55;
    goto LABEL_123;
  }

  unint64_t v73 = 0;
LABEL_127:
  unint64_t v79 = v73;
  CFTypeID v64 = v48 + 3;
LABEL_128:
  int64_t v80 = v64 + 1;
  if (v64 + 1 >= v5) {
    goto LABEL_139;
  }
  uint64_t v81 = 0LL;
  LOBYTE(v82) = 0;
  CFTypeID v83 = 1;
  while (2)
  {
    uint64_t v84 = v83;
    CFTypeRef v85 = v126[v64 + v81];
    uint64_t v86 = v85 - 48;
    if ((v85 - 48) < 0xA)
    {
LABEL_135:
      CFTypeID v83 = 0;
      int v82 = (v86 | (16 * v82));
      uint64_t v81 = 1LL;
      if ((v84 & 1) == 0) {
        goto LABEL_138;
      }
      continue;
    }

    break;
  }

  if ((v85 - 97) <= 5)
  {
    uint64_t v86 = v85 - 87;
    goto LABEL_135;
  }

  if ((v85 - 65) <= 5)
  {
    uint64_t v86 = v85 - 55;
    goto LABEL_135;
  }

  int v82 = 0;
LABEL_138:
  v79 |= (unint64_t)v82 << 8;
  int64_t v80 = v64 + 3;
  v64 += 2LL;
LABEL_139:
  if (v64 + 2 >= v5) {
    goto LABEL_150;
  }
  unint64_t v87 = 0LL;
  LOBYTE(v8_Block_object_dispose((const void *)(v28 - 104), 8) = 0;
  int v89 = &v126[v80];
  unint64_t v90 = 1;
  while (2)
  {
    unint64_t v91 = v90;
    CFIndex v92 = v89[v87];
    char v93 = v92 - 48;
    if ((v92 - 48) < 0xA)
    {
LABEL_146:
      unint64_t v90 = 0;
      uint64_t v88 = (v93 | (16 * v88));
      unint64_t v87 = 1LL;
      if ((v91 & 1) == 0) {
        goto LABEL_149;
      }
      continue;
    }

    break;
  }

  if ((v92 - 97) <= 5)
  {
    char v93 = v92 - 87;
    goto LABEL_146;
  }

  if ((v92 - 65) <= 5)
  {
    char v93 = v92 - 55;
    goto LABEL_146;
  }

  uint64_t v88 = 0;
LABEL_149:
  v79 |= (unint64_t)v88 << 16;
  int64_t v80 = v64 + 3;
LABEL_150:
  unint64_t v94 = v80 + 1;
  if (v80 + 1 >= v5) {
    goto LABEL_161;
  }
  CFIndex v95 = 0LL;
  LOBYTE(v96) = 0;
  unint64_t v97 = 1;
  while (2)
  {
    double v98 = v97;
    CFTypeRef v99 = v126[v80 + v95];
    unint64_t v100 = v99 - 48;
    if ((v99 - 48) < 0xA)
    {
LABEL_157:
      unint64_t v97 = 0;
      int32_t v96 = (v100 | (16 * v96));
      CFIndex v95 = 1LL;
      if ((v98 & 1) == 0) {
        goto LABEL_160;
      }
      continue;
    }

    break;
  }

  if ((v99 - 97) <= 5)
  {
    unint64_t v100 = v99 - 87;
    goto LABEL_157;
  }

  if ((v99 - 65) <= 5)
  {
    unint64_t v100 = v99 - 55;
    goto LABEL_157;
  }

  int32_t v96 = 0;
LABEL_160:
  v79 |= (unint64_t)v96 << 24;
  unint64_t v94 = v80 + 3;
  v80 += 2LL;
LABEL_161:
  if (v94 >= v5) {
    goto LABEL_172;
  }
  int v101 = 0LL;
  LOBYTE(v102) = 0;
  unint64_t v103 = 1;
  while (2)
  {
    char v104 = v103;
    char v105 = v126[v80 + v101];
    BOOL v106 = v105 - 48;
    if ((v105 - 48) < 0xA)
    {
LABEL_168:
      unint64_t v103 = 0;
      uint64_t v102 = (v106 | (16 * v102));
      int v101 = 1LL;
      if ((v104 & 1) == 0) {
        goto LABEL_171;
      }
      continue;
    }

    break;
  }

  if ((v105 - 97) <= 5)
  {
    BOOL v106 = v105 - 87;
    goto LABEL_168;
  }

  if ((v105 - 65) <= 5)
  {
    BOOL v106 = v105 - 55;
    goto LABEL_168;
  }

  uint64_t v102 = 0LL;
LABEL_171:
  v79 |= v102 << 32;
  unint64_t v94 = v80 + 3;
  v80 += 2LL;
LABEL_172:
  if (v94 >= v5) {
    goto LABEL_183;
  }
  uint64_t v107 = 0LL;
  LOBYTE(v10_Block_object_dispose((const void *)(v28 - 104), 8) = 0;
  double v109 = 1;
  while (2)
  {
    char v110 = v109;
    unint64_t v111 = v126[v80 + v107];
    unint64_t v112 = v111 - 48;
    if ((v111 - 48) < 0xA)
    {
LABEL_179:
      double v109 = 0;
      double v108 = (v112 | (16 * v108));
      uint64_t v107 = 1LL;
      if ((v110 & 1) == 0) {
        goto LABEL_182;
      }
      continue;
    }

    break;
  }

  if ((v111 - 97) <= 5)
  {
    unint64_t v112 = v111 - 87;
    goto LABEL_179;
  }

  if ((v111 - 65) <= 5)
  {
    unint64_t v112 = v111 - 55;
    goto LABEL_179;
  }

  double v108 = 0LL;
LABEL_182:
  v79 |= v108 << 40;
  unint64_t v94 = v80 + 3;
  v80 += 2LL;
LABEL_183:
  if (v94 >= v5) {
    goto LABEL_194;
  }
  CFTypeID v113 = 0LL;
  LOBYTE(v114) = 0;
  uint64_t v115 = 1;
  while (2)
  {
    unint64_t v116 = v115;
    CFTypeID v117 = v126[v80 + v113];
    int v118 = v117 - 48;
    if ((v117 - 48) < 0xA)
    {
LABEL_190:
      uint64_t v115 = 0;
      uint64_t v114 = (v118 | (16 * v114));
      CFTypeID v113 = 1LL;
      if ((v116 & 1) == 0) {
        goto LABEL_193;
      }
      continue;
    }

    break;
  }

  if ((v117 - 97) <= 5)
  {
    int v118 = v117 - 87;
    goto LABEL_190;
  }

  if ((v117 - 65) <= 5)
  {
    int v118 = v117 - 55;
    goto LABEL_190;
  }

  uint64_t v114 = 0LL;
LABEL_193:
  v79 |= v114 << 48;
  unint64_t v94 = v80 + 3;
  v80 += 2LL;
LABEL_194:
  if (v94 >= v5) {
    return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive( (uint64_t)alloc,  v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71,  v79,  0);
  }
  int v119 = 0LL;
  LOBYTE(v12_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0;
  uint64_t v121 = &v126[v80];
  int v122 = 1;
  while (2)
  {
    int v123 = v122;
    uint64_t v124 = v121[v119];
    int v125 = v124 - 48;
    if ((v124 - 48) < 0xA)
    {
LABEL_201:
      int v122 = 0;
      unint64_t v120 = (v125 | (16 * v120));
      int v119 = 1LL;
      if ((v123 & 1) == 0) {
        goto LABEL_204;
      }
      continue;
    }

    break;
  }

  if ((v124 - 97) <= 5)
  {
    int v125 = v124 - 87;
    goto LABEL_201;
  }

  if ((v124 - 65) <= 5)
  {
    int v125 = v124 - 55;
    goto LABEL_201;
  }

  unint64_t v120 = 0LL;
LABEL_204:
  v79 |= v120 << 56;
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive( (uint64_t)alloc,  v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71,  v79,  0);
}

  if (v7 != 127 && (v5 + 6) >= 0xF6u && (v7 + 3) >= 0x43u)
  {
    int v9 = v8 - 68 * (v5 & 0xF) + ((char)v7 >> 7) - 4160;
    goto LABEL_29;
  }

  if (v8 >> 6 <= 0x3B4 && v8 - 34624 > 0x5C)
  {
    size_t v10 = ShiftJISToJIS0208(a2);
    int v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }

  if (v8 > 0xFC60 || v8 >> 6 < 0x21D)
  {
LABEL_42:
    *a4 = 0;
    return 0LL;
  }

  int v12 = (unsigned __int16 *)&DOSJapanese_to_uni;
  uint64_t v13 = (unsigned __int16 *)&unk_180D73C0E;
  while (1)
  {
    CFIndex v14 = (0xF83E0F83E0F83E1LL * (v13 - v12)) >> 1;
    int v15 = &v12[33 * v14];
    BOOL v16 = *v15;
    if (v16 <= v8) {
      break;
    }
    uint64_t v13 = v15 - 33;
LABEL_41:
    if (v12 > v13) {
      goto LABEL_42;
    }
  }

  if (v16 + 32 <= v8)
  {
    int v12 = v15 + 33;
    goto LABEL_41;
  }

  char v17 = v12[33 * v14 + 1 + (int)(v8 - v16)];
  *a4 = v17;
  if (!v17) {
    return 0LL;
  }
  return 2LL;
}

    if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
    {
      uint64_t v7 = v12 + 1;
      if (!a5) {
        goto LABEL_232;
      }
      uint64_t v40 = v14 + 64;
LABEL_114:
      *a4++ = v40;
      goto LABEL_232;
    }

    char v17 = v13 + 1;
    if (v13 + 1 < a3 && v14 == 8230) {
      break;
    }
LABEL_33:
    uint64_t v24 = v13 > 0 || (v14 & 0xFFF0) == 63584;
    if ((a1 & 8) != 0 || !v24) {
      goto LABEL_238;
    }
    if ((a1 & 0x10) == 0)
    {
      uint64_t v13 = v8;
      int v11 = a2;
      goto LABEL_232;
    }

    if (v14 != 63615)
    {
      if ((int)v14 <= 12440)
      {
        if (v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0)
        {
          if (v14 == 8413)
          {
            int v28 = *(v11 - 1);
            switch(v28)
            {
              case 22823:
                LOBYTE(v29) = -111;
                break;
              case 25511:
                LOBYTE(v29) = -99;
                break;
              case 23567:
                LOBYTE(v29) = -110;
                break;
              default:
                goto LABEL_238;
            }

            if (a5)
            {
              uint64_t v50 = -121;
LABEL_126:
              *(a4 - 2) = v50;
              *(a4 - 1) = v29;
            }

  if (v11)
  {
    uint64_t v23 = v11;
    uint64_t v20 = _os_log_pack_size();
    stat v21 = (char *)v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v24 = _os_log_pack_fill();
    size_t v25 = __os_log_helper_1_2_3_8_32_8_0_8_0(v24, (uint64_t)"-[NSMutableArray insertObjects:count:atIndex:]", a5, --v23);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v25,  "-[NSMutableArray insertObjects:count:atIndex:]",  a5,  v23);
  }

  else
  {
    uint64_t v20 = _os_log_pack_size();
    stat v21 = (char *)v31 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    stat v22 = _os_log_pack_fill();
    *(_DWORD *)stat v22 = 136315394;
    *(void *)(v22 + 4) = "-[NSMutableArray insertObjects:count:atIndex:]";
    *(_WORD *)(v22 + 12) = 2048;
    *(void *)(v22 + 14) = a5;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "-[NSMutableArray insertObjects:count:atIndex:]",  a5);
  }

  uint64_t v26 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  _CFAutoreleasePoolAddObject(),  0LL,  v21,  v20);
  objc_exception_throw(v26);
  -[NSMutableArray insertObjectsFromArray:range:atIndex:](v27, v28, v29, v32, v30);
}

    uint64_t v3 = *((void *)&v8 + 1);
    if (*((void *)&v8 + 1) < 2uLL)
    {
      if (*((void *)&v8 + 1) == 1LL) {
        __CFBasicHashRemoveValue(v4, v7);
      }
    }

    else
    {
      ++*(_WORD *)(v4 + 16);
      if (v3 <= 0x7FFFFFFFFFFFFFFELL)
      {
        int v6 = *(unsigned __int16 *)(v4 + 18);
        if ((v6 & 0x18) != 0) {
          __asm { BR              X12 }
        }
      }
    }

    return v3;
  }

  switch(v5)
  {
    case 3:
      ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
    case 2:
      ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
    case 1:
      ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
  }

  if (filesec_unset_property(self->_filesec, FILESEC_GRPUUID)) {
    BOOL v5 = 0;
  }
  if ((v3 & 0x20) != 0)
  {
LABEL_11:
    if (filesec_unset_property(self->_filesec, FILESEC_ACL)) {
      return 0;
    }
  }

  return v5;
}

    *a5 = v17;
    return v16;
  }

  return 0LL;
}

    int v6 = i;
    uint64_t v7 = _os_log_pack_size();
    uint64_t v8 = (char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v9 = _os_log_pack_fill();
    *(_DWORD *)int v9 = 136315394;
    *(void *)(v9 + 4) = "-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]";
    *(_WORD *)(v9 + 12) = 2048;
    *(void *)(v9 + 14) = v6;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: attempt to insert nil object from objects[%lu]",  "-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]",  v6);
    while (1)
    {
LABEL_21:
      size_t v10 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v8,  v7);
      objc_exception_throw(v10);
LABEL_22:
      int v11 = a5;
      uint64_t v7 = _os_log_pack_size();
      uint64_t v8 = (char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
LABEL_25:
      CFIndex v14 = _os_log_pack_fill();
      *(_DWORD *)CFIndex v14 = 136315394;
      *(void *)(v14 + 4) = "-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]";
      *(_WORD *)(v14 + 12) = 2048;
      *(void *)(v14 + 14) = v11;
      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: pointer to objects array is NULL but length is %lu",  "-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]",  v11);
    }
  }

uint64_t _CFAppendPathExtension2(__CFString *a1, CFStringRef theString)
{
  if (!a1
    || CFStringGetLength(theString) >= 1 && CFStringGetCharacterAtIndex(theString, 0LL) == 47
    || CFStringGetLength(theString) > 1 && _hasDrive(theString))
  {
    return 0LL;
  }

  BOOL v4 = CFStringGetLength(a1) >= 2 && _hasDrive(a1);
  while (1)
  {
    CFIndex Length = CFStringGetLength(a1);
    if (v4)
    {
      if (Length <= 3) {
        break;
      }
    }

    else if (Length < 2)
    {
      break;
    }

    CFIndex v6 = CFStringGetLength(a1);
    if (CFStringGetCharacterAtIndex(a1, v6 - 1) != 47) {
      break;
    }
    v11.CFIndex location = CFStringGetLength(a1) - 1;
    v11.size_t length = 1LL;
    CFStringDelete(a1, v11);
  }

  if (!CFStringGetLength(a1)) {
    return 0LL;
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0LL);
  CFIndex v8 = CFStringGetLength(a1);
  uint64_t v9 = 0LL;
  switch(v8)
  {
    case 0LL:
      return v9;
    case 1LL:
      uint64_t v9 = 0LL;
      if (CharacterAtIndex != 47 && CharacterAtIndex != 126) {
        goto LABEL_25;
      }
      return v9;
    case 2LL:
      goto LABEL_25;
    case 3LL:
      if (CFStringGetCharacterAtIndex(a1, 2LL) == 47 && _hasDrive(a1)) {
        return 0LL;
      }
      goto LABEL_25;
    default:
LABEL_25:
      if (v8 >= 1 && CharacterAtIndex == 126)
      {
        v12.CFIndex location = 1LL;
        v12.size_t length = v8 - 1;
        if (!CFStringFindWithOptions(a1, @"/", v12, 0LL, 0LL)) {
          return 0LL;
        }
      }

      uint64_t v9 = 1LL;
      CFStringAppendCharacters(a1, _CFAppendPathExtension2_dotChar, 1LL);
      CFStringAppend(a1, theString);
      break;
  }

  return v9;
}

uint64_t _CFAppendPathExtension( unsigned __int16 *a1, uint64_t *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  if (a5 + *a2 + 1 > a3) {
    return 0LL;
  }
  if (a5 >= 1)
  {
    int v9 = *a4;
  }

  _CFStripTrailingPathSlashes(a1, a2);
  uint64_t v11 = *a2;
  uint64_t result = 0LL;
  switch(*a2)
  {
    case 0LL:
      return result;
    case 1LL:
      uint64_t result = 0LL;
      int v12 = *a1;
      if (v12 != 47 && v12 != 126) {
        goto LABEL_29;
      }
      return result;
    case 2LL:
      int v13 = a1[1];
      int v14 = *a1;
      if (v13 == 58)
      {
        if ((v14 & 0xFFFFFFDF) - 65 < 0x1A) {
          return 0LL;
        }
        goto LABEL_22;
      }

      if (v14 != 92) {
        goto LABEL_22;
      }
      if (v13 == 92) {
        return 0LL;
      }
      goto LABEL_29;
    case 3LL:
      if (a1[2] == 47 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
        return 0LL;
      }
      goto LABEL_21;
    default:
      if (v11 < 1) {
        goto LABEL_29;
      }
LABEL_21:
      int v14 = *a1;
LABEL_22:
      if (v14 != 126) {
        goto LABEL_29;
      }
      uint64_t v15 = v11 - 1;
      BOOL v16 = a1 + 1;
      break;
  }

  while (1)
  {
    int v17 = *v16++;
    if (v17 == 47) {
      break;
    }
    if (!--v15) {
      return 0LL;
    }
  }

BOOL _CFTransmutePathSlashes(_WORD *a1, uint64_t *a2, __int16 a3)
{
  uint64_t v3 = *a2;
  if (*a2 >= 2 && *a1 == 92) {
    uint64_t v4 = 2LL * (a1[1] == 92);
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (v4 < v3)
  {
    uint64_t v5 = v4;
    while (1)
    {
      int v6 = (unsigned __int16)a1[v5];
      if (v6 == 47) {
        break;
      }
      uint64_t v9 = v5 + 1;
      a1[v4] = v6;
LABEL_16:
      ++v4;
      uint64_t v5 = v9;
      if (v9 >= v3) {
        goto LABEL_19;
      }
    }

    a1[v4] = a3;
    if (v3 <= v5 + 1) {
      uint64_t v7 = v5 + 1;
    }
    else {
      uint64_t v7 = v3;
    }
    uint64_t v8 = v7 - 1;
    while (v8 != v5)
    {
      uint64_t v9 = v5 + 1;
      int v10 = (unsigned __int16)a1[++v5];
      if (v10 != 47) {
        goto LABEL_16;
      }
    }

    ++v4;
  }

CFStringRef _CFCreateLastPathComponent(const __CFAllocator *a1, CFStringRef theString, void *a3)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v7 = Length - 2;
  if (Length >= 2)
  {
    uint64_t v9 = Length;
    uint64_t v10 = 0LL;
    while (v9 + v10 >= 1)
    {
      if (CFStringGetCharacterAtIndex(theString, --v10 + v9) == 47)
      {
        v11.CFIndex location = v9 + v10 + 1;
        if (a3) {
          *a3 = v9 + v10;
        }
        v11.size_t length = ~v10;
        int v12 = a1;
        int v13 = theString;
        return CFStringCreateWithSubstring(v12, v13, v11);
      }
    }

    if (v9 >= 3 && _hasDrive(theString))
    {
      if (a3) {
        *a3 = -1LL;
      }
      int v12 = a1;
      int v13 = theString;
      v11.CFIndex location = 2LL;
      v11.size_t length = v7;
      return CFStringCreateWithSubstring(v12, v13, v11);
    }
  }

  if (a3) {
    *a3 = -1LL;
  }
  return (CFStringRef)CFRetain(theString);
}

uint64_t _CFStartOfLastPathComponent(_WORD *a1, uint64_t a2)
{
  if (a2 < 2) {
    return 0LL;
  }
  uint64_t v2 = a2;
  do
  {
    uint64_t v3 = v2 - 1;
    if (v2 == 1) {
      break;
    }
    int v4 = (unsigned __int16)a1[v2-- - 2];
  }

  while (v4 != 47);
  if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
    return 2LL;
  }
  else {
    return 0LL;
  }
}

uint64_t _CFStartOfLastPathComponent2(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 2) {
    return 0LL;
  }
  uint64_t v4 = Length;
  CFIndex v5 = Length;
  do
  {
    CFIndex v3 = v5 - 1;
    if (v5 == 1) {
      break;
    }
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v5 - 2);
    CFIndex v5 = v3;
  }

  while (CharacterAtIndex != 47);
  if (v4 >= 3 && _hasDrive(a1)) {
    return 2LL;
  }
  else {
    return 0LL;
  }
}

uint64_t _CFLengthAfterDeletingLastPathComponent(unsigned __int16 *a1, uint64_t a2)
{
  if (a2 >= 2)
  {
    uint64_t v3 = a2;
    while (1)
    {
      uint64_t v4 = v3 - 1;
      if (v3 == 1) {
        break;
      }
      int v5 = a1[v3-- - 2];
      if (v5 == 47)
      {
        uint64_t result = v4 - 1;
        if (v4 == 1) {
          return v4;
        }
        if (a1[1] == 58)
        {
          unsigned int v7 = *a1;
          if (v7 - 65 >= 0x1A)
          {
            if (v7 >= 0x61 && v4 == 3 && v7 <= 0x7A) {
              return v4;
            }
          }

          else if (v4 == 3)
          {
            return v4;
          }
        }

        return result;
      }
    }

    if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
      return 2LL;
    }
  }

  return 0LL;
}

CFIndex _CFStartOfPathExtension2(const __CFString *a1)
{
  if (CFStringGetLength(a1) >= 2)
  {
    BOOL hasDrive = _hasDrive(a1);
    CFIndex v4 = CFStringGetLength(a1) - 1;
    while (v4)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v4);
      if (CharacterAtIndex == 47) {
        break;
      }
      --v4;
      if (CharacterAtIndex == 46)
      {
        if (hasDrive && v4 == 1) {
          return 0LL;
        }
        else {
          return v4 + 1;
        }
      }
    }
  }

  return 0LL;
}

uint64_t _CFStartOfPathExtension(_WORD *a1, uint64_t a2)
{
  if (a2 < 2) {
    return 0LL;
  }
  uint64_t v3 = &a1[a2 - 1];
  while (--a2)
  {
    if (*(v3 - 1) == 47) {
      return 0LL;
    }
    int v4 = *v3--;
    if (v4 == 46)
    {
      if (a2 == 2 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A) {
        return 0LL;
      }
      return a2;
    }
  }

  return a2;
}

uint64_t _CFLengthAfterDeletingPathExtension2(const __CFString *a1)
{
  uint64_t result = _CFStartOfPathExtension2(a1);
  if (result <= 0) {
    return CFStringGetLength(a1);
  }
  return result;
}

uint64_t _CFLengthAfterDeletingPathExtension(_WORD *a1, uint64_t a2)
{
  uint64_t result = _CFStartOfPathExtension(a1, a2);
  if (!result) {
    return a2;
  }
  return result;
}

DIR *_CFIterateDirectory(const __CFString *a1, int a2, const __CFArray *a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t result = (DIR *)CFStringGetFileSystemRepresentation(a1, buffer, 1026LL);
  if ((_DWORD)result)
  {
    uint64_t result = opendir(buffer);
    if (result)
    {
      uint64_t v8 = result;
      uint64_t v29 = a4;
      int v28 = a2;
      uint64_t v27 = result;
      while (1)
      {
        uint64_t v9 = readdir(v8);
        if (!v9) {
          return (DIR *)closedir(v8);
        }
        uint64_t v10 = v9;
        d_namleuint64_t n = v9->d_namlen;
        if (!v9->d_namlen || !v9->d_ino) {
          goto LABEL_44;
        }
        if (v9->d_name[0] != 46) {
          goto LABEL_14;
        }
        if (d_namlen != 1)
        {
          if (d_namlen == 2)
          {
            int v12 = v9->d_name[1];
            if (v12 == 46) {
              goto LABEL_44;
            }
          }

          else
          {
            int v12 = v9->d_name[1];
          }

          if (v12 != 95)
          {
LABEL_14:
            CFStringRef cf = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9->d_name);
            v33[0] = 0;
            if (a3)
            {
              if (CFArrayGetCount(a3) < 1)
              {
                uint64_t v13 = 0LL;
              }

              else
              {
                uint64_t v13 = 0LL;
                CFIndex v14 = 0LL;
                do
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, v14);
                  *(void *)__dst = 0LL;
                  CFIndex Length = CFStringGetLength(ValueAtIndex);
                  CFStringEncoding v17 = CFStringFileSystemEncoding();
                  v36.CFIndex location = 0LL;
                  v36.size_t length = Length;
                  v13 += CFStringGetBytes( ValueAtIndex,  v36,  v17,  0,  0,  (UInt8 *)&v33[v13],  1025 - v13,  (CFIndex *)__dst);
                  if (v13 >= 1)
                  {
                    uint64_t v18 = *(void *)__dst;
                    if (v13 >= *(uint64_t *)__dst)
                    {
                      if (v33[v13 - 1] != 47) {
                        v33[v13++] = 47;
                      }
                    }

                    else if (v33[*(void *)__dst - 1] != 47)
                    {
                      v33[*(void *)__dst] = 47;
                      uint64_t v13 = v18 + 1;
                    }
                  }

                  ++v14;
                }

                while (v14 < CFArrayGetCount(a3));
              }

              v33[v13] = 0;
              a4 = v29;
              a2 = v28;
              uint64_t v8 = v27;
            }

            if (a2
              && (v10->d_type == 4
               || !v10->d_type
               && (strncpy(__dst, buffer, 0x400uLL), __strlcat_chk(), __strlcat_chk(), !stat(__dst, &v32))
               && (v32.st_mode & 0xF000) == 0x4000))
            {
              __strlcat_chk();
            }

            else if (!a3)
            {
              CFStringRef v21 = cf;
              if (cf) {
                goto LABEL_40;
              }
              goto LABEL_44;
            }

            __strlcat_chk();
            CFStringRef v19 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v33);
            CFStringRef v20 = v19;
            CFStringRef v21 = cf;
            if (cf)
            {
              if (!v19)
              {
LABEL_40:
                stat v22 = (const __CFString *)CFRetain(v21);
                CFStringRef v21 = cf;
                CFStringRef v20 = v22;
              }

              uint64_t d_type = v10->d_type;
              CFStringRef v24 = v21;
              int v25 = (*(uint64_t (**)(uint64_t, CFStringRef, CFStringRef, uint64_t))(a4 + 16))( a4,  v21,  v20,  d_type);
              CFRelease(v24);
              CFRelease(v20);
              if (v25) {
                int v26 = 0;
              }
              else {
                int v26 = 3;
              }
              goto LABEL_45;
            }

            if (v19) {
              CFRelease(v19);
            }
          }
        }

unint64_t _cfmp_cleanup(unint64_t name)
{
  mach_port_name_t v1 = name;
  char v2 = BYTE5(name);
  uint64_t v3 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  if (((name >> 40) & 0x10) != 0)
  {
    name = mach_port_mod_refs(*MEMORY[0x1895FBBE0], name, 1u, -1);
    if ((v2 & 8) == 0)
    {
LABEL_3:
      if ((v2 & 0x20) == 0) {
        return name;
      }
      goto LABEL_7;
    }
  }

  else if ((name & 0x80000000000LL) == 0)
  {
    goto LABEL_3;
  }

  name = mach_port_deallocate(*v3, v1);
  if ((v2 & 0x20) == 0) {
    return name;
  }
LABEL_7:
  if ((v2 & 0x80) == 0)
  {
    if ((v2 & 0x40) == 0) {
      return name;
    }
    return mach_port_deallocate(*v3, v1);
  }

  name = mach_port_mod_refs(*v3, v1, 1u, -1);
  if ((v2 & 0x40) != 0) {
    return mach_port_deallocate(*v3, v1);
  }
  return name;
}

void _cfmp_record_deallocation(char a1, unsigned int a2, char a3, char a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    unsigned int v6 = a2;
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    uint64_t v8 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    unsigned int v16 = v6;
    char v17 = a1;
    char v18 = 0;
    CFTypeRef Value = CFSetGetValue(v8, &v16);
    if (Value)
    {
      char v10 = Value[5];
      if ((v10 & 4) == 0)
      {
        Value[5] = (16 * (a4 & 1)) | (8 * (a3 & 1)) | v10 & 0xE7 | 2;
        os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
        return;
      }

      unsigned int v6 = *(_DWORD *)Value;
      uint64_t v14 = Value[4];
      unsigned __int8 v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1)) | v10 & 0xE7;
      uint64_t v15 = *((unsigned __int16 *)Value + 3);
      CFSetRemoveValue(v8, Value);
      uint64_t v12 = v15 << 48;
      uint64_t v11 = v14 << 32;
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      unsigned __int8 v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1));
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
  }

void _cfmp_record_intent_to_invalidate(char a1, int a2)
{
  if (a2)
  {
    int v4 = calloc(1uLL, 8uLL);
    if (!v4) {
      _cfmp_record_intent_to_invalidate_cold_1();
    }
    int v5 = v4;
    *int v4 = a2;
    *((_BYTE *)v4 + 4) = a1;
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    unsigned int v6 = (__CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    if (CFSetGetValue(v6, v5))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      free(v5);
    }

    else
    {
      CFSetAddValue(v6, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    }
  }

void _cfmp_source_invalidated(int a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (_cfmp_records_oGuard != -1) {
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  }
  int v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  int v7 = a2;
  char v8 = a1;
  char v9 = 0;
  CFTypeRef Value = CFSetGetValue(v4, &v7);
  if (!Value)
  {
    _cfmp_log_failure((uint64_t)"not expecting invalidation", 0LL, a1, a2);
    goto LABEL_7;
  }

  if ((Value[5] & 2) == 0)
  {
    Value[5] |= 4u;
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    return;
  }

  unint64_t v6 = *(void *)Value;
  CFSetRemoveValue(v4, Value);
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  _cfmp_cleanup(v6);
}

uint64_t _cfmp_log_failure(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  BOOL v8 = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR);
  if (a2)
  {
    if (v8)
    {
      unsigned int v9 = *((unsigned __int8 *)a2 + 5);
      int v10 = *((unsigned __int8 *)a2 + 4);
      int v11 = *a2;
      int v13 = 136449283;
      uint64_t v14 = a1;
      __int16 v15 = 1025;
      int v16 = v11;
      __int16 v17 = 1024;
      int v18 = v10;
      __int16 v19 = 1024;
      int v20 = v9 & 1;
      __int16 v21 = 1024;
      int v22 = (v9 >> 2) & 1;
      __int16 v23 = 1024;
      int v24 = (v9 >> 1) & 1;
      __int16 v25 = 1024;
      int v26 = (v9 >> 3) & 1;
      __int16 v27 = 1024;
      int v28 = (v9 >> 4) & 1;
      __int16 v29 = 1024;
      int v30 = (v9 >> 5) & 1;
      __int16 v31 = 1024;
      int v32 = (v9 >> 6) & 1;
      __int16 v33 = 1024;
      unsigned int v34 = v9 >> 7;
      __int16 v35 = 1024;
      int v36 = a3;
      __int16 v37 = 1024;
      int v38 = a4;
      _os_log_error_impl( &dword_180A4C000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_ERROR,  "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {p:%{private}d c:%d is:%d <i:%d,d:%d> s:%d,r :%d nsi:%d,nss:%d,nsr:%d - ic:%d,ip:%d}",  (uint8_t *)&v13,  0x54u);
    }
  }

  else if (v8)
  {
    _cfmp_log_failure_cold_1(a1, a3, a4);
  }

  return _CFMachPortDeallocationFailure();
}

void _cfmp_source_record_deadness(int a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (_cfmp_records_oGuard != -1) {
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  }
  int v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  int v6 = a2;
  char v7 = a1;
  char v8 = 0;
  CFTypeRef Value = CFSetGetValue(v4, &v6);
  if (Value) {
    Value[5] &= ~0x10u;
  }
  else {
    _cfmp_log_failure((uint64_t)"received deadname notification for untracked port", 0LL, a1, a2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
}

void _cfmp_record_nsmachport_is_interested(char a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (_cfmp_records_oGuard != -1) {
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    }
    int v4 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    int v6 = a2;
    char v7 = a1;
    char v8 = 0;
    CFTypeRef Value = CFSetGetValue(v4, &v6);
    if (Value) {
      Value[5] |= 0x20u;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  }

void _cfmp_record_nsmachport_deallocation(int a1, unsigned int a2, int a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    char v4 = a4;
    char v5 = a3;
    if (a4 | a3)
    {
      unsigned int v6 = a2;
      if (_cfmp_records_oGuard != -1) {
        dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
      }
      char v8 = (const __CFSet *)_cfmp_records_oRecords;
      os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
      unsigned int v16 = v6;
      char v17 = a1;
      char v18 = 0;
      CFTypeRef Value = (int *)CFSetGetValue(v8, &v16);
      if (Value)
      {
        char v10 = *((_BYTE *)Value + 5);
        if ((v10 & 0x20) == 0)
        {
          _cfmp_log_failure((uint64_t)"setting nsport state - when its not interested", Value, a1, v6);
LABEL_11:
          os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
          return;
        }

        if ((*((_BYTE *)Value + 5) & 4) == 0)
        {
          *((_BYTE *)Value + 5) = ((v5 & 1) << 6) | v10 & 0x3F | (v4 << 7) | 2;
          goto LABEL_11;
        }

        unsigned int v6 = *Value;
        uint64_t v14 = *((unsigned __int8 *)Value + 4);
        unsigned __int8 v13 = v10 & 0x3F | ((v5 & 1) << 6) | (v4 << 7);
        uint64_t v15 = *((unsigned __int16 *)Value + 3);
        CFSetRemoveValue(v8, Value);
        uint64_t v12 = v15 << 48;
        uint64_t v11 = v14 << 32;
      }

      else
      {
        uint64_t v11 = 0LL;
        uint64_t v12 = 0LL;
        unsigned __int8 v13 = (v4 << 7) | ((v5 & 1) << 6) | 0x20;
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
    }
  }

CFMutableSetRef ___cfmp_records_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  CFSetCallBacks v1 = *(CFSetCallBacks *)byte_189996B00;
  CFMutableSetRef result = CFSetCreateMutable(0LL, 16LL, &v1);
  _cfmp_records_oRecords = (uint64_t)result;
  return result;
}

uint64_t _cfmp_deallocation_record_retain(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 5) & 1) != 0) {
    _cfmp_deallocation_record_retain_cold_1();
  }
  *(_BYTE *)(a2 + 5) |= 1u;
  return a2;
}

void _cfmp_deallocation_record_release(int a1, int *a2)
{
  if ((*((_BYTE *)a2 + 5) & 1) == 0) {
    _cfmp_log_failure((uint64_t)"Freeing a record not in the set", a2, *((unsigned __int8 *)a2 + 4), *a2);
  }
  free(a2);
}

CFStringRef _cfmp_copy_description(unsigned int *a1)
{
  if (!a1) {
    return @"{null}";
  }
  unsigned int v1 = *((unsigned __int8 *)a1 + 5);
  return CFStringCreateWithFormat( 0LL,  0LL,  @"{p:%d c:%d is:%d <i:%d,d:%d> s:%d,r:%d nsi:%d,nss:%d,nsr:%d}",  *a1,  *((unsigned __int8 *)a1 + 4),  v1 & 1,  (v1 >> 2) & 1,  (v1 >> 1) & 1,  (v1 >> 3) & 1,  (v1 >> 4) & 1,  (v1 >> 5) & 1,  (v1 >> 6) & 1,  v1 >> 7);
}

BOOL _cfmp_equal(int *a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1 && a2)
  {
    int v4 = *a1;
    int v5 = *((unsigned __int8 *)a1 + 4);
    return v4 == *(_DWORD *)a2 && v5 == *(unsigned __int8 *)(a2 + 4);
  }

  return result;
}

uint64_t _cfmp_hash(uint64_t result)
{
  if (result) {
    return 2654435761LL * (*(unsigned __int8 *)(result + 4) | (*(_DWORD *)result << 8));
  }
  return result;
}

void __NSSingleEntryDictionaryI_new(unint64_t a1, unint64_t a2, char a3)
{
  v22[1] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v11 = _os_log_pack_size();
    unsigned __int8 v13 = (char *)v22 - ((MEMORY[0x1895F8858](v11, v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v14 = 136315138;
    *(void *)(v14 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: key cannot be nil",  "__NSSingleEntryDictionaryI_new");
    uint64_t v15 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v13,  v11);
    objc_exception_throw(v15);
LABEL_17:
    __break(1u);
    return;
  }

  if (!a2)
  {
    uint64_t v16 = _os_log_pack_size();
    char v18 = (char *)v22 - ((MEMORY[0x1895F8858](v16, v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v19 = 136315138;
    *(void *)(v19 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: object cannot be nil",  "__NSSingleEntryDictionaryI_new");
    int v20 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL,  v18,  v16);
    objc_exception_throw(v20);
    goto LABEL_17;
  }

  unsigned int v6 = (objc_class *)objc_opt_self();
  uint64_t v7 = __CFAllocateObject(v6, 0LL);
  if (!v7) {
    return;
  }
  if ((a3 & 1) == 0)
  {
    if ((a3 & 8) == 0 && (a1 & 0x8000000000000000LL) == 0) {
      id v8 = (id)a1;
    }
    *(void *)(v7 + 16) = a1;
    goto LABEL_10;
  }

  uint64_t v9 = [(id)a1 copyWithZone:0];
  *(void *)(v7 + 16) = v9;
  if (!v9)
  {
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSDictionary: -copyWithZone: for key %@ returned nil",  a1);
    __int16 v21 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
    objc_exception_throw(v21);
    goto LABEL_17;
  }

void sub_180A9ED24()
{
}

uint64_t (**__CFStringEncodingGetLatinSuppConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_1)
  {
    __CFStringEncodingPrecomposeLatinCharacter_1 = (_UNKNOWN *)a2(4LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_0 = (_UNKNOWN *)a2(3LL);
  }

  if (a1 > 1029)
  {
    if (a1 > 1286)
    {
      switch(a1)
      {
        case 1287:
          return __CFConverterWindowsBalticRim;
        case 2564:
          return __CFConverterMacRomanLatin1;
        case 2817:
          return __CFConverterNextStepLatin_0;
      }
    }

    else
    {
      switch(a1)
      {
        case 1030:
          return __CFConverterDOSBalticRim;
        case 1040:
          return __CFConverterDOSLatin1;
        case 1046:
          return __CFConverterDOSIcelandic;
      }
    }

    return 0LL;
  }

  BOOL result = __CFConverterISOLatin6;
  switch(a1)
  {
    case 522:
      return result;
    case 523:
    case 524:
      return 0LL;
    case 525:
      return __CFConverterISOLatin7;
    case 526:
      return __CFConverterISOLatin8;
    case 527:
      return __CFConverterISOLatin9;
    default:
      if (a1 == 37)
      {
        BOOL result = __CFConverterMacIcelandic;
      }

      else
      {
        if (a1 != 1024) {
          return 0LL;
        }
        BOOL result = __CFConverterDOSLatinUS;
      }

      break;
  }

  return result;
}

uint64_t __CFToISOLatin6(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8214 < 0xFFFFE091) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&ISOLatin6_from_uni;
  unsigned int v6 = (unsigned __int16 *)&unk_180C33CCE;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    id v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    unsigned int v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromISOLatin6(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin6_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin6Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8214) >= 0xE091u)
    {
      uint64_t v11 = (unsigned __int16 *)&ISOLatin6_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180C33CCE;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFIsValidCombiningCharacterForLatinSupp(int a1)
{
  else {
    return (__CFLatinSuppCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToISOLatin7(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  uint64_t result = 0LL;
  if (a2 != 161 && a2 <= 0x201E)
  {
    int v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
    unsigned int v6 = (unsigned __int16 *)&unk_180C33F14;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      id v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1LL;
        }

        int v5 = v8 + 2;
      }

      else
      {
        unsigned int v6 = v8 - 2;
      }

      if (v5 > v6) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t __CFFromISOLatin7(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin7_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin7Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0xA0)
  {
    if (v9 != 161 && v9 <= 0x201E)
    {
      uint64_t v12 = (unsigned __int16 *)&ISOLatin7_from_uni;
      uint64_t v13 = (unsigned __int16 *)&unk_180C33F14;
      while (1)
      {
        uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
        unsigned int v15 = &v12[2 * v14];
        unsigned int v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }

          uint64_t v12 = v15 + 2;
        }

        else
        {
          uint64_t v13 = v15 - 2;
        }

        if (v12 > v13) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToISOLatin8(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 7924 < 0xFFFFE1AF) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&ISOLatin8_from_uni;
  unsigned int v6 = (unsigned __int16 *)&unk_180C3414E;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    id v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    unsigned int v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromISOLatin8(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    LOWORD(a2) = ISOLatin8_to_uni[a2 - 161];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin8Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 7924) >= 0xE1AFu)
    {
      uint64_t v11 = (unsigned __int16 *)&ISOLatin8_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180C3414E;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToISOLatin9(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA3)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  uint64_t result = 0LL;
  if (a2 != 164 && a2 <= 0x20AC)
  {
    int v5 = (unsigned __int16 *)&ISOLatin9_from_uni;
    unsigned int v6 = (unsigned __int16 *)&unk_180C3437C;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      id v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1LL;
        }

        int v5 = v8 + 2;
      }

      else
      {
        unsigned int v6 = v8 - 2;
      }

      if (v5 > v6) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t __CFFromISOLatin9(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA3) {
    LOWORD(a2) = ISOLatin9_to_uni[a2 - 164];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin9Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0xA3)
  {
    if (v9 != 164 && v9 <= 0x20AC)
    {
      uint64_t v12 = (unsigned __int16 *)&ISOLatin9_from_uni;
      uint64_t v13 = (unsigned __int16 *)&unk_180C3437C;
      while (1)
      {
        uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
        unsigned int v15 = &v12[2 * v14];
        unsigned int v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }

          uint64_t v12 = v15 + 2;
        }

        else
        {
          uint64_t v13 = v15 - 2;
        }

        if (v12 > v13) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToMacIcelandic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      int v4 = (unsigned __int16 *)&MacIcelandic_from_uni;
      int v5 = (unsigned __int16 *)&unk_180C34634;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          int v4 = v7 + 2;
        }

        else
        {
          int v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

uint64_t __CFFromMacIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = MacIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToMacIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0LL;
    }
    goto LABEL_3;
  }

  uint64_t v12 = (unsigned __int16 *)&MacIcelandic_from_uni;
  uint64_t v13 = (unsigned __int16 *)&unk_180C34634;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    uint64_t v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0LL;
    }
  }

  if (v16 < v9)
  {
    uint64_t v12 = v15 + 2;
    goto LABEL_12;
  }

  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0LL;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFToWindowsBalticRim(uint64_t a1, unsigned int a2, char *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 < 0xA8)
  {
LABEL_12:
    if (a2 < 0xA0) {
      return 0LL;
    }
  }

  else if (a2 <= 0x2122)
  {
    int v5 = (unsigned __int16 *)&WindowsBalticRim_from_uni;
    uint64_t v6 = (unsigned __int16 *)&unk_180C34794;
    while (1)
    {
      uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
      unsigned int v8 = &v5[2 * v7];
      unsigned int v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
LABEL_29:
          char v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1LL;
        }

        int v5 = v8 + 2;
      }

      else
      {
        uint64_t v6 = v8 - 2;
      }

      if (v5 > v6) {
        goto LABEL_12;
      }
    }
  }

  uint64_t result = 0LL;
  if ((a2 - 161 > 0x13 || ((1 << (a2 + 95)) & 0x80011) == 0) && a2 != 255)
  {
    if (a2 < 0xA1)
    {
      char v3 = -96;
      goto LABEL_3;
    }

    uint64_t result = 0LL;
    if (a2 != 161 && a2 <= 0x201E)
    {
      int v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
      int v10 = (unsigned __int16 *)&unk_180C33F14;
      do
      {
        uint64_t v7 = ((char *)v10 - (char *)v5) >> 3;
        uint64_t v11 = &v5[2 * v7];
        unsigned int v12 = *v11;
        if (v12 <= a2)
        {
          if (v12 >= a2) {
            goto LABEL_29;
          }
          int v5 = v11 + 2;
        }

        else
        {
          int v10 = v11 - 2;
        }

        uint64_t result = 0LL;
      }

      while (v5 <= v10);
    }
  }

  return result;
}

uint64_t __CFFromWindowsBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) == 0) {
    goto LABEL_2;
  }
  if (a2 >= 0xA0)
  {
    *a3 = -3;
  }

  else
  {
    *a3 = WindowsBalticRim_to_uni[a2 - 128];
    if (((0x9501150AuLL >> a2) & 1) == 0) {
      return 1LL;
    }
  }

  if (a2 > 179)
  {
    if (a2 != 180)
    {
      if (a2 != 255)
      {
LABEL_16:
        goto LABEL_2;
      }

      LOWORD(a2) = 729;
    }

uint64_t __CFToWindowsBalticRimPrecompose( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  int v10 = __CFToWindowsBalticRim(v9, v9, &v13);
  uint64_t result = 0LL;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFToNextStepLatin_0(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      int v4 = (unsigned __int16 *)&nextstep_from_tab_0;
      int v5 = (unsigned __int16 *)&unk_180C349D4;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          int v4 = v7 + 2;
        }

        else
        {
          int v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

BOOL __CFFromNextStepLatin_0(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = NSToPrecompUnicodeTable_0[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToNextStepLatinPrecompose_0( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0LL;
    }
    goto LABEL_3;
  }

  BOOL v12 = (unsigned __int16 *)&nextstep_from_tab_0;
  char v13 = (unsigned __int16 *)&unk_180C349D4;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0LL;
    }
  }

  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }

  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0LL;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFStringEncodingIsValidCombiningCharacterForLatin1Wrapper()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_0();
}

uint64_t __CFToMacRomanLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      int v4 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
      int v5 = (unsigned __int16 *)&unk_180C34CDC;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          int v4 = v7 + 2;
        }

        else
        {
          int v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

BOOL __CFFromMacRomanLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = MacRomanLatin1_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanLatin1Precompose( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 <= 0x7F)
  {
    LOBYTE(v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v9;
    if (!(_BYTE)v9) {
      return 0LL;
    }
    goto LABEL_3;
  }

  BOOL v12 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
  char v13 = (unsigned __int16 *)&unk_180C34CDC;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    char v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0LL;
    }
  }

  if (v16 < v9)
  {
    BOOL v12 = v15 + 2;
    goto LABEL_12;
  }

  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0LL;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFToDOSLatinUS(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&DOSLatinUS_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C34FDC;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSLatinUS(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSLatinUS_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatinUSPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSLatinUS_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C34FDC;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToDOSLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&DOSLatin1_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C352DC;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSLatin1_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin1Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSLatin1_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C352DC;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToDOSBalticRim(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&DOSBalticRim_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C355DC;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSBalticRimPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSBalticRim_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C355DC;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToDOSIcelandic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  int v5 = (unsigned __int16 *)&DOSIcelandic_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180C357DC;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSIcelandic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      uint64_t v11 = (unsigned __int16 *)&DOSIcelandic_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180C357DC;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          uint64_t v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString( CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  for (uint64_t i = &buffer; ; uint64_t i = (uint64_t *)((char *)i + 1))
  {
    if (!*(_BYTE *)i)
    {
      v26[0] = 0;
      goto LABEL_14;
    }

    if (*(_BYTE *)i == 64) {
      break;
    }
  }

  v26[0] = 64;
  *(_BYTE *)uint64_t i = 0;
  int v5 = v26;
  uint64_t v6 = 1LL;
  do
  {
    int v7 = *((unsigned __int8 *)i + v6);
    if (v7 != 32)
    {
      *++int v5 = v7;
      int v7 = *((unsigned __int8 *)i + v6);
    }

    ++v6;
  }

  while (v7);
LABEL_14:
  __key[0] = &buffer;
  __key[1] = 0LL;
  if (buffer == 0x4F484141535F6161LL
    || (buffer == 0x414D4B4F425F6F6ELL ? (BOOL v8 = v28 == 76) : (BOOL v8 = 0),
        v8
     || (buffer == 0x524F4E594E5F6F6ELL ? (BOOL v9 = v28 == 19283) : (BOOL v9 = 0),
         v9
      || bsearch( __key,  oldAppleLocaleToCanonical,  0xB8uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))))
  {
    __strlcpy_chk();
    v25[0] = 0;
  }

  else
  {
    int v22 = 0LL;
    __int16 v23 = 0LL;
    _UpdateFullLocaleString((const char *)&buffer, &v23, &v22, v25);
    if (v23 && v22) {
      *int v22 = 0;
    }
  }

  __key[0] = &buffer;
  int v10 = (char **)bsearch( __key,  localeStringPrefixToDefaults,  0xB7uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
  if (v10) {
    _RemoveSubstringsIfPresent((char *)&buffer, v10[1]);
  }
  __key[0] = &buffer;
  if (bsearch( __key,  appleLocaleToLanguageString,  6uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    __strlcpy_chk();
  }

  else
  {
    p_uint64_t buffer = (char *)&buffer;
    for (uint64_t j = (char *)&buffer; *j; ++j)
    {
      if (*j == 95)
      {
        uint64_t v14 = j + 1;
        unsigned int v13 = j[1];
        uint64_t v15 = MEMORY[0x1895F8770];
        if ((v13 & 0x80000000) != 0)
        {
          if (__maskrune(j[1], 0x100uLL)) {
            goto LABEL_35;
          }
        }

        else if ((*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v13 + 60) & 0x100) != 0)
        {
LABEL_35:
          uint64_t v16 = 3LL;
          do
          {
            unsigned int v18 = *++v14;
            unsigned int v17 = v18;
            if ((v18 & 0x80000000) != 0) {
              int v19 = __maskrune(v17, 0x100uLL);
            }
            else {
              int v19 = *(_DWORD *)(v15 + 4LL * v17 + 60) & 0x100;
            }
          }

          while (v19);
          goto LABEL_50;
        }

        if (v13 - 48 > 9)
        {
          uint64_t v16 = 0LL;
        }

        else
        {
          uint64_t v16 = 4LL;
          do
            int v20 = *++v14;
          while ((v20 - 48) < 0xA);
        }

uint64_t _CompareTestEntryToTableEntryKey(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

unint64_t _UpdateFullLocaleString(const char *a1, char **a2, char **a3, _BYTE *a4)
{
  void __key[2] = *MEMORY[0x1895F89C0];
  __key[0] = a1;
  int v5 = (const char **)bsearch( __key,  localeStringPrefixToCanonical,  0x131uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareLowerTestEntryPrefixToTableEntryKey);
  if (!v5) {
    goto LABEL_15;
  }
  uint64_t v6 = v5;
  int v7 = strlen(*v5);
  BOOL v8 = v6[1];
  int v9 = strlen(v8);
  uint64_t v10 = (v9 - v7);
  if (v9 - v7 < 0)
  {
    unsigned int v13 = (char *)&a1[v9];
    do
    {
      int v14 = v13[v7 - v9];
      *v13++ = v14;
    }

    while (v14);
LABEL_11:
    if (v8)
    {
      char v15 = *v8;
      if (*v8)
      {
        uint64_t v16 = (unsigned __int8 *)(v8 + 1);
        unsigned int v17 = (char *)a1;
        do
        {
          *v17++ = v15;
          int v18 = *v16++;
          char v15 = v18;
        }

        while (v18);
      }
    }

    goto LABEL_15;
  }

  if (v9 == v7) {
    goto LABEL_11;
  }
  int v11 = strlen(a1);
  if ((int)v10 + v11 <= 256)
  {
    if (v11 >= (uint64_t)v7)
    {
      BOOL v12 = &a1[v11];
      do
      {
        v12[v10] = *v12;
        --v12;
      }

      while (v12 >= &a1[v7]);
    }

    goto LABEL_11;
  }

LABEL_107:
    uint64_t v40 = (const char *)v39[6];
    v39 += 5;
    if (v40) {
      continue;
    }
    break;
  }

  if (a2) {
    *a2 = v71;
  }
  if (a3) {
    *a3 = v70;
  }
  return result;
}

                          Context = __cficu_unum_getAttribute(v31, v32);
                          goto LABEL_4;
                        }

                        int v23 = *((void *)formatter + 2);
                        uint64_t v24 = 16;
LABEL_76:
                        __int16 v25 = __cficu_unum_getAttribute(v23, v24);
                        int v26 = (CFTypeRef *)&kCFBooleanTrue;
                        unsigned int v27 = v25 == 0;
LABEL_77:
                        if (v27) {
                          int v26 = (CFTypeRef *)&kCFBooleanFalse;
                        }
                        unint64_t result = *v26;
                        return CFRetain(result);
                      }

                      int v21 = *((void *)formatter + 2);
                      int v22 = 17;
                    }

                    goto LABEL_91;
                  }

                  int v33 = *((void *)formatter + 2);
                  int v34 = 3;
                }

    ++v12;
    goto LABEL_108;
  }

  if (v18 == 166 && (v23 + 39) <= 0x1Cu)
  {
    int v33 = v23 - 217;
    int v34 = 0x418007FuLL >> v33;
    __int16 v35 = ((a1 & 0x200) == 0) & (0x418007FuLL >> v33);
    if (v35) {
      int v36 = 2LL;
    }
    else {
      int v36 = 1LL;
    }
    v12 += v36;
    if (!a5) {
      goto LABEL_108;
    }
    if (v12 <= a5)
    {
      int v37 = __CFFromMacSimplifiedChineseMapA6[v33];
      uint64_t v38 = HIWORD(v37);
      if ((v34 & 1) == 0) {
        LOWORD(v3_Block_object_dispose((const void *)(v28 - 104), 8) = v37;
      }
      *a4 = v38;
      if ((v35 & 1) != 0)
      {
        a4[1] = v37;
        a4 += 2;
      }

      else
      {
        ++a4;
      }

    BOOL v12 = 0;
LABEL_108:
    ++a2;
LABEL_109:
    uint64_t v10 = v30;
    goto LABEL_110;
  }

  if ((unsigned __int16)(v13 - 4447) <= 1u)
  {
    ++a2;
LABEL_94:
    BOOL v12 = v164;
    goto LABEL_110;
  }

  if ((a1 & 8) != 0) {
    goto LABEL_452;
  }
  if ((a1 & 0x10) == 0)
  {
    uint64_t v16 = v11;
    goto LABEL_94;
  }

  unsigned int v49 = v13 == 63584 || (unsigned __int16)(v13 + 1945) < 3u;
  if (v22 < 3 || !v49)
  {
    if (v22 > 3 && v13 == 63585)
    {
      int v53 = a2[1];
      if (v53 == 40)
      {
        CFTypeID v74 = a2[2];
        unint64_t v75 = v74 - 65;
        if (v74 - 65 > 0x19 || a2[3] != 41) {
          goto LABEL_452;
        }
        if (v74 >= 0x56) {
          int v76 = 108;
        }
        else {
          int v76 = 105;
        }
        CFRange v55 = v75 + v76;
        char v54 = -93;
      }

      else
      {
        if (v53 != 8224 || a2[2] != 8224 || a2[3] != 8224) {
          goto LABEL_452;
        }
        char v54 = -90;
        CFRange v55 = 70;
      }

      int v30 = v10 + 2;
      if (a5)
      {
        if (v30 > a5) {
          goto LABEL_452;
        }
        *a4 = v54;
        a4[1] = v55;
        a4 += 2;
      }

      BOOL v12 = 0;
      a2 += 4;
      uint64_t v16 = v11 + 4;
      goto LABEL_109;
    }

    if (v22 >= 5 && (unsigned __int16)(v13 + 1950) <= 4u)
    {
      Boolean v56 = a2[1];
      if (v56 == 91)
      {
        uint64_t v77 = a2[2];
        if (v77 == 50)
        {
          if (a2[3] == 48 && a2[4] == 93)
          {
            unint64_t v79 = v13 - 98;
            if ((unsigned __int16)(v13 + 1950) < 5u)
            {
              unsigned int v43 = 0xF66854F954uLL >> (8 * v79);
              CFIndex v42 = 0xACA4A3A2A4uLL >> (8 * v79);
            }

            goto LABEL_399;
          }
        }

        else if (v77 == 49)
        {
          CFTypeID v78 = a2[3];
          if (v78 - 48 <= 9 && a2[4] == 93)
          {
            switch(v13)
            {
              case 0xF862u:
                LOBYTE(v43) = v78 + 26;
                goto LABEL_394;
              case 0xF863u:
                LOBYTE(v43) = v78 - 65;
                LOBYTE(v42) = -94;
                break;
              case 0xF864u:
                LOBYTE(v43) = v78 + 26;
                LOBYTE(v42) = -93;
                break;
              case 0xF865u:
                LOBYTE(v43) = v78 + 46;
LABEL_394:
                LOBYTE(v42) = -92;
                break;
              case 0xF866u:
                if (v78 >= 0x36) {
                  CFIndex v137 = -20;
                }
                else {
                  CFIndex v137 = -53;
                }
                LOBYTE(v43) = v78 - 48 + v137;
                LOBYTE(v42) = -84;
                break;
              default:
                goto LABEL_399;
            }

            goto LABEL_399;
          }
        }
      }

      else if (v56 == 51452 && a2[2] == 49885 && a2[3] == 54924 && a2[4] == 49324)
      {
        if (v13 == 63587)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = -127;
        }

        else if (v13 == 63586)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = 125;
        }

        goto LABEL_399;
      }

      if (v13 > 0xF864) {
        goto LABEL_452;
      }
      if (v56 != 40)
      {
        if (v13 > 0xF863 || v56 != 91 || a2[4] != 93) {
          goto LABEL_452;
        }
        int v82 = a2[2];
        if (v82 == 21313)
        {
          unint64_t v87 = a2[3] | (v13 << 16);
          if (v87 + 127707428 < 0xFFFEF724) {
            goto LABEL_452;
          }
          uint64_t v88 = (unsigned int *)&MacKorean_from_uni_0xF862_3;
          int v89 = (unsigned int *)&unk_180CA08E8;
          while (1)
          {
            unint64_t v90 = ((char *)v89 - (char *)v88) >> 4;
            unint64_t v91 = &v88[2 * v90];
            if (*v91 <= v87)
            {
              if (*v91 >= v87)
              {
                LODWORD(v43) = LOWORD(v88[2 * v90 + 1]);
                LODWORD(v42) = v43 >> 8;
                goto LABEL_399;
              }

              uint64_t v88 = v91 + 2;
            }

            else
            {
              int v89 = v91 - 2;
            }

            if (v88 > v89) {
              goto LABEL_452;
            }
          }
        }

        if (v82 != 20108 || a2[3] != 21313) {
          goto LABEL_452;
        }
        if (v13 == 63586) {
          LOBYTE(v43) = 104;
        }
        else {
          LOBYTE(v43) = 84;
        }
        LOBYTE(v42) = -83;
        goto LABEL_399;
      }

      int64_t v80 = a2[2];
      if (v80 != 50)
      {
        if (v80 != 51 || a2[3] != 48 || a2[4] != 41) {
          goto LABEL_452;
        }
        uint64_t v81 = v13 - 98;
        if ((unsigned __int16)(v13 + 1950) < 3u)
        {
          LODWORD(v43) = 0xFCFEFAu >> (8 * v81);
          LODWORD(v42) = 0xA5A7ABu >> (8 * v81);
        }

        goto LABEL_399;
      }

      CFTypeID v83 = a2[3];
      uint64_t v84 = v83 - 49;
      if (v83 - 49 > 8 || a2[4] != 41) {
        goto LABEL_452;
      }
      switch(v13)
      {
        case 0xF864u:
          CFTypeRef v85 = v83 >= 0x37;
          LOWORD(v42) = -23053;
          uint64_t v86 = -22791;
          break;
        case 0xF863u:
          LOBYTE(v43) = v83 - 60;
          LOBYTE(v42) = -89;
LABEL_399:
          if (a5)
          {
            if (v10 + 2 > a5) {
              goto LABEL_452;
            }
            *a4 = v42;
            a4[1] = v43;
            a4 += 2;
          }

          BOOL v12 = 0;
          a2 += 5;
          uint64_t v16 = v11 + 5;
          v10 += 2LL;
          goto LABEL_110;
        case 0xF862u:
          CFTypeRef v85 = v83 >= 0x37;
          LOWORD(v42) = -21519;
          uint64_t v86 = -21767;
          break;
        default:
          goto LABEL_399;
      }

      if (!v85) {
        LOWORD(v42) = v86;
      }
      LOBYTE(v43) = v84 + v42;
      LOBYTE(v42) = (unsigned __int16)(v84 + v42) >> 8;
      goto LABEL_399;
    }

    if (v22 > 1)
    {
      CFTypeID v64 = a2[1];
      int v65 = v64 & 0xFFF0;
      int v66 = v64 | (v13 << 16);
      if (v65 == 63600 && v66 + 12584832 >= 0xE1FFF7)
      {
        unint64_t v67 = (unsigned int *)&MacKorean_from_uni_0xF870;
        int v68 = (unsigned int *)&unk_180CA14E0;
        do
        {
          CFTypeID v69 = ((char *)v68 - (char *)v67) >> 4;
          unint64_t v70 = &v67[2 * v69];
          if (*v70 <= v66)
          {
            if (*v70 >= v66)
            {
LABEL_247:
              int v30 = v10 + 2;
              if (a5)
              {
                if (v30 > a5) {
                  goto LABEL_452;
                }
                *(_WORD *)a4 = __rev16(LOWORD(v67[2 * v69 + 1]));
                a4 += 2;
              }

              BOOL v12 = 0;
              a2 += 2;
              uint64_t v16 = v11 + 2;
              goto LABEL_109;
            }

            unint64_t v67 = v70 + 2;
          }

          else
          {
            int v68 = v70 - 2;
          }
        }

        while (v67 <= v68);
      }

      if (v66 - 721224520 >= 0xFAB71D9C)
      {
        unint64_t v67 = (unsigned int *)&MacKorean_from_uni_other_two_char;
        int v71 = (unsigned int *)&unk_180CA1500;
        do
        {
          CFTypeID v69 = ((char *)v71 - (char *)v67) >> 4;
          unint64_t v72 = &v67[2 * v69];
          if (*v72 <= v66)
          {
            if (*v72 >= v66) {
              goto LABEL_247;
            }
            unint64_t v67 = v72 + 2;
          }

          else
          {
            int v71 = v72 - 2;
          }
        }

        while (v67 <= v71);
      }
    }

    if (v11 < 1) {
      goto LABEL_452;
    }
    uint64_t v163 = a6;
    if ((int)v13 > 823)
    {
      if (v13 - 12441 >= 2)
      {
        if (v13 != 824)
        {
          if (v13 == 839)
          {
            if (*(a2 - 1) != 8741) {
              goto LABEL_309;
            }
            if (a5)
            {
              unint64_t v73 = -24924;
              goto LABEL_209;
            }

uint64_t _CompareTestEntryPrefixToTableEntryKey(void *a1, _BYTE **a2)
{
  int v2 = *(unsigned __int8 *)*a1;
  int v3 = **a2;
  BOOL v4 = **a2 == 0;
  if (v2 == v3 && v3 != 0)
  {
    uint64_t v6 = *a2 + 1;
    int v7 = (unsigned __int8 *)(*a1 + 1LL);
    do
    {
      int v8 = *v7++;
      int v2 = v8;
      int v9 = *v6++;
      int v3 = v9;
      BOOL v4 = v9 == 0;
    }

    while (v2 == v9 && v3 != 0);
  }

  else {
    unsigned int v11 = 1;
  }
  if (v4) {
    return 0LL;
  }
  else {
    return v11;
  }
}

char *_RemoveSubstringsIfPresent(char *__big, char *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  char v2 = *a2;
  if (!*a2) {
    return __big;
  }
  int v3 = a2;
  BOOL v4 = __big;
  uint64_t v5 = MEMORY[0x1895F8770];
  do
  {
    int v6 = 0;
    uint64_t v7 = 0LL;
    int v8 = v3 - 1;
    while ((v2 & 0x80) == 0)
    {
LABEL_8:
      __little[v7] = v2;
      int v9 = &v3[v7++];
      char v2 = v9[1];
      ++v8;
      ++v6;
    }

    if (__maskrune(v2, 0x800uLL)) {
      goto LABEL_8;
    }
LABEL_9:
    int v3 = v8;
    do
    {
      unsigned int v10 = v3[1];
      if ((v10 & 0x80000000) != 0) {
        __big = (char *)__maskrune(v10, 0x4000uLL);
      }
      else {
        __big = (char *)(*(_DWORD *)(v5 + 4LL * v10 + 60) & 0x4000);
      }
      ++v3;
    }

    while ((_DWORD)__big);
    if ((_DWORD)v7)
    {
      __little[v7] = 0;
      __big = strstr(v4, __little);
      if (__big)
      {
        do
        {
          int v11 = __big[v6];
          *__big++ = v11;
        }

        while (v11);
      }
    }

    char v2 = *v3;
  }

  while (*v3);
  return __big;
}

void _AppendKeyValueString(uint64_t a1, _BYTE *a2)
{
  if (*a2 && uloc_openKeywords())
  {
    while (uenum_next())
    {
      uloc_getKeywordValue();
      uloc_setKeywordValue();
    }

    uenum_close();
  }

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString( CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!localeIdentifier || !CFStringGetCString(localeIdentifier, buffer, 257LL, 0x600u)) {
    return 0LL;
  }
  for (uint64_t i = buffer; ; ++i)
  {
    if (!*i)
    {
      v17[0] = 0;
      goto LABEL_14;
    }

    if (*i == 64) {
      break;
    }
  }

  v17[0] = 64;
  *uint64_t i = 0;
  uint64_t v5 = v17;
  uint64_t v6 = 1LL;
  do
  {
    int v7 = i[v6];
    if (v7 != 32)
    {
      *++uint64_t v5 = v7;
      int v7 = i[v6];
    }

    ++v6;
  }

  while (v7);
LABEL_14:
  __key[0] = buffer;
  __key[1] = 0LL;
  if (!bsearch( __key,  oldAppleLocaleToCanonical,  0xB8uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    uint64_t v13 = 0LL;
    int v14 = 0LL;
    _UpdateFullLocaleString(buffer, &v14, &v13, v16);
    int v8 = v13;
    int v9 = v14;
    if (v14 && v13)
    {
      if (strncmp(v14 + 1, v13 + 1, 2uLL)) {
        goto LABEL_22;
      }
      do
      {
        int v10 = v9[3];
        *v9++ = v10;
      }

      while (v10);
      int v8 = v13;
    }

    if (!v8)
    {
LABEL_24:
      __key[0] = buffer;
      BOOL v12 = (char **)bsearch( __key,  localeStringPrefixToDefaults,  0xB7uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
      if (v12) {
        _RemoveSubstringsIfPresent(buffer, v12[1]);
      }
      goto LABEL_26;
    }

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes( CFAllocatorRef allocator, LangCode lcode, RegionCode rcode)
{
  unsigned int v3 = lcode;
  if (rcode > 0x6C
    || (uint64_t v5 = regionCodeToLocaleString[(unsigned __int16)rcode]) == 0LL
    || !*v5
    || (CFLocaleIdentifier result = CFStringCreateWithCStringNoCopy(allocator, v5, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull)) == 0LL)
  {
    if (v3 <= 0x97
      && (unint64_t)(unsigned __int16)v3 - 95 >= 0x21
      && (int v7 = langCodeToLocaleString[(unsigned __int16)v3], *v7))
    {
      return CFStringCreateWithCStringNoCopy(allocator, v7, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t CFLocaleGetLanguageRegionEncodingForLocaleIdentifier( CFStringRef localeIdentifier, _WORD *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(0LL, localeIdentifier);
  if (CanonicalLocaleIdentifierFromString)
  {
    int v10 = CanonicalLocaleIdentifierFromString;
    if (!CFStringGetCString(CanonicalLocaleIdentifierFromString, buffer, 257LL, 0x600u))
    {
LABEL_27:
      uint64_t v12 = 0LL;
      goto LABEL_28;
    }

    int v22 = 0;
    int Language = uloc_getLanguage();
    uint64_t v12 = 0LL;
    int v13 = Language;
    if (Language < 1)
    {
LABEL_28:
      CFRelease(v10);
      return v12;
    }

    __s[Language] = 0;
    __key[0] = __s;
    __key[1] = 0LL;
    int v22 = 0;
    int Script = uloc_getScript();
    BOOL v15 = Script != 0;
    if (!Script)
    {
      int v22 = 0;
      int Script = uloc_getCountry();
      if (!Script)
      {
        int v22 = 0;
        int Script = uloc_getVariant();
      }
    }

    if (Script >= 1)
    {
      v23[Script] = 0;
      __strlcat_chk();
      __strlcat_chk();
    }

    uint64_t v16 = bsearch( __key,  &localeToLegacyCodes,  0xA3uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
    if (!v16)
    {
      if (a5) {
        BOOL v18 = v15;
      }
      else {
        BOOL v18 = 0;
      }
      int v19 = strlen(__s);
      uint64_t v12 = 0LL;
      if (v18 || v13 >= v19) {
        goto LABEL_28;
      }
      __s[v13] = 0;
      uint64_t v16 = bsearch( __key,  &localeToLegacyCodes,  0xA3uLL,  0x10uLL,  (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
      if (!v16) {
        goto LABEL_27;
      }
    }

    if (a2) {
      *a2 = *((_WORD *)v16 + 5);
    }
    if (a3) {
      *a3 = *((_WORD *)v16 + 4);
    }
    if (a5) {
      *a5 = *((_DWORD *)v16 + 3);
    }
    if (!a4)
    {
LABEL_19:
      uint64_t v12 = 1LL;
      goto LABEL_28;
    }

    int v17 = *((_DWORD *)v16 + 3);
    if (v17 <= 0x20)
    {
LABEL_18:
      *a4 = v17;
      goto LABEL_19;
    }

    if (v17 > 235)
    {
      if (v17 == 236)
      {
        LOWORD(v17) = 28;
        goto LABEL_18;
      }

      if (v17 == 252)
      {
        LOWORD(v17) = 32;
        goto LABEL_18;
      }
    }

    else
    {
      if (v17 == 140)
      {
        LOWORD(v17) = 4;
        goto LABEL_18;
      }

      if (v17 == 152)
      {
        LOWORD(v17) = 7;
        goto LABEL_18;
      }
    }

    LOWORD(v17) = 0;
    goto LABEL_18;
  }

  return 0LL;
}

uint64_t CompareLocaleToLegacyCodesEntries(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier( CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(allocator, 10LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v25 = 0;
  if (localeID)
  {
    CFIndex usedBufLen = 0LL;
    v30.size_t length = CFStringGetLength(localeID);
    v30.CFIndex location = 0LL;
    CFStringGetBytes(localeID, v30, 0x600u, 0x3Fu, 1u, buffer, 256LL, &usedBufLen);
    buffer[usedBufLen] = 0;
    int Language = uloc_getLanguage();
    if (v25 <= 0 && Language >= 1)
    {
      CFStringRef v6 = CFStringCreateWithBytes(allocator, bytes, Language, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleLanguageCodeKey", v6);
      CFRelease(v6);
    }

    int v25 = 0;
    int Script = uloc_getScript();
    if (v25 <= 0 && Script >= 1)
    {
      CFStringRef v8 = CFStringCreateWithBytes(allocator, bytes, Script, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleScriptCodeKey", v8);
      CFRelease(v8);
    }

    int v25 = 0;
    int Country = uloc_getCountry();
    if (v25 <= 0 && Country >= 1)
    {
      CFStringRef v10 = CFStringCreateWithBytes(allocator, bytes, Country, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleCountryCodeKey", v10);
      CFRelease(v10);
    }

    int v25 = 0;
    int Variant = uloc_getVariant();
    if (v25 <= 0 && Variant >= 1)
    {
      CFStringRef v12 = CFStringCreateWithBytes(allocator, bytes, Variant, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, @"kCFLocaleVariantCodeKey", v12);
      CFRelease(v12);
    }

    int v25 = 0;
    uloc_openKeywords();
    uint64_t v13 = uenum_next();
    if (v13 && v25 <= 0)
    {
      int v14 = (const char *)v13;
      while (1)
      {
        size_t v16 = strlen(v14);
        CFStringRef v17 = CFStringCreateWithBytes(allocator, (const UInt8 *)v14, v16, 0x600u, 1u);
        size_t v18 = strlen(__s);
        CFStringRef v19 = CFStringCreateWithBytes(allocator, (const UInt8 *)__s, v18, 0x600u, 1u);
        CFStringRef v20 = v19;
        if (v17 && v19)
        {
          CFDictionaryAddValue(Mutable, v17, v19);
        }

        else if (!v17)
        {
          goto LABEL_27;
        }

        CFRelease(v17);
LABEL_27:
        if (v20) {
          CFRelease(v20);
        }
LABEL_29:
        uint64_t v21 = uenum_next();
        if (v21)
        {
          int v14 = (const char *)v21;
          if (v25 < 1) {
            continue;
          }
        }

        break;
      }
    }

    uenum_close();
  }

  CFArrayRef Copy = CFDictionaryCreateCopy(allocator, Mutable);
  CFRelease(Mutable);
  return Copy;
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents( CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!dictionary) {
    return 0LL;
  }
  CFAllocatorRef v33 = allocator;
  CFIndex Count = CFDictionaryGetCount(dictionary);
  v32[1] = v32;
  uint64_t v5 = MEMORY[0x1895F8858](Count, v4);
  int v7 = (CFTypeRef *)((char *)v32 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v5, v8);
  CFStringRef v10 = (const __CFString **)((char *)v32 - v9);
  CFDictionaryGetKeysAndValues(dictionary, (CFTypeRef *)((char *)v32 - v9), v7);
  if (Count >= 1)
  {
    int v11 = 0LL;
    int v36 = 0LL;
    int v37 = 0LL;
    int v34 = 0LL;
    __int16 v35 = @"kCFLocaleCountryCodeKey";
    v32[0] = @"kCFLocaleVariantCodeKey";
    CFStringRef v12 = (CFTypeRef *)v10;
    CFIndex v13 = Count;
    int v14 = (const __CFString **)v7;
    while (!CFEqual(@"kCFLocaleLanguageCodeKey", *v12))
    {
      if (CFEqual(@"kCFLocaleScriptCodeKey", *v12))
      {
        int v37 = __CStringFromString(*v14);
        goto LABEL_12;
      }

      if (CFEqual(v35, *v12))
      {
        int v36 = __CStringFromString(*v14);
        goto LABEL_12;
      }

      if (CFEqual(v32[0], *v12))
      {
        int v34 = __CStringFromString(*v14);
        goto LABEL_12;
      }

UInt8 *__CStringFromString(const __CFString *a1)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  usedBufLen[0] = 0LL;
  v7.CFIndex location = 0LL;
  v7.size_t length = Length;
  CFStringGetBytes(a1, v7, 0x600u, 0x3Fu, 0, 0LL, 0LL, usedBufLen);
  CFIndex v3 = usedBufLen[0];
  uint64_t v4 = (UInt8 *)malloc(usedBufLen[0] + 1);
  v8.CFIndex location = 0LL;
  v8.size_t length = Length;
  CFStringGetBytes(a1, v8, 0x600u, 0x3Fu, 0, v4, v3, usedBufLen);
  v4[usedBufLen[0]] = 0;
  return v4;
}

uint64_t _CompareLowerTestEntryPrefixToTableEntryKey(char **a1, _BYTE **a2)
{
  uint64_t v2 = (uint64_t)*a1;
  CFIndex v3 = *a2;
  __darwin_ct_rune_t v5 = __tolower(**a1);
  __darwin_ct_rune_t v4 = v5 << 24;
  __darwin_ct_rune_t v5 = (char)v5;
  __darwin_ct_rune_t v6 = (char)*v3;
  int v7 = *v3;
  if ((char)v5 == v6)
  {
    BOOL v8 = !*v3 || v4 == 1593835520;
    __darwin_ct_rune_t v6 = (char)v5;
    if (!v8)
    {
      uint64_t v9 = (char *)(v2 + 1);
      CFStringRef v10 = v3 + 1;
      do
      {
        __darwin_ct_rune_t v11 = *v9++;
        __darwin_ct_rune_t v5 = __tolower(v11);
        __darwin_ct_rune_t v4 = v5 << 24;
        __darwin_ct_rune_t v5 = (char)v5;
        __darwin_ct_rune_t v12 = *v10++;
        __darwin_ct_rune_t v6 = v12;
        int v7 = v12;
        BOOL v13 = !v7 || v4 == 1593835520;
        __darwin_ct_rune_t v6 = (char)v5;
      }

      while (!v13);
    }
  }

  if (v7)
  {
    uint64_t v14 = 0xFFFFFFFFLL;
    if (v4 != 1593835520)
    {
      if (v5 < v6) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1LL;
      }
    }
  }

  else
  {
    if (v4 < 0) {
      int v15 = __maskrune(v5, 0x500uLL);
    }
    else {
      int v15 = *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v5 + 60) & 0x500;
    }
    return v15 != 0;
  }

  return v14;
}

BOOL _CheckForTag(uint64_t a1, const char *a2)
{
  unsigned int v4 = *(char *)(a1 + 2);
  if ((v4 & 0x80000000) != 0) {
    int v5 = __maskrune(v4, 0x500uLL);
  }
  else {
    int v5 = *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v4 + 60) & 0x500;
  }
  return v5 == 0;
}

const NXArchInfo *_CFBundleCurrentArchitecture()
{
  CFLocaleIdentifier result = NXGetLocalArchInfo();
  if (result) {
    return (const NXArchInfo *)result->cputype;
  }
  return result;
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsForHint(const __CFString *a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint32_t v2 = _dyld_image_count();
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t Length = CFStringGetLength(a1);
  result.uint64_t location = 0LL;
  result.size_t length = 0LL;
  unsigned int v4 = _CFProcessPath();
  int v5 = _NSGetMachExecuteHeader();
  uint64_t location = 0LL;
  if (Length >= 15)
  {
    v33.uint64_t location = 0LL;
    v33.size_t length = Length;
    if (!CFStringFindWithOptions(a1, @".framework", v33, 0xDuLL, &result)
      || (uint64_t location = result.location, result.location < 1)
      || result.length <= 0)
    {
      v34.uint64_t location = 0LL;
      v34.size_t length = Length;
      if (!CFStringFindWithOptions(a1, @"framework", v34, 0xDuLL, &result)
        || (uint64_t location = result.location, result.location < 1)
        || result.length <= 0)
      {
        v35.uint64_t location = 0LL;
        v35.size_t length = Length;
        int v7 = CFStringFindWithOptions(a1, @"fw", v35, 0xDuLL, &result);
        if (result.length <= 0 || result.location <= 0 || v7 == 0) {
          uint64_t location = 0LL;
        }
        else {
          uint64_t location = result.location;
        }
      }
    }
  }

  if (v2)
  {
    uint32_t v10 = 0;
    uint32_t v28 = v2;
    uint64_t v26 = v5;
    int v27 = v4;
    do
    {
      image_name = _dyld_get_image_name(v10);
      __darwin_ct_rune_t v12 = _CFBundleNormalizedPath(image_name);
      if (v12)
      {
        BOOL v13 = v12;
        if ((!v4 || strcmp(v12, v4)) && v5 != (mach_header_64 *)_dyld_get_image_header(v10))
        {
          uint64_t v14 = strrchr(v13, 47);
          if (v14)
          {
            CFStringRef v15 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14 + 1);
            if (v15)
            {
              size_t v16 = v15;
              CFStringRef v17 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
              CFStringRef cf = v16;
              size_t v18 = _CFBundleDYLDCreateLoadedImagePathVariants(v17, v16);
              CFIndex Count = CFArrayGetCount(v18);
              if (Count >= 1)
              {
                CFIndex v20 = Count;
                for (CFIndex i = 0LL; i != v20; ++i)
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, i);
                  v36.uint64_t location = 0LL;
                  v36.size_t length = Length;
                  if (!CFStringFindWithOptions(a1, ValueAtIndex, v36, 0xDuLL, 0LL))
                  {
                    if (location < 1) {
                      continue;
                    }
                    v37.uint64_t location = 0LL;
                    v37.size_t length = location;
                    if (!CFStringFindWithOptions(a1, ValueAtIndex, v37, 0xDuLL, 0LL)) {
                      continue;
                    }
                  }

                  CFStringRef v23 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
                  if (v23)
                  {
                    CFStringRef v24 = v23;
                    CFArrayAppendValue(theArray, v23);
                    CFRelease(v24);
                  }
                }
              }

              CFRelease(v18);
              CFRelease(cf);
              uint32_t v2 = v28;
              int v5 = v26;
              unsigned int v4 = v27;
            }
          }
        }
      }

      ++v10;
    }

    while (v10 != v2);
  }

  return theArray;
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsIfChanged()
{
  uint32_t v0 = _dyld_image_count();
  if (v0 != _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCount)
  {
    int v2 = v0;
    CFIndex v3 = _CFProcessPath();
    unsigned int v4 = _NSGetMachExecuteHeader();
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    if (!v2)
    {
LABEL_39:
      _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCFIndex Count = v2;
      return Mutable;
    }

    uint32_t v5 = 0;
    while (1)
    {
      image_name = _dyld_get_image_name(v5);
      int v7 = _CFBundleNormalizedPath(image_name);
      BOOL v8 = v7;
      uint64_t v9 = 0LL;
      if (!v5 && v7)
      {
        uint32_t v10 = strdup(v7);
        uint64_t v9 = v10;
        if (!v10) {
          goto LABEL_29;
        }
        int64_t v11 = strlen(v10);
        if (v11 < 1)
        {
          uint64_t v13 = 0LL;
        }

        else
        {
          int64_t v12 = 0LL;
          uint64_t v13 = 0LL;
          do
          {
            v9[v13] = v9[v12];
            while (v12 < v11 - 1 && v9[v12] == 47)
            {
              int v14 = v9[v12 + 1];
              if (v14 != 47)
              {
                BOOL v15 = v14 == 46 && v12 < v11 - 2;
                if (!v15 || v9[v12 + 2] != 47) {
                  break;
                }
              }

              if (v14 == 47) {
                uint64_t v16 = 1LL;
              }
              else {
                uint64_t v16 = 2LL;
              }
              v12 += v16;
            }

            ++v13;
            ++v12;
          }

          while (v12 < v11);
        }

        v9[v13] = 0;
      }

      if (!v8) {
        goto LABEL_36;
      }
LABEL_29:
      if (v3)
      {
        if (!strcmp(v8, v3)) {
          goto LABEL_36;
        }
        if (v9 && !strcmp(v9, v3))
        {
LABEL_37:
          free(v9);
          goto LABEL_38;
        }
      }

      if (v4 != (mach_header_64 *)_dyld_get_image_header(v5))
      {
        CFStringRef v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
        if (v17)
        {
          CFStringRef v18 = v17;
          CFArrayAppendValue(Mutable, v17);
          CFRelease(v18);
        }
      }

uint64_t _CFBundleDlfcnCheckLoaded(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  os_unfair_lock_assert_owner((os_unfair_lock_t)(a1 + 96));
  uint64_t result = *(unsigned __int8 *)(a1 + 52);
  if (!*(_BYTE *)(a1 + 52))
  {
    CFIndex v3 = CFBundleCopyExecutableURL((CFBundleRef)a1);
    if (v3)
    {
      unsigned int v4 = v3;
      if (CFURLGetFileSystemRepresentation(v3, 1u, buffer, 1026LL))
      {
        uint32_t v5 = dlopen((const char *)buffer, 277);
        if (v5)
        {
          if (!*(void *)(a1 + 56))
          {
            *(void *)(a1 + 56) = v5;
            __darwin_ct_rune_t v6 = (os_log_s *)_CFBundleLoadingLogger();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v8 = *(void *)(a1 + 56);
              int v9 = 138544130;
              uint64_t v10 = a1;
              __int16 v11 = 2082;
              int64_t v12 = buffer;
              __int16 v13 = 1024;
              int v14 = 277;
              __int16 v15 = 2048;
              uint64_t v16 = v8;
              _os_log_debug_impl( &dword_180A4C000,  v6,  OS_LOG_TYPE_DEBUG,  "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x getting handle %p",  (uint8_t *)&v9,  0x26u);
            }
          }

          *(_BYTE *)(a1 + 52) = 1;
        }

        else
        {
          int v7 = (os_log_s *)_CFBundleLoadingLogger();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
            _CFBundleDlfcnCheckLoaded_cold_1();
          }
        }
      }

      CFRelease(v4);
    }

    return *(unsigned __int8 *)(a1 + 52);
  }

  return result;
}

uint64_t _CFBundleDlfcnPreflight(unsigned __int8 *a1, CFErrorRef *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v5 = a1[52];
  os_unfair_lock_unlock(v4);
  if (v5) {
    return 1LL;
  }
  int v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  uint64_t v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026LL))
  {
    if (a2)
    {
      uint64_t v16 = CFGetAllocator(a1);
      CFErrorRef Error = _CFBundleCreateError(v16, (__CFBundle *)a1, 4LL);
    }

    else
    {
      CFErrorRef Error = 0LL;
    }

    goto LABEL_41;
  }

  BOOL v9 = dlopen_preflight((const char *)buffer);
  BOOL v10 = v9;
  CFErrorRef Error = 0LL;
  if (a2 && !v9)
  {
    int64_t v12 = CFBundleCopyExecutableArchitectures((CFBundleRef)a1);
    __int16 v13 = dlerror();
    if (v13 && *v13)
    {
      int v14 = (__CFString *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
      if (!v12)
      {
LABEL_10:
        __int16 v15 = CFGetAllocator(a1);
        CFErrorRef Error = _CFBundleCreateErrorDebug(v15, (CFBundleRef)a1, 3587LL, v14);
LABEL_39:
        if (v14) {
          CFRelease(v14);
        }
LABEL_41:
        BOOL v10 = 0LL;
        uint64_t result = 0LL;
        if (!v8) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
    }

    else
    {
      int v14 = 0LL;
      if (!v12) {
        goto LABEL_10;
      }
    }

    CFIndex Count = CFArrayGetCount(v12);
    uint64_t v18 = NXGetLocalArchInfo();
    if (v18) {
      cpu_type_t cputype = v18->cputype;
    }
    else {
      cpu_type_t cputype = 0;
    }
    if (Count < 1) {
      goto LABEL_31;
    }
    CFIndex v20 = 0LL;
    do
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v20);
      if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr)) {
        BOOL v22 = valuePtr == cputype;
      }
      else {
        BOOL v22 = 0;
      }
      int v23 = !v22;
      ++v20;
    }

    while (v23 == 1 && v20 < Count);
    if ((v23 & 1) != 0)
    {
LABEL_31:
      CFIndex v25 = 3585LL;
    }

    else
    {
      int v28 = 0;
      if (_CFBundleGrokObjCImageInfoFromMainExecutable(0LL, &v28)
        && (v28 & 2) != 0
        && (int v27 = 0, _CFBundleGetObjCImageInfo((__CFBundle *)a1, 0LL, &v27))
        && (v27 & 2) == 0)
      {
        CFIndex v25 = 3586LL;
      }

      else
      {
        CFIndex v25 = 3587LL;
      }
    }

    uint64_t v26 = CFGetAllocator(a1);
    CFErrorRef Error = _CFBundleCreateErrorDebug(v26, (CFBundleRef)a1, v25, v14);
    CFRelease(v12);
    goto LABEL_39;
  }

uint64_t _CFBundleDlfcnLoadBundle(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  __darwin_ct_rune_t v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v7 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v6);
  if (v7) {
    return 1LL;
  }
  CFTypeRef cf = 0LL;
  BOOL v9 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  BOOL v10 = v9;
  if (!v9 || !CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026LL))
  {
    __int16 v15 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_1();
      if (!a3)
      {
LABEL_19:
        uint64_t v8 = 0LL;
        if (!v10) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
    }

    else if (!a3)
    {
      goto LABEL_19;
    }

    uint64_t v16 = CFGetAllocator((CFTypeRef)a1);
    CFTypeRef cf = _CFBundleCreateError(v16, (__CFBundle *)a1, 4LL);
    goto LABEL_19;
  }

  if (a2) {
    int v11 = 265;
  }
  else {
    int v11 = 262;
  }
  int64_t v12 = dlopen((const char *)buffer, v11);
  __int16 v13 = (os_log_s *)_CFBundleLoadingLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    uint64_t v23 = a1;
    __int16 v24 = 2082;
    CFIndex v25 = buffer;
    __int16 v26 = 1024;
    int v27 = v11;
    __int16 v28 = 2048;
    uint64_t v29 = v12;
    _os_log_debug_impl( &dword_180A4C000,  v13,  OS_LOG_TYPE_DEBUG,  "dlfcn load bundle %{public}@, dlopen of %{public}s mode 0x%x returns handle %p",  buf,  0x26u);
  }

  os_unfair_lock_lock_with_options();
  if (!v12)
  {
    *(void *)(a1 + 56) = 0LL;
    os_unfair_lock_unlock(v6);
    CFStringRef v17 = dlerror();
    uint64_t v18 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_2();
      if (!v17)
      {
LABEL_24:
        if (a3)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            CFStringRef v19 = CFGetAllocator((CFTypeRef)a1);
            CFTypeRef cf = _CFBundleCreateErrorDebug(v19, (CFBundleRef)a1, 3588LL, v17);
          }
        }

        if (v17) {
          CFRelease(v17);
        }
        uint64_t v8 = 0LL;
        goto LABEL_30;
      }
    }

    else if (!v17)
    {
      goto LABEL_24;
    }

    CFStringRef v17 = (void *)CFStringCreateWithFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const char *)v17);
    goto LABEL_24;
  }

  if (v12 == *(void **)(a1 + 56))
  {
    int v14 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnLoadBundle_cold_3();
    }
    os_unfair_lock_unlock(v6);
    dlclose(v12);
    os_unfair_lock_lock_with_options();
  }

  *(void *)(a1 + 56) = v12;
  uint64_t v8 = 1LL;
  *(_BYTE *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v6);
LABEL_30:
  CFRelease(v10);
LABEL_31:
  if (!a3 || (_DWORD)v8)
  {
    if (cf) {
      CFRelease(cf);
    }
  }

  else
  {
    *a3 = cf;
  }

  return v8;
}

uint64_t _CFBundleDlfcnLoadFramework(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  int v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v4);
  if (v5) {
    return 1LL;
  }
  CFTypeRef cf = 0LL;
  int v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  uint64_t v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026LL))
  {
    int64_t v12 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_1();
      if (!a2)
      {
LABEL_16:
        uint64_t v6 = 0LL;
        if (!v8) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }
    }

    else if (!a2)
    {
      goto LABEL_16;
    }

    __int16 v13 = CFGetAllocator((CFTypeRef)a1);
    CFTypeRef cf = _CFBundleCreateError(v13, (__CFBundle *)a1, 4LL);
    goto LABEL_16;
  }

  BOOL v9 = dlopen((const char *)buffer, 265);
  BOOL v10 = (os_log_s *)_CFBundleLoadingLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    uint64_t v20 = a1;
    __int16 v21 = 2082;
    BOOL v22 = buffer;
    __int16 v23 = 1024;
    int v24 = 265;
    __int16 v25 = 2048;
    __int16 v26 = v9;
    _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "dlfcn load framework %{public}@, dlopen of %{public}s mode 0x%x returns handle %p",  buf,  0x26u);
  }

  os_unfair_lock_lock_with_options();
  if (!v9)
  {
    *(void *)(a1 + 56) = 0LL;
    os_unfair_lock_unlock(v4);
    int v14 = dlerror();
    __int16 v15 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_2();
      if (!v14)
      {
LABEL_21:
        if (a2)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            uint64_t v16 = CFGetAllocator((CFTypeRef)a1);
            CFTypeRef cf = _CFBundleCreateErrorDebug(v16, (CFBundleRef)a1, 3588LL, v14);
          }
        }

        if (v14) {
          CFRelease(v14);
        }
        uint64_t v6 = 0LL;
        goto LABEL_27;
      }
    }

    else if (!v14)
    {
      goto LABEL_21;
    }

    int v14 = (void *)CFStringCreateWithFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const char *)v14);
    goto LABEL_21;
  }

  if (v9 == *(void **)(a1 + 56))
  {
    int v11 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnLoadFramework_cold_3();
    }
    os_unfair_lock_unlock(v4);
    dlclose(v9);
    os_unfair_lock_lock_with_options();
  }

  *(void *)(a1 + 56) = v9;
  uint64_t v6 = 1LL;
  *(_BYTE *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v4);
LABEL_27:
  CFRelease(v8);
LABEL_28:
  if (!a2 || (_DWORD)v6)
  {
    if (cf) {
      CFRelease(cf);
    }
  }

  else
  {
    *a2 = cf;
  }

  return v6;
}

void _CFBundleDlfcnUnload(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_assert_owner((os_unfair_lock_t)(a1 + 96));
  CFIndex v3 = *(void **)(a1 + 56);
  if (*(_BYTE *)(a1 + 52)) {
    BOOL v4 = v3 == 0LL;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v5 = (os_log_s *)_CFBundleLoadingLogger();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
      _CFBundleDlfcnUnload_cold_2();
    }
    *(void *)(a1 + 56) = 0LL;
    *(_BYTE *)(a1 + 52) = 0;
    os_unfair_lock_unlock(v2);
    int v6 = dlclose(v3);
    os_unfair_lock_lock(v2);
    if (v6)
    {
      int v7 = (os_log_s *)_CFBundleLoadingLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        _CFBundleDlfcnUnload_cold_1(a1, v7);
      }
      *(void *)(a1 + 56) = v3;
      *(_BYTE *)(a1 + 52) = 1;
    }
  }

void *_CFBundleDlfcnGetSymbolByName(uint64_t a1, const __CFString *a2)
{
  return _CFBundleDlfcnGetSymbolByNameWithSearch(a1, a2, 0);
}

void *_CFBundleDlfcnGetSymbolByNameWithSearch(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!CFStringGetCString(a2, buffer, 1024LL, 0x8000100u) || (int v7 = *(void **)(a1 + 56)) == 0LL)
  {
LABEL_11:
    BOOL v9 = 0LL;
    goto LABEL_12;
  }

  uint64_t v8 = dlsym(v7, buffer);
  BOOL v9 = v8;
  if (a3 && !v8) {
    BOOL v9 = dlsym((void *)0xFFFFFFFFFFFFFFFELL, buffer);
  }
  BOOL v10 = (os_log_s *)_CFBundleLoadingLogger();
  int v11 = v10;
  if (!v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1();
    }
    goto LABEL_11;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v12 = *(void *)(a1 + 56);
    int v14 = 138544130;
    uint64_t v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = v12;
    __int16 v18 = 2048;
    CFStringRef v19 = v9;
    __int16 v20 = 2082;
    __int16 v21 = buffer;
    _os_log_debug_impl( &dword_180A4C000,  v11,  OS_LOG_TYPE_DEBUG,  "bundle %{public}@ handle %p dlsym returns symbol %p for %{public}s",  (uint8_t *)&v14,  0x2Au);
  }

CFStringRef _CFBundleCopyLoadedImagePathForPointer()
{
  uint32_t v0 = (const char *)dyld_image_path_containing_address();
  unsigned int v1 = _CFBundleNormalizedPath(v0);
  if (v1) {
    CFStringRef v2 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
  }
  else {
    CFStringRef v2 = 0LL;
  }
  CFIndex v3 = (os_log_s *)_CFBundleLoadingLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
    _CFBundleCopyLoadedImagePathForPointer_cold_1();
  }
  return v2;
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (CFBundleLoadExecutable(bundle)) {
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, functionName, 0);
  }
  else {
    return 0LL;
  }
}

void *_CFBundleGetCFMFunctionPointerForName(__CFBundle *a1, const __CFString *a2)
{
  if (CFBundleLoadExecutable(a1)) {
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)a1, a2, 1);
  }
  else {
    return 0LL;
  }
}

void CFBundleGetFunctionPointersForNames(CFBundleRef bundle, CFArrayRef functionNames, void *ftbl[])
{
  if (ftbl)
  {
    int Count = CFArrayGetCount(functionNames);
    if (Count >= 1)
    {
      CFIndex v7 = 0LL;
      uint64_t v8 = Count;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(functionNames, v7);
        ftbl[v7++] = CFBundleGetFunctionPointerForName(bundle, ValueAtIndex);
      }

      while (v8 != v7);
    }
  }

__CFBundle *_CFBundleGetCFMFunctionPointersForNames(__CFBundle *result, CFArrayRef theArray, uint64_t a3)
{
  if (a3)
  {
    int v5 = result;
    uint64_t result = (__CFBundle *)CFArrayGetCount(theArray);
    if ((int)result >= 1)
    {
      CFIndex v6 = 0LL;
      uint64_t v7 = result;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v6);
        uint64_t result = (__CFBundle *)_CFBundleGetCFMFunctionPointerForName(v5, ValueAtIndex);
        *(void *)(a3 + 8 * v6++) = result;
      }

      while (v7 != v6);
    }
  }

  return result;
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  }
  if (CFBundleLoadExecutable(bundle)) {
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, symbolName, 0);
  }
  else {
    return 0LL;
  }
}

void CFBundleGetDataPointersForNames(CFBundleRef bundle, CFArrayRef symbolNames, void *stbl[])
{
  if (stbl)
  {
    int Count = CFArrayGetCount(symbolNames);
    if (Count >= 1)
    {
      CFIndex v7 = 0LL;
      uint64_t v8 = Count;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(symbolNames, v7);
        stbl[v7++] = CFBundleGetDataPointerForName(bundle, ValueAtIndex);
      }

      while (v8 != v7);
    }
  }

void OUTLINED_FUNCTION_0_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_1_3( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_7( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t OUTLINED_FUNCTION_0_5(uint64_t a1, const __CFString *a2)
{
  return _CFThrowFormattedException(v2, a2);
}

__CFArray *_CFBundleDYLDCreateLoadedImagePathVariants(const char *a1, const __CFString *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  if (a1)
  {
    if (*a1)
    {
      int v5 = CFStringCreateWithCStringNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  a1,  0x8000100u,  (CFAllocatorRef)&__kCFAllocatorNull);
      if (v5)
      {
        CFIndex v6 = v5;
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v5,  @":");
        CFRelease(v6);
        if (ArrayBySeparatingStrings)
        {
          CFIndex Length = CFStringGetLength(a2);
          CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
          if (Count >= 1)
          {
            CFIndex v10 = Count;
            for (CFIndex i = 0LL; i != v10; ++i)
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
              CFIndex v13 = CFStringGetLength(ValueAtIndex);
              if (v13)
              {
                CFIndex v14 = v13;
                v24.CFIndex location = 0LL;
                v24.size_t length = Length;
                int v15 = CFStringFindWithOptions(a2, @".", v24, 4uLL, &result);
                CFIndex location = result.location;
                if (!v15) {
                  CFIndex location = Length;
                }
                CFIndex v17 = location - v14;
                if (location - v14 >= 1)
                {
                  v25.CFIndex location = location - v14;
                  v25.size_t length = v14;
                  if (CFStringCompareWithOptions(a2, ValueAtIndex, v25, 8uLL) == kCFCompareEqualTo)
                  {
                    MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, a2);
                    if (MutableCopy)
                    {
                      CFStringRef v19 = MutableCopy;
                      v23.CFIndex location = v17;
                      v23.size_t length = v14;
                      CFStringReplace(MutableCopy, v23, &stru_1899EF170);
                      CFArrayAppendValue(Mutable, v19);
                      CFRelease(v19);
                    }
                  }
                }
              }
            }
          }

          CFRelease(ArrayBySeparatingStrings);
        }
      }
    }
  }

  CFArrayAppendValue(Mutable, a2);
  return Mutable;
}

void __CFMachPortDeallocate(uint64_t a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    uint64_t v2 = (os_unfair_lock_s *)(a1 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (!*(_DWORD *)(a1 + 16))
    {
      *(_DWORD *)(a1 + 16) = 1;
      __dmb(0xBu);
      CFIndex v3 = *(dispatch_source_s **)(a1 + 24);
      if (v3)
      {
        dispatch_source_cancel(v3);
        *(void *)(a1 + 24) = 0LL;
      }

      int v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      unint64_t v4 = *(__CFRunLoopSource **)(a1 + 40);
      *(void *)(a1 + 4_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
      uint64_t v6 = *(void *)(a1 + 64);
      CFIndex v7 = *(void (**)(uint64_t))(a1 + 112);
      *(void *)(a1 + 64) = 0LL;
      if (v5)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        v5(a1, v6);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }

      if (v4)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        CFRunLoopSourceInvalidate(v4);
        CFRelease(v4);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }

      if (v7)
      {
        if (v6)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
          v7(v6);
          os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
        }
      }

      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }

    *(_DWORD *)(a1 + 16) = 3;
    unsigned int v8 = *(_DWORD *)(a1 + 20);
    BOOL v9 = (unint64_t *)(a1 + 8);
    unsigned int v10 = atomic_load((unint64_t *)(a1 + 8));
    int v11 = (v10 >> 2) & 1;
    LODWORD(v9) = atomic_load(v9);
    unsigned int v12 = (v9 >> 1) & 1;
    os_unfair_lock_unlock(v2);
    _cfmp_record_deallocation(0, v8, v11, v12);
  }

BOOL __CFMachPortEqual(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
}

uint64_t __CFMachPortHash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

CFStringRef __CFMachPortCopyDescription(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    goto LABEL_5;
  }
  CFIndex v3 = *(uint64_t (**)(void))(a1 + 88);
  if (!v3) {
    goto LABEL_5;
  }
  CFStringRef v4 = (CFStringRef)v3();
  if (!v4)
  {
    uint64_t v2 = *(void *)(a1 + 64);
LABEL_5:
    CFStringRef v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFMachPort context %p>",  v2);
  }

  int v5 = *(void **)(a1 + 48);
  dli_sname = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5) {
      dli_sname = v12.dli_sname;
    }
  }

  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  BOOL v9 = "No";
  if (!*(_DWORD *)(a1 + 16)) {
    BOOL v9 = "Yes";
  }
  CFStringRef v10 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFMachPort %p [%p]>{valid = %s, port = %x, source = %p, callout = %s (%p), context = %@}",  a1,  v8,  v9,  *(unsigned int *)(a1 + 20),  *(void *)(a1 + 40),  dli_sname,  v5,  v4);
  if (v4) {
    CFRelease(v4);
  }
  return v10;
}

CFTypeID CFMachPortGetTypeID(void)
{
  return 36LL;
}

uint64_t _CFMachPortCreateWithPort2( const __CFAllocator *a1, mach_port_name_t a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 1);
}

uint64_t _CFMachPortCreateWithPort4( const __CFAllocator *a1, mach_port_name_t name, uint64_t a3, __int128 *a4, _BYTE *a5, int a6)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (a5) {
    *a5 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  mach_port_type_t ptype = 0;
  uint64_t v12 = mach_port_type(*MEMORY[0x1895FBBE0], name, &ptype);
  if ((_DWORD)v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = (ptype & 0x70000) == 0;
  }
  if (v13)
  {
    uint64_t v14 = v12;
    mach_port_type_t v15 = ptype & 0xFFEFFFFF;
    __int16 v16 = (os_log_s *)_CFOSLog();
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 134218496;
        uint64_t v46 = name;
        __int16 v47 = 1024;
        int v48 = v14;
        __int16 v49 = 2048;
        uint64_t v50 = ptype;
        _os_log_error_impl( &dword_180A4C000,  v16,  OS_LOG_TYPE_ERROR,  "*** CFMachPortCreateWithPort(): bad Mach port parameter (0x%lx) or unsupported mysterious kind of Mach port (%d, %ld)",  buf,  0x1Cu);
      }
    }

    else if (v17)
    {
      _CFMachPortCreateWithPort4_cold_1(name, v14, v16);
    }

    return 0LL;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
  if (__CFAllMachPorts && (CFIndex Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts), Count >= 1))
  {
    CFIndex v23 = Count;
    CFIndex v24 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v24);
      if (ValueAtIndex)
      {
        uint64_t v26 = (uint64_t)ValueAtIndex;
        if (ValueAtIndex[5] == name) {
          break;
        }
      }

      if (v23 == ++v24) {
        goto LABEL_22;
      }
    }

    CFRetain(ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    uint64_t v36 = 1LL;
  }

  else
  {
LABEL_22:
    uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x24uLL, 104LL, 0LL, v18, v19, v20, v21);
    if (!Instance)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      CFRange v37 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        _CFMachPortCreateWithPort4_cold_2(v37);
      }
      return 0LL;
    }

    uint64_t v26 = Instance;
    *(_DWORD *)(Instance + 2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = name;
    *(void *)(Instance + 4_Block_object_dispose((const void *)(v28 - 104), 8) = a3;
    *(_DWORD *)(Instance + 96) = 0;
    if (a4)
    {
      __int128 v28 = *a4;
      __int128 v29 = a4[1];
      *(void *)(Instance + 8_Block_object_dispose((const void *)(v28 - 104), 8) = *((void *)a4 + 4);
      *(_OWORD *)(Instance + 72) = v29;
      *(_OWORD *)(Instance + 56) = v28;
      uint64_t v30 = *((void *)a4 + 1);
      uint64_t v31 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
      if (v31)
      {
        uint64_t v30 = v31(v30);
        uint64_t v31 = (uint64_t (*)(uint64_t))*((void *)a4 + 2);
      }

      *(void *)(v26 + 64) = v30;
      *(void *)(v26 + 104) = v31;
      *(void *)(v26 + 112) = *((void *)a4 + 3);
      *(void *)(v26 + 72) = 0xAAAAAAAAAACCCAAALL;
      *(void *)(v26 + 8_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0xAAAAAAAAAABBBAAALL;
    }

    *(_DWORD *)(v26 + 16) = 0;
    CFMutableStringRef Mutable = (__CFArray *)__CFAllMachPorts;
    if (!__CFAllMachPorts)
    {
      CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
      __CFAllMachPorts = (uint64_t)Mutable;
    }

    CFArrayAppendValue(Mutable, (const void *)v26);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    if (a5) {
      *a5 = 0;
    }
    if (a6 && (ptype & 0x50000) != 0)
    {
      _cfmp_record_intent_to_invalidate(0, name);
      if (_CFMachPortQueue_onceToken != -1) {
        dispatch_once(&_CFMachPortQueue_onceToken, &__block_literal_global_17);
      }
      CFRange v33 = dispatch_source_create( MEMORY[0x1895F8B48],  name,  1uLL,  (dispatch_queue_t)_CFMachPortQueue___CFMachPortQueue);
      if (v33)
      {
        CFRange v34 = v33;
        uint64_t v35 = MEMORY[0x1895F87A8];
        handler[0] = MEMORY[0x1895F87A8];
        handler[1] = 3221225472LL;
        handler[2] = ___CFMachPortCreateWithPort4_block_invoke;
        handler[3] = &unk_18999AD60;
        mach_port_name_t v43 = name;
        handler[4] = v33;
        dispatch_source_set_cancel_handler(v33, handler);
        v40[0] = v35;
        v40[1] = 3221225472LL;
        v40[2] = ___CFMachPortCreateWithPort4_block_invoke_2;
        v40[3] = &__block_descriptor_36_e5_v8__0l;
        mach_port_name_t v41 = name;
        dispatch_source_set_event_handler(v34, v40);
        *(void *)(v26 + 24) = v34;
        dispatch_resume(v34);
      }
    }

    uint64_t v36 = 0LL;
  }

  if (!CFMachPortIsValid((CFMachPortRef)v26))
  {
    int v38 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      _CFMachPortCreateWithPort4_cold_3(v26, v36, v38);
    }
    CFRelease((CFTypeRef)v26);
    return 0LL;
  }

  return v26;
}

uint64_t _CFMachPortCreateWithPort3( const __CFAllocator *a1, mach_port_name_t a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 0);
}

CFMachPortRef CFMachPortCreateWithPort( CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreateWithPort4( allocator,  portNum,  (uint64_t)callout,  (__int128 *)&context->version,  shouldFreeInfo,  1);
}

uint64_t _CFMachPortCreateReply(const __CFAllocator *a1, uint64_t a2, __int128 *a3, _BYTE *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (a4) {
    *a4 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  mach_port_name_t name = 0;
  *(_OWORD *)&options.flags = xmmword_180C35910;
  options.reserved[1] = 0LL;
  CFAllocatorRef v8 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  uint64_t v9 = mach_port_construct(*MEMORY[0x1895FBBE0], &options, 0LL, &name);
  if (!(_DWORD)v9)
  {
    uint64_t result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, 1);
    if (!result)
    {
      if (name)
      {
        mach_port_mod_refs(*v8, name, 1u, -1);
        mach_port_deallocate(*v8, name);
      }

      return 0LL;
    }

    uint64_t v19 = (unint64_t *)(result + 8);
    unint64_t v20 = atomic_load((unint64_t *)(result + 8));
    while (1)
    {
      unint64_t v21 = __ldaxr(v19);
      if (v21 != v20) {
        break;
      }
      if (__stlxr(v20 | 2, v19)) {
        goto LABEL_18;
      }
      int v22 = 1;
LABEL_19:
      unint64_t v20 = v21;
      if (v22)
      {
        unint64_t v23 = atomic_load(v19);
        while (1)
        {
          unint64_t v24 = __ldaxr(v19);
          if (v24 != v23) {
            break;
          }
          if (__stlxr(v23 | 4, v19)) {
            goto LABEL_25;
          }
          int v25 = 1;
LABEL_26:
          unint64_t v23 = v24;
          if (v25) {
            return result;
          }
        }

        __clrex();
LABEL_25:
        int v25 = 0;
        goto LABEL_26;
      }
    }

    __clrex();
LABEL_18:
    int v22 = 0;
    goto LABEL_19;
  }

  uint64_t v10 = v9;
  int v11 = (os_log_s *)_CFOSLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
    _CFMachPortCreateReply_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  }
  return 0LL;
}

CFMachPortRef CFMachPortCreate( CFAllocatorRef allocator, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreate4( allocator,  (uint64_t)callout,  (__int128 *)&context->version,  shouldFreeInfo,  1);
}

uint64_t _CFMachPortCreate4(const __CFAllocator *a1, uint64_t a2, __int128 *a3, _BYTE *a4, int a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a4) {
    *a4 = 1;
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  mach_port_name_t name = 0;
  uint64_t v10 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  uint64_t inserted = mach_port_allocate(*MEMORY[0x1895FBBE0], 1u, &name);
  if (!(_DWORD)inserted)
  {
    uint64_t inserted = mach_port_insert_right(*v10, name, name, 0x14u);
    if (!(_DWORD)inserted)
    {
      uint64_t result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, a5);
      if (!result)
      {
        if (name)
        {
          mach_port_mod_refs(*v10, name, 1u, -1);
          mach_port_deallocate(*v10, name);
        }

        return 0LL;
      }

      unint64_t v21 = (unint64_t *)(result + 8);
      unint64_t v22 = atomic_load((unint64_t *)(result + 8));
      while (1)
      {
        unint64_t v23 = __ldaxr(v21);
        if (v23 != v22) {
          break;
        }
        if (__stlxr(v22 | 2, v21)) {
          goto LABEL_22;
        }
        int v24 = 1;
LABEL_23:
        unint64_t v22 = v23;
        if (v24)
        {
          unint64_t v25 = atomic_load(v21);
          while (1)
          {
            unint64_t v26 = __ldaxr(v21);
            if (v26 != v25) {
              break;
            }
            if (__stlxr(v25 | 4, v21)) {
              goto LABEL_29;
            }
            int v27 = 1;
LABEL_30:
            unint64_t v25 = v26;
            if (v27) {
              return result;
            }
          }

          __clrex();
LABEL_29:
          int v27 = 0;
          goto LABEL_30;
        }
      }

      __clrex();
LABEL_22:
      int v24 = 0;
      goto LABEL_23;
    }
  }

  if (name)
  {
    mach_port_mod_refs(*v10, name, 1u, -1);
    uint64_t v12 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      _CFMachPortCreate4_cold_2((int *)&name, inserted, v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      _CFMachPortCreate4_cold_1(inserted, v13, v14, v15, v16, v17, v18, v19);
    }
  }

  return 0LL;
}

uint64_t _CFMachPortCreate3(const __CFAllocator *a1, uint64_t a2, __int128 *a3, _BYTE *a4)
{
  return _CFMachPortCreate4(a1, a2, a3, a4, 0);
}

void CFMachPortInvalidate(CFMachPortRef port)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (CF_IS_OBJC(0x24uLL, (__objc2_class **)port))
    {
      -[__CFMachPort invalidate](port, "invalidate");
    }

    else
    {
      CFRetain(port);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
      os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      int v2 = *((_DWORD *)port + 4);
      if (v2)
      {
        CFIndex v3 = 0LL;
      }

      else
      {
        *((_DWORD *)port + 4) = 1;
        __dmb(0xBu);
        if (__CFAllMachPorts)
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts);
          if (Count >= 1)
          {
            CFIndex v5 = Count;
            CFIndex v6 = 0LL;
            while (CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v6) != port)
            {
              if (v5 == ++v6) {
                goto LABEL_18;
              }
            }

            CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFAllMachPorts, v6);
          }
        }

mach_port_t CFMachPortGetPort(CFMachPortRef port)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0;
  }
  return *((_DWORD *)port + 5);
}

void CFMachPortGetContext(CFMachPortRef port, CFMachPortContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  }
  __int128 v5 = *(_OWORD *)((char *)port + 56);
  __int128 v6 = *(_OWORD *)((char *)port + 72);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)port + 11);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

Boolean CFMachPortIsValid(CFMachPortRef port)
{
  kern_return_t v3;
  mach_port_type_t ptype;
  uint64_t v6;
  __int128 v6 = *MEMORY[0x1895F89C0];
  if (*((_DWORD *)port + 4)) {
    return 0;
  }
  mach_port_type_t ptype = 0;
  CFIndex v3 = mach_port_type(*MEMORY[0x1895FBBE0], *((_DWORD *)port + 5), &ptype);
  return (ptype & 0x70000) != 0 && v3 == 0;
}

CFMachPortInvalidationCallBack CFMachPortGetInvalidationCallBack(CFMachPortRef port)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v2 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  }
  CFIndex v3 = (os_unfair_lock_s *)((char *)port + 96);
  os_unfair_lock_lock((os_unfair_lock_t)port + 24);
  unint64_t v4 = (void (__cdecl *)(CFMachPortRef, void *))*((void *)port + 4);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFMachPortSetInvalidationCallBack(CFMachPortRef port, CFMachPortInvalidationCallBack callout)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (callout)
    {
      mach_port_type_t ptype = 0;
      if (mach_port_type(*MEMORY[0x1895FBBE0], *((_DWORD *)port + 5), &ptype) || (ptype & 0x50000) == 0) {
        CFLog( 3LL,  (uint64_t)@"*** WARNING: CFMachPortSetInvalidationCallBack() called on a CFMachPort with a Mach port (0x%x) which does not have any send rights.  This is not going to work.  Callback function: %p",  v5,  v6,  v7,  v8,  v9,  v10,  *((unsigned int *)port + 5));
      }
    }

    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (callout && *((_DWORD *)port + 4))
    {
      if (*((void *)port + 4))
      {
        CFLog( 4LL,  (uint64_t)@"CFMachPortSetInvalidationCallBack(): attempt to set invalidation callback (%p) on invalid CFMachPort (%p) thwarted",  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)callout);
      }

      else
      {
        uint64_t v17 = *((void *)port + 8);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
        ((void (*)(CFMachPortRef, uint64_t))callout)(port, v17);
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      }
    }

    else
    {
      *((void *)port + 4) = callout;
    }

    os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
  }

uint64_t CFMachPortGetQueuedMessageCount(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    return 0LL;
  }
  mach_msg_type_number_t port_info_outCnt = 10;
  if (mach_port_get_attributes(*MEMORY[0x1895FBBE0], *(_DWORD *)(a1 + 20), 2, port_info_out, &port_info_outCnt)) {
    return 0LL;
  }
  else {
    return port_info_out[4];
  }
}

uint64_t __CFMachPortPerform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a4 + 96));
    if (*(_DWORD *)(a4 + 16))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
    }

    else
    {
      uint64_t v7 = *(uint64_t (**)(void))(a4 + 104);
      uint64_t v8 = *(void *)(a4 + 64);
      if (v7)
      {
        uint64_t v8 = v7(*(void *)(a4 + 64));
        uint64_t v9 = *(void (**)(uint64_t))(a4 + 112);
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 48))(a4, a1, a2, v8);
      if (v9) {
        v9(v8);
      }
      if ((__CF_FORK_STATE & 2) == 0) {
        __CF_USED();
      }
      if ((__CF_FORK_STATE & 1) != 0) {
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
      }
    }
  }

  return 0LL;
}

uint64_t __CFDescribeCFMachPortPerformCallout(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (__CFDescribeCFMachPortPerformCallout_onceToken != -1) {
    dispatch_once(&__CFDescribeCFMachPortPerformCallout_onceToken, &__block_literal_global_5);
  }
  uint64_t v10 = *(const void **)(a1 + 48);
  if (__CFDescribeCFMachPortPerformCallout_foundationFireMachPort) {
    BOOL v11 = __CFDescribeCFMachPortPerformCallout_foundationDescribeNSMachPortCallout == 0LL;
  }
  else {
    BOOL v11 = 1;
  }
  uint64_t result = dladdr(v10, &v14);
  if ((_DWORD)result)
  {
    snprintf(a4, a5, "(CFMachPort) %s", v14.dli_sname);
    return snprintf(a2, a3, "%s", v14.dli_fname);
  }

  return result;
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  v13.perforuint64_t m = (void (__cdecl *)(void *))*MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v6 != 36) {
    _CFAssertMismatchedTypeID(0x24uLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0 && CFMachPortIsValid(port))
  {
    uint64_t v7 = (os_unfair_lock_s *)((char *)port + 96);
    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (*((_DWORD *)port + 4))
    {
LABEL_9:
      uint64_t v8 = 0LL;
LABEL_18:
      os_unfair_lock_unlock(v7);
      return v8;
    }

    uint64_t v9 = (__CFRunLoopSource *)*((void *)port + 5);
    if (v9)
    {
      int IsValid = CFRunLoopSourceIsValid(v9);
      CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)port + 5);
      if (IsValid)
      {
        if (v11) {
          goto LABEL_17;
        }
      }

      else
      {
        CFRelease(v11);
        *((void *)port + 5) = 0LL;
      }
    }

    v13.CFAllocatorRetainCallBack retain = CFRetain;
    v13.CFArrayReleaseCallBack release = CFRelease;
    v13.copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))__CFMachPortCopyDescription;
    v13.equal = (Boolean (__cdecl *)(const void *, const void *))__CFMachPortEqual;
    v13.CFIndex version = 1LL;
    v13.info = port;
    v13.hash = (CFHashCode (__cdecl *)(const void *))__CFMachPortHash;
    v13.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortGetPort;
    v13.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortPerform;
    CFRunLoopSourceRef v11 = CFRunLoopSourceCreate(allocator, order, &v13);
    *((void *)port + 5) = v11;
    if (!v11) {
      goto LABEL_9;
    }
LABEL_17:
    uint64_t v8 = (__CFRunLoopSource *)CFRetain(v11);
    goto LABEL_18;
  }

  return 0LL;
}

uint64_t __CFMachPortGetPort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void __CFMachMessageCheckForAndDestroyUnsentMessage(int a1, mach_msg_header_t *a2)
{
  if (a1 != 268435463)
  {
    if (a1 == 268435459)
    {
LABEL_10:
      mach_msg_destroy(a2);
      return;
    }

    if (a1 != 16) {
      return;
    }
  }

  mach_port_t msgh_local_port = a2->msgh_local_port;
  if (msgh_local_port - 1 <= 0xFFFFFFFD)
  {
    mach_msg_bits_t msgh_bits = a2->msgh_bits;
    if (((a2->msgh_bits >> 8) & 0x1F) - 17 <= 1)
    {
      mach_port_deallocate(*MEMORY[0x1895FBBE0], msgh_local_port);
      mach_msg_bits_t msgh_bits = a2->msgh_bits;
    }

    a2->mach_msg_bits_t msgh_bits = msgh_bits & 0xFFFFE0FF;
  }

  if (a1 == 268435459 || a1 == 16) {
    goto LABEL_10;
  }
}

BOOL __CFMachPortCheck(mach_port_name_t name)
{
  kern_return_t v1;
  mach_port_type_t ptype;
  uint64_t v5;
  uint64_t v5 = *MEMORY[0x1895F89C0];
  mach_port_type_t ptype = 0;
  unsigned int v1 = mach_port_type(*MEMORY[0x1895FBBE0], name, &ptype);
  return (ptype & 0x70000) != 0 && v1 == 0;
}

void OUTLINED_FUNCTION_0_6(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_1_4( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void __CFMessagePortDeallocate(char *ms)
{
  unint64_t v2 = (unint64_t *)(ms + 8);
  unint64_t v3 = atomic_load((unint64_t *)ms + 1);
  do
  {
    unint64_t v4 = __ldaxr(v2);
    if (v4 == v3)
    {
      if (!__stlxr(v3 | 8, v2))
      {
        int v5 = 1;
        goto LABEL_7;
      }
    }

    else
    {
      __clrex();
    }

    int v5 = 0;
LABEL_7:
    unint64_t v3 = v4;
  }

  while (!v5);
  CFMessagePortInvalidate((CFMessagePortRef)ms);
  unint64_t v6 = (const void *)*((void *)ms + 4);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)ms + 2);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (__CFMachPort *)*((void *)ms + 3);
  if (v8)
  {
    mach_port_t Port = CFMachPortGetPort(v8);
    char v10 = atomic_load((unint64_t *)ms + 1);
    _cfmp_record_deallocation(1, Port, (v10 & 2) != 0, (v10 & 2) != 0);
    CFMachPortInvalidate(*((CFMachPortRef *)ms + 3));
    CFRelease(*((CFTypeRef *)ms + 3));
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (__CFAllRemoteMessagePorts)
  {
    CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)__CFAllRemoteMessagePorts);
    uint64_t v12 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * Count, 0LL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)__CFAllRemoteMessagePorts, 0LL, v12);
    if (Count < 1)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      if (v12) {
        goto LABEL_23;
      }
    }

    else
    {
      CFRunLoopSourceContext v13 = v12;
      CFIndex v14 = Count;
      do
      {
        uint64_t v15 = *v13++;
        CFRetain(v15);
        --v14;
      }

      while (v14);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      uint64_t v16 = (CFMessagePortRef *)v12;
      do
      {
        CFMessagePortIsValid(*v16);
        CFMessagePortRef v17 = *v16++;
        CFRelease(v17);
        --Count;
      }

      while (Count);
LABEL_23:
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  }

CFStringRef __CFMessagePortCopyDescription(unint64_t *cf)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unint64_t v2 = cf + 1;
  char v3 = atomic_load(cf + 1);
  if ((v3 & 4) == 0)
  {
    unint64_t v4 = cf[16];
    if (v4)
    {
      int v5 = (uint64_t (*)(void))cf[19];
      if (v5)
      {
        CFStringRef v6 = (CFStringRef)v5();
        if (v6)
        {
LABEL_7:
          uint64_t v7 = (void *)cf[12];
          if (!v7) {
            uint64_t v7 = (void *)cf[13];
          }
          dli_smach_port_name_t name = "???";
          if (dladdr(v7, &v23))
          {
            if (v23.dli_sname && v23.dli_saddr == v7) {
              dli_smach_port_name_t name = v23.dli_sname;
            }
          }

          CFAllocatorRef v10 = CFGetAllocator(cf);
          char v11 = atomic_load(cf + 1);
          if ((v11 & 1) != 0) {
            uint64_t v12 = "Yes";
          }
          else {
            uint64_t v12 = "No";
          }
          char v13 = atomic_load(cf + 1);
          if ((v13 & 4) != 0) {
            CFIndex v14 = "Yes";
          }
          else {
            CFIndex v14 = "No";
          }
          uint64_t v15 = @"<no description>";
          if (v6) {
            uint64_t v15 = v6;
          }
          CFStringRef v16 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, name = %@, source = %p, callout = %s (%p), context = %@}",  cf,  v10,  "Maybe",  v12,  v14,  cf[2],  cf[7],  dli_sname,  v7,  v15);
          if (v6) {
            CFRelease(v6);
          }
          return v16;
        }

        unint64_t v4 = cf[16];
      }
    }

    CFStringRef v6 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFMessagePort context %p>",  v4);
    goto LABEL_7;
  }

  CFAllocatorRef v18 = CFGetAllocator(cf);
  char v19 = atomic_load(v2);
  unint64_t v20 = "Yes";
  if ((v19 & 1) != 0) {
    unint64_t v21 = "Yes";
  }
  else {
    unint64_t v21 = "No";
  }
  char v22 = atomic_load(v2);
  if ((v22 & 4) == 0) {
    unint64_t v20 = "No";
  }
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, mach_port_name_t name = %@}",  cf,  v18,  "Maybe",  v21,  v20,  cf[2]);
}

CFTypeID CFMessagePortGetTypeID(void)
{
  return 35LL;
}

CFMessagePortRef CFMessagePortCreateLocal( CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMessagePortRef)__CFMessagePortCreateLocal( allocator,  name,  (uint64_t)callout,  (__int128 *)&context->version,  shouldFreeInfo,  0,  0LL);
}

CFTypeRef __CFMessagePortCreateLocal( const __CFAllocator *a1, const __CFString *a2, uint64_t a3, __int128 *a4, _BYTE *a5, int a6, uint64_t a7)
{
  kern_return_t v44;
  kern_return_t v45;
  os_log_s *v46;
  os_log_s *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  os_log_s *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  kern_return_t inserted;
  int v64;
  os_log_s *v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  int v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  uint64_t (*v76)(uint64_t);
  __CFDictionary *Mutable;
  os_log_s *v79;
  const char *v80;
  CFTypeRef cf[2];
  __int128 v82;
  uint64_t v83;
  mach_port_t sp;
  mach_port_t special_port;
  void *ptr;
  uint8_t buf[4];
  kern_return_t v88;
  __int16 v89;
  kern_return_t v90;
  __int16 v91;
  const char *v92;
  __int16 v93;
  mach_port_t v94;
  __int16 v95;
  void *v96;
  uint64_t v97;
  unint64_t v97 = *MEMORY[0x1895F89C0];
  ptr = 0LL;
  if (a5) {
    *a5 = 1;
  }
  if (a2) {
    CFStringRef SanitizedStringName = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  }
  else {
    CFStringRef SanitizedStringName = 0LL;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (a6) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = SanitizedStringName == 0LL;
  }
  int v15 = !v14;
  if (!v14
    && __CFAllLocalMessagePorts
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
  {
    CFRetain(cf[0]);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    CFRelease(SanitizedStringName);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    if (CFMessagePortIsValid((CFMessagePortRef)cf[0])) {
      return cf[0];
    }
    CFStringRef v16 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      __CFMessagePortCreateLocal_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    CFTypeRef v24 = cf[0];
    goto LABEL_62;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 144LL, 0LL, v25, v26, v27, v28);
  if (!Instance)
  {
    if (SanitizedStringName) {
      CFRelease(SanitizedStringName);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    __int16 v47 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      __CFMessagePortCreateLocal_cold_1(v47, v48, v49, v50, v51, v52, v53, v54);
    }
    return 0LL;
  }

  uint64_t v30 = Instance;
  uint64_t v31 = (unint64_t *)(Instance + 8);
  unint64_t v32 = atomic_load((unint64_t *)(Instance + 8));
  do
  {
    unint64_t v33 = __ldaxr(v31);
    if (v33 == v32)
    {
      if (!__stlxr(v32 & 0xFFFFFFFFFFFFFFFELL, v31))
      {
        int v34 = 1;
        goto LABEL_26;
      }
    }

    else
    {
      __clrex();
    }

    int v34 = 0;
LABEL_26:
    unint64_t v32 = v33;
  }

  while (!v34);
  unint64_t v35 = atomic_load(v31);
  do
  {
    unint64_t v36 = __ldaxr(v31);
    if (v36 == v35)
    {
      if (!__stlxr(v35 & 0xFFFFFFFFFFFFFFFDLL, v31))
      {
        int v37 = 1;
        goto LABEL_33;
      }
    }

    else
    {
      __clrex();
    }

    int v37 = 0;
LABEL_33:
    unint64_t v35 = v36;
  }

  while (!v37);
  unint64_t v38 = atomic_load(v31);
  do
  {
    unint64_t v39 = __ldaxr(v31);
    if (v39 == v38)
    {
      if (!__stlxr(v38 & 0xFFFFFFFFFFFFFFFBLL, v31))
      {
        int v40 = 1;
        goto LABEL_40;
      }
    }

    else
    {
      __clrex();
    }

    int v40 = 0;
LABEL_40:
    unint64_t v38 = v39;
  }

  while (!v40);
  *(_DWORD *)(Instance + 112) = 0;
  *(void *)(Instance + 16) = SanitizedStringName;
  if (a6) {
    *(_DWORD *)(Instance + 44) = getpid();
  }
  *(void *)(v30 + 96) = a3;
  *(void *)(v30 + 104) = a7;
  if (!SanitizedStringName) {
    goto LABEL_73;
  }
  mach_port_name_t v41 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  task_get_special_port(*MEMORY[0x1895FBBE0], 4, &special_port);
  if (!a6 && !bootstrap_check_in(special_port, (const char *)ptr, &sp))
  {
    uint64_t inserted = mach_port_insert_right(*v41, sp, sp, 0x14u);
    if (inserted)
    {
      CFTypeID v64 = inserted;
      int v65 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        __CFMessagePortCreateLocal_cold_3((int *)&sp, v64, v65);
      }
      mach_port_mod_refs(*v41, sp, 1u, -1);
      goto LABEL_61;
    }

    cf[0] = 0LL;
    int v82 = 0u;
    CFTypeID v83 = 0LL;
    cf[1] = (CFTypeRef)v30;
    int v66 = _CFMachPortCreateWithPort3(a1, sp, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)cf, 0LL);
    if (!v66)
    {
      unint64_t v79 = (os_log_s *)_CFOSLog();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR)) {
        __CFMessagePortCreateLocal_cold_2((int *)&sp, v79);
      }
      mach_port_mod_refs(*v41, sp, 1u, -1);
      mach_port_deallocate(*v41, sp);
      goto LABEL_61;
    }

    mach_port_name_t v43 = (__CFMachPort *)v66;
    unint64_t v67 = atomic_load(v31);
    while (1)
    {
      int v68 = __ldaxr(v31);
      if (v68 != v67) {
        break;
      }
      if (__stlxr(v67 | 2, v31)) {
        goto LABEL_70;
      }
      CFTypeID v69 = 1;
LABEL_71:
      unint64_t v67 = v68;
      if (v69) {
        goto LABEL_72;
      }
    }

    __clrex();
LABEL_70:
    CFTypeID v69 = 0;
    goto LABEL_71;
  }

  cf[0] = 0LL;
  int v82 = 0u;
  CFTypeID v83 = 0LL;
  cf[1] = (CFTypeRef)v30;
  CFIndex v42 = (__CFMachPort *)_CFMachPortCreate3(a1, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)cf, 0LL);
  if (!v42)
  {
    CFRange v55 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      __CFMessagePortCreateLocal_cold_4(v55, v56, v57, v58, v59, v60, v61, v62);
    }
LABEL_61:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    CFTypeRef v24 = (CFTypeRef)v30;
LABEL_62:
    CFRelease(v24);
    return 0LL;
  }

  mach_port_name_t v43 = v42;
  sp = CFMachPortGetPort(v42);
  int v44 = bootstrap_register2();
  if (v44)
  {
    unsigned int v45 = v44;
    uint64_t v46 = (os_log_s *)_CFOSLog();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      int64_t v80 = bootstrap_strerror(v45);
      *(_DWORD *)buf = 67110146;
      uint64_t v88 = v45;
      int v89 = 1024;
      unint64_t v90 = v45;
      unint64_t v91 = 2080;
      CFIndex v92 = v80;
      char v93 = 1024;
      unint64_t v94 = sp;
      CFIndex v95 = 2080;
      int32_t v96 = ptr;
      _os_log_error_impl( &dword_180A4C000,  v46,  OS_LOG_TYPE_ERROR,  "*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, mach_port_name_t name = '%s'\n See /usr/include/servers/bootstrap_defs.h for the error codes.",  buf,  0x28u);
    }

    CFMachPortInvalidate(v43);
    CFRelease(v43);
    goto LABEL_61;
  }

CFTypeRef CFMessagePortCreatePerProcessLocal( const __CFAllocator *a1, const __CFString *a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return __CFMessagePortCreateLocal(a1, a2, a3, a4, a5, 1, 0LL);
}

CFTypeRef _CFMessagePortCreateLocalEx( const __CFAllocator *a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, __int128 *a6, _BYTE *a7)
{
  return __CFMessagePortCreateLocal(a1, a2, 0LL, a6, a7, a3, a5);
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)__CFMessagePortCreateRemote(allocator, name, 0, 0);
}

CFTypeRef __CFMessagePortCreateRemote(const __CFAllocator *a1, const __CFString *a2, int a3, int a4)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  ptr = 0LL;
  CFStringRef SanitizedStringName = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  if (!SanitizedStringName) {
    return 0LL;
  }
  CFStringRef v8 = SanitizedStringName;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!a3
    && __CFAllRemoteMessagePorts
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, (const void **)&value))
  {
    CFRetain((CFTypeRef)value.version);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    CFRelease(v8);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    int IsValid = CFMessagePortIsValid((CFMessagePortRef)value.version);
    CFIndex version = value.version;
    if (IsValid) {
      return (CFTypeRef)version;
    }
LABEL_29:
    uint64_t v25 = (const void *)version;
    goto LABEL_30;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 104LL, 0LL, v9, v10, v11, v12);
  CFIndex version = Instance;
  if (!Instance)
  {
    CFRelease(v8);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    return (CFTypeRef)version;
  }

  int v15 = (unint64_t *)(Instance + 8);
  unint64_t v16 = atomic_load((unint64_t *)(Instance + 8));
  do
  {
    unint64_t v17 = __ldaxr(v15);
    if (v17 == v16)
    {
      if (!__stlxr(v16 & 0xFFFFFFFFFFFFFFFELL, v15))
      {
        int v18 = 1;
        goto LABEL_10;
      }
    }

    else
    {
      __clrex();
    }

    int v18 = 0;
LABEL_10:
    unint64_t v16 = v17;
  }

  while (!v18);
  unint64_t v19 = atomic_load(v15);
  do
  {
    unint64_t v20 = __ldaxr(v15);
    if (v20 == v19)
    {
      if (!__stlxr(v19 & 0xFFFFFFFFFFFFFFFDLL, v15))
      {
        int v21 = 1;
        goto LABEL_17;
      }
    }

    else
    {
      __clrex();
    }

    int v21 = 0;
LABEL_17:
    unint64_t v19 = v20;
  }

  while (!v21);
  unint64_t v22 = atomic_load(v15);
  do
  {
    unint64_t v23 = __ldaxr(v15);
    if (v23 == v22)
    {
      if (!__stlxr(v22 | 4, v15))
      {
        int v24 = 1;
        goto LABEL_24;
      }
    }

    else
    {
      __clrex();
    }

    int v24 = 0;
LABEL_24:
    unint64_t v22 = v23;
  }

  while (!v24);
  *(_DWORD *)(Instance + 112) = 0;
  *(void *)(Instance + 16) = v8;
  *(void *)(Instance + 32) = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
  if (a3) {
    *(_DWORD *)(version + 44) = a4;
  }
  value.CFIndex version = 0LL;
  value.info = (void *)version;
  memset(&value.retain, 0, 24);
  task_get_special_port(*MEMORY[0x1895FBBE0], 4, &special_port);
  if (bootstrap_look_up2())
  {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    goto LABEL_29;
  }

  CFMachPortRef v28 = CFMachPortCreateWithPort(a1, portNum, (CFMachPortCallBack)__CFMessagePortDummyCallback, &value, 0LL);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  if (!v28) {
    goto LABEL_29;
  }
  *(void *)(version + 24) = v28;
  unint64_t v29 = atomic_load((unint64_t *)(version + 8));
  while (2)
  {
    unint64_t v30 = __ldaxr(v15);
    if (v30 == v29)
    {
      if (!__stlxr(v29 | 1, v15))
      {
        int v31 = 1;
        goto LABEL_45;
      }
    }

    else
    {
      __clrex();
    }

    int v31 = 0;
LABEL_45:
    unint64_t v29 = v30;
    if (!v31) {
      continue;
    }
    break;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!a3)
  {
    if (!__CFAllRemoteMessagePorts) {
      goto LABEL_51;
    }
    if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, &cf))
    {
      CFRetain(cf);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      CFRelease((CFTypeRef)version);
      return cf;
    }

    CFMutableStringRef Mutable = (__CFDictionary *)__CFAllRemoteMessagePorts;
    if (!__CFAllRemoteMessagePorts)
    {
LABEL_51:
      CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  0LL);
      __CFAllRemoteMessagePorts = (uint64_t)Mutable;
    }

    CFDictionaryAddValue(Mutable, v8, (const void *)version);
  }

  CFRetain(v28);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  CFMachPortSetInvalidationCallBack(v28, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  if (CFMachPortIsValid(v28))
  {
    CFRelease(v28);
    return (CFTypeRef)version;
  }

  CFRelease((CFTypeRef)version);
  uint64_t v25 = v28;
LABEL_30:
  CFRelease(v25);
  return 0LL;
}

CFTypeRef CFMessagePortCreatePerProcessRemote(const __CFAllocator *a1, const __CFString *a2, int a3)
{
  return __CFMessagePortCreateRemote(a1, a2, 1, a3);
}

Boolean CFMessagePortIsRemote(CFMessagePortRef ms)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  unsigned int v3 = atomic_load((unint64_t *)ms + 1);
  return (v3 >> 2) & 1;
}

CFStringRef CFMessagePortGetName(CFMessagePortRef ms)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  return (CFStringRef)*((void *)ms + 2);
}

Boolean CFMessagePortSetName(CFMessagePortRef ms, CFStringRef newName)
{
  ptr[1] = *(void **)MEMORY[0x1895F89C0];
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  CFAllocatorRef v5 = CFGetAllocator(ms);
  ptr[0] = 0LL;
  if (*((_DWORD *)ms + 11)) {
    goto LABEL_14;
  }
  CFStringRef v6 = (unint64_t *)((char *)ms + 8);
  char v7 = atomic_load((unint64_t *)ms + 1);
  if ((v7 & 4) != 0) {
    goto LABEL_14;
  }
  CFStringRef v8 = v5;
  CFStringRef SanitizedStringName = __CFMessagePortCreateSanitizedStringName(newName, (UInt8 **)ptr);
  if (!SanitizedStringName) {
    return SanitizedStringName;
  }
  CFStringRef v10 = SanitizedStringName;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (__CFAllLocalMessagePorts
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, v10, (const void **)value))
  {
    uint64_t v11 = (os_unfair_lock_s *)&__CFAllMessagePortsLock;
LABEL_13:
    os_unfair_lock_unlock(v11);
    CFRelease(v10);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
LABEL_14:
    LOBYTE(SanitizedStringName) = 0;
    return SanitizedStringName;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  if (*((void *)ms + 8))
  {
    CFLog( 7LL,  (uint64_t)@"*** CFMessagePort: Unable to SetName on CFMessagePort %p as it already has a dispatch queue associated with itself.",  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)ms);
LABEL_12:
    uint64_t v11 = (os_unfair_lock_s *)((char *)ms + 112);
    goto LABEL_13;
  }

  int v18 = dyld_program_sdk_at_least();
  unint64_t v19 = (const void *)*((void *)ms + 2);
  if (v18)
  {
    if (v19) {
      goto LABEL_12;
    }
  }

  else if (v19)
  {
    if (CFEqual(v19, v10))
    {
      CFRelease(v10);
      goto LABEL_48;
    }

    int v21 = (__CFMachPort **)((char *)ms + 24);
    unint64_t v20 = (__CFMachPort *)*((void *)ms + 3);
    if (*((void *)ms + 2))
    {
      unint64_t v40 = atomic_load(v6);
      uint64_t v42 = (v40 >> 1) & 1;
    }

    else
    {
      LODWORD(v42) = 0;
    }

    goto LABEL_21;
  }

  LODWORD(v42) = 0;
  int v21 = (__CFMachPort **)((char *)ms + 24);
  unint64_t v20 = (__CFMachPort *)*((void *)ms + 3);
LABEL_21:
  unint64_t v22 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  task_get_special_port(*MEMORY[0x1895FBBE0], 4, &special_port);
  if (mach_port_insert_right(*v22, sp, sp, 0x14u))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    mach_port_mod_refs(*v22, sp, 1u, -1);
LABEL_28:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
    CFRelease(v10);
    goto LABEL_14;
  }

  value[0] = 0LL;
  __int128 v44 = 0u;
  uint64_t v45 = 0LL;
  value[1] = ms;
  uint64_t v33 = _CFMachPortCreateWithPort3(v8, sp, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)value, 0LL);
  int v24 = (__CFMachPort *)v33;
  unint64_t v34 = atomic_load((unint64_t *)ms + 1);
  do
  {
    unint64_t v35 = __ldaxr(v6);
    if (v35 == v34)
    {
      if (!__stlxr(v34 | 2, v6))
      {
        char v36 = 1;
        goto LABEL_35;
      }
    }

    else
    {
      __clrex();
    }

    char v36 = 0;
LABEL_35:
    unint64_t v34 = v35;
  }

  while ((v36 & 1) == 0);
  if (v33) {
    goto LABEL_37;
  }
LABEL_22:
  value[0] = 0LL;
  __int128 v44 = 0u;
  uint64_t v45 = 0LL;
  value[1] = ms;
  unint64_t v23 = (__CFMachPort *)_CFMachPortCreate3(v8, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)value, 0LL);
  if (!v23)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    goto LABEL_28;
  }

  int v24 = v23;
  mach_port_t sp = CFMachPortGetPort(v23);
  uint64_t v25 = bootstrap_register2();
  if ((_DWORD)v25)
  {
    uint64_t v26 = v25;
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    bootstrap_strerror(v26);
    CFLog( 7LL,  (uint64_t)@"*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, mach_port_name_t name = '%s'\nSee /usr/include/servers/bootstrap_defs.h for the error codes.",  v27,  v28,  v29,  v30,  v31,  v32,  v26);
    CFMachPortInvalidate(v24);
    CFRelease(v24);
    goto LABEL_28;
  }

LABEL_37:
  CFMachPortSetInvalidationCallBack(v24, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  *int v21 = v24;
  if (v20 && v20 != v24)
  {
    if ((_DWORD)v42)
    {
      if (*((void *)ms + 8)) {
        CFMessagePortSetName_cold_1();
      }
      mach_port_t Port = CFMachPortGetPort(v20);
      mach_port_mod_refs(*v22, Port, 1u, -1);
      mach_port_deallocate(*v22, Port);
    }

    CFMachPortInvalidate(v20);
    CFRelease(v20);
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  CFMutableStringRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
  if (!__CFAllLocalMessagePorts)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  0LL);
    __CFAllLocalMessagePorts = (uint64_t)Mutable;
  }

  unint64_t v39 = (const void *)*((void *)ms + 2);
  if (v39)
  {
    CFDictionaryRemoveValue(Mutable, v39);
    CFRelease(*((CFTypeRef *)ms + 2));
    CFMutableStringRef Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
  }

  *((void *)ms + 2) = v10;
  CFDictionaryAddValue(Mutable, v10, ms);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
LABEL_48:
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
  LOBYTE(SanitizedStringName) = 1;
  return SanitizedStringName;
}

      *((void *)&v52 + v18++) = v23;
      goto LABEL_38;
    }

    if (!*((_BYTE *)v23 + 12)) {
      goto LABEL_31;
    }
    if (v23[2] == 1)
    {
      *((_BYTE *)v23 + 12) = 0;
LABEL_31:
      uint64_t v32 = (_DWORD *)__CFStorageDeleteUnfrozen(a1, a2);
      goto LABEL_36;
    }

    uint64_t v32 = __CFStorageDeleteFrozen((const __CFAllocator *)a1, a2, (uint64_t *)v23, v31 - v19, v30);
LABEL_36:
    unint64_t v23 = v32;
    if (v32) {
      goto LABEL_37;
    }
LABEL_38:
    ++v20;
    unint64_t v19 = v26;
  }

  while (v20 != 3);
  *(void *)v7 -= a5;
  unint64_t v35 = *(void *)(v7 + 16);
  char v36 = (unsigned int *)(v35 + 8);
  if (*(_DWORD *)(v35 + 8))
  {
    do
    {
      int v37 = __ldxr(v36);
      uint64_t v38 = v37 - 1;
    }

    while (__stxr(v38, v36));
    if (!v38) {
      __CFStorageDeallocateNode((const void *)a2, v35);
    }
  }

  unint64_t v39 = *(void *)(v7 + 24);
  if (v39)
  {
    unint64_t v40 = (unsigned int *)(v39 + 8);
    if (*(_DWORD *)(v39 + 8))
    {
      do
      {
        mach_port_name_t v41 = __ldxr(v40);
        uint64_t v42 = v41 - 1;
      }

      while (__stxr(v42, v40));
      if (!v42) {
        __CFStorageDeallocateNode((const void *)a2, v39);
      }
    }
  }

  mach_port_name_t v43 = *(void *)(v7 + 32);
  if (v43)
  {
    __int128 v44 = (unsigned int *)(v43 + 8);
    if (*(_DWORD *)(v43 + 8))
    {
      do
      {
        uint64_t v45 = __ldxr(v44);
        uint64_t v46 = v45 - 1;
      }

      while (__stxr(v46, v44));
      if (!v46) {
        __CFStorageDeallocateNode((const void *)a2, v43);
      }
    }
  }

  *int v21 = 0LL;
  *(void *)(v7 + 24) = 0LL;
  *(void *)(v7 + 32) = 0LL;
  if (v18 == 1) {
    return v52;
  }
  *(_OWORD *)int v21 = v52;
  *(void *)(v7 + 32) = v53;
LABEL_65:
  __int16 v49 = *(_DWORD *)(v7 + 8);
  if (v49) {
    *(_DWORD *)(v7 + _Block_object_dispose((const void *)(v28 - 104), 8) = v49 + 1;
  }
  return v7;
}

  if ((a4 & 0x90) == 0) {
    goto LABEL_51;
  }
  uint64_t v26 = v113;
  if (v15)
  {
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, v15);
    if (!BitmapPtrForPlane) {
      goto LABEL_51;
    }
  }

  else
  {
    BitmapPtrForPlane = __CFStringFoldCharacterClusterAtIndex_decompBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_decompBMP) {
      goto LABEL_51;
    }
  }

  if (((*(unsigned __int8 *)(BitmapPtrForPlane + (v26 >> 3)) >> (v26 & 7)) & 1) != 0)
  {
    uint64_t v28 = v113;
    uint64_t v29 = CFUniCharDecomposeCharacter(v113, a6, 64LL);
    int v18 = v29;
    uint64_t v30 = *a6;
    CFTypeID v113 = *a6;
    if ((a4 & 0x80) != 0 && v30 < 0x510)
    {
      int v18 = 1LL;
    }

    else if ((a4 & 0x10) != 0)
    {
      if (v111 && !v29) {
        *unint64_t v111 = 1;
      }
    }

    else
    {
      int v18 = 0LL;
      CFTypeID v113 = v28;
    }
  }

  int v37 = 0;
  uint64_t v38 = 32;
  do
  {
    unint64_t v39 = v38;
    v38 >>= 1;
    v37 += a3 & 1;
    a3 >>= 1;
  }

  while ((v39 & 2) == 0);
  unint64_t v40 = (CFIndex *)(a4 + 16LL * v37);
  mach_port_name_t v41 = *v40;
  uint64_t v42 = v40[1];
  if ((a6 & 0x20) == 0)
  {
    mach_port_name_t v43 = 0LL;
LABEL_52:
    __int16 v49 = 1;
LABEL_53:
    v134.CFIndex location = v41;
    v134.size_t length = v42;
    CFRange v55 = CFStringCreateWithSubstring(a1, a2, v134);
    goto LABEL_54;
  }

  __int128 v44 = 0;
  uint64_t v45 = 32;
  do
  {
    uint64_t v46 = v45;
    v45 >>= 1;
    v44 += a6 & 1;
    a6 >>= 1;
  }

  while ((v46 & 2) == 0);
  __int16 v47 = (CFRange *)&a7[2 * v44];
  CFIndex location = v47->location;
  mach_port_name_t v43 = v47->length;
  if (v47->location == -1) {
    goto LABEL_52;
  }
  if (!v42)
  {
    CFRange v55 = CFStringCreateWithSubstring(a1, a5, *v47);
    __int16 v49 = 0;
    goto LABEL_54;
  }

  __int16 v49 = 0;
  if (CFStringGetCharacterAtIndex(a2, v41) == 47 || !v43) {
    goto LABEL_53;
  }
  uint64_t v50 = (UniChar *)CFAllocatorAllocate(a1, 2 * (v43 + v42) + 2, 0LL);
  if (v50)
  {
    uint64_t v51 = (char *)v50;
    v125.CFIndex location = location;
    v125.size_t length = v43;
    CFStringGetCharacters(a5, v125, v50);
    CFRange v52 = 2 * v43;
    while (1)
    {
      int v53 = (UniChar *)&v51[v52];
      v52 -= 2LL;
      if (!v52) {
        break;
      }
      if (*(v53 - 1) == 47)
      {
        char v54 = (UniChar *)&v51[v52 + 2];
        goto LABEL_165;
      }
    }

    if (*(_WORD *)v51 == 47) {
      char v54 = v53;
    }
    else {
      char v54 = (UniChar *)v51;
    }
LABEL_165:
    v133.CFIndex location = v41;
    v133.size_t length = v42;
    CFStringGetCharacters(a2, v133, v54);
    unint64_t v116 = &v54[v42];
    *unint64_t v116 = 0;
    CFRange v55 = _resolvedPath(v51, (unint64_t)v116, 47, 0, 0, a1);
    __int16 v49 = 0;
    mach_port_name_t v43 = 1LL;
LABEL_54:
    if (((v49 & 1) != 0 || !v43) && CFStringGetCharacterAtIndex(v55, 0LL) != 47)
    {
      Boolean v56 = numChars;
      if (numChars >= 1024)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        Boolean v56 = 0LL;
        uint64_t numChars = 0LL;
      }

      v117[v56] = 47;
      ++numChars;
    }

    int v57 = CFStringGetLength(v55);
    char v58 = numChars;
    if (v57 < 1025)
    {
      int v59 = v57;
      if (numChars + v57 >= 1025)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        char v58 = 0LL;
        uint64_t numChars = 0LL;
      }

      uint64_t v60 = &v117[v58];
      v126.CFIndex location = 0LL;
      v126.size_t length = v59;
      CFStringGetCharacters(v55, v126, v60);
      numChars += v59;
    }

    else
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        uint64_t numChars = 0LL;
      }

      CFStringAppend(theString, v55);
    }

    CFRelease(v55);
    int v61 = v42 + v41;
    uint64_t v62 = CFStringGetLength(a2);
    char v63 = v62 - v61;
    if (v62 > v61) {
      goto LABEL_97;
    }
    goto LABEL_158;
  }

  uint64_t result = theString;
  if (theString)
  {
    CFRelease(theString);
    return 0LL;
  }

  return result;
}

LABEL_48:
    if (v22 >> 6 < 0x3CD) {
      return v12;
    }
LABEL_49:
    uint64_t v38 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
    unint64_t v39 = (unsigned __int16 *)&unk_180D7D040;
    while (2)
    {
      unint64_t v40 = ((char *)v39 - (char *)v38) >> 3;
      mach_port_name_t v41 = &v38[2 * v40];
      uint64_t v42 = *v41;
      if (v42 > (unsigned __int16)v22)
      {
        unint64_t v39 = v41 - 2;
        goto LABEL_55;
      }

      if (v42 < (unsigned __int16)v22)
      {
        uint64_t v38 = v41 + 2;
LABEL_55:
        if (v38 > v39) {
          return v12;
        }
        continue;
      }

      break;
    }

    mach_port_name_t v43 = __CFFromEmojiIndex(v38[2 * v40 + 1], __src);
    __int128 v44 = v43;
    if (!a5) {
      goto LABEL_60;
    }
    if (a5 - v11 < v43) {
      break;
    }
    memcpy(a4, __src, 2 * v43);
    a4 += v44;
    uint64_t v11 = *a6;
LABEL_60:
    v11 += v44;
    *a6 = v11;
    v12 += 2LL;
    a2 += 2;
    uint64_t v9 = v20;
  }

  while (v9 > 0);
  return v12;
}

    if ((_DWORD)v15 == 8254 || (_DWORD)v15 == 165)
    {
      CFStringRef v10 = v11 != 2;
      if (v11 == 2) {
        int v18 = 1LL;
      }
      else {
        int v18 = 4LL;
      }
      if (a5)
      {
        if (a5 - v12 < v18) {
          break;
        }
        if (v11 != 2)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 18984;
          a4 += 3;
        }

        if ((_DWORD)v15 == 165) {
          unint64_t v19 = 92;
        }
        else {
          unint64_t v19 = 126;
        }
        *a4++ = v19;
      }

      uint64_t v11 = 2;
      goto LABEL_147;
    }

    unint64_t v75 = v10;
    unint64_t v20 = __CFToEmojiIndex(v14, v8 - v13, v78);
    if (v20 != -1)
    {
      int v21 = __CFKDDITable[v20];
      CFStringRef v10 = v11 != 1;
      if (v11 == 1) {
        unint64_t v22 = 0LL;
      }
      else {
        unint64_t v22 = 3LL;
      }
      if (v20 == 613)
      {
        unint64_t v23 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
        int v24 = strlen(v23);
        int v18 = v24 + v22;
        if (!a5)
        {
          CFStringRef v10 = v11 != 1;
LABEL_106:
          v13 += v78[0];
          uint64_t v11 = 1;
          a2 = v76;
          goto LABEL_148;
        }

        CFStringRef v10 = v11 != 1;
        if (a5 - v12 >= v18)
        {
          if (v11 != 1)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 16932;
            a4 += 3;
          }

          if (v24 >= 1)
          {
            uint64_t v25 = (unsigned __int8 *)&v23[v24];
            do
            {
              uint64_t v26 = *(unsigned __int8 *)v23;
              uint64_t v27 = *((unsigned __int8 *)v23 + 1);
              uint64_t v28 = v27 | (v26 << 8);
              uint64_t v29 = (unsigned __int16)((v27 | ((_WORD)v26 << 8)) + 3264);
              uint64_t v30 = (v28 - 1536) >> 8;
              if (v29 <= 0x14D) {
                LOBYTE(v26) = v30;
              }
              if ((v26 & 0xE0) >= 0xA0) {
                uint64_t v31 = 79;
              }
              else {
                uint64_t v31 = 15;
              }
              uint64_t v32 = 2 * (v31 + v26);
              uint64_t v33 = v32 | 1;
              unint64_t v34 = v27 + ((char)v27 >> 7);
              unint64_t v35 = (v27 + ((char)v27 >> 7));
              char v36 = v32 + 2;
              int v37 = v35 > 0x9D;
              if (v35 <= 0x9D) {
                uint64_t v38 = v33;
              }
              else {
                uint64_t v38 = v36;
              }
              if (v37) {
                unint64_t v39 = 3;
              }
              else {
                unint64_t v39 = 97;
              }
              *a4 = v38 & 0x7F;
              a4[1] = (v39 + v34) & 0x7F;
              a4 += 2;
              v23 += 2;
            }

            while (v23 < (const char *)v25);
          }

          goto LABEL_106;
        }
      }

      else
      {
        uint64_t v45 = v21 >> 8;
        else {
          LOBYTE(v46) = v45;
        }
        if ((v46 & 0xE0) >= 0xA0) {
          __int16 v47 = 79;
        }
        else {
          __int16 v47 = 15;
        }
        int v48 = v47 + v46;
        __int16 v49 = v21 + ((char)v21 >> 7);
        else {
          uint64_t v50 = 2 * v48 + 2;
        }
        else {
          uint64_t v51 = 3;
        }
        int v18 = v22 + 2;
        if (!a5) {
          goto LABEL_106;
        }
        if (a5 - v12 >= v18)
        {
          if (v11 != 1)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 16932;
            a4 += 3;
          }

          *a4 = v50 & 0x7F;
          a4[1] = (v51 + v49) & 0x7F;
          a4 += 2;
          goto LABEL_106;
        }
      }

                    objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec",  0LL));
                    goto LABEL_263;
                  }

                  mach_port_name_t v43 = -1LL;
                }

                else
                {
                  mach_port_name_t v43 = v40 == 60;
                }

                v42 += v43;
                unint64_t v40 = v10[v41++ + 4];
              }

              while (v40);
            }

  uint64_t v25 = (unsigned __int16)v22;
  if (!(_WORD)v22
    || ((uint64_t v26 = __CFBasicHashTableSizes[BYTE2(v22)], v26 >= 20) ? (v27 = (unint64_t)v26 >> 2 > v25) : (v27 = 1),
        !v27))
  {
    int v24 = 0LL;
    goto LABEL_45;
  }

        if (v19 != 0x7FFFFFFFFFFFFFFFLL)
        {
          int v37 = self->_vertices;
          uint64_t v38 = &v37[v19];
          unint64_t v39 = v38->var1;
          if (v39)
          {
            unint64_t v40 = 0LL;
            mach_port_name_t v41 = &v37[v19];
            __int128 v44 = v41->var2;
            mach_port_name_t v43 = &v41->var2;
            uint64_t v42 = v44;
            uint64_t v45 = self->_dump;
            while (1)
            {
              uint64_t v46 = v42[v40];
              if (v46 != v45) {
                break;
              }
              if (v39 == ++v40) {
                goto LABEL_46;
              }
            }

            __int16 v47 = &self->_edges[v46];
            if (v47->var2 == 0x7FFFFFFFFFFFFFFFLL)
            {
              v4[v6++] = v47;
              v47->var2 = v19;
              uint64_t v45 = self->_dump;
              uint64_t v42 = *v43;
            }

            v42[v40] = v45;
            --v38->var0;
          }
        }

    if (v14 < v18 && v20 <= 0xF) {
      break;
    }
    if (v14 < v18) {
      uint64_t v25 = v13;
    }
    else {
      uint64_t v25 = v13 + 1;
    }
    mdict_rehashd((uint64_t)v44, v25);
    uint64_t v13 = (unint64_t)v9[1] >> 58;
    LODWORD(v14) = __NSDictionarySizes_0[v13];
  }

  uint64_t v26 = *(void **)(v17 + 8 * v14);
  uint64_t v27 = v17 + 8 * v18;
  if ((v43 & 0x200000000000000LL) != 0) {
    [v44 willChangeValueForKey:v5];
  }
  uint64_t v28 = *(void *)(v27 + 8 * v14);
  if (v26 == &___NSDictionaryM_DeletedMarker || v26 == 0LL)
  {
    *(void *)(v17 + 8 * v14) = [v5 copyWithZone:0];
    *(void *)(v27 + 8 * v14) = v42;
    uint64_t v30 = v9[1];
    uint64_t v31 = (v30 + 0x100000000LL) & 0x1FFFFFF00000000LL;
    v9[1] = v31 | v30 & 0xFE000000FFFFFFFFLL;
  }

  else
  {
    *(void *)(v27 + 8 * v14) = v42;
  }

  if ((v43 & 0x200000000000000LL) != 0) {
    [v44 didChangeValueForKey:v5];
  }
  if (v28 >= 1) {
}
  }

CFStringRef __CFMessagePortCreateSanitizedStringName(const __CFString *a1, UInt8 **a2)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  unint64_t v4 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 129LL, 0LL);
  v9.size_t length = CFStringGetLength(a1);
  v9.CFIndex location = 0LL;
  CFStringGetBytes(a1, v9, 0x8000100u, 0, 0, v4, 128LL, usedBufLen);
  CFIndex v5 = usedBufLen[0];
  v4[usedBufLen[0]] = 0;
  if (strlen((const char *)v4) != v5)
  {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
    unint64_t v4 = 0LL;
    CFStringRef v6 = 0LL;
    if (!a2) {
      return v6;
    }
LABEL_5:
    *a2 = v4;
    return v6;
  }

  CFStringRef v6 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, v5, 0x8000100u, 0);
  if (a2) {
    goto LABEL_5;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
  return v6;
}

void __CFMessagePortInvalidationCallBack(int a1, CFMessagePortRef ms)
{
  if (ms) {
    CFMessagePortInvalidate(ms);
  }
}

void CFMessagePortGetContext(CFMessagePortRef ms, CFMessagePortContext *context)
{
  unint64_t v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  }
  __int128 v5 = *(_OWORD *)((char *)ms + 120);
  __int128 v6 = *(_OWORD *)((char *)ms + 136);
  context->copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))*((void *)ms + 19);
  *(_OWORD *)&context->CFIndex version = v5;
  *(_OWORD *)&context->CFAllocatorRetainCallBack retain = v6;
}

void CFMessagePortInvalidate(CFMessagePortRef ms)
{
  if (!ms) {
    return;
  }
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  unsigned int v3 = (unint64_t *)((char *)ms + 8);
  char v4 = atomic_load((unint64_t *)ms + 1);
  if ((v4 & 8) == 0) {
    CFRetain(ms);
  }
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  char v5 = atomic_load(v3);
  if ((v5 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    goto LABEL_45;
  }

  uint64_t v6 = *((void *)ms + 8);
  if (v6)
  {
    dispatch_source_cancel(*((dispatch_source_t *)ms + 8));
    *((void *)ms + _Block_object_dispose((const void *)(v28 - 104), 8) = 0LL;
    *((void *)ms + 9) = 0LL;
  }

  uint64_t v28 = v6;
  char v7 = (__CFMachPort *)*((void *)ms + 6);
  CFStringRef v8 = (__CFRunLoopSource *)*((void *)ms + 7);
  CFRange v9 = (dispatch_semaphore_s *)*((void *)ms + 10);
  CFStringRef v10 = (void (*)(CFMessagePortRef, uint64_t))*((void *)ms + 11);
  uint64_t v12 = (const void *)*((void *)ms + 2);
  uint64_t v11 = (__CFMachPort *)*((void *)ms + 3);
  unint64_t v13 = atomic_load((unint64_t *)ms + 1);
  do
  {
    unint64_t v14 = __ldaxr(v3);
    if (v14 == v13)
    {
      if (!__stlxr(v13 & 0xFFFFFFFFFFFFFFFELL, v3))
      {
        int v15 = 1;
        goto LABEL_15;
      }
    }

    else
    {
      __clrex();
    }

    int v15 = 0;
LABEL_15:
    unint64_t v13 = v14;
  }

  while (!v15);
  char v16 = atomic_load(v3);
  if ((v16 & 4) != 0)
  {
    uint64_t v17 = 0LL;
  }

  else
  {
    uint64_t v17 = *((void *)ms + 16);
    *((void *)ms + 16) = 0LL;
  }

  *((void *)ms + 3) = 0LL;
  *((void *)ms + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 0LL;
  *((void *)ms + 6) = 0LL;
  *((void *)ms + 7) = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!*((_DWORD *)ms + 11) && v12)
  {
    int v18 = &__CFAllRemoteMessagePorts;
    char v19 = atomic_load(v3);
    unint64_t v20 = (v19 & 4) != 0 ? &__CFAllRemoteMessagePorts : &__CFAllLocalMessagePorts;
    if (*v20)
    {
      char v21 = atomic_load(v3);
      if ((v21 & 4) == 0) {
        int v18 = &__CFAllLocalMessagePorts;
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)*v18, v12);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (v10) {
    v10(ms, v17);
  }
  char v22 = atomic_load(v3);
  if ((v22 & 4) == 0)
  {
    unint64_t v23 = (void (*)(uint64_t))*((void *)ms + 18);
    if (v23) {
      v23(v17);
    }
  }

  if (v8)
  {
    CFRunLoopSourceInvalidate(v8);
    CFRelease(v8);
  }

  if (v7)
  {
    CFMachPortInvalidate(v7);
    CFRelease(v7);
  }

  if (v11)
  {
    mach_port_t Port = CFMachPortGetPort(v11);
    char v25 = atomic_load(v3);
    if ((v25 & 4) != 0) {
      _cfmp_record_deallocation(1, Port, 1, 0);
    }
    CFMachPortSetInvalidationCallBack(v11, 0LL);
    char v26 = atomic_load(v3);
    _cfmp_record_deallocation(1, Port, (v26 & 2) != 0, (v26 & 2) != 0);
    CFMachPortInvalidate(v11);
    CFRelease(v11);
  }

  if (v9)
  {
    if (v28) {
      dispatch_semaphore_wait(v9, 0xFFFFFFFFFFFFFFFFLL);
    }
    dispatch_release(v9);
  }

Boolean CFMessagePortIsValid(CFMessagePortRef ms)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  char v3 = atomic_load((unint64_t *)ms + 1);
  if ((v3 & 1) == 0) {
    return 0;
  }
  CFRetain(ms);
  char v5 = (__CFMachPort *)*((void *)ms + 3);
  if (v5 && !CFMachPortIsValid(v5) || (uint64_t v6 = (__CFMachPort *)*((void *)ms + 6)) != 0LL && !CFMachPortIsValid(v6))
  {
    CFMessagePortInvalidate(ms);
    Boolean v4 = 0;
  }

  else
  {
    Boolean v4 = 1;
  }

  CFRelease(ms);
  return v4;
}

CFMessagePortInvalidationCallBack CFMessagePortGetInvalidationCallBack(CFMessagePortRef ms)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  }
  return (CFMessagePortInvalidationCallBack)*((void *)ms + 11);
}

void CFMessagePortSetInvalidationCallBack(CFMessagePortRef ms, CFMessagePortInvalidationCallBack callout)
{
  unint64_t v3 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v3 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v3);
  }
  char v4 = atomic_load((unint64_t *)ms + 1);
  if (!callout || (v4 & 1) != 0) {
    *((void *)ms + 11) = callout;
  }
  else {
    ((void (*)(CFMessagePortRef, void))callout)(ms, *((void *)ms + 16));
  }
}

SInt32 CFMessagePortSendRequest( CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
{
  mach_msg_return_t v40;
  mach_port_name_t msgh_local_port;
  uint64_t v42;
  uint64_t v43;
  double v44;
  __objc2_class **Value;
  __objc2_class **v46;
  BOOL v47;
  int v48;
  CFDataRef v49;
  CFDataRef *v50;
  __CFRunLoop *rl;
  __int128 v52;
  CFTypeRef (__cdecl *v53)(CFTypeRef);
  void (__cdecl *v54)(CFTypeRef);
  CFStringRef (*v55)(unint64_t *);
  uint64_t v56;
  Boolean v56 = *MEMORY[0x1895F89C0];
  unint64_t v14 = _CFGetNonObjCTypeID((unint64_t *)remote);
  if (v14 != 35) {
    _CFAssertMismatchedTypeID(0x23uLL, v14);
  }
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  if (data && CFDataGetLength(data) >= 1610612737)
  {
    CFLog( 4LL,  (uint64_t)@"*** CFMessagePortSendRequest: CFMessagePort cannot send more than %lu bytes of data",  v16,  v17,  v18,  v19,  v20,  v21,  1610612736LL);
    return -4;
  }

  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  char v22 = atomic_load((unint64_t *)remote + 1);
  if ((v22 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    return -3;
  }

  uint64_t v50 = returnData;
  rl = Current;
  CFRetain(remote);
  if (!*((void *)remote + 6))
  {
    *(void *)&CFRange v52 = 0LL;
    *((void *)&v52 + 1) = remote;
    int v53 = CFRetain;
    char v54 = CFRelease;
    CFRange v55 = __CFMessagePortCopyDescription;
    int v24 = CFGetAllocator(remote);
    *((void *)remote + 6) = _CFMachPortCreateReply(v24, (uint64_t)__CFMessagePortReplyCallBack, &v52, 0LL);
  }

  int v25 = *((_DWORD *)remote + 10);
  *((_DWORD *)remote + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v25 + 1;
  mach_port_t Port = CFMachPortGetPort(*((CFMachPortRef *)remote + 3));
  if (replyMode)
  {
    mach_port_t v27 = CFMachPortGetPort(*((CFMachPortRef *)remote + 6));
    if (data)
    {
LABEL_11:
      BytePtr = CFDataGetBytePtr(data);
      int Length = CFDataGetLength(data);
      goto LABEL_14;
    }
  }

  else
  {
    mach_port_t v27 = 0;
    if (data) {
      goto LABEL_11;
    }
  }

  BytePtr = 0LL;
  int Length = -1;
LABEL_14:
  Message = __CFMessagePortCreateMessage(0, Port, v27, v25 + 1, msgid, BytePtr, Length);
  if (!Message)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFRelease(remote);
    return -4;
  }

  uint64_t v31 = (mach_msg_header_t *)Message;
  int v32 = ~v25;
  if (replyMode)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32, &__kCFNull);
    uint64_t v33 = CFGetAllocator(remote);
    RunLoopSource = CFMachPortCreateRunLoopSource(v33, *((CFMachPortRef *)remote + 6), -100LL);
    unint64_t v35 = rl;
    if (CFRunLoopContainsSource(rl, RunLoopSource, replyMode))
    {
      char v36 = 1;
    }

    else
    {
      CFRunLoopAddSource(rl, RunLoopSource, replyMode);
      char v36 = 0;
    }
  }

  else
  {
    RunLoopSource = 0LL;
    char v36 = 1;
    unint64_t v35 = rl;
  }

  if (sendTimeout >= 864000.0)
  {
    mach_msg_timeout_t v38 = 0;
    mach_msg_option_t v39 = 1;
  }

  else
  {
    double v37 = sendTimeout * 1000.0;
    if (sendTimeout * 1000.0 < 1.0) {
      double v37 = 0.0;
    }
    mach_msg_timeout_t v38 = vcvtmd_u64_f64(v37);
    mach_msg_option_t v39 = 17;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  unint64_t v40 = mach_msg(v31, v39, v31->msgh_size, 0, 0, v38, 0);
  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  if (!v40)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
    if (replyMode)
    {
      _CFMachPortInstallNotifyPort(v35, replyMode);
      uint64_t v42 = mach_absolute_time();
      mach_port_name_t v43 = __CFTimeIntervalToTSR(rcvTimeout) + v42;
      do
      {
        __int128 v44 = __CFTimeIntervalUntilTSR(v43);
        CFRunLoopRunInMode(replyMode, v44, 1u);
        CFTypeRef Value = (__objc2_class **)CFDictionaryGetValue(*((CFDictionaryRef *)remote + 4), (const void *)v32);
        uint64_t v46 = Value;
        if (Value) {
          __int16 v47 = &__kCFNull == Value;
        }
        else {
          __int16 v47 = 1;
        }
        int v48 = v47;
      }

      while (v47 && v43 >= mach_absolute_time() && CFMessagePortIsValid(remote));
      if ((v36 & 1) == 0) {
        CFRunLoopRemoveSource(rl, RunLoopSource, replyMode);
      }
      if (RunLoopSource) {
        CFRelease(RunLoopSource);
      }
      if (v48)
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
        CFRelease(remote);
        if (CFMessagePortIsValid(remote)) {
          return -2;
        }
        else {
          return -5;
        }
      }

      if (v50)
      {
        if (&__kCFBooleanFalse == v46) {
          __int16 v49 = 0LL;
        }
        else {
          __int16 v49 = (const __CFData *)CFRetain(v46);
        }
        const void *v50 = v49;
      }

      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
    }

    CFRelease(remote);
    return 0;
  }

  if (replyMode)
  {
    if ((v40 - 268435459) <= 4 && ((1 << (v40 - 3)) & 0x13) != 0)
    {
      mach_port_t msgh_local_port = v31->msgh_local_port;
      if (msgh_local_port - 1 <= 0xFFFFFFFD && (v31->msgh_bits & 0x1F00) == 0x1200)
      {
        mach_port_deallocate(*MEMORY[0x1895FBBE0], msgh_local_port);
        v31->mach_port_t msgh_local_port = 0;
      }
    }
  }

  if ((v36 & 1) == 0) {
    CFRunLoopRemoveSource(v35, RunLoopSource, replyMode);
  }
  if (RunLoopSource) {
    CFRelease(RunLoopSource);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
  CFRelease(remote);
  if (v40 == 268435460) {
    return -1;
  }
  else {
    return -4;
  }
}

void __CFMessagePortReplyCallBack(uint64_t a1, int *a2, unint64_t a3, uint64_t a4)
{
  char v7 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  char v14 = atomic_load((unint64_t *)(a4 + 8));
  if ((v14 & 1) == 0) {
    goto LABEL_79;
  }
  if (a3 < 0x18) {
    goto LABEL_3;
  }
  int v22 = *a2;
  if (*a2 < 0)
  {
    if (a3 >= 0x3C)
    {
      LODWORD(v29) = a2[1];
      if (v29 >= 0x3C)
      {
        int v30 = a2[11];
        BOOL v19 = v30 != -252513032 && v30 != -118164752;
        BOOL v17 = a2[6] != 1 || *((unsigned __int8 *)a2 + 39) != 1;
        goto LABEL_56;
      }
    }

    goto LABEL_3;
  }

  if (a2[5] == 1128680784)
  {
    if (a3 >= 0x38)
    {
      unint64_t v23 = 56LL;
      goto LABEL_36;
    }

LABEL_76:
  uint64_t v39 = 11LL;
LABEL_77:
  char v20 = 0;
  if (a2[v39 + 2] >= 0)
  {
LABEL_78:
    CFLog( 4LL,  (uint64_t)@"*** CFMessagePort: dropping corrupt reply Mach message (0b%d%d%d%d%d%d)",  v8,  v9,  v10,  v11,  v12,  v13,  v19);
    mach_msg_destroy((mach_msg_header_t *)a2);
    goto LABEL_79;
  }

    uint64_t v46 = -1LL;
    v47[0] = v7;
    goto LABEL_77;
  }

    __break(1u);
    return;
  }

  if (v8 == 3)
  {
    Bucket_Exponential_Indirect_NoCollisiouint64_t n = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, a3);
    goto LABEL_19;
  }

  if (v8 == 2)
  {
    Bucket_Exponential_Indirect_NoCollisiouint64_t n = ___CFBasicHashFindBucket_Double_NoCollision(cf, a3);
    goto LABEL_19;
  }

  if (v8 != 1) {
    goto LABEL_76;
  }
  Bucket_Exponential_Indirect_NoCollisiouint64_t n = ___CFBasicHashFindBucket_Linear_NoCollision(cf, a3);
LABEL_19:
  uint64_t v10 = Bucket_Exponential_Indirect_NoCollision;
LABEL_20:
  if ((*(void *)(cf + 32) & 2) == 0)
  {
    uint64_t v12 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 39) & 0x1FLL]
                                                                  + 8 * ((*(void *)(cf + 24) >> 34) & 0x1FLL));
    if (v12)
    {
      if (cf < 0)
      {
        uint64_t v13 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v14 = atomic_load((unint64_t *)(cf + 8));
        if (v14 < 0) {
          uint64_t v13 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v13 = (const CFAllocatorRef *)(cf - 16);
        }
      }

      a4 = v12(*v13, a4);
    }
  }

  if ((*(_WORD *)(cf + 18) & 4) != 0 && (*(void *)(cf + 32) & 2) == 0)
  {
    int v15 = *(uint64_t (**)(const CFAllocatorRef, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(cf + 27) >> 5) & 0x1F]
                                                                           + 8 * (*(_DWORD *)(cf + 27) & 0x1FLL));
    if (v15)
    {
      else {
        BOOL v17 = (const CFAllocatorRef *)(cf - 16);
      }
      a3 = v15(*v17, a3);
    }
  }

  BOOL v18 = *(void *)(cf + 40);
  BOOL v19 = *(void *)(v18 + 8 * v10);
  if (a4) {
    char v20 = a4;
  }
  else {
    char v20 = 2814029233LL;
  }
  if (v20 == -1) {
    char v20 = 2780474809LL;
  }
  *(void *)(v18 + 8 * v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v20;
  if ((unint64_t)(v19 + 1) >= 2)
  {
    if (v19 == 2814029233LL) {
      BOOL v19 = 0LL;
    }
    if (v19 == 2780474809LL) {
      uint64_t v21 = -1LL;
    }
    else {
      uint64_t v21 = v19;
    }
    if ((*(void *)(cf + 32) & 2) == 0)
    {
      int v22 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                              + (HIBYTE(*(void *)(cf + 24)) & 0xF8LL))
                                                                 + 8 * ((*(void *)(cf + 24) >> 54) & 0x1FLL));
      if (v22)
      {
        else {
          int v24 = (const CFAllocatorRef *)(cf - 16);
        }
        v22(*v24, v21);
      }
    }
  }

  int v25 = *(unsigned __int16 *)(cf + 18);
  if ((v25 & 4) != 0)
  {
    uint64_t v26 = *(void *)(cf + 8 * ((v25 >> 2) & 1) + 40);
    mach_port_t v27 = *(void *)(v26 + 8 * v10);
    if (a3) {
      uint64_t v28 = a3;
    }
    else {
      uint64_t v28 = 2814029233LL;
    }
    if (v28 == -1) {
      uint64_t v28 = 2780474809LL;
    }
    *(void *)(v26 + 8 * v1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = v28;
    if ((unint64_t)(v27 + 1) >= 2)
    {
      if (v27 == 2814029233LL) {
        mach_port_t v27 = 0LL;
      }
      if (v27 == 2780474809LL) {
        unint64_t v29 = -1LL;
      }
      else {
        unint64_t v29 = v27;
      }
      if ((*(void *)(cf + 32) & 2) == 0)
      {
        int v30 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
        if (v30)
        {
          else {
            CFDataRef v32 = (const CFAllocatorRef *)(cf - 16);
          }
          v30(*v32, v29);
        }
      }
    }
  }

  if ((*(_WORD *)(cf + 18) & 0x18) != 0) {
    __CFBasicHashIncSlotCount(cf);
  }
  ++*(_DWORD *)(cf + 20);
}

LABEL_79:
  os_unfair_lock_unlock(v7);
}

  if (!a13)
  {
    if (a7)
    {
      if (a12)
      {
        int v25 = (void *)v73;
        if (v73) {
          goto LABEL_9;
        }
      }

      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unsupported property list");
      goto LABEL_8;
    }

    uint64_t result = (uint64_t)v73;
    if (!v73) {
      return result;
    }
    goto LABEL_100;
  }

  CFMachPortContext value = 0LL;
  if (a7) {
    p_CFMachPortContext value = &value;
  }
  else {
    p_CFMachPortContext value = 0LL;
  }
  CFRange v55 = __CFCreateOldStylePropertyListOrStringsFile(a1, theData, a4, a5, a6, (CFErrorRef *)p_value, v27);
  Boolean v56 = (__CFError *)v73;
  if (!v55)
  {
    if (a7)
    {
      int v25 = value;
      if (v73 && value)
      {
        char v58 = CFErrorCopyUserInfo((CFErrorRef)v73);
        CFIndex Count = CFDictionaryGetCount(v58);
        MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count + 1, v58);
        CFDictionaryAddValue(MutableCopy, @"kCFPropertyListOldStyleParsingError", value);
        Domaiuint64_t n = CFErrorGetDomain(v56);
        Code = CFErrorGetCode(v56);
        char v63 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Domain, Code, MutableCopy);
        CFRelease(v58);
        CFRelease(MutableCopy);
        CFRelease(value);
        CFRelease(v56);
        uint64_t result = 0LL;
        *a7 = v63;
        return result;
      }

      if (v73 && !value)
      {
        uint64_t result = 0LL;
        *a7 = v73;
        return result;
      }

      if (!v73 && value)
      {
LABEL_9:
        uint64_t result = 0LL;
        *a7 = v25;
        return result;
      }

      if (!((unint64_t)v73 | (unint64_t)value))
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Encountered unknown error during parse");
        goto LABEL_8;
      }

      return 0LL;
    }

    if (!v73) {
      return 0LL;
    }
    uint64_t result = (uint64_t)v73;
LABEL_100:
    CFRelease((CFTypeRef)result);
    return 0LL;
  }

  int v57 = v55;
  if (v73) {
    CFRelease(v73);
  }
  *a11 = v57;
  return 1LL;
}

        unsigned int v35 = [a1 _cfTypeID];
        break;
    }
  }

  else
  {
    int v36 = atomic_load(a1 + 1);
    unsigned int v35 = (v36 >> 8) & 0x3FF;
  }

  if (v35 <= 0x47) {
LABEL_81:
  }
    BOOL v37 = &__CFRuntimeBuiltinClassTable + v35;
  else {
    BOOL v37 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v35 - 72) >> 6] + 8LL * (((_DWORD)v35 - 72) & 0x3F));
  }
  BOOL v38 = (uint64_t (*)(unint64_t *, unint64_t *))*((void *)*v37 + 5);
  if (v38) {
    return v38(a1, a2);
  }
  else {
    return 0LL;
  }
}

  unint64_t v73 = _CFGetTSD(1u);
  if (v73) {
    CFTypeID v74 = (const __CFAllocator *)v73;
  }
  else {
    CFTypeID v74 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  unint64_t v72 = v526;
  if (((2 * v49) | 1) > 61)
  {
    unint64_t v75 = CFAllocatorAllocate(v74, 32LL * ((2 * v49) | 1u), 0LL);
    unint64_t v72 = v75;
    if (v75 != v526 && __CFOASafe != 0)
    {
      uint64_t v77 = v75;
      __CFSetLastAllocationEventName();
      unint64_t v72 = v77;
    }
  }

  v513 = v72;
  if (v49 >= 61)
  {
    CFTypeID v78 = (unsigned __int8 **)CFAllocatorAllocate(v74, 8LL * v49, 0LL);
    unint64_t v72 = v513;
  }

  else
  {
    CFTypeID v78 = v524;
  }

  int64_t v80 = v495;
  unint64_t v79 = range;
  uint64_t v81 = v494;
  v487 = v78;
  p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
  alCFIndex loc = v74;
  v506 = v27;
  v469 = v45;
  if (range < 1)
  {
    v486 = 0LL;
    v500 = 0LL;
    LODWORD(v83) = 0;
    goto LABEL_290;
  }

  CFTypeID v83 = 0LL;
  LODWORD(v84) = 0;
  v500 = 0LL;
  v486 = 0LL;
  CFTypeRef v85 = xmmword_180C44970;
  do
  {
    uint64_t v86 = &v72[32 * v83];
    *((_DWORD *)v86 + 1) = v84;
    unint64_t v87 = v86 + 4;
    *(_OWORD *)(v86 + _Block_object_dispose((const void *)(v28 - 104), 8) = v85;
    uint64_t v88 = v86 + 8;
    *(_DWORD *)uint64_t v86 = 0;
    int v89 = v86 + 27;
    unint64_t v90 = (__int16 *)(v86 + 2);
    *((_DWORD *)v86 + 6) = -1;
    unint64_t v91 = v84;
    if (v80)
    {
      uint64_t v84 = (int)v84;
      while (*(_BYTE *)(v80 + v84) != 37)
      {
        if (v79 == ++v84) {
          goto LABEL_102;
        }
      }
    }

    else
    {
      uint64_t v84 = (int)v84;
      while (*(_WORD *)(v81 + 2 * v84) != 37)
      {
        if (v79 == ++v84)
        {
LABEL_102:
          LODWORD(v84) = v79;
          break;
        }
      }
    }

    if ((_DWORD)v84 != v91)
    {
      uint64_t v124 = 32;
      goto LABEL_274;
    }

      if (v60 < 0 || (unint64_t v73 = v335, v335 <= v60))
      {
        int v68 = 0;
        goto LABEL_85;
      }

      CFTypeID v74 = v332;
      if (v332)
      {
        unint64_t v75 = v334 + v60;
      }

      else
      {
        if (v333)
        {
          int v76 = *(char *)(v333 + v334 + v60);
          goto LABEL_124;
        }

        if (v337 <= v60 || (uint64_t v114 = v336, v336 > v60))
        {
          if (v287 < v335) {
            unint64_t v73 = v287;
          }
          v336 = v288;
          v337 = v73;
          v351.CFIndex location = v334 + v288;
          v351.size_t length = v73 - v288;
          v283 = v51;
          uint64_t v115 = v48;
          unint64_t v116 = v50;
          CFStringGetCharacters(v331, v351, buffer);
          CFTypeID v64 = v316;
          int v61 = v318;
          uint64_t v46 = v321;
          int v57 = v306;
          Boolean v56 = v317 ^ 1;
          uint64_t v51 = v283;
          char v58 = v303;
          __int16 v47 = v304;
          uint64_t v50 = v116;
          __int16 v49 = v317;
          int v48 = v115;
          uint64_t v114 = v336;
        }

        unint64_t v75 = v60 - v114;
        CFTypeID v74 = buffer;
      }

      int v76 = v74[v75];
LABEL_124:
      int v68 = v76;
      if ((v46 & 1) != 0 && v76 >= 0x41u && v76 <= 0x5Au)
      {
        if (__s1 && v76 == 73)
        {
          int v68 = 73;
        }

        else
        {
          if (v48) {
            BOOL v106 = 1;
          }
          else {
            BOOL v106 = (v46 & 0x200) == 0LL;
          }
          if (v106) {
            int v68 = v76 + 32;
          }
        }
      }

  if (v15)
  {
    BOOL v37 = CFUniCharGetBitmapPtrForPlane(0x67u, v15);
    if (!v37) {
      goto LABEL_84;
    }
  }

  else
  {
    BOOL v37 = __CFStringFoldCharacterClusterAtIndex_lowerBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
    {
LABEL_84:
      BOOL v38 = v113;
      if (v15)
      {
        uint64_t v39 = CFUniCharGetBitmapPtrForPlane(0x6Au, v15);
        if (!v39) {
          goto LABEL_52;
        }
      }

      else
      {
        uint64_t v39 = __CFStringFoldCharacterClusterAtIndex_caseFoldBMP;
        if (!__CFStringFoldCharacterClusterAtIndex_caseFoldBMP) {
          goto LABEL_52;
        }
      }

      goto LABEL_89;
    }
  }

      if (errorCode)
      {
        unsigned int v35 = -10;
LABEL_81:
        *errorCode = v35;
      }

char *__CFMessagePortCreateMessage(int a1, int a2, int a3, int a4, int a5, const void *a6, int a7)
{
  if (a7 == -1) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = (a7 + 7) & 0xFFFFFFF8;
  }
  if (v15 >= 0xFA1) {
    size_t v16 = 60LL;
  }
  else {
    size_t v16 = v15 + 60;
  }
  BOOL v17 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, 0LL);
  char v7 = v17;
  if (v17)
  {
    bzero(v17, v16);
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = a3;
    if (a1) {
      int v18 = 18;
    }
    else {
      int v18 = 19;
    }
    if (a3) {
      int v19 = 5376;
    }
    else {
      int v19 = 0;
    }
    int v20 = v19 | v18;
    *(_DWORD *)char v7 = v20;
    *((_DWORD *)v7 + 1) = v16;
    *(void *)(v7 + 2_CFBundleUnloadExecutable((uint64_t)bundle, 0) = 1667657072LL;
    *((_DWORD *)v7 + 11) = -252513032;
    *((_DWORD *)v7 + 12) = a5;
    *((_DWORD *)v7 + 13) = a4;
    *((_DWORD *)v7 + 14) = a7;
    if (v15 > 0xFA0)
    {
      *(_DWORD *)char v7 = v20 | 0x80000000;
      *((_DWORD *)v7 + 6) = 1;
      int v21 = v7[38];
      *(void *)(v7 + 2_Block_object_dispose((const void *)(v28 - 104), 8) = a6;
      *((_DWORD *)v7 + 9) = (v21 << 16) | 0x1000100;
      *((_DWORD *)v7 + 1_CFBundleUnloadExecutable((uint64_t)bundle, 0) = a7;
    }

    else if (a6 && a7 >= 1)
    {
      memmove(v7 + 60, a6, a7);
    }
  }

  return v7;
}

CFRunLoopSourceRef CFMessagePortCreateRunLoopSource( CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
{
  v15.perforuint64_t m = (void (__cdecl *)(void *))*MEMORY[0x1895F89C0];
  if (local)
  {
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)local);
    if (v6 != 35) {
      _CFAssertMismatchedTypeID(0x23uLL, v6);
    }
  }

  if (CFMessagePortIsValid(local))
  {
    char v7 = atomic_load((unint64_t *)local + 1);
    if ((v7 & 4) == 0)
    {
      uint64_t v8 = (os_unfair_lock_s *)((char *)local + 112);
      os_unfair_lock_lock((os_unfair_lock_t)local + 28);
      uint64_t v9 = (__CFRunLoopSource *)*((void *)local + 7);
      if (v9)
      {
        int IsValid = CFRunLoopSourceIsValid(v9);
        CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)local + 7);
        if (IsValid)
        {
          if (v11) {
            goto LABEL_17;
          }
        }

        else
        {
          CFRelease(v11);
          *((void *)local + 7) = 0LL;
        }
      }

      if (*((void *)local + 8)) {
        goto LABEL_12;
      }
      char v13 = atomic_load((unint64_t *)local + 1);
      if ((v13 & 1) != 0)
      {
        v15.CFIndex version = 1LL;
        v15.info = local;
        v15.CFAllocatorRetainCallBack retain = CFRetain;
        v15.CFArrayReleaseCallBack release = CFRelease;
        v15.copyDescriptiouint64_t n = (CFStringRef (__cdecl *)(const void *))__CFMessagePortCopyDescription;
        v15.equal = 0LL;
        v15.hash = 0LL;
        v15.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortGetPort;
        v15.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortPerform;
        CFRunLoopSourceRef v11 = CFRunLoopSourceCreate(allocator, order, &v15);
        *((void *)local + 7) = v11;
      }

      else
      {
        CFRunLoopSourceRef v11 = (CFRunLoopSourceRef)*((void *)local + 7);
      }

      if (!v11)
      {
LABEL_12:
        uint64_t v12 = 0LL;
LABEL_18:
        os_unfair_lock_unlock(v8);
        return v12;
      }

__CFMachPort *__CFMessagePortGetPort( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(__CFMachPort **)(a1 + 24);
  if (result) {
    return (__CFMachPort *)CFMachPortGetPort(result);
  }
  char v10 = atomic_load((unint64_t *)(a1 + 8));
  if ((v10 & 1) != 0) {
    CFLog( 4LL,  (uint64_t)@"*** Warning: A local CFMessagePort (%p) is being put in a run loop or dispatch queue, but it has not been named yet, so this will be a no-op and no messages are going to be received, even if named later.",  a3,  a4,  a5,  a6,  a7,  a8,  a1);
  }
  uint64_t result = *(__CFMachPort **)(a1 + 24);
  if (result) {
    return (__CFMachPort *)CFMachPortGetPort(result);
  }
  return result;
}

char *__CFMessagePortPerform(int *a1, unint64_t a2, const __CFAllocator *a3, uint64_t a4)
{
  address[1] = *MEMORY[0x1895F89C0];
  address[0] = 0LL;
  uint64_t v8 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  char v9 = atomic_load((unint64_t *)(a4 + 8));
  if ((v9 & 1) == 0)
  {
    os_unfair_lock_unlock(v8);
    return 0LL;
  }

  uint64_t v11 = *(void *)(a4 + 128);
  char v10 = *(uint64_t (**)(void))(a4 + 136);
  if (v10)
  {
    uint64_t v11 = v10(*(void *)(a4 + 128));
    uint64_t v12 = *(void (**)(uint64_t))(a4 + 144);
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  os_unfair_lock_unlock(v8);
  if (a2 < 0x18) {
    goto LABEL_7;
  }
  int v28 = *a1;
  if (*a1 < 0)
  {
    if (a2 >= 0x3C)
    {
      LODWORD(v31) = a1[1];
      if (v31 >= 0x3C)
      {
        int v32 = a1[11];
        BOOL v19 = v32 != -252513032 && v32 != -118164752;
        BOOL v34 = a1[6] != 1;
        goto LABEL_78;
      }
    }

    goto LABEL_7;
  }

  if (a1[5] == 1128680784)
  {
    if (a2 >= 0x38)
    {
      unint64_t v29 = 56LL;
      goto LABEL_38;
    }