void __securityd_create_connection_block_invoke(int a1, xpc_object_t xdict)
{
  const char *string;
  os_log_s *v3;
  int v4;
  const char *v5;
  uint64_t v6;
  v6 = *MEMORY[0x1895F89C0];
  string = xpc_dictionary_get_string(xdict, (const char *)*MEMORY[0x1895F91B0]);
  v3 = (os_log_s *)secLogObjForScope("xpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136315138;
    v5 = string;
    _os_log_debug_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEBUG, "got event: %s", (uint8_t *)&v4, 0xCu);
  }
}

const void *secLogObjForScope(const char *a1)
{
  if (!a1) {
    return secLogObjForCFScope(0LL);
  }
  v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], a1, 0x600u);
  v3 = secLogObjForCFScope(v2);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

const void *secLogObjForCFScope(const __CFString *a1)
{
  if (a1) {
    v1 = a1;
  }
  else {
    v1 = @"logging";
  }
  os_unfair_lock_lock_with_options();
  Mutable = (const __CFDictionary *)secLogObjForCFScope_scopeMap;
  if (!secLogObjForCFScope_scopeMap)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189604E40], 0LL);
    secLogObjForCFScope_scopeMap = (uint64_t)Mutable;
  }

  Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    v5[2] = __secLogObjForCFScope_block_invoke;
    v5[3] = &__block_descriptor_tmp_19_13216;
    v5[4] = v1;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __CFStringPerformWithCString_block_invoke;
    v6[3] = &unk_189676790;
    v6[4] = v5;
    CFStringPerformWithCStringAndLength(v1, (uint64_t)v6);
    Value = CFDictionaryGetValue((CFDictionaryRef)secLogObjForCFScope_scopeMap, v1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&secLogObjForCFScope_lock);
  return Value;
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  v4 = (void *)MEMORY[0x186DFF9D0]();
  OSStatus v22 = -1431655766;
  uint64_t v16 = 0LL;
  v17 = (const __CFDictionary **)&v16;
  uint64_t v18 = 0x3010000000LL;
  v19 = &unk_18069119A;
  CFDictionaryRef v20 = query;
  uint64_t v21 = 0LL;
  v5 = _os_activity_create(&dword_1804F4000, "SecItemCopyMatching_ios", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  if ((explode_identity(v17[4], SecItemCopyMatching, &v22, (__CFData **)result) & 1) == 0)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v17[4], @"r_Data");
    if (Value) {
      BOOL v7 = CFBooleanGetValue(Value) == 0;
    }
    else {
      BOOL v7 = 1;
    }
    v8 = (const __CFBoolean *)CFDictionaryGetValue(v17[4], @"r_Attributes");
    if (v8) {
      BOOL v9 = CFBooleanGetValue(v8) != 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v7 && !v9)
    {
      v10 = SecCFDictionaryCOWGetMutable(v17 + 4);
      CFDictionarySetValue(v10, @"r_Attributes", (const void *)*MEMORY[0x189604DE8]);
    }

    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __SecItemCopyMatching_block_invoke;
    v14[3] = &unk_189670338;
    v14[4] = &v16;
    v14[5] = query;
    v14[6] = result;
    OSStatus v22 = SecOSStatusWith((uint64_t)v14);
  }

  v11 = v17[5];
  if (v11) {
    CFRelease(v11);
  }
  OSStatus v12 = v22;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v16, 8);
  objc_autoreleasePoolPop(v4);
  return v12;
}

void sub_1804F5B04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, char a17)
{
}

uint64_t explode_identity( const __CFDictionary *a1, OSStatus (__cdecl *a2)(CFDictionaryRef attributes, CFTypeRef *result), OSStatus *a3, __CFData **a4)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  Value = CFDictionaryGetValue(a1, @"v_Ref");
  if (Value)
  {
    BOOL v9 = Value;
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 != SecIdentityGetTypeID()) {
      return 0LL;
    }
    v38 = a3;
    v11 = (const void *)*((void *)v9 + 2);
    CFRetain(v11);
    CFMutableDictionaryRef v12 = (CFMutableDictionaryRef)*((void *)v9 + 3);
    CFRetain(v12);
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, a1);
    CFDictionarySetValue(MutableCopy, @"v_Ref", v11);
    CFDictionaryRemoveValue(MutableCopy, @"class");
    CFDictionarySetValue(MutableCopy, @"class", @"cert");
    CFTypeRef v41 = 0LL;
    if (a4) {
      v14 = &v41;
    }
    else {
      v14 = 0LL;
    }
    OSStatus v15 = ((uint64_t (*)(__CFDictionary *, CFTypeRef *))a2)(MutableCopy, v14);
    BOOL v16 = a2 == SecItemAdd;
    BOOL v17 = v15 == -25299;
    BOOL v18 = v16 && v17;
    if (v16 && v17) {
      OSStatus v19 = 0;
    }
    else {
      OSStatus v19 = v15;
    }
    if (v19) {
      BOOL v20 = v19 == -25300;
    }
    else {
      BOOL v20 = 1;
    }
    if (!v20)
    {
      OSStatus v24 = v15;
      a3 = v38;
      if (!MutableCopy) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }

    if ((char *)a2 == (char *)SecItemDelete)
    {
      v29 = SecKeyCopyAttributes(v12);
      if (v29)
      {
        v30 = v29;
        v31 = (void *)CFDictionaryGetValue(v29, @"klbl");
        *(void *)&__int128 keys = @"class";
        *((void *)&keys + 1) = @"pkhh";
        values[0] = @"cert";
        values[1] = v31;
        if (v31 && (v32 = CFDictionaryCreate(0LL, (const void **)&keys, (const void **)values, 2LL, 0LL, 0LL)) != 0LL)
        {
          v33 = v32;
          OSStatus v34 = SecItemCopyMatching(v32, 0LL);
          CFRelease(v33);
          CFRelease(v30);
          if (!v34)
          {
            OSStatus v24 = v19;
            goto LABEL_24;
          }
        }

        else
        {
          CFRelease(v30);
        }
      }
    }

    CFDictionarySetValue(MutableCopy, @"v_Ref", v12);
    CFDictionarySetValue(MutableCopy, @"r_PersistentRef", (const void *)*MEMORY[0x189604DE0]);
    CFDictionaryRemoveValue(MutableCopy, @"class");
    CFDictionarySetValue(MutableCopy, @"class", @"keys");
    OSStatus v21 = ((uint64_t (*)(__CFDictionary *, void))a2)(MutableCopy, 0LL);
    if (v18) {
      int v22 = -25299;
    }
    else {
      int v22 = 0;
    }
    if (v21 == -25299 && a2 == SecItemAdd) {
      OSStatus v24 = v22;
    }
    else {
      OSStatus v24 = v21;
    }
LABEL_24:
    a3 = v38;
    CFTypeRef v25 = v41;
    if (v41)
    {
      if (!v24)
      {
        values[0] = (void *)-1LL;
        CFTypeRef cf = 0LL;
        CFDataRef theData = 0LL;
        if (_SecItemParsePersistentRef(v41, 0LL, values, (const void **)&theData, (CFDictionaryRef *)&cf))
        {
          if (SecKeychainIsStaticPersistentRefsEnabled() && theData && CFDataGetLength(theData) == 16)
          {
            UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef(@"idnt", theData, (CFDictionaryRef)cf);
          }

          else
          {
            if (SecKeychainIsStaticPersistentRefsEnabled())
            {
              secLogObjForScope("pref");
              v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys) = 134217984;
                *(void **)((char *)&keys + 4) = values[0];
                _os_log_impl( &dword_1804F4000,  v35,  OS_LOG_TYPE_DEFAULT,  "explode_identity: Creating old persistent ref for %llu",  (uint8_t *)&keys,  0xCu);
              }
            }

            UUIDBasedPersistentRef = _SecItemCreatePersistentRef( @"idnt",  (unint64_t)values[0],  (const __CFDictionary *)cf);
          }

          *a4 = UUIDBasedPersistentRef;
        }

        CFDataRef v36 = theData;
        if (theData)
        {
          CFDataRef theData = 0LL;
          CFRelease(v36);
        }

        CFTypeRef v37 = cf;
        if (cf)
        {
          CFTypeRef cf = 0LL;
          CFRelease(v37);
        }

        CFTypeRef v25 = v41;
        if (!v41)
        {
          OSStatus v24 = 0;
          if (!MutableCopy)
          {
LABEL_59:
            if (v11) {
              CFRelease(v11);
            }
            if (!v12) {
              goto LABEL_63;
            }
            goto LABEL_62;
          }

LABEL_58:
          CFRelease(MutableCopy);
          goto LABEL_59;
        }
      }

      CFTypeRef v41 = 0LL;
      CFRelease(v25);
    }

    if (!MutableCopy) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }

  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"class");
  if (result)
  {
    int v28 = CFEqual(@"idnt", (CFTypeRef)result);
    uint64_t result = 0LL;
    if ((char *)a2 == (char *)SecItemDelete)
    {
      if (v28)
      {
        CFMutableDictionaryRef v12 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, a1);
        CFDictionaryRemoveValue(v12, @"class");
        CFDictionarySetValue(v12, @"class", @"cert");
        OSStatus v24 = SecItemDelete(v12);
        if (!v24)
        {
          CFDictionarySetValue(v12, @"class", @"keys");
          OSStatus v24 = SecItemDelete(v12);
        }

        __break(0x5513u);
        goto LABEL_59;
      }

      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        CFTypeID v10 = v32;
        CFMutableDictionaryRef v12 = v33;
        goto LABEL_47;
      }
    }

    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0LL;
      }

      else
      {
        CFTypeRef v25 = (__int16 *)(a3 + 24LL * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        uint64_t result = 0LL;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }

        return 5LL;
      }
    }
  }

  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0LL;
    }
    else {
      return 3LL;
    }
  }

  return result;
}

LABEL_62:
        CFRelease(v12);
LABEL_63:
        *a3 = v24;
        return 1LL;
      }
    }
  }

  return result;
}

CFMutableDictionaryRef SecCFDictionaryCOWGetMutable(const __CFDictionary **a1)
{
  CFMutableDictionaryRef result = a1[1];
  if (!result)
  {
    CFMutableDictionaryRef result = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    a1[1] = result;
    v3 = *a1;
    if (*a1)
    {
      context[0] = MEMORY[0x1895F87A8];
      context[1] = 3221225472LL;
      context[2] = __SecCFDictionaryCOWGetMutable_block_invoke;
      context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
      context[4] = a1;
      CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_8844, context);
      CFMutableDictionaryRef result = a1[1];
    }

    *a1 = result;
  }

  return result;
}

void __SecCFDictionaryCOWGetMutable_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t SecOSStatusWith(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  int v1 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(a1 + 16))(a1, &cf);
  CFTypeRef v2 = cf;
  if (v1)
  {
    if (cf) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
    SetLastError(0LL);
    return 0LL;
  }

  else
  {
    if (!cf)
    {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
      CFTypeRef v2 = cf;
    }

    SetLastError(v2);
    uint64_t OSStatus = SecErrorGetOSStatus((uint64_t)cf);
    if ((_DWORD)OSStatus != -25300)
    {
      secLogObjForScope("OSStatus");
      v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109378;
        int v9 = OSStatus;
        __int16 v10 = 2112;
        CFTypeRef v11 = cf;
        _os_log_debug_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEBUG, "error:[%d] %@", buf, 0x12u);
      }
    }

    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v5);
    }
  }

  return OSStatus;
}

BOOL __SecItemCopyMatching_block_invoke(uint64_t a1, __CFString **a2)
{
  CFTypeRef v2 = (CFDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 32LL);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __SecItemCopyMatching_block_invoke_2;
  v4[3] = &__block_descriptor_48_e105_B48__0__TKClientTokenSession_8____CFDictionary__16____CFDictionary__24____CFDictionary__32_____CFError_40l;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  return SecItemAuthDoQuery(v2, 0LL, SecItemCopyMatching, a2, v4);
}

BOOL SecItemAuthDoQuery( CFDictionaryRef *a1, CFDictionaryRef *a2, OSStatus (__cdecl *a3)(CFDictionaryRef attributes, CFTypeRef *result), __CFString **a4, void *a5)
{
  uint64_t v113 = *MEMORY[0x1895F89C0];
  id v80 = a5;
  uint64_t v97 = 0LL;
  v98 = (const __CFDictionary **)&v97;
  uint64_t v99 = 0x3010000000LL;
  uint64_t v101 = 0LL;
  uint64_t v102 = 0LL;
  v100 = &unk_18069119A;
  v95[0] = 0LL;
  v95[1] = v95;
  v95[2] = 0x3032000000LL;
  v95[3] = __Block_byref_object_copy__8849;
  v95[4] = __Block_byref_object_dispose__8850;
  id v96 = 0LL;
  if (a2) {
    v8 = a2;
  }
  else {
    v8 = a1;
  }
  int v9 = *v8;
  __int16 v10 = (CFDictionaryRef *)CFDictionaryGetValue(*v8, @"accc");
  CFTypeRef v11 = v10;
  uint64_t v12 = (const void **)MEMORY[0x189604DE8];
  if (!v10)
  {
    BOOL v14 = (char *)a3 == (char *)SecItemUpdate;
    goto LABEL_17;
  }

  CFTypeID v13 = CFGetTypeID(v10);
  if (v13 != SecAccessControlGetTypeID())
  {
    SecError(-50, a4, @"Unexpected type of kSecAttrAccessControl attribute");
    goto LABEL_109;
  }

  BOOL v14 = (char *)a3 == (char *)SecItemUpdate;
  if (a3 != SecItemAdd && (char *)a3 != (char *)SecItemUpdate)
  {
    BOOL v14 = 0;
    goto LABEL_17;
  }

  if (CFDictionaryGetValue(v11[2], @"acl"))
  {
    OSStatus v15 = CFDictionaryGetValue(v9, @"sync");
    BOOL v16 = *v12;
    if (v15 && v16)
    {
      if (!CFEqual(v15, v16)) {
        goto LABEL_17;
      }
    }

    else if (v15 != v16)
    {
      goto LABEL_17;
    }

    if (SecError(-50, a4, @"item with kSecAttrAccessControl is not synchronizable")) {
      goto LABEL_17;
    }
LABEL_109:
    BOOL v75 = 0LL;
    goto LABEL_99;
  }

LABEL_17:
  int v17 = (char *)a3 == (char *)SecItemDelete || v14;
  if (a3 == SecItemCopyMatching) {
    int v18 = 1;
  }
  else {
    int v18 = v17;
  }
  OSStatus v19 = v98;
  BOOL v20 = CFDictionaryGetValue(*a1, @"u_OpPrompt");
  if (v20)
  {
    OSStatus v21 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v21, @"u_OpPrompt", v20);
    int v22 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v22, @"u_OpPrompt");
  }

  v23 = CFDictionaryGetValue(*a1, @"u_CallerName");
  if (v23)
  {
    OSStatus v24 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v24, @"u_CallerName", v23);
    CFTypeRef v25 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v25, @"u_CallerName");
  }

  v26 = (const __CFString *)CFDictionaryGetValue(*a1, @"u_AuthUI");
  if (!v26)
  {
    v27 = CFDictionaryGetValue(*a1, @"u_NoAuthUI");
    int v28 = *v12;
    if (v27 && v28) {
      BOOL v29 = CFEqual(v27, v28) != 0;
    }
    else {
      BOOL v29 = v27 == v28;
    }
    if (v29) {
      v26 = @"u_AuthUIF";
    }
    else {
      v26 = @"u_AuthUIA";
    }
  }

  if (!CFEqual(v26, @"u_AuthUIS") || CFDictionaryGetValue(*a1, @"u_NoAuthUI"))
  {
    if (CFDictionaryContainsKey(*a1, @"u_NoAuthUI"))
    {
      v30 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v30, @"u_NoAuthUI");
    }

    if ((!v26 || !CFEqual(v26, @"u_AuthUIS")) && CFDictionaryContainsKey(*a1, @"u_AuthUI"))
    {
      v31 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v31, @"u_AuthUI");
    }
  }

  if (!CFEqual(v26, @"u_AuthUIA"))
  {
    v32 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v32, @"u_AuthUI", v26);
  }

  v33 = CFDictionaryGetValue(*a1, @"u_CredRef");
  if (v33)
  {
    OSStatus v34 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v34, @"u_CredRef", v33);
  }

  if (a3 != SecItemCopyMatching)
  {
    v35 = CFDictionaryGetValue(*a1, @"u_AuthUI");
    if (v35)
    {
      if (CFEqual(v35, @"u_AuthUIS"))
      {
        SecError(-50, a4, @"kSecUseAuthenticationUISkip is allowed only for SecItemCopyMatching");
        goto LABEL_109;
      }
    }
  }

  v82 = v98 + 4;
  v86[0] = MEMORY[0x1895F87A8];
  CFDataRef v36 = (uint64_t (*)(void))__SecItemAuthDoQuery_block_invoke;
  v86[1] = 3221225472LL;
  v87 = __SecItemAuthDoQuery_block_invoke;
  v88 = &unk_189670728;
  v92 = a1;
  v93 = a2;
  v94 = a3;
  v90 = &v97;
  v91 = v95;
  id v89 = v80;
  CFTypeRef v37 = v86;
  int v38 = 0;
  v110 = 0LL;
  v108 = 0LL;
  CFTypeRef cf = 0LL;
  format = @"Unable to create LAContext from externalizedContext";
  v81 = (void *)*v12;
  v83 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  id v79 = v37;
  while (1)
  {
    int v39 = v36();
    if (v39 != 2) {
      break;
    }
    if (!LocalAuthenticationLibraryCore())
    {
      SecError(-4, a4, @"LocalAuthentication is not available");
      goto LABEL_93;
    }

    SecCFDictionaryCOWGetMutable(v82);
    -[__CFDictionary objectForKey:](*v82, "objectForKey:", @"u_AuthCtx");
    id value = (id)objc_claimAutoreleasedReturnValue();
    if (!value)
    {
      v40 = -[__CFDictionary objectForKey:](*v82, "objectForKey:", @"u_CredRef");
      LAContextClass = (objc_class *)getLAContextClass();
      if (v40) {
        id value = (id)[[LAContextClass alloc] initWithExternalizedContext:v40];
      }
      else {
        id value = objc_alloc_init(LAContextClass);
      }
      if (!value)
      {
        id value = 0LL;
        goto LABEL_111;
      }

      v42 = SecCFDictionaryCOWGetMutable(v82);
      CFDictionarySetValue(v42, @"u_AuthCtx", value);
      if (!v40)
      {
        [value externalizedContext];
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v40)
        {
          format = @"Failed to get externalized context from LAContext";
LABEL_111:
          SecError(-25293, a4, format, format);

LABEL_112:
LABEL_93:
          BOOL v75 = 0LL;
          goto LABEL_94;
        }

        v43 = SecCFDictionaryCOWGetMutable(v82);
        CFDictionarySetValue(v43, @"u_CredRef", v40);
      }
    }

    if (v38 == 20)
    {
      SecItemAuthMaxAttemptsReached(v110, a4);
      goto LABEL_112;
    }

    if (!v108)
    {
      v66 = CFDictionaryGetValue(*v82, @"u_OpPrompt");
      if (v66)
      {
        uint64_t valuePtr = 2LL;
        CFNumberRef v67 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
        v68 = SecCFDictionaryCOWGetMutable(&v108);
        CFDictionarySetValue(v68, v67, v66);
        CFRelease(v67);
      }

      v69 = CFDictionaryGetValue(*v82, @"u_CallerName");
      if (v69)
      {
        uint64_t valuePtr = 1021LL;
        CFNumberRef v70 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
        v71 = SecCFDictionaryCOWGetMutable(&v108);
        CFDictionarySetValue(v71, v70, v69);
        CFRelease(v70);
      }

      v72 = CFDictionaryGetValue(*v82, @"u_AuthUI");
      if (v72 && CFEqual(v72, @"u_AuthUIF"))
      {
        uint64_t valuePtr = 1000LL;
        CFNumberRef v73 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
        v74 = SecCFDictionaryCOWGetMutable(&v108);
        CFDictionarySetValue(v74, v73, v81);
        CFRelease(v73);
      }
    }

    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    uint64_t v44 = v110;
    uint64_t v45 = -[__CFArray countByEnumeratingWithState:objects:count:]( v44,  "countByEnumeratingWithState:objects:count:",  &v104,  v112,  16LL);
    if (v45)
    {
      uint64_t v46 = *(void *)v105;
      while (2)
      {
        for (uint64_t i = 0LL; i != v45; ++i)
        {
          if (*(void *)v105 != v46) {
            objc_enumerationMutation(v44);
          }
          v48 = *(void **)(*((void *)&v104 + 1) + 8 * i);
          objc_msgSend(v48, "objectAtIndexedSubscript:", 0, format);
          v49 = (const __CFData *)objc_claimAutoreleasedReturnValue();
          v50 = (CFMutableDictionaryRef *)SecAccessControlCreateFromData(v83, v49, a4);

          if (!v50)
          {

            goto LABEL_93;
          }

          [v48 objectAtIndexedSubscript:1];
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          id v103 = 0LL;
          [value evaluateAccessControl:v50 aksOperation:v51 options:v108 error:&v103];
          v52 = (void *)objc_claimAutoreleasedReturnValue();
          v53 = (__CFString *)v103;

          BOOL v54 = a4 == 0LL;
          if (v52) {
            BOOL v54 = 1;
          }
          if (!v54)
          {
            v53 = v53;
            *a4 = v53;
LABEL_92:

            goto LABEL_93;
          }

          if (!v52) {
            goto LABEL_92;
          }
          [v48 objectAtIndexedSubscript:1];
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          int v56 = [v55 isEqual:&stru_1896794C8];

          if (v56)
          {
            CFDictionarySetValue(v50[2], @"bound", v81);
            v64 = SecAccessControlCopyData((uint64_t)v50, v57, v58, v59, v60, v61, v62, v63);
            v65 = SecCFDictionaryCOWGetMutable(v82);
            CFDictionarySetValue(v65, @"accc", v64);
          }
        }

        uint64_t v45 = -[__CFArray countByEnumeratingWithState:objects:count:]( v44,  "countByEnumeratingWithState:objects:count:",  &v104,  v112,  16LL);
        if (v45) {
          continue;
        }
        break;
      }
    }

    ++v38;
    CFDataRef v36 = (uint64_t (*)(void))v87;
  }

  BOOL v75 = v39 != 1;
LABEL_94:
  if (cf) {
    CFRelease(cf);
  }
  if (v110) {
    CFRelease(v110);
  }

LABEL_99:
  v76 = v98[5];
  if (v76) {
    CFRelease(v76);
  }
  _Block_object_dispose(v95, 8);

  _Block_object_dispose(&v97, 8);
  return v75;
}

    if (v8 <= *a3)
    {
      CFMutableDictionaryRef result = 0LL;
      *a3 = v8;
      return result;
    }
  }

        __break(0x5513u);
        goto LABEL_18;
      }
    }
  }

  return result;
}

    CFTypeID v13 = 0LL;
    goto LABEL_18;
  }

  if (a4 < 1.0 && a4 != -1.0)
  {
    secLogObjForScope("SecError");
    OSStatus v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    LODWORD(buf) = 134217984;
    *(double *)((char *)&buf + 4) = a4;
    BOOL v14 = "SFAnalytics: cannot add sampler with interval %f";
    int v17 = v15;
    int v18 = 12;
    goto LABEL_16;
  }

  if (!v9)
  {
    secLogObjForScope("SecError");
    OSStatus v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      BOOL v14 = "SFAnalytics: cannot add sampler without block";
      goto LABEL_15;
    }

    goto LABEL_17;
  }

  *(void *)&buf = 0LL;
  *((void *)&buf + 1) = &buf;
  int v28 = 0x3032000000LL;
  BOOL v29 = __Block_byref_object_copy__2082;
  v30 = __Block_byref_object_dispose__2083;
  v31 = 0LL;
  location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, self);
  queue = self->_queue;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __62__SFAnalytics_addMetricSamplerForName_withTimeInterval_block___block_invoke;
  block[3] = &unk_189665708;
  objc_copyWeak(v25, &location);
  OSStatus v21 = v8;
  p_buf = &buf;
  v25[1] = *(id *)&a4;
  int v22 = self;
  v23 = v10;
  dispatch_sync((dispatch_queue_t)queue, block);
  CFTypeID v13 = *(id *)(*((void *)&buf + 1) + 40LL);

  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Block_object_dispose(&buf, 8);

LABEL_18:
  return v13;
}

    CFTypeID v13 = 0LL;
    goto LABEL_18;
  }

  if (a4 < 1.0 && a4 != -1.0)
  {
    secLogObjForScope("SecError");
    OSStatus v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    LODWORD(buf) = 134217984;
    *(double *)((char *)&buf + 4) = a4;
    BOOL v14 = "SFAnalytics: cannot add sampler with interval %f";
    int v17 = v15;
    int v18 = 12;
    goto LABEL_16;
  }

  if (!v9)
  {
    secLogObjForScope("SecError");
    OSStatus v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      BOOL v14 = "SFAnalytics: cannot add sampler without block";
      goto LABEL_15;
    }

    goto LABEL_17;
  }

  *(void *)&buf = 0LL;
  *((void *)&buf + 1) = &buf;
  int v28 = 0x3032000000LL;
  BOOL v29 = __Block_byref_object_copy__2082;
  v30 = __Block_byref_object_dispose__2083;
  v31 = 0LL;
  location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, self);
  queue = self->_queue;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __61__SFAnalytics_AddMultiSamplerForName_withTimeInterval_block___block_invoke;
  block[3] = &unk_189665708;
  objc_copyWeak(v25, &location);
  OSStatus v21 = v8;
  p_buf = &buf;
  v25[1] = *(id *)&a4;
  int v22 = self;
  v23 = v10;
  dispatch_sync((dispatch_queue_t)queue, block);
  CFTypeID v13 = *(id *)(*((void *)&buf + 1) + 40LL);

  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Block_object_dispose(&buf, 8);

LABEL_18:
  return v13;
}

      v6 = 0;
      CFMutableDictionaryRef result = kSecAsn1IA5StringTemplate;
      if (a2) {
        return result;
      }
      goto LABEL_21;
    }

    if (v5 == 34 || v5 == 214)
    {
      v6 = 0;
      CFMutableDictionaryRef result = kSecAsn1OctetStringTemplate;
    }

    else if (v5 == 99)
    {
      goto LABEL_17;
    }

    if (a2) {
      return result;
    }
    goto LABEL_21;
  }

  v6 = 1;
  CFMutableDictionaryRef result = kSecAsn1AnyTemplate;
  if (!a2) {
LABEL_21:
  }
    *(_BYTE *)(v3 + 32) = v6;
  return result;
}

  sessionParameters = v8->_sessionParameters;
  v8->_sessionParameters = (NSDictionary *)MEMORY[0x189604A60];
  v35 = -[SecCTKKey tokenObject](v8, "tokenObject");
  [v35 keychainAttributes];
  CFDataRef v36 = (void *)objc_claimAutoreleasedReturnValue();
  CFTypeRef v37 = (void *)[v36 mutableCopy];

  [v37 addEntriesFromDictionary:v6];
  [v37 objectForKeyedSubscript:@"accc"];
  int v38 = (const __CFData *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    int v39 = (SecCTKKey *)SecAccessControlCreateFromData( (const __CFAllocator *)*MEMORY[0x189604DB0],  v38,  (__CFString **)a4);

    if (!v39)
    {

      goto LABEL_32;
    }

    v55 = v6;
    [v37 setObject:v39 forKeyedSubscript:@"accc"];
    objc_msgSend(v37, "removeObjectForKey:", @"toid", v39);
  }

  else
  {
    v55 = v6;
    objc_msgSend(v37, "removeObjectForKey:", @"toid", v38);
  }

  [v37 removeObjectForKey:@"u_TokenSession"];
  uint64_t v58 = 0u;
  uint64_t v59 = 0u;
  int v56 = 0u;
  uint64_t v57 = 0u;
  v61[0] = @"type";
  v61[1] = @"kcls";
  [MEMORY[0x189603F18] arrayWithObjects:v61 count:2];
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  CFTypeRef v41 = [v40 countByEnumeratingWithState:&v56 objects:v62 count:16];
  if (v41)
  {
    v42 = v41;
    v43 = *(void *)v57;
    do
    {
      for (uint64_t i = 0LL; i != v42; ++i)
      {
        if (*(void *)v57 != v43) {
          objc_enumerationMutation(v40);
        }
        uint64_t v45 = *(void *)(*((void *)&v56 + 1) + 8 * i);
        [v37 objectForKeyedSubscript:v45];
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          [v46 stringValue];
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          [v37 setObject:v47 forKeyedSubscript:v45];
        }
      }

      v42 = [v40 countByEnumeratingWithState:&v56 objects:v62 count:16];
    }

    while (v42);
  }

  [v37 setObject:@"keys" forKeyedSubscript:@"class"];
  [v37 setObject:@"1" forKeyedSubscript:@"kcls"];
  v48 = [v37 copy];
  keychainAttributes = v8->_keychainAttributes;
  v8->_keychainAttributes = (NSDictionary *)v48;

  v6 = v55;
LABEL_31:
  int v39 = v8;
LABEL_32:

  return v39;
}

    CFRelease(Mutable);
    return v11;
  }

  if (a3) {
    return SecFrameworkCopyLocalizedString(@"<NULL>", @"Certificate");
  }
  return @"<NULL>";
}

  if (!v17)
  {
    if ((void)v72 == 8LL && !memcmp(&_oidSha256Ecdsa, *((const void **)&v72 + 1), 8uLL))
    {
      OSStatus v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }

    else if ((void)v23 == 8LL && !memcmp(&_oidSha384Ecdsa, *((const void **)&v23 + 1), 8uLL))
    {
      OSStatus v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }

    else
    {
      OSStatus v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }

  return 4294967246LL;
}

  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (Value) {
    CFRelease(Value);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (BasicX509) {
    CFRelease(BasicX509);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (trust) {
    CFRelease(trust);
  }
}

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v8;
  return result;
}

  BOOL v16 = (os_log_s *)secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)OSStatus v19 = 138412290;
    *(void *)&v19[4] = theDict;
    _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "Invalid or missing key size in: %@", v19, 0xCu);
  }

  return 4294941985LL;
}

  BOOL v14 = CFGetTypeID(a3);
  if (v14 == CFBooleanGetTypeID())
  {
  }

  else
  {
    v17[0] = (const void *)0xAAAAAAAAAAAAAAAALL;
    v17[1] = (const void *)0xAAAAAAAAAAAAAAAALL;
    Security::CFDictionary::CFDictionary((Security::CFDictionary *)v17, a3);
    OSStatus v15 = Security::CFDictionary::get<__CFBoolean const*>((uint64_t)v17, "omit");
    Security::CFRef<__CFDictionary const*>::~CFRef(v17);
    if (v15 != v13) {
      goto LABEL_26;
    }
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) |= CFArrayContainsValue( *(CFArrayRef *)(a1 + 72),  *(CFRange *)(a1 + 80),  a2) == 0;
LABEL_26:
}

  if ((v8 & 0x80) != 0) {
    v8 = *((void *)this + 18);
  }
  else {
    v8 = v8;
  }
  v221 = (void **)((char *)this + 136);
  if (v8)
  {
    __int16 v10 = (os_log_s *)secLogObjForScope("signer");
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_83;
    }
    CFTypeRef v11 = (char *)this + 136;
    *(_DWORD *)v250 = 136315138;
    *(void *)&v250[4] = v11;
    uint64_t v12 = "using explicit identifier=%s";
    goto LABEL_389;
  }

  (*(void (**)(_BYTE *__return_ptr, void, Security::CodeSigning::SecCodeSigner::Signer *))(**((void **)this + 3) + 184LL))( v250,  *((void *)this + 3),  this);
  *(_OWORD *)BOOL v7 = *(_OWORD *)v250;
  *((void *)this + 19) = *(void *)&v250[16];
  if (std::string::find((const std::string *)((char *)this + 136), 46, 0LL) == -1LL)
  {
    CFTypeID v13 = *((void *)this + 1);
    else {
      BOOL v14 = *(void *)(v13 + 208);
    }
    else {
      OSStatus v15 = *((void *)this + 18);
    }
    memset(v250, 170, 24);
    BOOL v16 = v250;
    std::string::basic_string[abi:ne180100]((uint64_t)v250, v15 + v14);
    if (v250[23] < 0) {
      BOOL v16 = *(_BYTE **)v250;
    }
    if (v14)
    {
      else {
        int v17 = *(const void **)(v13 + 200);
      }
      memmove(v16, v17, v14);
    }

    int v18 = &v16[v14];
    if (v15)
    {
      else {
        OSStatus v19 = (char *)*((void *)this + 17);
      }
      memmove(v18, v19, v15);
    }

    v18[v15] = 0;
    *(_OWORD *)BOOL v7 = *(_OWORD *)v250;
    *((void *)this + 19) = *(void *)&v250[16];
  }

  if (std::string::find((const std::string *)((char *)this + 136), 46, 0LL) == -1LL
    && (*(unsigned int (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 8LL))(this))
  {
    (*(void (**)(_BYTE *__return_ptr))(**((void **)this + 3) + 192LL))(v250);
    if (v250[23] >= 0) {
      BOOL v20 = v250[23];
    }
    else {
      BOOL v20 = *(void *)&v250[8];
    }
    if ((v250[23] & 0x80000000) != 0) {
      operator delete(*(void **)v250);
    }
    if (!v20)
    {
      else {
        OSStatus v21 = *((void *)this + 18);
      }
      memset(v250, 170, 24);
      std::string::basic_string[abi:ne180100]((uint64_t)v250, v21 + 1);
      if (v250[23] >= 0) {
        int v22 = v250;
      }
      else {
        int v22 = *(_BYTE **)v250;
      }
      if (v21)
      {
        else {
          v23 = (char *)*((void *)this + 17);
        }
        memmove(v22, v23, v21);
      }

      *(_WORD *)&v22[v21] = 45;
      theData.__r_.__value_.__r.__words[0] = (*(uint64_t (**)(void))(**((void **)this + 3) + 32LL))(*((void *)this + 3));
      BytePtr = CFDataGetBytePtr((CFDataRef)theData.__r_.__value_.__l.__data_);
      Length = CFDataGetLength((CFDataRef)theData.__r_.__value_.__l.__data_);
      memset(v237, 0, 24);
      if (Length >= 1)
      {
        do
        {
          memset(&__str, 170, 3);
          v26 = *BytePtr++;
          snprintf((char *)&__str, 3uLL, "%02x", v26);
          v27 = strlen((const char *)&__str);
          std::string::append((std::string *)v237, (const std::string::value_type *)&__str, v27);
          --Length;
        }

        while (Length);
      }

      Security::CFRef<__CFData const*>::~CFRef((const void **)&theData.__r_.__value_.__l.__data_);
      if (v237[23] >= 0) {
        int v28 = v237;
      }
      else {
        int v28 = *(const std::string::value_type **)v237;
      }
      if (v237[23] >= 0) {
        BOOL v29 = v237[23];
      }
      else {
        BOOL v29 = *(void *)&v237[8];
      }
      v30 = std::string::append((std::string *)v250, v28, v29);
      v31 = v30->__r_.__value_.__r.__words[0];
      __p.__r_.__value_.__r.__words[0] = v30->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
      size = v30->__r_.__value_.__s.__size_;
      v30->__r_.__value_.__l.__size_ = 0LL;
      v30->__r_.__value_.__l.__cap_ = 0LL;
      v30->__r_.__value_.__r.__words[0] = 0LL;
      *((void *)this + 17) = v31;
      *((void *)this + 18) = __p.__r_.__value_.__r.__words[0];
      *(void *)((char *)this + 151) = *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7);
      *((_BYTE *)this + 159) = size;
      if ((v237[23] & 0x80000000) != 0) {
        operator delete(*(void **)v237);
      }
      BOOL v7 = (void **)((char *)this + 136);
      if ((v250[23] & 0x80000000) != 0) {
        operator delete(*(void **)v250);
      }
    }
  }

  __int16 v10 = (os_log_s *)secLogObjForScope("signer");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    v211 = v7;
    *(_DWORD *)v250 = 136315138;
    *(void *)&v250[4] = v211;
    uint64_t v12 = "using default identifier=%s";
LABEL_389:
    _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, v12, v250, 0xCu);
  }

  free(v22);
  (*(void (**)(Security::MachOBase *))(*(void *)v5 + 8LL))(v5);
  if (v21) {
    Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add( &v68,  4u,  v21);
  }
  v23 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(&v68);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v68);
  return v23;
}

void sub_1804F6BBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
}

uint64_t SecItemAttributesPrepare(CFDictionaryRef *a1, int a2, __CFString **a3)
{
  values[2] = *(void **)MEMORY[0x1895F89C0];
  Value = CFDictionaryGetValue(*a1, @"v_Ref");
  if (!Value)
  {
    __int16 v10 = 0LL;
    goto LABEL_12;
  }

  BOOL v7 = SecItemCopyAttributeDictionary(Value, a2);
  if (!v7)
  {
    SecError(-50, a3, @"unsupported kSecValueRef in query");
    uint64_t v55 = 0LL;
    int v28 = 0LL;
    goto LABEL_72;
  }

  v8 = v7;
  if ((a2 & 1) != 0)
  {
    uint64_t context = MEMORY[0x1895F87A8];
    uint64_t v62 = 3221225472LL;
    uint64_t v63 = __SecItemAttributesPrepare_block_invoke;
    v64 = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    v65 = a1;
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)apply_block_2_8844, &context);
    int v9 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v9, @"toid");
LABEL_11:
    BOOL v14 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v14, @"v_Ref");
    __int16 v10 = v8;
    goto LABEL_12;
  }

  __int16 v10 = v7;
  -[__CFDictionary objectForKeyedSubscript:](v10, "objectForKeyedSubscript:", @"class");
  CFTypeRef v11 = (void *)objc_claimAutoreleasedReturnValue();
  int v12 = [v11 isEqual:@"keys"];

  if (v12)
  {
    -[__CFDictionary objectForKeyedSubscript:](v10, "objectForKeyedSubscript:", @"tkid");
    CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      [v13 hasPrefix:@"com.apple.setoken"];
    }
  }

  uint64_t context = MEMORY[0x1895F87A8];
  uint64_t v62 = 3221225472LL;
  uint64_t v63 = __SecItemAttributesPrepare_block_invoke;
  v64 = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
  v65 = a1;
  CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)apply_block_2_8844, &context);
  if (!CFDictionaryContainsKey(*a1, @"tkid")) {
    goto LABEL_11;
  }
LABEL_12:
  OSStatus v15 = CFDictionaryGetValue(*a1, @"accc");
  if (!v15)
  {
    v26 = 0LL;
    goto LABEL_17;
  }

  uint64_t v16 = (uint64_t)v15;
  CFTypeID v17 = CFGetTypeID(v15);
  if (v17 != SecAccessControlGetTypeID())
  {
    SecError(-50, a3, @"Unexpected type of kSecAttrAccessControl attribute");
    goto LABEL_80;
  }

  CFTypeRef v25 = SecAccessControlCopyData(v16, v18, v19, v20, v21, v22, v23, v24);
  if (!v25)
  {
    SecError(-50, a3, @"unsupported kSecAttrAccessControl in query");
LABEL_80:
    int v28 = 0LL;
    uint64_t v55 = 0LL;
    if (v10) {
      goto LABEL_71;
    }
    goto LABEL_72;
  }

  v26 = v25;
  v27 = SecCFDictionaryCOWGetMutable(a1);
  CFDictionarySetValue(v27, @"accc", v26);
LABEL_17:
  -[__CFDictionary objectForKey:](*a1, "objectForKey:", @"u_AuthCtx");
  int v28 = (void *)objc_claimAutoreleasedReturnValue();
  if (v28)
  {
    if (CFDictionaryContainsKey(*a1, @"u_CredRef"))
    {
      SecError(-50, a3, @"kSecUseAuthenticationContext cannot be used together with kSecUseCredentialReference");
      BOOL v29 = 0LL;
      goto LABEL_75;
    }

    [v28 externalizedContext];
    BOOL v29 = (const void *)objc_claimAutoreleasedReturnValue();
    if (!v29)
    {
      SecError(-25293, a3, @"Unable to get externalizedContext from LAContext");
      goto LABEL_75;
    }

    v30 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v30, @"u_AuthCtx");
    v31 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionarySetValue(v31, @"u_CredRef", v29);
  }

  else
  {
    BOOL v29 = 0LL;
  }

  v32 = (void *)CFDictionaryGetValue(*a1, @"m_Policy");
  if (!v32) {
    goto LABEL_58;
  }
  v33 = v32;
  CFTypeID v34 = CFGetTypeID(v32);
  if (v34 != SecPolicyGetTypeID())
  {
    uint64_t v57 = @"unsupported kSecMatchPolicy in query";
    goto LABEL_74;
  }

  values[0] = v33;
  v35 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)values, 1LL, MEMORY[0x189605228]);
  xpc_object_t v36 = xpc_array_create(0LL, 0LL);
  if (!v36)
  {
    SecError(-108, a3, @"failed to create xpc_array");
    if (v35) {
      goto LABEL_54;
    }
    goto LABEL_55;
  }

  uint64_t v60 = a3;
  CFIndex Count = CFArrayGetCount(v35);
  if (Count < 1)
  {
    if (v35) {
      goto LABEL_54;
    }
    goto LABEL_55;
  }

  CFIndex v38 = Count;
  uint64_t v58 = v28;
  uint64_t v59 = v10;
  CFIndex v39 = 0LL;
  while (1)
  {
    ValueAtIndex = (CFStringRef *)CFArrayGetValueAtIndex(v35, v39);
    if (ValueAtIndex) {
      break;
    }
LABEL_45:
    if (v38 == ++v39) {
      goto LABEL_53;
    }
  }

  CFTypeRef v41 = ValueAtIndex;
  objects[0] = 0LL;
  objects[1] = 0LL;
  MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, ValueAtIndex[2]);
  v43 = MutableCopy;
  if (MutableCopy)
  {
    if (v41[3])
    {
      CFStringAppend(MutableCopy, @"++");
      CFStringAppend(v43, v41[3]);
    }

    objects[0] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
    if (!objects[0])
    {
      SecError(-50, v60, @"failed to create xpc_object from policy oid and name", v58, v59);
LABEL_49:
      xpc_object_t v44 = 0LL;
      goto LABEL_39;
    }
  }

  else
  {
    objects[0] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
    if (!objects[0])
    {
      SecError(-50, v60, @"failed to create xpc_object from policy oid", v58, v59);
      goto LABEL_49;
    }
  }

  objects[1] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  if (objects[1])
  {
    xpc_object_t v44 = xpc_array_create(objects, 2uLL);
    if (!v44) {
      SecError(-108, v60, @"failed to create xpc_array for policy");
    }
  }

  else
  {
    SecError(-50, v60, @"failed to create xpc_object from policy options");
    xpc_object_t v44 = 0LL;
  }

  if (objects[0]) {
    xpc_release(objects[0]);
  }
LABEL_39:
  if (objects[1]) {
    xpc_release(objects[1]);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (v44)
  {
    xpc_array_append_value(v36, v44);
    xpc_release(v44);
    goto LABEL_45;
  }

  xpc_release(v36);
  xpc_object_t v36 = 0LL;
LABEL_53:
  __int16 v10 = v59;
  a3 = v60;
  int v28 = v58;
  if (v35) {
LABEL_54:
  }
    CFRelease(v35);
LABEL_55:
  if (!v36)
  {
    SecError(-26276, a3, @"Failed to copy XPC policy", v58, v59);
LABEL_89:

    goto LABEL_75;
  }

  uint64_t v45 = _CFXPCCreateCFObjectFromXPCObject();
  if (!v45)
  {
    SecError(-26276, a3, @"Failed to create CFObject from XPC policy", v58, v59);
    goto LABEL_89;
  }

  uint64_t v46 = (const void *)v45;
  v47 = SecCFDictionaryCOWGetMutable(a1);
  CFDictionarySetValue(v47, @"m_Policy", v46);
  CFRelease(v46);

LABEL_58:
  v48 = (const __CFData *)CFDictionaryGetValue(*a1, @"issr");
  if (!v48)
  {
LABEL_64:
    if (CFDictionaryContainsKey(*a1, @"u_TokenRawItems"))
    {
      BOOL v54 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v54, @"u_TokenRawItems");
    }

    uint64_t v55 = 1LL;
    if (!v26) {
      goto LABEL_68;
    }
LABEL_67:
    CFRelease(v26);
    goto LABEL_68;
  }

  v49 = v48;
  CFTypeID v50 = CFGetTypeID(v48);
  if (v50 == CFDataGetTypeID())
  {
    values[0] = (void *)CFDataGetBytePtr(v49);
    values[1] = (void *)CFDataGetLength(v49);
    memset(objects, 170, sizeof(objects));
    if (!DERDecodeItem((uint64_t)values, (unint64_t *)objects)
      && objects[0] == (xpc_object_t)0x2000000000000010LL)
    {
      NormalizedX501Name = createNormalizedX501Name((const __CFAllocator *)*MEMORY[0x189604DB0], (uint64_t)&objects[1]);
      if (NormalizedX501Name)
      {
        v52 = NormalizedX501Name;
        v53 = SecCFDictionaryCOWGetMutable(a1);
        CFDictionarySetValue(v53, @"issr", v52);
        CFRelease(v52);
      }
    }

    goto LABEL_64;
  }

  uint64_t v57 = @"Unexpected type";
LABEL_74:
  SecError(-50, a3, v57, v58, v59);
LABEL_75:
  uint64_t v55 = 0LL;
  if (v26) {
    goto LABEL_67;
  }
LABEL_68:
  if (v29) {
    CFRelease(v29);
  }
  if (v10) {
LABEL_71:
  }
    CFRelease(v10);
LABEL_72:

  return v55;
}

uint64_t __SecItemAuthDoQuery_block_invoke(uint64_t a1, CFTypeRef *a2, __CFString **a3)
{
  v6 = *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 32LL);
  if (v6)
  {
    Value = CFDictionaryGetValue(v6, @"u_CredRef");
    if (Value)
    {
      v8 = Value;
      int v9 = SecCFDictionaryCOWGetMutable(*(const __CFDictionary ***)(a1 + 56));
      CFDictionarySetValue(v9, @"u_CredRef", v8);
    }

    __int16 v10 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 32LL), @"accc");
    if (v10)
    {
      CFTypeRef v11 = v10;
      int v12 = *(const __CFDictionary ***)(a1 + 64);
      if (!v12) {
        int v12 = *(const __CFDictionary ***)(a1 + 56);
      }
      CFTypeID v13 = SecCFDictionaryCOWGetMutable(v12);
      CFDictionarySetValue(v13, @"accc", v11);
    }
  }

  BOOL v14 = (const __CFString *)CFDictionaryGetValue(**(CFDictionaryRef **)(a1 + 56), @"tkid");
  if (v14)
  {
    OSStatus v15 = v14;
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 != CFStringGetTypeID())
    {
      SecError(-50, a3, @"Unexpected type");
      return 1LL;
    }

    if (*(OSStatus (__cdecl **)(CFDictionaryRef, CFTypeRef *))(a1 + 72) != SecItemCopyMatching)
    {
      CFTypeID v17 = (const __CFBoolean *)CFDictionaryGetValue(**(CFDictionaryRef **)(a1 + 56), @"u_TokenRawItems");
      if (!v17 || !CFBooleanGetValue(v17))
      {
        CFErrorRef err = 0LL;
        uint64_t v18 = SecTokenSessionCreate( v15,  (const __CFDictionary **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 32LL),  (__CFString **)&err);
        uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
        uint64_t v20 = *(void **)(v19 + 40);
        *(void *)(v19 + 40) = v18;

        if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
        {
          if (*(OSStatus (__cdecl **)(CFDictionaryRef))(a1 + 72) != SecItemDelete
            || !CryptoTokenKitLibraryCore()
            || !getTKErrorDomainSymbolLoc()
            || (CFErrorDomain Domain = CFErrorGetDomain(err), getTKErrorDomain(), !CFEqual(Domain, v22))
            || CFErrorGetCode(err) != -7)
          {
            if (err)
            {
              if (a3 && !*a3) {
                *a3 = (__CFString *)err;
              }
              else {
                CFRelease(err);
              }
            }

            return 1LL;
          }

          CFErrorRef v23 = err;
          if (err)
          {
            CFErrorRef err = 0LL;
            CFRelease(v23);
          }
        }
      }
    }
  }

  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16LL))())
  {
    if (!a3 || !*a3 || CFErrorGetCode((CFErrorRef)*a3) != -25330) {
      return 1LL;
    }
    CFErrorDomain v25 = CFErrorGetDomain((CFErrorRef)*a3);
    CFErrorDomain v26 = (CFErrorDomain)*MEMORY[0x189604F50];
    if (v25 && v26)
    {
      if (!CFEqual(v25, v26)) {
        return 1LL;
      }
LABEL_38:
      v27 = CFErrorCopyUserInfo((CFErrorRef)*a3);
      CFErrorRef err = (CFErrorRef)-25330LL;
      CFNumberRef v28 = CFNumberCreate(0LL, kCFNumberCFIndexType, &err);
      CFTypeRef v29 = CFDictionaryGetValue(v27, v28);
      CFTypeRef v30 = *a2;
      if (*a2 != v29)
      {
        if (!v29 || (CFRetain(v29), (CFTypeRef v30 = *a2) != 0LL)) {
          CFRelease(v30);
        }
        *a2 = v29;
      }

      if (!v29)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
        if (*a2) {
          CFRelease(*a2);
        }
        *a2 = Mutable;
      }

      CFRelease(v28);
      CFRelease(v27);
      v32 = *a3;
      if (*a3)
      {
        *a3 = 0LL;
        CFRelease(v32);
      }

      return 2LL;
    }

    if (v25 == v26) {
      goto LABEL_38;
    }
    return 1LL;
  }

  if (!a3) {
    return 0LL;
  }
  uint64_t result = (uint64_t)*a3;
  if (*a3)
  {
    *a3 = 0LL;
    CFRelease((CFTypeRef)result);
    return 0LL;
  }

  return result;
}

uint64_t __SecItemCopyMatching_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5, CFTypeRef *a6)
{
  CFTypeRef cf = 0LL;
  +[SecItemRateLimit instance](&OBJC_CLASS___SecItemRateLimit, "instance");
  __int16 v10 = (void *)objc_claimAutoreleasedReturnValue();
  char v11 = [v10 isReadOnlyAPICallWithinLimits];

  if ((v11 & 1) == 0) {
    __security_simulatecrash( @"BUG IN CLIENT OF SECITEM: too many reads. See https://at.apple.com/secitemratelimit",  0x53C0000Fu);
  }
  if (gSecurityd
    && (int v12 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *, CFTypeRef *))(gSecurityd + 8)) != 0LL)
  {
    uint64_t v13 = SecSecurityClientGet();
    if ((v12(a3, v13, &cf, a6) & 1) == 0) {
      return 0LL;
    }
  }

  else
  {
    SecSecurityClientGet();
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __cftype_to_BOOL_cftype_error_request_block_invoke;
    v18[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v18[4] = a3;
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = __cftype_to_BOOL_cftype_error_request_block_invoke_2;
    v17[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v17[4] = &cf;
  }

  uint64_t v14 = SecItemResultProcess( *(const __CFDictionary **)(a1 + 32),  a5,  0LL,  cf,  *(CFTypeRef **)(a1 + 40),  (__CFString **)a6);
  if (cf) {
    CFRelease(cf);
  }
  return v14;
}

uint64_t SecSecurityClientGet()
{
  if (SecSecurityClientGet_onceToken != -1) {
    dispatch_once(&SecSecurityClientGet_onceToken, &__block_literal_global_731);
  }
  onceTokenThreadLocalClient = (dispatch_once_t *)SecSecurityClientGet_onceTokenThreadLocalClient();
  if (*onceTokenThreadLocalClient != -1) {
    dispatch_once(onceTokenThreadLocalClient, &__block_literal_global_2);
  }
  if (gSecurityd && *(void *)(gSecurityd + 688))
  {
    uint64_t v1 = threadLocalClient(&threadLocalClient);
    v2(v1);
  }

  return threadLocalClient(&threadLocalClient);
}

CFTypeRef __SecSecurityClientGet_block_invoke_2()
{
  v0 = (os_log_s *)secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 v5 = 0;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "SecSecurityClientGet new thread!", v5, 2u);
  }

  uint64_t v1 = threadLocalClient();
  *(_OWORD *)uint64_t v1 = gClient;
  *(_OWORD *)(v1 + 16) = xmmword_18C4872B8;
  *(_OWORD *)(v1 + 32) = xmmword_18C4872C8;
  *(void *)(v1 + 48) = qword_18C4872D8;
  if (*(void *)v1) {
    CFRetain(*(CFTypeRef *)v1);
  }
  CFTypeRef v2 = *(const void **)(v1 + 8);
  if (v2) {
    CFRetain(v2);
  }
  v3 = *(const void **)(v1 + 24);
  if (v3) {
    CFRetain(v3);
  }
  CFTypeRef result = *(CFTypeRef *)(v1 + 40);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t securityd_send_sync_and_do(unsigned int a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t message = securityd_create_message(a1, a2);
  if (!message) {
    return 0LL;
  }
  v8 = message;
  if ((!a3 || (*(unsigned int (**)(uint64_t, xpc_object_t, CFTypeRef *))(a3 + 16))(a3, message, a2))
    && (uint64_t v9 = securityd_message_with_reply_sync(v8, (uint64_t)a2)) != 0)
  {
    __int16 v10 = (void *)v9;
    if (securityd_message_no_error(v9, (CFErrorRef *)a2))
    {
      if (a4) {
        uint64_t v11 = (*(uint64_t (**)(uint64_t, void *, CFTypeRef *))(a4 + 16))(a4, v10, a2);
      }
      else {
        uint64_t v11 = 1LL;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    xpc_release(v10);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  xpc_release(v8);
  return v11;
}

xpc_object_t securityd_create_message(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_object_t v8 = v4;
  if (v4) {
    xpc_dictionary_set_uint64(v4, "operation", a1);
  }
  else {
    SecCFCreateErrorWithFormat( 3LL,  (const __CFString *)sSecXPCErrorDomain,  0LL,  a2,  v5,  @"xpc_dictionary_create returned NULL",  v6,  v7,  v10);
  }
  return v8;
}

size_t SecXPCDictionarySetPListWithRepair( void *a1, const char *a2, const __CFString *a3, __CFString **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return SecError(-50, a4, @"object for key %s is NULL", a2);
  }
  size_t result = der_sizeof_plist(a3, (CFTypeRef *)a4, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if (result)
  {
    size_t v13 = result;
    uint64_t v14 = (UInt8 *)malloc(result);
    unint64_t v15 = (unint64_t)&v14[v13];
    uint64_t v19 = (const void *)der_encode_plist_repair(a3, (CFTypeRef *)a4, 0LL, v14, v15, v16, v17, v18);
    if (v19 && v15 > (unint64_t)v19)
    {
      xpc_dictionary_set_data(a1, a2, v19, v15 - (void)v19);
      free(v14);
      return 1LL;
    }

    else
    {
      free(v14);
      return 0LL;
    }
  }

  return result;
}

uint64_t der_sizeof_plist( const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    unint64_t v15 = (const __CFString *)sSecDERErrorDomain;
    uint64_t v16 = @"Null CFType";
LABEL_8:
    SecCFCreateErrorWithFormat(-5LL, v15, 0LL, a2, a5, v16, a7, a8, v18);
    return 0LL;
  }

  CFTypeID v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      uint64_t v12 = 0LL;
      unint64_t v13 = Count + 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 2);
        v12 += der_sizeof_plist(ValueAtIndex, a2);
        --v13;
      }

      while (v13 > 1);
    }

    return ccder_sizeof();
  }

  if (CFBooleanGetTypeID() == v10) {
    return ccder_sizeof();
  }
  if (CFDataGetTypeID() == v10)
  {
    CFDataGetLength((CFDataRef)a1);
    return ccder_sizeof_raw_octet_string();
  }

  if (CFDateGetTypeID() == v10) {
    return der_sizeof_date();
  }
  if (CFDictionaryGetTypeID() == v10) {
    return der_sizeof_dictionary((const __CFDictionary *)a1, (uint64_t)a2);
  }
  if (CFSetGetTypeID() == v10) {
    return der_sizeof_set((const __CFSet *)a1, (uint64_t)a2);
  }
  if (CFStringGetTypeID() == v10) {
    return der_sizeof_string(a1);
  }
  if (CFNumberGetTypeID() != v10)
  {
    if (CFNullGetTypeID() != v10)
    {
      unint64_t v15 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v16 = @"Unsupported CFType";
      goto LABEL_8;
    }

    return ccder_sizeof();
  }

  return der_sizeof_number((const __CFNumber *)a1, a2);
}

uint64_t der_sizeof_dictionary(const __CFDictionary *a1, uint64_t a2)
{
  __int128 v3 = xmmword_18065A240;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)add_key_value_size, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0LL;
  }
}

uint64_t add_key_value_size(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    size_t result = der_sizeof_key_value(result, a2, *(CFTypeRef **)(a3 + 16));
    if (result) {
      *(void *)(a3 + 8) += result;
    }
    else {
      *(_BYTE *)a3 = 0;
    }
  }

  return result;
}

uint64_t der_sizeof_key_value(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if (der_sizeof_plist(a1, a3) && der_sizeof_plist(a2, a3)) {
    return ccder_sizeof();
  }
  SecCFCreateErrorWithFormat(-6LL, (const __CFString *)sSecDERErrorDomain, 0LL, a3, v5, @"null input", v6, v7, v9);
  return 0LL;
}

uint64_t der_sizeof_string(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex usedBufLen = 0LL;
  v6.location = 0LL;
  v6.length = Length;
  CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, 0LL, MaximumSizeForEncoding, &usedBufLen);
  return ccder_sizeof();
}

uint64_t der_encode_plist_repair( const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CFTypeRef v22 = (const __CFString *)sSecDERErrorDomain;
    CFErrorRef v23 = @"Null CFType";
LABEL_8:
    SecCFCreateErrorWithFormat(-5LL, v22, 0LL, a2, a5, v23, a7, a8, v31);
    return 0LL;
  }

  CFTypeID v13 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v13)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      unint64_t v15 = Count + 1;
      uint64_t v16 = a5;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v15 - 2);
        uint64_t v16 = der_encode_plist_repair(ValueAtIndex, a2, a3, a4, v16);
        --v15;
      }

      while (v15 > 1);
    }

    goto LABEL_6;
  }

  if (CFBooleanGetTypeID() == v13)
  {
    CFBooleanGetValue((CFBooleanRef)a1);
    ccder_encode_body();
    uint64_t v18 = ccder_encode_tl();
LABEL_11:
    uint64_t v24 = v18;
    if (!v18) {
      SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v19,  @"ccder failed to encode",  v20,  v21,  v31);
    }
    return v24;
  }

  if (CFDataGetTypeID() == v13) {
    return der_encode_data((const __CFData *)a1, a2);
  }
  if (CFDateGetTypeID() == v13)
  {
    double v26 = MEMORY[0x186DFE188](a1);
    der_encode_generalizedtime_body_repair(a2, a3, (uint64_t)a4, a5, v26);
LABEL_6:
    uint64_t v18 = ccder_encode_constructed_tl();
    goto LABEL_11;
  }

  if (CFDictionaryGetTypeID() == v13) {
    return der_encode_dictionary_repair((const __CFDictionary *)a1, a2, a3);
  }
  if (CFSetGetTypeID() == v13) {
    return der_encode_set_repair((const __CFSet *)a1, a2, a3);
  }
  if (CFStringGetTypeID() == v13) {
    return der_encode_string(a1, a2, a4, a5, v27, v28, v29, v30);
  }
  if (CFNumberGetTypeID() == v13) {
    return der_encode_number((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  }
  if (CFNullGetTypeID() != v13)
  {
    CFTypeRef v22 = (const __CFString *)sSecDERErrorDomain;
    CFErrorRef v23 = @"Unsupported CFType";
    goto LABEL_8;
  }

  return der_encode_null(a2);
}

uint64_t der_encode_dictionary_repair(const __CFDictionary *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  v14[0] = 0xAAAAAAAAAAAAAA01LL;
  v14[1] = a2;
  BYTE1(v14[0]) = a3;
  v14[2] = Mutable;
  v14[3] = 0LL;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)add_sequence_to_array, v14);
  if (!LOBYTE(v14[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0LL;
  }

  v15.length = CFArrayGetCount(Mutable);
  v15.location = 0LL;
  CFArraySortValues(Mutable, v15, (CFComparatorFunction)cfdata_compare_der_contents, 0LL);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }

    while (v8 > 1);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v11,  @"ccder failed to encode",  v12,  v13,  v14[0]);
    return 0LL;
  }

  return result;
}

void add_sequence_to_array(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    CFIndex v6 = der_sizeof_key_value(a1, a2, *(CFTypeRef **)(a3 + 8));
    if (!v6)
    {
      *(_BYTE *)a3 = 0;
      return;
    }

    CFIndex v7 = v6;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v6);
    CFDataSetLength(Mutable, v7);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    CFTypeID v10 = &MutableBytePtr[v7];
    uint64_t v11 = *(CFTypeRef **)(a3 + 8);
    uint64_t v12 = *(unsigned __int8 *)(a3 + 1);
    uint64_t v13 = der_encode_plist_repair(a2, v11, v12, MutableBytePtr, v10);
    der_encode_plist_repair(a1, v11, v12, MutableBytePtr, v13);
    uint64_t v14 = ccder_encode_constructed_tl();
    if (v14)
    {
      v19.length = v14 - (void)MutableBytePtr;
      v19.location = 0LL;
      CFDataDeleteBytes(Mutable, v19);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }

    else
    {
      SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  v11,  v15,  @"ccder failed to encode",  v16,  v17,  v18);
      *(_BYTE *)a3 = 0;
      if (!Mutable) {
        return;
      }
    }

    CFRelease(Mutable);
  }

uint64_t der_encode_string( const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v18 = 0LL;
    v19.location = 0LL;
    v19.length = Length;
    if (CFStringGetBytes(a1, v19, 0x8000100u, 0, 0, a3, a4 - (void)a3, &v18) == Length)
    {
      ccder_encode_body();
      uint64_t result = ccder_encode_tl();
      if (result) {
        return result;
      }
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"ccder failed to encode";
      CFIndex v16 = -7LL;
    }

    else
    {
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"String extraction failed";
      CFIndex v16 = -5LL;
    }
  }

  else
  {
    uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
    uint64_t v15 = @"null input";
    CFIndex v16 = -6LL;
  }

  SecCFCreateErrorWithFormat(v16, v14, 0LL, a2, a5, v15, a7, a8, usedBufLen);
  return 0LL;
}

uint64_t cfdata_compare_der_contents(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = -1LL;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    char v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1LL;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }

    else
    {
      return 1LL;
    }
  }

uint64_t securityd_message_with_reply_sync(void *a1, uint64_t a2)
{
  uint64_t uint64 = xpc_dictionary_get_uint64(a1, "operation");
  int v10 = 6;
  CFIndex v5 = securityd_connection_for_operation(uint64, &v10);
  switch(v10)
  {
    case 0:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    case 1:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    case 2:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    case 3:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    case 4:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    case 5:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
    default:
      unint64_t v6 = a1;
      uint64_t v7 = uint64;
      uint64_t v8 = a2;
      break;
  }

  return security_fw_CALLING_SECD_OR_SECURITYD(v6, v5, v7, v8);
}

_xpc_connection_s *securityd_connection_for_operation(unsigned int a1, _DWORD *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  char v4 = is_trust_operation(a1);
  if (a1 - 100 <= 0x21 && ((1LL << (a1 - 100)) & 0x220000003LL) != 0 || a1 - 4 < 3)
  {
    if ((v4 & 1) != 0)
    {
      *a2 = 5;
      if (trustd_system_connection_once != -1) {
        dispatch_once(&trustd_system_connection_once, &__block_literal_global_41);
      }
      return (_xpc_connection_s *)sTrustdSystemInstanceConnection;
    }

    goto LABEL_17;
  }

  if ((v4 & 1) == 0)
  {
LABEL_17:
    int v9 = 1;
    if ((a1 - 95 > 4 || ((1 << (a1 - 95)) & 0x13) == 0) && a1 != 8) {
      int v9 = 0;
    }
    int v10 = 0;
    for (unsigned int i = 1; ; ++i)
    {
      int v12 = v10;
      if (v9)
      {
        *a2 = 1;
        if ((xpc_user_sessions_enabled() & 1) != 0)
        {
          LODWORD(v23) = 0;
          int foreground_uid = xpc_user_sessions_get_foreground_uid();
          if ((_DWORD)v23)
          {
            uint64_t v14 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v23;
              _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "xpc: could not get foreground uid %d", buf, 8u);
            }

            int v15 = -1;
          }

          else
          {
            int v15 = foreground_uid;
            uint64_t v17 = (os_log_s *)secLogObjForScope("xpc");
            CFIndex v18 = v17;
            if (v15 == 501)
            {
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = 501;
                _os_log_debug_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEBUG,  "user sessions enabled, targeting %d",  buf,  8u);
              }
            }

            else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v15;
              _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "user sessions enabled, targeting %d", buf, 8u);
            }
          }

          int v16 = v15;
        }

        else
        {
          int v16 = -1;
        }

        connection = securityd_create_connection("com.apple.securityd", v16);
        if (connection) {
          goto LABEL_41;
        }
      }

      else
      {
        *a2 = 0;
        if (_securityd_connection_onceToken != -1) {
          dispatch_once(&_securityd_connection_onceToken, &__block_literal_global_44);
        }
        uint64_t v23 = 0LL;
        uint64_t v24 = &v23;
        uint64_t v25 = 0x2000000000LL;
        uint64_t v26 = 0LL;
        *(void *)buf = MEMORY[0x1895F87A8];
        uint64_t v28 = 0x40000000LL;
        uint64_t v29 = ___securityd_connection_block_invoke_2;
        uint64_t v30 = &unk_189665028;
        char v31 = &v23;
        dispatch_sync((dispatch_queue_t)sSecuritydConnectionsQueue, buf);
        connection = (_xpc_connection_s *)v24[3];
        _Block_object_dispose(&v23, 8);
        if (connection) {
          goto LABEL_41;
        }
      }

      usleep(0x9C4u);
LABEL_41:
      ++v10;
      if (100 * (i / 0x64) - 1 == v12)
      {
        CFRange v19 = (os_log_s *)secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v10;
          _os_log_impl( &dword_1804F4000,  v19,  OS_LOG_TYPE_DEFAULT,  "xpc: have been trying %d times to get a securityd connection",  buf,  8u);
        }
      }

      if (connection) {
        return connection;
      }
    }
  }

  if ((a1 - 95 > 4 || ((1 << (a1 - 95)) & 0x13) == 0) && a1 != 8)
  {
    *a2 = 3;
    if (trustd_connection_once != -1) {
      dispatch_once(&trustd_connection_once, &__block_literal_global_33);
    }
    return (_xpc_connection_s *)sTrustdConnection;
  }

  *a2 = 4;
  if (trustd_connection_once != -1) {
    dispatch_once(&trustd_connection_once, &__block_literal_global_33);
  }
  name = xpc_connection_get_name((xpc_connection_t)sTrustdConnection);
  if ((xpc_user_sessions_enabled() & 1) != 0)
  {
    LODWORD(v23) = 0;
    int v8 = xpc_user_sessions_get_foreground_uid();
    int v20 = v8;
    uint64_t v21 = (os_log_s *)secLogObjForScope("xpc");
    CFTypeRef v22 = v21;
    if (v20 == 501)
    {
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 501;
        _os_log_debug_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEBUG, "user sessions enabled, targeting %d", buf, 8u);
      }
    }

    else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEFAULT, "user sessions enabled, targeting %d", buf, 8u);
    }

    return securityd_create_connection(name, v20);
  }

  return securityd_create_connection(name, -1);
}

uint64_t is_trust_operation(unsigned int a1)
{
  uint64_t result = 1LL;
  if ((a1 - 100 > 0x23 || ((1LL << (a1 - 100)) & 0xE7FFF8007LL) == 0)
    && (a1 > 0x1A || ((1 << a1) & 0x6980170) == 0))
  {
    return 0LL;
  }

  return result;
}

void ___securityd_connection_block_invoke_2(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  if (CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool) < 1)
  {
    if (sSecuritydConnectionsCount <= 4)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = securityd_create_connection( "com.apple.securityd",  -1);
      ++sSecuritydConnectionsCount;
      CFTypeRef v2 = (os_log_s *)secLogObjForScope("xpc");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        v3[0] = 67109120;
        v3[1] = sSecuritydConnectionsCount;
        _os_log_debug_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEBUG,  "Adding securityd connection to pool, total now %d",  (uint8_t *)v3,  8u);
      }
    }
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFArrayGetValueAtIndex( (CFArrayRef)sSecuritydConnectionsPool,  0LL);
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)sSecuritydConnectionsPool, 0LL);
  }

void _securityd_process_message_reply(xpc_object_t *a1, CFTypeRef *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (MEMORY[0x186E0087C](*a1) == MEMORY[0x1895F9268])
  {
    if (*a1 == (xpc_object_t)MEMORY[0x1895F9198] || *a1 == (xpc_object_t)MEMORY[0x1895F91A0])
    {
      int v9 = (os_log_s *)secLogObjForScope("SecCritical");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = is_trust_operation(a4);
        uint64_t v11 = "securityd";
        if (v10) {
          uint64_t v11 = "trustd";
        }
        *(_DWORD *)buf = 136315394;
        int v20 = v11;
        __int16 v21 = 1024;
        int v22 = 4;
        _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "Failed to talk to %s after %d attempts.", buf, 0x12u);
      }

      CFIndex v12 = 3LL;
    }

    else
    {
      CFIndex v12 = 4LL;
    }

    uint64_t v13 = (void *)MEMORY[0x186E00738](a3);
    xpc_dictionary_get_string(*a1, (const char *)*MEMORY[0x1895F91B0]);
    uint64_t v17 = (void *)xpc_connection_copy_invalidation_reason();
    if (v17) {
      CFIndex v18 = @"%s: %s - %s";
    }
    else {
      CFIndex v18 = @"%s: %s";
    }
    SecCFCreateErrorWithFormat(v12, (const __CFString *)sSecXPCErrorDomain, 0LL, a2, v14, v18, v15, v16, (char)v13);
    free(v13);
    free(v17);
    xpc_release(*a1);
    *a1 = 0LL;
  }

void return_securityd_connection_to_pool(unsigned int a1, char a2, _xpc_connection_s *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  int v6 = is_trust_operation(a1);
  unsigned int v7 = a1 - 95;
  if (!v6)
  {
    if ((v7 > 4 || ((1 << v7) & 0x13) == 0) && a1 != 8 && (a2 & 1) == 0)
    {
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __return_securityd_connection_to_pool_block_invoke;
      block[3] = &__block_descriptor_tmp_54;
      block[4] = a3;
      dispatch_sync((dispatch_queue_t)sSecuritydConnectionsQueue, block);
      return;
    }

    int v8 = (os_log_s *)secLogObjForScope("xpc");
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_12;
    }
    *(_DWORD *)buf = 134217984;
    CFIndex v12 = a3;
    int v9 = "cleaning up unpooled xpc conn %p";
    goto LABEL_16;
  }

  if (v7 <= 4 && ((1 << v7) & 0x13) != 0 || a1 == 8)
  {
    int v8 = (os_log_s *)secLogObjForScope("xpc");
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
LABEL_12:
      xpc_connection_cancel(a3);
      xpc_release(a3);
      return;
    }

    *(_DWORD *)buf = 134217984;
    CFIndex v12 = a3;
    int v9 = "cleaning up unpooled xpc conn to trustd %p";
LABEL_16:
    _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, v9, buf, 0xCu);
    goto LABEL_12;
  }

void __return_securityd_connection_to_pool_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool) >= 5)
  {
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    CFTypeRef v2 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "xpc: Unable to re-enqueue securityd connection because already at limit",  (uint8_t *)v6,  2u);
    }

    if (sSecuritydConnectionsCount <= 4)
    {
      __int128 v3 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = sSecuritydConnectionsCount;
        CFIndex Count = CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool);
        v6[0] = 67109376;
        v6[1] = v4;
        __int16 v7 = 2048;
        CFIndex v8 = Count;
        _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "xpc: connection pool full but tracker does not agree (%d vs %ld)",  (uint8_t *)v6,  0x12u);
      }
    }

    abort();
  }

  CFArrayAppendValue((CFMutableArrayRef)sSecuritydConnectionsPool, *(const void **)(a1 + 32));
}

uint64_t securityd_message_no_error(uint64_t result, CFErrorRef *a2)
{
  if (result)
  {
    xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)result, "error");
    if (value)
    {
      CFErrorRef CFErrorWithXPCObject = SecCreateCFErrorWithXPCObject(value);
      CFErrorRef v5 = CFErrorWithXPCObject;
      if (a2)
      {
        uint64_t result = 0LL;
        *a2 = v5;
      }

      else
      {
        if (CFErrorWithXPCObject) {
          CFRelease(CFErrorWithXPCObject);
        }
        return 0LL;
      }
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

CFErrorRef SecCreateCFErrorWithXPCObject(void *a1)
{
  CFTypeRef v20 = 0LL;
  if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9250])
  {
    SecCFCreateErrorWithFormat( 1LL,  (const __CFString *)sSecXPCErrorDomain,  0LL,  &v20,  v2,  @"Remote error not dictionary!: %@",  v3,  v4,  (char)a1);
    return (CFErrorRef)v20;
  }

  string = xpc_dictionary_get_string(a1, "domain");
  __int16 v7 = (uint64_t *)MEMORY[0x189604DB0];
  if (string)
  {
    CFIndex v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], string, 0x8000100u);
  }

  else
  {
    CFIndex v8 = (const __CFString *)sSecXPCErrorDomain;
    CFRetain((CFTypeRef)sSecXPCErrorDomain);
  }

  int64_t int64 = xpc_dictionary_get_int64(a1, "code");
  size_t length = 0LL;
  CFTypeRef cf = 0LL;
  data = xpc_dictionary_get_data(a1, "userinfo", &length);
  if (data)
  {
    size_t v14 = (size_t)data + length;
    uint64_t v15 = der_decode_plist(*v7, (uint64_t)&cf, 0LL, (uint64_t)data, (uint64_t)data + length, v11, v12, v13);
    CFTypeRef v16 = cf;
    if (v15 == v14)
    {
      CFErrorRef v5 = CFErrorCreate(0LL, v8, int64, (CFDictionaryRef)cf);
      if (v16) {
        CFRelease(v16);
      }
      goto LABEL_11;
    }

    if (cf) {
      CFRelease(cf);
    }
  }

  CFErrorRef v5 = CFErrorCreate(0LL, v8, int64, 0LL);
LABEL_11:
  if (v8) {
    CFRelease(v8);
  }
  return v5;
}

uint64_t der_decode_plist( uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a4;
  if (a4)
  {
    if (ccder_decode_tag())
    {
      uint64_t v13 = (const __CFString *)sSecDERErrorDomain;
      size_t v14 = @"Unsupported DER Type";
      CFIndex v15 = -2LL;
    }

    else
    {
      uint64_t v13 = (const __CFString *)sSecDERErrorDomain;
      size_t v14 = @"invalid tag";
      CFIndex v15 = -1LL;
    }

    SecCFCreateErrorWithFormat(v15, v13, 0LL, a3, v10, v14, v11, v12, 170);
    return 0LL;
  }

  else
  {
    SecCFCreateErrorWithFormat( -6LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  a5,  @"null input",  a7,  a8,  v17);
  }

  return v8;
}

uint64_t der_decode_dictionary( const __CFAllocator *a1, CFMutableDictionaryRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    uint64_t v14 = ccder_decode_constructed_tl();
    if (v14)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      if (Mutable)
      {
        CFRelease(Mutable);
      }

      else
      {
        SecCFCreateErrorWithFormat( -3LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  v15,  @"Failed to create dictionary",  v16,  v17,  0);
        uint64_t v14 = 0LL;
        if (!v21) {
          *a2 = Mutable;
        }
      }
    }

    else
    {
      SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  v11,  @"Unknown data encoding, expected CCDER_CONSTRUCTED_SET",  v12,  v13,  0);
    }
  }

  else
  {
    SecCFCreateErrorWithFormat( -6LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  a5,  @"null input",  a7,  a8,  v20);
    return 0LL;
  }

  return v14;
}

const UInt8 *der_decode_string( const __CFAllocator *a1, CFStringRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    uint64_t v12 = (const UInt8 *)ccder_decode_tl();
    if (v12 && (uint64_t v13 = v12, a5 - (uint64_t)v12 >= 0))
    {
      CFStringRef v18 = CFStringCreateWithBytes(a1, v12, 0LL, 0x8000100u, 0);
      *a2 = v18;
      if (v18) {
        return v13;
      }
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"String allocation failed";
      CFIndex v16 = -3LL;
    }

    else
    {
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"Unknown string encoding";
      CFIndex v16 = -1LL;
    }
  }

  else
  {
    uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
    uint64_t v15 = @"null input";
    CFIndex v16 = -6LL;
  }

  SecCFCreateErrorWithFormat(v16, v14, 0LL, a3, a5, v15, a7, a8, v19);
  return 0LL;
}

uint64_t der_decode_number( const __CFAllocator *a1, CFNumberRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    uint64_t v20 = 0LL;
    uint64_t v12 = ccder_decode_tl();
    if (v12 && (uint64_t v13 = v12, a5 - v12 >= v20))
    {
      uint64_t v19 = 0LL;
      CFNumberRef v17 = CFNumberCreate(a1, kCFNumberLongLongType, &v19);
      *a2 = v17;
      if (v17) {
        return v13 + v20;
      }
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"Number allocation failed";
      CFIndex v16 = -3LL;
    }

    else
    {
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"Unknown number encoding";
      CFIndex v16 = -1LL;
    }
  }

  else
  {
    uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
    uint64_t v15 = @"null input";
    CFIndex v16 = -6LL;
  }

  SecCFCreateErrorWithFormat(v16, v14, 0LL, a3, a5, v15, a7, a8, v19);
  return 0LL;
}

void SetLastError(const void *a1)
{
  if (getLastErrorKey_onceToken != -1) {
    dispatch_once(&getLastErrorKey_onceToken, &__block_literal_global_81);
  }
  if (getLastErrorKey_haveKey == 1)
  {
    pthread_key_t v2 = getLastErrorKey_key;
    uint64_t v3 = pthread_getspecific(getLastErrorKey_key);
    if (v3) {
      CFRelease(v3);
    }
    if (a1) {
      CFRetain(a1);
    }
    pthread_setspecific(v2, a1);
  }

uint64_t SecErrorGetOSStatus(uint64_t result)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!result) {
    return result;
  }
  uint64_t v1 = (__CFError *)result;
  CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)result);
  if (!Domain)
  {
    secLogObjForScope("SecError");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      uint64_t v15 = v1;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "No error domain for error: %@", (uint8_t *)&v14, 0xCu);
    }

    return 4294941020LL;
  }

  CFErrorDomain v3 = Domain;
  if (CFEqual((CFTypeRef)*MEMORY[0x189604F50], Domain)) {
    return CFErrorGetCode(v1);
  }
  if (!CFEqual(@"com.apple.utilities.sqlite3", v3))
  {
    if (CFEqual((CFTypeRef)*MEMORY[0x189604F58], v3)) {
      return CFErrorGetCode(v1);
    }
    if (CFEqual((CFTypeRef)*MEMORY[0x189604F48], v3))
    {
      CFIndex Code = CFErrorGetCode(v1);
      return osstatus_for_kern_return(Code);
    }

    if (CFEqual((CFTypeRef)sSecXPCErrorDomain, v3))
    {
      unint64_t v7 = CFErrorGetCode(v1);
      if (v7 < 4) {
        return dword_18065A2A0[v7];
      }
    }

    else if (CFEqual((CFTypeRef)sSecDERErrorDomain, v3))
    {
      unint64_t v8 = CFErrorGetCode(v1);
      if (v8 > 0xFFFFFFFFFFFFFFFALL) {
        return *((unsigned int *)&unk_18065770C + v8 + 5);
      }
    }

    else
    {
      if (LocalAuthenticationLibraryCore())
      {
        if (getLAErrorDomainSymbolLoc())
        {
          getLAErrorDomain();
          if (CFEqual(v9, v3))
          {
            CFIndex v10 = CFErrorGetCode(v1);
            switch(v10)
            {
              case -1004LL:
                return 4294941988LL;
              case -2LL:
                return 4294967168LL;
              case -1001LL:
                return 4294967246LL;
            }

            return 4294942003LL;
          }
        }
      }

      if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc() && (getTKErrorDomain(), CFEqual(v11, v3)))
      {
        unint64_t v12 = CFErrorGetCode(v1);
        if (v12 > 0xFFFFFFFFFFFFFFF7LL) {
          return *((unsigned int *)&unk_180657720 + v12 + 8);
        }
      }

      else if (!CFEqual(@"com.apple.security.sos.error", v3))
      {
        secLogObjForScope("securityd");
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = 138412546;
          uint64_t v15 = (__CFError *)v3;
          __int16 v16 = 2112;
          CFNumberRef v17 = v1;
          _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "unknown error domain: %@ for error: %@",  (uint8_t *)&v14,  0x16u);
        }
      }
    }

    return 4294941020LL;
  }

  int v5 = CFErrorGetCode(v1);
  uint64_t result = 0LL;
  if (v5 > 18)
  {
    switch(v5)
    {
      case 19:
        return 4294941997LL;
      case 20:
        return 4294941993LL;
      case 101:
        break;
      default:
        return 4294942005LL;
    }
  }

  else
  {
    switch(v5)
    {
      case 0:
        return result;
      case 2:
        uint64_t result = 4294965226LL;
        break;
      case 4:
        uint64_t result = 0xFFFFFFFFLL;
        break;
      case 7:
        uint64_t result = 4294967188LL;
        break;
      case 8:
        uint64_t result = 4294942004LL;
        break;
      case 10:
        uint64_t result = 4294967260LL;
        break;
      default:
        return 4294942005LL;
    }
  }

  return result;
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    mach_msg_type_number_t task_info_outCnt = 8;
    if (task_info(*MEMORY[0x1895FBBE0], 0xFu, (task_info_t)(Instance + 16), &task_info_outCnt))
    {
      CFRelease((CFTypeRef)Instance);
      return 0LL;
    }

    else
    {
      *(_BYTE *)(Instance + 48) = 0;
      *(void *)(Instance + 56) = 0LL;
    }
  }

  return (SecTaskRef)Instance;
}

CFTypeID SecTaskGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTaskGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_14270;
  block[4] = &SecTaskGetTypeID_sSecTaskGetTypeIDSingleton;
  if (SecTaskGetTypeID_sSecTaskGetTypeIDOnce != -1) {
    dispatch_once(&SecTaskGetTypeID_sSecTaskGetTypeIDOnce, block);
  }
  return SecTaskGetTypeID_sSecTaskGetTypeIDSingleton;
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  CFTypeID TypeID = SecTaskGetTypeID();
  unint64_t v7 = (const __CFDictionary *)*((void *)task + 7);
  if (!v7) {
    return 0LL;
  }
  Value = CFDictionaryGetValue(v7, entitlement);
  CFTypeRef v9 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v9;
}

BOOL SecTaskLoadEntitlements(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = 0LL;
  int v4 = csops_task(a1);
  if (v4 != -1)
  {
    int v5 = v4;
    int v6 = 0LL;
    *(void *)(a1 + 56) = 0LL;
    *(_BYTE *)(a1 + 48) = 1;
    goto LABEL_3;
  }

  if (*__error() != 34)
  {
    int v5 = *__error();
    pid_t v23 = -1;
    if (csops_task(a1) == -1)
    {
      CFIndex v10 = __error();
      syslog(5, "Failed to get cs_flags, error=%d", *v10);
    }

    pid_t pidp = -1431655766;
    __int128 v11 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v11;
    audit_token_to_au32(&atoken, 0LL, 0LL, 0LL, 0LL, 0LL, &pidp, 0LL, 0LL);
    syslog(5, "SecTaskLoadEntitlements failed error=%d cs_flags=%x, pid=%d", v5, v23, pidp);
    unint64_t v12 = SecTaskCopyDebugDescription(a1);
    CFIndex v13 = 4 * CFStringGetLength(v12);
    int v14 = (char *)malloc(v13);
    if (!CFStringGetCString(v12, v14, v13, 0x8000100u)) {
      char *v14 = 0;
    }
    syslog(5, "SecTaskCopyDebugDescription: %s", v14);
    if (v12) {
      CFRelease(v12);
    }
    free(v14);
    *(_DWORD *)(a1 + 64) = v5;
    if (v5 == 22)
    {
      BOOL result = 1LL;
      *(_BYTE *)(a1 + 48) = 1;
      return result;
    }

    int v6 = 0LL;
LABEL_3:
    CFTypeRef v7 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v7);
    }

    if (!v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  size_t v9 = bswap32(HIDWORD(v25));
  if ((v9 - 1048577) < 0xFFF00007)
  {
    int v6 = 0LL;
    int v5 = 7;
    goto LABEL_3;
  }

  int v6 = (UInt8 *)malloc(v9);
  if (!v6)
  {
    int v5 = 12;
    goto LABEL_3;
  }

  if (csops_task(a1))
  {
    int v5 = *__error();
    goto LABEL_3;
  }

  CFDataRef v15 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  v6 + 8,  (v9 - 8),  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint64_t v16 = CEManagedContextFromCFData();
  CFNumberRef v17 = (void *)MEMORY[0x1896135D8];
  if (v16 != *MEMORY[0x1896135D8])
  {
    pid_t v23 = -1431655766;
    __int128 v18 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v18;
    audit_token_to_au32(&atoken, 0LL, 0LL, 0LL, 0LL, 0LL, &v23, 0LL, 0LL);
    uint64_t v19 = (os_log_s *)secLogObjForScope("SecTask");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      atoken.val[0] = 67109120;
      atoken.val[1] = v23;
      uint64_t v20 = "couldn't create a managed context from csops call %d";
      goto LABEL_40;
    }

    goto LABEL_33;
  }

  if (CEQueryContextToCFDictionary() != *v17)
  {
    pid_t v23 = -1431655766;
    __int128 v21 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v21;
    audit_token_to_au32(&atoken, 0LL, 0LL, 0LL, 0LL, 0LL, &v23, 0LL, 0LL);
    uint64_t v19 = (os_log_s *)secLogObjForScope("SecTask");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      atoken.val[0] = 67109120;
      atoken.val[1] = v23;
      uint64_t v20 = "couldn't convert CE to CF %d";
LABEL_40:
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, v20, (uint8_t *)&atoken, 8u);
      if (!v15) {
        goto LABEL_35;
      }
      goto LABEL_34;
    }

LABEL_33:
    if (!v15)
    {
LABEL_35:
      int v5 = 33;
      goto LABEL_3;
    }

              uint64_t v30 = v33;
            }

            else
            {
              uint64_t v30 = 0;
            }

            char v31 = 0LL;
            v76 = 0LL;
            v77 = 0LL;
            uint64_t v26 = 0LL;
            CFTypeID v34 = 0LL;
          }

          else
          {
            v76 = 0LL;
            v77 = 0LL;
            uint64_t v26 = 0LL;
            CFTypeID v34 = 0LL;
          }
        }

        else
        {
          uint64_t v29 = 0LL;
          char v31 = 0LL;
          v76 = 0LL;
          v77 = 0LL;
          uint64_t v26 = 0LL;
          CFTypeID v34 = 0LL;
          uint64_t v30 = -8152;
        }

        v42 = cf;
        goto LABEL_45;
      }

      uint64_t v30 = 0;
      char v31 = 0LL;
      v76 = 0LL;
      v77 = 0LL;
      uint64_t v26 = 0LL;
      CFTypeID v34 = 0LL;
      goto LABEL_47;
    }

    v35 = SecCertificateCopyKey(v15);
    if (!v35) {
      goto LABEL_116;
    }
    xpc_object_t v36 = v35;
    Size = SecKeyGetSize((uint64_t)v35, 2);
    CFIndex v38 = PORT_ArenaAlloc(v16, Size);
    *(void *)(v13 + 72) = Size;
    *(void *)(v13 + 80) = v38;
    if (!v38
      || CFDataGetLength(v12) < 0
      || (CFIndex v39 = CFDataGetBytePtr(v12),
          v40 = CFDataGetLength(v12),
          SecKeyEncrypt(v36, 1u, v39, v40, *(uint8_t **)(v13 + 80), (size_t *)(v13 + 72))))
    {
      CFRelease(v36);
      goto LABEL_116;
    }

    CFRelease(v36);
    uint64_t v30 = SECOID_SetAlgorithmID(v16, (unint64_t *)(v13 + 40), 0x10u, 0LL);
LABEL_70:
    if (v30) {
      goto LABEL_116;
    }
    v48 = *v14++;
    CFIndex v13 = v48;
    if (!v48) {
      goto LABEL_106;
    }
  }

  v68 = PR_getThreadErrInfo(1, (int *)&v90);
  if (!v68) {
    goto LABEL_116;
  }
  v69 = 0xFFFFE00500000000LL;
LABEL_115:
  __CFDictionary *v68 = v69;
LABEL_116:
  if (v12) {
    CFRelease(v12);
  }
  return 0xFFFFFFFFLL;
}

LABEL_34:
    CFRelease(v15);
    goto LABEL_35;
  }

  if (v15) {
    CFRelease(v15);
  }
  int v5 = 33;
LABEL_6:
  free(v6);
LABEL_7:
  if (a2 && v5 && !*a2) {
    *a2 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F58], v5, 0LL);
  }
  CEReleaseManagedContext();
  return v5 == 0;
}

  uint64_t v20 = v19;
LABEL_35:
  theString = v18;
  CFTypeID v34 = CFGetTypeID(a1);
  v93 = v19;
  if (v34 == CFDictionaryGetTypeID())
  {
    uint64_t v24 = CFDictionaryGetValue((CFDictionaryRef)a1, @"v_Data");
    if (!v24) {
      goto LABEL_49;
    }
  }

  else
  {
    uint64_t v24 = a1;
    if (!a1)
    {
LABEL_49:
      v94 = (CFTypeRef *)a6;
      int v22 = 0LL;
      xpc_object_t v36 = 0LL;
      unint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
      BOOL v75 = v10;
LABEL_50:
      if (!v101)
      {
        CFTypeRef cf = v25;
        if (!v102)
        {
          if (v12)
          {
            uint64_t v99 = v12;
            id v89 = v75;
            uint64_t v45 = v22;
            uint64_t v46 = v26;
            v76 = 0LL;
            v47 = 1;
            pid_t v23 = v36;
            goto LABEL_72;
          }

          if (v24) {
            CFRetain(v24);
          }
          v78 = 0LL;
          v77 = 0LL;
          v76 = 0LL;
          *a5 = v24;
          goto LABEL_131;
        }

  return v11;
}

    uint64_t v1 = 0LL;
LABEL_25:
    if ((void)v21) {
      free((void *)v21);
    }
    goto LABEL_27;
  }

  uint64_t v1 = 0LL;
LABEL_27:
  if (v22) {
    free(v22);
  }
  if (v4) {
    free(v4);
  }
  if (v6) {
    free(v6);
  }
  return v1;
}

      __int128 v11 = -26276;
LABEL_36:
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v11;
      return result;
    }

    BOOL result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, @"identity");
    if (!result) {
      goto LABEL_34;
    }
    CFTypeRef v7 = (const void *)result;
    unint64_t v8 = CFGetTypeID((CFTypeRef)result);
    BOOL result = SecIdentityGetTypeID();
    if (v8 != result) {
      goto LABEL_34;
    }
    size_t v9 = secItemOptionsFromPKCS12Options(v4);
    CFDictionaryAddValue(v9, @"nleg", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v9, @"class", @"idnt");
    CFDictionaryAddValue(v9, @"v_Ref", v7);
    CFIndex v10 = SecItemAdd(v9, 0LL);
    if (v10 == -25299)
    {
      unint64_t v12 = (os_log_s *)secLogObjForScope("p12Decode");
      __int128 v11 = 0;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)buf = 0;
      CFIndex v13 = "skipping dup cert";
    }

    else
    {
      __int128 v11 = v10;
      if (v10)
      {
        int v14 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          uint64_t v29 = v11;
          _os_log_impl( &dword_1804F4000,  v14,  OS_LOG_TYPE_DEFAULT,  "p12Decode: Error %d adding identity to keychain",  buf,  8u);
        }

        goto LABEL_15;
      }

      unint64_t v12 = (os_log_s *)secLogObjForScope("p12Decode");
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        if (v9) {
          CFRelease(v9);
        }
        goto LABEL_17;
      }

      *(_WORD *)buf = 0;
      CFIndex v13 = "cert added to keychain";
    }

    _os_log_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
    __int128 v11 = 0;
    goto LABEL_15;
  }

  return result;
}

  std::string::basic_string(&v35, &__str, size - 2, 2uLL, (std::allocator<char> *)v38);
  uint64_t v19 = v35.__r_.__value_.__s.__size_;
  if ((v35.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    uint64_t v19 = v35.__r_.__value_.__l.__size_;
  }
  if (v19 != 2)
  {
    __int128 v21 = 0;
LABEL_43:
    operator delete(v35.__r_.__value_.__l.__data_);
    if (!v21) {
      goto LABEL_49;
    }
    goto LABEL_44;
  }

  uint64_t v20 = (std::string *)v35.__r_.__value_.__r.__words[0];
  if ((v35.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v20 = &v35;
  }
  __int128 v21 = LOWORD(v20->__r_.__value_.__l.__data_) == 11823;
LABEL_40:
  if (!v21) {
    goto LABEL_49;
  }
LABEL_44:
  int v22 = __str.__r_.__value_.__s.__size_;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    int v22 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v35, &__str, 0LL, v22 - 2, (std::allocator<char> *)v38);
  __str = v35;
LABEL_49:
  *((void *)this + 1) = 0xAAAAAAAAAAAAAAAALL;
  pid_t v23 = (void *)((char *)this + 8);
  *((void *)this + 2) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)this = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = CFBundleCopyResourcesDirectoryURL(a2[3]);
  Security::cfStringRelease(this, v24);
  unint64_t v25 = *((unsigned __int8 *)this + 23);
  if ((v25 & 0x80u) == 0LL) {
    uint64_t v26 = *((unsigned __int8 *)this + 23);
  }
  else {
    uint64_t v26 = *((void *)this + 1);
  }
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v27 = __str.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v27 = __str.__r_.__value_.__l.__size_;
  }
  if (v26 == v27)
  {
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v28 = &__str;
    }
    else {
      uint64_t v28 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if ((v25 & 0x80) == 0)
    {
      if (*((_BYTE *)this + 23))
      {
        uint64_t v29 = this;
        while (*(unsigned __int8 *)v29 == v28->__r_.__value_.__s.__data_[0])
        {
          uint64_t v29 = (Security::CodeSigning::BundleDiskRep *)((char *)v29 + 1);
          uint64_t v28 = (std::string *)((char *)v28 + 1);
          if (!--v25) {
            goto LABEL_64;
          }
        }

        goto LABEL_66;
      }

      __cxa_end_catch();
      JUMPOUT(0x180621B30LL);
    case 5:
      __int128 v21 = __cxa_begin_catch(a1);
      int v22 = (*(uint64_t (**)(void *))(*(void *)v21 + 24LL))(v21);
      if (!v15) {
        goto LABEL_34;
      }
      pid_t v23 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v22, 0LL);
LABEL_33:
      *CFDataRef v15 = v23;
      goto LABEL_34;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v27 = __cxa_begin_catch(a1);
      uint64_t v28 = (*(uint64_t (**)(void *))(*(void *)v27 + 24LL))(v27);
      if (v15) {
        *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v28, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15) {
          *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15) {
          *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_34;
  }

  uint64_t v24 = __cxa_begin_catch(a1);
  unint64_t v25 = v24[36];
  if (v25 > 0x1A) {
    goto LABEL_30;
  }
  uint64_t v20 = -67033;
  uint64_t v26 = 1 << v25;
  if ((v26 & 0x800108) != 0) {
    goto LABEL_31;
  }
  if ((v26 & 0x4014000) != 0) {
    uint64_t v20 = -67032;
  }
  else {
LABEL_30:
  }
    uint64_t v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v24 + 24LL))(v24);
LABEL_31:
  if (!v15) {
    goto LABEL_34;
  }
  goto LABEL_32;
}

      __cxa_end_catch();
      JUMPOUT(0x180621F0CLL);
    case 5:
      __int128 v21 = __cxa_begin_catch(a1);
      int v22 = (*(uint64_t (**)(void *))(*(void *)v21 + 24LL))(v21);
      if (!v15) {
        goto LABEL_34;
      }
      pid_t v23 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v22, 0LL);
LABEL_33:
      *CFDataRef v15 = v23;
      goto LABEL_34;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v27 = __cxa_begin_catch(a1);
      uint64_t v28 = (*(uint64_t (**)(void *))(*(void *)v27 + 24LL))(v27);
      if (v15) {
        *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v28, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15) {
          *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15) {
          *CFDataRef v15 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_34;
  }

  uint64_t v24 = __cxa_begin_catch(a1);
  unint64_t v25 = v24[36];
  if (v25 > 0x1A) {
    goto LABEL_30;
  }
  uint64_t v20 = -67033;
  uint64_t v26 = 1 << v25;
  if ((v26 & 0x800108) != 0) {
    goto LABEL_31;
  }
  if ((v26 & 0x4014000) != 0) {
    uint64_t v20 = -67032;
  }
  else {
LABEL_30:
  }
    uint64_t v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v24 + 24LL))(v24);
LABEL_31:
  if (!v15) {
    goto LABEL_34;
  }
  goto LABEL_32;
}

  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v27);
  return v14;
}

uint64_t csops_task(uint64_t a1)
{
  pid_t pidp = -1431655766;
  __int128 v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&atoken.val[4] = v2;
  audit_token_to_au32(&atoken, 0LL, 0LL, 0LL, 0LL, 0LL, &pidp, 0LL, 0LL);
  uint64_t v3 = csops_audittoken();
  if ((_DWORD)v3 == -1) {
    int v4 = *__error();
  }
  else {
    int v4 = 0;
  }
  *(_DWORD *)(a1 + 64) = v4;
  return v3;
}

void SecTaskFinalize(uint64_t a1)
{
  __int128 v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 56) = 0LL;
    CFRelease(v2);
  }

void sec_protocol_options_set_verify_block( sec_protocol_options_t options, sec_protocol_verify_t verify_block, dispatch_queue_t verify_block_queue)
{
  if (options)
  {
    if (verify_block_queue)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_verify_block_block_invoke;
      v3[3] = &unk_189665F28;
      v3[4] = verify_block;
      v3[5] = verify_block_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }

uint64_t sec_protocol_options_access_handle(uint64_t a1, uint64_t a2)
{
  if (sec_protocol_options_access_handle_onceToken != -1) {
    dispatch_once(&sec_protocol_options_access_handle_onceToken, &__block_literal_global_3182);
  }
  if (sec_protocol_options_access_handle__nw_protocol_options_access_handle) {
    return sec_protocol_options_access_handle__nw_protocol_options_access_handle(a1, a2);
  }
  else {
    return 0LL;
  }
}

BOOL __sec_protocol_options_set_verify_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = *(const void **)(a2 + 120);
    if (v4) {
      _Block_release(v4);
    }
    int v5 = *(dispatch_object_s **)(a2 + 128);
    if (v5) {
      dispatch_release(v5);
    }
    int v6 = _Block_copy(*(const void **)(a1 + 32));
    CFTypeRef v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 120) = v6;
    *(void *)(a2 + 128) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

void sec_protocol_options_set_challenge_block( sec_protocol_options_t options, sec_protocol_challenge_t challenge_block, dispatch_queue_t challenge_queue)
{
  if (options)
  {
    if (challenge_queue)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_challenge_block_block_invoke;
      v3[3] = &unk_189665F00;
      v3[4] = challenge_block;
      v3[5] = challenge_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }

BOOL __sec_protocol_options_set_challenge_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = *(const void **)(a2 + 104);
    if (v4) {
      _Block_release(v4);
    }
    int v5 = *(dispatch_object_s **)(a2 + 112);
    if (v5) {
      dispatch_release(v5);
    }
    int v6 = _Block_copy(*(const void **)(a1 + 32));
    CFTypeRef v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 104) = v6;
    *(void *)(a2 + 112) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

void sec_protocol_options_add_tls_ciphersuite_group(sec_protocol_options_t options, SSLCiphersuiteGroup group)
{
  uint64_t v10 = v2;
  uint64_t v11 = v3;
  switch(group)
  {
    case kSSLCiphersuiteGroupDefault:
      if (options)
      {
        uint64_t v5 = MEMORY[0x1895F87A8];
        uint64_t v6 = 0x40000000LL;
        CFTypeRef v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        unint64_t v8 = &__block_descriptor_tmp_11;
        __int16 v9 = 0;
        goto LABEL_13;
      }

      break;
    case kSSLCiphersuiteGroupCompatibility:
      if (options)
      {
        uint64_t v5 = MEMORY[0x1895F87A8];
        uint64_t v6 = 0x40000000LL;
        CFTypeRef v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        unint64_t v8 = &__block_descriptor_tmp_11;
        __int16 v4 = 1;
        goto LABEL_12;
      }

      break;
    case kSSLCiphersuiteGroupLegacy:
      if (options)
      {
        uint64_t v5 = MEMORY[0x1895F87A8];
        uint64_t v6 = 0x40000000LL;
        CFTypeRef v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        unint64_t v8 = &__block_descriptor_tmp_11;
        __int16 v4 = 2;
        goto LABEL_12;
      }

      break;
    case kSSLCiphersuiteGroupATS:
      if (options)
      {
        uint64_t v5 = MEMORY[0x1895F87A8];
        uint64_t v6 = 0x40000000LL;
        CFTypeRef v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        unint64_t v8 = &__block_descriptor_tmp_11;
        __int16 v4 = 3;
        goto LABEL_12;
      }

      break;
    case kSSLCiphersuiteGroupATSCompatibility:
      if (options)
      {
        uint64_t v5 = MEMORY[0x1895F87A8];
        uint64_t v6 = 0x40000000LL;
        CFTypeRef v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        unint64_t v8 = &__block_descriptor_tmp_11;
        __int16 v4 = 4;
LABEL_12:
        __int16 v9 = v4;
LABEL_13:
        sec_protocol_options_access_handle((uint64_t)options, (uint64_t)&v5);
      }

      break;
    default:
      return;
  }

void sec_protocol_options_append_tls_ciphersuite_group( sec_protocol_options_t options, tls_ciphersuite_group_t group)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_11;
    tls_ciphersuite_group_t v3 = group;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_append_tls_ciphersuite_group_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = *(unsigned __int16 *)(a1 + 32);
    if (v3 <= 4)
    {
      uint64_t v4 = qword_180652E88[v3];
      uint64_t v5 = (unsigned __int16 *)*(&off_189667138 + v3);
      if (!*(void *)(a2 + 40)) {
        *(void *)(a2 + 40) = xpc_array_create(0LL, 0LL);
      }
      do
      {
        unsigned int v6 = *v5++;
        xpc_array_set_uint64(*(xpc_object_t *)(a2 + 40), 0xFFFFFFFFFFFFFFFFLL, v6);
        --v4;
      }

      while (v4);
    }
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_is_fallback_attempt(sec_protocol_options_t options, BOOL is_fallback_attempt)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_is_fallback_attempt_block_invoke;
    v2[3] = &__block_descriptor_tmp_28;
    BOOL v3 = is_fallback_attempt;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_is_fallback_attempt_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFFFFE7F | ((*(_BYTE *)(a1 + 32) & 1) << 7) | 0x100;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFFE7FLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_false_start_enabled(sec_protocol_options_t options, BOOL false_start_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_false_start_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_31;
    BOOL v3 = false_start_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_false_start_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFFFF9FF | (*(unsigned __int8 *)(a1 + 32) << 9) | 0x400;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFF9FFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_server_name(sec_protocol_options_t options, const char *server_name)
{
  if (options)
  {
    if (server_name)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_tls_server_name_block_invoke;
      v2[3] = &__block_descriptor_tmp_23;
      void v2[4] = server_name;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }

BOOL __sec_protocol_options_set_tls_server_name_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    free(*(void **)(a2 + 8));
    *(void *)(a2 + 8) = strdup(*(const char **)(a1 + 32));
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_resumption_enabled(sec_protocol_options_t options, BOOL resumption_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_resumption_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_30;
    BOOL v3 = resumption_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_resumption_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFE7FFFF | (*(unsigned __int8 *)(a1 + 32) << 19) | 0x100000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFE7FFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_add_transport_specific_application_protocol(uint64_t result, uint64_t a2, int a3)
{
  if (result)
  {
    if (a2)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_add_transport_specific_application_protocol_block_invoke;
      v3[3] = &__block_descriptor_tmp_21;
      v3[4] = a2;
      int v4 = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }

  return result;
}

BOOL __sec_protocol_options_add_transport_specific_application_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!*(void *)(a2 + 48)) {
      *(void *)(a2 + 48) = xpc_array_create(0LL, 0LL);
    }
    xpc_object_t v4 = xpc_array_create(0LL, 0LL);
    if (v4)
    {
      uint64_t v5 = v4;
      xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 32));
      xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, *(unsigned int *)(a1 + 40));
      xpc_array_append_value(*(xpc_object_t *)(a2 + 48), v5);
      xpc_release(v5);
    }
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_min_version(sec_protocol_options_t options, SSLProtocol version)
{
  uint64_t v2 = 0LL;
  int v3 = ssl_protocol_version_map;
  while (1)
  {
    int v4 = *v3;
    v3 += 2;
    if (v4 == version) {
      break;
    }
    if (++v2 == 8) {
      return;
    }
  }

  if (v2 != 7)
  {
    if (options)
    {
      __int16 v5 = ssl_protocol_version_map[2 * v2 + 1];
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 0x40000000LL;
      _DWORD v6[2] = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
      v6[3] = &__block_descriptor_tmp_14;
      __int16 v7 = v5;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v6);
    }
  }

void sec_protocol_options_set_min_tls_protocol_version( sec_protocol_options_t options, tls_protocol_version_t version)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
    v2[3] = &__block_descriptor_tmp_14;
    tls_protocol_version_t v3 = version;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_min_tls_protocol_version_block_invoke(uint64_t a1, _WORD *a2)
{
  if (a2) {
    *a2 = *(_WORD *)(a1 + 32);
  }
  return a2 != 0LL;
}

uint64_t sec_protocol_helper_ciphersuite_group_to_ciphersuite_list(unsigned int a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a1 > 4)
  {
    uint64_t v2 = 0LL;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v2 = qword_180652E88[a1];
    uint64_t result = (uint64_t)*(&off_189667138 + a1);
  }

  *a2 = v2;
  return result;
}

BOOL SecFrameworkIsDNSName(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length > 255) {
    return 0LL;
  }
  uint64_t v3 = Length;
  CFStringRef theString = a1;
  uint64_t v26 = 0LL;
  CFIndex v27 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  uint64_t v24 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  int64_t v28 = 0LL;
  int64_t v29 = 0LL;
  unint64_t v25 = CStringPtr;
  if (v3 < 1) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  int64_t v7 = 0LL;
  int v8 = 0;
  int v9 = 0;
  int64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 64LL;
  do
  {
    else {
      uint64_t v13 = v10;
    }
    CFIndex v14 = v27;
    if (v27 <= v10)
    {
      UniChar v15 = 0;
      ++v11;
    }

    else
    {
      if (v24)
      {
        UniChar v15 = v24[v10 + v26];
      }

      else if (v25)
      {
        UniChar v15 = v25[v26 + v10];
      }

      else
      {
        if (v29 <= v10 || v7 > v10)
        {
          uint64_t v17 = v13 + v6;
          uint64_t v18 = v12 - v13;
          int64_t v19 = v10 - v13;
          CFIndex v20 = v19 + 64;
          if (v19 + 64 >= v27) {
            CFIndex v20 = v27;
          }
          int64_t v28 = v19;
          int64_t v29 = v20;
          if (v27 >= v18) {
            CFIndex v14 = v18;
          }
          v30.size_t length = v14 + v17;
          v30.location = v19 + v26;
          CFStringGetCharacters(theString, v30, (UniChar *)v22);
          int64_t v7 = v28;
        }

        UniChar v15 = *((_WORD *)v22 + v10 - v7);
      }

      if (v15 == 46)
      {
        if (v11 > 63 || (v9 & 0xFFFFFFFE) != 2) {
          return 0LL;
        }
        uint64_t v11 = 0LL;
        int v8 = 0;
        int v9 = 1;
        goto LABEL_41;
      }

      ++v11;
      if ((unsigned __int16)(v15 - 65) < 0x1Au)
      {
        int v8 = 1;
LABEL_40:
        int v9 = 2;
        goto LABEL_41;
      }
    }

    if (v15 == 42 || (unsigned __int16)(v15 - 97) < 0x1Au)
    {
      int v9 = 2;
      int v8 = 1;
      goto LABEL_41;
    }

    if ((unsigned __int16)(v15 - 48) < 0xAu)
    {
      int v9 = 3;
      goto LABEL_41;
    }

    if (v15 == 95) {
      goto LABEL_40;
    }
    int v9 = 4;
LABEL_41:
    ++v10;
    --v6;
    ++v12;
  }

  while (v3 != v10);
  return v11 <= 63 && (v9 & 6) == 2 && v8 == 1;
}

BOOL sec_protocol_options_get_enable_encrypted_client_hello(sec_protocol_options_t options)
{
  if (!options) {
    return 0;
  }
  uint64_t v4 = 0LL;
  __int16 v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_options_get_enable_encrypted_client_hello_block_invoke;
  v3[3] = &unk_189665B40;
  v3[4] = &v4;
  sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
  BOOL v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_options_get_enable_encrypted_client_hello_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_DWORD *)(a2 + 361) & 0x2000000) != 0;
  }
  return a2 != 0;
}

SecConcrete_sec_array *sec_array_create()
{
  return objc_alloc_init(&OBJC_CLASS___SecConcrete_sec_array);
}

BOOL sec_array_apply(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3 && v3[1] && MEMORY[0x186E0087C]() == MEMORY[0x1895F9220])
  {
    char v7 = (void *)v3[1];
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    v8[2] = __sec_array_apply_block_invoke;
    v8[3] = &unk_189667570;
    int v9 = v3;
    id v10 = v4;
    BOOL v5 = xpc_array_apply(v7, v8);
  }

  else
  {
    BOOL v5 = 0LL;
  }

  return v5;
}

uint64_t __sec_array_apply_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void *SecCertificateCreateWithBytes(uint64_t a1, const void *a2, int64_t a3)
{
  uint64_t v3 = 0LL;
  if (a2)
  {
    if (a3 >= 1)
    {
      SecCertificateGetTypeID();
      uint64_t Instance = _CFRuntimeCreateInstance();
      uint64_t v3 = (void *)Instance;
      if (Instance)
      {
        bzero((void *)(Instance + 32), 0x258uLL);
        _DWORD v3[2] = v3 + 79;
        v3[3] = a3;
        memcpy(v3 + 79, a2, a3);
        if ((SecCertificateParse((uint64_t)v3) & 1) == 0)
        {
          CFRelease(v3);
          return 0LL;
        }
      }
    }
  }

  return v3;
}

CFTypeID SecCertificateGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecCertificateGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_37_8076;
  block[4] = &SecCertificateGetTypeID_sSecCertificateGetTypeIDSingleton;
  if (SecCertificateGetTypeID_sSecCertificateGetTypeIDOnce != -1) {
    dispatch_once(&SecCertificateGetTypeID_sSecCertificateGetTypeIDOnce, block);
  }
  return SecCertificateGetTypeID_sSecCertificateGetTypeIDSingleton;
}

uint64_t SecCertificateParse(uint64_t a1)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFSetCreateMutable(0LL, 0LL, MEMORY[0x189605258]);
  uint64_t v3 = CFGetAllocator((CFTypeRef)a1);
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v46 = v4;
  __int128 v47 = v4;
  __int128 v48 = v4;
  if (DERParseSequence( a1 + 16,  (unsigned __int16)DERNumSignedCertCrlItemSpecs,  (uint64_t)&DERSignedCertCrlItemSpecs,  (unint64_t)&v46,  0x30uLL)) {
    goto LABEL_85;
  }
  *(_OWORD *)(a1 + 32) = v46;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v36 = v5;
  *(_OWORD *)bytes = v5;
  __int128 v38 = v5;
  __int128 v39 = v5;
  __int128 v40 = v5;
  __int128 v41 = v5;
  __int128 v42 = v5;
  __int128 v43 = v5;
  __int128 v44 = v5;
  __int128 v45 = v5;
  if (DERParseSequence( (uint64_t)&v46,  (unsigned __int16)DERNumTBSCertItemSpecs,  (uint64_t)&DERTBSCertItemSpecs,  (unint64_t)&v36,  0xA0uLL)) {
    goto LABEL_85;
  }
  if (DERParseSequenceContent( (unint64_t *)&v47,  (unsigned __int16)DERNumAlgorithmIdItemSpecs,  (uint64_t)&DERAlgorithmIdItemSpecs,  a1 + 48,  0x20uLL)) {
    goto LABEL_85;
  }
  char v35 = -86;
  if (*((void *)&v36 + 1))
  {
    memset(v49, 170, 24);
    if (DERDecodeItem((uint64_t)&v36, (unint64_t *)v49)
      || *(void *)v49 != 2LL
      || *(void *)&v49[16] != 1LL)
    {
      goto LABEL_85;
    }

    unsigned int v6 = **(_BYTE **)&v49[8];
    *(_BYTE *)(a1 + 96) = v6;
    if (v6 >= 3)
    {
      char v7 = (os_log_s *)secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *(unsigned __int8 *)(a1 + 96);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v8;
        _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "Invalid certificate version (%d), must be 0..2",  buf,  8u);
      }

      unsigned int v6 = *(unsigned __int8 *)(a1 + 96);
    }

    if (v6 - 3 <= 0xFFFFFFFD) {
      goto LABEL_85;
    }
  }

  else
  {
    *(_BYTE *)(a1 + 96) = 0;
  }

  *(_OWORD *)(a1 + 104) = *(_OWORD *)bytes;
  unint64_t v9 = (unint64_t)bytes[1];
  if (bytes[1] == (UInt8 *)21)
  {
    if (*bytes[0])
    {
LABEL_19:
      id v10 = (os_log_s *)secLogObjForScope("SecWarning");
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      unint64_t v9 = (unint64_t)bytes[1];
      if (v11)
      {
        *(_DWORD *)v49 = 134217984;
        *(UInt8 **)&v49[4] = bytes[1];
        _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "Invalid serial number length (%ld), must be 1..20",  v49,  0xCu);
        unint64_t v9 = (unint64_t)bytes[1];
      }

      goto LABEL_22;
    }

    unint64_t v9 = 21LL;
  }

LABEL_22:
  if (bytes[0])
  {
    if (v9)
    {
      if (v9 <= 0x25)
      {
        *(void *)(a1 + 568) = CFDataCreate(v3, bytes[0], v9);
        if (!DERParseSequenceContent( (unint64_t *)&v38,  (unsigned __int16)DERNumAlgorithmIdItemSpecs,  (uint64_t)&DERAlgorithmIdItemSpecs,  a1 + 120,  0x20uLL))
        {
          *(_OWORD *)(a1 + 152) = v39;
          *(void *)(a1 + 576) = createNormalizedX501Name(v3, (uint64_t)&v39);
          *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __int128 v33 = v12;
          __int128 v34 = v12;
          if (!DERParseSequenceContent( (unint64_t *)&v40,  (unsigned __int16)DERNumValidityItemSpecs,  (uint64_t)&DERValidityItemSpecs,  (unint64_t)&v33,  0x20uLL)
            && derDateGetAbsoluteTime((uint64_t)&v33, (double *)(a1 + 168))
            && derDateGetAbsoluteTime((uint64_t)&v34, (double *)(a1 + 176)))
          {
            *(_OWORD *)(a1 + 184) = v41;
            *(void *)(a1 + 584) = createNormalizedX501Name(v3, (uint64_t)&v41);
            *(_OWORD *)(a1 + 200) = v42;
            *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v31 = v13;
            __int128 v32 = v13;
            if (!DERParseSequenceContent( (unint64_t *)&v42,  (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs,  (uint64_t)&DERSubjPubKeyInfoItemSpecs,  (unint64_t)&v31,  0x20uLL)
              && !DERParseSequenceContent( (unint64_t *)&v31,  (unsigned __int16)DERNumAlgorithmIdItemSpecs,  (uint64_t)&DERAlgorithmIdItemSpecs,  a1 + 216,  0x20uLL)
              && !DERParseBitString((uint64_t)&v32, (unint64_t *)(a1 + 248), &v35))
            {
              __int128 v14 = v44;
              *(_OWORD *)(a1 + 264) = v43;
              *(_OWORD *)(a1 + 280) = v14;
              *(void *)(a1 + 528) = -1LL;
              *(void *)(a1 + 536) = -1LL;
              if (!*((void *)&v45 + 1))
              {
LABEL_82:
                uint64_t v28 = 1LL;
                uint64_t result = 1LL;
                if (!Mutable) {
                  return result;
                }
                goto LABEL_83;
              }

              memset(v30, 170, sizeof(v30));
              if (!DERDecodeSeqInit((uint64_t)&v45, v30, &v30[1]) && v30[0] == 0x2000000000000010LL)
              {
                uint64_t v15 = 0LL;
                memset(buf, 170, sizeof(buf));
                while (1)
                {
                  int v16 = DERDecodeSeqNext(&v30[1], (unint64_t *)buf);
                  if (v16) {
                    break;
                  }
                  ++v15;
                }

                if (v16 == 1 && (unint64_t)(v15 - 10000) >= 0xFFFFFFFFFFFFD8F1LL)
                {
                  *(void *)(a1 + 512) = v15;
                  uint64_t v17 = malloc(40 * v15);
                  *(void *)(a1 + 520) = v17;
                  if (v17)
                  {
                    if (!DERDecodeSeqInit((uint64_t)&v45, v30, &v30[1]))
                    {
                      uint64_t v18 = 0LL;
                      while (1)
                      {
                        int v19 = DERDecodeSeqNext(&v30[1], (unint64_t *)buf);
                        if (v19 && (v18 != v15 - 1 || v19 != 1)) {
                          break;
                        }
                        if (*(void *)buf != 0x2000000000000010LL) {
                          break;
                        }
                        *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
                        *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
                        *(_OWORD *)&v49[16] = v20;
                        __int128 v50 = v20;
                        *(_OWORD *)v49 = v20;
                        if (DERParseSequenceContent( (unint64_t *)&buf[8],  (unsigned __int16)DERNumExtensionItemSpecs,  (uint64_t)&DERExtensionItemSpecs,  (unint64_t)v49,  0x30uLL)) {
                          break;
                        }
                        *(_OWORD *)(*(void *)(a1 + 520) + 40 * v18) = *(_OWORD *)v49;
                        if ((*(void *)&v49[8] & 0x8000000000000000LL) == 0)
                        {
                          CFDataRef v21 = CFDataCreate(0LL, *(const UInt8 **)v49, *(CFIndex *)&v49[8]);
                          if (CFSetContainsValue(Mutable, v21))
                          {
                            if (v21) {
                              CFRelease(v21);
                            }
                            *(void *)(a1 + 536) = v18;
                          }

                          else
                          {
                            CFSetAddValue(Mutable, v21);
                            if (v21) {
                              CFRelease(v21);
                            }
                          }
                        }

                        if (DERParseBooleanWithDefault( (unsigned __int8 **)&v49[16],  0,  (BOOL *)(*(void *)(a1 + 520) + 40 * v18 + 16))) {
                          break;
                        }
                        *(_OWORD *)(*(void *)(a1 + 520) + 40 * v18 + 24) = v50;
                        Value = (uint64_t (*)(uint64_t, uint64_t))CFDictionaryGetValue( (CFDictionaryRef)sExtensionParsers,  (const void *)(*(void *)(a1 + 520)
                                                                                         + 40 * v18));
                        uint64_t v23 = *(void *)(a1 + 520);
                        if (Value)
                        {
                          if ((Value(a1, v23 + 40 * v18) & 1) == 0)
                          {
                            *(void *)(a1 + 528) = v18;
                            if (*(_BYTE *)(*(void *)(a1 + 520) + 40 * v18 + 16)) {
                              break;
                            }
                          }
                        }

                        else if (*(_BYTE *)(v23 + 40 * v18 + 16))
                        {
                          uint64_t v24 = *(_BYTE **)v49;
                          if (!*(void *)v49) {
                            goto LABEL_73;
                          }
                          unint64_t v25 = *(void **)&v49[8];
                          if (*(void *)&v49[8] < 9uLL)
                          {
                            if (*(void *)&v49[8]) {
                              goto LABEL_64;
                            }
LABEL_73:
                            *(_BYTE *)(a1 + 296) = 1;
                            goto LABEL_74;
                          }

                          if (**(void **)v49 != 0x66463F78648862ALL
                            && **(void **)v49 != 0xB6463F78648862ALL
                            && **(void **)v49 != 0xC6463F78648862ALL
                            && **(void **)v49 != 0xD6463F78648862ALL
                            && **(void **)v49 != 0xF6463F78648862ALL)
                          {
LABEL_64:
                            uint64_t v26 = 0LL;
                            while (v25 != *(_UNKNOWN **)((char *)&unparsed_known_extensions + v26 + 8)
                                 || memcmp(v24, *(_UNKNOWN **)((char *)&unparsed_known_extensions + v26), (size_t)v25))
                            {
                              v26 += 16LL;
                              if (v26 == 48)
                              {
                                if ((unint64_t)v25 >= 0xA
                                  && *(void *)v24 == 0x69C482010401062BLL
                                  && v24[8] == 5)
                                {
                                  break;
                                }

                                goto LABEL_73;
                              }
                            }
                          }
                        }

    __break(0x5513u);
    goto LABEL_23;
  }

      [v16 addObject:@"keyData"];
      goto LABEL_14;
    }

    [v21 addObject:@"wrapppedTLK"];
    if (v18)
    {
LABEL_14:
      if (!a4)
      {
LABEL_16:

        int v19 = 0LL;
        goto LABEL_17;
      }

  return v5;
}

  if (v17) {
    goto LABEL_23;
  }
  return updated;
}

        appendError(v1, @"Hostname mismatch.");
        unint64_t v9 = context;
        if ((context & 0x20) == 0)
        {
LABEL_12:
          if ((v9 & 0x40) == 0) {
            goto LABEL_13;
          }
          goto LABEL_24;
        }

  __int128 v5 = (uint64_t *)*v12;
  char v7 = (uint64_t **)v12;
  if (!*v12) {
    goto LABEL_44;
  }
  return v5;
}

    (*(void (**)(Security::MachOBase *))(*(void *)v4 + 8LL))(v4);
    return *((void *)this + 8);
  }

  return result;
}

LABEL_74:
                        if (++v18 == v15) {
                          goto LABEL_82;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

        __break(0x5519u);
      }

      goto LABEL_73;
    }

    ValueOfKofN = 0LL;
    goto LABEL_75;
  }

  if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"dacl",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)) {
    goto LABEL_14;
  }
  return v9;
}

LABEL_85:
  uint64_t v28 = 0LL;
  uint64_t result = 0LL;
  if (!Mutable) {
    return result;
  }
LABEL_83:
  CFRelease(Mutable);
  return v28;
}

  *(_DWORD *)(*(void *)(v1[4] + 8LL) + 24LL) = v4;
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t DERParseSequenceToObject( uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  v12[3] = *MEMORY[0x1895F89C0];
  memset(v12, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0LL);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010LL) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3LL;
  }
  __int128 v4 = *(_BYTE **)result;
  if (*(void *)result == -1LL) {
    goto LABEL_68;
  }
  __int128 v5 = &v4[v3];
  unsigned int v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    __int128 v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1LL)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      __int128 v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0LL;
            }
LABEL_34:
            uint64_t result = 0LL;
            *a3 = v15;
            return result;
          }

LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }

        return 3LL;
      }

      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3LL;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3LL;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3LL;
      }
      unint64_t v15 = 0LL;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1LL)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3LL;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          uint64_t v28 = &v5[-v23];
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0LL;
        }
      }
    }

            if (*(_BYTE *)(v34 + 139))
            {
              while (1)
              {
                __int128 v34 = *(void *)(v34 + 32);
                if (!v34) {
                  break;
                }
                __int128 v46 = *(_DWORD *)(v34 + 48);
              }
            }

            else
            {
              v199 = *(void *)(v34 + 96);
              v49 = v9;
LABEL_71:
              if (!sec_asn1d_check_and_subtract_length(&v199, v49[13], *v9)
                || !sec_asn1d_check_and_subtract_length(&v199, v49[11], *v9)
                || *((_BYTE *)v49 + 139) && !sec_asn1d_check_and_subtract_length(&v199, 2uLL, *v9))
              {
                goto LABEL_337;
              }

              while (1)
              {
                v49 = (void *)v49[4];
                if (!v49) {
                  break;
                }
                __int128 v50 = *((_DWORD *)v49 + 12);
                if ((v50 - 16) >= 4 && v50 != 24 && v50 != 11)
                {
                  if (*((_BYTE *)v49 + 139)) {
                    goto LABEL_71;
                  }
                  break;
                }
              }
            }

LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }

  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3LL;
  }
  unint64_t v8 = 0LL;
  uint64_t result = 3LL;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    __int128 v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3LL;
      }
      goto LABEL_20;
    }
  }

  return result;
}

    log_error(a5, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0LL;
  }

  uint64_t v28 = *((_DWORD *)v19 + 8);
  int64_t v29 = *((_DWORD *)v19 + 9);
  CFRange v30 = bswap32(v28);
  if (v7) {
    uint64_t v28 = v30;
  }
  __int128 v31 = bswap32(v29);
  if (v7) {
    int64_t v29 = v31;
  }
  __int128 v32 = __CFADD__(v28, v29);
  __int128 v33 = v28 + v29;
  __int128 v34 = a4;
  a5 = v84;
  char v35 = a2;
  __int128 v36 = a1;
  CFTypeRef v37 = a3;
  __int128 v38 = v79;
  if (v32 || v33 > a3) {
    goto LABEL_69;
  }
LABEL_60:
  if (v20)
  {
    __int128 v44 = *((_DWORD *)v20 + 2);
    __int128 v45 = *((_DWORD *)v20 + 3);
    __int128 v46 = bswap32(v44);
    if (v7) {
      __int128 v44 = v46;
    }
    __int128 v47 = bswap32(v45);
    if (v7) {
      __int128 v45 = v47;
    }
    __int128 v32 = __CFADD__(v44, v45);
    __int128 v48 = v44 + v45;
    if (v32)
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE offset + size overflows\n");
    }

    else if (v48 >= v37 - 7)
    {
      v64 = bswap32(v35);
      if (!v7) {
        v64 = v35;
      }
      *((_DWORD *)v20 + 3) = v64;
      v65 = *v34;
      __int128 v32 = __CFADD__(v44, v35);
      uint64_t v63 = v44 + v35;
      *__int128 v34 = v63;
      if (!v32)
      {
        if (v65 > v63)
        {
          bzero((char *)v36 + v63, v65 - v63);
          uint64_t v63 = *v34;
        }

        goto LABEL_112;
      }

      log_error(a5, "mew sigSpace causes overflow\n");
    }

    else
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    }

    return 0LL;
  }

  __int128 v50 = 0;
  v51 = 1;
  uint64_t v52 = 96LL;
  while (2)
  {
    v53 = bswap32(*(_DWORD *)v21);
    if (!v7) {
      v53 = *(_DWORD *)v21;
    }
    BOOL v54 = bswap32(*((_DWORD *)v21 + 1));
    if (!v7) {
      BOOL v54 = *((_DWORD *)v21 + 1);
    }
    if (v53 != 25)
    {
      if (v53 == 1 && !*((_DWORD *)v21 + 8) && *((_DWORD *)v21 + 9) && *((_DWORD *)v21 + 12)) {
        goto LABEL_129;
      }
      goto LABEL_85;
    }

    if (*((void *)v21 + 5) || !*((void *)v21 + 6) || !*((_DWORD *)v21 + 16))
    {
LABEL_85:
      v21 += v54;
      v51 = ++v50 < v15;
      if (v15 == v50) {
        goto LABEL_86;
      }
      continue;
    }

    break;
  }

  uint64_t v52 = 120LL;
LABEL_129:
  LODWORD(v52) = *(_DWORD *)&v21[v52];
  v78 = bswap32(v52);
  if (v7) {
    uint64_t v52 = v78;
  }
  else {
    uint64_t v52 = v52;
  }
  if (v51 && v38 + 16 > v52)
  {
    log_error(a5, "not enough room in load commands to add LC_CODE_SIGNATURE\n");
    return 0LL;
  }

uint64_t DERParseSequenceContentToObject( unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  unint64_t v32 = 0LL;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }

  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    int64_t v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result) {
        break;
      }
      if (a2 <= v13) {
        return 2LL;
      }
      while (1)
      {
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24LL * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24LL * v13 + 8)) {
          break;
        }
        uint64_t result = 2LL;
        if ((v18 & 1) != 0)
        {
          ++v13;
        }

        return result;
      }

      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24LL * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7LL;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3LL;
            }

            goto LABEL_59;
          }

          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }

          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }

      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[2] = *MEMORY[0x1895F89C0];
  v10[0] = 0LL;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1LL;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0LL);
  if (!(_DWORD)result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0LL;
        *a1 = v9;
        return result;
      }

      __break(0x5519u);
    }

    __break(0x5513u);
  }

  return result;
}

unint64_t *DERParseSequenceContent( unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, _BYTE *a3)
{
  *a3 = 0;
  *a2 = 0LL;
  a2[1] = 0LL;
  if (!*(void *)(result + 8)) {
    return 3LL;
  }
  unsigned int v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      unint64_t v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }

      unint64_t v6 = *(void *)result;
      unint64_t v7 = *(void *)result + v4;
      unint64_t v8 = (unsigned __int8 *)(*(void *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }

      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1LL)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }

        unint64_t v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          uint64_t result = 0LL;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }

        goto LABEL_19;
      }
    }

    return 3LL;
  }

  if (v3) {
    return 3LL;
  }
  else {
    return 0LL;
  }
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0LL);
}

__CFData *createNormalizedX501Name(const __CFAllocator *a1, uint64_t a2)
{
  CFIndex v2 = *(void *)(a2 + 8);
  if (v2 < 0) {
    return 0LL;
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, *(void *)(a2 + 8));
  CFDataSetLength(Mutable, v2);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v62[0] = 0xAAAAAAAAAAAAAAAALL;
  v62[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v6 = 0LL;
  unint64_t v7 = &v61[1];
  memset(v61, 170, sizeof(v61));
  for (unsigned int i = (const void *)v62[0]; ; unsigned int i = (const void *)v62[0])
  {
    int v9 = DERDecodeSeqNext(v62, v61);
    if (v9) {
      break;
    }
    if (v61[0] != 0x2000000000000011LL) {
      goto LABEL_55;
    }
    unint64_t v10 = v61[2];
    if (!v61[2]) {
      goto LABEL_55;
    }
    unint64_t v11 = v61[1] - (void)i;
    unint64_t v12 = &MutableBytePtr[v6];
    memcpy(&MutableBytePtr[v6], i, v61[1] - (void)i);
    v60[0] = 0xAAAAAAAAAAAAAAAALL;
    v60[1] = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v50 = v11;
    unint64_t v51 = v10;
    memset(v59, 170, sizeof(v59));
    unint64_t v52 = v11 + v6;
    unint64_t v48 = (unint64_t)(v12 + 1);
    while (1)
    {
      unsigned __int16 v13 = (const void *)v60[0];
      int v14 = DERDecodeSeqNext(v60, v59);
      if (v14) {
        break;
      }
      if (v59[0] != 0x2000000000000010LL) {
        goto LABEL_55;
      }
      unint64_t v15 = v59[1] - (void)v13;
      unint64_t v16 = v59[2];
      unsigned __int16 v17 = &MutableBytePtr[v52];
      memcpy(&MutableBytePtr[v52], v13, v59[2] + v15);
      *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v57 = v18;
      __int128 v58 = v18;
      if (DERParseSequenceContent( &v59[1],  (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs,  (uint64_t)&DERAttributeTypeAndValueItemSpecs,  (unint64_t)&v57,  0x20uLL)) {
        goto LABEL_55;
      }
      if (!*((void *)&v57 + 1)) {
        goto LABEL_55;
      }
      memset(v56, 170, sizeof(v56));
      if (v56[0] == 19)
      {
        unint64_t v46 = v58 + v52 - (void)v13;
        uint64_t v19 = v56[1] - v58;
        v49 = v12;
        unint64_t v44 = v6;
        __int128 v45 = v7;
        unint64_t v20 = v56[2];
        uint64_t v43 = v56[1] - v58;
        unint64_t v21 = v19 + v46;
        if (v56[2])
        {
          __int128 v42 = Mutable;
          uint64_t v22 = 0LL;
          BOOL v23 = 0;
          unint64_t v24 = v19 + v46;
          while (1)
          {
            uint64_t v25 = *(unsigned __int8 *)(v56[1] + v22);
            int v26 = *(char *)(v56[1] + v22) < 0
            LODWORD(v27) = v26 != 0;
            if (!v26) {
              break;
            }
            if (!v23 && v24 > v21)
            {
              char v28 = 32;
LABEL_30:
              MutableBytePtr[v24++] = v28;
            }

            ++v22;
            BOOL v23 = v26 != 0;
            if (v20 == v22)
            {
              unint64_t v29 = v56[2];
              CFMutableDictionaryRef Mutable = v42;
              goto LABEL_34;
            }
          }

          else {
            char v28 = v25 - 32;
          }
          goto LABEL_30;
        }

        unint64_t v29 = 0LL;
        LODWORD(v27) = 0;
        unint64_t v24 = v21;
LABEL_34:
        unint64_t v30 = v24 - v21;
        if (v24 > v21) {
          uint64_t v27 = v27;
        }
        else {
          uint64_t v27 = 0LL;
        }
        unint64_t v31 = v30 - v27;
        unint64_t v32 = v29 - (v30 - v27);
        unint64_t v12 = v49;
        if (v29 == v30 - v27)
        {
          unint64_t v6 = v44;
          unint64_t v7 = v45;
        }

        else
        {
          unint64_t v55 = v43 - 1;
          unint64_t v33 = &MutableBytePtr[v46];
          unint64_t v34 = v55;
          unint64_t v35 = v55 + 1;
          unint64_t v55 = v35;
          if (v43 != v35)
          {
            unint64_t v47 = ~v34;
            memmove(&v33[v35], &v33[v43], v31);
            v32 += v43 + v47;
          }

          v16 -= v32;
          unint64_t v54 = v15 - 1;
          unint64_t v36 = v54;
          unint64_t v37 = v54 + 1;
          unint64_t v54 = v37;
          unint64_t v7 = v45;
          if (v15 != v37)
          {
            unint64_t v38 = ~v36;
            memmove(&v17[v37], &v17[v15], v16);
            v32 += v15 + v38;
            unint64_t v15 = v54;
          }

          size_t v39 = v51 - v32;
          unint64_t v53 = v50 - 1;
          unint64_t v40 = v53 + 1;
          unint64_t v53 = v40;
          if (v50 != v40)
          {
            memmove(&v49[v40], &v49[v50], v39);
            unint64_t v52 = v52 - v50 + v40;
            unint64_t v50 = v53;
          }

          unint64_t v6 = v44;
          unint64_t v51 = v39;
          unint64_t v12 = v49;
        }
      }

      v52 += v15 + v16;
    }

    if (v14 != 1) {
      goto LABEL_55;
    }
    v6 += v50 + v51;
  }

  if (v9 != 1 || v6 > 0x7FFFFFFFFFFFFFFELL)
  {
LABEL_55:
    CFRelease(Mutable);
    return 0LL;
  }

  CFDataSetLength(Mutable, v6);
  return Mutable;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }

  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0LL;
    }
  }

  __break(0x5519u);
  return result;
}

BOOL derDateGetAbsoluteTime(uint64_t a1, double *a2)
{
  else {
    return 0LL;
  }
}

BOOL derDateContentGetAbsoluteTime(uint64_t a1, unsigned __int8 *a2, uint64_t a3, double *a4)
{
  CFTypeRef cf = 0LL;
  double v5 = SecAbsoluteTimeFromDateContentWithError(a1, a2, a3, (CFErrorRef *)&cf);
  CFTypeRef v6 = cf;
  if (cf)
  {
    unint64_t v7 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "Invalid date specification in certificate (see RFC5280 4.1.2.5)",  v9,  2u);
    }

    CFRelease(cf);
  }

  else
  {
    *a4 = v5;
  }

  return v6 == 0LL;
}

double SecAbsoluteTimeFromDateContentWithError(uint64_t a1, unsigned __int8 *a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = 0LL;
  }
  if (a2 && a3)
  {
    int v4 = 0;
    char v5 = 0;
    int v6 = 0;
    int v7 = 0;
    switch(a3)
    {
      case 11LL:
        int v6 = 0;
        char v5 = 1;
        goto LABEL_8;
      case 13LL:
        char v5 = 0;
        int v6 = 0;
LABEL_8:
        int v7 = 1;
        goto LABEL_11;
      case 15LL:
        goto LABEL_11;
      case 17LL:
        int v4 = 1;
        goto LABEL_10;
      case 19LL:
LABEL_10:
        char v5 = 0;
        int v6 = 1;
        int v7 = v4;
LABEL_11:
        if (a1 == 24)
        {
          if ((v7 & 1) != 0) {
            goto LABEL_66;
          }
        }

        else if (a1 != 23 || (v7 & 1) == 0)
        {
          goto LABEL_66;
        }

        uint64_t v8 = 0LL;
        break;
      default:
        goto LABEL_66;
    }

    while (1)
    {
      int v9 = a2[v8];
      if ((v9 - 48) >= 0xA)
      {
        char v10 = v6 ^ 1;
        if (a3 - 5 != v8) {
          char v10 = 1;
        }
        if ((v10 & 1) != 0 || v9 != 43 && v9 != 45)
        {
          char v11 = a3 - 1 == v8 ? v6 : 1;
          if ((v11 & 1) != 0 || v9 != 90) {
            break;
          }
        }
      }

      if (a3 == ++v8)
      {
        int v12 = a2[1] + 10 * *a2 - 528;
        if (v7)
        {
          unsigned __int16 v13 = a2 + 2;
          if (v12 > 49)
          {
            double v15 = 0.0;
            int v14 = a2[1] + 10 * *a2 + 1372;
          }

          else
          {
            int v14 = a2[1] + 10 * *a2 + 1472;
          }
        }

        else
        {
          unsigned __int16 v13 = a2 + 4;
          int v14 = a2[3] + 10 * a2[2] + 100 * v12 - 528;
        }

        if ((v5 & 1) != 0)
        {
          int v16 = 0;
          unsigned __int16 v17 = v13 + 8;
        }

        else
        {
          unsigned __int16 v17 = v13 + 10;
          int v16 = v13[9] + 10 * v13[8] - 528;
        }

        double v18 = 0.0;
        if (v6)
        {
          if (*v17 == 43) {
            int v19 = 60;
          }
          else {
            int v19 = -60;
          }
          double v18 = (double)((v17[4]
                        + 10 * v17[3]
                        + 60 * (v17[2] + 10 * v17[1])
                        - 32208)
                       * v19);
        }

        unsigned int v20 = v13[1] + 10 * *v13 - 528;
        signed int v21 = v13[3] + 10 * v13[2] - 528;
        int v22 = v13[5] + 10 * v13[4] - 528;
        if ((v14 & 3) != 0)
        {
          int v23 = 0;
        }

        else
        {
          HIDWORD(v25) = -1030792151 * v14 + 85899344;
          LODWORD(v25) = HIDWORD(v25);
          unsigned int v24 = v25 >> 2;
          LODWORD(v25) = HIDWORD(v25);
          BOOL v26 = (v25 >> 4) < 0xA3D70B;
          int v23 = v24 > 0x28F5C28 || v26;
        }

        int v30 = v13[7] + 10 * v13[6] - 528;
        if (v30 > 59 || v16 > 60 || v20 == 2 && v21 > (v23 | 0x1Cu)) {
          break;
        }
        if (v20 == 2)
        {
          int v31 = 31;
        }

        else
        {
          int v31 = mdays[v20 - 1];
          if (v21 > mdays[v20] - v31) {
            break;
          }
        }

        int v33 = v14 - 2000;
        BOOL v34 = __OFSUB__(v14, 2001);
        int v35 = v14 - 2001;
        if (v35 < 0 != v34)
        {
          int v36 = -2;
        }

        else
        {
          int v33 = v35;
          int v36 = -1;
        }

        int v37 = v33 / -100;
        int v38 = v33 / 400;
        int v39 = v33 + (v33 < 0 ? 3 : 0);
        if (v20 <= 2) {
          int v40 = 0;
        }
        else {
          int v40 = v23;
        }
        return (double)v16
             + ((double)v30
              + ((double)v22 + (double)(v36 + 365 * v35 + (v39 >> 2) + v37 + v38 + v21 + v40 + v31) * 24.0) * 60.0)
             * 60.0
             - v18;
      }
    }
  }

LABEL_66:
  double v15 = 0.0;
  if (a4) {
    *a4 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -26275LL, 0LL);
  }
  return v15;
}

        return 0LL;
      case 8u:
        BOOL v34 = 0;
        int v35 = 0;
        int v36 = 0LL;
        *(_BYTE *)(a1 + 68) |= 4u;
        while (2)
        {
          int v37 = *v3;
          int v38 = *(void *)(a2 + v37);
          if (v38 == -1LL || v38 >= *(void *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }

          else
          {
            int v39 = *(_BYTE *)(*(void *)(a2 + *v7) + v38);
            *(void *)(a2 + v37) = v38 + 1;
            v36 |= (unint64_t)(v39 & 0x7F) << v34;
            if (v39 < 0)
            {
              v34 += 7;
              int v14 = v35++ >= 9;
              if (v14)
              {
                int v36 = 0LL;
                goto LABEL_63;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + *v5)) {
          int v36 = 0LL;
        }
LABEL_63:
        *(_BYTE *)(a1 + 64) = v36 != 0;
        goto LABEL_64;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_64;
    }
  }

  if (std::string::compare((const std::string *)this, 0LL, v27, &__str, 0LL, v27)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
  }
  int v31 = __str.__r_.__value_.__s.__size_;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    int v31 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string( &v35,  (const std::string *)this,  v31 + 1,  0xFFFFFFFFFFFFFFFFLL,  (std::allocator<char> *)&v37);
  unint64_t v32 = std::string::append(&v35, "/", 1uLL);
  int v33 = v32->__r_.__value_.__r.__words[0];
  *(void *)int v38 = v32->__r_.__value_.__l.__size_;
  *(void *)&v38[7] = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
  BOOL v34 = v32->__r_.__value_.__s.__size_;
  v32->__r_.__value_.__l.__size_ = 0LL;
  v32->__r_.__value_.__l.__cap_ = 0LL;
  v32->__r_.__value_.__r.__words[0] = 0LL;
  *(void *)this = v33;
  CFStringRef v23 = *(void *)v38;
  *(void *)((char *)this + 15) = *(void *)&v38[7];
  *((_BYTE *)this + 23) = v34;
LABEL_75:
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  v8[3] = *MEMORY[0x1895F89C0];
  memset(v8, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0LL);
  if (!(_DWORD)result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008LL)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }

      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0LL;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }

      __break(0x5519u);
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERParseBooleanWithDefault(unsigned __int8 **a1, BOOL a2, BOOL *a3)
{
  unint64_t v3 = a1[1];
  if (!v3) {
    goto LABEL_9;
  }
  if (v3 == (unsigned __int8 *)1)
  {
    int v4 = **a1;
    if (v4 == 255 || v4 == 0)
    {
      a2 = v4 != 0;
LABEL_9:
      uint64_t result = 0LL;
      *a3 = a2;
      return result;
    }
  }

  return 3LL;
}

unint64_t SecDERItemHash(uint64_t *a1)
{
  unint64_t result = a1[1];
  unint64_t v3 = result - 8;
  if (result < 8) {
    unint64_t v3 = 0LL;
  }
  if (v3 < result)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = 8LL;
    if (result < 8) {
      uint64_t v5 = result;
    }
    uint64_t v6 = -v5;
    uint64_t v7 = v4 + result;
    do
      unint64_t result = (result << 9) + (result >> 23) + *(unsigned __int8 *)(v7 + v6);
    while (!__CFADD__(v6++, 1LL));
  }

  return result;
}

BOOL SecDERItemEqual(uint64_t a1, uint64_t a2)
{
  return DEROidCompare(a1, a2);
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1 && a2)
  {
    size_t v4 = *(void *)(a1 + 8);
    return v4 == *(void *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }

  return result;
}

uint64_t SecCEPBasicConstraints(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v9 = v4;
  __int128 v10 = v4;
  if (!DERParseSequence( a2 + 24,  (unsigned __int16)DERNumBasicConstraintsItemSpecs,  (uint64_t)&DERBasicConstraintsItemSpecs,  (unint64_t)&v9,  0x20uLL)
    && !DERParseBooleanWithDefault((unsigned __int8 **)&v9, 0, (BOOL *)(a1 + 302)))
  {
    if (!*((void *)&v10 + 1))
    {
LABEL_6:
      uint64_t result = 1LL;
      *(_BYTE *)(a1 + 300) = 1;
      *(_BYTE *)(a1 + 301) = *(_BYTE *)(a2 + 16);
      return result;
    }

    if (!DERParseInteger((char **)&v10, (_DWORD *)(a1 + 304)))
    {
      *(_BYTE *)(a1 + 303) = 1;
      goto LABEL_6;
    }
  }

  *(_BYTE *)(a1 + 300) = 0;
  uint64_t v6 = (os_log_s *)secLogObjForScope("SecWarning");
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v7)
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Invalid BasicConstraints Extension", v8, 2u);
    return 0LL;
  }

  return result;
}

uint64_t SecCEPAuthorityKeyIdentifier(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v9 = v3;
  __int128 v10 = v3;
  __int128 v8 = v3;
  if (!DERParseSequence( a2 + 24,  (unsigned __int16)DERNumAuthorityKeyIdentifierItemSpecs,  (uint64_t)&DERAuthorityKeyIdentifierItemSpecs,  (unint64_t)&v8,  0x30uLL))
  {
    if (*((void *)&v8 + 1)) {
      *(_OWORD *)(a1 + 408) = v8;
    }
    if (!(*((void *)&v9 + 1) | *((void *)&v10 + 1))) {
      return 1LL;
    }
    if (*((void *)&v9 + 1) && *((void *)&v10 + 1))
    {
      *(_OWORD *)(a1 + 424) = v9;
      *(_OWORD *)(a1 + 440) = v10;
      return 1LL;
    }
  }

  uint64_t v5 = (os_log_s *)secLogObjForScope("SecWarning");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v6)
  {
    *(_WORD *)BOOL v7 = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Invalid AuthorityKeyIdentifier Extension", v7, 2u);
    return 0LL;
  }

  return result;
}

uint64_t SecCEPAuthorityInfoAccess(uint64_t a1, uint64_t a2)
{
  double v15 = (__CFArray **)(a1 + 480);
  __int128 v3 = (__CFArray **)(a1 + 472);
  __int128 v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  for (int i = 1023; ; --i)
  {
    uint64_t result = DERDecodeSeqNext(v20, v19);
    if ((_DWORD)result) {
      break;
    }
    if (v19[0] != 0x2000000000000010LL) {
      goto LABEL_23;
    }
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)buf = v7;
    __int128 v18 = v7;
    if (DERParseSequenceContent( &v19[1],  (unsigned __int16)DERNumAccessDescriptionItemSpecs,  (uint64_t)&DERAccessDescriptionItemSpecs,  (unint64_t)buf,  0x20uLL)
      || i == 0)
    {
      goto LABEL_23;
    }

    __int128 v9 = v3;
    if (!DEROidCompare((uint64_t)buf, (uint64_t)&oidAdOCSP))
    {
      __int128 v9 = v15;
    }

    memset(v16, 170, sizeof(v16));
    if (DERDecodeItem((uint64_t)&v18, v16)
      || v16[0] != 0x8000000000000006LL
      || v16[2] > 0x7FFFFFFFFFFFFFFELL)
    {
      goto LABEL_23;
    }

    CFURLRef v10 = CFURLCreateWithBytes(v4, (const UInt8 *)v16[1], v16[2], 0x600u, 0LL);
    if (v10)
    {
      CFURLRef v11 = v10;
      CFMutableDictionaryRef Mutable = *v9;
      if (!*v9)
      {
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v4, 0LL, MEMORY[0x189605228]);
        *__int128 v9 = Mutable;
      }

      CFArrayAppendValue(Mutable, v11);
      CFRelease(v11);
    }
  }

  if ((_DWORD)result != 1)
  {
LABEL_23:
    unsigned __int16 v13 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v14)
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "Invalid Authority Information Access extension",  buf,  2u);
      return 0LL;
    }
  }

  return result;
}

BOOL SecCEPSubjectAltName(uint64_t a1, uint64_t a2)
{
  int v4 = SecCertificateParseGeneralNames( a2 + 24,  0LL,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))verifySubjectAltGeneralName);
  if (v4)
  {
    *(void *)(a1 + 456) = 0LL;
    BOOL v6 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 v7 = 0;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Invalid SubjectAltName Extension", v7, 2u);
    }
  }

  else
  {
    *(void *)(a1 + 456) = a2;
  }

  return v4 == 0;
}

uint64_t SecCertificateParseGeneralNames( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  int v5 = DERDecodeItem(a1, v8);
  uint64_t result = 4294941021LL;
  if (!v5 && v8[0] == 0x2000000000000010LL && v8[2] != 0) {
    return parseGeneralNamesContent(&v8[1], a2, a3);
  }
  return result;
}

uint64_t parseGeneralNamesContent( unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(v10, 170, sizeof(v10));
  int v5 = 8193;
  while (1)
  {
    int v6 = DERDecodeSeqNext(v11, v10);
    if (v6) {
      break;
    }
    uint64_t result = SecCertificateParseGeneralNameContentProperty(v10[0], (uint64_t)&v10[1], a2, a3);
    if ((_DWORD)result) {
      return result;
    }
    if (!--v5)
    {
      __int128 v8 = (os_log_s *)secLogObjForScope("SecWarning");
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0LL;
      if (v9)
      {
        *(_DWORD *)buf = 67109120;
        int v13 = 0x2000;
        _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "Skipping general names after the first %d", buf, 8u);
        return 0LL;
      }

      return result;
    }
  }

  if (v6 == 1) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

uint64_t SecCertificateParseGeneralNameContentProperty( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  uint64_t result = 4294941021LL;
  switch(a1)
  {
    case 0x8000000000000001LL:
      uint64_t v8 = a3;
      uint64_t v9 = 1LL;
      goto LABEL_13;
    case 0x8000000000000002LL:
      uint64_t v8 = a3;
      uint64_t v9 = 2LL;
      goto LABEL_13;
    case 0x8000000000000003LL:
    case 0x8000000000000004LL:
    case 0x8000000000000005LL:
      return result;
    case 0x8000000000000006LL:
      uint64_t v8 = a3;
      uint64_t v9 = 6LL;
      goto LABEL_13;
    case 0x8000000000000007LL:
      uint64_t v8 = a3;
      uint64_t v9 = 7LL;
      goto LABEL_13;
    case 0x8000000000000008LL:
      uint64_t v8 = a3;
      uint64_t v9 = 8LL;
LABEL_13:
      uint64_t result = a4(v8, v9, a2);
      break;
    default:
      switch(a1)
      {
        case 0xA000000000000000LL:
          uint64_t v8 = a3;
          uint64_t v9 = 0LL;
          goto LABEL_13;
        case 0xA000000000000003LL:
          uint64_t v8 = a3;
          uint64_t v9 = 3LL;
          goto LABEL_13;
        case 0xA000000000000004LL:
          uint64_t v8 = a3;
          uint64_t v9 = 4LL;
          goto LABEL_13;
        case 0xA000000000000005LL:
          uint64_t v8 = a3;
          uint64_t v9 = 5LL;
          goto LABEL_13;
        case 0xA000000000000006LL:
          memset(v11, 170, sizeof(v11));
          else {
            uint64_t result = a4(a3, 6LL, (uint64_t)&v11[1]);
          }
          break;
        default:
          return result;
      }

      break;
  }

  return result;
}

uint64_t verifySubjectAltGeneralName()
{
  return 0LL;
}

uint64_t SecCEPCertificatePolicies(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 24;
  memset(v20, 170, sizeof(v20));
  unint64_t v5 = 0LL;
  memset(v19, 170, sizeof(v19));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v20, v19);
    if (v6) {
      break;
    }
    if (v19[0] != 0x2000000000000010LL || v5++ >= 0x1FFF) {
      goto LABEL_10;
    }
  }

  if (!v5) {
    goto LABEL_10;
  }
  if (v6 != 1) {
    goto LABEL_10;
  }
  CFURLRef v11 = malloc(32 * v5);
  if (!v11) {
    goto LABEL_10;
  }
  int v12 = v11;
  if (DERDecodeSeqInit(v4, &v20[2], v20))
  {
LABEL_22:
    free(v12);
LABEL_10:
    *(_BYTE *)(a1 + 352) = 0;
    uint64_t v8 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v9)
    {
      LOWORD(v17) = 0;
      _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "Invalid CertificatePolicies Extension",  (uint8_t *)&v17,  2u);
      return 0LL;
    }

    return result;
  }

  int v13 = v12 + 1;
  unint64_t v14 = v5;
  do
  {
    *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v17 = v15;
    __int128 v18 = v15;
    if (DERParseSequenceContent( &v19[1],  (unsigned __int16)DERNumPolicyInformationItemSpecs,  (uint64_t)&DERPolicyInformationItemSpecs,  (unint64_t)&v17,  0x20uLL)) {
      goto LABEL_22;
    }
    __int128 v16 = v18;
    *(v13 - 1) = v17;
    *int v13 = v16;
    v13 += 2;
    --v14;
  }

  while (v14);
  uint64_t result = 1LL;
  *(_BYTE *)(a1 + 352) = 1;
  *(_BYTE *)(a1 + 353) = *(_BYTE *)(a2 + 16);
  *(void *)(a1 + 360) = v5;
  *(void *)(a1 + 368) = v12;
  return result;
}

uint64_t SecCEPExtendedKeyUsage(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = 0;
  memset(v8, 170, sizeof(v8));
  while (1)
  {
    uint64_t result = DERDecodeSeqNext(&v9[1], v8);
    if ((_DWORD)result) {
      break;
    }
    if (v8[0] != 6 || v2++ >= 0x1FFF) {
      goto LABEL_14;
    }
  }

  if ((_DWORD)result != 1)
  {
LABEL_14:
    unint64_t v5 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v6)
    {
      *(_WORD *)__int128 v7 = 0;
      _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Invalidate EKU Extension", v7, 2u);
      return 0LL;
    }
  }

  return result;
}

uint64_t SecCEPCrlDistributionPoints(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = 0;
  memset(v14, 170, sizeof(v14));
  uint64_t v4 = a1 + 464;
  while (1)
  {
    uint64_t result = DERDecodeSeqNext(&v15[1], v14);
    if ((_DWORD)result) {
      break;
    }
    if (v14[0] != 0x2000000000000010LL) {
      goto LABEL_23;
    }
    *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v12 = v6;
    __int128 v13 = v6;
    *(_OWORD *)buf = v6;
    if (DERParseSequenceContent( &v14[1],  (unsigned __int16)DERNumDistributionPointItemSpecs,  (uint64_t)&DERDistributionPointItemSpecs,  (unint64_t)buf,  0x30uLL)) {
      goto LABEL_23;
    }
    uint64_t v7 = v13;
    if (*(void *)buf)
    {
      memset(v10, 170, sizeof(v10));
      if (DERDecodeItem((uint64_t)buf, v10)
        || v10[0] != 0xA000000000000001LL
        && (v10[0] != 0xA000000000000000LL
         || parseGeneralNamesContent( &v10[1],  v4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendCRLDPFromGeneralNames)))
      {
        goto LABEL_23;
      }

      uint64_t v7 = v13;
    }

    if (v7)
    {
      if (parseGeneralNamesContent( (unint64_t *)&v13,  v4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendCRLDPFromGeneralNames)
        || v3 > 0x3FE)
      {
        goto LABEL_23;
      }
    }

    else if (v3 >= 0x3FF)
    {
      goto LABEL_23;
    }

    ++v3;
  }

  if ((_DWORD)result != 1)
  {
LABEL_23:
    uint64_t v8 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v9)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "Invalid CRL Distribution Points extension", buf, 2u);
      return 0LL;
    }
  }

  return result;
}

CFURLRef appendCRLDPFromGeneralNames(__CFArray **a1, int a2, uint64_t a3)
{
  if (a2 != 6) {
    return 0LL;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0) {
    return (CFURLRef)4294941021LL;
  }
  CFURLRef result = CFURLCreateWithBytes(0LL, *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0LL);
  if (result)
  {
    unint64_t v5 = result;
    CFMutableDictionaryRef Mutable = *a1;
    if (!*a1)
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
      *a1 = Mutable;
    }

    CFArrayAppendValue(Mutable, v5);
    CFRelease(v5);
    return 0LL;
  }

  return result;
}

uint64_t SecCEPSubjectKeyIdentifier(uint64_t a1, uint64_t a2)
{
  else {
    BOOL v3 = v9[0] == 4;
  }
  uint64_t v4 = v3;
  if (v3)
  {
    *(_OWORD *)(a1 + 392) = *(_OWORD *)&v9[1];
  }

  else
  {
    __int128 v6 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Invalid SubjectKeyIdentifier Extension", v8, 2u);
    }
  }

  return v4;
}

uint64_t SecCEPKeyUsage(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 16) != 0;
  memset(v16, 170, sizeof(v16));
  if (!DERDecodeItem(a2 + 24, v16)
    && v16[0] == 3
    && v16[1] + v16[2] == *(void *)(a2 + 24) + *(void *)(a2 + 32)
    && (v16[2] & 0xFFFFFFFFFFFFFFFELL) == 2
    && (unint64_t v5 = *(unsigned __int8 *)v16[1], v5 <= 7))
  {
    int v6 = v4 << 31;
    unsigned __int16 v7 = 8 * (LOWORD(v16[2]) - 1) - v5;
    int v8 = *(unsigned __int8 *)(v16[1] + 1);
    if (v16[2] - 1 < 2)
    {
      int v9 = 128;
    }

    else
    {
      int v8 = *(unsigned __int8 *)(v16[1] + 2) | (v8 << 8);
      int v9 = 0x8000;
    }

    if (v7)
    {
      for (int i = 0; i != v7; ++i)
      {
        int v11 = 1 << i;
        if ((v8 & v9) == 0) {
          int v11 = 0;
        }
        v6 |= v11;
        int v9 = (unsigned __int16)v9 >> 1;
      }
    }

    *(_DWORD *)(a1 + 384) = v6;
    return 1LL;
  }

  else
  {
    *(_DWORD *)(a1 + 384) = 0;
    __int128 v13 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v14)
    {
      *(_WORD *)__int128 v15 = 0;
      _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEFAULT, "Invalid KeyUsage Extension", v15, 2u);
      return 0LL;
    }
  }

  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  v4[1] = *MEMORY[0x1895F89C0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7LL;
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = v4[0];
    }
  }

  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3LL;
  }
  BOOL v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3LL;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7LL;
    }
    goto LABEL_10;
  }

  if (v2 >= 2)
  {
    if (v2 > 9) {
      return 7LL;
    }
  }

LABEL_10:
  unint64_t v5 = 0LL;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }

  while (v2);
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

  int v8 = 393226LL;
  int v9 = a2[1];
  if (v9 - *a2 < v6) {
    return 393220LL;
  }
  if (!v9) {
    goto LABEL_22;
  }
  a2[1] = v9 - 1;
  *(_BYTE *)(v9 - 1) = 90;
  if (__CFADD__(result, v7)) {
    goto LABEL_22;
  }
  if (result + v7 <= result + 14 && result + v7 >= result && v5 <= 14 - v7)
  {
    goto LABEL_19;
  }

  return Mutable;
}

  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  return v5;
}

    int v4 = 0LL;
    goto LABEL_11;
  }

  int v11 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v11;
}

  *(_BYTE *)(a1 + 308) = 0;
  unsigned int v6 = (os_log_s *)secLogObjForScope("SecWarning");
  unsigned __int16 v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v7)
  {
    *(_WORD *)int v8 = 0;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Invalid PolicyConstraints Extension", v8, 2u);
    return 0LL;
  }

  return result;
}

      if (a4)
      {
        int v11 = SecFrameworkCopyLocalizedString(@"not displayed (tag = %ld; length %ld)", @"Certificate");
        if (!v11) {
          return 0LL;
        }
      }

      else
      {
        int v11 = @"not displayed (tag = %ld; length %ld)";
      }

      __int128 v13 = CFStringCreateWithFormat(a1, 0LL, v11, a2, *(void *)(a3 + 8));
      CFRelease(v11);
      uint64_t result = v13;
      break;
  }

  return result;
}

  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v2, 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendDNSNamesFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

          int v9 = 0LL;
        }
      }
    }
  }

  ValueAtIndex = SecPolicyCreateBasicX509();
  __int128 v12 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  __int128 v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605228]);
  if (v13) {
    CFRelease(v13);
  }
  BOOL v14 = theDict ? (const __CFDictionary *)CFDictionaryGetValue(theDict, (const void *)kSecCMSSignedAttributes) : 0LL;
  unint64_t v25 = -1431655766;
  int v19 = copySignerCert((__SecTrust *)cfa);
  if (!v19)
  {
    __int128 v15 = 0LL;
    __int128 v16 = 0LL;
    goto LABEL_26;
  }

  __int128 v15 = 0LL;
  if (!CFEqual(values, v19) || !v14)
  {
    __int128 v16 = 0LL;
    __int128 v17 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_42;
  }

  __int128 v16 = copy_signed_attr_printable_string_value(v14, 2u);
  __int128 v15 = copy_signed_attr_printable_string_value(v14, 3u);
  if ((unint64_t)v16 | (unint64_t)v15)
  {
    if (!v16 || !CFEqual(v16, @"3") || !v15 || CFEqual(v15, @"2")) {
      goto LABEL_26;
    }
    if (CFEqual(v15, @"3"))
    {
      unint64_t v32 = 1801;
      unsigned int v20 = CFDataCreate(v12, bytes, 10LL);
      *(void *)bytes = v20;
      if (v20)
      {
        unsigned int v24 = dictionary_array_value_1(v14, v20);
        if (v24)
        {
          signed int v21 = CFDictionaryCreate(v12, (const void **)bytes, &v24, 1LL, MEMORY[0x189605240], MEMORY[0x189605250]);
          if (a4) {
            *a4 = CFErrorCreate(v12, @"PENDING", 3LL, v21);
          }
          if (v21) {
            CFRelease(v21);
          }
        }

        if (*(void *)bytes) {
          CFRelease(*(CFTypeRef *)bytes);
        }
      }

      goto LABEL_26;
    }

    if (!CFEqual(v15, @"0"))
    {
LABEL_26:
      __int128 v17 = 0LL;
      CFMutableDictionaryRef Mutable = 0LL;
      goto LABEL_42;
    }
  }

  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v12, 0LL);
  __int128 v17 = 0LL;
  if (!SecCMSDecryptEnvelopedData((const __CFData *)v29, Mutable, &v27))
  {
    if (v27)
    {
      __int128 v17 = SecCMSCertificatesOnlyMessageCopyCertificates((uint64_t)Mutable);
      if (v17)
      {
        int v22 = CFDictionaryCreate(0LL, (const void **)&kSecValueRef, &v27, 1LL, 0LL, 0LL);
        SecItemDelete(v22);
        if (v22) {
          CFRelease(v22);
        }
      }
    }
  }

  CFRelease(v11);
  CFRelease(v14);
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v20;
}

  int v11 = *a2 - 1LL;
  v64 = a2[1];
  v65 = v11;
  if (DEROidCompare((uint64_t)&OID_PKCS12_pbep, (uint64_t)&v64))
  {
    __int128 v13 = *(unsigned __int8 *)(*a2 + a2[1] - 1LL);
    __int128 v15 = (char *)&pkcsOidInfos + 16 * v13;
    __int128 v16 = *((_DWORD *)v15 - 4);
    __int128 v17 = *((_DWORD *)v15 - 3);
    int v19 = *((_DWORD *)v15 - 2);
    __int128 v18 = *((_DWORD *)v15 - 1);
    unsigned int v20 = 20;
  }

  else
  {
    __int128 v16 = 0;
    unsigned int v20 = 32;
    __int128 v18 = 1;
    int v19 = 16;
    __int128 v17 = 256;
  }

  signed int v21 = v55;
  if ((void)v55 && (int v22 = (unsigned __int8 *)*((void *)&v55 + 1)) != 0LL)
  {
    int v23 = 0;
    do
    {
      unsigned int v24 = *v22++;
      int v23 = v24 | (v23 << 8);
      --v21;
    }

    while (v21);
  }

  else
  {
    int v23 = 0;
  }

  BOOL v34 = a4;
  if (v17 && *(void *)a1)
  {
    unint64_t v25 = (v17 + 7) >> 3;
    BOOL v26 = (void *)PORT_ArenaAlloc(**(void **)a1, v25);
    if (!v26) {
      unint64_t v25 = 0LL;
    }
    if (!v16)
    {
LABEL_30:
      unint64_t v50 = 0LL;
      unint64_t v51 = &v50;
      unint64_t v52 = 0x2000000000LL;
      unint64_t v53 = 0;
      unint64_t v25 = v17 >> 3;
      uint64_t v27 = *(const __CFString **)(a1 + 8);
      v36[0] = MEMORY[0x1895F87A8];
      uint64_t v43 = v60;
      unint64_t v44 = v61;
      __int128 v45 = v62;
      unint64_t v46 = v63;
      int v39 = v56;
      int v40 = v57;
      __int128 v41 = v58;
      __int128 v42 = v59;
      int v37 = v54;
      v36[1] = 0x40000000LL;
      v36[2] = __p12Decrypt_block_invoke;
      v36[3] = &unk_1896763A8;
      v36[4] = &v50;
      int v38 = v55;
      v49 = v23;
      unint64_t v47 = v25;
      unint64_t v48 = v26;
      v64 = MEMORY[0x1895F87A8];
      v65 = 0x40000000LL;
      v66 = __CFStringPerformWithCString_block_invoke;
      CFNumberRef v67 = &unk_189676790;
      v68 = v36;
      CFStringPerformWithCStringAndLength(v27, (uint64_t)&v64);
      char v28 = *((_DWORD *)v51 + 6);
      _Block_object_dispose(&v50, 8);
      if (v28) {
        return result;
      }
      goto LABEL_34;
    }
  }

  else
  {
    unint64_t v25 = 0LL;
    BOOL v26 = 0LL;
    if (!v16) {
      goto LABEL_30;
    }
  }

  if (p12_pbe_gen( *(const __CFString **)(a1 + 8),  *((const void **)&v54 + 1),  v54,  v23,  1LL,  v26,  v25,  0x40u,  v20)) {
    return result;
  }
LABEL_34:
  unint64_t v29 = (void *)*((void *)&v63 + 1);
  if (*((void *)&v63 + 1) && (void)v63)
  {
LABEL_44:
    int v35 = 0uLL;
    int v31 = *(uint64_t **)a1;
    if (*(void *)a1)
    {
      dataOutAvailable = *(void *)a3;
      dataOut = (void *)PORT_ArenaAlloc(*v31, *(void *)a3);
      *((void *)&v35 + 1) = dataOut;
      if (dataOut) {
        *(void *)&int v35 = dataOutAvailable;
      }
      else {
        dataOutAvailable = 0LL;
      }
    }

    else
    {
      dataOutAvailable = 0LL;
      dataOut = 0LL;
    }

    if (!CCCrypt( 1u,  v16,  v18,  v26,  v25,  v29,  *(const void **)(a3 + 8),  *(void *)a3,  dataOut,  dataOutAvailable,  (size_t *)&v35))
    {
      uint64_t result = *(double *)&v35;
      *BOOL v34 = v35;
    }

    return result;
  }

  if (!v19)
  {
    unint64_t v29 = 0LL;
    goto LABEL_44;
  }

  if (*(void *)a1)
  {
    unint64_t v29 = (void *)PORT_ArenaAlloc(**(void **)a1, v19);
    if (v29) {
      int v30 = v19;
    }
    else {
      int v30 = 0LL;
    }
  }

  else
  {
    int v30 = 0LL;
    unint64_t v29 = 0LL;
  }

  if (!p12_pbe_gen( *(const __CFString **)(a1 + 8),  *((const void **)&v54 + 1),  v54,  v23,  2LL,  v29,  v30,  0x40u,  v20)) {
    goto LABEL_44;
  }
  return result;
}

    int v9 = os_unfair_lock_opaque + this;
    v7[2]._os_unfair_lock_opaque = v9;
    os_unfair_lock_unlock(v7 + 3);
    if (!this) {
      return v9;
    }
    if ((_DWORD)v9) {
      return 0LL;
    }
LABEL_14:
    if ((*(unsigned int (**)(os_unfair_lock_s *))(*(void *)&v7->_os_unfair_lock_opaque + 72LL))(v7))
    {
      Security::CFClass::finalizeType(a2, v10);
      int v9 = 0LL;
      *a3 = 1;
      return v9;
    }

    return 0LL;
  }

  if (os_unfair_lock_opaque != -1) {
    goto LABEL_10;
  }
  os_unfair_lock_unlock(v7 + 3);
  if (this) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  BOOL v1 = (const void *)*((void *)certificate + 68);
  if (v1) {
    goto LABEL_5;
  }
  BOOL v3 = SecCertificateCopySPKIEncoded((uint64_t)certificate);
  if (v3)
  {
    int v4 = v3;
    *((void *)certificate + 68) = SecKeyCreateFromSubjectPublicKeyInfoData(0LL, v3);
    CFRelease(v4);
  }

  BOOL v1 = (const void *)*((void *)certificate + 68);
  if (v1) {
LABEL_5:
  }
    CFRetain(v1);
  return (SecKeyRef)v1;
}

CFDataRef SecCertificateCopySPKIEncoded(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 200)) {
    return 0LL;
  }
  unint64_t v2 = DERLengthOfItem(0x2000000000000010uLL, *(void *)(a1 + 208));
  CFDataRef v3 = 0LL;
  CFIndex length = v2;
  if ((v2 & 0x8000000000000000LL) != 0) {
    return v3;
  }
  unint64_t v4 = *(void *)(a1 + 208);
  if (v2 < v4) {
    return v3;
  }
  unint64_t v5 = (UInt8 *)malloc(v2);
  if (!v5) {
    return 0LL;
  }
  unsigned int v6 = v5;
  if (DEREncodeItem( 0x2000000000000010uLL,  v4,  *(const void **)(a1 + 200),  (unint64_t)v5,  (unint64_t *)&length)) {
    CFDataRef v3 = 0LL;
  }
  else {
    CFDataRef v3 = CFDataCreate(0LL, v6, length);
  }
  free(v6);
  return v3;
}

unint64_t DERLengthOfItem(unint64_t result, unint64_t a2)
{
  unint64_t v2 = result & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v3 = 1LL;
  if ((result & 0x1FFFFFFFFFFFFFFFLL) >= 0x1F)
  {
    do
    {
      ++v3;
      BOOL v4 = v2 > 0x7F;
      v2 >>= 7;
    }

    while (v4);
  }

  uint64_t v5 = 1LL;
  if (a2 >= 0x80)
  {
    unint64_t v6 = a2;
    do
    {
      ++v5;
      BOOL v4 = v6 > 0xFF;
      v6 >>= 8;
    }

    while (v4);
  }

  BOOL v7 = __CFADD__(v3, v5);
  uint64_t v8 = v3 + v5;
  if (v7 || (uint64_t result = v8 + a2, __CFADD__(v8, a2))) {
    __break(0x5500u);
  }
  return result;
}

uint64_t DEREncodeItem( unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t *a5)
{
  return DEREncodeItemSized(a1, a2, a3, a4, *a5, a5);
}

uint64_t DEREncodeItemSized( unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  v22[1] = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a6;
  unint64_t v13 = DERLengthOfItem(a1, a2);
  if (v13 > a5) {
    return 7LL;
  }
  unint64_t v15 = v13;
  if (v13 > *a6) {
    goto LABEL_20;
  }
  *a6 = v13;
  v22[0] = v13;
  if (v13 > v12) {
    goto LABEL_20;
  }
  uint64_t result = DEREncodeTag(a1, a4, (unint64_t *)v22);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v16 = v22[0];
  if (__CFADD__(a4, v22[0]))
  {
LABEL_21:
    __break(0x5513u);
    goto LABEL_22;
  }

  BOOL v17 = v15 >= v22[0];
  unint64_t v18 = v15 - v22[0];
  if (!v17) {
    goto LABEL_22;
  }
  unint64_t v19 = a4 + v12;
  unint64_t v20 = a4 + v22[0];
  v22[0] = v18;
  if (a4 + v16 > a4 + v12 || v20 < a4 || v18 > v19 - v20) {
LABEL_20:
  }
    __break(0x5519u);
  uint64_t result = DEREncodeLengthSized(a2, v20, v18, v22);
  if ((_DWORD)result) {
    return result;
  }
  if (__CFADD__(v20, v22[0])) {
    goto LABEL_21;
  }
  if (v18 < v22[0])
  {
LABEL_22:
    __break(0x5515u);
    return result;
  }

  signed int v21 = (void *)(v20 + v22[0]);
  memmove(v21, a3, a2);
  return 0LL;
}

uint64_t DEREncodeTag(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(_BYTE *)a2 = HIBYTE(result) & 0xE0 | result;
      unint64_t v8 = 1LL;
      goto LABEL_17;
    }

    return 7LL;
  }

  unint64_t v4 = 0LL;
  unint64_t v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    BOOL v6 = v5 > 0x7F;
    v5 >>= 7;
  }

  while (v6);
  unint64_t v7 = *a3;
  if (v4 >= *a3) {
    return 7LL;
  }
  if (v4 >= ~a2 || (*(_BYTE *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2LL))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }

  if (a2 + v4 >= a2)
  {
    unint64_t v8 = v4 + 1;
    *(_BYTE *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      int v9 = (_BYTE *)(a2 + v4 - 1);
      CFURLRef v10 = (_BYTE *)(a2 + v7);
      while (v9 != (_BYTE *)-2LL)
      {
        unint64_t v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11) {
          goto LABEL_17;
        }
      }

      goto LABEL_20;
    }

LABEL_21:
  __break(0x5519u);
  return result;
}

  __break(0x5500u);
  return result;
}

    [v16 addObject:@"parentKeyUUID"];
    if (v11) {
      goto LABEL_14;
    }
    goto LABEL_22;
  }

  if (!a4)
  {
    unint64_t v12 = 0LL;
    goto LABEL_17;
  }

  unint64_t v13 = (void *)MEMORY[0x189607870];
  BOOL v14 = *MEMORY[0x189607670];
  int v23 = *MEMORY[0x1896075E0];
  v24[0] = @"No wrapped key to parse";
  [MEMORY[0x189603F68] dictionaryWithObjects:v24 forKeys:&v23 count:1];
  unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  [v13 errorWithDomain:v14 code:-50 userInfo:v11];
  unint64_t v12 = 0LL;
  *a4 = (id)objc_claimAutoreleasedReturnValue();
LABEL_16:

LABEL_17:
  return v12;
}

    [v21 addObject:@"senderPeerID"];
    if (v15)
    {
LABEL_13:
      if (v18) {
        goto LABEL_14;
      }
      goto LABEL_23;
    }

  return v11;
}

  (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
}

  uint64_t result = 0xFFFFFFFFLL;
LABEL_22:
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

      if (a2 == 1) {
        return 0LL;
      }
      *(_DWORD *)CFURLRef v10 = 0;
      *(_DWORD *)(v10 + 24) = 0;
      unint64_t v19 = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
      *(void *)(v10 + 32) = v19;
      if (!v19) {
        return 0LL;
      }
      goto LABEL_35;
    }

    *(_DWORD *)CFURLRef v10 = 0;
    *(_DWORD *)(v10 + 24) = a2;
    if (a2)
    {
      unint64_t v20 = (unint64_t *)PORT_ArenaAlloc(v8, 0x10uLL);
      *(void *)(v10 + 32) = v20;
      if (!v20) {
        goto LABEL_45;
      }
      if (SECITEM_CopyItem(v8, v20, a4))
      {
        unint64_t v15 = -8077;
        goto LABEL_11;
      }

      if (!*(void *)(*(void *)(v10 + 32) + 8LL))
      {
LABEL_45:
        unint64_t v15 = -8173;
        goto LABEL_11;
      }
    }

    else
    {
      *(void *)(v10 + 32) = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
    }
  }

  CFRelease(v5);
  unint64_t v7 = 0LL;
  uint64_t result = 0LL;
  unint64_t v5 = Mutable;
  if (Mutable)
  {
LABEL_25:
    CFRelease(v5);
    return (const __CFArray *)v7;
  }

  return result;
}

    CFRelease(v6);
    return v8;
  }

  return v5;
}

    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_13;
  }

  CFRetain(v8);
  CFMutableDictionaryRef Mutable = v9;
LABEL_13:
  CFRelease(v9);
  return Mutable;
}

  CFRelease(v15);
  if (v23) {
    CFRelease(v23);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v35)
  {
    int v38 = v35;
LABEL_31:
    CFRelease(v38);
  }

  return v34;
}

    CFIndex Length = CFDataGetLength(v22);
    unint64_t v25 = CFStringCreateMutable(v9, 2 * Length);
    BytePtr = CFDataGetBytePtr(v22);
    char v28 = CFDataGetLength(v22);
    if (v28 >= 1)
    {
      unint64_t v29 = v28;
      do
      {
        int v30 = *BytePtr++;
        CFStringAppendFormat(v25, 0LL, @"%02X", v30);
        --v29;
      }

      while (v29);
    }

        SecError(-50, a8, @"%@: sign - input buffer bad size (%d bytes)", a1, Length);
        return 0LL;
      }

      return (__CFData *)*MEMORY[0x189604DE8];
    }
  }

  else if (!a2 && CFEqual(cf1, @"algid:sign:RSA:raw-cc"))
  {
    if (!a5)
    {
      CFIndex Length = CFDataGetLength(a6);
      ccrsa_ctx_public();
      if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8LL))
      {
        CFDataGetLength(a6);
        CFDataGetBytePtr(a6);
        if ((ccn_cmpn() & 0x80000000) == 0)
        {
          BOOL v17 = CFDataGetLength(a6);
          SecError(-50, a8, @"%@: sign - digest too big (%d bytes)", a1, v17);
          return 0LL;
        }

        BOOL v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        goto LABEL_15;
      }

      goto LABEL_21;
    }

    return (__CFData *)*MEMORY[0x189604DE8];
  }

  return Mutable;
}

unint64_t DEREncodeLengthSized( unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (result >= 0x80)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = result;
    do
    {
      --v5;
      BOOL v7 = v6 > 0xFF;
      v6 >>= 8;
    }

    while (v7);
    unint64_t v8 = -v5;
    uint64_t v9 = 7LL;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        uint64_t v4 = 1 - v5;
        *(_BYTE *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          CFURLRef v10 = (_BYTE *)(a2 - v5);
          if (a2 - v5 != -2LL)
          {
            unint64_t v11 = (_BYTE *)(a2 + *a4);
            while (v10 != (_BYTE *)-1LL)
            {
              *v10-- = result;
              BOOL v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4) {
                  goto LABEL_23;
                }
                goto LABEL_19;
              }
            }
          }
        }

        __break(0x5513u);
      }

      goto LABEL_23;
    }

    return v9;
  }

  if (!a3) {
    return 7LL;
  }
  if (*a4)
  {
    *(_BYTE *)a2 = result;
    if (*a4)
    {
      uint64_t v4 = 1LL;
LABEL_19:
      uint64_t v9 = 0LL;
      *a4 = v4;
      return v9;
    }
  }

LABEL_23:
  __break(0x5519u);
  return result;
}

  __break(0x5519u);
  return result;
}

  __break(0x5519u);
LABEL_24:
  __break(1u);
  return result;
}

    [v21 addObject:@"signature"];
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  unint64_t v19 = -[CKKSExternalTLKShare initWithView:tlkUUID:receiverPeerID:senderPeerID:wrappedTLK:signature:]( objc_alloc(&OBJC_CLASS___CKKSExternalTLKShare),  "initWithView:tlkUUID:receiverPeerID:senderPeerID:wrappedTLK:signature:",  v7,  v8,  v10,  v12,  v15,  v18);
LABEL_17:

  return v19;
}

    unsigned int v24 = 0LL;
    unint64_t v25 = 0LL;
    unint64_t v15 = 4294967188LL;
    goto LABEL_24;
  }

  unint64_t v13 = (objc_class *)objc_opt_class();
  NSStringFromClass(v13);
  BOOL v14 = (id)objc_claimAutoreleasedReturnValue();
LABEL_53:

  return v14;
}

  unint64_t v18 = 0LL;
  if (v8) {
LABEL_10:
  }
    CFRelease(v8);
LABEL_11:
  unint64_t v19 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v19);
  }

  unint64_t v20 = v24;
  if (v24)
  {
    unsigned int v24 = 0LL;
    CFRelease(v20);
  }

  if (v14) {
    CFRelease(v14);
  }
  return v18;
}

      ++a1;
      if (!--a2) {
        return (_BYTE *)(v9 - a3);
      }
    }
  }

  return (_BYTE *)v8;
}

  SecError(v20, &v40, @"failed to generate key", context);
  _SecKeyErrorPropagate(key != 0LL, (uint64_t)"SecKeyCreateRandomKey", v40, error);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (cf) {
    CFRelease(cf);
  }
  unint64_t v25 = key;
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(contextb);
  return v25;
}

        appendError(v1, @"Policy requirements not met.");
        uint64_t v9 = context;
        if ((context & 0x40) == 0)
        {
LABEL_13:
          if ((v9 & 0x80) == 0) {
            goto LABEL_14;
          }
          goto LABEL_25;
        }

      unint64_t v18 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v84, (char *)p_str);
      unint64_t v19 = std::string::insert(v18, 0LL, "../", 3uLL);
      unint64_t v20 = v19->__r_.__value_.__r.__words[0];
      *(void *)v85 = v19->__r_.__value_.__l.__size_;
      *(void *)&v85[7] = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
      size = v19->__r_.__value_.__s.__size_;
      v19->__r_.__value_.__l.__size_ = 0LL;
      v19->__r_.__value_.__l.__cap_ = 0LL;
      v19->__r_.__value_.__r.__words[0] = 0LL;
      __str.__r_.__value_.__r.__words[0] = v20;
      __str.__r_.__value_.__l.__size_ = *(void *)v85;
      *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(void *)&v85[7];
      __str.__r_.__value_.__s.__size_ = size;
      std::string::basic_string(&v84, &__str, 0LL, 0xCuLL, (std::allocator<char> *)v85);
      int v22 = v84.__r_.__value_.__s.__size_;
      if ((v84.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v22 = v84.__r_.__value_.__l.__size_;
      }
      if (v22 == 12)
      {
        int v23 = (std::string *)v84.__r_.__value_.__r.__words[0];
        if ((v84.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v23 = &v84;
        }
        unsigned int v24 = v23->__r_.__value_.__r.__words[0];
        unint64_t v25 = v23->__r_.__value_.__r.__words[1];
        uint64_t v27 = v24 == 0x65746E6F432F2E2ELL && v25 == 796095598;
        if (((char)v84.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_39:
          if (v27)
          {
LABEL_43:
            std::string::basic_string(&v84, &__str, 0xCuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v85);
            __str = v84;
          }

void *SecKeyCreateFromSubjectPublicKeyInfoData(uint64_t a1, CFDataRef theData)
{
  v18[0] = CFDataGetBytePtr(theData);
  v18[1] = CFDataGetLength(theData);
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v16 = v4;
  __int128 v17 = v4;
  *(_OWORD *)unint64_t v15 = v4;
  *(_OWORD *)&v15[16] = v4;
  unint64_t v13 = (uint8_t *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  if (!DERParseSequence( (uint64_t)v18,  (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs,  (uint64_t)&DERSubjPubKeyInfoItemSpecs,  (unint64_t)&v16,  0x20uLL)
    && !DERParseSequenceContent( (unint64_t *)&v16,  (unsigned __int16)DERNumAlgorithmIdItemSpecs,  (uint64_t)&DERAlgorithmIdItemSpecs,  (unint64_t)v15,  0x20uLL))
  {
    char v12 = -86;
    if (!DERParseBitString((uint64_t)&v17, (unint64_t *)&v13, &v12))
    {
      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidRsa))
      {
        uint64_t v5 = v13;
        uint64_t v6 = v14;
        BOOL v7 = &kSecRSAPublicKeyDescriptor;
        uint64_t v8 = a1;
        uint64_t v9 = 1LL;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }

      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEcPubKey))
      {
        *(void *)buf = *(void *)v15;
        __int128 v20 = *(_OWORD *)&v15[8];
        uint64_t v21 = *(void *)&v15[24];
        unint64_t v22 = (unint64_t)v13;
        unint64_t v23 = v14;
        BOOL v7 = &kSecECPublicKeyDescriptor;
        uint64_t v5 = buf;
        uint64_t v8 = a1;
        uint64_t v6 = 48LL;
        uint64_t v9 = 4LL;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }

      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEd25519))
      {
        uint64_t v5 = v13;
        uint64_t v6 = v14;
        BOOL v7 = &kSecEd25519PublicKeyDescriptor;
LABEL_12:
        uint64_t v8 = a1;
        uint64_t v9 = 7LL;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }

      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEd448))
      {
        uint64_t v5 = v13;
        uint64_t v6 = v14;
        BOOL v7 = &kSecEd448PublicKeyDescriptor;
        goto LABEL_12;
      }

      _SECKEY_LOG_9790();
      unint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "Unsupported algorithm oid", buf, 2u);
      }
    }
  }

  return 0LL;
}

void *SecKeyCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a2) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"Attempting to create SecKeyRef with NULL key_class"];
  }
  uint64_t v9 = *(unsigned int *)(a2 + 16);
  SecKeyGetTypeID();
  size_t v10 = v9 + 16;
  uint64_t Instance = _CFRuntimeCreateInstance();
  char v12 = (void *)Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), v10);
    v12[2] = a2;
    if (*(_DWORD *)(a2 + 16)) {
      v12[3] = v12 + 4;
    }
    unint64_t v13 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v13)
    {
      int v14 = v13(v12, a3, a4, a5);
      if (v14)
      {
        int v15 = v14;
        _SECKEY_LOG_9790();
        __int128 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = *(void *)(a2 + 8);
          int v19 = 136446466;
          uint64_t v20 = v18;
          __int16 v21 = 1024;
          int v22 = v15;
          _os_log_error_impl( &dword_1804F4000,  v16,  OS_LOG_TYPE_ERROR,  "SecKeyCreate init(%{public}s) failed: %d",  (uint8_t *)&v19,  0x12u);
        }

        CFRelease(v12);
        return 0LL;
      }
    }
  }

  return v12;
}

CFTypeID SecKeyGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SecKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SecKeyGetTypeID_sSecKeyGetTypeIDSingleton;
  if (SecKeyGetTypeID_sSecKeyGetTypeIDOnce != -1) {
    dispatch_once(&SecKeyGetTypeID_sSecKeyGetTypeIDOnce, block);
  }
  return SecKeyGetTypeID_sSecKeyGetTypeIDSingleton;
}

uint64_t SecRSAPublicKeyInit(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = 4294967246LL;
  switch(a4)
  {
    case 1:
    case 7:
      uint64_t v8 = ccrsa_import_pub_n();
      if ((unint64_t)(v8 - 129) >= 0xFFFFFFFFFFFFFF80LL)
      {
        uint64_t v9 = v8;
        size_t v10 = calloc(1uLL, 24 * v8 + 40);
        *(void *)(a1 + 24) = v10;
        if (!v10) {
          goto LABEL_17;
        }
        void *v10 = v9;
        int v11 = ccrsa_import_pub();
        goto LABEL_11;
      }

      uint64_t result = 4294967246LL;
      break;
    case 2:
      char v12 = (unint64_t *)calloc(1uLL, 0xC28uLL);
      *(void *)(a1 + 24) = v12;
      if (!v12) {
        goto LABEL_17;
      }
      unint64_t v13 = v12;
      *char v12 = 128LL;
      v25[0] = a2;
      v25[1] = a3;
      *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v24[1] = v14;
      v24[2] = v14;
      v24[0] = v14;
      if (!DERParseSequence( (uint64_t)v25,  (unsigned __int16)DERNumRSAPubKeyAppleItemSpecs,  (uint64_t)&DERRSAPubKeyAppleItemSpecs,  (unint64_t)v24,  0x30uLL))
      {
        uint64_t v15 = *((void *)&v24[0] + 1);
        __int128 v16 = *(_BYTE **)&v24[0];
        __int128 v17 = v13;
        goto LABEL_10;
      }

      uint64_t result = 4294941021LL;
      break;
    case 3:
      unint64_t v18 = *(void *)(a2 + 8) + 7LL;
      __int128 v17 = (unint64_t *)calloc(1uLL, 3 * (v18 & 0xFFFFFFFFFFFFFFF8LL) + 40);
      *(void *)(a1 + 24) = v17;
      if (!v17) {
        goto LABEL_17;
      }
      *__int128 v17 = v18 >> 3;
      __int128 v16 = *(_BYTE **)a2;
      uint64_t v15 = *(void *)(a2 + 8);
LABEL_10:
      int v11 = ccrsa_pub_init(v17, v15, v16);
LABEL_11:
      if (v11) {
        uint64_t result = 4294967246LL;
      }
      else {
        uint64_t result = 0LL;
      }
      break;
    case 6:
      int v19 = *(_BYTE **)a2;
      size_t v20 = 24LL * *(void *)a2 + 40;
      __int16 v21 = calloc(1uLL, v20);
      *(void *)(a1 + 24) = v21;
      if (v21)
      {
        int v22 = v21;
        *__int16 v21 = v19;
        uint64_t v23 = (const void *)ccrsa_ctx_public();
        memcpy(v22, v23, v20);
        uint64_t result = 0LL;
      }

      else
      {
LABEL_17:
        uint64_t result = 4294967188LL;
      }

      break;
    default:
      return result;
  }

  return result;
}

void *SecPolicyCreateSSLWithKeyUsage(int a1, const __CFString *a2, int a3)
{
  return SecPolicyCreateSSL_internal(a1, a2, a3, 0LL);
}

void *SecPolicyCreateSSL_internal(int a1, const __CFString *a2, int a3, const __CFDictionary *a4)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v9 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (a2) {
    CFDictionaryAddValue(v9, @"SSLHostname", a2);
  }
  size_t v10 = (const void *)*MEMORY[0x189604DE8];
  CFDictionaryAddValue(v9, @"BlackListedLeaf", (const void *)*MEMORY[0x189604DE8]);
  CFDictionaryAddValue(v9, @"GrayListedLeaf", v10);
  if (!a1) {
    goto LABEL_41;
  }
  if (SecPolicyRemoveWeakHashOptions(v9) && SecPolicyAddStrongKeySizeOptions(v9))
  {
    if (SecPolicyAddPinningRequiredIfInfoSpecified_onceToken != -1) {
      dispatch_once(&SecPolicyAddPinningRequiredIfInfoSpecified_onceToken, &__block_literal_global_11627);
    }
    if (SecPolicyAddPinningRequiredIfInfoSpecified_result == 1)
    {
      if (SecPolicyAddPinningRequiredIfInfoSpecified_hasPinningRequiredKey != 1
        || (add_element(v9, @"PinningRequired", v10), SecPolicyAddPinningRequiredIfInfoSpecified_result == 1))
      {
        Value = (const __CFString *)CFDictionaryGetValue(v9, @"SSLHostname");
        if (Value)
        {
          char v12 = Value;
          CFTypeID v13 = CFGetTypeID(Value);
          if (v13 == CFStringGetTypeID())
          {
            CFMutableArrayRef NSPinnedIdentitiesForHostName = getNSPinnedIdentitiesForHostName( v12,  (uint64_t)@"NSPinnedLeafIdentities");
            if (NSPinnedIdentitiesForHostName) {
              add_element(v9, @"LeafSPKISHA256", NSPinnedIdentitiesForHostName);
            }
            CFMutableArrayRef v15 = getNSPinnedIdentitiesForHostName(v12, (uint64_t)@"NSPinnedCAIdentities");
            if (v15) {
              add_element(v9, @"CAspkiSHA256", v15);
            }
          }
        }

        SecPolicyReconcilePinningRequiredIfInfoSpecified(v9);
        __int128 v16 = CFArrayCreateMutable(0LL, 2LL, MEMORY[0x189605228]);
        CFDateRef v17 = CFDateCreate(0LL, 541555200.0);
        uint64_t valuePtr = 0x4190FECE40000000LL;
        CFNumberRef v18 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v16, v17);
        CFArrayAppendValue(v16, v18);
        if (v17) {
          CFRelease(v17);
        }
        if (v18) {
          CFRelease(v18);
        }
        int v19 = CFArrayCreateMutable(0LL, 2LL, MEMORY[0x189605228]);
        CFDateRef v20 = CFDateCreate(0LL, 620611200.0);
        uint64_t v31 = 0x418065A800000000LL;
        CFNumberRef v21 = CFNumberCreate(0LL, kCFNumberDoubleType, &v31);
        CFArrayAppendValue(v19, v20);
        CFArrayAppendValue(v19, v21);
        if (v20) {
          CFRelease(v20);
        }
        if (v21) {
          CFRelease(v21);
        }
        int v22 = CFArrayCreateMutable(0LL, 2LL, MEMORY[0x189605228]);
        CFArrayAppendValue(v22, v16);
        CFArrayAppendValue(v22, v19);
        if (v19) {
          CFRelease(v19);
        }
        if (v16) {
          CFRelease(v16);
        }
        CFDictionaryAddValue(v9, @"SystemTrustValidityPeriod", v22);
        if (v22) {
          CFRelease(v22);
        }
        uint64_t v23 = CFArrayCreateMutable(0LL, 2LL, MEMORY[0x189605228]);
        CFDateRef v24 = CFDateCreate(0LL, 583628400.0);
        CFNumberRef v25 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v23, v24);
        CFArrayAppendValue(v23, v25);
        if (v24) {
          CFRelease(v24);
        }
        if (v25) {
          CFRelease(v25);
        }
        BOOL v26 = CFArrayCreateMutable(0LL, 1LL, MEMORY[0x189605228]);
        CFArrayAppendValue(v26, v23);
        if (v23) {
          CFRelease(v23);
        }
        CFDictionaryAddValue(v9, @"OtherTrustValidityPeriod", v26);
        if (v26) {
          CFRelease(v26);
        }
        CFDictionaryAddValue(v9, @"ServerAuthEKU", v10);
        CFDictionaryAddValue(v9, @"SystemTrustedCTRequired", v10);
LABEL_41:
        if (a3)
        {
          add_ku(v9, a3);
          add_ku(v9, 0);
        }

        BOOL v27 = a1 != 0;
        if (a1) {
          char v28 = @"sslServer";
        }
        else {
          char v28 = @"sslClient";
        }
        set_ssl_ekus(v9, v27);
        add_ats_options_from_dict(v9, a2, a4);
        unint64_t v29 = SecPolicyCreate(@"1.2.840.113635.100.1.3", v28, v9);
        goto LABEL_47;
      }
    }
  }

  unint64_t v29 = 0LL;
LABEL_47:
  CFRelease(v9);
  return v29;
}

void SecPolicyAddBasicX509Options(__CFDictionary *a1)
{
  unint64_t v2 = (const void *)*MEMORY[0x189604DE8];
  CFDictionaryAddValue(a1, @"TemporalValidity", (const void *)*MEMORY[0x189604DE8]);
  CFDictionaryAddValue(a1, @"BlackListedLeaf", v2);
  CFDictionaryAddValue(a1, @"GrayListedLeaf", v2);
}

void SecPolicyAddBasicCertOptions(__CFDictionary *a1)
{
  unint64_t v2 = (const void *)*MEMORY[0x189604DE8];
  CFDictionaryAddValue(a1, @"CriticalExtensions", (const void *)*MEMORY[0x189604DE8]);
  CFDictionaryAddValue(a1, @"UnparseableExtension", v2);
  CFDictionaryAddValue(a1, @"DuplicateExtension", v2);
  CFDictionaryAddValue(a1, @"IdLinkage", v2);
  CFDictionaryAddValue(a1, @"BasicConstraints", v2);
  CFDictionaryAddValue(a1, @"NonEmptySubject", v2);
  CFDictionaryAddValue(a1, @"WeakKeySize", v2);
  CFDictionaryAddValue(a1, @"WeakSignature", v2);
}

BOOL SecPolicyRemoveWeakHashOptions(const __CFDictionary *a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 5LL, MEMORY[0x189605228]);
  unint64_t v3 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, @"SignatureDigestMD2");
    CFArrayAppendValue(v3, @"SignatureDigestMD4");
    CFArrayAppendValue(v3, @"SignatureDigestMD5");
    CFArrayAppendValue(v3, @"SignatureDigestSHA1");
    add_element(a1, @"SignatureHashAlgorithms", v3);
    CFRelease(v3);
  }

  return v3 != 0LL;
}

void add_element(const __CFDictionary *a1, const void *a2, const void *a3)
{
  Value = (__CFArray *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    BOOL v7 = Value;
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFArrayGetTypeID())
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
      CFArrayAppendValue(Mutable, v7);
      CFDictionarySetValue(a1, a2, Mutable);
      CFRelease(Mutable);
      BOOL v7 = Mutable;
    }

    CFArrayAppendValue(v7, a3);
  }

  else
  {
    CFDictionaryAddValue(a1, a2, a3);
  }

BOOL SecPolicyAddStrongKeySizeOptions(const __CFDictionary *a1)
{
  keys[2] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v10 = 2048LL;
  CFNumberRef v2 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v10);
  if (!v2) {
    return 0LL;
  }
  CFNumberRef v3 = v2;
  uint64_t v10 = 256LL;
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v10);
  if (v4)
  {
    CFNumberRef v5 = v4;
    keys[0] = @"42";
    keys[1] = @"73";
    values[0] = v3;
    values[1] = v4;
    CFDictionaryRef v6 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    BOOL v7 = v6 != 0LL;
    if (v6)
    {
      CFDictionaryRef v8 = v6;
      add_element(a1, @"KeySize", v6);
      CFRelease(v8);
    }

    CFRelease(v3);
  }

  else
  {
    BOOL v7 = 0LL;
    CFNumberRef v5 = v3;
  }

  CFRelease(v5);
  return v7;
}

CFMutableArrayRef getNSPinnedIdentitiesForHostName(const __CFString *a1, uint64_t a2)
{
  if (getNSPinnedIdentitiesForHostName_onceToken != -1) {
    dispatch_once(&getNSPinnedIdentitiesForHostName_onceToken, &__block_literal_global_759);
  }
  CFMutableArrayRef result = (CFMutableArrayRef)getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict;
  if (getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict) {
    return parseNSPinnedDomains((const __CFDictionary *)getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict, a1, a2);
  }
  return result;
}

void SecPolicyReconcilePinningRequiredIfInfoSpecified(const __CFDictionary *a1)
{
  if (CFDictionaryContainsKey(a1, @"PinningRequired"))
  {
    Value = CFDictionaryGetValue(a1, @"LeafSPKISHA256");
    CFNumberRef v3 = CFDictionaryGetValue(a1, @"CAspkiSHA256");
    if (Value)
    {
      CFNumberRef v4 = v3;
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFArrayGetTypeID() && !CFArrayGetCount((CFArrayRef)Value))
      {
        if (v4)
        {
          CFTypeID v6 = CFGetTypeID(v4);
          if (v6 == CFArrayGetTypeID() && !CFArrayGetCount((CFArrayRef)v4)) {
            CFDictionaryRemoveValue(a1, @"PinningRequired");
          }
        }
      }
    }

    CFDictionaryRemoveValue(a1, @"LeafSPKISHA256");
    CFDictionaryRemoveValue(a1, @"CAspkiSHA256");
  }

void add_ku(const __CFDictionary *a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v3;
    add_element(a1, @"KeyUsage", v3);
    CFRelease(v4);
  }

void set_ssl_ekus(__CFDictionary *a1, int a2)
{
  if (a2)
  {
    add_eku(a1, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
    add_eku(a1, (const UInt8 *)&oidExtendedKeyUsageMicrosoftSGC);
    CFNumberRef v4 = &oidExtendedKeyUsageNetscapeSGC;
  }

  else
  {
    CFNumberRef v4 = &oidExtendedKeyUsageClientAuth;
  }

  add_eku(a1, (const UInt8 *)v4);
}

void add_eku(const __CFDictionary *a1, const UInt8 *a2)
{
  if (a2)
  {
    CFIndex v3 = *((void *)a2 + 1);
    if (v3 < 0) {
      return;
    }
    a2 = *(const UInt8 **)a2;
  }

  else
  {
    CFIndex v3 = 0LL;
  }

  CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], a2, v3);
  if (v4)
  {
    CFDataRef v5 = v4;
    add_element(a1, @"ExtendedKeyUsage", v4);
    CFRelease(v5);
  }

void *SecPolicyCreate(const void *a1, const void *a2, const void *a3)
{
  if (!a1) {
    return 0LL;
  }
  SecPolicyGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(a1);
    Instance[2] = a1;
    if (a2) {
      CFRetain(a2);
    }
    Instance[3] = a2;
    CFRetain(a3);
    Instance[4] = a3;
  }

  return Instance;
}

CFTypeID SecPolicyGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecPolicyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11596;
  block[4] = &SecPolicyGetTypeID_sSecPolicyGetTypeIDSingleton;
  if (SecPolicyGetTypeID_sSecPolicyGetTypeIDOnce != -1) {
    dispatch_once(&SecPolicyGetTypeID_sSecPolicyGetTypeIDOnce, block);
  }
  return SecPolicyGetTypeID_sSecPolicyGetTypeIDSingleton;
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  int v39 = (void *)policies;
  values = (void *)certificates;
  CFTypeID v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFTypeID v7 = CFGetTypeID(certificates);
  if (v7 != CFArrayGetTypeID())
  {
    if (v7 != SecCertificateGetTypeID())
    {
      char v28 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( &dword_1804F4000,  v28,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: certificates contains unsupported value type",  buf,  2u);
      }

      return -50;
    }

    int v11 = CFArrayCreate(v6, (const void **)&values, 1LL, MEMORY[0x189605228]);
    if (v11) {
      goto LABEL_13;
    }
    return -108;
  }

  uint64_t Count = CFArrayGetCount((CFArrayRef)certificates);
  if (Count < 1) {
    return -50;
  }
  uint64_t v9 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, Count, MEMORY[0x189605228]);
  if (!Mutable) {
    return -108;
  }
  int v11 = Mutable;
  int v36 = trust;
  for (CFIndex i = 0LL; i != v9; ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)certificates, i);
    if (ValueAtIndex && (v14 = ValueAtIndex, CFTypeID v15 = CFGetTypeID(ValueAtIndex), v15 == SecCertificateGetTypeID()))
    {
      CFArrayAppendValue(v11, v14);
    }

    else
    {
      __int128 v16 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( &dword_1804F4000,  v16,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: certificates array contains non-certificate value",  buf,  2u);
      }
    }
  }

  if (v9 != CFArrayGetCount(v11)) {
    goto LABEL_43;
  }
  trust = v36;
LABEL_13:
  if (!policies)
  {
    *(void *)buf = SecPolicyCreateBasicX509();
    CFNumberRef v21 = CFArrayCreate(v6, (const void **)buf, 1LL, MEMORY[0x189605228]);
    CFRelease(*(CFTypeRef *)buf);
    if (v21) {
      goto LABEL_33;
    }
    goto LABEL_40;
  }

  CFTypeID v17 = CFGetTypeID(policies);
  if (v17 != CFArrayGetTypeID())
  {
    CFTypeID v33 = CFGetTypeID(policies);
    if (v33 == SecPolicyGetTypeID())
    {
      CFNumberRef v21 = CFArrayCreate(v6, (const void **)&v39, 1LL, MEMORY[0x189605228]);
      if (v21) {
        goto LABEL_33;
      }
      goto LABEL_40;
    }

    BOOL v34 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_1804F4000,  v34,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: policies contains unsupported value type",  buf,  2u);
    }

LABEL_43:
    OSStatus v27 = -50;
    goto LABEL_44;
  }

  uint64_t v18 = CFArrayGetCount((CFArrayRef)policies);
  if (v18 < 1) {
    goto LABEL_43;
  }
  uint64_t v19 = v18;
  CFMutableArrayRef v20 = CFArrayCreateMutable(v6, v18, MEMORY[0x189605228]);
  if (!v20)
  {
LABEL_40:
    OSStatus v27 = -108;
LABEL_44:
    CFRelease(v11);
    return v27;
  }

  CFNumberRef v21 = v20;
  int v37 = trust;
  for (CFIndex j = 0LL; j != v19; ++j)
  {
    uint64_t v23 = CFArrayGetValueAtIndex((CFArrayRef)policies, j);
    if (v23 && (CFDateRef v24 = v23, v25 = CFGetTypeID(v23), v25 == SecPolicyGetTypeID()))
    {
      CFArrayAppendValue(v21, v24);
    }

    else
    {
      BOOL v26 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( &dword_1804F4000,  v26,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: policies array contains non-policy value",  buf,  2u);
      }
    }
  }

  if (v19 != CFArrayGetCount(v21))
  {
    CFRelease(v11);
    CFRelease(v21);
    return -50;
  }

  trust = v37;
LABEL_33:
  dispatch_queue_t v29 = dispatch_queue_create("trust", 0LL);
  dispatch_group_t v30 = dispatch_group_create();
  OSStatus v27 = -108;
  if (v29)
  {
    dispatch_group_t v31 = v30;
    if (v30)
    {
      SecTrustGetTypeID();
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        *(_OWORD *)(Instance + 24) = 0u;
        *(_OWORD *)(Instance + 104) = 0u;
        *(_OWORD *)(Instance + 136) = 0u;
        *(_OWORD *)(Instance + 152) = 0u;
        *(_OWORD *)(Instance + 120) = 0u;
        *(_OWORD *)(Instance + 88) = 0u;
        *(_OWORD *)(Instance + 72) = 0u;
        *(_OWORD *)(Instance + 56) = 0u;
        *(_OWORD *)(Instance + 40) = 0u;
        *(void *)(Instance + 16) = v11;
        *(void *)(Instance + 32) = v21;
        *(_BYTE *)(Instance + 117) = 1;
        *(void *)(Instance + 136) = v29;
        *(void *)(Instance + 168) = v31;
        if (trust)
        {
          OSStatus v27 = 0;
          *trust = (SecTrustRef)Instance;
        }

        else
        {
          CFRelease((CFTypeRef)Instance);
          return 0;
        }

        return v27;
      }

      OSStatus v27 = -50;
    }
  }

  CFRelease(v11);
  CFRelease(v21);
  if (v29) {
    dispatch_release(v29);
  }
  return v27;
}

      ;
    }

    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

        CFTypeID v25 = 8;
LABEL_45:
        CFRelease(v19);
LABEL_46:
        *(_DWORD *)(v10 + 160) = v25;
        dispatch_group_t v30 = PR_getThreadErrInfo(1, &v33);
        if (v30) {
          void *v30 = 0xFFFFE02F00000000LL;
        }
        return 0xFFFFFFFFLL;
      }
    }
  }

  return 4294967246LL;
}

    char v28 = *v24;
    if (*v24) {
      goto LABEL_47;
    }
    goto LABEL_44;
  }

  if ((void)v72 == 9LL && !memcmp(&_oidSha1Rsa, *((const void **)&v72 + 1), 9uLL))
  {
    CFDateRef v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
    goto LABEL_43;
  }

  if ((void)v23 == 9LL && !memcmp(&_oidSha256Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFDateRef v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_43;
  }

  if ((void)v23 == 9LL && !memcmp(&_oidSha384Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFDateRef v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_43;
  }

  if ((void)v23 == 9LL && !memcmp(&_oidSha512Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    CFDateRef v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_43;
  }

  BOOL v34 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
  *(void *)(Instance + 112) = v34;
  if (!v34) {
    goto LABEL_76;
  }
LABEL_44:
  CFNumberRef v67 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 112), 0, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  int v35 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  int v36 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v35;
  bytes = v36;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 112), 1, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  int v37 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  int v38 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v37;
  bytes = v38;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 104), 0, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  int v39 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  int v40 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v39;
  bytes = v40;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 80), *(void *)(Instance + 104), 1, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  __int128 v41 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  __int128 v42 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v41;
  bytes = v42;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 112), 0, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  uint64_t v43 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  unint64_t v44 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v43;
  bytes = v44;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 112), 1, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  __int128 v45 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  unint64_t v46 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v45;
  bytes = v46;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 104), 0, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  unint64_t v47 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  unint64_t v48 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v47;
  bytes = v48;
  SecOTRSFindKeysForMessage(Instance, *(void *)(Instance + 88), *(void *)(Instance + 104), 1, 0LL, 0LL, &v67);
  if (!v67) {
    goto LABEL_76;
  }
  v49 = v68;
  unint64_t v50 = v68 - 8;
  if (v68 < 8) {
    goto LABEL_76;
  }
  unint64_t v51 = bytes;
  unint64_t v52 = bytes + 8;
  *CFNumberRef v67 = bswap64(*(void *)bytes);
  v68 = v50;
  bytes = v52;
  if (v50 < 4 || (unint64_t v53 = bswap32(*((_DWORD *)v51 + 2)), v68 = v49 - 12, bytes = v51 + 12, v49 - 12 < v53))
  {
    *(void *)(Instance + 120) = 0LL;
    goto LABEL_76;
  }

  unint64_t v54 = CFDataCreateMutable(v8, 0LL);
  CFDataAppendBytes(v54, bytes, v53);
  unint64_t v55 = v68;
  int v56 = &bytes[v53];
  __int128 v57 = v68 - v53;
  v68 -= v53;
  bytes += v53;
  *(void *)(Instance + 120) = v54;
  if (!v54 || v55 == v53) {
    goto LABEL_76;
  }
  __int128 v58 = *v56;
  bytes = v56 + 1;
  v68 = v57 - 1;
  *(_BYTE *)(Instance + 648) = v58 != 0;
  if (v7 < 4) {
    return Instance;
  }
  if (v57 == 1) {
    goto LABEL_76;
  }
  uint64_t v59 = v56[1];
  bytes = v56 + 2;
  v68 = v57 - 2;
  *(_BYTE *)(Instance + 649) = v59 != 0;
  if (v7 < 5) {
    return Instance;
  }
  if (v57 == 2) {
    goto LABEL_76;
  }
  uint64_t v60 = v56[2];
  bytes = v56 + 3;
  v68 = v57 - 3;
  *(_BYTE *)(Instance + 650) = v60 != 0;
  if (v7 >= 6)
  {
    if ((unint64_t)(v57 - 3) >= 8)
    {
      *(void *)(Instance + 656) = bswap64(*(void *)(v56 + 3));
      v68 = v57 - 11;
      bytes = v56 + 11;
      if (v57 != 11)
      {
        uint64_t v61 = v56[11];
        bytes = v56 + 12;
        v68 = v57 - 12;
        *(_BYTE *)(Instance + 664) = v61 != 0;
        if ((unint64_t)(v57 - 12) >= 8)
        {
          uint64_t v62 = *(void *)(v56 + 12);
          bytes = v56 + 20;
          v68 = v57 - 20;
          if (v57 != 20)
          {
            uint64_t v63 = v56[20];
            v64 = v56 + 21;
            *(_BYTE *)(Instance + 680) = v63 != 0;
            v68 = v57 - 21;
            bytes = v64;
            if (v57 != 21)
            {
              *(_BYTE *)(Instance + 681) = *v64 != 0;
              *(double *)(Instance + 672) = (double)bswap64(v62);
              return Instance;
            }
          }
        }
      }
    }

    goto LABEL_76;
  }

  return Instance;
}

    free(v10);
    return 1LL;
  }

  if (a1)
  {
    CFRetain(a1);
    CFTypeID v15 = CFStringGetLength(a1);
    __int128 v16 = CFStringGetMaximumSizeForEncoding(v15, 0x8000100u) + 1;
    uint64_t v10 = (char *)malloc(v16);
    if (!CFStringGetCString(a1, v10, v16, 0x8000100u)) {
      const void *v10 = 0;
    }
    CFRelease(a1);
  }

  else
  {
    uint64_t v10 = strdup((const char *)&unk_18065A197);
  }

  CFNumberRef v21 = 0LL;
  do
  {
    if (CFStringGetLength(a1) <= v21) {
      break;
    }
    if (CFStringGetLength(a1) <= v21 + 1) {
      goto LABEL_43;
    }
    int v22 = v10[v21];
    uint64_t v23 = v10[++v21];
  }

  while (v22 == v23);
  CFDateRef v24 = 0LL;
  do
  {
    if (CFStringGetLength(a1) <= v24) {
      break;
    }
    if (v24 == CFStringGetLength(a1) - 1) {
      goto LABEL_43;
    }
    CFTypeID v25 = (unsigned __int8 *)&v10[v24];
    BOOL v26 = v10[v24++] + 1;
  }

  while (v26 == (char)v25[1]);
  for (m = 0LL; CFStringGetLength(a1) > m; ++m)
  {
    if (m == CFStringGetLength(a1) - 1) {
      goto LABEL_43;
    }
    if (v10[m + 1] + 1 != v10[m] && (m || v10[m] != 48 || v10[m + 1] != 57)) {
      goto LABEL_78;
    }
  }

        if (a2) {
          *a2 = v26;
        }
        if (a3)
        {
          OSStatus v27 = v12[1].cmd;
          char v28 = bswap32(v27);
          if (v10) {
            OSStatus v27 = v28;
          }
          *a3 = v27;
        }

        if (a4)
        {
          uint64_t v23 = v12[1].cmdsize;
LABEL_51:
          dispatch_queue_t v29 = bswap32(v23);
          if (v10) {
            dispatch_group_t v30 = v29;
          }
          else {
            dispatch_group_t v30 = v23;
          }
          *a4 = v30;
        }

        return 1LL;
      }

    __int128 v14 = a1 + 1;
LABEL_44:
    CFDataRef v5 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v5 + 7) = a4;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( a1,  (uint64_t)v14,  v7,  v5);
    return v5;
  }

    Security::CFRef<__CFData const*>::~CFRef((const void **)&subDirName);
  }

  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v41);
  dispatch_queue_t v29 = *v15;
  dispatch_group_t v30 = (uint64_t **)(a1 + 80);
  dispatch_group_t v31 = (uint64_t **)(a1 + 80);
  if (*v15)
  {
    while (1)
    {
      while (1)
      {
        dispatch_group_t v30 = (uint64_t **)v29;
        unint64_t v32 = v29 + 4;
        dispatch_queue_t v29 = *v30;
        dispatch_group_t v31 = v30;
        if (!*v30) {
          goto LABEL_50;
        }
      }

      dispatch_group_t v31 = v30 + 1;
      dispatch_queue_t v29 = v30[1];
      if (!v29) {
        goto LABEL_50;
      }
    }

    CFTypeID v33 = (char *)v30;
  }

  else
  {
LABEL_50:
    v46.__r_.__value_.__l.__cap_ = 0xAAAAAAAAAAAAAAAALL;
    CFTypeID v33 = (char *)operator new(0x40uLL);
    v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
    v46.__r_.__value_.__l.__size_ = a1 + 80;
    v46.__r_.__value_.__s.__data_[16] = 0;
    BOOL v34 = (std::string *)(v33 + 32);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external(v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }

    else
    {
      *(_OWORD *)&v34->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v33 + 6) = __p.__r_.__value_.__l.__cap_;
    }

    *((void *)v33 + 7) = 0LL;
    v46.__r_.__value_.__s.__data_[16] = 1;
    *(void *)CFTypeID v33 = 0LL;
    *((void *)v33 + 1) = 0LL;
    *((void *)v33 + 2) = v30;
    uint64_t *v31 = (uint64_t *)v33;
    int v35 = **(void **)(a1 + 72);
    int v36 = (uint64_t *)v33;
    if (v35)
    {
      *(void *)(a1 + 72) = v35;
      int v36 = *v31;
    }

    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 80), v36);
    ++*(void *)(a1 + 88);
    v46.__r_.__value_.__r.__words[0] = 0LL;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v46);
  }

  Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v33 + 7, (CFTypeRef *)&theData);
  uint64_t v19 = theData;
  Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
LABEL_58:
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v43);
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v19) {
      goto LABEL_60;
    }
  }

  else if (v19)
  {
LABEL_60:
    int v37 = (Security::CodeSigning::Requirement *)CFDataGetBytePtr(v19);
    return Security::CodeSigning::Requirement::validates(v37, a4, -67050);
  }

  return 0LL;
}

CFTypeID SecTrustGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11961;
  block[4] = &SecTrustGetTypeID_sSecTrustGetTypeIDSingleton;
  if (SecTrustGetTypeID_sSecTrustGetTypeIDOnce != -1) {
    dispatch_once(&SecTrustGetTypeID_sSecTrustGetTypeIDOnce, block);
  }
  return SecTrustGetTypeID_sSecTrustGetTypeIDSingleton;
}

uint64_t SecTrustSetURLRequestAttribution(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  CFDataRef v5 = *(dispatch_queue_s **)(a1 + 136);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = a1;
  dispatch_sync(v5, block);
  CFTypeID v6 = *(dispatch_queue_s **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  v8[2] = __SecTrustSetURLRequestAttribution_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_276;
  unint64_t v8[4] = a1;
  v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0LL;
}

uint64_t __SecTrustSetNeedsEvaluation_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 32) + 112LL) = 0;
  return result;
}

uint64_t __SecTrustSetURLRequestAttribution_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 152LL) = *(void *)(result + 40);
  return result;
}

OSStatus SecTrustSetOCSPResponse(SecTrustRef trust, CFTypeRef responseData)
{
  values = (void *)responseData;
  if (trust)
  {
    uint64_t v4 = MEMORY[0x1895F87A8];
    CFDataRef v5 = (dispatch_queue_s *)*((void *)trust + 17);
    uint64_t block = MEMORY[0x1895F87A8];
    p_uint64_t block = 0x40000000LL;
    uint64_t v26 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    OSStatus v27 = &__block_descriptor_tmp_49_11982;
    SecTrustRef v28 = trust;
    dispatch_sync(v5, &block);
    uint64_t block = 0LL;
    p_uint64_t block = (uint64_t)&block;
    uint64_t v26 = 0x2000000000LL;
    OSStatus v27 = 0LL;
    if (responseData)
    {
      CFTypeID v6 = CFGetTypeID(responseData);
      if (v6 == CFArrayGetTypeID())
      {
        uint64_t Count = CFArrayGetCount((CFArrayRef)responseData);
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
        *(void *)(p_block + 24) = Mutable;
        if (!Mutable)
        {
          OSStatus v15 = -108;
          goto LABEL_25;
        }

        if (Count >= 1)
        {
          for (CFIndex i = 0LL; i != Count; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)responseData, i);
            if (ValueAtIndex && (v11 = ValueAtIndex, CFTypeID v12 = CFGetTypeID(ValueAtIndex), v12 == CFDataGetTypeID()))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v11);
            }

            else
            {
              CFTypeID v13 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: responseData array contains non-data value",  buf,  2u);
              }
            }
          }

          CFMutableArrayRef Mutable = *(const __CFArray **)(p_block + 24);
          uint64_t v4 = MEMORY[0x1895F87A8];
        }

        if (Count != CFArrayGetCount(Mutable))
        {
          __int128 v14 = *(const void **)(p_block + 24);
          if (v14) {
            CFRelease(v14);
          }
LABEL_23:
          OSStatus v15 = -50;
          goto LABEL_25;
        }
      }

      else
      {
        CFTypeID v16 = CFGetTypeID(responseData);
        if (v16 != CFDataGetTypeID())
        {
          uint64_t v19 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( &dword_1804F4000,  v19,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: responseData contains unsupported value type",  buf,  2u);
          }

          goto LABEL_23;
        }

        CFArrayRef v17 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605228]);
        *(void *)(p_block + 24) = v17;
      }
    }

    uint64_t v18 = (dispatch_queue_s *)*((void *)trust + 17);
    v21[0] = v4;
    v21[1] = 0x40000000LL;
    v21[2] = __SecTrustSetOCSPResponse_block_invoke;
    v21[3] = &unk_189674880;
    v21[4] = &block;
    v21[5] = trust;
    dispatch_sync(v18, v21);
    OSStatus v15 = 0;
LABEL_25:
    _Block_object_dispose(&block, 8);
    return v15;
  }

  return -50;
}

void __SecTrustSetOCSPResponse_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFIndex v3 = *(const void **)(v2 + 40);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }

  *(void *)(v2 + 40) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sec_array_append(void *a1, void *a2)
{
  CFTypeID v6 = a1;
  id v3 = a2;
  if (v6)
  {
    if (v6[1])
    {
      uint64_t v4 = MEMORY[0x186E0087C]();
      if (v3)
      {
        if (v4 == MEMORY[0x1895F9220])
        {
          id v5 = v3;
          xpc_array_set_pointer();
        }
      }
    }
  }
}

sec_certificate_t sec_certificate_create(SecCertificateRef certificate)
{
  return (sec_certificate_t)-[SecConcrete_sec_certificate initWithCertificate:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_certificate),  "initWithCertificate:",  certificate);
}

CFTypeRef SecKeyCopySubjectPublicKeyInfo(__SecKey *a1)
{
  CFDataRef v18 = 0LL;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  if (!v18) {
    return 0LL;
  }
  if (!CFDataGetLength(v18))
  {
LABEL_15:
    CFTypeRef v6 = 0LL;
    goto LABEL_22;
  }

  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  CFDataAppendBytes(Mutable, byte_180657740, 1LL);
  BytePtr = CFDataGetBytePtr(v18);
  CFIndex v5 = CFDataGetLength(v18);
  CFDataAppendBytes(Mutable, BytePtr, v5);
  if (v18) {
    CFRelease(v18);
  }
  CFDataRef v18 = Mutable;
  *(void *)&__int128 v17 = CFDataGetBytePtr(Mutable);
  CFTypeRef v6 = 0LL;
  *((void *)&v17 + 1) = CFDataGetLength(v18);
  switch(AlgorithmId)
  {
    case 1LL:
      *(void *)&__int128 v16 = &encodedAlgIdRSA;
      uint64_t v7 = 13LL;
      goto LABEL_19;
    case 3LL:
      int NamedCurve = SecECKeyGetNamedCurve(a1);
      if (NamedCurve == 25)
      {
        uint64_t v10 = &encodedAlgIdECsecp521;
LABEL_18:
        *(void *)&__int128 v16 = v10;
        uint64_t v7 = 16LL;
        goto LABEL_19;
      }

      if (NamedCurve == 24)
      {
        uint64_t v10 = &encodedAlgIdECsecp384;
        goto LABEL_18;
      }

      if (NamedCurve != 23) {
        goto LABEL_15;
      }
      *(void *)&__int128 v16 = &encodedAlgIdECsecp256;
      uint64_t v7 = 19LL;
LABEL_19:
      *((void *)&v16 + 1) = v7;
      CFIndex length = DERLengthOfEncodedSequence( 0x2000000000000010LL,  (unint64_t)&v16,  (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs,  (uint64_t)&DERSubjPubKeyInfoItemSpecs);
      int v11 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], length);
      CFDataSetLength(v11, length);
      MutableBytePtr = CFDataGetMutableBytePtr(v11);
      if (!DEREncodeSequence( 0x2000000000000010LL,  (unint64_t)&v16,  (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs,  (uint64_t)&DERSubjPubKeyInfoItemSpecs,  (unint64_t)MutableBytePtr,  (unint64_t *)&length))
      {
        CFDataSetLength(v11, length);
        CFTypeRef v6 = CFRetain(v11);
        if (!v11) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }

      CFTypeRef v6 = 0LL;
      if (v11) {
LABEL_21:
      }
        CFRelease(v11);
LABEL_22:
      CFDataRef v13 = v18;
      if (v18)
      {
        CFDataRef v18 = 0LL;
        CFRelease(v13);
      }

      return v6;
    case 4LL:
      uint64_t v9 = &encodedAlgIdEd25519;
      goto LABEL_14;
    case 6LL:
      uint64_t v9 = &encodedAlgIdEd448;
LABEL_14:
      *(void *)&__int128 v16 = v9;
      uint64_t v7 = 5LL;
      goto LABEL_19;
    default:
      goto LABEL_22;
  }

uint64_t SecKeyGetAlgorithmId(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    else {
      return 1LL;
    }
  }

  else
  {
    _SECKEY_LOG_9790();
    CFIndex v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFTypeRef v6 = 0;
      _os_log_fault_impl(&dword_1804F4000, v5, OS_LOG_TYPE_FAULT, "Key with NULL class detected!", v6, 2u);
    }

    return 0LL;
  }

uint64_t SecKeyCopyPublicBytes(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v5 = _os_activity_create(&dword_1804F4000, "SecKeyCopyPublicBytes", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  v10.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v10.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &v10);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCopyPublicBytes");
  uint64_t v6 = *(void *)(a1 + 16);
  else {
    uint64_t v8 = 4294967292LL;
  }
  os_activity_scope_leave(&v10);

  objc_autoreleasePoolPop(v4);
  return v8;
}

void sub_180500A30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

uint64_t SecRSAPublicKeyCopyPublicSerialization(const void *a1, __CFData **a2)
{
  id v3 = CFGetAllocator(a1);
  PKCS1 = SecRSAPublicKeyCreatePKCS1(v3);
  *a2 = PKCS1;
  if (PKCS1) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecRSAPublicKeyCreatePKCS1(const __CFAllocator *a1)
{
  unint64_t v2 = ccn_write_int_size();
  unint64_t v3 = ccn_write_int_size();
  unint64_t v4 = DERLengthOfItem(2uLL, v2);
  unint64_t v5 = DERLengthOfItem(2uLL, v3) + v4;
  CFIndex v6 = DERLengthOfItem(0x10uLL, v5);
  CFMutableArrayRef Mutable = CFDataCreateMutable(a1, 0LL);
  CFDataSetLength(Mutable, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  UInt8 *MutableBytePtr = 48;
  uint64_t v9 = MutableBytePtr + 1;
  unint64_t v14 = 4LL;
  DEREncodeLength(v5, (unint64_t)(MutableBytePtr + 1), &v14);
  os_activity_scope_state_s v10 = &v9[v14];
  *v10++ = 2;
  unint64_t v15 = 4LL;
  DEREncodeLength(v2, (unint64_t)v10, &v15);
  int v11 = &v10[v15];
  ccn_write_int();
  CFTypeID v12 = &v11[v2];
  *CFTypeID v12 = 2;
  unint64_t v15 = 4LL;
  DEREncodeLength(v3, (unint64_t)(v12 + 1), &v15);
  ccn_write_int();
  return Mutable;
}

unint64_t DEREncodeLength(unint64_t a1, unint64_t a2, unint64_t *a3)
{
  return DEREncodeLengthSized(a1, a2, *a3, (uint64_t *)a3);
}

uint64_t DERLengthOfEncodedSequence(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  v5[1] = *MEMORY[0x1895F89C0];
  v5[0] = 0LL;
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) < a2) {
    __break(0x5519u);
  }
  else {
    return v5[0];
  }
}

unint64_t DERLengthOfEncodedSequenceFromObject( uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  v17[1] = *MEMORY[0x1895F89C0];
  v17[0] = 0LL;
  unint64_t result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v17);
  if (!(_DWORD)result)
  {
    unint64_t v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    uint64_t v10 = 1LL;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        BOOL v11 = v9 > 0x7F;
        v9 >>= 7;
      }

      while (v11);
    }

    uint64_t v12 = 1LL;
    if (v17[0] >= 0x80uLL)
    {
      unint64_t v13 = v17[0];
      do
      {
        ++v12;
        BOOL v11 = v13 > 0xFF;
        v13 >>= 8;
      }

      while (v11);
    }

    BOOL v14 = __CFADD__(v10, v12);
    uint64_t v15 = v10 + v12;
    if (v14 || (v14 = __CFADD__(v15, v17[0]), uint64_t v16 = v15 + v17[0], v14))
    {
      __break(0x5500u);
    }

    else
    {
      unint64_t result = 0LL;
      *a6 = v16;
    }
  }

  return result;
}

unint64_t DERContentLengthOfEncodedSequence( unint64_t result, unint64_t a2, int a3, uint64_t a4, void *a5)
{
  uint64_t v5 = 0LL;
  if (!a3)
  {
LABEL_38:
    unint64_t result = 0LL;
LABEL_40:
    *a5 = v5;
    return result;
  }

  unsigned int v6 = 0;
  unint64_t v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    unint64_t v8 = *(void *)(a4 + 24LL * v6);
    BOOL v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      uint64_t v5 = 0LL;
      unint64_t result = 7LL;
      goto LABEL_40;
    }

    if (v8 > ~result) {
      break;
    }
    uint64_t v10 = (unsigned __int8 **)(result + v8);
    __int16 v11 = *(_WORD *)(a4 + 24LL * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if ((v11 & 1) != 0)
      {
        if (!v10[1]) {
          goto LABEL_37;
        }
      }

      unint64_t v13 = *(void *)(a4 + 24LL * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      uint64_t v14 = 1LL;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          BOOL v9 = v13 > 0x7F;
          v13 >>= 7;
        }

        while (v9);
      }

      BOOL v15 = __CFADD__(v5, v14);
      uint64_t v16 = v5 + v14;
      if (v15) {
        goto LABEL_42;
      }
      unint64_t v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24LL * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }

LABEL_25:
        uint64_t v18 = 1LL;
      }

      else
      {
LABEL_24:
        if (v17 < 0x80) {
          goto LABEL_25;
        }
        uint64_t v18 = 1LL;
        unint64_t v21 = v17;
        do
        {
          ++v18;
          BOOL v9 = v21 > 0xFF;
          v21 >>= 8;
        }

        while (v9);
      }

      BOOL v15 = __CFADD__(v16, v18);
      uint64_t v22 = v16 + v18;
      if (v15) {
        goto LABEL_42;
      }
      BOOL v15 = __CFADD__(v22, v17);
      uint64_t v5 = v22 + v17;
      if (v15) {
        goto LABEL_42;
      }
      goto LABEL_37;
    }

    CFMutableArrayRef v20 = v10[1];
    BOOL v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15) {
      goto LABEL_42;
    }
LABEL_37:
    if (++v6 == a3) {
      goto LABEL_38;
    }
  }

  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

      unint64_t v3 = a1[++v5];
      if (!v3)
      {
        if (!a2) {
          return v7;
        }
        goto LABEL_29;
      }
    }

    uint64_t v12 = 0LL;
    while (!a2)
    {
      unint64_t v7 = (v7 + 1);
LABEL_22:
      BOOL v15 = &v10[v12++];
      __int16 v11 = v15[1];
      if (!v11) {
        goto LABEL_25;
      }
    }

    unint64_t v13 = PORT_ZAlloc(0x28uLL);
    if (!v13) {
      return 0xFFFFFFFFLL;
    }
    *unint64_t v13 = v5;
    v13[1] = v12;
    if (*(_DWORD *)v11 == 1)
    {
      v13[2] = 1;
      uint64_t v14 = v11 + 8;
    }

    else
    {
      if (*(_DWORD *)v11)
      {
LABEL_21:
        *(void *)(a2 + 8LL * v6++) = v13;
        uint64_t v10 = *(uint64_t **)(v3 + 128);
        goto LABEL_22;
      }

      v13[2] = 0;
      uint64_t v14 = *(void *)(v11 + 8);
    }

    *((void *)v13 + 2) = v14;
    goto LABEL_21;
  }

  unint64_t v7 = 0LL;
  unsigned int v6 = 0;
  if (a2)
  {
LABEL_29:
    unint64_t v7 = 0LL;
    *(void *)(a2 + 8LL * v6) = 0LL;
  }

  return v7;
}

              SecCmsMessageDestroy(v20);
              goto LABEL_26;
            }
          }
        }
      }
    }

  SecCmsMessageDestroy(v3);
  return Mutable;
}

    CFRelease(ArrayBySeparatingStrings);
  }

  else
  {
    unint64_t v8 = 0LL;
    uint64_t v10 = ArrayBySeparatingStrings;
  }

  CFRelease(v10);
  return v8;
}

        appendError(v1, @"One or more certificates is using a weak key size.");
        BOOL v9 = context;
        if ((context & 0x100) == 0)
        {
LABEL_15:
          if ((v9 & 0x200) == 0)
          {
LABEL_29:
            if (!CFArrayGetCount(v1) && v1)
            {
              CFRelease(v1);
              BOOL v1 = 0LL;
            }

            __int16 v11 = (const void *)v16[3];
            if (v11)
            {
              unint64_t v16[3] = 0LL;
              CFRelease(v11);
            }

            goto LABEL_34;
          }

          goto LABEL_27;
        }

uint64_t DEREncodeSequence( uint64_t result, unint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) >= a2) {
    return DEREncodeSequenceFromObject(result, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5, *a6, a6);
  }
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequenceFromObject( uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  v45[1] = *MEMORY[0x1895F89C0];
  unint64_t v8 = ~a6;
  if (~a6 < a7) {
    goto LABEL_73;
  }
  unint64_t v11 = *a8;
  unint64_t v44 = a7;
  v45[0] = 0LL;
  if (v11 < a7) {
    goto LABEL_74;
  }
  uint64_t result = DEREncodeTag(a1, a6, &v44);
  if ((_DWORD)result) {
    return result;
  }
  if (v44 > v8) {
    goto LABEL_73;
  }
  unint64_t v17 = a7 - v44;
  if (a7 < v44) {
    goto LABEL_75;
  }
  unint64_t v18 = a6 + a7;
  unint64_t v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    uint64_t result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v45);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19) {
      goto LABEL_74;
    }
    unint64_t v42 = a6 + v11;
    unint64_t v20 = v45[0];
    uint64_t result = DEREncodeLengthSized(v45[0], v19, v17, (uint64_t *)&v44);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }

    unint64_t v22 = v17 - v44;
    if (v17 >= v44)
    {
      uint64_t v23 = (_BYTE *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if (a4)
        {
          unint64_t v24 = 0LL;
          unint64_t v25 = a2 + a3;
          uint64_t v41 = 24LL * a4;
          while (1)
          {
            if (v24 > ~a5) {
              goto LABEL_73;
            }
            unint64_t v26 = *(void *)(a5 + v24);
            if (v26 > ~a2) {
              goto LABEL_73;
            }
            OSStatus v27 = (const void **)(a2 + v26);
            __int16 v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0) {
              break;
            }
            if ((v28 & 1) == 0) {
              goto LABEL_29;
            }
            if (v27[1])
            {
LABEL_29:
              unint64_t v44 = v22;
              uint64_t result = DEREncodeTag(*(void *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if ((_DWORD)result) {
                return result;
              }
              if (__CFADD__(v23, v44)) {
                goto LABEL_73;
              }
              unint64_t v30 = v22 - v44;
              if (v22 < v44) {
                goto LABEL_75;
              }
              unint64_t v31 = (unint64_t)v27[1];
              v45[0] = v31;
              char v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                char v32 = 0;
                v45[0] = ++v31;
              }

              unint64_t v33 = (unint64_t)&v23[v44];
              unint64_t v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33) {
                goto LABEL_74;
              }
              uint64_t result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if ((_DWORD)result) {
                return result;
              }
              unint64_t v34 = v44;
              if (__CFADD__(v33, v44)) {
                goto LABEL_73;
              }
              unint64_t v35 = v30 - v44;
              if (v30 < v44) {
                goto LABEL_75;
              }
              uint64_t v23 = (_BYTE *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (_BYTE *)-1LL) {
                  goto LABEL_73;
                }
                _BYTE *v23 = 0;
                --v35;
                if (v30 == v34) {
                  goto LABEL_75;
                }
                ++v23;
              }

              size_t v36 = (size_t)v27[1];
              uint64_t result = (uint64_t)memmove(v23, *v27, v36);
              unint64_t v21 = v42;
              unint64_t v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37)) {
                goto LABEL_73;
              }
              unint64_t v22 = v35 - v37;
              if (v35 < v37) {
                goto LABEL_75;
              }
              goto LABEL_69;
            }

LABEL_70:
            v24 += 24LL;
            if (v41 == v24) {
              goto LABEL_71;
            }
          }

          size_t v39 = (size_t)v27[1];
          uint64_t result = (uint64_t)memmove(v23, *v27, v39);
          unint64_t v21 = v42;
          unint64_t v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37)) {
            goto LABEL_73;
          }
          BOOL v40 = v22 >= v37;
          v22 -= v37;
          if (!v40) {
            goto LABEL_75;
          }
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }

          unint64_t v8 = v42;
          BOOL v9 = v44;
LABEL_76:

          unint64_t v33 = 0;
          goto LABEL_77;
        }

        [v12 objectForKeyedSubscript:@"eventType"];
        unint64_t v13 = (id)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          if (a5)
          {
            size_t v36 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:2 description:@"eventType missing"];
            *a5 = v36;
          }

          goto LABEL_70;
        }

        [v12 objectForKeyedSubscript:@"eventClass"];
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v14) {
          goto LABEL_14;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          unint64_t v8 = v42;
          BOOL v9 = v44;
          if (a5)
          {
            [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:2 description:@"eventType not a string"];
            unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
            goto LABEL_74;
          }

    log_error(a4, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0LL;
  }

  unint64_t v26 = *((_DWORD *)v18 + 8);
  OSStatus v27 = *((_DWORD *)v18 + 9);
  __int16 v28 = bswap32(v26);
  if (v6) {
    unint64_t v26 = v28;
  }
  dispatch_queue_t v29 = bswap32(v27);
  if (v6) {
    OSStatus v27 = v29;
  }
  unint64_t v30 = __CFADD__(v26, v27);
  unint64_t v31 = v26 + v27;
  char v32 = a3;
  a4 = v64;
  unint64_t v33 = a1;
  unint64_t v34 = a2;
  unint64_t v35 = v60;
  if (v30 || v31 > a2)
  {
LABEL_71:
    log_error(a4, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
    return 0LL;
  }

    unint64_t v21 = (const std::string *)certificates;
  }

  std::string::operator=((std::string *)((char *)this + 160), v21);
  unint64_t v19 = certificates[23];
LABEL_72:
  if (v19 < 0) {
    operator delete(*(void **)certificates);
  }
  unint64_t v30 = *((void *)this + 1);
  if (*(_BYTE *)(v30 + 249))
  {
LABEL_75:
    v172 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v170 = v31;
    v171 = v31;
    *(_OWORD *)v168 = v31;
    v169 = v31;
    if (*(void *)(v30 + 32))
    {
      char v32 = (char *)operator new(0x38uLL);
      *((_DWORD *)v32 + 2) = 0;
      *(void *)(v32 + 12) = -1LL;
      *((_DWORD *)v32 + 5) = 0;
      *((void *)v32 + 4) = 0LL;
      *((void *)v32 + 3) = v32 + 32;
      *(void *)char v32 = off_189678B40;
      *((void *)v32 + 5) = 0LL;
      *((void *)v32 + 6) = this;
      Security::Mutex::Mutex((pthread_mutex_t *)&v168[2]);
    }

    else
    {
      char v32 = (char *)(*(uint64_t (**)(void))(*(void *)*v126 + 256LL))(*v126);
      Security::Mutex::Mutex((pthread_mutex_t *)&v168[2]);
      if (!v32)
      {
LABEL_87:
        *(void *)v168 = v32;
        if (*(_BYTE *)(*((void *)this + 1) + 300LL)) {
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
        }
        trust = (SecTrustRef)&v144;
        v144 = 0LL;
        v145 = 0LL;
        v146 = 0LL;
        unint64_t v42 = *(void **)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this);
        while (v42 != (void *)((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this)
                                + 8))
        {
          *(void *)&uint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v166 = v43;
          v167 = v43;
          v164 = v43;
          v165 = v43;
          v162 = v43;
          v163 = v43;
          v160 = v43;
          v161 = v43;
          v158 = v43;
          v159 = v43;
          v156 = v43;
          v157 = v43;
          *(_OWORD *)&certificates[16] = v43;
          v155 = v43;
          *(_OWORD *)certificates = v43;
          Security::CodeSigning::CodeDirectory::Builder::Builder( (Security::CodeSigning::CodeDirectory::Builder *)certificates,  (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v42 + 7));
          v139 = 0LL;
          v140 = 0LL;
          v138 = (SecTrustRef)&v139;
          v141 = 0LL;
          (*(void (**)(void, void, Security::CodeSigning::SecCodeSigner::Signer *))(**((void **)this + 3)
                                                                                                 + 208LL))( *((void *)this + 3),  0LL,  this);
          Security::CodeSigning::InternalRequirements::operator()((uint64_t)&v138);
          unint64_t v44 = *(void *)v168;
          if (*((void *)this + 12) && !*(_BYTE *)(*((void *)this + 1) + 250LL))
          {
            (*(void (**)(void, uint64_t, void))(**(void **)v168 + 16LL))( *(void *)v168,  3LL,  *((void *)this + 13));
            unint64_t v44 = *(void *)v168;
          }

          __int128 v45 = (*(uint64_t (**)(void))(*(void *)*v126 + 88LL))(*v126);
          unint64_t v46 = (*(uint64_t (**)(void))(*(void *)*v126 + 96LL))(*v126);
          unint64_t v47 = (*(uint64_t (**)(void, void))(*(void *)*v126 + 104LL))(*v126, 0LL);
          unint64_t v48 = (*(uint64_t (**)(void, void))(*(void *)*v126 + 112LL))(*v126, 0LL);
          (*(void (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this);
          v49 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>( (uint64_t **)this + 29,  *((void *)this + 28),  (uint64_t *)this + 28);
          if ((*((_BYTE *)this + 290) & 1) != 0) {
            unint64_t v50 = *(_DWORD *)(*((void *)this + 1) + 296LL);
          }
          else {
            unint64_t v50 = 0;
          }
          Security::CodeSigning::SecCodeSigner::Signer::populate( (uint64_t)this,  (uint64_t)certificates,  v44,  (uint64_t)&v138,  v45,  v46,  0,  v47,  v48,  (void *)v49 + 5,  v50);
          unint64_t v51 = (const Security::CodeSigning::CodeDirectory *)Security::CodeSigning::CodeDirectory::Builder::build((Security::CodeSigning::CodeDirectory::Builder *)certificates);
          if (!*(_BYTE *)(*((void *)this + 1) + 250LL)) {
            Security::CodeSigning::CodeDirectorySet::add((Security::CodeSigning::CodeDirectorySet *)&trust, v51);
          }
          free(v141);
          Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v138);
          Security::CodeSigning::CodeDirectory::Builder::~Builder((Security::CodeSigning::CodeDirectory::Builder *)certificates);
          unint64_t v52 = (void *)v42[1];
          unint64_t v53 = v42;
          if (v52)
          {
            do
            {
              unint64_t v42 = v52;
              unint64_t v52 = (void *)*v52;
            }

            while (v52);
          }

          else
          {
            do
            {
              unint64_t v42 = (void *)v53[2];
              v66 = *v42 == (void)v53;
              unint64_t v53 = v42;
            }

            while (!v66);
          }
        }

        unint64_t v54 = *((void *)this + 1);
        if (*(void *)(v54 + 32))
        {
          *(void *)certificates = (*(uint64_t (**)(void))(*(void *)*v126 + 32LL))(*v126);
          (*(void (**)(void, uint64_t, void))(**(void **)v168 + 16LL))( *(void *)v168,  65537LL,  *(void *)certificates);
          Security::CFRef<__CFData const*>::~CFRef((const void **)certificates);
          unint64_t v54 = *((void *)this + 1);
        }

        if (!*(_BYTE *)(v54 + 250)) {
          Security::CodeSigning::CodeDirectorySet::populate( (const void **)&trust,  *(Security::CodeSigning::DiskRep::Writer **)v168);
        }
        *(void *)certificates = Security::CodeSigning::CodeDirectorySet::hashDict((Security::CodeSigning::CodeDirectorySet *)&trust);
        int v56 = Security::CodeSigning::CodeDirectorySet::hashList((Security::CodeSigning::CodeDirectorySet *)&trust, v55);
        v138 = v56;
        __int128 v57 = v146;
        if (!v146)
        {
          __int128 v57 = (const Security::CodeSigning::CodeDirectory *)*((void *)trust + 5);
          v146 = v57;
        }

        v137[0] = Security::CodeSigning::SecCodeSigner::Signer::signCodeDirectory( this,  v57,  *(const __CFDictionary **)certificates,  v56);
        (*(void (**)(void, uint64_t, CFTypeRef))(**(void **)v168 + 16LL))( *(void *)v168,  0x10000LL,  v137[0]);
        (*(void (**)(void))(**(void **)v168 + 48LL))(*(void *)v168);
        Security::CFRef<__CFData const*>::~CFRef(v137);
        Security::CFRef<__CFArray const*>::~CFRef((const void **)&v138);
        Security::CFRef<__CFDictionary const*>::~CFRef((const void **)certificates);
        Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&trust);
        __int128 v58 = v168;
        goto LABEL_193;
      }
    }

    BOOL v40 = (unsigned int *)(v32 + 8);
    do
      uint64_t v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    goto LABEL_87;
  }

  v124 = (Security::Universal *)(*(uint64_t (**)(void))(*(void *)*v126 + 80LL))(*v126);
  if (!v124)
  {
    unint64_t v30 = *((void *)this + 1);
    goto LABEL_75;
  }

  *(void *)&v157 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v155 = v33;
  v156 = v33;
  *(_OWORD *)certificates = v33;
  *(_OWORD *)&certificates[16] = v33;
  unint64_t v34 = (unsigned int *)(*(uint64_t (**)(void))(*(void *)*v126 + 256LL))(*v126);
  Security::Mutex::Mutex((pthread_mutex_t *)&certificates[8]);
  if (v34)
  {
    unint64_t v35 = v34 + 2;
    do
      size_t v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }

  *(void *)certificates = v34;
  unint64_t v37 = *((void *)this + 1);
  if (*(_BYTE *)(v37 + 300)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
  }
  if (*(void *)(v37 + 32))
  {
    int v38 = operator new(0x68uLL);
    size_t v39 = (void *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v168, v39);
    Security::CodeSigning::ArchEditor::ArchEditor((uint64_t)v38, v124, v168, 0);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)&v168[2]);
    OSStatus *v38 = off_189677CD8;
    v38[8] = 0LL;
    v38[6] = this;
    v38[7] = v38 + 8;
    v38[12] = 0LL;
    v38[11] = 0LL;
    v38[9] = 0LL;
    v38[10] = v38 + 11;
  }

  else
  {
    int v38 = operator new(0xD8uLL);
    uint64_t v59 = (void *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)buf, v59);
    (*(void (**)(void **__return_ptr))(*(void *)*v126 + 40LL))(v151);
    Security::CodeSigning::MachOEditor::MachOEditor((uint64_t)v38, v34, v124, buf, (__int128 *)v151);
    if (v152 < 0) {
      operator delete(v151[0]);
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)buf[1]);
  }

  if ((*((_BYTE *)v38 + 20) & 2) == 0 && *((void *)this + 12) && !*(_BYTE *)(*((void *)this + 1) + 250LL)) {
    (*(void (**)(void *, uint64_t, void))(*v38 + 16LL))(v38, 3LL, *((void *)this + 13));
  }
  uint64_t v60 = (void *)v38[3];
  v125 = v38 + 4;
  uint64_t v61 = v38;
  if (v60 != v38 + 4)
  {
    v127 = (uint64_t **)((char *)this + 264);
    do
    {
      uint64_t v62 = v60[5];
      uint64_t v63 = Security::Universal::architecture( v124,  (const Security::Architecture *)*((unsigned int *)v60 + 8),  *((_DWORD *)v60 + 9));
      v64 = *(void *)(v62 + 56);
      *(void *)(v62 + 56) = v63;
      if (v64) {
        (*(void (**)(uint64_t))(*(void *)v64 + 8LL))(v64);
      }
      v65 = (uint64_t *)(v62 + 48);
      v66 = *(_DWORD *)(v62 + 48) != 7 || (*((_DWORD *)this + 72) & 0x2000) == 0;
      if (!v66) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA37LL);
      }
      CFNumberRef v67 = *(void *)(v62 + 56);
      v68 = *(_DWORD *)(*(void *)(v67 + 8) + 12LL);
      v69 = bswap32(v68);
      if (*(_BYTE *)(v67 + 33)) {
        v68 = v69;
      }
      CFNumberRef v70 = v68 == 2;
      if ((*((_DWORD *)this + 72) & 0x10000) != 0)
      {
        v71 = *(_DWORD *)(*((void *)this + 1) + 296LL);
        if (!v71)
        {
          v168[0] = -1431655766;
          else {
            v71 = 0;
          }
        }
      }

      else
      {
        v71 = 0;
      }

      (*(void (**)(void, uint64_t, Security::CodeSigning::SecCodeSigner::Signer *))(**((void **)this + 3)
                                                                                              + 208LL))( *((void *)this + 3),  v62 + 48,  this);
      Security::CodeSigning::InternalRequirements::operator()(v62 + 88);
      if ((*((_BYTE *)v38 + 20) & 2) != 0 && *((void *)this + 12) && !*(_BYTE *)(*((void *)this + 1) + 250LL)) {
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v62 + 16LL))(v62, 3LL, *((void *)this + 13));
      }
      v72 = *(void **)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this
                                                                                                  + 24LL))(this);
      while (v72 != (void *)((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)this + 24LL))(this)
                              + 8))
      {
        v74 = v71;
        if ((*((_BYTE *)this + 290) & 1) == 0) {
          goto LABEL_155;
        }
        BOOL v75 = (uint64_t *)*((void *)this + 34);
        v74 = v71;
        if (!v75) {
          goto LABEL_155;
        }
        v76 = *v65;
        v77 = HIDWORD(*v65);
        while (1)
        {
          v78 = *((_DWORD *)v75 + 8);
          id v79 = *((_DWORD *)v75 + 9);
          id v80 = (int)v77 < v79;
          if ((_DWORD)v76 != v78) {
            id v80 = (int)v76 < v78;
          }
          if (v80) {
            goto LABEL_153;
          }
          v81 = v79 < (int)v77;
          v82 = (_DWORD)v76 == v78 ? v81 : v78 < (int)v76;
          if (v82 != 1) {
            break;
          }
          ++v75;
LABEL_153:
          BOOL v75 = (uint64_t *)*v75;
          if (!v75)
          {
LABEL_154:
            v74 = v71;
            goto LABEL_155;
          }
        }

        v85 = (uint64_t *)*((void *)std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>( v127,  v76,  (uint64_t *)(v62 + 48))
                         + 6);
        v74 = v71;
        if (v85)
        {
          v86 = *((_DWORD *)v72 + 7);
          while (1)
          {
            v87 = *((_DWORD *)v85 + 7);
            if (v86 >= v87)
            {
              if (v87 >= v86)
              {
                v88 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>( v127,  *v65,  (uint64_t *)(v62 + 48));
                v74 = *((_DWORD *)std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t **)v88 + 5,  *((_DWORD *)v72 + 7),  (_DWORD *)v72 + 7)
                      + 8);
                break;
              }

              ++v85;
            }

            v85 = (uint64_t *)*v85;
            if (!v85) {
              goto LABEL_154;
            }
          }
        }

    ++v31;
    v34 += 2LL;
  }

  while (v33 != v31);
  unint64_t v54 = HIDWORD(v74);
  free(v17);
  unint64_t v21 = (uint64_t *)v75;
  if (v54)
  {
    unint64_t v22 = 0LL;
    *((_DWORD *)v75 + 1) = bswap32(HIDWORD(v76));
    BOOL v75 = 0LL;
  }

  else
  {
    unint64_t v22 = v75;
    unint64_t v21 = 0LL;
  }

LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          uint64_t result = 0LL;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }

  __break(0x5519u);
  return result;
}

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)(v48 + 40),  (uint64_t)v54,  v52,  (uint64_t *)v51);
  *(void *)buf = 0LL;
  std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
  std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>( (uint64_t *)(*(void *)(a1[5] + 8LL) + 40LL),  BytePtr[37],  BytePtr[37]);
  if (!a2) {
    Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(*(void *)(a1[6] + 8LL) + 40LL), (CFTypeRef *)&v58[1]);
  }
LABEL_73:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v58[1]);
  return v5 != 0LL;
}

        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)(a2 + 200),  (uint64_t)v46,  v47,  (uint64_t *)v106[0]);
        v106[0] = 0LL;
        std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v106);
        unint64_t v48 = v34[1];
        if (v48)
        {
          do
          {
            v49 = (uint64_t **)v48;
            unint64_t v48 = (uint64_t *)*v48;
          }

          while (v48);
        }

        else
        {
          do
          {
            v49 = (uint64_t **)v34[2];
            unint64_t v26 = *v49 == (uint64_t *)v34;
            unint64_t v34 = v49;
          }

          while (!v26);
        }

        unint64_t v34 = v49;
      }

      while (v49 != &v99);
    }
  }

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy((const void **)v99);
  *(_DWORD *)(a2 + 224) = a11;
  unint64_t v50 = (Security::CodeSigning::SecCodeSigner::Signer *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 24LL))( *(void *)(a1 + 24),  1LL);
  v106[0] = v50;
  if (v50) {
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  1u,  v50);
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  unint64_t v51 = *(void *)(v95 + 24);
  if (v51)
  {
    v106[0] = CFDataCreate(0LL, (const UInt8 *)v51, bswap32(*(_DWORD *)(v51 + 4)));
    (*(void (**)(uint64_t, uint64_t, Security::CodeSigning::SecCodeSigner::Signer *))(*(void *)a3 + 16LL))( a3,  2LL,  v106[0]);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  2u,  v106[0]);
    Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  }

  if (*(void *)(a1 + 96)) {
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  3u,  *(const __CFData **)(a1 + 104));
  }
  unint64_t v52 = *(const __CFData ***)(a1 + 192);
  unint64_t v53 = *(const __CFData ***)(a1 + 200);
  if (v52 != v53)
  {
    unint64_t v54 = 8LL;
    do
    {
      if (*v52)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a3 + 16LL))(a3, v54);
        Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  v54,  *v52);
      }

      unint64_t v54 = (v54 + 1);
      ++v52;
    }

    while (v52 != v53);
  }

  if (*(void *)(a1 + 216))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a3 + 16LL))(a3, 11LL);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  0xBu,  *(const __CFData **)(a1 + 216));
  }

  if (*(void *)(a1 + 184) && ((v96 & 1) != 0 || *(_BYTE *)(*(void *)(a1 + 8) + 72LL)))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a3 + 16LL))(a3, 5LL);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  5u,  *(const __CFData **)(a1 + 184));
    unint64_t v55 = *(const __CFData **)(a1 + 184);
    uint64_t v97 = 0LL;
    if (v55)
    {
      BytePtr = (unsigned int *)CFDataGetBytePtr(v55);
      if (BytePtr)
      {
        CFIndex Length = CFDataGetLength(v55);
        if (Length >= 8)
        {
          if (*BytePtr == 1903288058 && (__int128 v58 = bswap32(BytePtr[1]), v58 > 7))
          {
            if (Length == v58)
            {
              v106[0] = (Security::CodeSigning::SecCodeSigner::Signer *)0xAAAAAAAAAAAAAAAALL;
              uint64_t v59 = (Security::CodeSigning::SecCodeSigner::Signer *)Security::CodeSigning::EntitlementBlob::entitlements((Security::CodeSigning::EntitlementBlob *)BytePtr);
              __int128 v105 = 0LL;
              v106[0] = v59;
              CFTypeRef cf = 0LL;
              if (CESerializeCFDictionary() == *MEMORY[0x1896135D8])
              {
                uint64_t v60 = (const __CFData *)cf;
                CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
                uint64_t v62 = CFDataGetLength(v60);
                CFDataSetLength(Mutable, v62 + 8);
                if (Mutable)
                {
                  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
                  v64 = CFDataGetLength(v60);
                  *(_DWORD *)MutableBytePtr = 1920065274;
                  *((_DWORD *)MutableBytePtr + 1) = bswap32(v64 + 8);
                  v65 = CFDataGetBytePtr(v60);
                  v66 = CFDataGetLength(v60);
                  memcpy(MutableBytePtr + 8, v65, v66);
                  uint64_t v97 = Mutable;
                  CFRelease(cf);
                  Security::CFRef<__CFError *>::~CFRef(&v105);
                  v68 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"get-task-allow",  v67);
                  CFNumberRef v70 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"run-unsigned-code",  v69);
                  v72 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"com.apple.private.cs.debugger",  v71);
                  v74 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"dynamic-codesigning",  v73);
                  v76 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"com.apple.private.skip-library-validation",  v75);
                  v78 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"com.apple.private.amfi.can-load-cdhash",  v77);
                  id v80 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement( v106[0],  (const __CFDictionary *)@"com.apple.private.amfi.can-execute-cdhash",  v79);
                  v81 = 16LL;
                  if (!(v68 | v70)) {
                    v81 = 0LL;
                  }
                  v82 = 32LL;
                  if (!v72) {
                    v82 = 0LL;
                  }
                  v83 = 64LL;
                  if (!v74) {
                    v83 = 0LL;
                  }
                  v84 = v82 | v83 | v81;
                  v85 = 128LL;
                  if (!v76) {
                    v85 = 0LL;
                  }
                  v86 = 256LL;
                  if (!v78) {
                    v86 = 0LL;
                  }
                  v87 = v85 | v86;
                  v88 = 512LL;
                  if (!v80) {
                    v88 = 0LL;
                  }
                  id v89 = v84 | v87 | v88;
                  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v106);
                  v90 = v97;
                  goto LABEL_115;
                }

                v93 = 4294967188LL;
              }

              else
              {
                v93 = 4294900302LL;
                v94 = (os_log_s *)secLogObjForScope("SecError");
                if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( &dword_1804F4000,  v94,  OS_LOG_TYPE_DEFAULT,  "Serializing DER entitlements failed",  buf,  2u);
                }
              }

              Security::MacOSError::throwMe((Security::MacOSError *)v93);
            }
          }

          else
          {
            *__error() = 22;
          }
        }
      }

      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA4ELL);
    }

    v90 = 0LL;
    id v89 = 0LL;
LABEL_115:
    (*(void (**)(uint64_t, uint64_t, __CFData *))(*(void *)a3 + 16LL))(a3, 7LL, v90);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  7u,  v97);
    *(void *)(a2 + 184) |= v89;
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v97);
  }

  v91 = (Security::CodeSigning::SecCodeSigner::Signer *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 24LL))( *(void *)(a1 + 24),  6LL);
  v106[0] = v91;
  if (v91) {
    Security::CodeSigning::CodeDirectory::Builder::specialSlot( (Security::CodeSigning::CodeDirectory::Builder *)a2,  6u,  v91);
  }
  Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 32LL))(a3, a2);
}

LABEL_75:
    __break(0x5515u);
    return result;
  }

  return 7LL;
}

          goto LABEL_76;
        }

        if ([v14 isEqual:@"all"])
        {
          BOOL v15 = 0;
          uint64_t v16 = 1LL;
          goto LABEL_15;
        }

        if (([v14 isEqual:@"errors"] & 1) == 0)
        {
          if ([v14 isEqual:@"success"])
          {
            BOOL v15 = 0;
            uint64_t v16 = 10LL;
          }

          else if ([v14 isEqual:@"hardfail"])
          {
            BOOL v15 = 0;
            uint64_t v16 = 11LL;
          }

          else if ([v14 isEqual:@"softfail"])
          {
            BOOL v15 = 0;
            uint64_t v16 = 12LL;
          }

          else if ([v14 isEqual:@"note"])
          {
            BOOL v15 = 0;
            uint64_t v16 = 13LL;
          }

          else
          {
            if (([v14 isEqual:@"rockwell"] & 1) == 0)
            {
              unint64_t v8 = v42;
              BOOL v9 = v44;
              if (a5)
              {
                BOOL v40 = (void *)MEMORY[0x189607870];
                [NSString stringWithFormat:@"unknown eventclass: %@", v14];
                uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
                [v40 errorWithDomain:@"com.apple.SFAErrorDomain" code:2 description:v41];
                unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();

                uint64_t v10 = v48;
LABEL_74:
                int v38 = v37;
                *a5 = v38;
              }

              goto LABEL_75;
            }

            BOOL v15 = 0;
            uint64_t v16 = 14LL;
          }
        }

        else
        {
LABEL_14:
          uint64_t v16 = 0LL;
          BOOL v15 = 1;
        }

  v69 = a2[1];
  CFNumberRef v70 = (unint64_t)a2[2];
  if ((unint64_t)v69 >= v70)
  {
    v72 = (v69 - *a2) >> 5;
    CFNumberRef v73 = v72 + 1;
    v74 = v70 - (void)*a2;
    if (v74 >> 4 > v73) {
      CFNumberRef v73 = v74 >> 4;
    }
    else {
      BOOL v75 = v73;
    }
    if (v75) {
      BOOL v75 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v75);
    }
    else {
      v76 = 0LL;
    }
    v77 = (void *)(v75 + 32 * v72);
    v78 = v75 + 32 * v76;
    *v77 = 8LL;
    v77[1] = 0LL;
    v77[2] = 0LL;
    v77[3] = 0LL;
    v71 = (char *)(v77 + 4);
    id v80 = *a2;
    id v79 = a2[1];
    if (v79 != *a2)
    {
      do
      {
        v81 = *((_OWORD *)v79 - 1);
        *((_OWORD *)v77 - 2) = *((_OWORD *)v79 - 2);
        *((_OWORD *)v77 - 1) = v81;
        v77 -= 4;
        v79 -= 32;
      }

      while (v79 != v80);
      id v79 = *a2;
    }

    *a2 = (char *)v77;
    a2[1] = v71;
    a2[2] = (char *)v78;
    if (v79) {
      operator delete(v79);
    }
  }

  else
  {
    *(void *)v69 = 8LL;
    *((void *)v69 + 1) = 0LL;
    *((void *)v69 + 2) = 0LL;
    *((void *)v69 + 3) = 0LL;
    v71 = v69 + 32;
  }

  a2[1] = v71;
  unint64_t v55 = *MEMORY[0x1896135D8];
LABEL_96:

  return v55;
}

    size_t v39 = *(const __CFArray **)(v9 + 144);
    if (v39)
    {
      uint64_t v5 = CFArrayGetCount(v39) + v68;
      unint64_t v2 = v66;
    }

    else
    {
      unint64_t v2 = v66;
      uint64_t v5 = v68;
    }

    unint64_t v4 = v67 + 1;
    unsigned int v6 = *(int8x16_t **)(a1 + 160);
    if (v6) {
      goto LABEL_8;
    }
LABEL_12:
    LODWORD(v7) = 0;
  }

  uint64_t v41 = *(const __CFArray **)(a1 + 176);
  if (v41) {
    v5 += CFArrayGetCount(v41);
  }
  if ((unint64_t)(v5 - 0xFFFFFFFFFFFFFFELL) <= 0xF000000000000002LL)
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 144) = 0LL;
    return result;
  }

  unint64_t v46 = PORT_ArenaAlloc(v2, 8 * v5 + 8);
  *(void *)(a1 + 144) = v46;
  if (v46)
  {
    if (v65 && (unint64_t v47 = v65->i64[0]) != 0)
    {
      unint64_t v48 = 0LL;
      v49 = 0;
      do
      {
        for (CFIndex i = 0LL; CFArrayGetCount(*(CFArrayRef *)(v47 + 144)) > i; ++i)
        {
          unint64_t v51 = (void *)PORT_ArenaAlloc(v2, 0x10uLL);
          if (v51)
          {
            void *v51 = 0LL;
            v51[1] = 0LL;
          }

          *(void *)(*(void *)(a1 + 144) + 8LL * v49) = v51;
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v47 + 144), i);
          unint64_t v53 = ValueAtIndex[3];
          if ((v53 & 0x8000000000000000LL) == 0)
          {
            unint64_t v54 = v49;
            unint64_t v55 = ValueAtIndex[2];
            ++v49;
            int v56 = *(void **)(*(void *)(a1 + 144) + 8 * v54);
            *int v56 = v53;
            v56[1] = v55;
          }
        }

        unint64_t v47 = v65->i64[++v48];
      }

      while (v47);
    }

    else
    {
      v49 = 0;
    }

    __int128 v57 = *(const __CFArray **)(a1 + 176);
    if (v57)
    {
      for (CFIndex j = 0LL; CFArrayGetCount(v57) > j; ++j)
      {
        uint64_t v59 = (void *)PORT_ArenaAlloc(v2, 0x10uLL);
        if (v59)
        {
          *uint64_t v59 = 0LL;
          v59[1] = 0LL;
        }

        *(void *)(*(void *)(a1 + 144) + 8LL * v49) = v59;
        uint64_t v60 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), j);
        uint64_t v61 = v60[3];
        if ((v61 & 0x8000000000000000LL) == 0)
        {
          uint64_t v62 = v49;
          uint64_t v63 = v60[2];
          ++v49;
          v64 = *(void **)(*(void *)(a1 + 144) + 8 * v62);
          void *v64 = v61;
          v64[1] = v63;
        }

        __int128 v57 = *(const __CFArray **)(a1 + 176);
      }
    }

    *(void *)(*(void *)(a1 + 144) + 8LL * v49) = 0LL;
    SecCmsArraySort(*(void **)(a1 + 144), 0LL, 0LL);
    return 0LL;
  }

  return 0xFFFFFFFFLL;
}

sec_trust_t sec_trust_create(SecTrustRef trust)
{
  return (sec_trust_t)-[SecConcrete_sec_trust initWithTrust:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_trust),  "initWithTrust:",  trust);
}

void *__cdecl sec_retain(void *obj)
{
  if (obj) {
    return os_retain(obj);
  }
  return obj;
}

SecTrustRef sec_trust_copy_ref(sec_trust_t trust)
{
  else {
    return 0LL;
  }
}

void *SecPolicyCreateSSLWithATSPinning(int a1, const __CFString *a2, const __CFDictionary *a3)
{
  return SecPolicyCreateSSL_internal(a1, a2, 0, a3);
}

OSStatus SecTrustSetPolicies(SecTrustRef trust, CFTypeRef policies)
{
  values = (void *)policies;
  OSStatus v2 = -50;
  if (trust && policies)
  {
    uint64_t v5 = MEMORY[0x1895F87A8];
    unsigned int v6 = (dispatch_queue_s *)*((void *)trust + 17);
    uint64_t block = MEMORY[0x1895F87A8];
    p_uint64_t block = 0x40000000LL;
    uint64_t v27 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    __int16 v28 = &__block_descriptor_tmp_49_11982;
    SecTrustRef v29 = trust;
    dispatch_sync(v6, &block);
    uint64_t block = 0LL;
    p_uint64_t block = (uint64_t)&block;
    uint64_t v27 = 0x2000000000LL;
    __int16 v28 = 0LL;
    CFTypeID v7 = CFGetTypeID(policies);
    if (v7 == CFArrayGetTypeID())
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)policies);
      if (Count < 1)
      {
LABEL_21:
        OSStatus v2 = -50;
        goto LABEL_22;
      }

      uint64_t v9 = Count;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
      *(void *)(p_block + 24) = Mutable;
      if (!Mutable)
      {
        OSStatus v2 = -108;
        goto LABEL_22;
      }

      for (CFIndex i = 0LL; i != v9; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)policies, i);
        if (ValueAtIndex && (unint64_t v13 = ValueAtIndex, v14 = CFGetTypeID(ValueAtIndex), v14 == SecPolicyGetTypeID()))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v13);
        }

        else
        {
          BOOL v15 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( &dword_1804F4000,  v15,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: newPolicies array contains non-policy value",  buf,  2u);
          }
        }
      }

      if (v9 != CFArrayGetCount(*(CFArrayRef *)(p_block + 24)))
      {
        uint64_t v16 = *(const void **)(p_block + 24);
        if (v16) {
          CFRelease(v16);
        }
        goto LABEL_21;
      }
    }

    else
    {
      CFTypeID v17 = CFGetTypeID(policies);
      if (v17 != SecPolicyGetTypeID())
      {
        unint64_t v20 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( &dword_1804F4000,  v20,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: newPolicies contains unsupported value type",  buf,  2u);
        }

        goto LABEL_21;
      }

      CFArrayRef v18 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605228]);
      *(void *)(p_block + 24) = v18;
    }

    unint64_t v19 = (dispatch_queue_s *)*((void *)trust + 17);
    v22[0] = v5;
    v22[1] = 0x40000000LL;
    uint64_t v22[2] = __SecTrustSetPolicies_block_invoke;
    v22[3] = &unk_189674908;
    v22[4] = &block;
    v22[5] = trust;
    dispatch_sync(v19, v22);
    OSStatus v2 = 0;
LABEL_22:
    _Block_object_dispose(&block, 8);
  }

  return v2;
}

void __SecTrustSetPolicies_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(const void **)(v2 + 32);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }

  *(void *)(v2 + 32) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void SecPolicyDestroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

__CFData *SecTrustSerialize(uint64_t a1, __CFString **a2)
{
  if (!a1)
  {
    SecError(-50, a2, @"null trust input");
    return 0LL;
  }

  uint64_t v16 = 0LL;
  CFTypeID v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  v17[3] = (uint64_t)Mutable;
  uint64_t v5 = *(dispatch_queue_s **)(a1 + 136);
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 0x40000000LL;
  v15[2] = __SecTrustCopyPlist_block_invoke;
  void v15[3] = &unk_189675CE8;
  v15[4] = &v16;
  v15[5] = a1;
  dispatch_sync(v5, v15);
  unsigned int v6 = (const __CFString *)v17[3];
  _Block_object_dispose(&v16, 8);
  if (!v6)
  {
    SecError(-26275, a2, @"unable to create trust plist");
    return 0LL;
  }

  DERData = CFPropertyListCreateDERData(v7, v6, (CFTypeRef *)a2, v8, v9, v10, v11, v12);
  CFRelease(v6);
  return DERData;
}

void __SecTrustCopyPlist_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(a1 + 40) + 16LL);
  if (v2)
  {
    CFMutableArrayRef v3 = SecCertificateArraySerialize(v2);
    if (v3)
    {
      CFMutableArrayRef v4 = v3;
      CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"certificates",  v3);
      CFRelease(v4);
    }
  }

  uint64_t v5 = *(const void **)(*(void *)(a1 + 40) + 24LL);
  if (v5)
  {
    CFMutableArrayRef v6 = SecCertificateArraySerialize(v5);
    if (v6)
    {
      CFMutableArrayRef v7 = v6;
      CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"anchors",  v6);
      CFRelease(v7);
    }
  }

  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(const __CFArray **)(v8 + 32);
  if (v9)
  {
    CFTypeID v10 = CFGetTypeID(*(CFTypeRef *)(v8 + 32));
    if (v10 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount(v9);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
      v31.location = 0LL;
      v31.CFIndex length = Count;
      CFArrayApplyFunction(v9, v31, (CFArrayApplierFunction)serializePolicy, Mutable);
      if (Mutable)
      {
        CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"policies",  Mutable);
        CFRelease(Mutable);
      }
    }
  }

  unint64_t v13 = *(void **)(a1 + 40);
  CFTypeID v14 = (const void *)v13[5];
  if (v14)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"responses",  v14);
    unint64_t v13 = *(void **)(a1 + 40);
  }

  BOOL v15 = (const void *)v13[6];
  if (v15)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"scts",  v15);
    unint64_t v13 = *(void **)(a1 + 40);
  }

  uint64_t v16 = (const void *)v13[7];
  if (v16)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"trustedLogs",  v16);
    unint64_t v13 = *(void **)(a1 + 40);
  }

  CFTypeID v17 = (const void *)v13[8];
  if (v17)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"verifyDate",  v17);
    unint64_t v13 = *(void **)(a1 + 40);
  }

  uint64_t v18 = (const void *)v13[9];
  if (v18)
  {
    CFMutableArrayRef v19 = SecCertificateArraySerialize(v18);
    if (v19)
    {
      CFMutableArrayRef v20 = v19;
      CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"chain",  v19);
      CFRelease(v20);
    }
  }

  unint64_t v21 = *(void **)(a1 + 40);
  unint64_t v22 = (const void *)v21[11];
  if (v22)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"details",  v22);
    unint64_t v21 = *(void **)(a1 + 40);
  }

  uint64_t v23 = (const void *)v21[12];
  if (v23)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"info",  v23);
    unint64_t v21 = *(void **)(a1 + 40);
  }

  unint64_t v24 = (const void *)v21[13];
  if (v24)
  {
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"exceptions",  v24);
    unint64_t v21 = *(void **)(a1 + 40);
  }

  CFNumberRef v25 = CFNumberCreate(0LL, kCFNumberSInt32Type, v21 + 14);
  if (v25)
  {
    CFNumberRef v26 = v25;
    CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"result",  v25);
    CFRelease(v26);
  }

  uint64_t v27 = (const void *)*MEMORY[0x189604DE0];
  __int16 v28 = (const void *)*MEMORY[0x189604DE8];
  if (*(_BYTE *)(*(void *)(a1 + 40) + 116LL)) {
    SecTrustRef v29 = (const void *)*MEMORY[0x189604DE8];
  }
  else {
    SecTrustRef v29 = (const void *)*MEMORY[0x189604DE0];
  }
  CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"anchorsOnly",  v29);
  if (*(_BYTE *)(*(void *)(a1 + 40) + 117LL)) {
    unint64_t v30 = v28;
  }
  else {
    unint64_t v30 = v27;
  }
  CFDictionaryAddValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"keychainsAllowed",  v30);
}

CFMutableArrayRef SecCertificateArraySerialize(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID()) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
  v6.location = 0LL;
  v6.CFIndex length = Count;
  CFArrayApplyFunction((CFArrayRef)a1, v6, (CFArrayApplierFunction)serializeCertificate, Mutable);
  return Mutable;
}

void serializeCertificate(__SecCertificate *a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID TypeID = SecCertificateGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      CFDataRef v5 = SecCertificateCopyData(a1);
      if (v5)
      {
        CFDataRef v6 = v5;
        CFArrayAppendValue(a2, v5);
        CFRelease(v6);
      }
    }
  }

CFDataRef SecCertificateCopyData(CFDataRef certificate)
{
  if (certificate)
  {
    CFDataRef v1 = certificate;
    CFTypeID v2 = (const void *)*((void *)certificate + 69);
    if (v2)
    {
      CFRetain(v2);
      return (CFDataRef)*((void *)v1 + 69);
    }

    else
    {
      CFMutableArrayRef v3 = CFGetAllocator(v1);
      return CFDataCreate(v3, *((const UInt8 **)v1 + 2), *((void *)v1 + 3));
    }
  }

  return certificate;
}

void serializePolicy(uint64_t a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID TypeID = SecPolicyGetTypeID();
    if (TypeID == CFGetTypeID((CFTypeRef)a1))
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 3LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      CFDictionaryAddValue(Mutable, @"SecPolicyOid", *(const void **)(a1 + 16));
      CFDictionaryAddValue(Mutable, @"policyOptions", *(const void **)(a1 + 32));
      CFDataRef v6 = *(const void **)(a1 + 24);
      if (v6) {
        CFDictionaryAddValue(Mutable, @"SecPolicyPolicyName", v6);
      }
      if (Mutable)
      {
        CFArrayAppendValue(a2, Mutable);
        CFRelease(Mutable);
      }
    }
  }

__CFData *CFPropertyListCreateDERData( uint64_t a1, const __CFString *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v10 = der_sizeof_plist(a2, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, v10);
  CFDataSetLength(Mutable, v10);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair(a2, a3, 0LL, MutableBytePtr, (unint64_t)&MutableBytePtr[v10], v13, v14, v15)
    && Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t der_sizeof_number(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    if ((HIBYTE(valuePtr) + 1) <= 1u)
    {
      uint64_t v6 = 9LL;
      uint64_t v7 = 48LL;
      do
      {
        uint64_t v8 = valuePtr >> v7;
        --v6;
        v7 -= 8LL;
      }

      while (HIBYTE(valuePtr) == v8);
    }

    return ccder_sizeof();
  }

  else
  {
    SecCFCreateErrorWithFormat( -4LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v3,  @"Unable to get number from data",  v4,  v5,  v10);
    return 0LL;
  }

uint64_t der_sizeof_date()
{
  return ccder_sizeof();
}

uint64_t der_encode_data(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v7 = ccder_encode_tl();
  if (!v7) {
    SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v4,  @"ccder failed to encode",  v5,  v6,  v9);
  }
  return v7;
}

uint64_t der_encode_number(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    uint64_t v16 = (const __CFString *)sSecDERErrorDomain;
    CFTypeID v17 = @"Unable to get number from data";
    CFIndex v18 = -4LL;
LABEL_23:
    SecCFCreateErrorWithFormat(v18, v16, 0LL, a2, v7, v17, v8, v9, v22);
    return 0LL;
  }

  uint64_t v10 = valuePtr;
  unint64_t v11 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    unint64_t v19 = 8LL;
    if (!a4) {
      goto LABEL_22;
    }
  }

  else
  {
    uint64_t v12 = 9LL;
    uint64_t v13 = 48LL;
    uint64_t v14 = 1LL;
    while ((unint64_t)(v12 - 2) >= 2)
    {
      uint64_t v15 = valuePtr >> v13;
      --v12;
      v13 -= 8LL;
      if ((_DWORD)v11 != v15)
      {
        uint64_t v14 = v12 - 1;
        goto LABEL_11;
      }
    }

    uint64_t v12 = 2LL;
LABEL_11:
    else {
      unint64_t v19 = v14;
    }
    if (!a4) {
      goto LABEL_22;
    }
  }

  if (a4 - a3 < (uint64_t)v19)
  {
LABEL_22:
    uint64_t v16 = (const __CFString *)sSecDERErrorDomain;
    CFTypeID v17 = @"Unknown size";
    CFIndex v18 = -3LL;
    goto LABEL_23;
  }

  if (v19 <= 1) {
    uint64_t v20 = 1LL;
  }
  else {
    uint64_t v20 = v19;
  }
  do
  {
    *(_BYTE *)--a4 = v10;
    v10 >>= 8;
    --v20;
  }

  while (v20);
  uint64_t valuePtr = v10;
  uint64_t result = ccder_encode_tl();
  if (!result)
  {
    uint64_t v16 = (const __CFString *)sSecDERErrorDomain;
    CFTypeID v17 = @"ccder failed to encode";
    CFIndex v18 = -7LL;
    goto LABEL_23;
  }

  return result;
}

unint64_t der_encode_generalizedtime_body_repair( CFTypeRef *a1, int a2, uint64_t a3, unint64_t a4, double a5)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  uint64_t v48 = 0LL;
  uint64_t v49 = 0LL;
  uint64_t v47 = 0LL;
  CFErrorRef err = 0LL;
  p_CFErrorRef err = &err;
  uint64_t v52 = 0x2000000000LL;
  char v53 = -86;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&uint8_t buf[8] = 0x40000000LL;
  *(void *)&uint8_t buf[16] = __SecAbsoluteTimeGetGregorianDate_block_invoke;
  __int128 v57 = &unk_189676968;
  __int128 v58 = &err;
  double v59 = a5;
  uint64_t v60 = (char *)&v49 + 4;
  uint64_t v61 = &v49;
  uint64_t v62 = (char *)&v48 + 4;
  uint64_t v63 = &v48;
  v64 = (char *)&v47 + 4;
  v65 = &v47;
  SecCFCalendarDoWithZuluCalendar((uint64_t)buf);
  if (*((_BYTE *)p_err + 24))
  {
    _Block_object_dispose(&err, 8);
  }

  else
  {
    SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a1,  v10,  @"Failed to encode date.",  v11,  v12,  v43);
    int v13 = *((unsigned __int8 *)p_err + 24);
    _Block_object_dispose(&err, 8);
    if (!v13)
    {
      unint64_t v34 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (a1) {
          CFTypeRef v35 = *a1;
        }
        else {
          CFTypeRef v35 = 0LL;
        }
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = v35;
        _os_log_impl(&dword_1804F4000, v34, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
      }

      return 0LL;
    }
  }

  CFErrorRef err = 0LL;
  if ((validateDateComponents( HIDWORD(v49),  v49,  HIDWORD(v48),  v48,  HIDWORD(v47),  v47,  0LL,  (__CFString **)&err) & 1) == 0)
  {
    uint64_t v14 = (__CFString *)CFErrorCopyDescription(err);
    __security_simulatecrash(v14, 0x53C00002u);
    if (v14) {
      CFRelease(v14);
    }
    uint64_t v15 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "continuing";
      if (a2) {
        uint64_t v16 = "setting default value";
      }
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = err;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v16;
      _os_log_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
    }

    CFErrorRef v17 = err;
    if (err)
    {
      CFErrorRef err = 0LL;
      CFRelease(v17);
    }

    if (a2)
    {
      uint64_t v49 = 0x7D100000001LL;
      HIDWORD(v48) = 1;
      HIDWORD(v47) = 1;
    }
  }

  if (a3 + 1 <= a4)
  {
    *(_BYTE *)(a4 - 1) = 90;
    unint64_t v18 = a4 - 1;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  int v20 = v49;
  int v19 = HIDWORD(v49);
  int v21 = HIDWORD(v47);
  int v45 = HIDWORD(v48);
  int v46 = v48;
  int v22 = v47;
  int v54 = -1431655766;
  int v55 = -1431655766;
  *(void *)buf = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v23 = __dtoa();
  int v24 = v55;
  uint64_t v25 = *(void *)buf;
  if (a5 < 0.0)
  {
    unint64_t v26 = v23 + (v55 & ~(v55 >> 31));
    if (v26 < *(void *)buf)
    {
      uint64_t v27 = (_BYTE *)(*(void *)buf - 1LL);
    }

    int v24 = v55;
    uint64_t v25 = *(void *)buf;
  }

  if (v25 - v23 > v24)
  {
    if ((v24 & 0x80000000) == 0)
    {
      unint64_t v18 = ccder_encode_body();
LABEL_31:
      if (a3 + 1 <= v18) {
        *(_BYTE *)--unint64_t v18 = 46;
      }
      else {
        unint64_t v18 = 0LL;
      }
      goto LABEL_38;
    }

    int v44 = v20;
    SecTrustRef v29 = a1;
    int v30 = v19;
    ccder_encode_body();
    size_t v31 = -(uint64_t)v55;
    char v32 = (void *)ccder_encode_body_nocopy();
    unint64_t v18 = (unint64_t)v32;
    if (v32)
    {
      if (a5 >= 0.0) {
        int v33 = 48;
      }
      else {
        int v33 = 57;
      }
      memset(v32, v33, v31);
      int v19 = v30;
      a1 = v29;
      int v20 = v44;
      goto LABEL_31;
    }

    int v19 = v30;
    a1 = v29;
    int v20 = v44;
  }

LABEL_38:
  __freedtoa();
  if (v18)
  {
    unint64_t v39 = a3 + 2;
    if (a3 + 2 <= v18)
    {
      *(_BYTE *)(v18 - 2) = v22 / 10 + 48;
      *(_BYTE *)(v18 - 1) = v22 % 10 + 48;
      if (v39 <= v18 - 2)
      {
        *(_BYTE *)(v18 - 4) = v21 / 10 + 48;
        *(_BYTE *)(v18 - 3) = v21 % 10 + 48;
        if (v39 <= v18 - 4)
        {
          *(_BYTE *)(v18 - 6) = v46 / 10 + 48;
          *(_BYTE *)(v18 - 5) = v46 % 10 + 48;
          if (v39 <= v18 - 6)
          {
            *(_BYTE *)(v18 - 8) = v45 / 10 + 48;
            *(_BYTE *)(v18 - 7) = v45 % 10 + 48;
            if (v39 <= v18 - 8)
            {
              *(_BYTE *)(v18 - 10) = v20 / 10 + 48;
              *(_BYTE *)(v18 - 9) = v20 % 10 + 48;
              if (v39 <= v18 - 10)
              {
                unsigned int v40 = (((103 * (v19 % 100)) >> 15) & 1) + ((103 * (v19 % 100)) >> 10);
                *(_BYTE *)(v18 - 12) = v40 + 48;
                *(_BYTE *)(v18 - 11) = v19 % 100 - 10 * v40 + 48;
                if (v39 <= v18 - 12)
                {
                  *(_BYTE *)(v18 - 14) = v19 / 1000 + 48;
                  unint64_t v41 = v18 - 14;
                  *(_BYTE *)(v41 + 1) = v19 / 100 % 10 + 48;
                  return v41;
                }
              }
            }
          }
        }
      }
    }
  }

  SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a1,  v36,  @"ccder failed to encode",  v37,  v38,  v43);
  return 0LL;
}

      goto LABEL_39;
    }

    if (a4)
    {
      uint64_t v8 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:8 description:@"radarNumber invalid"];
      uint64_t v9 = 0LL;
      *a4 = v8;
      goto LABEL_38;
    }

    uint64_t v9 = 0LL;
LABEL_39:

    goto LABEL_40;
  }

  if (a4)
  {
    uint64_t v7 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:6 description:@"action invalid type"];
    uint64_t v9 = 0LL;
    *a4 = v7;
    goto LABEL_39;
  }

  uint64_t v9 = 0LL;
LABEL_40:

  return v9;
}

  return v8;
}

          uint64_t v36 = operator new(0x30uLL);
          v36[2] = v71;
          *(void *)uint64_t v36 = 0LL;
          *((void *)v36 + 1) = 0LL;
          *((void *)v36 + 2) = v32;
          *unint64_t v34 = v36;
          uint64_t v37 = **(void **)(a1 + 48);
          if (v37)
          {
            *(void *)(a1 + 48) = v37;
            uint64_t v36 = (_OWORD *)*v34;
          }

          uint64_t v38 = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>( *(uint64_t **)(a1 + 56),  (uint64_t *)v36);
          ++*(void *)(a1 + 64);
          unint64_t v39 = v26[2];
          unsigned int v40 = *((unsigned int *)v39 + 2) - v29;
          if (v29 != v69)
          {
            unint64_t v41 = *((_DWORD *)v39 + 4);
            if (v41 > 0x1E || v40 >= 1LL << v41)
            {
              v64 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.st_dev) = 0;
                uint64_t v60 = "STRICT VALIDATION ERROR: the size of the padding after the universal cannot be calculated to a fixed size";
                p_buf = &buf;
                uint64_t v62 = v64;
                uint64_t v63 = 2;
LABEL_77:
                _os_log_impl(&dword_1804F4000, v62, OS_LOG_TYPE_DEFAULT, v60, (uint8_t *)p_buf, v63);
              }

              goto LABEL_78;
            }
          }

          char v43 = Security::Allocator::standard((Security::Allocator *)v38);
          int v44 = (Security::Allocator *)(*(uint64_t (**)(uint64_t, void))(*(void *)v43 + 16LL))( v43,  *MEMORY[0x1895FD590]);
          int v45 = Security::Allocator::standard(v44);
          int v46 = 0LL;
LABEL_46:
          if (v40 > v46) {
            break;
          }
LABEL_60:
          if (v46 != v40)
          {
            int v56 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              buf.st_dev = 134218240;
              *(void *)&buf.st_mode = v46;
              WORD2(buf.st_ino) = 2048;
              *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v40;
              _os_log_impl( &dword_1804F4000,  v56,  OS_LOG_TYPE_DEFAULT,  "STRICT VALIDATION ERROR: gap size does not match expected (%zu != %zu)",  (uint8_t *)&buf,  0x16u);
            }

            *(_BYTE *)(a1 + 76) = 1;
LABEL_70:
            (*(void (**)(uint64_t, Security::Allocator *))(*(void *)v45 + 24LL))(v45, v44);
            goto LABEL_71;
          }

          if (*(_BYTE *)(a1 + 76)) {
            goto LABEL_70;
          }
          int v54 = v26[2];
          uint64_t v27 = *((unsigned int *)v54 + 2);
          char v28 = *((unsigned int *)v54 + 3);
          SecTrustRef v29 = (v28 + v27);
          (*(void (**)(uint64_t, Security::Allocator *))(*(void *)v45 + 24LL))(v45, v44);
          unint64_t v26 = (uint64_t **)v26[1];
          if (v26 == &v72) {
            goto LABEL_71;
          }
        }

        if (*MEMORY[0x1895FD590] >= v40 - v46) {
          uint64_t v47 = v40 - v46;
        }
        else {
          uint64_t v47 = *MEMORY[0x1895FD590];
        }
        uint64_t v48 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v44, v47, v46 + v29);
        if (v48)
        {
          v46 += v48;
          uint64_t v49 = v44;
          while (1)
          {
            unint64_t v50 = *(unsigned __int8 *)v49;
            uint64_t v49 = (Security::Allocator *)((char *)v49 + 1);
            if (v50) {
              break;
            }
            if (!--v48)
            {
              if (!*(_BYTE *)(a1 + 76)) {
                goto LABEL_46;
              }
              goto LABEL_60;
            }
          }

          unint64_t v51 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_59;
          }
          LOWORD(buf.st_dev) = 0;
          uint64_t v52 = v51;
          char v53 = "STRICT VALIDATION ERROR: non-zero gap byte found";
        }

        else
        {
          int v55 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_59;
          }
          LOWORD(buf.st_dev) = 0;
          uint64_t v52 = v55;
          char v53 = "STRICT VALIDATION ERROR: failed to read expected gap bytes";
        }

        _os_log_impl(&dword_1804F4000, v52, OS_LOG_TYPE_DEFAULT, v53, (uint8_t *)&buf, 2u);
LABEL_59:
        *(_BYTE *)(a1 + 76) = 1;
        goto LABEL_60;
      }

      free(v14);
      v68 = 8LL;
    }

    else
    {
      v68 = *__error();
    }

    Security::UnixError::throwMe((Security::UnixError *)v68);
  }

  if ((v75[0].i32[0] + 17958194) >= 2)
  {
    uint64_t v6 = -805638658;
LABEL_24:
    if (v75[0].i32[0] == v6)
    {
      *(void *)(a1 + 8) = 0LL;
      *(_DWORD *)(a1 + 16) = 0;
      *(int8x8_t *)(a1 + 20) = vrev32_s8(*(int8x8_t *)((char *)v75 + 4));
      uint64_t v7 = (os_log_s *)secLogObjForScope("macho");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = NXGetArchInfoFromCpuType(*(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) & 0xFFFFFF);
        if (v25) {
          name = (__darwin_ino64_t)v25->name;
        }
        else {
          name = 0LL;
        }
LABEL_83:
        buf.st_dev = 134218242;
        *(void *)&buf.st_mode = a1;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = name;
        _os_log_debug_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEBUG, "%p is a thin file (%s)", (uint8_t *)&buf, 0x16u);
        return a1;
      }

      return a1;
    }

      __cxa_end_catch();
      JUMPOUT(0x180623FB8LL);
    case 5:
      char v43 = __cxa_begin_catch(a1);
      int v44 = (*(uint64_t (**)(void *))(*(void *)v43 + 24LL))(v43);
      if (!v35) {
        goto LABEL_38;
      }
      int v45 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v44, 0LL);
LABEL_37:
      CFArrayRef v35 = v45;
      goto LABEL_38;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v49 = __cxa_begin_catch(a1);
      unint64_t v50 = (*(uint64_t (**)(void *))(*(void *)v49 + 24LL))(v49);
      if (v35) {
        CFArrayRef v35 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v50, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v35) {
          CFArrayRef v35 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v51);
        if (v35) {
          CFArrayRef v35 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_38;
  }

  int v46 = __cxa_begin_catch(a1);
  uint64_t v47 = v46[36];
  if (v47 > 0x1A) {
    goto LABEL_34;
  }
  unint64_t v42 = -67033;
  uint64_t v48 = 1 << v47;
  if ((v48 & 0x800108) != 0) {
    goto LABEL_35;
  }
  if ((v48 & 0x4014000) != 0) {
    unint64_t v42 = -67032;
  }
  else {
LABEL_34:
  }
    unint64_t v42 = (*(uint64_t (**)(_DWORD *))(*(void *)v46 + 24LL))(v46);
LABEL_35:
  if (!v35) {
    goto LABEL_38;
  }
  goto LABEL_36;
}

      std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)a1,  (uint64_t)v25,  v26,  v22);
      uint64_t v27 = (void *)a2[1];
      if (v27)
      {
        do
        {
          char v28 = v27;
          uint64_t v27 = (void *)*v27;
        }

        while (v27);
      }

      else
      {
        do
        {
          char v28 = (void *)a2[2];
          unint64_t v18 = *v28 == (void)a2;
          a2 = v28;
        }

        while (!v18);
      }

      a2 = v28;
    }

    while (v28 != a3);
  }

void SecCFCalendarDoWithZuluCalendar(uint64_t a1)
{
  if (SecCFCalendarGetZuluQueue_onceToken != -1) {
    dispatch_once(&SecCFCalendarGetZuluQueue_onceToken, &__block_literal_global_13274);
  }
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecCFCalendarDoWithZuluCalendar_block_invoke;
  block[3] = &unk_189676740;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)fqueue_cf, block);
}

uint64_t __SecCFCalendarDoWithZuluCalendar_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (SecCFCalendarGetZulu_onceToken != -1) {
    dispatch_once(&SecCFCalendarGetZulu_onceToken, &__block_literal_global_51);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))(v1, sZuluCalendar);
}

uint64_t __SecAbsoluteTimeGetGregorianDate_block_invoke(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarDecomposeAbsoluteTime( calendar,  *(CFAbsoluteTime *)(a1 + 40),  "yMdHms",  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 88));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (_DWORD)result != 0;
  return result;
}

uint64_t validateDateComponents( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  if ((a1 & 3) != 0)
  {
    BOOL v8 = 0LL;
  }

  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      BOOL v8 = (v10 >> 4) < 0xA3D70B;
    }

    else
    {
      BOOL v8 = 1LL;
    }
  }

  if (a7) {
    *a7 = v8;
  }
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && ((_DWORD)a2 != 2 || (v8 | 0x1C) >= a3)
    && ((_DWORD)a2 == 2 || mdays[a2] - mdays[(a2 - 1)] >= (int)a3))
  {
    return 1LL;
  }

  SecError(-1, a8, @"Invalid date: %i, %i, %i, %i, %i, %i, %i", a1, a2, a3, a4, a5, a6, v8);
  return 0LL;
}

BOOL sec_protocol_metadata_access_peer_certificate_chain(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_peer_certificate_chain_block_invoke;
    unint64_t v4[3] = &unk_189666450;
    void v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }

  return v2;
}

uint64_t sec_protocol_metadata_access_handle(uint64_t a1, uint64_t a2)
{
  if (sec_protocol_metadata_access_handle_onceToken != -1) {
    dispatch_once(&sec_protocol_metadata_access_handle_onceToken, &__block_literal_global_4);
  }
  if (sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle) {
    return sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle(a1, a2);
  }
  else {
    return 0LL;
  }
}

uint64_t __sec_protocol_metadata_access_peer_certificate_chain_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a2 + 88);
  if (result)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_peer_certificate_chain_block_invoke_2;
    unint64_t v4[3] = &unk_189666428;
    void v4[4] = *(void *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1LL;
  }

  return result;
}

uint64_t __sec_protocol_metadata_access_peer_certificate_chain_block_invoke_2(uint64_t a1)
{
  return 1LL;
}

SecCertificateRef sec_certificate_copy_ref(sec_certificate_t certificate)
{
  else {
    return 0LL;
  }
}

const char *__cdecl sec_protocol_metadata_get_negotiated_protocol(sec_protocol_metadata_t metadata)
{
  if (!metadata) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_negotiated_protocol_block_invoke;
  v3[3] = &unk_1896662C0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  uint64_t v1 = (const char *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_negotiated_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 40);
  }
  return a2 != 0;
}

tls_protocol_version_t sec_protocol_metadata_get_negotiated_tls_protocol_version( sec_protocol_metadata_t metadata)
{
  if (!metadata) {
    return 0;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  __int16 v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_negotiated_tls_protocol_version_block_invoke;
  v3[3] = &unk_1896664A0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  tls_protocol_version_t v1 = *((_WORD *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_negotiated_tls_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_WORD *)(a2 + 32);
  }
  return a2 != 0;
}

tls_ciphersuite_t sec_protocol_metadata_get_negotiated_tls_ciphersuite(sec_protocol_metadata_t metadata)
{
  tls_ciphersuite_t v1 = tls_ciphersuite_CHACHA20_POLY1305_SHA256|tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256|0x2054;
  if (metadata)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = &v4;
    uint64_t v6 = 0x2000000000LL;
    __int16 v7 = -1;
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 0x40000000LL;
    _DWORD v3[2] = __sec_protocol_metadata_get_negotiated_tls_ciphersuite_block_invoke;
    v3[3] = &unk_1896664F0;
    v3[4] = &v4;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
    tls_ciphersuite_t v1 = *((_WORD *)v5 + 12);
    _Block_object_dispose(&v4, 8);
  }

  return v1;
}

BOOL __sec_protocol_metadata_get_negotiated_tls_ciphersuite_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_WORD *)(a2 + 34);
  }
  return a2 != 0;
}

uint64_t SecTrustEvaluateFastAsync(uint64_t a1, dispatch_queue_t queue, uint64_t a3)
{
  uint64_t result = 4294967246LL;
  if (a1 && queue)
  {
    if (a3)
    {
      dispatch_assert_queue_V2(queue);
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 0x40000000LL;
      v7[2] = __SecTrustEvaluateFastAsync_block_invoke;
      v7[3] = &unk_189674FE8;
      v7[4] = a3;
      v7[5] = a1;
      SecTrustEvaluateIfNecessaryFastAsync(a1, queue, (uint64_t)v7);
      return 0LL;
    }
  }

  return result;
}

void SecTrustEvaluateIfNecessaryFastAsync(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    v17[0] = 0LL;
    v17[1] = v17;
    void v17[2] = 0x2000000000LL;
    CFAbsoluteTime VerifyTime = NAN;
    CFAbsoluteTime VerifyTime = SecTrustGetVerifyTime((SecTrustRef)a1);
    SecTrustAddPolicyAnchors(a1);
    dispatch_retain(a2);
    CFRetain((CFTypeRef)a1);
    uint64_t v6 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke;
    block[3] = &unk_189675BB8;
    block[6] = a1;
    block[7] = a2;
    block[4] = a3;
    void block[5] = v17;
    uint64_t v12 = 0LL;
    int v13 = &v12;
    uint64_t v14 = 0x2000000000LL;
    char v15 = 0;
    __int16 v7 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v20 = a1;
      _os_log_debug_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEBUG, "(Trust %p) waiting for queue", buf, 0xCu);
    }

    BOOL v8 = *(dispatch_queue_s **)(a1 + 136);
    v11[0] = v6;
    v11[1] = 0x40000000LL;
    unint64_t v11[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_405;
    unint64_t v11[3] = &unk_189675BE0;
    v11[4] = &v12;
    v11[5] = a1;
    dispatch_sync(v8, v11);
    if (*((_BYTE *)v13 + 24))
    {
      unint64_t v9 = (os_log_s *)secLogObjForScope("trust");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v20 = a1;
        _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "(Trust %p) Waiting for pending eval", buf, 0xCu);
      }

      dispatch_group_notify(*(dispatch_group_t *)(a1 + 168), *(dispatch_queue_t *)(a1 + 136), block);
    }

    else
    {
      dispatch_sync(*(dispatch_queue_t *)(a1 + 136), block);
      unint64_t v10 = (os_log_s *)secLogObjForScope("trust");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v20 = a1;
        _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "(Trust %p) Completed async eval kickoff", buf, 0xCu);
      }

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 168));
    }

    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(v17, 8);
  }

CFAbsoluteTime SecTrustGetVerifyTime(SecTrustRef trust)
{
  uint64_t v6 = 0LL;
  __int16 v7 = (double *)&v6;
  uint64_t v8 = 0x2000000000LL;
  CFAbsoluteTime Current = NAN;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  if (trust)
  {
    BOOL v2 = (dispatch_queue_s *)*((void *)trust + 17);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    uint64_t v5[2] = __SecTrustGetVerifyTime_block_invoke;
    v5[3] = &unk_189674A60;
    v5[4] = &v6;
    void v5[5] = trust;
    dispatch_sync(v2, v5);
  }

  double v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecTrustGetVerifyTime_block_invoke(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 40);
  if (v2[8])
  {
    *(double *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = MEMORY[0x186DFE188](v2[8]);
  }

  else
  {
    double v3 = CFGetAllocator(v2);
    *(void *)(*(void *)(a1 + 40) + 64LL) = CFDateCreate( v3,  *(CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  }

void SecTrustAddPolicyAnchors(uint64_t a1)
{
  uint64_t v16 = 0LL;
  CFErrorRef v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  BOOL v2 = *(dispatch_queue_s **)(a1 + 136);
  uint64_t v3 = MEMORY[0x1895F87A8];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustAddPolicyAnchors_block_invoke;
  block[3] = &unk_1896759A8;
  block[4] = &v16;
  void block[5] = a1;
  dispatch_sync(v2, block);
  CFIndex Count = CFArrayGetCount((CFArrayRef)v17[3]);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0LL;
    while (1)
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex((CFArrayRef)v17[3], v6);
      if (ValueAtIndex)
      {
        if (CFEqual(ValueAtIndex[2], @"1.2.840.113635.100.1.32")) {
          break;
        }
      }

      if (v5 == ++v6) {
        goto LABEL_12;
      }
    }

    v13[0] = 0LL;
    v13[1] = v13;
    v13[2] = 0x2000000000LL;
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    values = SecCertificateCreateWithBytes(*MEMORY[0x189604DB0], &_SEC_TestAppleRootCAECC, 555LL);
    if (values)
    {
      CFArrayRef v9 = CFArrayCreate(v8, (const void **)&values, 1LL, MEMORY[0x189605228]);
      if (values) {
        CFRelease(values);
      }
    }

    else
    {
      CFArrayRef v9 = 0LL;
    }

    unint64_t v14 = (unint64_t)v9;
    unint64_t v10 = *(dispatch_queue_s **)(a1 + 136);
    v12[0] = v3;
    v12[1] = 0x40000000LL;
    v12[2] = __SecTrustAddPolicyAnchors_block_invoke_2;
    v12[3] = &unk_1896759D8;
    unint64_t v12[4] = v13;
    v12[5] = a1;
    dispatch_sync(v10, v12);
    *(_BYTE *)(a1 + 116) = 1;
    _Block_object_dispose(v13, 8);
  }

LABEL_12:
  uint64_t v11 = (const void *)v17[3];
  if (v11) {
    CFRelease(v11);
  }
  _Block_object_dispose(&v16, 8);
}

  __break(0x5519u);
  return result;
}

  uint64_t v11 = v14 - 0x5555555555555556LL;
  if (v14 > v14 - 0x5555555555555556LL || v11 > v13) {
    goto LABEL_30;
  }
  if (v11 == v13)
  {
    if (a3)
    {
      *a3 = 0LL;
      a3[1] = 0LL;
    }
  }

  else if (a3)
  {
    *a3 = v11;
    a3[1] = v13 - v11;
  }

  if (v13 > v15 || v14 > v13) {
    goto LABEL_30;
  }
  *a4 = 0LL;
  a4[1] = 0LL;
  if (v13 == v15) {
    return 0LL;
  }
  else {
    return 655365LL;
  }
}

    __break(0x5519u);
  }

  return result;
}

  return v7;
}

    CFIndex v5 = 0;
  }

    uint64_t result = 0LL;
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(_DWORD *)(v8 + 40) = 1;
    *(void *)(v8 + 48) = "Attempted to execute unknown CoreEntitlements operation";
    *(void *)(v8 + 56) = 55LL;
    return result;
  }

  uint64_t v3 = der_vm_string_from_context();
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(v4 + 8) = v3;
  *(void *)(v4 + 16) = v5;
  **(void **)(a1 + 48) |= 0x4000000000000000uLL;
LABEL_8:
  if (der_vm_context_is_valid())
  {
    der_vm_execute_nocopy();
    CFIndex v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
    *(_OWORD *)(v6 + 40) = v9;
    *(_OWORD *)(v6 + 56) = v10;
    *(_OWORD *)(v6 + 72) = v11;
    *(void *)(v6 + 88) = v12;
  }

  return 1LL;
}

          CFArrayAppendValue(Mutable, v11);
        }

  uint64_t v11 = (const void *)v17[5];
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = v22;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v16, 8);
  objc_autoreleasePoolPop(v2);
  return v12;
}

    CFRelease(v10);
    goto LABEL_13;
  }

  unint64_t v14 = 0LL;
LABEL_17:
  if (v20) {
    CFRelease(v20);
  }
  objc_autoreleasePoolPop(v6);
  return v14;
}

  uint64_t v8 = (CFErrorRef)v10;

  return v8;
}
}

  int v13 = objc_alloc_init(&OBJC_CLASS___SecCBORMap);
  unint64_t v14 = -[SecCBORString initWith:](objc_alloc(&OBJC_CLASS___SecCBORString), "initWith:", @"x5c");
  -[SecCBORMap setKey:value:](v13, "setKey:value:", v14, v6);

  char v15 = objc_alloc_init(&OBJC_CLASS___SecCBORMap);
  uint64_t v16 = -[SecCBORString initWith:](objc_alloc(&OBJC_CLASS___SecCBORString), "initWith:", @"fmt");
  CFErrorRef v17 = -[SecCBORString initWith:](objc_alloc(&OBJC_CLASS___SecCBORString), "initWith:", @"apple");
  -[SecCBORMap setKey:value:](v15, "setKey:value:", v16, v17);

  uint64_t v18 = -[SecCBORString initWith:](objc_alloc(&OBJC_CLASS___SecCBORString), "initWith:", @"attStmt");
  -[SecCBORMap setKey:value:](v15, "setKey:value:", v18, v13);

  uint64_t v19 = objc_alloc_init(MEMORY[0x189603FB8]);
  -[SecCBORMap write:](v15, "write:", v19);
  uint64_t v20 = (void *)[v19 copy];

  objc_autoreleasePoolPop(v5);
  if (v20 && self->_logAcmeCSR)
  {
    [NSString stringWithFormat:@"/tmp/AcmeAtt_%@", self->_timestamp];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[SecJWSEncoder base64URLEncodedStringRepresentationWithData:]( self->_encoder,  "base64URLEncodedStringRepresentationWithData:",  v20);
    int v22 = (void *)objc_claimAutoreleasedReturnValue();
    [v22 dataUsingEncoding:4];
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();

    [v23 writeToFile:v21 atomically:1];
  }

  return v20;
}

  publicKey = self->_publicKey;
  if (publicKey)
  {
    v22[0] = @"class";
    v22[1] = @"v_Ref";
    v23[0] = @"keys";
    v23[1] = publicKey;
    [MEMORY[0x189603F68] dictionaryWithObjects:v23 forKeys:v22 count:2];
    CFErrorRef v17 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
    SecItemDelete(v17);
  }

  if (v6)
  {
    secLogObjForScope("SecError");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 138412290;
      uint64_t v21 = v6;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "identityWithError: %@", (uint8_t *)&v20, 0xCu);
    }
  }

  if (a3) {
    *a3 = v6;
  }

  return self->_identity;
}

    MutableCopy = 0LL;
    goto LABEL_16;
  }

  int v13 = CFStringGetLength(cf);
  unint64_t v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (v13 > 5)
  {
    v21.location = 0LL;
    v21.CFIndex length = 6LL;
    Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], cf, v21);
  }

  else
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], cf);
  }

    __int16 v7 = this;
    CFIndex v5 = (os_log_s *)secLogObjForScope("macho");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      CFIndex v6 = **(_DWORD **)(v7 + 8);
      *(_DWORD *)buf = 134218240;
      CFArrayRef v9 = v7;
      unint64_t v10 = 1024;
      uint64_t v11 = v6;
      _os_log_debug_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEBUG, "%p: unrecognized header magic (%x)", buf, 0x12u);
    }

    Security::UnixError::throwMe((Security::UnixError *)8);
  }

  if (magic == -822415874)
  {
    uint64_t v4 = 0;
    uint64_t v3 = 1;
    goto LABEL_11;
  }

  if (magic != -805638658) {
    goto LABEL_12;
  }
  uint64_t v3 = 1;
LABEL_8:
  uint64_t v4 = 1;
LABEL_11:
  *(_BYTE *)(this + 33) = v3;
  *(_BYTE *)(this + 32) = v4;
  return this;
}

CFTypeRef __SecTrustAddPolicyAnchors_block_invoke(uint64_t a1)
{
  CFTypeRef result = CFRetain(*(CFTypeRef *)(*(void *)(a1 + 40) + 32LL));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke(uint64_t a1)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  BOOL v2 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v29 = *(void *)(a1 + 48);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v29;
    _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "(Trust %p) Started eval block", (uint8_t *)&buf, 0xCu);
  }

  if (SecTrustIsTrustResultValid( *(void *)(a1 + 48),  *(double *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)))
  {
    uint64_t v3 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 48);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v4;
      _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "(Trust %p) Prior trust results valid",  (uint8_t *)&buf,  0xCu);
    }

    uint64_t v5 = *(void *)(a1 + 48);
    *(_BYTE *)(v5 + 160) = 0;
    CFIndex v6 = *(dispatch_queue_s **)(a1 + 56);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_385;
    block[3] = &unk_189675A88;
    block[4] = *(void *)(a1 + 32);
    void block[5] = v5;
    dispatch_async(v6, block);
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }

  else
  {
    dispatch_group_enter(*(dispatch_group_t *)(*(void *)(a1 + 48) + 168LL));
    uint64_t v7 = *(void *)(a1 + 48);
    *(_DWORD *)(v7 + 112) = 7;
    uint64_t v8 = *(const void **)(v7 + 72);
    if (v8)
    {
      *(void *)(v7 + 72) = 0LL;
      CFRelease(v8);
      uint64_t v7 = *(void *)(a1 + 48);
    }

    CFArrayRef v9 = *(const void **)(v7 + 88);
    if (v9)
    {
      *(void *)(v7 + 88) = 0LL;
      CFRelease(v9);
      uint64_t v7 = *(void *)(a1 + 48);
    }

    unint64_t v10 = *(const void **)(v7 + 96);
    if (v10)
    {
      *(void *)(v7 + 96) = 0LL;
      CFRelease(v10);
      uint64_t v7 = *(void *)(a1 + 48);
    }

    uint64_t v11 = *(void **)(v7 + 120);
    if (v11)
    {
      free(v11);
      *(void *)(*(void *)(a1 + 48) + 120LL) = 0LL;
      uint64_t v7 = *(void *)(a1 + 48);
    }

    uint64_t v12 = *(void **)(v7 + 128);
    if (v12)
    {
      free(v12);
      *(void *)(*(void *)(a1 + 48) + 128LL) = 0LL;
    }

    int v13 = _os_activity_create( &dword_1804F4000,  "SecTrustEvaluateIfNecessaryFastAsync",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
    v45[0] = 0LL;
    v45[1] = v45;
    unint64_t v45[2] = 0x2800000000LL;
    v46.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    v46.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v13, &v46);
    os_release(v13);
    SecTrustValidateInput(*(void **)(a1 + 48));
    unint64_t v14 = (char *)calloc(1uLL, 0x18uLL);
    if (gTrustd && *(void *)(gTrustd + 40))
    {
      v40[0] = MEMORY[0x1895F87A8];
      v40[1] = 0x40000000LL;
      v40[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_387;
      v40[3] = &unk_189675B20;
      char v15 = *(dispatch_queue_s **)(a1 + 56);
      uint64_t v43 = *(void *)(a1 + 48);
      int v44 = v14;
      unint64_t v42 = v45;
      __int128 v41 = *(_OWORD *)(a1 + 32);
      dispatch_async(v15, v40);
    }

    else
    {
      uint64_t v16 = MEMORY[0x1895F87A8];
      v37[0] = MEMORY[0x1895F87A8];
      v37[1] = 0x40000000LL;
      v37[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_395;
      v37[3] = &unk_189675B90;
      CFErrorRef v17 = *(dispatch_queue_s **)(a1 + 56);
      uint64_t v38 = *(void *)(a1 + 48);
      unint64_t v39 = v14;
      uint64_t v18 = *(void *)(a1 + 40);
      v37[4] = *(void *)(a1 + 32);
      v37[5] = v45;
      char v19 = *(_BYTE *)(v38 + 116);
      __int128 v20 = *(_OWORD *)(v38 + 16);
      __int128 v21 = *(_OWORD *)(v38 + 32);
      __int128 v22 = *(_OWORD *)(v38 + 48);
      char v23 = *(_BYTE *)(v38 + 117);
      uint64_t v24 = *(void *)(*(void *)(v18 + 8) + 24LL);
      if (SecTrustGetCurrentAccessGroups_onceToken != -1)
      {
        char v36 = *(_BYTE *)(v38 + 117);
        unint64_t v34 = v17;
        CFTypeRef v35 = v14;
        uint64_t v33 = *(void *)(*(void *)(v18 + 8) + 24LL);
        __int128 v31 = *(_OWORD *)(v38 + 16);
        __int128 v32 = *(_OWORD *)(v38 + 48);
        __int128 v30 = *(_OWORD *)(v38 + 32);
        dispatch_once(&SecTrustGetCurrentAccessGroups_onceToken, &__block_literal_global_344);
        __int128 v21 = v30;
        __int128 v20 = v31;
        __int128 v22 = v32;
        char v23 = v36;
        uint64_t v24 = v33;
        CFErrorRef v17 = v34;
        unint64_t v14 = v35;
      }

      uint64_t v25 = *(void **)(a1 + 48);
      uint64_t v26 = v25[13];
      uint64_t v28 = v25[18];
      uint64_t v27 = v25[19];
      *(void *)&__int128 buf = v16;
      *((void *)&buf + 1) = 0x40000000LL;
      unint64_t v50 = __handle_trust_evaluate_xpc_async_block_invoke;
      unint64_t v51 = &__block_descriptor_tmp_407;
      char v59 = v19;
      char v60 = v23;
      __int128 v52 = v20;
      __int128 v53 = v21;
      __int128 v54 = v22;
      uint64_t v55 = v24;
      uint64_t v56 = v26;
      uint64_t v57 = v28;
      uint64_t v58 = v27;
      v48[0] = v16;
      v48[1] = 0x40000000LL;
      v48[2] = __handle_trust_evaluate_xpc_async_block_invoke_2;
      v48[3] = &unk_189675C28;
      v48[4] = v37;
      v48[5] = v14;
      v48[6] = v14 + 8;
      v48[7] = v14 + 16;
      securityd_send_async_and_do(8u, v17, (uint64_t)&buf, (uint64_t)v48);
    }

    dispatch_release(*(dispatch_object_t *)(a1 + 56));
    _Block_object_dispose(v45, 8);
  }

uint64_t SecTrustIsTrustResultValid(uint64_t a1, double a2)
{
  if (!*(_DWORD *)(a1 + 112)) {
    return 0LL;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current + 4500.0 < a2 || Current + -4500.0 > a2) {
    return 1LL;
  }
  uint64_t v7 = *(const __CFDictionary **)(a1 + 96);
  if (!v7) {
    return 0LL;
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), @"TrustResultNotBefore");
  CFArrayRef v9 = CFDictionaryGetValue(v7, @"TrustResultNotAfter");
  uint64_t result = 0LL;
  if (Value && v9)
  {
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 == CFDateGetTypeID())
    {
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFDateGetTypeID() && Current < MEMORY[0x186DFE188](v9) && Current > MEMORY[0x186DFE188](Value)) {
        return 1LL;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t SecTrustValidateInput(void *a1)
{
  BOOL v2 = (const __CFArray *)a1[2];
  CFTypeID TypeID = SecCertificateGetTypeID();
  unsigned int v4 = validate_array_of_items(v2, (uint64_t)@"certificate", TypeID, 1);
  uint64_t v5 = (const __CFArray *)a1[3];
  CFTypeID v6 = SecCertificateGetTypeID();
  unsigned int v7 = validate_array_of_items(v5, (uint64_t)@"input anchor", v6, 0);
  if (v7) {
    unsigned int v4 = v7;
  }
  uint64_t v8 = (const __CFArray *)a1[4];
  CFTypeID v9 = SecPolicyGetTypeID();
  LODWORD(result) = validate_array_of_items(v8, (uint64_t)@"policy", v9, 1);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v4;
  }
}

uint64_t validate_array_of_items(const __CFArray *a1, uint64_t a2, uint64_t a3, int a4)
{
  char v4 = a4;
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    CFIndex v9 = Count;
    if (Count || (v4 & 1) == 0)
    {
      if (Count >= 1)
      {
        uint64_t v10 = 0LL;
        CFIndex v11 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a1, v11);
          if (!ValueAtIndex)
          {
            CFErrorRef v17 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412802;
              uint64_t v26 = a2;
              __int16 v27 = 2112;
              uint64_t v28 = @"reference is nil";
              __int16 v29 = 1024;
              int v30 = v11;
              _os_log_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
            }

            uint64_t v10 = 4294967246LL;
            goto LABEL_29;
          }

          int v13 = ValueAtIndex;
          CFTypeID v14 = CFGetTypeID(ValueAtIndex);
          if (v14 != a3)
          {
            char v15 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412802;
              uint64_t v26 = a2;
              __int16 v27 = 2112;
              uint64_t v28 = @"is not the expected CF type";
              __int16 v29 = 1024;
              int v30 = v11;
              _os_log_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
            }

            uint64_t v10 = 4294967246LL;
          }

          if (v14 == SecCertificateGetTypeID())
          {
            uint64_t v16 = v13[2];
            if (!v13[3])
            {
              uint64_t v18 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412802;
                uint64_t v26 = a2;
                __int16 v27 = 2112;
                uint64_t v28 = @"has zero length";
                __int16 v29 = 1024;
                int v30 = v11;
                _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }

              uint64_t v10 = 4294967246LL;
              if (v16) {
                goto LABEL_24;
              }
LABEL_21:
              char v19 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412802;
                uint64_t v26 = a2;
                __int16 v27 = 2112;
                uint64_t v28 = @"has nil bytes";
                __int16 v29 = 1024;
                int v30 = v11;
                _os_log_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }

              uint64_t v10 = 4294967246LL;
              goto LABEL_24;
            }

            if (!v16) {
              goto LABEL_21;
            }
          }

LABEL_24:
          if (v14 == SecPolicyGetTypeID())
          {
            __int128 v20 = (const void *)v13[2];
            if (!v20 || (CFTypeID v21 = CFGetTypeID(v20), v21 != CFStringGetTypeID()))
            {
              __int128 v22 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412802;
                uint64_t v26 = a2;
                __int16 v27 = 2112;
                uint64_t v28 = @"has invalid OID string!";
                __int16 v29 = 1024;
                int v30 = v11;
                _os_log_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }
            }
          }

    uint64_t v18 = @"Can't expand V2 Dictionary";
    goto LABEL_25;
  }

  return result;
}

    char v23 = 4294967246LL;
    goto LABEL_25;
  }

  if (a6)
  {
    uint64_t v25 = cf2;
    if (cf2) {
      CFRetain(cf2);
    }
    *a6 = (uint64_t)v25;
  }

  if (a7)
  {
    uint64_t v26 = (const __CFDictionary *)cf;
    if (cf) {
      CFRetain(cf);
    }
    *a7 = v26;
  }

  if (a4)
  {
    __int16 v27 = (__SecTrust *)v106;
    if (v106) {
      CFRetain(v106);
    }
    *a4 = v27;
  }

  uint64_t v28 = cf2;
  if (cf2)
  {
    cf2 = 0LL;
    CFRelease(v28);
  }

  __int16 v29 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v29);
  }

  int v30 = v106;
  if (v106)
  {
    __int128 v106 = 0LL;
    CFRelease(v30);
  }

  return BytePtr;
}

    if (!v5) {
      return v5;
    }
  }

  CFRelease(v5);
  return 0LL;
}

    __SecOTRPIEqualToBytes_block_invoke((uint64_t)&v47, (uint64_t)v25);
    CFRelease(v25);
    uint64_t v24 = 0;
    if (!v22) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }

  uint64_t v24 = 1;
  if (v22) {
    goto LABEL_25;
  }
LABEL_26:
  if (v23) {
    CFRelease(v23);
  }
  if ((v24 & 1) == 0)
  {
    char v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
    int v44 = -25293;
    goto LABEL_49;
  }

  uint64_t v31 = (unsigned int *)&v13[v19];
  __int128 v32 = v11 - v19;
  uint64_t v33 = *(void *)(a1 + 56);
  if (v11 - v19 < 4)
  {
    unint64_t v34 = -50;
  }

  else
  {
    unint64_t v34 = 0;
    CFTypeRef v35 = *v31++;
    *(_DWORD *)(v33 + 96) = bswap32(v35);
    __int128 v32 = v11 - v19 - 4;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v34;
  char v36 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (!*(_DWORD *)(v36 + 24))
  {
    if (v32 < 4)
    {
      uint64_t v37 = -50;
      unint64_t v39 = 2863311530LL;
    }

    else
    {
      uint64_t v37 = 0;
      uint64_t v38 = *v31++;
      unint64_t v39 = bswap32(v38);
      v32 -= 4LL;
    }

    *(_DWORD *)(v36 + 24) = v37;
    unsigned int v40 = *(void *)(*(void *)(a1 + 32) + 8LL);
    if (!*(_DWORD *)(v40 + 24))
    {
      if (v32 < v39)
      {
        *(_DWORD *)(v40 + 24) = -26275;
        return;
      }

      __int128 v41 = *(void *)(v33 + 32);
      if (v39)
      {
        unint64_t v42 = *(unsigned __int8 *)v31;
        if (v39 - 1 == v42)
        {
          uint64_t v31 = (unsigned int *)((char *)v31 + 1);
          if (!SecKeyDigestAndVerify( *(void *)(v41 + 16),  (const SecAsn1Oid *)kOTRSignatureAlgIDPtr,  (const UInt8 *)v53,  32LL,  (const UInt8 *)v31,  v42)) {
            goto LABEL_39;
          }
        }

        else
        {
          unint64_t v42 = v39;
        }
      }

      else
      {
        unint64_t v42 = 0LL;
      }

      int v45 = (const UInt8 *)malloc(v42 + 3);
      os_activity_scope_state_s v46 = (UInt8 *)v45;
      if (!v45
        || (uint64_t v47 = 8LL, v52 = v45, SecOTRPIRecreateSignature((uint64_t)v31, v42, (uint64_t *)&v52, &v47), !v52)
        || SecKeyDigestAndVerify( *(void *)(v41 + 16),  (const SecAsn1Oid *)kOTRSignatureAlgIDPtr,  (const UInt8 *)v53,  32LL,  v52,  v47))
      {
        free(v46);
        uint64_t v43 = -26275;
        goto LABEL_40;
      }

      free(v46);
LABEL_39:
      uint64_t v43 = 0;
LABEL_40:
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v43;
    }
  }

        appendError(v1, @"One or more certificates have expired or are not valid yet.");
        CFIndex v9 = context;
        if ((context & 0x80) == 0)
        {
LABEL_14:
          if ((v9 & 0x100) == 0) {
            goto LABEL_15;
          }
          goto LABEL_26;
        }

  uint64_t v16 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  uint64_t v18 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x288,  *(void *)(v16 + 200),  v17);
  Security::cfString((Security *)__p, path);
  if (v27 >= 0) {
    char v19 = (char *)__p;
  }
  else {
    char v19 = (char *)__p[0];
  }
  __int128 v20 = Security::CodeSigning::DiskRep::bestGuess(v19, (unsigned int *)&v30);
  Security::CodeSigning::SecStaticCode::SecStaticCode(v18, (Security::CodeSigning::DiskRep *)v20, flags);
  CFTypeID v21 = (const __SecCode *)Security::SecCFObject::handle(v18, 1);
  if (!staticCode) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *staticCFIndex Code = v21;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  return 0;
}

    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
  }

  CFIndex v9 = *v3;
  if (v9) {
    CFRelease(v9);
  }
  *((void *)this + 17) = 0LL;
  uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 4) + 16LL))(*((void *)this + 4));
  Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((void *)this + 4, v10);
  return this;
}

LABEL_29:
          if (v9 == ++v11) {
            return v10;
          }
        }
      }

      return 0LL;
    }
  }

  else if (!a4)
  {
    return 0LL;
  }

  char v23 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v26 = a2;
    _os_log_impl(&dword_1804F4000, v23, OS_LOG_TYPE_DEFAULT, "no %@ in array!", buf, 0xCu);
  }

  return 4294967246LL;
}

                    __break(1u);
                    goto LABEL_30;
                  }
                }

                __break(0x5500u);
                goto LABEL_29;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

  sqlite3_close_v2(self->_db);
  self->_db = 0LL;
  if (a3)
  {
    if (!v10)
    {
      uint64_t v48 = (void *)MEMORY[0x189607870];
      uint64_t v49 = *MEMORY[0x189607460];
      v68 = *MEMORY[0x1896075E0];
      [NSString stringWithFormat:@"Error opening db at %@", self->_path];
      unint64_t v50 = (void *)objc_claimAutoreleasedReturnValue();
      v69 = v50;
      [MEMORY[0x189603F68] dictionaryWithObjects:&v69 forKeys:&v68 count:1];
      unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue();
      [v48 errorWithDomain:v49 code:0 userInfo:v51];
      uint64_t v10 = (id)objc_claimAutoreleasedReturnValue();
    }

    uint64_t v10 = v10;
    uint64_t v8 = 0LL;
    CFIndex v11 = 0;
    *a3 = v10;
  }

  else
  {
    uint64_t v8 = 0LL;
    CFIndex v11 = 0;
  }

          __int16 v29 = 1;
          goto LABEL_52;
        }

        [v12 objectForKeyedSubscript:@"repeatAfterSeconds"];
        uint64_t v18 = (id)objc_claimAutoreleasedReturnValue();
        if (v18 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          if (!a5) {
            goto LABEL_29;
          }
          char v19 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:5 description:@"repeatAfterSeconds not number"];
          *a5 = v19;
        }

        else
        {
          [v12 objectForKeyedSubscript:@"processName"];
          char v19 = (id)objc_claimAutoreleasedReturnValue();
          if (!v19 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
          {
            os_activity_scope_state_s v46 = v19;
            __int128 v20 = a5;
            CFTypeID v21 = [v12 objectForKeyedSubscript:@"matchOnFirstFailure"];
            if (v21 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              uint64_t v31 = (id)v21;
              a5 = v20;
              if (v20)
              {
                uint64_t v24 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:5 description:@"matchOnFirstFailure not number"];
                *__int128 v20 = v24;
                __int16 v29 = 1;
                char v19 = v46;
                goto LABEL_49;
              }

              __int16 v29 = 1;
              char v19 = v46;
            }

            else
            {
              uint64_t v47 = (void *)v21;
              __int128 v22 = objc_alloc_init(&OBJC_CLASS___SECSFAEventRule);
              -[SECSFAEventRule setEventType:](v22, "setEventType:", v13);
              if ((v15 & 1) == 0) {
                -[SECSFAEventRule setEventClass:](v22, "setEventClass:", v16);
              }
              char v19 = v46;
              -[SECSFAEventRule setProcessName:](v22, "setProcessName:", v46);
              -[SECSFAEventRule setRepeatAfterSeconds:]( v22,  "setRepeatAfterSeconds:",  (int)[v18 intValue]);
              -[SECSFAEventRule setMatchOnFirstFailure:]( v22,  "setMatchOnFirstFailure:",  [v47 intValue] != 0);
              unint64_t v51 = 0LL;
              [MEMORY[0x1896079E8] dataWithPropertyList:v17 format:200 options:0 error:&v51];
              char v23 = (void *)objc_claimAutoreleasedReturnValue();
              uint64_t v24 = v51;
              -[SECSFAEventRule setMatch:](v22, "setMatch:", v23);

              -[SECSFAEventRule match](v22, "match");
              uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();

              if (v25)
              {
                [v12 objectForKeyedSubscript:@"action"];
                uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
                [v43 parseAction:v26 error:v45];
                __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
                -[SECSFAEventRule setAction:](v22, "setAction:", v27);

                -[SECSFAEventRule action](v22, "action");
                uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();

                if (v28)
                {
                  [v44 addEventRules:v22];
                  __int16 v29 = 0;
                }

                else
                {
                  __int16 v29 = 1;
                }
              }

              else
              {
                if (v45)
                {
                  [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:12 description:@"plist encode failed" underlying:v24];
                  *int v45 = (id)objc_claimAutoreleasedReturnValue();
                }

                __int16 v29 = 1;
              }

              uint64_t v31 = v47;

              a5 = v45;
LABEL_49:
            }

        goto LABEL_30;
      }
    }

    else
    {
    }

    secLogObjForScope("SecError");
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      char v23 = "CMS message does not contain a EnvelopedData";
      uint64_t v24 = (os_log_s *)v12;
      uint64_t v25 = 2;
LABEL_17:
      _os_log_impl(&dword_1804F4000, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
    }
  }

  else
  {
    secLogObjForScope("SecError");
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v32 = v6;
      char v23 = "failed to decode CMS message: %@";
      uint64_t v24 = (os_log_s *)v12;
      uint64_t v25 = 12;
      goto LABEL_17;
    }
  }

  __int128 v22 = 4294941021LL;
LABEL_19:

  return v22;
}
  }

  else
  {
    CFIndex v9 = 0;
  }

    CFIndex v9 = 4;
    goto LABEL_9;
  }

  CFIndex v9 = 4;
LABEL_8:
  CFRelease(v8);
LABEL_9:
  uint64_t v10 = 0;
  CFIndex v11 = *(void *)(a1[4] + 8LL);
  if (v9)
  {
    uint64_t v12 = *(_DWORD *)(v11 + 24);
    if (v12)
    {
      uint64_t v10 = 6;
      if (v9 != 6)
      {
        if (v12 == 7 || v9 == 7) {
          CFTypeID v14 = 7;
        }
        else {
          CFTypeID v14 = *(_DWORD *)(v11 + 24);
        }
        if (v12 == 6) {
          uint64_t v10 = 6;
        }
        else {
          uint64_t v10 = v14;
        }
      }
    }
  }

  *(_DWORD *)(v11 + 24) = v10;
}

      CFRelease(Mutable);
      CFRelease(v17);
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      if (!v13) {
        goto LABEL_12;
      }
      goto LABEL_9;
    }

  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }

  return v12;
}

        uint64_t v26 = SecPolicyCreate(v29, a4, v9);
LABEL_30:
        CFRelease(v9);
        goto LABEL_31;
      }
    }
  }

  uint64_t v26 = 0LL;
  CFIndex v11 = v9;
LABEL_31:
  CFRelease(v11);
  __int16 v27 = values;
  if (values)
  {
    values = 0LL;
    CFRelease(v27);
  }

  return v26;
}

      if (++v5 == this[1]) {
        return 0LL;
      }
    }

    if (!a5) {
      return v11;
    }
    CFTypeID v14 = *(void *)&v11[2].re_magic;
    if (!v14)
    {
      Security::Syslog::notice((Security::Syslog *)"code signing internal problem: !mTargetBlock", v13);
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18LL);
    }

    memset(v27, 170, sizeof(v27));
    std::string::basic_string[abi:ne180100]<0>(&v28, a2);
    std::string::basic_string[abi:ne180100]<0>(__p, a5);
    (*(void (**)(void **__return_ptr, uint64_t, regex_t *, void **))(v14 + 16))(v27, v14, &v28, __p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v28.re_endp) < 0) {
      operator delete(*(void **)&v28.re_magic);
    }
    char v15 = (void *)HIBYTE(v27[2]);
    if (SHIBYTE(v27[2]) < 0) {
      char v15 = v27[1];
    }
    if (v15)
    {
      uint64_t v16 = (os_log_s *)secLogObjForScope("dirval");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        if (SHIBYTE(v27[2]) >= 0) {
          char v23 = v27;
        }
        else {
          char v23 = (void **)v27[0];
        }
        v28.re_magic = 136315650;
        *(void *)(&v28.re_magic + 1) = a2;
        WORD2(v28.re_nsub) = 2080;
        *(size_t *)((char *)&v28.re_nsub + 6) = (size_t)a5;
        HIWORD(v28.re_endp) = 2080;
        v28.re_g = (re_guts *)v23;
        _os_log_debug_impl( &dword_1804F4000,  v16,  OS_LOG_TYPE_DEBUG,  "%s: match target %s against %s",  (uint8_t *)&v28,  0x20u);
      }

      *(void *)&CFErrorRef v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v28.re_magic = v17;
      *(_OWORD *)&v28.re_endp = v17;
      if (SHIBYTE(v27[2]) >= 0) {
        uint64_t v18 = v27;
      }
      else {
        uint64_t v18 = (void **)v27[0];
      }
      if (regcomp(&v28, (const char *)v18, 5))
      {
        Security::Syslog::notice( (Security::Syslog *)"code signing internal problem: failed to compile internal RE",  v19);
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18LL);
      }

      __int128 v20 = regexec(&v28, a5, 0LL, 0LL, 0);
      MEMORY[0x186DFFEA4](&v28);
      if ((_DWORD)v20)
      {
        if ((_DWORD)v20 != 1)
        {
          Security::Syslog::notice((Security::Syslog *)"code signing internal error: regexec failed error=%d", v21, v20);
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18LL);
        }

        __int128 v22 = 0;
      }

      else
      {
        __int128 v22 = 1;
      }

      if ((HIBYTE(v27[2]) & 0x80) == 0)
      {
LABEL_28:
        if ((v22 & 1) != 0) {
          return v11;
        }
        goto LABEL_29;
      }
    }

    else
    {
      __int128 v22 = 1;
      if ((HIBYTE(v27[2]) & 0x80) == 0) {
        goto LABEL_28;
      }
    }

    operator delete(v27[0]);
    goto LABEL_28;
  }

  return 0LL;
}

      *(void *)&v19.st_dev = 0LL;
      Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
      return v9;
    }

    Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
    *(void *)&v19.st_dev = 0xAAAAAAAAAAAAAAAALL;
    int v13 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
    if (v13)
    {
      *(void *)&v19.st_dev = Security::CodeSigning::BundleDiskRep::metaData(this, v13);
      if (*(void *)&v19.st_dev)
      {
        if (*((_BYTE *)this + 177))
        {
          if (*((_BYTE *)this + 176)) {
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
          }
        }

        else
        {
          *((_WORD *)this + 88) = 256;
        }

        std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>( (uint64_t *)this + 23,  a2,  (int)a2);
        CFIndex v9 = *(CFDataRef *)&v19.st_dev;
        goto LABEL_29;
      }
    }

    else
    {
      *(void *)&v19.st_dev = 0LL;
    }

    Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
  }

  return 0LL;
}

      close(v9);
      goto LABEL_30;
    }

    if ((__int16)v30.st_mode < 0)
    {
      st_size = v30.st_size;
      if (v30.st_size > 0x7FFFFFFF)
      {
        uint64_t v25 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_29;
        }
        *(_DWORD *)__int128 buf = 134217984;
        __int128 v32 = v30.st_size;
        uint64_t v12 = "ticket size was too large: %lld";
        int v13 = v25;
        CFTypeID v14 = 12;
        goto LABEL_28;
      }

      CFTypeID v21 = (UInt8 *)malloc(v30.st_size);
      if (v21)
      {
        __int128 v22 = v21;
        if (read(v9, v21, st_size) == st_size)
        {
          char v23 = CFDataCreateWithBytesNoCopy(0LL, v22, st_size, (CFAllocatorRef)*MEMORY[0x189604DB8]);
          if (cf) {
            CFRelease(cf);
          }
          CFTypeRef cf = v23;
          if (v23) {
            goto LABEL_29;
          }
          CFErrorRef v17 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_29;
          }
          *(_WORD *)__int128 buf = 0;
          uint64_t v12 = "unable to create cfdata for notarization";
        }

        else
        {
          CFErrorRef v17 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_29;
          }
          *(_WORD *)__int128 buf = 0;
          uint64_t v12 = "unable to read entire ticket from bundle";
        }
      }

      else
      {
        CFErrorRef v17 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_29;
        }
        *(_WORD *)__int128 buf = 0;
        uint64_t v12 = "unable to allocate data for ticket";
      }
    }

    else
    {
      CFErrorRef v17 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_29;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v12 = "stapling is not a regular file";
    }

    int v13 = v17;
    CFTypeID v14 = 2;
    goto LABEL_28;
  }

  if (*__error() != 2)
  {
    char v15 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *__error();
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v32) = v16;
      _os_log_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEFAULT, "cannot open stapled file for reading: %d", buf, 8u);
    }
  }

  if (v9) {
    goto LABEL_29;
  }
LABEL_30:
  uint64_t v18 = cf;
  CFTypeRef cf = 0LL;
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  if (SHIBYTE(v26[2]) < 0) {
    operator delete(v26[0]);
  }
  return v18;
}

    if (a2 == 3) {
      __int128 v20 = -67023;
    }
    else {
      __int128 v20 = -67061;
    }
    if (a2 == 1) {
      CFTypeID v21 = 4294900266LL;
    }
    else {
      CFTypeID v21 = v20;
    }
    Security::MacOSError::throwMe((Security::MacOSError *)v21);
  }

  if (*((_BYTE *)this + 176))
  {
    uint64_t v12 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    if (Security::CodeSigning::CodeDirectory::slotIsPresent(v12, -a2)) {
      goto LABEL_29;
    }
  }

  if (a2 == 7)
  {
    int v13 = (const __CFData *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, uint64_t, uint64_t))(*(void *)this + 80LL))( this,  5LL,  4294900235LL);
    if (v13)
    {
      (*(void (**)(Security::CodeSigning::SecStaticCode *, uint64_t, uint64_t))(*(void *)this + 96LL))( this,  5LL,  4294900235LL);
      CFTypeID v14 = (unsigned int *)CFDataGetBytePtr(v13);
      char v15 = bswap32(v14[1]);
      if (*v14 == 1903288058 && v15 > 7)
      {
        __int128 v22 = Security::CodeSigning::EntitlementBlob::entitlements((Security::CodeSigning::EntitlementBlob *)v14);
        if (CESerializeCFDictionary() == *MEMORY[0x1896135D8])
        {
          char v19 = Security::Blob<Security::CodeSigning::EntitlementDERBlob,4208882034u>::blobify(0LL);
          if (*v7) {
            CFRelease(*v7);
          }
          *unsigned int v7 = v19;
          CFRelease(0LL);
          Security::CFRef<__CFDictionary const*>::~CFRef(&v22);
          goto LABEL_22;
        }

        uint64_t v18 = (os_log_s *)secLogObjForScope("staticCode");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 134217984;
          uint64_t v25 = this;
          _os_log_debug_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEBUG,  "%p the XML cannot be converted to valid DER",  buf,  0xCu);
        }

        Security::CFRef<__CFDictionary const*>::~CFRef(&v22);
      }

      else
      {
        *__error() = 22;
      }
    }
  }

  Security::CFRef<__CFArray const*>::operator=(v7, *v4);
LABEL_22:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
  uint64_t v3 = *v7;
LABEL_23:
  if (v3 == *v4) {
    return 0LL;
  }
  else {
    return v3;
  }
}

void securityd_send_async_and_do(unsigned int a1, dispatch_queue_s *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0LL;
  xpc_object_t v7 = securityd_create_message(a1, &cf);
  if (v7)
  {
    uint64_t v8 = v7;
    if (!a3 || ((*(uint64_t (**)(uint64_t, xpc_object_t, CFTypeRef *))(a3 + 16))(a3, v7, &cf) & 1) != 0)
    {
      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 0x40000000LL;
      v10[2] = __securityd_send_async_and_do_block_invoke;
      unint64_t v10[3] = &unk_189664F00;
      v10[4] = a4;
      _securityd_message_with_reply_async_inner(v8, a2, v10, 4);
      xpc_release(v8);
      return;
    }

    (*(void (**)(uint64_t, void, CFTypeRef))(a4 + 16))(a4, 0LL, cf);
    xpc_release(v8);
  }

  else
  {
    (*(void (**)(uint64_t, void, CFTypeRef))(a4 + 16))(a4, 0LL, cf);
  }

  CFTypeRef v9 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v9);
  }

size_t __handle_trust_evaluate_xpc_async_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result = SecXPCDictionarySetCertificates(a2, "certificates", *(const __CFArray **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    xpc_object_t v7 = *(const __CFArray **)(a1 + 40);
    if (!v7 || (size_t result = SecXPCDictionarySetCertificates(a2, "anchors", v7, a3), (_DWORD)result))
    {
      if (*(_BYTE *)(a1 + 112)) {
        xpc_dictionary_set_BOOL(a2, "anchorsOnly", 1);
      }
      xpc_dictionary_set_BOOL(a2, "keychainsAllowed", *(_BYTE *)(a1 + 113));
      size_t result = SecXPCDictionarySetPolicies(a2, *(const __CFArray **)(a1 + 48), a3);
      if ((_DWORD)result)
      {
        uint64_t v12 = *(const __CFArray **)(a1 + 56);
        if (!v12 || (size_t result = SecXPCDictionarySetDataArray(a2, "responses", v12, a3), (_DWORD)result))
        {
          int v13 = *(const __CFArray **)(a1 + 64);
          if (!v13 || (size_t result = SecXPCDictionarySetDataArray(a2, "scts", v13, a3), (_DWORD)result))
          {
            CFTypeID v14 = *(const __CFString **)(a1 + 72);
            if (!v14
              || (size_t result = SecXPCDictionarySetPListWithRepair(a2, "trustedLogs", v14, a3, v8, v9, v10, v11),
                  (_DWORD)result))
            {
              xpc_dictionary_set_double(a2, "verifyDate", *(double *)(a1 + 80));
              char v19 = *(const __CFString **)(a1 + 88);
              if (!v19
                || (size_t result = SecXPCDictionarySetPListWithRepair(a2, "exceptions", v19, a3, v15, v16, v17, v18),
                    (_DWORD)result))
              {
                __int128 v20 = *(const __CFData **)(a1 + 96);
                if (!v20 || (size_t result = SecXPCDictionarySetData(a2, "auditToken", v20, a3), (_DWORD)result))
                {
                  xpc_dictionary_set_uint64(a2, "attribution", *(void *)(a1 + 104));
                  return 1LL;
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t SecXPCDictionarySetCertificates(void *a1, const char *a2, const __CFArray *a3, __CFString **a4)
{
  xpc_object_t v8 = xpc_array_create(0LL, 0LL);
  if (v8)
  {
    uint64_t v9 = v8;
    CFIndex Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0LL; v11 != i; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, i);
        if (ValueAtIndex)
        {
          CFTypeID v14 = (const void *)ValueAtIndex[2];
          int64_t v15 = ValueAtIndex[3];
          if (v15 < 1 || v14 == 0LL)
          {
            xpc_release(v9);
            goto LABEL_13;
          }

          xpc_array_set_data(v9, 0xFFFFFFFFFFFFFFFFLL, v14, v15);
        }
      }
    }

    xpc_dictionary_set_value(a1, a2, v9);
    xpc_release(v9);
    return 1LL;
  }

  else
  {
LABEL_13:
    SecError(-108, a4, @"failed to create xpc_array of certificates");
    return 0LL;
  }

uint64_t SecXPCDictionarySetPolicies(void *a1, const __CFArray *a2, __CFString **a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  xpc_object_t v6 = xpc_array_create(0LL, 0LL);
  if (v6)
  {
    xpc_object_t v7 = v6;
    CFTypeID TypeID = SecPolicyGetTypeID();
    validate_array_of_items(a2, (uint64_t)@"policy", TypeID, 1);
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      CFIndex v12 = 0LL;
      *(void *)&__int128 v10 = 134217984LL;
      __int128 v29 = v10;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, v12);
        if (!ValueAtIndex) {
          goto LABEL_27;
        }
        CFTypeID v14 = ValueAtIndex;
        xpc_object_t objects = 0LL;
        xpc_object_t object = 0LL;
        int64_t v15 = (const void *)ValueAtIndex[2];
        if (!v15)
        {
LABEL_14:
          char v23 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = v29;
            uint64_t v31 = v14;
            _os_log_impl(&dword_1804F4000, v23, OS_LOG_TYPE_DEFAULT, "policy 0x%lX has no _oid", buf, 0xCu);
          }

          goto LABEL_16;
        }

        CFTypeID v16 = CFGetTypeID(v15);
        if (v16 == CFStringGetTypeID()
          && (uint64_t v17 = (const void *)v14[3]) != 0LL
          && (CFTypeID v18 = CFGetTypeID(v17), v18 == CFStringGetTypeID()))
        {
          MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, (CFStringRef)v14[2]);
          if (MutableCopy)
          {
            __int128 v20 = MutableCopy;
            CFStringAppend(MutableCopy, @"++");
            CFStringAppend(v20, (CFStringRef)v14[3]);
            xpc_object_t objects = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
            CFRelease(v20);
            goto LABEL_16;
          }
        }

        else
        {
          CFTypeID v21 = (const void *)v14[2];
          if (!v21) {
            goto LABEL_14;
          }
          CFTypeID v22 = CFGetTypeID(v21);
          if (v22 != CFStringGetTypeID()) {
            goto LABEL_14;
          }
        }

        xpc_object_t objects = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
LABEL_16:
        uint64_t v24 = (const void *)v14[4];
        if (v24 && (CFTypeID v25 = CFGetTypeID(v24), v25 == CFDictionaryGetTypeID()))
        {
          xpc_object_t object = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
        }

        else
        {
          uint64_t v26 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = v29;
            uint64_t v31 = v14;
            _os_log_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEFAULT, "policy 0x%lX has no _options", buf, 0xCu);
          }
        }

        xpc_object_t v27 = xpc_array_create(&objects, 2uLL);
        if (objects) {
          xpc_release(objects);
        }
        if (object) {
          xpc_release(object);
        }
        if (!v27)
        {
          xpc_release(v7);
          goto LABEL_30;
        }

        xpc_array_append_value(v7, v27);
        xpc_release(v27);
LABEL_27:
        ++v12;
      }

      while (v11 != v12);
    }

    xpc_dictionary_set_value(a1, "policies", v7);
    xpc_release(v7);
    return 1LL;
  }

  else
  {
LABEL_30:
    SecError(-108, a3, @"failed to create xpc_array of policies", v29);
    return 0LL;
  }

uint64_t SecXPCDictionarySetDataArray(void *a1, const char *a2, const __CFArray *a3, __CFString **a4)
{
  xpc_object_t v8 = xpc_array_create(0LL, 0LL);
  if (v8)
  {
    uint64_t v9 = v8;
    CFIndex Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0LL; v11 != i; ++i)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(a3, i);
        if (ValueAtIndex)
        {
          CFTypeID v14 = ValueAtIndex;
          CFIndex Length = CFDataGetLength(ValueAtIndex);
          BytePtr = CFDataGetBytePtr(v14);
          if (Length >= 1 && BytePtr)
          {
            xpc_array_set_data(v9, 0xFFFFFFFFFFFFFFFFLL, BytePtr, Length);
          }

          else if (!SecError(-50, a4, @"invalid CFDataRef"))
          {
            xpc_release(v9);
            return 0LL;
          }
        }
      }
    }

    xpc_dictionary_set_value(a1, a2, v9);
    xpc_release(v9);
    return 1LL;
  }

  else
  {
    SecError(-108, a4, @"failed to create xpc_array");
    return 0LL;
  }

void _securityd_message_with_reply_async_inner(void *a1, dispatch_queue_s *a2, const void *a3, int a4)
{
  uint64_t uint64 = xpc_dictionary_get_uint64(a1, "operation");
  uint64_t v9 = securityd_connection_for_operation(uint64, &v14);
  xpc_retain(a1);
  dispatch_retain(a2);
  __int128 v10 = _Block_copy(a3);
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 0x40000000LL;
  handler[2] = ___securityd_message_with_reply_async_inner_block_invoke;
  handler[3] = &unk_189665070;
  int v12 = a4;
  handler[4] = v10;
  handler[5] = a1;
  handler[6] = a2;
  handler[7] = v9;
  handler[8] = uint64;
  char v13 = 0;
  xpc_connection_send_message_with_reply(v9, a1, a2, handler);
}

_xpc_connection_s *securityd_create_connection(const char *a1, int a2)
{
  if (!a1) {
    a1 = "com.apple.securityd";
  }
  mach_service = xpc_connection_create_mach_service(a1, 0LL, 0LL);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_37);
  if (a2 != -1) {
    xpc_connection_set_target_user_session_uid();
  }
  xpc_connection_resume(mach_service);
  return mach_service;
}

uint64_t SecTrustSetPinningPolicyName(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = MEMORY[0x1895F87A8];
      xpc_object_t v6 = *(dispatch_queue_s **)(a1 + 136);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
      block[3] = &__block_descriptor_tmp_49_11982;
      block[4] = a1;
      dispatch_sync(v6, block);
      xpc_object_t v7 = *(dispatch_queue_s **)(a1 + 136);
      v8[0] = v5;
      v8[1] = 0x40000000LL;
      v8[2] = __SecTrustSetPinningPolicyName_block_invoke;
      unint64_t v8[3] = &__block_descriptor_tmp_60_12005;
      unint64_t v8[4] = a1;
      v8[5] = a2;
      dispatch_sync(v7, v8);
      return 0LL;
    }
  }

  return result;
}

void __SecTrustSetPinningPolicyName_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  BOOL v2 = *(const __CFArray **)(*(void *)(a1 + 32) + 32LL);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SecTrustSetPinningPolicyName_block_invoke_2;
  context[3] = &__block_descriptor_tmp_59_12006;
  context[4] = v1;
  v4.CFIndex length = CFArrayGetCount(v2);
  v4.location = 0LL;
  CFArrayApplyFunction(v2, v4, (CFArrayApplierFunction)apply_block_1_11979, context);
}

void __SecTrustSetPinningPolicyName_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  SecPolicySetName(a2, *(CFTypeRef *)(a1 + 32));
  uint64_t v3 = (os_log_s *)secLogObjForScope("SecPinningDb");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v4;
    _os_log_debug_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEBUG, "Set %@ as name on all policies", (uint8_t *)&v5, 0xCu);
  }

void SecPolicySetName(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf)
  {
    uint64_t v4 = *(const void **)(a1 + 24);
    CFRetain(cf);
    *(void *)(a1 + 24) = cf;
    if (v4) {
      CFRelease(v4);
    }
  }

void ___securityd_message_with_reply_async_inner_block_invoke(uint64_t a1, void *a2)
{
  xpc_object_t v6 = a2;
  if (a2 == (void *)MEMORY[0x1895F9198] && (int v4 = *(_DWORD *)(a1 + 72)) != 0)
  {
    _securityd_message_with_reply_async_inner( *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 32),  (v4 - 1));
  }

  else
  {
    CFTypeRef cf = 0LL;
    _securityd_process_message_reply(&v6, &cf, *(void *)(a1 + 56), *(void *)(a1 + 64));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    CFTypeRef v3 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v3);
    }
  }

  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  _Block_release(*(const void **)(a1 + 32));
  return_securityd_connection_to_pool(*(_DWORD *)(a1 + 64), *(_BYTE *)(a1 + 76), *(_xpc_connection_s **)(a1 + 56));
}

void __securityd_send_async_and_do_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    CFTypeRef cf = 0LL;
    char v5 = securityd_message_no_error(a2, (CFErrorRef *)&cf);
    uint64_t v6 = *(void *)(a1 + 32);
    if ((v5 & 1) != 0)
    {
      (*(void (**)(uint64_t, uint64_t, void))(v6 + 16))(v6, a2, 0LL);
    }

    else
    {
      (*(void (**)(uint64_t, void, CFTypeRef))(v6 + 16))(v6, 0LL, cf);
      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v7);
      }
    }
  }

void __handle_trust_evaluate_xpc_async_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a2 || a3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    char v5 = *(const void ***)(a1 + 40);
    uint64_t v6 = *v5;
    if (*v5)
    {
      CFArrayRef v5 = 0LL;
      CFRelease(v6);
    }

    CFTypeRef v7 = *(const void ***)(a1 + 48);
    xpc_object_t v8 = *v7;
    if (*v7)
    {
      *CFTypeRef v7 = 0LL;
      CFRelease(v8);
    }

    uint64_t v9 = *(const void ***)(a1 + 56);
    __int128 v10 = *v9;
    if (*v9)
    {
      *uint64_t v9 = 0LL;
      CFRelease(v10);
    }

    CFTypeRef cf = 0LL;
    if (SecXPCDictionaryCopyArrayOptional(a2, "details", *(void **)(a1 + 40), (__CFString **)&cf)
      && SecXPCDictionaryCopyDictionaryOptional(a2, "info", *(void **)(a1 + 48), (__CFString **)&cf)
      && SecXPCDictionaryCopyChainOptional(a2, *(CFMutableArrayRef **)(a1 + 56), (__CFString **)&cf))
    {
      SecXPCDictionaryGetNonZeroInteger(a2, (__CFString **)&cf);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    CFTypeRef v11 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v11);
    }
  }

BOOL SecXPCDictionaryCopyArrayOptional(void *a1, const char *a2, void *a3, __CFString **a4)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    xpc_object_t value = (void *)SecXPCDictionaryCopyArray(a1, a2, a4);
    BOOL v9 = value != 0LL;
  }

  else
  {
    BOOL v9 = 1LL;
  }

  *a3 = value;
  return v9;
}

const void *SecXPCDictionaryCopyArray(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a1, a2, a3);
  uint64_t v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFArrayGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      SecError(-50, a3, @"object for key %s not array but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0LL;
    }
  }

  return v6;
}

CFTypeRef SecXPCDictionaryCopyPListAndPossiblyMutateMessage(void *a1, const char *a2, __CFString **a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  size_t length = 0LL;
  CFTypeRef cf = 0LL;
  data = xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    uint64_t v9 = (uint64_t)data;
    uint64_t v10 = (uint64_t)data + length;
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    if (der_decode_plist(SecCFAllocatorZeroize_sAllocator, (uint64_t)&cf, (CFTypeRef *)a3, v9, v10, v6, v7, v8) == v10)
    {
      CFTypeRef v14 = cf;
    }

    else
    {
      CFTypeRef v11 = (__CFString *)CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"trailing garbage after der decoded object for key %s",  a2);
      SecError(-50, a3, @"%@", v11);
      if (a3)
      {
        int v12 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          char v13 = *a3;
          *(_DWORD *)__int128 buf = 138412290;
          char v19 = v13;
          _os_log_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }

      __security_simulatecrash(v11, 0x53C00002u);
      if (v11) {
        CFRelease(v11);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef v14 = 0LL;
    }

    cc_clear();
  }

  else
  {
    SecError(-50, a3, @"no object for key %s", a2);
    return 0LL;
  }

  return v14;
}

const void *SecCFAllocatorDeallocate(const void *result, uint64_t a2)
{
  if (result)
  {
    CFTypeRef v3 = result;
    if (malloc_size(result)) {
      cc_clear();
    }
    return (const void *)off_18C487428(v3, a2);
  }

  return result;
}

BOOL SecXPCDictionaryCopyDictionaryOptional(void *a1, const char *a2, void *a3, __CFString **a4)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    xpc_object_t value = (void *)SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(a1, a2, a4);
    BOOL v9 = value != 0LL;
  }

  else
  {
    BOOL v9 = 1LL;
  }

  *a3 = value;
  return v9;
}

const void *SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage( void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a1, a2, a3);
  uint64_t v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFDictionaryGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      SecError(-50, a3, @"object for key %s not dictionary but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0LL;
    }
  }

  return v6;
}

unint64_t der_decode_date( const __CFAllocator *a1, CFDateRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v46 = a5;
  if (!a4)
  {
    unsigned int v40 = (const __CFString *)sSecDERErrorDomain;
    __int128 v41 = @"null input";
    CFIndex v42 = -6LL;
    goto LABEL_6;
  }

  CFAbsoluteTime at = 0.0;
  uint64_t v47 = (unsigned __int8 *)ccder_decode_constructed_tl();
  int v16 = der_decode_decimal(&v47, v46, a3, v11, v12, v13, v14, v15);
  int v22 = der_decode_decimal(&v47, v46, a3, v17, v18, v19, v20, v21) + 10 * v16;
  int v28 = der_decode_decimal(&v47, v46, a3, v23, v24, v25, v26, v27);
  int v34 = der_decode_decimal(&v47, v46, a3, v29, v30, v31, v32, v33);
  unint64_t v38 = der_decode_commontime_body(&at, a3, v34 + 10 * v28 + 100 * v22, v47, v46, v35, v36, v37);
  if (v38)
  {
    CFDateRef v39 = CFDateCreate(a1, at);
    *a2 = v39;
    if (!v39)
    {
      unsigned int v40 = (const __CFString *)sSecDERErrorDomain;
      __int128 v41 = @"Failed to create date";
      CFIndex v42 = -3LL;
LABEL_6:
      SecCFCreateErrorWithFormat(v42, v40, 0LL, a3, a5, v41, a7, a8, v44);
      return 0LL;
    }
  }

  return v38;
}

uint64_t der_decode_decimal( unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a1;
  if (*a1)
  {
    if ((unint64_t)v10 >= a2)
    {
      SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  a5,  @"Unexpected end of datetime",  a7,  a8,  v14);
      *a1 = 0LL;
    }

    else
    {
      int v12 = *v10;
      int v11 = v12;
      *a1 = v10 + 1;
    }
  }

  SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a3,  a5,  @"Not a decimal digit",  a7,  a8,  v14);
  *a1 = 0LL;
  return 0xFFFFFFFFLL;
}

unint64_t der_decode_commontime_body( double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a5;
  v114 = a4;
  int v111 = der_decode_decimal(&v114, a5, a2, (uint64_t)a4, a5, a6, a7, a8);
  int v110 = der_decode_decimal(&v114, v8, a2, v10, v11, v12, v13, v14);
  int v109 = der_decode_decimal(&v114, v8, a2, v15, v16, v17, v18, v19);
  int v25 = der_decode_decimal(&v114, v8, a2, v20, v21, v22, v23, v24);
  int v31 = der_decode_decimal(&v114, v8, a2, v26, v27, v28, v29, v30);
  int v37 = der_decode_decimal(&v114, v8, a2, v32, v33, v34, v35, v36);
  int v43 = der_decode_decimal(&v114, v8, a2, v38, v39, v40, v41, v42);
  int v49 = der_decode_decimal(&v114, v8, a2, v44, v45, v46, v47, v48);
  int v55 = der_decode_decimal(&v114, v8, a2, v50, v51, v52, v53, v54);
  int v66 = der_decode_decimal(&v114, v8, a2, v56, v57, v58, v59, v60);
  CFNumberRef v67 = 0LL;
  v68 = v114;
  double v69 = NAN;
  int v70 = *v114;
  if (v70 == 46)
  {
    v71 = v114 + 1;
    if ((unint64_t)(v114 + 1) < v8)
    {
      int v70 = *v71;
      if ((v70 - 58) < 0xFFFFFFF6)
      {
        v72 = (const __CFString *)sSecDERErrorDomain;
        CFNumberRef v73 = @"fraction without digits";
LABEL_14:
        CFIndex v75 = -1LL;
LABEL_23:
        SecCFCreateErrorWithFormat(v75, v72, 0LL, a2, v62, v73, v64, v65, v107);
        CFNumberRef v67 = 0LL;
        goto LABEL_24;
      }

      uint64_t v76 = 0LL;
      uint64_t v77 = v8 - (void)v114 - 2;
      unint64_t v78 = 1LL;
      while (v77)
      {
        int v79 = v70;
        if (v78 < 0x1999999999999999LL)
        {
          v78 *= 10LL;
          uint64_t v76 = (v70 - 48) + 10 * v76;
        }

        int v80 = *++v71;
        int v70 = v80;
        --v77;
        if ((v80 - 58) < 0xFFFFFFF6)
        {
          if (v79 == 48)
          {
            v72 = (const __CFString *)sSecDERErrorDomain;
            CFNumberRef v73 = @"fraction ends in 0";
            goto LABEL_14;
          }

          double v69 = (double)(unint64_t)v76 / (double)v78;
          v68 = v71;
          goto LABEL_8;
        }
      }
    }

    v72 = (const __CFString *)sSecDERErrorDomain;
    CFNumberRef v73 = @"overflow";
    CFIndex v75 = -8LL;
    goto LABEL_23;
  }

  double v69 = 0.0;
LABEL_8:
  if ((unint64_t)v68 >= v8)
  {
    v72 = (const __CFString *)sSecDERErrorDomain;
    CFNumberRef v73 = @"Unexpected end of datetime";
    goto LABEL_14;
  }

  CFNumberRef v67 = v68 + 1;
  v114 = v68 + 1;
  switch(v70)
  {
    case 'Z':
      double v81 = 0.0;
      goto LABEL_26;
    case '-':
      int v74 = -60;
      break;
    case '+':
      int v74 = 60;
      break;
    default:
LABEL_24:
      SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v62,  @"Invalid datetime character",  v64,  v65,  v107);
      double v81 = NAN;
      goto LABEL_25;
  }

  int v108 = v74;
  int v90 = der_decode_decimal(&v114, v8, a2, v61, v62, v63, v64, v65);
  int v107 = der_decode_decimal(&v114, v8, a2, v91, v92, v93, v94, v95) + 10 * v90;
  int v101 = der_decode_decimal(&v114, v8, a2, v96, v97, v98, v99, v100);
  double v81 = (double)(int)((der_decode_decimal(&v114, v8, a2, v102, v103, v104, v105, v106) + 10 * v101 + 60 * v107) * v108);
  CFNumberRef v67 = v114;
LABEL_25:
  if (!v67) {
    return 0LL;
  }
LABEL_26:
  if (v67 != (unsigned __int8 *)v8)
  {
    SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v62,  @"trailing garbage at end of datetime",  v64,  v65,  v107);
    return 0LL;
  }

  uint64_t v83 = (v25 + 10 * v109);
  uint64_t v84 = (v37 + 10 * v31);
  uint64_t v85 = (v49 + 10 * v43);
  v130[0] = 0;
  if ((validateDateComponents( a3,  (v110 + 10 * v111),  v83,  v84,  v85,  (v66 + 10 * v55),  v130,  (__CFString **)a2) & 1) != 0)
  {
    uint64_t v126 = 0LL;
    v127 = &v126;
    uint64_t v128 = 0x2000000000LL;
    char v129 = 0;
    int v122 = 0;
    v123 = (double *)((char *)&v121 + 4);
    uint64_t v124 = 0x2000000000LL;
    uint64_t v125 = 0LL;
    v115[0] = MEMORY[0x1895F87A8];
    v115[1] = 0x40000000LL;
    v115[2] = __SecGregorianDateGetAbsoluteTime_block_invoke;
    v115[3] = &unk_189676940;
    v115[4] = &v126;
    v115[5] = (char *)&v121 + 4;
    unsigned int v116 = a3;
    int v117 = v110 + 10 * v111;
    int v118 = v83;
    int v119 = v84;
    int v120 = v85;
    uint64_t v121 = (v66 + 10 * v55);
    SecCFCalendarDoWithZuluCalendar((uint64_t)v115);
    if (*((_BYTE *)v127 + 24))
    {
      double v89 = v123[3] - v81;
    }

    else
    {
      SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v86,  @"Failed to encode date from components",  v87,  v88,  v107);
      double v89 = NAN;
    }

    _Block_object_dispose((char *)&v121 + 4, 8);
    _Block_object_dispose(&v126, 8);
    *a1 = v89;
    *a1 = v69 + v89;
  }

  else
  {
    unint64_t v8 = 0LL;
    *a1 = NAN;
  }

  return v8;
}

uint64_t __SecGregorianDateGetAbsoluteTime_block_invoke(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarComposeAbsoluteTime( calendar,  (CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  "yMdHms",  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 52),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 60),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 68));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (_DWORD)result != 0;
  return result;
}

uint64_t SecXPCDictionaryCopyChainOptional(void *a1, CFMutableArrayRef *a2, __CFString **a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "chain");
  if (!value)
  {
    *a2 = 0LL;
    return 1LL;
  }

  uint64_t v6 = value;
  if (MEMORY[0x186E0087C]() == MEMORY[0x1895F9220])
  {
    unint64_t count = xpc_array_get_count(v6);
    if (count)
    {
      unint64_t v8 = count;
      if (count < 0x7FFFFFFFFFFFFFFFLL)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, count, MEMORY[0x189605228]);
        for (size_t i = 0LL; i != v8; ++i)
        {
          uint64_t v11 = SecCertificateCreateWithXPCArrayAtIndex(v6, i, a3);
          if (!v11)
          {
            if (Mutable) {
              CFRelease(Mutable);
            }
            return 0LL;
          }

          uint64_t v12 = v11;
          CFArrayAppendValue(Mutable, v11);
          CFRelease(v12);
        }

        if (!Mutable) {
          return 0LL;
        }
        CFMutableArrayRef v13 = *a2;
        if (*a2)
        {
          *a2 = 0LL;
          CFRelease(v13);
        }

        *a2 = Mutable;
        return 1LL;
      }

      SecError(-26275, a3, @"xpc_path array count > LONG_MAX");
    }

    else
    {
      SecError(-26275, a3, @"xpc_path array count == 0");
    }
  }

  else
  {
    SecError(-26275, a3, @"xpc_path value is not an array");
  }

  return 0LL;
}

void *SecCertificateCreateWithXPCArrayAtIndex(void *a1, size_t a2, __CFString **a3)
{
  size_t length = 0LL;
  data = xpc_array_get_data(a1, a2, &length);
  if (!data
    || length > 0x7FFFFFFFFFFFFFFELL
    || (uint64_t result = SecCertificateCreateWithBytes(*MEMORY[0x189604DB0], data, length)) == 0LL)
  {
    SecError(-50, a3, @"certificates[%zu] failed to decode", a2);
    return 0LL;
  }

  return result;
}

int64_t SecXPCDictionaryGetNonZeroInteger(void *a1, __CFString **a2)
{
  int64_t int64 = xpc_dictionary_get_int64(a1, "result");
  int64_t v4 = int64;
  if (int64)
  {
  }

  else
  {
    SecError(-26276, a2, @"object for key %s is 0", "result");
  }

  return v4;
}

void __SecTrustEvaluateFastAsync_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    uint64_t v6 = 0LL;
    CFTypeID v7 = &v6;
    uint64_t v8 = 0x2000000000LL;
    int v9 = 0;
    uint64_t v3 = *(void *)(a1 + 40);
    int64_t v4 = *(dispatch_queue_s **)(v3 + 136);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    uint64_t v5[2] = __SecTrustEvaluateFastAsync_block_invoke_2;
    v5[3] = &unk_189674FC0;
    v5[4] = &v6;
    void v5[5] = v3;
    dispatch_sync(v4, v5);
    SecTrustLogFailureDescription(*(__SecTrust **)(a1 + 40), *((_DWORD *)v7 + 6));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    _Block_object_dispose(&v6, 8);
  }

uint64_t __SecTrustEvaluateFastAsync_block_invoke_2(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 112LL);
  return result;
}

void SecTrustLogFailureDescription(__SecTrust *a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a2 != 1 && a2 != 4)
  {
    BOOL v2 = SecTrustCopyFailureDescription(a1);
    uint64_t v3 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      CFTypeRef v5 = v2;
      _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "Trust evaluate failure:%{public}@", (uint8_t *)&v4, 0xCu);
    }

    CFRelease(v2);
  }

uint64_t SecTrustReportNetworkingAnalytics(char *cStr, uint64_t a2)
{
  uint64_t v2 = 0LL;
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (cStr && a2)
  {
    CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x8000100u);
    if (v4)
    {
      CFStringRef v5 = v4;
      CFErrorRef err = 0LL;
      if (gTrustd && (uint64_t v6 = *(uint64_t (**)(CFStringRef, uint64_t, CFErrorRef *))(gTrustd + 144)) != 0LL)
      {
        uint64_t v2 = v6(v4, a2, &err);
        if (err)
        {
          CFTypeID v7 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            int Code = CFErrorGetCode(err);
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = Code;
            _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "SecTrustReportNetworkingAnalytics failed with error: %d",  buf,  8u);
          }
        }

        CFRelease(v5);
        CFErrorRef v9 = err;
        if (err)
        {
          CFErrorRef err = 0LL;
          CFRelease(v9);
        }
      }

      else
      {
        uint64_t v10 = _os_activity_create( &dword_1804F4000,  "SecTrustReportNetworkingAnalytics",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
        state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
        state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
        os_activity_scope_enter(v10, &state);
        *(void *)__int128 buf = 0LL;
        uint64_t v23 = buf;
        uint64_t v24 = 0x2000000000LL;
        char v25 = 0;
        v16[4] = buf;
        v17[0] = MEMORY[0x1895F87A8];
        v17[1] = 0x40000000LL;
        void v17[2] = __SecTrustReportNetworkingAnalytics_block_invoke;
        void v17[3] = &__block_descriptor_tmp_263;
        v17[4] = v5;
        void v17[5] = a2;
        v16[0] = MEMORY[0x1895F87A8];
        v16[1] = 0x40000000LL;
        v16[2] = __SecTrustReportNetworkingAnalytics_block_invoke_2;
        unint64_t v16[3] = &unk_189675470;
        securityd_send_sync_and_do(0x73u, (CFTypeRef *)&err, (uint64_t)v17, (uint64_t)v16);
        if (err)
        {
          uint64_t v11 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = CFErrorGetCode(err);
            *(_DWORD *)uint64_t v20 = 67109120;
            int v21 = v12;
            _os_log_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEFAULT,  "SecTrustReportNetworkingAnalytics failed with error: %d",  v20,  8u);
          }

          CFErrorRef v13 = err;
          if (err)
          {
            CFErrorRef err = 0LL;
            CFRelease(v13);
          }
        }

        CFRelease(v5);
        os_release(v10);
        uint64_t v2 = v23[24] != 0;
        _Block_object_dispose(buf, 8);
        os_activity_scope_leave(&state);
      }
    }

    else
    {
      uint64_t v14 = (os_log_s *)secLogObjForScope("SecError");
      uint64_t v2 = 0LL;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "CFStringCreateWithCString failed", buf, 2u);
        return 0LL;
      }
    }
  }

  return v2;
}

BOOL __SecTrustReportNetworkingAnalytics_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL v5 = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"eventName", *(const __CFString **)(a1 + 32), a3);
  if (v5) {
    xpc_dictionary_set_value(a2, "eventAttributes", *(xpc_object_t *)(a1 + 40));
  }
  return v5;
}

BOOL SecXPCDictionarySetString(uint64_t a1, uint64_t a2, const __CFString *a3, __CFString **a4)
{
  if (!a3) {
    return SecError(-50, a4, @"string for key %s is NULL", a2);
  }
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 1;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  _DWORD v6[2] = __SecXPCDictionarySetString_block_invoke;
  v6[3] = &unk_189676238;
  void v6[4] = &v7;
  void v6[5] = a1;
  v6[6] = a2;
  v6[7] = a4;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  unint64_t v11[2] = __CFStringPerformWithCString_block_invoke;
  unint64_t v11[3] = &unk_189676790;
  v11[4] = v6;
  CFStringPerformWithCStringAndLength(a3, (uint64_t)v11);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void CFStringPerformWithCStringAndLength(const __CFString *a1, uint64_t a2)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    BOOL v5 = CStringPtr;
    size_t v6 = strlen(CStringPtr);
    (*(void (**)(uint64_t, const char *, size_t))(a2 + 16))(a2, v5, v6);
  }

  else
  {
    CFIndex usedBufLen = 0LL;
    CFIndex Length = CFStringGetLength(a1);
    v10.location = 0LL;
    v10.size_t length = Length;
    CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, 0LL, 0LL, &usedBufLen);
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __CFStringPerformWithCStringAndLength_block_invoke;
    unint64_t v8[3] = &unk_189676768;
    void v8[6] = 0LL;
    v8[7] = Length;
    uint8_t v8[8] = usedBufLen;
    unint64_t v8[4] = a2;
    v8[5] = a1;
    PerformWithBuffer(usedBufLen + 1, (uint64_t)v8);
  }

uint64_t __CFStringPerformWithCString_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __SecXPCDictionarySetString_block_invoke(uint64_t a1, char *string)
{
  if (string) {
    xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 40), *(const char **)(a1 + 48), string);
  }
  else {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SecError( -50,  *(__CFString ***)(a1 + 56),  @"failed to convert string for key %s to utf8",  *(void *)(a1 + 48));
  }
}

size_t sec_array_get_count(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1 && v1[1] && MEMORY[0x186E0087C]() == MEMORY[0x1895F9220]) {
    size_t count = xpc_array_get_count(v2[1]);
  }
  else {
    size_t count = 0LL;
  }

  return count;
}

uint64_t sec_protocol_metadata_copy_sec_trust(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_copy_sec_trust_block_invoke;
  v3[3] = &unk_189666A80;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_sec_trust_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 168);
    if (v3)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
      uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v4) {
        os_retain(v4);
      }
    }
  }

  return a2 != 0;
}

uint64_t __SecTrustReportNetworkingAnalytics_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

void sec_release(void *obj)
{
  if (obj) {
    os_release(obj);
  }
}

BOOL sec_protocol_metadata_access_distinguished_names(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_distinguished_names_block_invoke;
    unint64_t v4[3] = &unk_189666620;
    void v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_access_distinguished_names_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a2 + 144);
  if (result)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_distinguished_names_block_invoke_2;
    unint64_t v4[3] = &unk_1896665F8;
    void v4[4] = *(void *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1LL;
  }

  return result;
}

uint64_t sec_protocol_metadata_copy_sec_identity(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_copy_sec_identity_block_invoke;
  v3[3] = &unk_189666AA8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_sec_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 160);
    if (v3)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
      uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v4) {
        os_retain(v4);
      }
    }
  }

  return a2 != 0;
}

SSLProtocol sec_protocol_metadata_get_negotiated_protocol_version(sec_protocol_metadata_t metadata)
{
  if (!metadata) {
    return 0;
  }
  uint64_t v4 = 0LL;
  BOOL v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  int v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_negotiated_protocol_version_block_invoke;
  v3[3] = &unk_1896664C8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  SSLProtocol v1 = *((_DWORD *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_negotiated_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = &word_18065475C;
    while (1)
    {
      int v4 = (unsigned __int16)*v3;
      v3 += 4;
      if (++v2 == 8)
      {
        int v5 = 0;
        goto LABEL_7;
      }
    }

    int v5 = ssl_protocol_version_map[2 * v2];
LABEL_7:
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v5;
  }

  return a2 != 0;
}

BOOL SecXPCDictionaryCopyPListOptional(void *a1, void *a2, __CFString **a3)
{
  size_t length = 0LL;
  data = xpc_dictionary_get_data(a1, "status", &length);
  if (data)
  {
    data = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a1, "status", a3);
    BOOL v7 = data != 0LL;
  }

  else
  {
    BOOL v7 = 1LL;
  }

  *a2 = data;
  return v7;
}

const UInt8 *der_decode_data( const __CFAllocator *a1, CFDataRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    int v12 = (const UInt8 *)ccder_decode_tl();
    if (v12 && (CFErrorRef v13 = v12, a5 - (uint64_t)v12 >= 0))
    {
      CFDataRef v18 = CFDataCreate(a1, v12, 0LL);
      *a2 = v18;
      if (v18) {
        return v13;
      }
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"Failed to create data";
      CFIndex v16 = -3LL;
    }

    else
    {
      uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
      uint64_t v15 = @"Unknown data encoding";
      CFIndex v16 = -1LL;
    }
  }

  else
  {
    uint64_t v14 = (const __CFString *)sSecDERErrorDomain;
    uint64_t v15 = @"null input";
    CFIndex v16 = -6LL;
  }

  SecCFCreateErrorWithFormat(v16, v14, 0LL, a3, a5, v15, a7, a8, v19);
  return 0LL;
}

uint64_t SecItemResultProcess( const __CFDictionary *a1, const __CFDictionary *a2, void *a3, const void *a4, CFTypeRef *a5, __CFString **a6)
{
  id v11 = a3;
  uint64_t v12 = 1LL;
  if (!a4 || !a5) {
    goto LABEL_22;
  }
  CFTypeID v13 = CFGetTypeID(a4);
  if (v13 != CFArrayGetTypeID())
  {
    goto LABEL_21;
  }

  CFIndex Count = CFArrayGetCount((CFArrayRef)a4);
  *a5 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  if (Count < 1)
  {
LABEL_21:
    uint64_t v12 = 1LL;
    goto LABEL_22;
  }

  CFIndex v15 = 0LL;
  while (1)
  {
    CFErrorRef err = 0LL;
    xpc_object_t value = (void *)0xAAAAAAAAAAAAAAAALL;
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, v15);
    if ((SecItemResultCopyPrepared(ValueAtIndex, v11, a1, a2, (CFTypeRef *)&value, (__CFString **)&err) & 1) != 0)
    {
      uint64_t v17 = value;
      if (value)
      {
        CFArrayAppendValue((CFMutableArrayRef)*a5, value);
LABEL_17:
        CFRelease(v17);
        goto LABEL_18;
      }

      goto LABEL_18;
    }

    if (!err) {
      goto LABEL_28;
    }
    if (!CryptoTokenKitLibraryCore()) {
      break;
    }
    if (!getTKErrorDomainSymbolLoc()) {
      break;
    }
    CFErrorDomain Domain = CFErrorGetDomain(err);
    getTKErrorDomain();
    if (!CFEqual(Domain, v19) || CFErrorGetCode(err) != -7 && CFErrorGetCode(err) != -6) {
      break;
    }
    uint64_t v17 = err;
    if (err)
    {
      CFErrorRef err = 0LL;
      goto LABEL_17;
    }

LABEL_18:
    if (Count == ++v15) {
      goto LABEL_21;
    }
  }

  if (err)
  {
    if (a6 && !*a6) {
      *a6 = (__CFString *)err;
    }
    else {
      CFRelease(err);
    }
  }

    __break(0x5513u);
    return result;
  }

  uint64_t v2 = &MFi4AccessoryCAName;
  uint64_t result = compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)&v7);
  if ((_DWORD)result)
  {
    uint64_t v2 = &MFi4AttestationCAName;
    uint64_t result = compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)&v7);
    if ((_DWORD)result) {
      return 0LL;
    }
  }

  uint64_t v3 = v2[1];
  int v4 = v7;
  if (__CFADD__(v7, v3)) {
    goto LABEL_18;
  }
  int v5 = v8;
  uint64_t result = (unint64_t)&v3[v7];
  if (!&v3[v7]) {
    return result;
  }
LABEL_11:
  uint64_t v6 = __CFADD__(v4, v5);
  if (result > 0xFFFFFFFFFFFFFFF7LL || v6) {
    goto LABEL_18;
  }
  if (v4 + v5 < result + 8) {
    return 0LL;
  }
  return result;
}

    __break(0x5519u);
    goto LABEL_19;
  }

  return result;
}

          __break(0x5519u);
          return result;
        }

  return v10;
}

    uint64_t result = (*(uint64_t (**)(void, char *))(*(void *)(v5 + 40) + 16LL))(*(void *)(v5 + 48), v4);
    if (!result) {
      goto LABEL_23;
    }
    *(_DWORD *)(result + 8) = v6;
    *(void *)(result + 16) = v4;
    *(void *)(result + 24) = v4;
    *(void *)uint64_t result = *v10;
    os_activity_s *v10 = result;
    ++*(_DWORD *)(v5 + 8);
  }

  return result;
}

  uint64_t v12 = 0LL;
LABEL_19:
  CFTypeID v13 = v6 - 1;
  do
  {
    if (v13 < 1) {
      return result;
    }
    uint64_t v14 = 0LL;
    CFIndex v15 = -(uint64_t)v13;
    CFIndex v16 = 1LL;
    uint64_t v17 = a2;
    CFDataRef v18 = a3;
    CFTypeID v13 = 0;
    do
    {
      CFTypeRef v19 = v5[v14];
      uint64_t v20 = v5[v16];
      if (*(void *)v19 == *(void *)v20)
      {
        uint64_t result = (void *)memcmp(*(const void **)(v19 + 8), *(const void **)(v20 + 8), *(void *)v19);
      }

      else if (*(void *)v19 < *(void *)v20)
      {
        goto LABEL_34;
      }

      *(int8x16_t *)&v5[v14] = vextq_s8(*(int8x16_t *)&v5[v14], *(int8x16_t *)&v5[v14], 8uLL);
      if (a2 && v16 < v21) {
        *uint64_t v17 = vextq_s8(*v17, *v17, 8uLL);
      }
      if (a3)
      {
        if (v16 < v12) {
          *CFDataRef v18 = vextq_s8(*v18, *v18, 8uLL);
        }
      }

      CFTypeID v13 = v16;
LABEL_34:
      CFDataRef v18 = (int8x16_t *)((char *)v18 + 8);
      uint64_t v17 = (int8x16_t *)((char *)v17 + 8);
      ++v16;
      ++v14;
    }

    while (v15 + v16 != 1);
  }

  while (v13);
  return result;
}

    CFIndex Length = 0LL;
    BytePtr = 0LL;
    if (a3)
    {
      CFIndex Length = CFDataGetLength(a3);
      BytePtr = CFDataGetBytePtr(a3);
      if (Length) {
        p_CFIndex Length = &Length;
      }
      else {
        p_CFIndex Length = 0LL;
      }
    }

    else
    {
      p_CFIndex Length = 0LL;
    }

    else {
      uint64_t v24 = 0LL;
    }
    goto LABEL_27;
  }

  uint64_t v22 = CFGetTypeID(a1);
LABEL_22:
  uint64_t v24 = 4294967246LL;
LABEL_27:
  SecCmsMessageDestroy((uint64_t)v12);
  return v24;
}

  if (*a2) {
    CFRelease(*a2);
  }
  uint64_t v9 = 0LL;
  *a2 = v6;
  return v9;
}

        CFIndex v16 = 0LL;
        goto LABEL_19;
      }

      CFRelease(v4);
    }

    int v4 = 0LL;
    goto LABEL_7;
  }

  return (char)trust;
}

  os_release(v6);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v20, 8);
  return v7;
}

LABEL_28:
  uint64_t v12 = 0LL;
LABEL_22:

  return v12;
}

  return v31;
}

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return CTKKey;
}

    appendError(v1, v10);
    goto LABEL_29;
  }

  return v1;
}

  uint64_t v26 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberLongType, &v30);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v26, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v29 = Mutable;
  if (cf) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x189604F88], cf);
  }
  if (v27) {
    CFDictionaryAddValue(v29, @"numberOfErrorsDeep", v27);
  }
  if (v11) {
    CFDictionaryAddValue(v29, *v12, v11);
  }
  *a4 = CFErrorCreate(v26, a2, a1, v29);
  if (v27) {
    CFRelease(v27);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (cf)
  {
    uint64_t v22 = cf;
LABEL_42:
    CFRelease(v22);
  }

    Command = Security::MachOBase::nextCommand((Security::MachOBase *)a1, (const load_command *)Command);
    if (!Command) {
      goto LABEL_57;
    }
  }

  uint64_t v17 = *(_DWORD *)(Command + 4);
  CFDataRef v18 = bswap32(v17);
  if (*(_BYTE *)(a1 + 33)) {
    uint64_t v17 = v18;
  }
  if (v17 <= 0x37) {
    goto LABEL_65;
  }
  uint64_t v33 = *(_DWORD *)(Command + 32);
  uint64_t v34 = *(_DWORD *)(Command + 36);
  uint64_t v35 = bswap32(v33);
  if (v15) {
    uint64_t v33 = v35;
  }
  uint64_t v36 = bswap32(v34);
  if (v15) {
    uint64_t v34 = v36;
  }
  uint64_t v27 = v34 + v33;
  uint64_t v28 = *(void *)(a1 + 56);
  uint64_t v29 = v28 == v27;
  uint64_t v30 = (os_log_s *)secLogObjForScope("macho");
  if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_56;
  }
  int v37 = " NOT";
  if (v28 == v27) {
    int v37 = (const char *)&unk_18065A197;
  }
  v49.st_dev = 136315138;
  *(void *)&v49.st_mode = v37;
  uint64_t v32 = "32-bit linkedit is%s valid";
LABEL_49:
  _os_log_debug_impl(&dword_1804F4000, v30, OS_LOG_TYPE_DEBUG, v32, (uint8_t *)&v49, 0xCu);
  if (v28 != v27)
  {
LABEL_57:
    uint64_t v45 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v49.st_dev) = 0;
      _os_log_impl( &dword_1804F4000,  v45,  OS_LOG_TYPE_DEFAULT,  "STRICT VALIDATION ERROR: invalid structure",  (uint8_t *)&v49,  2u);
    }

    *(_BYTE *)(a1 + 104) = 1;
  }

  return a1;
}

uint64_t SecItemResultCopyPrepared( const void *a1, void *a2, const __CFDictionary *a3, const __CFDictionary *a4, CFTypeRef *a5, __CFString **a6)
{
  id v10 = a2;
  uint64_t v106 = a4;
  CFTypeRef v107 = 0LL;
  id v11 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"r_Ref");
  if (v11) {
    BOOL v12 = CFBooleanGetValue(v11) != 0;
  }
  else {
    BOOL v12 = 0;
  }
  CFTypeID v13 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"r_Data");
  if (v13) {
    BOOL v14 = CFBooleanGetValue(v13) != 0;
  }
  else {
    BOOL v14 = 0;
  }
  CFIndex v15 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"r_Attributes");
  if (v15) {
    BOOL v101 = CFBooleanGetValue(v15) != 0;
  }
  else {
    BOOL v101 = 0;
  }
  CFIndex v16 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"r_PersistentRef");
  if (v16) {
    BOOL v102 = CFBooleanGetValue(v16) != 0;
  }
  else {
    BOOL v102 = 0;
  }
  BOOL v98 = v14;
  uint64_t v95 = (uint64_t)v10;
  if (v10)
  {
    id v17 = v10;
    CFDataRef v18 = 0LL;
    BOOL v19 = 1;
    BOOL v20 = 1;
  }

  else
  {
    CFTypeID v27 = CFGetTypeID(a1);
    if (v27 == CFDictionaryGetTypeID())
    {
      uint64_t v28 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"tkid");
      CFDataRef v18 = v28;
      if (v28 && (CFTypeID v29 = CFGetTypeID(v28), v29 != CFStringGetTypeID())
        || (BOOL v19 = v18 != 0LL, v30 = CFDictionaryGetValue((CFDictionaryRef)a1, @"certtkid"), (v31 = v30) != 0LL)
        && (v32 = CFGetTypeID(v30), v33 = v32 == CFStringGetTypeID(), BOOL v14 = v98, !v33))
      {
        SecError(-50, a6, @"Unexpected type");
        CFNumberRef v73 = 0LL;
        uint64_t v74 = 0LL;
        CFIndex v75 = 0LL;
        goto LABEL_148;
      }

      BOOL v20 = v31 != 0LL;
      if (v31) {
        goto LABEL_15;
      }
    }

    else
    {
      BOOL v20 = 0;
      BOOL v19 = 0;
      CFDataRef v18 = 0LL;
    }

    if (!v19)
    {
      if (!v14 && !v12)
      {
        CFStringRef theString = v18;
        BOOL v99 = v12;
        uint64_t v94 = (CFTypeRef *)a6;
        BOOL v20 = 0;
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
        CFTypeRef v24 = 0LL;
        CFTypeRef v25 = 0LL;
        uint64_t v26 = 0LL;
        CFIndex v75 = 0LL;
        char v93 = 0;
        goto LABEL_58;
      }

      goto LABEL_34;
    }
  }

LABEL_15:
  int v21 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"u_TokenRawItems");
  if (!v21 || !CFBooleanGetValue(v21))
  {
    if (v14 || v12) {
      goto LABEL_35;
    }
    if (v19)
    {
      BOOL v19 = 1;
      if (v101) {
        goto LABEL_35;
      }
      CFStringRef theString = v18;
      char v93 = 1;
      BOOL v99 = v12;
      uint64_t v94 = (CFTypeRef *)a6;
    }

    else
    {
      CFStringRef theString = v18;
      BOOL v99 = v12;
      uint64_t v94 = (CFTypeRef *)a6;
      char v93 = 0;
    }

    uint64_t v22 = 0LL;
    uint64_t v23 = 0LL;
    CFTypeRef v24 = 0LL;
    CFTypeRef v25 = 0LL;
    uint64_t v26 = 0LL;
    goto LABEL_57;
  }

  BOOL v19 = 0;
  if (!v14 && !v12)
  {
    CFStringRef theString = v18;
    BOOL v99 = v12;
    uint64_t v94 = (CFTypeRef *)a6;
    BOOL v20 = 0;
    uint64_t v22 = 0LL;
    uint64_t v23 = 0LL;
    CFTypeRef v24 = 0LL;
    CFTypeRef v25 = 0LL;
    uint64_t v26 = 0LL;
    char v93 = 0;
LABEL_57:
    CFIndex v75 = v10;
    goto LABEL_58;
  }

  __break(0x5519u);
  return result;
}

      uint64_t v22 = (void *)MEMORY[0x189607870];
      uint64_t v26 = a4;
      uint64_t v23 = *MEMORY[0x189607670];
      v28[0] = *MEMORY[0x1896075E0];
      v28[1] = @"missingkeys";
      v29[0] = @"Missing some required field";
      v29[1] = v21;
      objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v29, v28, 2, v26);
      CFTypeRef v24 = (void *)objc_claimAutoreleasedReturnValue();
      [v22 errorWithDomain:v23 code:-50 userInfo:v24];
      _BYTE *v27 = (id)objc_claimAutoreleasedReturnValue();

      goto LABEL_16;
    }

        [v12 objectForKeyedSubscript:@"match"];
        id v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:4 description:@"match missing"];
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
          CFDataRef v18 = v30;
          if (a5)
          {
            CFDataRef v18 = v30;
            *a5 = v18;
          }

        if ((v7 & 2) != 0) {
          goto LABEL_20;
        }
        [v6 database];
        id v10 = (void *)objc_claimAutoreleasedReturnValue();
        [v10 incrementSuccessCountForEventType:*(void *)(a1 + 40)];
        break;
      case 4LL:
        if ((*(_BYTE *)(a1 + 76) & 1) != 0) {
          goto LABEL_20;
        }
        [v15 database];
        id v10 = (void *)objc_claimAutoreleasedReturnValue();
        [v10 addRockwellDict:*(void *)(a1 + 40) userinfo:v5 toTable:@"rockwell" timestampBucket:*(unsigned int *)(a1 + 72)];
        break;
      default:
        goto LABEL_20;
    }

LABEL_20:
    [v15 database];
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue();
    [v14 end];

    WeakRetained = v15;
  }
}

  return a3;
}

  [getKCPairingChannelClass() pairingChannelInitiator:v4];
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

  return v22;
}

  [getKCPairingChannelClass() pairingChannelAcceptor:v4];
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

  return v22;
}

    uint64_t v9 = 0LL;
    goto LABEL_16;
  }

  if (![v7 length])
  {
    secLogObjForScope("SecCritical");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      BOOL v14 = "Cannot init db without schema";
      goto LABEL_14;
    }

    goto LABEL_15;
  }

  [v6 stringByStandardizingPath];
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v9 = (void *)[objc_alloc((Class)a1) initWithPath:v8 schema:v7];
  CFIndex v16 = 0LL;
  id v10 = [v9 openWithError:&v16];
  id v11 = v16;
  BOOL v12 = v11;
  if ((v10 & 1) == 0 && (!v11 || [v11 code] != 23))
  {
    secLogObjForScope("SecError");
    CFTypeID v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFDataRef v18 = v12;
      _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "SFAnalytics: could not open db at init, will try again later. Error: %@",  buf,  0xCu);
    }
  }

LABEL_16:
  return (SFAnalyticsSQLiteStore *)v9;
}

  keys[0] = @"class";
  keys[1] = @"skid";
  keys[2] = @"r_Ref";
  values[0] = (void *)a2;
  values[1] = v8;
  values[2] = *(void **)MEMORY[0x189604DE8];
  CFIndex v16 = CFDictionaryCreate(v7, (const void **)keys, (const void **)values, 3LL, 0LL, 0LL);
  if (_is_apple_mail_bundle_onceToken != -1) {
    dispatch_once(&_is_apple_mail_bundle_onceToken, &__block_literal_global_5400);
  }
  if (_is_apple_mail_bundle_result)
  {
    mail_keychain_query = _create_mail_keychain_query(v16);
    if (v16) {
      CFRelease(v16);
    }
  }

  else
  {
    mail_keychain_query = v16;
  }

  ItemInAllAvailableKeychains = CERT_FindItemInAllAvailableKeychains(mail_keychain_query);
  if (mail_keychain_query) {
    CFRelease(mail_keychain_query);
  }
  if (v8) {
LABEL_26:
  }
    CFRelease(v8);
  return ItemInAllAvailableKeychains;
}

  uint64_t v40 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v40);
  }

  return 1LL;
}

  cc_clear();
  return 0LL;
}

    BOOL v14 = SecItemAuthDoQuery(&v21, &v19, SecItemUpdate, a3, &__block_literal_global_8916);
    id v17 = cf;
    if (!cf) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  CFIndex v15 = CFDictionaryGetValue(a1, @"class");
  if (!v15 || !CFEqual(@"idnt", v15)) {
    goto LABEL_15;
  }
  CFIndex v16 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, a1);
  if (v16)
  {
    CFTypeID v13 = v16;
    CFDictionarySetValue(v16, @"class", @"cert");
    if (SecItemUpdateWithError(v13, a2, a3))
    {
      CFDictionarySetValue(v13, @"class", @"keys");
      id v10 = 0LL;
      BOOL v14 = (SecItemUpdateWithError(v13, a2, a3) & 1) != 0;
      id v11 = 0LL;
      goto LABEL_11;
    }

    id v10 = 0LL;
    id v11 = 0LL;
LABEL_24:
    BOOL v14 = 0LL;
LABEL_11:
    CFRelease(v13);
    if (!v10)
    {
LABEL_13:
      if (!v11) {
        goto LABEL_17;
      }
      id v17 = v11;
LABEL_16:
      CFRelease(v17);
      goto LABEL_17;
    }
  }

  return v11;
}

  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

    BOOL v12 = 1;
  }

  CFTypeID v13 = (const void *)*MEMORY[0x189604DE8];
  if (v12 && v13 == a3)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    goto LABEL_26;
  }

  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
  *(void *)this = v10;
  if (v16 < 0)
  {
    id v11 = *(char **)cStr;
LABEL_19:
    operator delete(v11);
  }

  return this;
}

LABEL_60:
        CFTypeID v48 = CFGetTypeID(a1);
        if (v48 == CFDictionaryGetTypeID())
        {
          uint64_t v76 = CFDictionaryGetValue((CFDictionaryRef)a1, @"v_PersistentRef");
          BOOL v14 = v98;
          if (!v76) {
            goto LABEL_66;
          }
        }

        else
        {
          uint64_t v76 = a1;
          BOOL v14 = v98;
          if (!a1)
          {
LABEL_66:
            if (v101 || v14 || v12)
            {
              BOOL v99 = v12;
              uint64_t v23 = v36;
LABEL_68:
              if (v99 || v101)
              {
                double v89 = v75;
                uint64_t v45 = v22;
                uint64_t v46 = v26;
                int v47 = 1;
              }

              else
              {
                if (!v14 || !v102)
                {
                  unint64_t v78 = 0LL;
                  id v77 = 0LL;
                  *a5 = 0LL;
                  uint64_t v74 = 1LL;
                  uint64_t v36 = v23;
                  if (!v23) {
                    goto LABEL_133;
                  }
                  goto LABEL_132;
                }

                double v89 = v75;
                uint64_t v45 = v22;
                uint64_t v46 = v26;
                int v47 = 0;
              }

  return v15;
}

  if (!v19) {
    return 1LL;
  }
  CFTypeID v41 = *((_DWORD *)v19 + 3);
  uint64_t v42 = bswap32(*((_DWORD *)v19 + 2));
  if (v6) {
    int v43 = v42;
  }
  else {
    int v43 = *((_DWORD *)v19 + 2);
  }
  CFTypeID v44 = bswap32(v41);
  if (v6) {
    uint64_t v45 = v44;
  }
  else {
    uint64_t v45 = v41;
  }
  uint64_t v46 = v43 + v45;
  if (__CFADD__(v43, (_DWORD)v45))
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE wraps around\n");
    return 0LL;
  }

  if (v46 < v34 - 7)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    return 0LL;
  }

  if (v46 > *v32)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE points past the end of the mach-o\n");
    return 0LL;
  }

  bzero((char *)v33 + v43, v45);
  void *v32 = v43;
  CFTypeID v48 = v14 - 1;
  CFTypeID v49 = bswap32(v14 - 1);
  if (v6) {
    CFTypeID v48 = v49;
  }
  *(void *)BOOL v19 = 0LL;
  *((void *)v19 + 1) = 0LL;
  int v50 = bswap32(v35 - 16);
  if (!v6) {
    int v50 = v35 - 16;
  }
  v33[4] = v48;
  v33[5] = v50;
  if (v19 + 16 < v21)
  {
    memmove(v19, v19 + 16, v21 - (v19 + 16));
    *((void *)v21 - 2) = 0LL;
    *((void *)v21 - 1) = 0LL;
  }

  int v51 = *v32;
  if (v18)
  {
    int v52 = *((_DWORD *)v18 + 8);
    int v53 = bswap32(v52);
    if (v6) {
      int v52 = v53;
    }
    int v54 = v51 - v52;
    int v55 = bswap32(v54);
    if (v6) {
      int v54 = v55;
    }
    *((_DWORD *)v18 + 9) = v54;
  }

  else
  {
    int v56 = *((void *)v17 + 5);
    uint64_t v57 = bswap64(v56);
    if (v6) {
      int v56 = v57;
    }
    uint64_t v58 = v51 - v56;
    uint64_t v59 = bswap64(v58);
    if (v6) {
      uint64_t v58 = v59;
    }
    *((void *)v17 + 6) = v58;
  }

  return 1LL;
}

          uint64_t v42 = v52;
          *((_DWORD *)v52 + 52) = *(_DWORD *)(a1 + 208) & 0x20010000;
          Security::CodeSigning::SecStaticCode::detachedSignature(v42, *(const __CFData **)(a1 + 136));
          (*(void (**)(uint64_t, Security::CodeSigning::SecStaticCode *))(a2 + 16))(a2, v52);
          Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v52);
          uint64_t v8 = v46;
LABEL_61:
          int v43 = *(void **)(v7 + 8);
          if (v43)
          {
            do
            {
              CFTypeID v44 = (void **)v43;
              int v43 = (void *)*v43;
            }

            while (v43);
          }

          else
          {
            do
            {
              CFTypeID v44 = *(void ***)(v7 + 16);
              uint64_t v45 = *v44 == (void *)v7;
              BOOL v7 = (uint64_t)v44;
            }

            while (!v45);
          }

          BOOL v7 = (uint64_t)v44;
          if (v44 == &v59) {
            goto LABEL_67;
          }
        }

        uint64_t v36 = memcmp(__p, v28, __n) == 0;
        goto LABEL_47;
      }
    }

  BOOL v60 = 4294967246LL;
LABEL_61:

  Security::CFRef<__SecCertificate *>::~CFRef(&cf);
  if ((_DWORD)v60) {
    Security::MacOSError::throwMe((Security::MacOSError *)v60);
  }
  uint64_t v22 = v102;
  BOOL v102 = 0LL;
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v102);
  return v22;
}

LABEL_72:
              CFTypeID v49 = CFGetTypeID(a1);
              if (v49 == CFDictionaryGetTypeID()) {
                MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, (CFDictionaryRef)a1);
              }
              else {
                MutableCopy = CFDictionaryCreateForCFTypes(0LL, v50, v51, v52, v53, v54, v55, v56, 0LL, v88);
              }
              uint64_t v58 = MutableCopy;
              *a5 = MutableCopy;
              if (v98)
              {
                uint64_t v59 = v24;
                if (v24)
                {
LABEL_77:
                  CFDictionarySetValue(MutableCopy, @"v_Data", v59);
                  goto LABEL_82;
                }
              }

              else
              {
                uint64_t v59 = v24;
                BOOL v60 = v99;
                if (!v24) {
                  BOOL v60 = 0;
                }
                if (v60) {
                  goto LABEL_77;
                }
              }

              CFDictionaryRemoveValue(MutableCopy, @"v_Data");
LABEL_82:
              char v61 = !v102;
              if (!v76) {
                char v61 = 1;
              }
              if ((v61 & 1) != 0)
              {
                CFDictionaryRemoveValue(v58, @"v_PersistentRef");
                if (!v47) {
                  goto LABEL_86;
                }
              }

              else
              {
                CFDictionarySetValue(v58, @"v_PersistentRef", v76);
                if (!v47)
                {
LABEL_86:
                  id v77 = 0LL;
                  unint64_t v78 = 0LL;
                  uint64_t v36 = v23;
                  uint64_t v26 = v46;
                  uint64_t v22 = v45;
                  CFIndex v75 = v89;
                  goto LABEL_115;
                }
              }

              if (v20 && (uint64_t v62 = CFDictionaryGetValue(v58, @"class")) != 0LL && CFEqual(v62, @"idnt"))
              {
                uint64_t v63 = CFDictionaryGetValue(v58, @"certdata");
                uint64_t v26 = v46;
                if (v63)
                {
                  uint64_t v36 = SecTokenItemValueCopy(v63, v94);
                  if (v23) {
                    CFRelease(v23);
                  }
                  uint64_t v22 = v45;
                  if (!v36)
                  {
                    uint64_t v74 = 0LL;
                    id v77 = 0LL;
                    unint64_t v78 = 0LL;
                    CFIndex v75 = v89;
                    goto LABEL_133;
                  }

                  uint64_t v64 = (void *)CFDictionaryGetValue(v36, @"data");
                  id v77 = v64;
                  CFIndex v75 = v89;
                  if (!v64 || (CFRetain(v64), CFTypeID v65 = CFGetTypeID(v77), v65 == CFDataGetTypeID()))
                  {
                    int v66 = CFDictionaryGetValue(v36, @"oid");
                    unint64_t v78 = v66;
                    if (v66)
                    {
                      CFRetain(v66);
                      CFTypeID v67 = CFGetTypeID(v78);
                      if (v67 != CFDataGetTypeID())
                      {
                        SecError(-50, (__CFString **)v94, @"Unexpected type");
                        uint64_t v74 = 0LL;
                        goto LABEL_132;
                      }
                    }

                    if (v77)
                    {
LABEL_100:
                      CFDictionarySetValue(v58, @"certdata", v77);
LABEL_106:
                      if ((v93 & 1) != 0 || (v68 = CFDictionaryGetValue(v58, @"accc"), v22 == v68))
                      {
                        if (!v22) {
                          goto LABEL_115;
                        }
                      }

                      else
                      {
                        double v69 = v68;
                        if (!v68)
                        {
                          CFRelease(v22);
                          uint64_t v22 = 0LL;
                          goto LABEL_115;
                        }

                        CFRetain(v68);
                        if (v22) {
                          CFRelease(v22);
                        }
                        uint64_t v22 = v69;
                      }

                      int v70 = SecAccessControlCreateFromData( (const __CFAllocator *)*MEMORY[0x189604DB0],  (const __CFData *)v22,  (__CFString **)v94);
                      if (!v70) {
                        goto LABEL_184;
                      }
                      v71 = v70;
                      CFDictionarySetValue(v58, @"accc", v70);
                      CFRelease(v71);
LABEL_115:
                      if (!v99) {
                        goto LABEL_131;
                      }
                      xpc_object_t value = (void *)0xAAAAAAAAAAAAAAAALL;
                      if (SecTokenItemCreateFromAttributes( v58,  v106,  v75,  v26,  (uint64_t *)&value,  (__CFString **)v94))
                      {
                        v72 = value;
                        if (v101 || v98 || v102)
                        {
                          if (value)
                          {
                            CFDictionarySetValue(v58, @"v_Ref", value);
                            CFRelease(v72);
                            if (!v98) {
                              CFDictionaryRemoveValue(v58, @"v_Data");
                            }
                          }
                        }

                        else
                        {
                          if (*a5) {
                            CFRelease(*a5);
                          }
                          *a5 = v72;
                        }

                        goto LABEL_131;
                      }

LABEL_184:
                      uint64_t v74 = 0LL;
                      if (!v36)
                      {
LABEL_133:
                        if (cf) {
                          CFRelease(cf);
                        }
                        if (v78) {
                          CFRelease(v78);
                        }
                        if (v77) {
                          CFRelease(v77);
                        }
                        if (v22) {
                          CFRelease(v22);
                        }
                        if (!v24) {
                          goto LABEL_143;
                        }
                        goto LABEL_142;
                      }

LABEL_132:
                      CFRelease(v36);
                      goto LABEL_133;
                    }

                    if (!v95)
                    {
                      uint64_t v95 = SecTokenSessionCreate(theString, &v106, (__CFString **)v94);
                      if (!v95)
                      {
                        uint64_t v74 = 0LL;
                        id v77 = 0LL;
                        uint64_t v95 = 0LL;
                        goto LABEL_132;
                      }
                    }

                    id v104 = 0LL;
                    [v89 objectForObjectID:v78 error:&v104];
                    uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue();
                    uint64_t v85 = (__CFString *)v104;
                    uint64_t v86 = v85;
                    if (!v94 || v84)
                    {
                      if (v84)
                      {
                        [v84 value];
                        theStringa = v86;
                        id v77 = (id)objc_claimAutoreleasedReturnValue();

                        if (!v77)
                        {
                          CFDictionaryRemoveValue(v58, @"certdata");
                          goto LABEL_106;
                        }

                        goto LABEL_100;
                      }
                    }

                    else
                    {
                      uint64_t v87 = v85;

                      *uint64_t v94 = v87;
                    }

                    uint64_t v74 = 0LL;
                    id v77 = 0LL;
                    goto LABEL_132;
                  }

                  SecError(-50, (__CFString **)v94, @"Unexpected type");
                  uint64_t v74 = 0LL;
LABEL_165:
                  unint64_t v78 = 0LL;
                  goto LABEL_132;
                }

                unint64_t v78 = 0LL;
                id v77 = 0LL;
                uint64_t v36 = v23;
              }

              else
              {
                unint64_t v78 = 0LL;
                id v77 = 0LL;
                uint64_t v36 = v23;
                uint64_t v26 = v46;
              }

              uint64_t v22 = v45;
              CFIndex v75 = v89;
              goto LABEL_106;
            }

            if (v76) {
              CFRetain(v76);
            }
            unint64_t v78 = 0LL;
            id v77 = 0LL;
            *a5 = v76;
LABEL_131:
            uint64_t v74 = 1LL;
            if (!v36) {
              goto LABEL_133;
            }
            goto LABEL_132;
          }
        }

        CFRetain(v76);
        goto LABEL_66;
      }

      BOOL v99 = v12;
      uint64_t v23 = v36;
LABEL_58:
      CFTypeRef cf = v25;
      if (!v102)
      {
        uint64_t v76 = 0LL;
        goto LABEL_68;
      }

      uint64_t v36 = v23;
      BOOL v12 = v99;
      goto LABEL_60;
    }
  }

  CFRetain(v24);
  if (!v19) {
    goto LABEL_49;
  }
  uint64_t v35 = SecTokenItemValueCopy(v24, (CFTypeRef *)a6);
  if (v35)
  {
    uint64_t v36 = v35;
    int v37 = CFDictionaryGetValue(v35, @"oid");
    uint64_t v26 = v37;
    if (v37)
    {
      CFRetain(v37);
      uint64_t v38 = v26;
      CFTypeID v39 = CFGetTypeID(v26);
      BOOL v33 = v39 == CFDataGetTypeID();
      uint64_t v26 = v38;
      if (!v33)
      {
        SecError(-50, a6, @"Unexpected type");
        uint64_t v74 = 0LL;
        CFIndex v75 = v10;
        uint64_t v76 = 0LL;
        id v77 = 0LL;
        unint64_t v78 = 0LL;
        CFTypeRef cf = 0LL;
        uint64_t v22 = 0LL;
        goto LABEL_132;
      }
    }

    uint64_t v40 = CFDictionaryGetValue(v36, @"ac");
    uint64_t v22 = v40;
    if (v40 && (CFRetain(v40), CFTypeID v41 = CFGetTypeID(v22), v41 != CFDataGetTypeID()))
    {
      SecError(-50, a6, @"Unexpected type");
      uint64_t v74 = 0LL;
      CFIndex v75 = v10;
    }

    else
    {
      uint64_t v42 = CFDictionaryGetValue(v36, @"data");
      if (v42)
      {
        int v43 = v42;
        CFRetain(v42);
        CFTypeRef cf = v43;
        CFTypeID v44 = CFGetTypeID(v43);
        if (v44 != CFDataGetTypeID())
        {
          SecError(-50, a6, @"Unexpected type");
          uint64_t v74 = 0LL;
          CFIndex v75 = v10;
          uint64_t v76 = 0LL;
          id v77 = 0LL;
          goto LABEL_165;
        }

        uint64_t v94 = (CFTypeRef *)a6;
        CFIndex v75 = v10;
        goto LABEL_168;
      }

      uint64_t v94 = (CFTypeRef *)a6;
      BOOL v14 = v98;
      if (!v98 && !v12)
      {
        CFTypeRef cf = 0LL;
        CFIndex v75 = v10;
        goto LABEL_173;
      }

      BOOL v100 = v12;
      CFIndex v75 = v10;
      if (!v10)
      {
        SecTokenSessionCreate(theString, &v106, (__CFString **)v94);
        CFIndex v75 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v75)
        {
          uint64_t v74 = 0LL;
          uint64_t v76 = 0LL;
          id v77 = 0LL;
          unint64_t v78 = 0LL;
          uint64_t v95 = 0LL;
          CFTypeRef cf = 0LL;
          goto LABEL_132;
        }
      }

      id v105 = 0LL;
      [v75 objectForObjectID:v26 error:&v105];
      int v80 = (void *)objc_claimAutoreleasedReturnValue();
      id v81 = v105;
      v82 = v81;
      if (!v94 || v80)
      {
        if (v80)
        {
          [v80 value];
          int v90 = v82;
          id v83 = (id)objc_claimAutoreleasedReturnValue();

          CFTypeRef cf = v83;
          BOOL v12 = v100;
LABEL_168:
          BOOL v14 = v98;
          if (v24 == cf)
          {
            CFTypeRef v25 = v24;
            goto LABEL_50;
          }

          if (cf) {
            CFRetain(cf);
          }
          else {
            CFTypeRef cf = 0LL;
          }
LABEL_173:
          CFRelease(v24);
          CFTypeRef v25 = cf;
          CFTypeRef v24 = cf;
          goto LABEL_50;
        }
      }

      else
      {
        *uint64_t v94 = v81;
      }

      uint64_t v74 = 0LL;
    }

    uint64_t v76 = 0LL;
    id v77 = 0LL;
    unint64_t v78 = 0LL;
    CFTypeRef cf = 0LL;
    goto LABEL_132;
  }

  uint64_t v26 = 0LL;
  CFIndex v75 = v10;
  uint64_t v76 = 0LL;
  uint64_t v74 = 0LL;
LABEL_142:
  CFRelease(v24);
LABEL_143:
  if (v76) {
    CFRelease(v76);
  }
  if (v26) {
    CFRelease(v26);
  }
  CFNumberRef v73 = (void *)v95;
LABEL_148:
  if (v107) {
    CFRelease(v107);
  }

  return v74;
}

  return v19;
}

void SecCertificateDestroy(void *a1)
{
  uint64_t v2 = (void *)a1[46];
  if (v2)
  {
    free(v2);
    a1[46] = 0LL;
  }

  uint64_t v3 = (void *)a1[43];
  if (v3)
  {
    free(v3);
    a1[43] = 0LL;
  }

  int v4 = (const void *)a1[58];
  if (v4)
  {
    a1[58] = 0LL;
    CFRelease(v4);
  }

  int v5 = (const void *)a1[59];
  if (v5)
  {
    a1[59] = 0LL;
    CFRelease(v5);
  }

  uint64_t v6 = (const void *)a1[60];
  if (v6)
  {
    a1[60] = 0LL;
    CFRelease(v6);
  }

  BOOL v7 = (void *)a1[65];
  if (v7)
  {
    free(v7);
    a1[65] = 0LL;
  }

  uint64_t v8 = (const void *)a1[68];
  if (v8)
  {
    a1[68] = 0LL;
    CFRelease(v8);
  }

  uint64_t v9 = (const void *)a1[69];
  if (v9)
  {
    a1[69] = 0LL;
    CFRelease(v9);
  }

  id v10 = (const void *)a1[70];
  if (v10)
  {
    a1[70] = 0LL;
    CFRelease(v10);
  }

  id v11 = (const void *)a1[71];
  if (v11)
  {
    a1[71] = 0LL;
    CFRelease(v11);
  }

  BOOL v12 = (const void *)a1[72];
  if (v12)
  {
    a1[72] = 0LL;
    CFRelease(v12);
  }

  CFTypeID v13 = (const void *)a1[73];
  if (v13)
  {
    a1[73] = 0LL;
    CFRelease(v13);
  }

  BOOL v14 = (const void *)a1[74];
  if (v14)
  {
    a1[74] = 0LL;
    CFRelease(v14);
  }

  CFIndex v15 = (const void *)a1[75];
  if (v15)
  {
    a1[75] = 0LL;
    CFRelease(v15);
  }

  CFIndex v16 = (const void *)a1[76];
  if (v16)
  {
    a1[76] = 0LL;
    CFRelease(v16);
  }

  id v17 = (const void *)a1[77];
  if (v17)
  {
    a1[77] = 0LL;
    CFRelease(v17);
  }

  CFDataRef v18 = (const void *)a1[61];
  if (v18)
  {
    a1[61] = 0LL;
    CFRelease(v18);
  }

  BOOL v19 = (const void *)a1[62];
  if (v19)
  {
    a1[62] = 0LL;
    CFRelease(v19);
  }

void SecTrustDestroy(void *a1)
{
  uint64_t v2 = (dispatch_object_s *)a1[17];
  if (v2)
  {
    a1[17] = 0LL;
    dispatch_release(v2);
  }

  uint64_t v3 = (dispatch_object_s *)a1[21];
  if (v3)
  {
    a1[21] = 0LL;
    dispatch_release(v3);
  }

  int v4 = (const void *)a1[2];
  if (v4)
  {
    a1[2] = 0LL;
    CFRelease(v4);
  }

  int v5 = (const void *)a1[4];
  if (v5)
  {
    a1[4] = 0LL;
    CFRelease(v5);
  }

  uint64_t v6 = (const void *)a1[5];
  if (v6)
  {
    a1[5] = 0LL;
    CFRelease(v6);
  }

  BOOL v7 = (const void *)a1[6];
  if (v7)
  {
    a1[6] = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = (const void *)a1[7];
  if (v8)
  {
    a1[7] = 0LL;
    CFRelease(v8);
  }

  uint64_t v9 = (const void *)a1[8];
  if (v9)
  {
    a1[8] = 0LL;
    CFRelease(v9);
  }

  id v10 = (const void *)a1[3];
  if (v10)
  {
    a1[3] = 0LL;
    CFRelease(v10);
  }

  id v11 = (const void *)a1[9];
  if (v11)
  {
    a1[9] = 0LL;
    CFRelease(v11);
  }

  BOOL v12 = (const void *)a1[10];
  if (v12)
  {
    a1[10] = 0LL;
    CFRelease(v12);
  }

  CFTypeID v13 = (const void *)a1[11];
  if (v13)
  {
    a1[11] = 0LL;
    CFRelease(v13);
  }

  BOOL v14 = (const void *)a1[12];
  if (v14)
  {
    a1[12] = 0LL;
    CFRelease(v14);
  }

  CFIndex v15 = (const void *)a1[13];
  if (v15)
  {
    a1[13] = 0LL;
    CFRelease(v15);
  }

  CFIndex v16 = (const void *)a1[18];
  if (v16)
  {
    a1[18] = 0LL;
    CFRelease(v16);
  }

  id v17 = (void *)a1[15];
  if (v17) {
    free(v17);
  }
  CFDataRef v18 = (void *)a1[16];
  if (v18) {
    free(v18);
  }
}

uint64_t SecKeyDestroy(uint64_t result)
{
  SSLProtocol v1 = *(uint64_t (**)(void))(*(void *)(result + 16) + 32LL);
  if (v1) {
    return v1();
  }
  return result;
}

void SecRSAPublicKeyDestroy(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    cc_clear();
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
  }

void lastErrorReleaseError(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t get_aks_client_connection()
{
  if (get_aks_client_dispatch_queue_onceToken != -1) {
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  }
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_150);
  uint64_t result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }

  return result;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection) {
    get_aks_client_connection_connection = _copy_aks_client_connection( "IOService:/IOResources/AppleKeyStore",  "AppleKeyStore");
  }
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("aks-client-queue", 0LL);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  kern_return_t v7;
  CFDictionaryRef v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;
  connect = 0;
  mach_port_t v3 = *MEMORY[0x1896086B0];
  io_service_t v4 = IORegistryEntryFromPath(*MEMORY[0x1896086B0], path);
  int v5 = (task_port_t *)MEMORY[0x1895FBBE0];
  if (!v4 || (v6 = v4, BOOL v7 = IOServiceOpen(v4, *MEMORY[0x1895FBBE0], 0, &connect), IOObjectRelease(v6), v7))
  {
    uint64_t v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      id v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }

  dispatch_queue_t result = connect;
  if (connect)
  {
    BOOL v12 = IOConnectCallMethod(connect, 0, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
    dispatch_queue_t result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0LL;
    }
  }

  return result;
}

uint64_t aks_unlock_bag(int a1, uint64_t a2, int a3)
{
  input[3] = *MEMORY[0x1895F89C0];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    return IOConnectCallMethod(aks_client_connection, 0xCu, input, 3u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_unlock_bag",  ":",  807,  "",  0,  "",  "");
    return 3758097084LL;
  }

uint64_t aks_create_bag(uint64_t a1, int a2, unsigned int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0LL, 0, a3, -1, a4);
}

uint64_t _create_bag(uint64_t a1, int a2, uint64_t a3, int a4, unsigned int a5, int a6, _DWORD *a7)
{
  input[6] = *MEMORY[0x1895F89C0];
  uint64_t v14 = 3758097084LL;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a7)
    {
      input[0] = a5;
      input[1] = a6;
      input[2] = a1;
      input[3] = a2;
      uint64_t input[4] = a3;
      input[5] = a4;
      uint64_t output = 0LL;
      uint32_t outputCnt = 1;
      uint64_t v14 = IOConnectCallMethod(aks_client_connection, 2u, input, 6u, 0LL, 0LL, &output, &outputCnt, 0LL, 0LL);
      if (!(_DWORD)v14) {
        *a7 = output;
      }
    }

    else
    {
      return 3758097090LL;
    }
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "_create_bag",  ":",  187,  "",  0,  "",  "");
  }

  return v14;
}

uint64_t aks_load_bag(const void *a1, int a2, _DWORD *a3)
{
  output[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = 3758097084LL;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v6 = 3758097090LL;
    if (a1)
    {
      if (a3)
      {
        output[0] = 0LL;
        uint32_t outputCnt = 1;
        uint64_t v6 = IOConnectCallMethod(aks_client_connection, 6u, 0LL, 0, a1, a2, output, &outputCnt, 0LL, 0LL);
        if (!(_DWORD)v6) {
          *a3 = output[0];
        }
      }
    }
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_load_bag",  ":",  574,  "",  0,  "",  "");
  }

  return v6;
}

uint64_t aks_unload_bag(int a1)
{
  input[1] = *MEMORY[0x1895F89C0];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 4u, input, 1u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_unload_bag",  ":",  612,  "",  0,  "",  "");
    return 3758097084LL;
  }

uint64_t aks_save_bag(uint64_t a1)
{
  int v1 = MEMORY[0x1895F8858](a1);
  mach_port_t v3 = v2;
  int v5 = v4;
  int v6 = v1;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v8 = aks_client_connection;
    uint64_t result = 3758097090LL;
    if (v5)
    {
      if (v3)
      {
        bzero(__src, 0x8000uLL);
        __size_t count = 0x8000LL;
        uint64_t input = v6;
        uint64_t result = IOConnectCallMethod(v8, 3u, &input, 1u, 0LL, 0LL, 0LL, 0LL, __src, &__count);
        if (!(_DWORD)result)
        {
          id v10 = calloc(__count, 1uLL);
          void *v5 = v10;
          if (v10)
          {
            memcpy(v10, __src, __count);
            uint64_t result = 0LL;
            _DWORD *v3 = __count;
          }

          else
          {
            return 3758097085LL;
          }
        }
      }
    }
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_save_bag",  ":",  646,  "",  0,  "",  "");
    return 3758097084LL;
  }

  return result;
}

uint64_t aks_get_lock_state(int a1, _DWORD *a2)
{
  input[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = 3758097084LL;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t output = 0LL;
      input[0] = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 7u, input, 1u, 0LL, 0LL, &output, &outputCnt, 0LL, 0LL);
      if (!(_DWORD)v4) {
        *a2 = output;
      }
    }

    else
    {
      return 3758097090LL;
    }
  }

  else
  {
    fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_get_lock_state",  ":",  824,  "",  0,  "",  "");
  }

  return v4;
}

uint64_t aks_assert_hold(int a1, unsigned int a2, uint64_t a3)
{
  input[3] = *MEMORY[0x1895F89C0];
  input[0] = a2;
  input[1] = a3;
  uint64_t input[2] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Au, input, 3u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }
  fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_assert_hold",  ":",  1654,  "",  0,  "",  "");
  return 3758097084LL;
}

uint64_t aks_assert_drop(int a1, unsigned int a2)
{
  uint64_t input[2] = *MEMORY[0x1895F89C0];
  input[0] = a2;
  input[1] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Bu, input, 2u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }
  fprintf( (FILE *)*MEMORY[0x1895F89E0],  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_assert_drop",  ":",  1672,  "",  0,  "",  "");
  return 3758097084LL;
}

uint64_t amfi_interface_cdhash_in_trustcache(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = 22LL;
  if (a1 && a2 == 20 && a3)
  {
    *a3 = 0LL;
    uint64_t result = __sandbox_ms();
    if ((_DWORD)result) {
      return *__error();
    }
    else {
      *a3 = 0LL;
    }
  }

  return result;
}

BOOL amfi_developer_mode_status()
{
  uint64_t v2 = 0LL;
  size_t v3 = 8LL;
  return !sysctlbyname("security.mac.amfi.developer_mode_status", &v2, &v3, 0LL, 0LL) && v2 == 1;
}

uint64_t amfi_launch_constraint_matches_process(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = (int *)a4;
  v7[128] = *MEMORY[0x1895F89C0];
  if (a2 && a3)
  {
    if (a3 <= 0x4000)
    {
      bzero(v7, 0x400uLL);
      int v6 = 5;
      if (!v4) {
        uint64_t v4 = &v6;
      }
    }

    else if (a4)
    {
      uint64_t result = 0LL;
      *(_DWORD *)a4 = 5;
      strcpy((char *)(a4 + 4), "Constraint too large");
      return result;
    }
  }

  else if (a4)
  {
    uint64_t result = 0LL;
    *(_DWORD *)a4 = 5;
    strcpy((char *)(a4 + 4), "No Constraint provided");
    return result;
  }

  return 0LL;
}

uint64_t ccder_encode_extension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  uint64_t result = ccder_blob_encode_body_tl();
  if (!(_DWORD)result) {
    return 0LL;
  }
  if (!a5) {
    goto LABEL_6;
  }
  uint64_t v9 = a6[1];
  if (v9)
  {
    a6[1] = v9 - 1;
    *(_BYTE *)(v9 - 1) = -1;
    if (ccder_blob_encode_tl())
    {
LABEL_6:
    }

    return 0LL;
  }

  __break(0x5513u);
  return result;
}

uint64_t ccder_sizeof_extension(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = ccder_sizeof();
  uint64_t v5 = ccder_sizeof();
  if (a3) {
    uint64_t result = ccder_sizeof();
  }
  else {
    uint64_t result = 0LL;
  }
  if (!__CFADD__(result, v5) && !__CFADD__(result + v5, v4)) {
    return ccder_sizeof();
  }
  __break(0x5500u);
  return result;
}

uint64_t CTDecompressComputeBufferSize(unint64_t a1, unint64_t a2, void *a3)
{
  return CTDecompressGeneric(a1, a2, a3, 0LL, 0LL);
}

uint64_t CTDecompressGeneric( unint64_t a1, unint64_t a2, void *a3, unint64_t a4, unint64_t a5)
{
  uint64_t v97 = *MEMORY[0x1895F89C0];
  uint64_t v6 = 393217LL;
  if (a1 && a2)
  {
    uint64_t v85 = a3;
    int v11 = *(unsigned __int8 *)a1;
    *(void *)&__int128 v87 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v87 + 1) = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v84 = ~a4;
    if (~a4 < a5) {
      goto LABEL_241;
    }
    unint64_t v12 = a4 + a5;
    if (a4 + a5 < a4) {
      goto LABEL_240;
    }
    *(void *)&__int128 v87 = a4;
    *((void *)&v87 + 1) = a4 + a5;
    if (a4) {
      CFTypeID v13 = (unint64_t *)&v87;
    }
    else {
      CFTypeID v13 = 0LL;
    }
    uint64_t v86 = 0LL;
    if ((v11 - 2) >= 2 && (v11 - 162) >= 2)
    {
      id v83 = v13;
      unint64_t v20 = 0LL;
    }

    else
    {
      *(void *)char v93 = 0LL;
      *(void *)&v92[0] = 0LL;
      uint64_t Signature = CTDecompressGetSignature(v11, a1, a2, (unint64_t *)v92, v93);
      if ((_DWORD)Signature) {
        return Signature;
      }
      unint64_t v15 = CTNonVariableCompressedSizeForStyle(v11);
      unint64_t v16 = a2 - v15;
      if (a2 < v15 || (unint64_t v5 = v16 - *(void *)v93, v16 < *(void *)v93))
      {
        __break(0x5515u);
        goto LABEL_204;
      }

      id v83 = v13;
      if (__CFADD__(*(void *)&v92[0], *(void *)v93)) {
        goto LABEL_241;
      }
      unint64_t v17 = *(void *)&v92[0] + *(void *)v93;
      if (!((uint64_t)(*(void *)&v92[0] + *(void *)v93 - a1) >= 0
           ? *(void *)&v92[0] + *(void *)v93 >= a1
           : *(void *)&v92[0] + *(void *)v93 < a1))
        goto LABEL_241;
      unint64_t v19 = ccder_sizeof_extension(v5, 10LL, 0);
      unint64_t v20 = v19;
      if (a4)
      {
        if (*((void *)&v87 + 1) - (void)v87 < v19) {
          return 393220LL;
        }
        if (a1 + a2 < v17 || v17 < a1 || v5 > a1 + a2 - v17) {
          goto LABEL_240;
        }
      }
    }

    if (v11 > 160)
    {
      if (v11 != 163 && v11 != 161) {
        goto LABEL_45;
      }
    }

    else if (v11 != 1 && v11 != 3)
    {
LABEL_45:
      unint64_t v28 = ccder_sizeof_extension(32LL, 10LL, 1);
      uint64_t v29 = 72LL;
      if ((~v11 & 0xA0) == 0) {
        uint64_t v29 = 70LL;
      }
      uint64_t Signature = 393217LL;
      if ((v29 | 0x20uLL) > a2) {
        return Signature;
      }
      unint64_t v5 = v28;
      if (!a4)
      {
        if (__CFADD__(a1, v29)) {
          goto LABEL_241;
        }
LABEL_95:
        BOOL v23 = __CFADD__(v20, v5);
        v20 += v5;
        if (v23) {
          goto LABEL_245;
        }
LABEL_47:
        a3 = &leaf_5280_extensions_template;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            int v25 = 0;
            uint64_t v26 = &ca_5280_extensions_template;
            unint64_t v27 = 33LL;
            unint64_t v5 = 102LL;
            goto LABEL_65;
          }

          unsigned int v24 = v11 - 164;
        }

        else
        {
          unsigned int v24 = v11 - 4;
          if (v11 < 4)
          {
            int v25 = 0;
            uint64_t v26 = &ca_5280_extensions_template;
            unint64_t v27 = 33LL;
            unint64_t v5 = 104LL;
            goto LABEL_65;
          }
        }

        uint64_t Signature = 393218LL;
        if (v24 >= 2) {
          return Signature;
        }
        a3 = &ca_5280_extensions_template;
        uint64_t v26 = &CTOidAppleMFI4ProductPlanUID;
        int v25 = 1;
        unint64_t v27 = 97LL;
        unint64_t v5 = 78LL;
LABEL_65:
        uint64_t Signature = 393217LL;
        if (v5 + 20 > a2) {
          return Signature;
        }
        if (a4)
        {
          unint64_t v30 = v87;
          if (*((void *)&v87 + 1) - (void)v87 < v27) {
            return 393220LL;
          }
          int v80 = v25;
          v92[0] = v87;
          BOOL v23 = v26 >= (_BYTE *)a3;
          unint64_t v34 = v26 - (_BYTE *)a3;
          if (!v23 || v27 > v34) {
            goto LABEL_240;
          }
          unint64_t v74 = v27;
          unint64_t v77 = *((void *)&v87 + 1);
          if (v80)
          {
            unint64_t v90 = 0xAAAAAAAAAAAAAAAALL;
            unint64_t v91 = 0xAAAAAAAAAAAAAAAALL;
            if (v77 >= 0xFFFFFFFFFFFFFFD1LL) {
              goto LABEL_241;
            }
            if (v77 < 0x2F || v30 > v77 - 47) {
              goto LABEL_240;
            }
            unint64_t v90 = v30;
            unint64_t v91 = v77 - 47;
            if (__CFADD__(a1, v5)) {
              goto LABEL_241;
            }
            a3 = (void *)(a1 + v5);
            if (a1 + v5 < a1 || a2 - v5 < 0x14) {
              goto LABEL_240;
            }
            if ((ccder_blob_encode_body() & 1) == 0) {
              return 393226LL;
            }
            unint64_t v5 = v30;
            memset(v93, 170, 20);
            uint64_t Signature = CTDecompressCAComputeSKID(a1, a2, (uint64_t)v93);
            if ((_DWORD)Signature) {
              return Signature;
            }
            if (v5 > v77 - 16) {
              goto LABEL_240;
            }
            unint64_t v88 = v5;
            unint64_t v89 = v77 - 16;
          }

          else
          {
            if (__CFADD__(a1, v5)) {
              goto LABEL_241;
            }
            a3 = (void *)(a1 + v5);
            if (a1 + v5 < a1 || a2 - v5 < 0x14) {
              goto LABEL_240;
            }
          }

          if ((ccder_blob_encode_body() & 1) == 0) {
            return 393226LL;
          }
          if (__CFADD__(v20, v74)) {
            goto LABEL_245;
          }
          if ((ccder_blob_encode_tl() & 1) == 0) {
            return 393220LL;
          }
          ccder_sizeof();
          if ((ccder_blob_encode_tl() & 1) == 0) {
            return 393220LL;
          }
        }

        else
        {
          if (__CFADD__(v20, v27)) {
            goto LABEL_245;
          }
          ccder_sizeof();
        }

        unint64_t v5 = ccder_sizeof();
        uint64_t v86 = v5;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            unint64_t v33 = 37LL;
            goto LABEL_109;
          }

          unsigned int v32 = v11 - 164;
        }

        else
        {
          unsigned int v32 = v11 - 4;
          if (v11 < 4)
          {
            unint64_t v33 = 39LL;
            goto LABEL_109;
          }
        }

        uint64_t Signature = 393218LL;
        if (v32 >= 2) {
          return Signature;
        }
        unint64_t v33 = 45LL;
LABEL_109:
        uint64_t Signature = 393217LL;
        if (v33 + 33 > a2) {
          return Signature;
        }
        if (a4 && *((void *)&v87 + 1) - (void)v87 < 0x5BuLL) {
          return 393220LL;
        }
        unint64_t v35 = ~a1;
        if (v33 > ~a1) {
          goto LABEL_241;
        }
        unint64_t v36 = a1 + v33;
        if (v36 < a1) {
          goto LABEL_240;
        }
        unint64_t v81 = a1 + a2;
        if (a1 + a2 - v36 <= 0x20) {
          goto LABEL_240;
        }
        *(void *)&v92[0] = v36;
        *((void *)&v92[0] + 1) = 33LL;
        char v96 = -86;
        *(void *)&__int128 v37 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v37 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v95 = v37;
        *(_OWORD *)&v93[16] = v37;
        __int128 v94 = v37;
        *(_OWORD *)char v93 = v37;
        uint64_t Signature = decompressECPublicKey((uint64_t)v92, (int **)&CTOidSECP256r1, (uint64_t)v93, 65LL);
        if ((_DWORD)Signature) {
          return Signature;
        }
        if (a4)
        {
          uint64_t Signature = 393226LL;
        }

        uint64_t v86 = 91LL;
        unint64_t v38 = v5 + 91;
        uint64_t Signature = 393218LL;
        if (v5 >= 0xFFFFFFFFFFFFFFA5LL) {
          goto LABEL_245;
        }
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            a3 = &attestation_leaf_subject;
            CFTypeID v39 = &attestation_ca_subject;
            uint64_t v40 = 14LL;
            uint64_t v41 = 64LL;
            unint64_t v42 = 164LL;
            unint64_t v5 = 37LL;
            uint64_t v43 = 33LL;
            goto LABEL_130;
          }

          a3 = &attestation_ca_subject;
          CFTypeID v39 = &root_subject;
          uint64_t v40 = 58LL;
          unint64_t v42 = 108LL;
        }

        else
        {
          if (v11 < 4)
          {
            a3 = &mfi_leaf_subject;
            CFTypeID v39 = &mfi_ca_subject;
            uint64_t v40 = 17LL;
            uint64_t v41 = 32LL;
            unint64_t v42 = 119LL;
            unint64_t v5 = 1LL;
            uint64_t v43 = 16LL;
            goto LABEL_130;
          }

          a3 = &mfi_ca_subject;
          CFTypeID v39 = &attestation_leaf_subject;
          uint64_t v40 = 57LL;
          unint64_t v42 = 107LL;
        }

        unint64_t v5 = 37LL;
        uint64_t v43 = 8LL;
        uint64_t v41 = 8LL;
LABEL_130:
        uint64_t Signature = 393217LL;
        if (v5 + v43 > a2) {
          return Signature;
        }
        if (a4)
        {
          unint64_t v44 = v87;
          if (*((void *)&v87 + 1) - (void)v87 < v42) {
            return 393220LL;
          }
          uint64_t v75 = v40;
          size_t v78 = v43;
          unint64_t v73 = v41;
          unint64_t v71 = v38;
          unint64_t v72 = *((void *)&v87 + 1);
          unint64_t v70 = v42;
          if (__CFADD__(*((void *)&v87 + 1), v75)) {
            goto LABEL_241;
          }
          uint64_t v76 = (char *)(*((void *)&v87 + 1) + v75);
          BOOL v45 = (uint64_t)&v76[-v44] >= 0 ? (unint64_t)v76 >= v44 : (unint64_t)v76 < v44;
          if (!v45 || v5 > v35) {
            goto LABEL_241;
          }
          uint64_t v46 = (const void *)(a1 + v5);
          if (a1 + v5 < a1
            || (unint64_t)v76 > v72
            || v44 > (unint64_t)v76
            || v73 > v72 - (unint64_t)v76
            || (unint64_t)v46 > v81
            || v78 > v81 - (unint64_t)v46)
          {
            goto LABEL_240;
          }

          if (v11 > 159)
          {
            if ((v11 - 160) < 4)
            {
              unint64_t v90 = a1 + v5;
              unint64_t v91 = v78;
              char v96 = -86;
              *(void *)&__int128 v50 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
              __int128 v95 = v50;
              *(_OWORD *)&v93[16] = v50;
              __int128 v94 = v50;
              *(_OWORD *)char v93 = v50;
              uint64_t Signature = decompressECPublicKey((uint64_t)&v90, (int **)&CTOidSECP256r1, (uint64_t)v93, 65LL);
              if ((_DWORD)Signature) {
                goto LABEL_156;
              }
              ccsha256_di();
              memset(v92, 0, sizeof(v92));
              ccdigest();
              CFTypeID v48 = v92;
              uint64_t v49 = 32LL;
LABEL_155:
              uint64_t Signature = CTConvertByteArrayToAsciiHex((unint64_t)v48, v49, v76, v73);
LABEL_156:
              unint64_t v42 = v70;
              unint64_t v38 = v71;
              if ((_DWORD)Signature) {
                return Signature;
              }
              goto LABEL_162;
            }

            unsigned int v47 = v11 - 164;
          }

          else
          {
            unsigned int v47 = v11 - 4;
            if (v11 < 4)
            {
              CFTypeID v48 = (_OWORD *)(a1 + v5);
              uint64_t v49 = v78;
              goto LABEL_155;
            }
          }

          uint64_t Signature = 393218LL;
          if (v47 >= 2) {
            return Signature;
          }
          if (v78 > v73) {
            goto LABEL_240;
          }
          memcpy(v76, v46, v78);
          unint64_t v42 = v70;
          unint64_t v38 = v71;
        }

LABEL_162:
        uint64_t v86 = v42;
        if (__CFADD__(v38, v42)) {
          goto LABEL_245;
        }
        unint64_t v79 = v38 + v42;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
LABEL_169:
            int v55 = 0LL;
            int v54 = 0LL;
            char v52 = 1;
            unint64_t v5 = 9LL;
            unint64_t v53 = 23LL;
LABEL_170:
            if (v5 + 14 > a2) {
              return 393217LL;
            }
            uint64_t Signature = 393217LL;
            if (v53 + 14 <= a2)
            {
              if (v5 > v35) {
                goto LABEL_241;
              }
              if ((v52 & 1) != 0)
              {
                if (v53 > v35) {
                  goto LABEL_241;
                }
                unint64_t v56 = a1 + v53;
                int v55 = (const char *)(a1 + a2);
                int v54 = (void *)a1;
              }

              else
              {
                unint64_t v56 = (unint64_t)v54;
              }

              *(void *)char v93 = 0LL;
              if (v56 <= (unint64_t)v55 && (unint64_t)v54 <= v56 && (uint64_t)&v55[-v56] > 13)
              {
                uint64_t Signature = CTDecompressDate(v56, v83, (unint64_t *)v93);
                if ((_DWORD)Signature) {
                  return Signature;
                }
                unint64_t v57 = a1 + v5;
                if (a1 + v5 >= a1 && (uint64_t)(v81 - v57) >= 14)
                {
                  uint64_t v58 = *(void *)v93;
                  uint64_t Signature = CTDecompressDate(v57, v83, (unint64_t *)v93);
                  if ((_DWORD)Signature) {
                    return Signature;
                  }
                  if (__CFADD__(v58, *(void *)v93)) {
                    goto LABEL_245;
                  }
                  if (a4 && (ccder_blob_encode_tl() & 1) == 0) {
                    return 393220LL;
                  }
                  uint64_t v86 = ccder_sizeof();
                  unint64_t v59 = v79 + v86;
                  if (__CFADD__(v79, v86)) {
                    goto LABEL_245;
                  }
                  uint64_t Signature = CTDecompressIssuer(v11, a1, a2, v83, (unint64_t *)&v86);
                  if ((_DWORD)Signature) {
                    return Signature;
                  }
                  BOOL v23 = __CFADD__(v59, v86);
                  unint64_t v60 = v59 + v86;
                  if (v23) {
                    goto LABEL_245;
                  }
                  if (a4)
                  {
                    if (*((void *)&v87 + 1) - (void)v87 < 0xCuLL) {
                      return 393220LL;
                    }
                  }

                  uint64_t v86 = 12LL;
                  BOOL v23 = __CFADD__(v60, 12LL);
                  unint64_t v61 = v60 + 12;
                  if (v23) {
                    goto LABEL_245;
                  }
                  uint64_t Signature = CTDecompressSerialNumber(v11, (_OWORD *)a1, a2, v83, (unint64_t *)&v86);
                  if ((_DWORD)Signature) {
                    return Signature;
                  }
                  BOOL v23 = __CFADD__(v61, v86);
                  unint64_t v5 = v61 + v86;
                  if (v23) {
                    goto LABEL_245;
                  }
                  if (a4)
                  {
                    if (*((void *)&v87 + 1) - (void)v87 < 5uLL) {
                      return 393220LL;
                    }
                    if ((ccder_blob_encode_body() & 1) != 0)
                    {
                      uint64_t v86 = 5LL;
                      if (v5 >= 0xFFFFFFFFFFFFFFFBLL) {
                        goto LABEL_245;
                      }
LABEL_205:
                      size_t v62 = ccder_sizeof();
                      *(void *)char v93 = 0LL;
                      *(void *)&v92[0] = 0LL;
                      uint64_t Signature = CTDecompressGetSignature(v11, a1, a2, (unint64_t *)v92, v93);
                      if ((_DWORD)Signature) {
                        return Signature;
                      }
                      if (*(void *)v93 == -1LL) {
                        goto LABEL_245;
                      }
                      size_t v82 = v62 + 12;
                      if (v62 >= 0xFFFFFFFFFFFFFFF4LL || __CFADD__(v82, ccder_sizeof())) {
                        goto LABEL_245;
                      }
                      unint64_t v63 = ccder_sizeof_tl();
                      unint64_t v5 = v63;
                      if (a4)
                      {
                        unint64_t v64 = v63 + v62;
                        if (__CFADD__(v63, v62)) {
                          goto LABEL_245;
                        }
                        if (v64 > a5) {
                          return 393220LL;
                        }
                        if (v63 > v84) {
                          goto LABEL_241;
                        }
                        CFTypeID v65 = (const void *)*((void *)&v87 + 1);
                        if (!((uint64_t)(*((void *)&v87 + 1) - a4) >= 0
                             ? *((void *)&v87 + 1) >= a4
                             : *((void *)&v87 + 1) < a4))
                          goto LABEL_241;
                        *(void *)&__int128 v87 = a4;
                        *((void *)&v87 + 1) = a4 + a5;
                        unint64_t v67 = a4 + v63;
                        if (a4 + v63 > v12 || v67 < a4 || v62 > v12 - v67) {
                          goto LABEL_240;
                        }
                        memmove((void *)(a4 + v63), v65, v62);
                        if (v64 >= 0xFFFFFFFFFFFFFFF4LL) {
                          goto LABEL_245;
                        }
                        if (v64 + 12 > a5) {
                          return 393220LL;
                        }
                        if (__CFADD__(v67, v62)) {
                          goto LABEL_241;
                        }
                        unint64_t v68 = v67 + v62;
                        if (v12 < v67 + v62 || v68 < a4 || v12 - (v67 + v62) < 0xC) {
                          goto LABEL_240;
                        }
                        *(_DWORD *)(v68 + 8) = 33752125;
                        *(void *)unint64_t v68 = 0xCE48862A08060A30LL;
                      }

                      uint64_t Signature = CTDecompressSignature(v11, a1, a2, v83, (unint64_t *)&v86);
                      if ((_DWORD)Signature) {
                        return Signature;
                      }
                      a3 = (void *)(v82 + v86);
                      if (__CFADD__(v82, v86)) {
                        goto LABEL_245;
                      }
                      if (!a4) {
                        goto LABEL_242;
                      }
                      double v69 = (char *)a3 + v5;
                      if (__CFADD__(v5, a3)) {
                        goto LABEL_245;
                      }
                      uint64_t Signature = 393220LL;
                      if (v5 <= v84)
                      {
                        if (a4 + v5 <= v12 && a4 + v5 >= a4)
                        {
                          *(void *)&__int128 v87 = a4;
                          *((void *)&v87 + 1) = a4 + v5;
                          if ((ccder_blob_encode_tl() & 1) == 0) {
                            return 393226LL;
                          }
                          goto LABEL_243;
                        }

                        goto LABEL_240;
                      }

LABEL_241:
                      __break(0x5513u);
LABEL_242:
                      double v69 = (char *)a3 + v5;
                      if (!__CFADD__(a3, v5))
                      {
LABEL_243:
                        if (v85)
                        {
                          uint64_t Signature = 0LL;
                          *uint64_t v85 = v69;
                          return Signature;
                        }

                        return 0LL;
                      }

LABEL_245:
                      __break(0x5500u);
                      return 0LL;
                    }

                    return 393226LL;
                  }

LABEL_204:
                  uint64_t v86 = 5LL;
                  if (v5 >= 0xFFFFFFFFFFFFFFFBLL) {
                    goto LABEL_245;
                  }
                  goto LABEL_205;
                }
              }

LABEL_240:
              __break(0x5519u);
              goto LABEL_241;
            }

            return Signature;
          }

          unsigned int v51 = v11 - 164;
        }

        else
        {
          unsigned int v51 = v11 - 4;
          if (v11 < 4)
          {
            char v52 = 0;
            unint64_t v53 = 0LL;
            int v54 = &endOfTime;
            int v55 = nibbleToAsciiByte;
            unint64_t v5 = 25LL;
            goto LABEL_170;
          }
        }

        uint64_t Signature = 393218LL;
        if (v51 >= 2) {
          return Signature;
        }
        goto LABEL_169;
      }

      if (*((void *)&v87 + 1) - (void)v87 >= v28)
      {
        if (__CFADD__(a1, v29)) {
          goto LABEL_241;
        }
        if (a1 + v29 < a1 || a2 - v29 < 0x20) {
          goto LABEL_240;
        }
      }

      return 393220LL;
    }

    unint64_t v21 = ccder_sizeof_extension(36LL, 10LL, 0);
    uint64_t v22 = 124LL;
    if ((~v11 & 0xA0) == 0) {
      uint64_t v22 = 122LL;
    }
    uint64_t Signature = 393217LL;
    if (v22 + 36 > a2) {
      return Signature;
    }
    unint64_t v5 = v21;
    if (a4)
    {
      if (*((void *)&v87 + 1) - (void)v87 < v21) {
        return 393220LL;
      }
      if (__CFADD__(a1, v22)) {
        goto LABEL_241;
      }
      if (a1 + v22 < a1 || a2 - v22 < 0x24) {
        goto LABEL_240;
      }
    }

    else if (__CFADD__(a1, v22))
    {
      goto LABEL_241;
    }

    BOOL v23 = __CFADD__(v20, v5);
    v20 += v5;
    if (v23) {
      goto LABEL_245;
    }
    goto LABEL_45;
  }

  return v6;
}

uint64_t CTDecompress(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return CTDecompressGeneric(a1, a2, 0LL, a3, a4);
}

uint64_t CTCompressComputeBufferSize(unint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_16:
    __break(0x5519u);
  }

  if (a1 + a2 < a1) {
    goto LABEL_16;
  }
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v30 = v6;
  __int128 v31 = v6;
  __int128 v28 = v6;
  __int128 v29 = v6;
  __int128 v26 = v6;
  __int128 v27 = v6;
  __int128 v24 = v6;
  __int128 v25 = v6;
  __int128 v22 = v6;
  __int128 v23 = v6;
  __int128 v20 = v6;
  __int128 v21 = v6;
  __int128 v18 = v6;
  __int128 v19 = v6;
  unint64_t v16[3] = v6;
  __int128 v17 = v6;
  v16[1] = v6;
  v16[2] = v6;
  v16[0] = v6;
  v15[0] = a1;
  v15[1] = a1 + a2;
  uint64_t v7 = X509CertificateParse((unint64_t *)v16, v15);
  if ((_DWORD)v7) {
    return v7;
  }
  uint64_t v7 = 393218LL;
  int v9 = CTCompressedStyleFromCert((uint64_t)v16);
  if (v9 == 255) {
    return v7;
  }
  int v10 = v9;
  uint64_t result = CTNonVariableCompressedSizeForStyle(v9);
  if (result < 0) {
    return v7;
  }
  uint64_t v11 = result + v17;
  if (!__CFADD__(result, (void)v17))
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t result = CTParseExtensionValue(a1, a2, &CTOidAppleMFI4AccessoryData, 0xAuLL, &v13, &v14);
    if ((_DWORD)result) {
      return result;
    }
    BOOL v12 = __CFADD__(v11, v14);
    v11 += v14;
    if (!v12)
    {
LABEL_13:
      uint64_t v7 = 0LL;
      if (a3) {
        *a3 = v11;
      }
      return v7;
    }
  }

  __break(0x5500u);
  return result;
}

uint64_t CTCompressedStyleFromCert(uint64_t a1)
{
  unint64_t v11[2] = *MEMORY[0x1895F89C0];
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  if (*(_BYTE *)(a1 + 265))
  {
    X509PolicySetFlagsForCommonNames(a1);
    uint64_t v3 = *(void *)(a1 + 240);
    if ((v3 & 0x400000000LL) != 0)
    {
      int v4 = 0;
LABEL_12:
      else {
        return v4 | 4u;
      }
    }

    if ((v3 & 0x800000000LL) != 0)
    {
      int v4 = 160;
      goto LABEL_12;
    }

    return 255LL;
  }

  if ((~*(void *)(a1 + 240) & 0xC00000000LL) != 0) {
    return 255LL;
  }
  if (compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)v11))
  {
    int v5 = 160;
  }

  else
  {
    int v5 = 0;
  }

  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  int v6 = CTParseExtensionValue(*(void *)a1, *(void *)(a1 + 8), &CTOidAppleMFI4AccessoryData, 0xAuLL, &v9, &v10);
  int v7 = CTParseExtensionValue(*(void *)a1, *(void *)(a1 + 8), &CTOidAppleMFI4ProductPlanUID, 0xAuLL, &v9, &v10);
  unsigned int v8 = v5 | 2;
  if (v6) {
    unsigned int v8 = v5;
  }
  if (!v7) {
    unsigned int v8 = v5 | 1;
  }
  if (v7 | v6) {
    return v8;
  }
  else {
    return v5 | 3u;
  }
}

uint64_t CTNonVariableCompressedSizeForStyle(int a1)
{
  uint64_t result = 124LL;
  switch(a1)
  {
    case 0:
    case 2:
      return result;
    case 1:
    case 3:
      uint64_t result = 160LL;
      break;
    case 4:
    case 5:
LABEL_6:
      uint64_t result = 98LL;
      break;
    default:
      switch(a1)
      {
        case 160:
        case 162:
          uint64_t result = 122LL;
          break;
        case 161:
        case 163:
          uint64_t result = 158LL;
          break;
        case 164:
        case 165:
          goto LABEL_6;
        default:
          uint64_t result = -1LL;
          break;
      }

      break;
  }

  return result;
}

uint64_t CTCompress(unint64_t a1, uint64_t a2, _BYTE *a3, size_t a4)
{
  v39[2] = *MEMORY[0x1895F89C0];
  size_t v33 = 0LL;
  uint64_t result = CTCompressComputeBufferSize(a1, a2, &v33);
  uint64_t v9 = result;
  if ((_DWORD)result) {
    return v9;
  }
  uint64_t v9 = 393220LL;
  if (!a4 || v33 > a4) {
    return v9;
  }
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v31 = v10;
  __int128 v32 = v10;
  __int128 v29 = v10;
  __int128 v30 = v10;
  __int128 v27 = v10;
  __int128 v28 = v10;
  __int128 v25 = v10;
  __int128 v26 = v10;
  v23[2] = v10;
  __int128 v24 = v10;
  v23[0] = v10;
  v23[1] = v10;
  __int128 v21 = v10;
  __int128 v22 = v10;
  *(_OWORD *)__src = v10;
  *(_OWORD *)__n = v10;
  v18[1] = v10;
  void v18[2] = v10;
  v18[0] = v10;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2)) {
    goto LABEL_47;
  }
  unint64_t v16 = a1;
  unint64_t v17 = a1 + a2;
  uint64_t v11 = X509CertificateParse((unint64_t *)v18, &v16);
  if ((_DWORD)v11) {
    return v11;
  }
  bzero(a3, a4);
  uint64_t result = CTCompressedStyleFromCert((uint64_t)v18);
  if ((_DWORD)result == 255) {
    return 393218LL;
  }
  *a3 = result;
  if ((result & 4) == 0)
  {
    if ((~(_DWORD)result & 0xA0) != 0) {
      uint64_t result = CTCompressMFiLeaf((uint64_t)v18, (unint64_t)a3, a4);
    }
    else {
      uint64_t result = CTCompressAttestationLeaf((unint64_t *)v18, (unint64_t)a3, a4);
    }
    goto LABEL_20;
  }

  if (a3 != (_BYTE *)-1LL)
  {
    uint64_t result = CTCompressGetCommonNameSuffixPointer((unint64_t *)v23 + 1);
    if (!result)
    {
      uint64_t v9 = 393224LL;
      goto LABEL_23;
    }

    if (a4 < 9)
    {
LABEL_23:
      bzero(a3, a4);
      return v9;
    }

    *(void *)(a3 + 1) = *(void *)result;
    if ((unint64_t)(a3 + 1) <= 0xFFFFFFFFFFFFFFF7LL)
    {
      memset(v35, 170, sizeof(v35));
      uint64_t result = X509CertificateParseValidity((uint64_t)v18);
      if ((_DWORD)result) {
        goto LABEL_20;
      }
      memset(v39, 170, 14);
      uint64_t result = CTGetGeneralizedTime((uint64_t)&v35[2], (unint64_t)v39);
      if ((_DWORD)result) {
        goto LABEL_20;
      }
      if (a4 < 0x17) {
        goto LABEL_18;
      }
      *(void *)(a3 + 9) = v39[0];
      *(void *)(a3 + 15) = *(void *)((char *)v39 + 6);
      if ((unint64_t)(a3 + 9) <= 0xFFFFFFFFFFFFFFF1LL)
      {
        uint64_t result = CTGetGeneralizedTime((uint64_t)v35, (unint64_t)v39);
        if ((_DWORD)result) {
          goto LABEL_20;
        }
        if (a4 < 0x25) {
          goto LABEL_18;
        }
        *(void *)(a3 + 23) = v39[0];
        *(void *)(a3 + 29) = *(void *)((char *)v39 + 6);
        uint64_t result = CTCompressGetCommonNameSuffixPointer((unint64_t *)&v22 + 1);
        if (!result)
        {
          uint64_t result = 393224LL;
          goto LABEL_20;
        }

        if (a4 < 0x2D)
        {
LABEL_18:
          uint64_t result = 393220LL;
          goto LABEL_20;
        }

        *(void *)(a3 + 37) = *(void *)result;
        char v38 = -86;
        *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v36 = v12;
        __int128 v37 = v12;
        memset(v34, 170, sizeof(v34));
        uint64_t result = X509CertificateParseSPKI((unint64_t *)&v21 + 1, 0LL, (unint64_t *)v34, &v34[2]);
        if ((_DWORD)result) {
          goto LABEL_20;
        }
        uint64_t result = compressECPublicKey(&v34[2], v34, (uint64_t)&v36, 33LL);
        if ((_DWORD)result) {
          goto LABEL_20;
        }
        if (a4 < 0x4E) {
          goto LABEL_18;
        }
        __int128 v13 = v37;
        *(_OWORD *)(a3 + 45) = v36;
        *(_OWORD *)(a3 + 61) = v13;
        a3[77] = v38;
        if ((unint64_t)(a3 + 45) <= 0xFFFFFFFFFFFFFFDELL)
        {
          uint64_t result = 393221LL;
          if (!*((void *)&v24 + 1) || (void)v25 != 20LL) {
            goto LABEL_20;
          }
          if (a4 < 0x62) {
            goto LABEL_18;
          }
          __int128 v14 = **((_OWORD **)&v24 + 1);
          *(_DWORD *)(a3 + 94) = *(_DWORD *)(*((void *)&v24 + 1) + 16LL);
          *(_OWORD *)(a3 + 78) = v14;
          if ((unint64_t)(a3 + 78) <= 0xFFFFFFFFFFFFFFEBLL)
          {
            uint64_t result = 655619LL;
            if (__src[1])
            {
              size_t v15 = __n[0];
              if (__n[0] - 73 >= 0xFFFFFFFFFFFFFFFDLL)
              {
                uint64_t result = 393220LL;
                if (__n[0] + 98 <= a4)
                {
                  uint64_t result = (uint64_t)memcpy(a3 + 98, __src[1], __n[0]);
                  if (!__CFADD__(a3 + 98, v15))
                  {
                    uint64_t result = 0LL;
                    goto LABEL_20;
                  }

                  goto LABEL_47;
                }
              }
            }

LABEL_20:
            uint64_t v9 = result;
            if (!(_DWORD)result) {
              return 0LL;
            }
            goto LABEL_23;
          }
        }
      }
    }
  }

    __break(0x5519u);
  }

  return result;
}

    [v21 addObject:@"receiverPeerID"];
    if (v12)
    {
LABEL_12:
      if (v15) {
        goto LABEL_13;
      }
      goto LABEL_22;
    }

    int v7 = 0;
    goto LABEL_23;
  }

  if (!v4 || ![v4 count]) {
    goto LABEL_20;
  }
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  unint64_t v16 = 0u;
  unint64_t v17 = 0u;
  size_t v15 = v4;
  [v4 allValues];
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v9 = [v8 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v9)
  {
    __int128 v10 = v9;
    int v7 = 0;
    uint64_t v11 = *(void *)v17;
    do
    {
      for (size_t i = 0LL; i != v10; ++i)
      {
        if (*(void *)v17 != v11) {
          objc_enumerationMutation(v8);
        }
        __int128 v13 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        if (([v13 isEqualToString:@"have_prerecord"] & 1) != 0
          || ([v13 isEqualToString:@"pending_passcode"] & 1) != 0
          || [v13 isEqualToString:@"pending_certificate"])
        {
          int v7 = 1;
        }
      }

      __int128 v10 = [v8 countByEnumeratingWithState:&v16 objects:v21 count:16];
    }

    while (v10);
  }

  else
  {
    int v7 = 0;
  }

  int v4 = v15;
LABEL_23:

  return v7 & 1;
}

  [MEMORY[0x189604030] fileURLWithPath:v3 isDirectory:0];
  __int128 v19 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
  int v4 = v19;
  if (!v19)
  {
    int v5 = 0LL;
    int v7 = 0LL;
    goto LABEL_14;
  }

  __int128 v20 = CFBundleCopyInfoDictionaryForURL(v19);
  int v5 = v20;
  if (v20)
  {
    __int128 v21 = -[__CFDictionary objectForKeyedSubscript:](v20, "objectForKeyedSubscript:", @"CFBundleVisibleComponentName");
    if (v21
      || ([v5 objectForKeyedSubscript:@"CFBundleDisplayName"],
          (__int128 v21 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      int v7 = (id)v21;
      goto LABEL_14;
    }

    [v5 objectForKeyedSubscript:@"CFBundleName"];
    int v7 = (id)objc_claimAutoreleasedReturnValue();
    if (v7) {
      goto LABEL_14;
    }
  }

  __int128 v23 = 0LL;
  __int128 v22 = [v4 getResourceValue:&v23 forKey:*MEMORY[0x189603D00] error:0];
  int v6 = v23;
  int v7 = 0LL;
  if (v22)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      int v7 = 0LL;
      goto LABEL_13;
    }

    goto LABEL_3;
  }

  if (v9 != 3)
  {
LABEL_25:
    __int128 v13 = v12;
    __int128 v14 = *v6;
    if (0xFFFFFFFF - v10 < v12)
    {
LABEL_26:
      ThreadErrInfo = PR_getThreadErrInfo(1, &v17);
      if (ThreadErrInfo) {
        *ThreadErrInfo = 0xFFFFE00900000000LL;
      }
      int v5 = 0LL;
      *(_DWORD *)(*(void *)a1 + 24LL) = 1;
      return v5;
    }

    goto LABEL_29;
  }

  if ((v10 & 7) != 0) {
    goto LABEL_26;
  }
  if (v12 >> 61) {
    goto LABEL_26;
  }
  __int128 v13 = 8 * v12 - *(unsigned int *)(a1 + 116);
  if (0xFFFFFFFF - v10 < v13) {
    goto LABEL_26;
  }
  __int128 v14 = v10 >> 3;
LABEL_29:
  const void *v6 = v13 + v10;
  memcpy((void *)(v7 + v14), __src, v12);
  int v4 = *(void *)(a1 + 96);
LABEL_30:
  *(void *)(a1 + 96) = v4 - v5;
  if (v4 == v5) {
    *(_DWORD *)(a1 + 48) = 20;
  }
  return v5;
}

    ++v5;
  }

  return 0LL;
}

    __int128 v20 = SecTrustGetVerifyTime(a1);
    __int128 v21 = *(double *)(v49[3] + 176);
    double Current = CFAbsoluteTimeGetCurrent();
    if (v21 >= v20 + 4500.0 || v21 <= Current) {
      __int128 v21 = v20 + 4500.0;
    }
    __int128 v24 = CFDateCreate(0LL, v20);
    __int128 v25 = CFDateCreate(0LL, v21);
    v35[1] = 0x40000000LL;
    __int128 v36 = context;
    __int128 v37 = v53;
    char v38 = v54[0];
    CFTypeID v39 = v54[1];
    __int128 v26 = (dispatch_queue_s *)*((void *)a1 + 17);
    v35[0] = v6;
    v35[2] = __SecTrustEvaluateLeafOnly_block_invoke_2;
    v35[3] = &__block_descriptor_tmp_266;
    void v35[4] = a1;
    unint64_t v42 = v19;
    uint64_t v40 = v24;
    uint64_t v41 = v25;
    dispatch_sync(v26, v35);
    __int128 v27 = (const void *)*((void *)&context + 1);
    if (*((void *)&context + 1))
    {
      *((void *)&context + 1) = 0LL;
      CFRelease(v27);
    }

    __int128 v28 = (const void *)*((void *)&v53 + 1);
    if (*((void *)&v53 + 1))
    {
      *((void *)&v53 + 1) = 0LL;
      CFRelease(v28);
    }

    __int128 v29 = (const void *)*((void *)&v54[0] + 1);
    if (*((void *)&v54[0] + 1))
    {
      *((void *)&v54[0] + 1) = 0LL;
      CFRelease(v29);
    }

    __int128 v30 = (const void *)context;
    if ((void)context)
    {
      *(void *)&uint64_t context = 0LL;
      CFRelease(v30);
    }

    if (!v13)
    {
      __int128 v31 = SecTrustCopyFailureDescription(a1);
      __int128 v32 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)values = 138412290;
        *(void *)&values[4] = v31;
        _os_log_impl(&dword_1804F4000, v32, OS_LOG_TYPE_DEFAULT, "%@", values, 0xCu);
      }

      CFRelease(v31);
    }

    if (a2) {
      *a2 = v19;
    }
    size_t v33 = (const void *)v49[3];
    if (v33) {
      CFRelease(v33);
    }
    unint64_t v34 = (const void *)v45[3];
    if (v34) {
      CFRelease(v34);
    }
    if (v24) {
      CFRelease(v24);
    }
    if (v25) {
      CFRelease(v25);
    }
    _Block_object_dispose(&v44, 8);
    _Block_object_dispose(&v48, 8);
    return 0LL;
  }

  return result;
}

  if (!a3) {
    goto LABEL_34;
  }
LABEL_21:
  if (a2[55] >= 0) {
    __int128 v12 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    __int128 v12 = *((void *)a2 + 5);
  }
  memset(&v18, 170, sizeof(v18));
  __int128 v13 = &v18;
  std::string::basic_string[abi:ne180100]((uint64_t)&v18, v12 + 1);
  if ((v18.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int128 v13 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if (v12)
  {
    if (a2[55] >= 0) {
      __int128 v14 = v6;
    }
    else {
      __int128 v14 = (char *)*((void *)a2 + 4);
    }
    memmove(v13, v14, v12);
  }

  *(_WORD *)((char *)&v13->__r_.__value_.__l.__data_ + v12) = 47;
  size_t v15 = strlen(a3);
  unint64_t v16 = std::string::append(&v18, a3, v15);
  *this = *v16;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
}

      (*(void (**)(_DWORD *))(*(void *)v31 + 24LL))(v31);
LABEL_21:
      __cxa_end_catch();
LABEL_23:
      JUMPOUT(0x180623994LL);
    }

    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v35);
      }
      goto LABEL_21;
    }
  }

  __int128 v32 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v32 + 24LL))(v32);
  __cxa_end_catch();
  goto LABEL_23;
}

      CFRelease(v14);
      goto LABEL_21;
    }

    size_t v15 = CFDictionaryGetValue((CFDictionaryRef)Value, @"hash");
    Security::CFRef<__CFArray const*>::operator=(&cf, v15);
    goto LABEL_14;
  }

  return result;
}

    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11LL);
  }

  __int128 v14 = Security::cfmake<__CFDictionary const*>((uint64_t)"{hash=%O}", v7, v8, v9, v10, v11, v12, v13, (uint64_t)cf);
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
  *(void *)this = v14;
LABEL_8:
  __int128 v23 = 0;
  Value = CFDictionaryGetValue(v14, @"requirement");
  __int128 v18 = *(const __CFString **)this;
  if (Value)
  {
    __int128 v19 = "{requirement=%SO,?optional=%B}";
    int v4 = v3;
LABEL_12:
    __int128 v21 = Security::cfscan(v18, v19, v16, v4, &v23);
    goto LABEL_13;
  }

  __int128 v20 = CFDictionaryGetValue((CFDictionaryRef)v18, @"symlink");
  __int128 v18 = *(const __CFString **)this;
  if (v20)
  {
    __int128 v19 = "{symlink=%SO,?optional=%B}";
    goto LABEL_12;
  }

  __int128 v21 = Security::cfscan(v18, "{?optional=%B}", v16, &v23);
LABEL_13:
  if ((v21 & 1) == 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11LL);
  }
  if (v23) {
    *((_DWORD *)this + 6) |= 1u;
  }
  if (*(void *)v3) {
    *((_DWORD *)this + 6) |= 4u;
  }
  return this;
}

LABEL_47:
  __break(0x5513u);
  return result;
}

      if (!MutableCopy) {
        return v8;
      }
      __int128 v37 = MutableCopy;
      goto LABEL_49;
    case 9:
      if (!a7) {
        return 1LL;
      }
      __int128 v32 = CFStringCreateMutableCopy(0LL, 128LL, theString);
      size_t v33 = copyStringEndingIn(v32, @"|");
      if (v33)
      {
        unint64_t v34 = v33;
        unint64_t v35 = CFStringCreateCopy(0LL, v32);
        unsigned int v8 = v35 != 0LL;
        if (v35)
        {
          __int128 v36 = v35;
          *a7 = CFStringCreateCopy(0LL, v35);
          CFRelease(v34);
          unint64_t v34 = v36;
        }

        CFRelease(v34);
        if (!v32) {
          return v8;
        }
      }

      else
      {
        unsigned int v8 = 0LL;
        if (!v32) {
          return v8;
        }
      }

      __int128 v37 = v32;
LABEL_49:
      CFRelease(v37);
      return v8;
    default:
      return v8;
  }

  __int128 v19 = 0LL;
LABEL_52:
  if (v66) {
    free(v61[0]);
  }
  PORT_FreeArena(v9, 1);
  if (v34) {
    CFRelease(v34);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v42) {
    CFRelease(v42);
  }
  free(v23);
  free(v24);
  free(v52);
  free(v51);
  if (error)
  {
    unint64_t v44 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t v67 = 138412290;
      unint64_t v68 = error;
      _os_log_impl(&dword_1804F4000, v44, OS_LOG_TYPE_DEFAULT, "csr: cert request encoding failed: %@", v67, 0xCu);
    }

    BOOL v45 = error;
    if (error)
    {
      error = 0LL;
      CFRelease(v45);
    }
  }

  return v19;
}

        __int128 v24 = 0LL;
        goto LABEL_33;
      }
    }

    __int128 v27 = 0LL;
    __int128 v18 = 0LL;
    __int128 v24 = 0LL;
LABEL_34:
    if (cf) {
      CFRelease(cf);
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v18) {
      CFRelease(v18);
    }
    if (v17) {
      CFRelease(v27);
    }
    if (v32) {
      CFRelease(v32);
    }

    goto LABEL_45;
  }

  context[0] = 0LL;
  logUnreasonableDataLength(a3);
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash( @"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit",  0x53C0000Fu);
  }
  if (gSecurityd
    && (__int128 v22 = *(uint64_t (**)(const __CFDictionary *, uint64_t, const void **, CFErrorRef *))gSecurityd) != 0LL)
  {
    __int128 v23 = SecSecurityClientGet();
    if ((v22(a3, v23, context, a6) & 1) == 0)
    {
      __int128 v24 = 0LL;
      goto LABEL_45;
    }
  }

  else
  {
    SecSecurityClientGet();
    char v38 = MEMORY[0x1895F87A8];
    CFTypeID v39 = 3221225472LL;
    uint64_t v40 = __cftype_to_BOOL_cftype_error_request_block_invoke;
    uint64_t v41 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    unint64_t v42 = a3;
    size_t v33 = MEMORY[0x1895F87A8];
    unint64_t v34 = 3221225472LL;
    unint64_t v35 = __cftype_to_BOOL_cftype_error_request_block_invoke_2;
    __int128 v36 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    p_CFTypeRef cf = context;
    __int128 v24 = 0LL;
  }

  __int128 v24 = SecItemResultProcess(a3, a5, 0LL, context[0], *(CFTypeRef **)(a1 + 32), (__CFString **)a6);
  if (context[0]) {
    CFRelease(context[0]);
  }
LABEL_45:

  return v24;
}

  (*(void (**)(_BYTE *__return_ptr))(**((void **)a1 + 4) + 40LL))(__p);
  if (__p[23] >= 0) {
    __int128 v26 = __p[23];
  }
  else {
    __int128 v26 = *(void *)&__p[8];
  }
  __int128 v27 = a2->__r_.__value_.__s.__size_;
  __int128 v28 = (char)v27;
  if ((v27 & 0x80u) != 0LL) {
    __int128 v27 = a2->__r_.__value_.__l.__size_;
  }
  if (v26 != v27)
  {
    if ((__p[23] & 0x80) != 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_124;
  }

  if (v28 >= 0) {
    __int128 v29 = a2;
  }
  else {
    __int128 v29 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  if ((__p[23] & 0x80) != 0)
  {
    char v38 = *(void **)__p;
    CFTypeID v39 = memcmp(*(const void **)__p, v29, *(size_t *)&__p[8]);
    operator delete(v38);
    if (!v39) {
      goto LABEL_125;
    }
    goto LABEL_124;
  }

  if (__p[23])
  {
    __int128 v30 = 0LL;
    do
    {
      __int128 v31 = __p[v30];
      __int128 v32 = v29->__r_.__value_.__s.__data_[v30];
    }

    while (v31 == v32 && __p[23] - 1LL != v30++);
    if (v31 != v32) {
      goto LABEL_124;
    }
  }

  __int128 v31 = __str.__r_.__value_.__s.__size_;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int128 v31 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&context, &__str, v31 - 1, 1uLL, (std::allocator<char> *)theDict);
  __int128 v32 = context.__r_.__value_.__s.__size_;
  if ((context.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int128 v32 = context.__r_.__value_.__l.__size_;
  }
  if (v32 != 1)
  {
    unint64_t v34 = 0;
LABEL_60:
    operator delete(context.__r_.__value_.__l.__data_);
    if (v34) {
      goto LABEL_56;
    }
LABEL_61:
    unint64_t v67 = __str;
    memset(&__str, 0, sizeof(__str));
    goto LABEL_62;
  }

  size_t v33 = (std::string *)context.__r_.__value_.__r.__words[0];
  if ((context.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t v33 = &context;
  }
  unint64_t v34 = v33->__r_.__value_.__s.__data_[0] == 47;
LABEL_55:
  if (!v34) {
    goto LABEL_61;
  }
LABEL_56:
  unint64_t v35 = __str.__r_.__value_.__s.__size_;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    unint64_t v35 = __str.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v67, &__str, 0LL, v35 - 1, (std::allocator<char> *)&context);
LABEL_62:
  if ((v67.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v36 = &v67;
  }
  else {
    __int128 v36 = (std::string *)v67.__r_.__value_.__r.__words[0];
  }
  __int128 v37 = realpath_DARWIN_EXTSN((const char *)v36, __b);
  if (!v37) {
    goto LABEL_130;
  }
  std::string::__assign_external(v11, __b);
  char v38 = *(unsigned __int8 *)(a1 + 23);
  CFTypeID v39 = v38;
  if ((v38 & 0x80u) == 0LL) {
    uint64_t v40 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v40 = *(void *)(a1 + 8);
  }
  uint64_t v41 = *(unsigned __int8 *)(a1 + 47);
  unint64_t v42 = (char)v41;
  if ((v41 & 0x80u) != 0LL) {
    uint64_t v41 = *(void *)(a1 + 32);
  }
  if (v40 == v41)
  {
    if (v42 >= 0) {
      uint64_t v43 = v11;
    }
    else {
      uint64_t v43 = (std::string *)v11->__r_.__value_.__r.__words[0];
    }
    if ((char)v38 < 0)
    {
      BOOL v45 = *(const void **)a1;
      if (!memcmp(*(const void **)a1, v43, *(void *)(a1 + 8)))
      {
        v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
        goto LABEL_124;
      }
    }

    else
    {
      if (!(_BYTE)v38)
      {
        v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
        BOOL v45 = (const void *)a1;
        goto LABEL_124;
      }

      unint64_t v44 = (unsigned __int8 *)a1;
      while (*v44 == v43->__r_.__value_.__s.__data_[0])
      {
        ++v44;
        uint64_t v43 = (std::string *)((char *)v43 + 1);
        if (!--v38) {
          goto LABEL_113;
        }
      }
    }
  }

  memset(&context, 170, sizeof(context));
  uint64_t v46 = &context;
  std::string::basic_string[abi:ne180100]((uint64_t)&context, v40 + 9);
  if ((context.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    uint64_t v46 = (std::string *)context.__r_.__value_.__r.__words[0];
  }
  if (v40)
  {
    else {
      unsigned int v47 = *(const void **)a1;
    }
    memmove(v46, v47, v40);
  }

  strcpy((char *)v46 + v40, "/Contents");
  CFTypeID v48 = *(unsigned __int8 *)(a1 + 47);
  if ((v48 & 0x80u) == 0LL) {
    uint64_t v49 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v49 = *(void *)(a1 + 32);
  }
  __int128 v50 = context.__r_.__value_.__s.__size_;
  unsigned int v51 = (char)context.__r_.__value_.__s.__size_;
  if ((context.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int128 v50 = context.__r_.__value_.__l.__size_;
  }
  if (v49 == v50)
  {
    if ((context.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v52 = &context;
    }
    else {
      char v52 = (std::string *)context.__r_.__value_.__r.__words[0];
    }
    if ((v48 & 0x80) != 0)
    {
      uint64_t v58 = memcmp(v11->__r_.__value_.__l.__data_, v52, *(void *)(a1 + 32)) != 0;
      if ((v51 & 0x80000000) == 0) {
        goto LABEL_111;
      }
    }

    else if (*(_BYTE *)(a1 + 47))
    {
      unint64_t v53 = v48 - 1;
      int v54 = v11;
      do
      {
        unint64_t v56 = v54->__r_.__value_.__s.__data_[0];
        int v54 = (std::string *)((char *)v54 + 1);
        int v55 = v56;
        unint64_t v57 = v52->__r_.__value_.__s.__data_[0];
        char v52 = (std::string *)((char *)v52 + 1);
        uint64_t v58 = v55 != v57;
      }

      while (v55 == v57 && v53-- != 0);
      if (((char)context.__r_.__value_.__s.__size_ & 0x80000000) == 0)
      {
LABEL_111:
        if (!v58) {
          goto LABEL_112;
        }
LABEL_117:
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
      }
    }

    else
    {
      uint64_t v58 = 0;
    }
  }

  else
  {
    uint64_t v58 = 1;
  }

  operator delete(context.__r_.__value_.__l.__data_);
  if (v58) {
    goto LABEL_117;
  }
LABEL_112:
  CFTypeID v39 = *(_BYTE *)(a1 + 23);
LABEL_113:
  v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  BOOL v45 = (const void *)a1;
  if (v39 < 0) {
    BOOL v45 = *(const void **)a1;
  }
LABEL_124:
  *(_OWORD *)&v67.__r_.__value_.__l.__data_ = (unint64_t)v45;
  unint64_t v60 = fts_open(&v67.__r_.__value_.__l.__data_, 21, 0LL);
  *(void *)(a1 + 48) = v60;
  if (!v60)
  {
    unint64_t v63 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v63);
  }

  if (a4) {
    CFRetain(a4);
  }
  if (*v10) {
    CFRelease(*v10);
  }
  void *v10 = a4;
  theDict[0] = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  theDict[1] = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  Security::CFDictionary::CFDictionary( (Security::CFDictionary *)theDict,  (const __CFDictionary *)a4,  (Security::MacOSError *)0xFFFEFA13LL);
  context.__r_.__value_.__r.__words[0] = a1;
  context.__r_.__value_.__l.__size_ = (std::string::size_type)Security::CodeSigning::ResourceBuilder::addRule;
  context.__r_.__value_.__l.__cap_ = 0LL;
  CFDictionaryApplyFunction( theDict[0],  (CFDictionaryApplierFunction)Security::CFDictionary::Applier<Security::CodeSigning::ResourceBuilder>::apply,  &context);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)theDict);
  return a1;
}

uint64_t CTCompressAttestationLeaf(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  v38[2] = *MEMORY[0x1895F89C0];
  if (a2 == -1LL) {
    goto LABEL_65;
  }
  uint64_t v6 = 393220LL;
  uint64_t result = CTCompressGetCommonNameSuffixPointer(a1 + 15);
  if (!result) {
    return 393224LL;
  }
  if (a3 < 9) {
    return v6;
  }
  unint64_t v8 = a2 + 1;
  if (a2 + 1 >= a2)
  {
    unint64_t v9 = a2 + a3;
    if (v8 <= a2 + a3)
    {
      *(void *)(a2 + 1) = *(void *)result;
      if (v8 > 0xFFFFFFFFFFFFFFF7LL) {
        goto LABEL_65;
      }
      memset(v34, 170, sizeof(v34));
      uint64_t result = X509CertificateParseValidity((uint64_t)a1);
      if ((_DWORD)result) {
        return result;
      }
      memset(v38, 170, 14);
      uint64_t result = CTGetGeneralizedTime((uint64_t)&v34[2], (unint64_t)v38);
      if ((_DWORD)result) {
        return result;
      }
      if (a3 < 0x17) {
        return 393220LL;
      }
      __int128 v10 = (void *)(a2 + 9);
      if (a2 + 9 >= a2 && (unint64_t)v10 <= v9)
      {
        void *v10 = v38[0];
        *(void *)(a2 + 15) = *(void *)((char *)v38 + 6);
        uint64_t result = CTGetGeneralizedTime((uint64_t)v34, (unint64_t)v38);
        if ((_DWORD)result) {
          return result;
        }
        if (a3 < 0x25) {
          return 393220LL;
        }
        uint64_t v11 = (void *)(a2 + 23);
        if (a2 + 23 >= a2 && (unint64_t)v11 <= v9)
        {
          void *v11 = v38[0];
          *(void *)(a2 + 29) = *(void *)((char *)v38 + 6);
          char v37 = -86;
          *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __int128 v35 = v12;
          __int128 v36 = v12;
          memset(v33, 170, sizeof(v33));
          uint64_t result = X509CertificateParseSPKI(a1 + 11, 0LL, (unint64_t *)v33, &v33[2]);
          if ((_DWORD)result) {
            return result;
          }
          uint64_t result = compressECPublicKey(&v33[2], v33, (uint64_t)&v35, 33LL);
          if ((_DWORD)result) {
            return result;
          }
          if (a3 < 0x46) {
            return 393220LL;
          }
          __int128 v13 = (_OWORD *)(a2 + 37);
          if (a2 + 37 >= a2 && (unint64_t)v13 <= v9)
          {
            __int128 v14 = v36;
            *__int128 v13 = v35;
            *(_OWORD *)(a2 + 53) = v14;
            *(_BYTE *)(a2 + 69) = v37;
            size_t v15 = (_OWORD *)a1[31];
            uint64_t result = 393222LL;
            if (!v15 || a1[32] != 32) {
              return result;
            }
            if (a3 < 0x66) {
              return 393220LL;
            }
            unint64_t v16 = (_OWORD *)(a2 + 70);
            if (a2 + 70 >= a2 && (unint64_t)v16 <= v9)
            {
              __int128 v17 = v15[1];
              *unint64_t v16 = *v15;
              *(_OWORD *)(a2 + 86) = v17;
              unint64_t v18 = a1[21];
              uint64_t result = 393221LL;
              if (!v18 || a1[22] != 20) {
                return result;
              }
              if (a3 < 0x7A) {
                return 393220LL;
              }
              __int128 v19 = (_OWORD *)(a2 + 102);
              if (a2 + 102 >= a2 && (unint64_t)v19 <= v9)
              {
                __int128 v20 = *(_OWORD *)v18;
                *(_DWORD *)(a2 + 118) = *(_DWORD *)(v18 + 16);
                _OWORD *v19 = v20;
                __int128 v21 = (_OWORD *)(a2 + 122);
                __src = 0LL;
                size_t __n = 0LL;
                if (CTParseExtensionValue( *a1,  a1[1],  &CTOidAppleMFI4ProductPlanUID,  0xAuLL,  &__src,  &__n))
                {
                  uint64_t v22 = 122LL;
                }

                else
                {
                  uint64_t result = 393222LL;
                  if (!__src || __n != 36) {
                    return result;
                  }
                  if (a3 < 0x9E) {
                    return 393220LL;
                  }
                  __int128 v27 = *(_OWORD *)__src;
                  __int128 v28 = *((_OWORD *)__src + 1);
                  *(_DWORD *)(a2 + 154) = *((_DWORD *)__src + 8);
                  *__int128 v21 = v27;
                  *(_OWORD *)(a2 + 138) = v28;
                  __int128 v21 = (_OWORD *)(a2 + 158);
                  uint64_t v22 = 158LL;
                }

                __int128 v23 = (const void *)a1[7];
                uint64_t result = 655619LL;
                if (!v23) {
                  return result;
                }
                size_t v24 = a1[8];
                if (v24 - 73 < 0xFFFFFFFFFFFFFFFDLL) {
                  return result;
                }
                size_t v25 = v24 + v22;
                if (v24 + v22 > a3) {
                  return 393220LL;
                }
                if ((unint64_t)v21 <= v9 && (unint64_t)v21 >= a2 && v24 <= v9 - (unint64_t)v21)
                {
                  memcpy(v21, v23, v24);
                  unint64_t v26 = a1[8];
                  if (__CFADD__(v21, v26)) {
                    goto LABEL_65;
                  }
                  if (CTParseExtensionValue( *a1,  a1[1],  &CTOidAppleMFI4AccessoryData,  0xAuLL,  &__src,  &__n)) {
                    return 0LL;
                  }
                  if (!__src) {
                    return 393222LL;
                  }
                  size_t v29 = __n;
                  uint64_t result = 393220LL;
                  if (__n + v25 > a3) {
                    return result;
                  }
                  __int128 v30 = (char *)v21 + v26;
                  if ((unint64_t)v21 + v26 <= v9
                    && (unint64_t)v30 >= a2
                    && __n <= v9 - (unint64_t)v30)
                  {
                    memcpy((char *)v21 + v26, __src, __n);
                    if (!__CFADD__(v30, v29)) {
                      return 0LL;
                    }
LABEL_65:
                    __break(0x5513u);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

LABEL_67:
  __break(0x5519u);
  return result;
}

    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v59);
  }

uint64_t CTCompressMFiLeaf(uint64_t result, unint64_t a2, unint64_t a3)
{
  v39[2] = *MEMORY[0x1895F89C0];
  if (a2 == -1LL) {
    goto LABEL_69;
  }
  uint64_t v3 = (unint64_t *)result;
  uint64_t v4 = 393220LL;
  int v5 = *(_OWORD **)(result + 136);
  if (v5) {
    BOOL v6 = *(void *)(result + 144) == 16LL;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6) {
    return 393223LL;
  }
  if (a3 < 0x11) {
    return v4;
  }
  unint64_t v9 = (_OWORD *)(a2 + 1);
  if (a2 + 1 >= a2)
  {
    unint64_t v10 = a2 + a3;
    if ((unint64_t)v9 <= a2 + a3)
    {
      *unint64_t v9 = *v5;
      uint64_t result = CTCompressGetCommonNameSuffixPointer((unint64_t *)(result + 120));
      if (!result) {
        return 393224LL;
      }
      if (a3 < 0x19) {
        return v4;
      }
      unint64_t v11 = a2 + 17;
      if (a2 + 17 >= a2 && v11 <= v10)
      {
        *(void *)(a2 + 17) = *(void *)result;
        if (v11 > 0xFFFFFFFFFFFFFFF7LL) {
          goto LABEL_69;
        }
        v35[0] = 0xAAAAAAAAAAAAAAAALL;
        v35[1] = 0xAAAAAAAAAAAAAAAALL;
        uint64_t result = X509CertificateParseValidity((uint64_t)v3);
        if ((_DWORD)result) {
          return result;
        }
        *(void *)((char *)v39 + 6) = 0xAAAAAAAAAAAAAAAALL;
        v39[0] = 0xAAAAAAAAAAAAAAAALL;
        uint64_t result = CTGetGeneralizedTime((uint64_t)v35, (unint64_t)v39);
        if ((_DWORD)result) {
          return result;
        }
        if (a3 < 0x27) {
          return 393220LL;
        }
        __int128 v12 = (void *)(a2 + 25);
        if (a2 + 25 >= a2 && (unint64_t)v12 <= v10)
        {
          *__int128 v12 = v39[0];
          *(void *)(a2 + 31) = *(void *)((char *)v39 + 6);
          char v38 = -86;
          *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __int128 v36 = v13;
          __int128 v37 = v13;
          memset(v34, 170, sizeof(v34));
          uint64_t result = X509CertificateParseSPKI(v3 + 11, 0LL, (unint64_t *)v34, &v34[2]);
          if ((_DWORD)result) {
            return result;
          }
          uint64_t result = compressECPublicKey(&v34[2], v34, (uint64_t)&v36, 33LL);
          if ((_DWORD)result) {
            return result;
          }
          if (a3 < 0x48) {
            return 393220LL;
          }
          __int128 v14 = (_OWORD *)(a2 + 39);
          if (a2 + 39 >= a2 && (unint64_t)v14 <= v10)
          {
            __int128 v15 = v37;
            _OWORD *v14 = v36;
            *(_OWORD *)(a2 + 55) = v15;
            *(_BYTE *)(a2 + 71) = v38;
            unint64_t v16 = (_OWORD *)v3[31];
            uint64_t result = 393222LL;
            if (!v16 || v3[32] != 32) {
              return result;
            }
            if (a3 < 0x68) {
              return 393220LL;
            }
            __int128 v17 = (_OWORD *)(a2 + 72);
            if (a2 + 72 >= a2 && (unint64_t)v17 <= v10)
            {
              __int128 v18 = v16[1];
              *__int128 v17 = *v16;
              *(_OWORD *)(a2 + 88) = v18;
              unint64_t v19 = v3[21];
              uint64_t result = 393221LL;
              if (!v19 || v3[22] != 20) {
                return result;
              }
              if (a3 < 0x7C) {
                return 393220LL;
              }
              __int128 v20 = (_OWORD *)(a2 + 104);
              if (a2 + 104 >= a2 && (unint64_t)v20 <= v10)
              {
                __int128 v21 = *(_OWORD *)v19;
                *(_DWORD *)(a2 + 120) = *(_DWORD *)(v19 + 16);
                *__int128 v20 = v21;
                uint64_t v22 = (_OWORD *)(a2 + 124);
                __src = 0LL;
                size_t __n = 0LL;
                if (CTParseExtensionValue( *v3,  v3[1],  &CTOidAppleMFI4ProductPlanUID,  0xAuLL,  &__src,  &__n))
                {
                  uint64_t v23 = 124LL;
                }

                else
                {
                  uint64_t result = 393222LL;
                  if (!__src || __n != 36) {
                    return result;
                  }
                  if (a3 < 0xA0) {
                    return 393220LL;
                  }
                  __int128 v28 = *(_OWORD *)__src;
                  __int128 v29 = *((_OWORD *)__src + 1);
                  *(_DWORD *)(a2 + 156) = *((_DWORD *)__src + 8);
                  *uint64_t v22 = v28;
                  *(_OWORD *)(a2 + 140) = v29;
                  uint64_t v22 = (_OWORD *)(a2 + 160);
                  uint64_t v23 = 160LL;
                }

                size_t v24 = (const void *)v3[7];
                uint64_t result = 655619LL;
                if (!v24) {
                  return result;
                }
                size_t v25 = v3[8];
                if (v25 - 73 < 0xFFFFFFFFFFFFFFFDLL) {
                  return result;
                }
                size_t v26 = v25 + v23;
                if (v25 + v23 > a3) {
                  return 393220LL;
                }
                if ((unint64_t)v22 <= v10 && (unint64_t)v22 >= a2 && v25 <= v10 - (unint64_t)v22)
                {
                  memcpy(v22, v24, v25);
                  unint64_t v27 = v3[8];
                  if (__CFADD__(v22, v27)) {
                    goto LABEL_69;
                  }
                  if (CTParseExtensionValue( *v3,  v3[1],  &CTOidAppleMFI4AccessoryData,  0xAuLL,  &__src,  &__n)) {
                    return 0LL;
                  }
                  if (!__src) {
                    return 393222LL;
                  }
                  size_t v30 = __n;
                  uint64_t result = 393220LL;
                  if (__n + v26 > a3) {
                    return result;
                  }
                  __int128 v31 = (char *)v22 + v27;
                  if ((unint64_t)v22 + v27 <= v10
                    && (unint64_t)v31 >= a2
                    && __n <= v10 - (unint64_t)v31)
                  {
                    memcpy((char *)v22 + v27, __src, __n);
                    if (!__CFADD__(v31, v30)) {
                      return 0LL;
                    }
LABEL_69:
                    __break(0x5513u);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

uint64_t CTDecompressIssuer( int a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result = 393218LL;
  if (a1 <= 159)
  {
    unint64_t v11 = &mfi_ca_subject;
    if (a1 < 4)
    {
      __int128 v12 = &attestation_leaf_subject;
      uint64_t v13 = 57LL;
      unint64_t v14 = 107LL;
      uint64_t v15 = 17LL;
      goto LABEL_14;
    }

    if (a1 != 4)
    {
      if (a1 != 5) {
        return result;
      }
      __int128 v12 = &attestation_leaf_subject;
      uint64_t v13 = 57LL;
      unint64_t v14 = 107LL;
      goto LABEL_13;
    }

    goto LABEL_12;
  }

  if ((a1 - 160) >= 4)
  {
    if (a1 == 164)
    {
LABEL_12:
      unint64_t v11 = &root_subject;
      __int128 v12 = &leaf_5280_extensions_template;
      uint64_t v13 = 39LL;
      unint64_t v14 = 89LL;
      goto LABEL_13;
    }

    if (a1 != 165) {
      return result;
    }
  }

  unint64_t v11 = &attestation_ca_subject;
  __int128 v12 = &root_subject;
  uint64_t v13 = 58LL;
  unint64_t v14 = 108LL;
LABEL_13:
  uint64_t v15 = 1LL;
LABEL_14:
  uint64_t result = 393217LL;
  if ((v15 | 8uLL) > a3) {
    return result;
  }
  if (!a4) {
    goto LABEL_35;
  }
  unint64_t v17 = *a4;
  unint64_t v16 = a4[1];
  if (v16 - *a4 < v14) {
    return 393220LL;
  }
  if (v17 > v16 || v11 > v12 || v14 > v12 - v11)
  {
LABEL_40:
    __break(0x5519u);
    return result;
  }

  uint64_t result = ccder_blob_encode_body();
  if (!(_DWORD)result) {
    return 393226LL;
  }
  unint64_t v18 = a4[1];
  if (__CFADD__(v18, v13)
    || ((unint64_t v19 = (void *)(v18 + v13), (uint64_t)((uint64_t)v19 - v17) >= 0)
      ? (BOOL v20 = (unint64_t)v19 >= v17)
      : (BOOL v20 = (unint64_t)v19 < v17),
        !v20 || __CFADD__(a2, v15)))
  {
    __break(0x5513u);
    goto LABEL_40;
  }

  __int128 v21 = (void *)(a2 + v15);
  void *v19 = *v21;
LABEL_35:
  uint64_t result = 0LL;
  if (a5) {
    *a5 = v14;
  }
  return result;
}

uint64_t CTDecompressSerialNumber( int a1, _OWORD *a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  *(void *)&v31[7] = *MEMORY[0x1895F89C0];
  uint64_t result = 393218LL;
  if (a1 <= 159)
  {
    BOOL v11 = a1 >= 4;
    unsigned int v12 = a1 - 4;
    if (!v11)
    {
      uint64_t v13 = 0LL;
      unint64_t v14 = 0LL;
      uint64_t v15 = 1LL;
      unint64_t v16 = 16LL;
      goto LABEL_10;
    }

    goto LABEL_7;
  }

  if ((a1 - 160) >= 4)
  {
    unsigned int v12 = a1 - 164;
LABEL_7:
    if (v12 >= 2) {
      return result;
    }
    unint64_t v14 = v29;
    uint64_t v13 = v31;
    uint64_t v15 = 45LL;
    goto LABEL_9;
  }

  unint64_t v14 = v29;
  uint64_t v13 = v31;
  uint64_t v15 = 37LL;
LABEL_9:
  unint64_t v16 = 20LL;
LABEL_10:
  unint64_t v17 = ccder_sizeof();
  uint64_t result = 393217LL;
  if (v15 + v16 > a3) {
    return result;
  }
  char v30 = -86;
  *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29[2] = v18;
  v29[3] = v18;
  v29[0] = v18;
  v29[1] = v18;
  if (!v14)
  {
    if (!__CFADD__(a2, v15))
    {
      uint64_t v13 = (char *)a2 + a3;
      unint64_t v19 = (unint64_t)a2 + v15;
      unint64_t v14 = a2;
      if (!a4) {
        goto LABEL_37;
      }
      goto LABEL_21;
    }

LABEL_41:
    __break(0x5513u);
LABEL_42:
    __break(0x5519u);
    goto LABEL_43;
  }

  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a2, v15)) {
    goto LABEL_41;
  }
  unint64_t v27 = (unint64_t)a2 + v15;
  unint64_t v28 = 33LL;
  uint64_t result = decompressECPublicKey((uint64_t)&v27, (int **)&CTOidSECP256r1, (uint64_t)v29, 65LL);
  unint64_t v19 = (unint64_t)v14;
  if ((_DWORD)result) {
    return result;
  }
  if (!a4) {
    goto LABEL_37;
  }
LABEL_21:
  unint64_t v20 = *a4;
  unint64_t v21 = a4[1];
  if (v21 - *a4 < v17) {
    return 393220LL;
  }
  uint64_t v22 = ccder_sizeof_tag();
  uint64_t result = ccder_sizeof_len();
  uint64_t v23 = v22 + result;
  if (__CFADD__(v22, result))
  {
LABEL_43:
    __break(0x5500u);
    return result;
  }

  unint64_t v24 = a4[1];
  if (__CFADD__(v24, v23)) {
    goto LABEL_41;
  }
  size_t v25 = (_BYTE *)(v24 + v23);
  *v25 &= ~0x80u;
LABEL_37:
  uint64_t result = 0LL;
  if (a5) {
    *a5 = v17;
  }
  return result;
}

        unint64_t v10 = 0LL;
        goto LABEL_50;
      case 4:
        if (!v8)
        {
          secLogObjForScope("SecError");
          unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_45;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "defaultAppStoreLWCR";
          unint64_t v20 = "%s: signing identifier is NULL, cannot generate a LWCR";
          goto LABEL_44;
        }

        if (v4)
        {
          uint64_t v40 = @"$or";
          v38[1] = @"$and";
          v39[0] = &unk_18969C0F0;
          v38[0] = @"validation-category";
          v37[0] = &unk_18969C108;
          v36[0] = @"validation-category";
          v36[1] = @"team-identifier";
          [NSString stringWithUTF8String:v4];
          unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v37[1] = v9;
          [MEMORY[0x189603F68] dictionaryWithObjects:v37 forKeys:v36 count:2];
          unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue();
          v39[1] = v12;
          [MEMORY[0x189603F68] dictionaryWithObjects:v39 forKeys:v38 count:2];
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
          *(void *)&__int128 buf = v13;
          uint64_t v41 = @"signing-identifier";
          [NSString stringWithUTF8String:v8];
          unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
          *((void *)&buf + 1) = v14;
          unint64_t v10 = [MEMORY[0x189603F68] dictionaryWithObjects:&buf forKeys:&v40 count:2];

          goto LABEL_50;
        }

        secLogObjForScope("SecError");
        unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "defaultAppStoreLWCR";
          unint64_t v20 = "%s: team identifier is NULL, cannot generate a LWCR";
LABEL_44:
          _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, 0xCu);
        }

  (*(void (**)(unsigned __int8 *))(*(void *)v2 + 8LL))(v2);
  size_t v26 = cf;
  CFTypeRef cf = 0LL;
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  return v26;
}

unint64_t CTDecompressGetSignature( int a1, unint64_t a2, unint64_t a3, unint64_t *a4, void *a5)
{
  uint64_t v9 = 393217LL;
  unint64_t result = CTNonVariableCompressedSizeForStyle(a1);
  if ((result & 0x8000000000000000LL) != 0) {
    return 393218LL;
  }
  unint64_t v11 = result;
  if (result + 70 > a3) {
    return v9;
  }
  if (~a2 < a3 || result > ~a2) {
    goto LABEL_20;
  }
  unint64_t v12 = a2 + result;
  if (a2 + result > a2 + a3 || v12 < a2)
  {
LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }

  unint64_t v14 = a2 + result;
  unint64_t result = ccder_blob_decode_tl();
  if ((result & 1) == 0) {
    return 393225LL;
  }
  unint64_t v13 = v14 - v12;
  if (!v13) {
    return 393225LL;
  }
  if (!__CFADD__(v11, v13))
  {
    if (v11 + v13 > a3) {
      return v9;
    }
    uint64_t v9 = 0LL;
    if (!a4 || !a5) {
      return v9;
    }
    if (v13 <= a2 + a3 - v12)
    {
      uint64_t v9 = 0LL;
      *a4 = v12;
      *a5 = v13;
      return v9;
    }

    goto LABEL_19;
  }

uint64_t ccder_sizeof_tl()
{
  uint64_t v0 = ccder_sizeof_tag();
  uint64_t v1 = ccder_sizeof_len();
  BOOL v2 = __CFADD__(v0, v1);
  uint64_t result = v0 + v1;
  if (v2) {
    __break(0x5500u);
  }
  return result;
}

uint64_t CTDecompressSignature( int a1, unint64_t a2, unint64_t a3, void *a4, unint64_t *a5)
{
  v13[1] = *MEMORY[0x1895F89C0];
  unint64_t v12 = 0LL;
  v13[0] = 0LL;
  if ((a3 & 0x8000000000000000LL) != 0) {
    __break(0x5519u);
  }
  uint64_t result = CTDecompressGetSignature(a1, a2, a3, &v12, v13);
  uint64_t v8 = result;
  if ((_DWORD)result) {
    return v8;
  }
  if (v13[0] == -1LL)
  {
LABEL_15:
    __break(0x5500u);
    goto LABEL_16;
  }

  unint64_t v9 = ccder_sizeof();
  unint64_t v10 = v9;
  if (!a4) {
    goto LABEL_12;
  }
  uint64_t v8 = 393226LL;
  if (a4[1] - *a4 < v9) {
    return 393220LL;
  }
  uint64_t result = ccder_blob_encode_body();
  if (!(_DWORD)result) {
    return v8;
  }
  uint64_t v11 = a4[1];
  if (v11)
  {
    a4[1] = v11 - 1;
    *(_BYTE *)(v11 - 1) = 0;
    if (v13[0] != -1LL)
    {
LABEL_12:
      uint64_t v8 = 0LL;
      if (a5) {
        *a5 = v10;
      }
      return v8;
    }

    goto LABEL_15;
  }

LABEL_16:
  __break(0x5513u);
  return result;
}

    __break(0x5519u);
  }

  return result;
}

  CFDataAppendBytes(Mutable, (const UInt8 *)"NTLMSSP", 8LL);
  LODWORD(bytes) = 3;
  CFDataAppendBytes(Mutable, (const UInt8 *)&bytes, 4LL);
  if (v18 && (_DWORD)v19 && (v17 & 0x800000) != 0 && (*(_BYTE *)a1 & 4) != 0)
  {
    unint64_t v44 = v17;
    *(void *)unint64_t v68 = 0xAAAAAAAAAAAAAAAALL;
    CCRandomCopyBytes();
    bytes = *(_OWORD *)CFDataGetBytePtr(a5);
    size_t v26 = CFStringCreateMutableCopy(0LL, 0LL, a4);
    unint64_t v27 = v26;
    if (a3) {
      CFStringAppend(v26, a3);
    }
    CFStringUppercase(v27, 0LL);
    unint64_t v61 = 0LL;
    memset(v66, 170, sizeof(v66));
    memset(v65, 170, sizeof(v65));
    *(_DWORD *)unint64_t v59 = 257;
    unint64_t v60 = -1431655766;
    ntlmStringToLE(v27, &v61, &v60);
    uint64_t v43 = v61;
    ntlmHmacMD5(&bytes, v61, v60, &v66[2]);
    v66[0] = dataOut[6];
    v66[1] = *(void *)v68;
    ntlmHmacMD5(&v66[2], v66, 0x10u, &v65[1]);
    *(_OWORD *)&dataOut[3] = v65[1];
    dataOut[5] = *(void *)v68;
    CFTypeRef cf = v27;
    unint64_t v28 = CFDataCreateMutable(0LL, 0LL);
    CFDataAppendBytes(v28, v59, 4LL);
    *(_DWORD *)size_t v62 = 0;
    CFDataAppendBytes(v28, v62, 4LL);
    ntlmAppendTimestamp(v28);
    CFDataAppendBytes(v28, v68, 8LL);
    *(_DWORD *)size_t v62 = 0;
    CFDataAppendBytes(v28, v62, 4LL);
    BOOL v45 = v18;
    CFDataAppendBytes(v28, (const UInt8 *)v18, v19);
    *(_DWORD *)size_t v62 = 0;
    CFDataAppendBytes(v28, v62, 4LL);
    __int128 v29 = CFDataGetLength(v28);
    char v30 = CFDataCreateMutable(0LL, 0LL);
    CFDataAppendBytes(v30, (const UInt8 *)&dataOut[6], 8LL);
    __int128 v31 = CFDataGetBytePtr(v28);
    __int128 v32 = v29;
    CFDataAppendBytes(v30, v31, v29);
    size_t v33 = CFDataGetBytePtr(v30);
    unint64_t v34 = CFDataGetLength(v30);
    ntlmHmacMD5(&v66[2], v33, v34, v65);
    size_t length = v29 + 16;
    size_t v25 = (UInt8 *)malloc(length);
    *(_OWORD *)size_t v25 = v65[0];
    __int128 v35 = CFDataGetBytePtr(v28);
    memmove(v25 + 16, v35, v32);
    if (cf) {
      CFRelease(cf);
    }
    unint64_t v17 = v44;
    if (v28) {
      CFRelease(v28);
    }
    if (v30) {
      CFRelease(v30);
    }
    if (v43) {
      free(v43);
    }
    appendSecBuf(Mutable, 24, &v58);
    appendSecBuf(Mutable, length, &v57);
    *(_DWORD *)(a1 + 4) = 4;
    __int128 v18 = v45;
    goto LABEL_55;
  }

  if ((v17 & 0x80000) != 0 && (*(_BYTE *)a1 & 2) != 0)
  {
    CCRandomCopyBytes();
    dataOut[4] = 0LL;
    dataOut[5] = 0LL;
    *(void *)&bytes = dataOut[6];
    *((void *)&bytes + 1) = dataOut[3];
    v66[2] = 0xAAAAAAAAAAAAAAAALL;
    v66[3] = 0xAAAAAAAAAAAAAAAALL;
    md5Hash(&bytes, (unsigned __int8 *)&v66[2]);
    *(_OWORD *)v63[0].i8 = *(_OWORD *)CFDataGetBytePtr(a5);
    __int128 v37 = lmv2Response((uint64_t)v63, &v66[2], (char *)dataOut, v63[0], v36);
    if ((_DWORD)v37)
    {
      uint64_t v15 = v37;
      unint64_t v24 = 0LL;
      size_t v25 = 0LL;
      goto LABEL_24;
    }

    *(_DWORD *)(a1 + 4) = 2;
    size_t length = 24LL;
    appendSecBuf(Mutable, 24, &v58);
    appendSecBuf(Mutable, 24, &v57);
    size_t v25 = (UInt8 *)dataOut;
LABEL_55:
    if (a3)
    {
      if (ntlmStringFlatten(a3, v17 & 1, (char **)&v56, &v55))
      {
LABEL_60:
        unint64_t v24 = 0LL;
        uint64_t v15 = 4294967246LL;
        goto LABEL_24;
      }

      char v38 = v55;
      CFTypeID v39 = v55;
    }

    else
    {
      char v38 = 0LL;
      CFTypeID v39 = 0;
    }

    appendSecBuf(Mutable, v39, &v54);
    if (!ntlmStringFlatten(a4, v17 & 1, (char **)&v53, &v52))
    {
      uint64_t v40 = v52;
      appendSecBuf(Mutable, v52, &v51);
      ntlmHostName(v17 & 1, &v50, &v49);
      uint64_t v41 = v49;
      appendSecBuf(Mutable, v49, &v48);
      appendSecBuf(Mutable, 0, &v47);
      LODWORD(bytes) = *(_DWORD *)(a1 + 8) & v17;
      CFDataAppendBytes(Mutable, (const UInt8 *)&bytes, 4LL);
      secBufOffset(Mutable, v58);
      CFDataAppendBytes(Mutable, (const UInt8 *)&dataOut[3], 24LL);
      secBufOffset(Mutable, v57);
      CFDataAppendBytes(Mutable, v25, length);
      if (a3)
      {
        secBufOffset(Mutable, v54);
        CFDataAppendBytes(Mutable, v56, v38);
      }

      secBufOffset(Mutable, v51);
      CFDataAppendBytes(Mutable, v53, v40);
      secBufOffset(Mutable, v48);
      unint64_t v24 = v50;
      CFDataAppendBytes(Mutable, v50, v41);
      uint64_t v15 = 0LL;
      goto LABEL_24;
    }

    goto LABEL_60;
  }

  unint64_t v24 = 0LL;
  size_t v25 = 0LL;
  uint64_t v15 = 4294942003LL;
LABEL_24:
  if (v18) {
    free(v18);
  }
  if (v56) {
    free(v56);
  }
  if (v53) {
    free(v53);
  }
  if (v24) {
    free(v24);
  }
  if (a3) {
    CFRelease(a3);
  }
  if (v25 != (UInt8 *)dataOut && v25) {
    free(v25);
  }
  if ((_DWORD)v15)
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
  }

  else
  {
    *a7 = Mutable;
  }

  return v15;
}

    unint64_t v19 = sec_protocol_configuration_tls_required((uint64_t)v7);
LABEL_17:
    unint64_t v10 = v19;
LABEL_18:

    goto LABEL_19;
  }

  unint64_t v10 = 0LL;
LABEL_20:

  return v10;
}

  if (v6) {
    return v9;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  if (!CFArrayGetCount(Mutable) && !*(_DWORD *)(a1 + 16))
  {
    unint64_t v19 = CERT_FindByIssuerAndSN(*(const void **)(*(void *)(a1 + 128) + 176LL), @"cert", *(void *)(a1 + 24));
    if (v19)
    {
      unint64_t v20 = v19;
      CFArrayAppendValue(Mutable, v19);
      CFRelease(v20);
    }
  }

  if (!CFArrayGetCount(Mutable) && *(_DWORD *)(a1 + 16) == 1)
  {
    uint64_t v22 = CERT_FindBySubjectKeyID( *(const void **)(*(void *)(a1 + 128) + 176LL),  @"cert",  *(CFIndex **)(a1 + 24));
    if (v22)
    {
      uint64_t v23 = v22;
      CFArrayAppendValue(Mutable, v22);
      CFRelease(v23);
    }
  }

  if (Mutable)
  {
    SecCmsSignerInfoGetSigningTime(a1, (double *)&v28, v21);
    if (v24)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      *(double *)&unint64_t v28 = Current;
    }

    else
    {
      double Current = *(double *)&v28;
    }

    size_t v26 = CERT_VerifyCert(Mutable, a2, a3, Current);
    CFRelease(Mutable);
  }

  else
  {
    *(_DWORD *)(a1 + 160) = 4;
    return 0xFFFFFFFFLL;
  }

  return v26;
}

  if (a1 != 3 || !sTestViewSet)
  {
    if (!a1 && sTestViewSet)
    {
      context[0] = MEMORY[0x1895F87A8];
      context[1] = 3221225472LL;
      context[2] = __CFSetUnion_block_invoke_6846;
      context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      context[4] = v4;
      CFSetApplyFunction((CFSetRef)sTestViewSet, (CFSetApplierFunction)apply_block_1_6847, context);
    }

    return v4;
  }

  if (v4) {
    CFRelease(v4);
  }
  return CFSetCreateMutable(v2, 0LL, MEMORY[0x189605258]);
}

      if ((v10 + 9851) > 0x30 || ((1LL << (v10 + 123)) & 0x1400000000605LL) == 0)
      {
        if (v10) {
          *((_DWORD *)context + 20) = 4;
        }
      }
    }

    return v10;
  }

  return v4;
}
}

    if (ArrayBySeparatingStrings) {
      CFRelease(ArrayBySeparatingStrings);
    }
    *a3 = &v11[-v8];
  }

  return v8;
}

  if (CryptoTokenKitLibraryCore())
  {
    unint64_t v12 = (void *)[objc_alloc((Class)getTKClientTokenClass()) initWithTokenID:theString];
    unint64_t v20 = 0LL;
    unint64_t v13 = (void *)[objc_alloc((Class)getTKClientTokenSessionClass()) initWithToken:v12 LAContext:v10 parameters:MEMORY[0x189604A60] error:&v20];
    unint64_t v14 = v20;

    uint64_t v15 = (void *)MEMORY[0x189604A60];
  }

  else
  {
    unint64_t v16 = (void *)MEMORY[0x189607870];
    unint64_t v21 = *MEMORY[0x189607490];
    v22[0] = @"CryptoTokenKit is not available";
    [MEMORY[0x189603F68] dictionaryWithObjects:v22 forKeys:&v21 count:1];
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    [v16 errorWithDomain:*MEMORY[0x189607670] code:-4 userInfo:v15];
    unint64_t v14 = (id)objc_claimAutoreleasedReturnValue();
    unint64_t v13 = 0LL;
  }

  if (a3)
  {
    if (!v13) {
      *a3 = (__CFString *)v14;
    }
  }

  return v13;
}
}

    __int128 v29 = 0LL;
    CFErrorRef CFErrorWithXPCObject = 0LL;
    goto LABEL_17;
  }

  size_t v25 = v24;
  if (v24 == MEMORY[0x1895F9238])
  {
    CFErrorRef CFErrorWithXPCObject = 0LL;
    __int128 v29 = 0LL;
    __int128 v31 = 0LL;
    if (!a4) {
      goto LABEL_23;
    }
LABEL_22:
    __int128 v31 = v29;
    *a4 = v31;
    goto LABEL_23;
  }

  if (v24 != MEMORY[0x1895F9250])
  {
    secLogObjForScope("SecError");
    size_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      unint64_t v63 = (const char *)v25;
      unint64_t v27 = "unexpected message reply type %p";
LABEL_15:
      _os_log_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEFAULT, v27, buf, 0xCu);
      goto LABEL_16;
    }

    goto LABEL_16;
  }

  xpc_dictionary_get_value(v20, "AcmeReply");
  unint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  size_t v26 = v34;
  if (v34) {
    size_t length = xpc_data_get_length(v34);
  }
  else {
    size_t length = 0LL;
  }
  xpc_dictionary_get_value(v20, "AcmeError");
  __int128 v35 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_get_value(v20, "AcmeStatus");
  xint = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_get_value(v20, "AcmeNonce");
  __int128 v36 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_get_value(v20, "AcmeLocation");
  unint64_t v57 = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  xstring = v36;
  if (v36)
  {
    string_ptr = xpc_string_get_string_ptr(v36);
    char v38 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithBytes:length:encoding:",  string_ptr,  xpc_string_get_length(xstring),  4,  v48,  v13,  v11,  v18);
    if ([v38 length]) {
      objc_storeStrong((id *)&self->_nonce, v38);
    }
  }

  if (v57)
  {
    CFTypeID v39 = xpc_string_get_string_ptr(v57);
    uint64_t v40 = (void *)[objc_alloc(NSString) initWithBytes:v39 length:xpc_string_get_length(v57) encoding:4];
    if ([v40 length]) {
      objc_storeStrong((id *)&self->_location, v40);
    }
  }

  if (v35) {
    CFErrorRef CFErrorWithXPCObject = SecCreateCFErrorWithXPCObject(v35);
  }
  else {
    CFErrorRef CFErrorWithXPCObject = 0LL;
  }
  else {
    xpc_object_t value = 0LL;
  }
  if (-[AcmeCertRequest errorStatusWithHTTPErrorCode:]( self,  "errorStatusWithHTTPErrorCode:",  value,  v48,  v49,  v50,  v51))
  {
    __int128 v29 = 0LL;
  }

  else
  {
    if (v26) {
      bytes_ptr = xpc_data_get_bytes_ptr(v26);
    }
    else {
      bytes_ptr = &unk_18065A197;
    }
    uint64_t v43 = [MEMORY[0x189603F48] dataWithBytes:bytes_ptr length:length];
    if (self->_state == 9)
    {
      unint64_t v60 = @"certificate";
      unint64_t v61 = v43;
      unint64_t v44 = (void *)v43;
      BOOL v45 = [MEMORY[0x189603F68] dictionaryWithObjects:&v61 forKeys:&v60 count:1];
      uint64_t v46 = v44;
      __int128 v29 = (void *)v45;
    }

    else
    {
      uint64_t v58 = CFErrorWithXPCObject;
      char v52 = (void *)v43;
      [MEMORY[0x1896078D8] JSONObjectWithData:v43 options:0 error:&v58];
      __int128 v29 = (void *)objc_claimAutoreleasedReturnValue();
      int v54 = v58;

      if (v54)
      {
        secLogObjForScope("SecError");
        unsigned int v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          unint64_t v63 = (const char *)v54;
          _os_log_impl(&dword_1804F4000, v47, OS_LOG_TYPE_DEFAULT, "error converting json to dictionary: %@", buf, 0xCu);
        }

        uint64_t v46 = v52;
        CFErrorRef CFErrorWithXPCObject = v54;
      }

      else
      {
        CFErrorRef CFErrorWithXPCObject = 0LL;
        uint64_t v46 = v52;
      }
    }
  }

LABEL_17:
  if (a4) {
    goto LABEL_22;
  }
  if (v29) {

  }
  __int128 v31 = 0LL;
LABEL_23:

  __int128 v32 = CFErrorWithXPCObject;
  return v32;
}

      (*(void (**)(_DWORD *))(*(void *)v20 + 24LL))(v20);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x18061EFACLL);
    }

    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v24);
      }
      goto LABEL_17;
    }
  }

  unint64_t v21 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v21 + 24LL))(v21);
  __cxa_end_catch();
  goto LABEL_19;
}

      (*(void (**)(_DWORD *))(*(void *)v13 + 24LL))(v13);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x180622C74LL);
    }

    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
      }
      goto LABEL_17;
    }
  }

  unint64_t v14 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(void *)v14 + 24LL))(v14);
  __cxa_end_catch();
  goto LABEL_19;
}

unint64_t CTDecompressCAComputeSKID(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  if (a1 > 0xFFFFFFFFFFFFFFD2LL)
  {
    __break(0x5513u);
    goto LABEL_9;
  }

  if ((unint64_t)(a2 - 78) > 0xFFFFFFFFFFFFFFDELL || a1 + 45 < a1 || a1 + 45 > a1 + a2) {
LABEL_9:
  }
    __break(0x5519u);
  v6[0] = a1 + 45;
  v6[1] = 33LL;
  char v8 = -86;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[2] = v3;
  v7[3] = v3;
  v7[0] = v3;
  v7[1] = v3;
  unint64_t v4 = decompressECPublicKey((uint64_t)v6, (int **)&CTOidSECP256r1, (uint64_t)v7, 65LL);
  if (!(_DWORD)v4)
  {
    ccsha1_di();
    ccdigest();
  }

  return v4;
}

unint64_t CTConvertByteArrayToAsciiHex(unint64_t result, uint64_t a2, char *a3, uint64_t a4)
{
  if (!__CFADD__(result, a2))
  {
    if (a4 != 2 * a2) {
      return 393220LL;
    }
    if (!__CFADD__(a3, a4))
    {
      uint64_t v4 = 0LL;
      if (result + a2 > result)
      {
        int v5 = &a3[a4];
        if (&a3[a4] > a3)
        {
          BOOL v6 = (unsigned __int8 *)result;
          while ((unint64_t)v6 >= result)
          {
            unint64_t v7 = *v6;
            char v8 = &nibbleToAsciiByte[v7 >> 4];
            BOOL v9 = v8 < "Apple iPhone Certification Authority" && v8 >= nibbleToAsciiByte;
            unint64_t v10 = &nibbleToAsciiByte[v7 & 0xF];
            BOOL v11 = !v9 || v10 >= "Apple iPhone Certification Authority";
            if (v11 || v10 < nibbleToAsciiByte) {
              break;
            }
            char v13 = *v10;
            *a3 = *v8;
            unint64_t v14 = a3 + 1;
            uint64_t v4 = 0LL;
            char *v14 = v13;
            a3 = v14 + 1;
          }

          __break(0x5519u);
          goto LABEL_26;
        }
      }

      return v4;
    }
  }

LABEL_26:
  __break(0x5513u);
  return result;
}

    unint64_t v12 = 0;
  }

  _Block_object_dispose(&v46, 8);
  return v25;
}

  if ((_DWORD)v47)
  {
    uint64_t v15 = *(void *)(a1[4] + 8LL);
    *(_OWORD *)(v15 + 40) = v47;
    uint64_t result = (void *)*((void *)&v48 + 1);
    *(void *)(v15 + 56) = v48;
    if (result)
    {
      unint64_t v16 = result[1];
      if (v16 <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = "Over-release of an object";
        __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
      }

      unint64_t v17 = v16 - 1;
      result[1] = v17;
      if (!v17) {
        (*(void (**)(void *))(*result + 8LL))(result);
      }
      return 0LL;
    }

    return result;
  }

  __int128 v18 = (unint64_t *)a1[8];
  unint64_t v19 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  unint64_t v20 = *v18;
  if (*v18)
  {
    unint64_t v21 = v20 + 8LL * *((unsigned int *)v18 + 2);
    uint64_t v22 = v21 >= v20;
    uint64_t v23 = v21 - v20;
    if (!v22 || HIDWORD(v23)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v9);
    }
  }

  else
  {
    LODWORD(v23) = 0;
  }

  if (v19 >= 0) {
    unint64_t v24 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  }
  else {
    unint64_t v24 = -v19;
  }
  size_t v25 = ((unint64_t)v19 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
  if (v19 >= 0) {
    size_t v26 = 8 * v24;
  }
  else {
    size_t v26 = -8LL * v24;
  }
  if (v24 >> 61) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = 8 * v24 > v25;
  }
  if (v27)
  {
    unint64_t v28 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would trigger an overflow";
    goto LABEL_71;
  }

  if (v26 != (int)v26)
  {
    unint64_t v28 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current pos"
          "ition would overflow.";
    goto LABEL_71;
  }

  unint64_t v28 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
  if ((v26 & 0x80000000) != 0
    || (int)v26 + 8 > v23
    || ((__int128 v29 = (int)v26, v30 = (uint64_t)(int)v26 >> 63, v31 = (void **)(v20 + v29), !__CFADD__(v20, v29))
      ? (__int128 v32 = v30)
      : (__int128 v32 = v30 + 1),
        (size_t v33 = v32 << 63 >> 63,
         unint64_t v28 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.",
         v33 ^ v32)
     || v33 < 0))
  {
LABEL_71:
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v28, v9);
  }

  unint64_t v34 = (void *)*((void *)&v48 + 1);
  __int128 v35 = *v31;
  if (*v31)
  {
    __int128 v36 = v35[1];
    if (v36 <= 0)
    {
      uint64_t v46 = __cxa_allocate_exception(8uLL);
      *uint64_t v46 = "Over-release of an object";
      __cxa_throw(v46, MEMORY[0x1896146E0], 0LL);
    }

    __int128 v37 = v36 - 1;
    v35[1] = v37;
    if (!v37) {
      (*(void (**)(void *))(*v35 + 8LL))(v35);
    }
  }

  char *v31 = v34;
  char v38 = *(void *)(a1[5] + 8LL);
  CFTypeID v39 = *(void *)(v38 + 24);
  uint64_t v40 = v39 + 1;
  uint64_t v41 = v39 == -1;
  uint64_t v43 = v41 << 63 >> 63 != v41 || v41 << 63 >> 63 == -1;
  if (v43)
  {
    unint64_t v44 = *(void *)(a1[4] + 8LL);
    *(_DWORD *)(v44 + 40) = 10;
    *(void *)(v44 + 48) = "Array contains too many elements";
    *(void *)(v44 + 56) = 32LL;
    return 0LL;
  }

  else
  {
    *(void *)(v38 + 24) = v40;
    return (void *)!v43;
  }

    if (!a2 && v6 == a3)
    {
      OID = *(void *)(a3 + 32);
      if (OID || (OID = SECOID_FindOID(a3), (*(void *)(a3 + 32) = OID) != 0LL)) {
        unint64_t v19 = *(_DWORD *)(OID + 16);
      }
      else {
        unint64_t v19 = 0;
      }
      *(_DWORD *)(a1 + 24) = v19;
      *(void *)(a1 + 32) = *(void *)(a3 + 16);
    }

    return;
  }

  char v8 = v7 > 0x1E;
  BOOL v9 = (1 << v7) & 0x6C000000;
  if (v8 || v9 == 0) {
    BOOL v11 = 0LL;
  }
  else {
    BOOL v11 = *(void *)(a1 + 32);
  }
  if (*(void *)(a1 + 32)) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0LL;
  }
  char v13 = *(void *)(v12 + 32);
  if (v13 || (char v13 = SECOID_FindOID(v12), (*(void *)(v12 + 32) = v13) != 0LL))
  {
    unint64_t v14 = *(_DWORD *)(v13 + 16);
    if (a2) {
      goto LABEL_33;
    }
  }

  else
  {
    unint64_t v14 = 0;
    if (a2)
    {
LABEL_33:
      unint64_t v20 = v12 + 72;
      if (a2 && v20 == a3)
      {
        if (v14 == 25 && (unint64_t v21 = *(void *)(v12 + 16)) != 0) {
          nss_cms_encoder_work_data(a1, *(char **)(v21 + 8), *(void *)v21, 1, 1);
        }
        else {
          *(_DWORD *)(*(void *)a1 + 24LL) = 1;
        }
        return;
      }

      if (a2 || v20 != a3) {
        return;
      }
      switch(*(_DWORD *)(a1 + 24))
      {
        case 0x1A:
          uint64_t v22 = SecCmsSignedDataEncodeAfterData(*(void *)(a1 + 32));
          goto LABEL_66;
        case 0x1B:
        case 0x1E:
          SecCmsEncryptedDataEncodeAfterData(*(void *)(a1 + 32));
          goto LABEL_70;
        case 0x1D:
          uint64_t v22 = SecCmsDigestedDataEncodeAfterData(*(void **)(a1 + 32));
LABEL_66:
          if (v22) {
            goto LABEL_67;
          }
          goto LABEL_70;
        default:
LABEL_67:
          *(_DWORD *)(a1 + 64) = PORT_GetError();
          ThreadErrInfo = PR_getThreadErrInfo(1, (int *)v40);
          if (ThreadErrInfo) {
            *ThreadErrInfo = 0LL;
          }
          break;
      }

      goto LABEL_70;
    }
  }

  if (v12 != a3) {
    goto LABEL_33;
  }
  switch(*(_DWORD *)(a1 + 24))
  {
    case 0x1A:
      uint64_t v23 = *(uint64_t **)(a1 + 32);
      unint64_t v24 = (uint64_t *)v23[17];
      if (v24) {
        goto LABEL_48;
      }
      goto LABEL_50;
    case 0x1B:
    case 0x1E:
      uint64_t v15 = *(void *)(a1 + 32);
      if (!v15) {
        goto LABEL_82;
      }
      unint64_t v16 = *(const __CFData **)(v15 + 80);
      if (!v16) {
        goto LABEL_82;
      }
      CFRetain(*(CFTypeRef *)(v15 + 80));
      *(void *)(v15 + 96) = SecCmsCipherContextStart(*(void *)(*(void *)(v15 + 24) + 120LL), v16, v15 + 40, 1);
      CFRelease(v16);
      if (!*(void *)(v15 + 96)) {
        goto LABEL_82;
      }
      goto LABEL_49;
    case 0x1D:
      uint64_t v23 = *(uint64_t **)(a1 + 32);
      if (!v23[17]) {
        goto LABEL_53;
      }
      if (!v23[21])
      {
        v40[0] = v23 + 17;
        v40[1] = 0LL;
        unint64_t v24 = v40;
LABEL_48:
        started = SecCmsDigestContextStartMultiple(v24);
        v23[13] = started;
        if (!started) {
          goto LABEL_82;
        }
      }

  PORT_FreeArena(**(void ***)a1, 0);
  free(a1);
  ThreadErrInfo = PR_getThreadErrInfo(1, &v15);
  if (ThreadErrInfo) {
    *ThreadErrInfo = 0LL;
  }
  return Error;
}

  uint64_t v22 = SecDERItemCopyOIDDecimalRepresentation(v6, (unsigned __int8 **)a2);
  uint64_t v23 = copyOidDescription(v6, a2, a3);
  appendProperty(a1, @"section", v22, v23, Mutable, a3);
  if (v23) {
    CFRelease(v23);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

        goto LABEL_27;
      }

      if (v16)
      {
        SecError(-50, (__CFString **)error, @"Unsupported key class: %@", v15);
        goto LABEL_25;
      }

      if (v14 <= 104)
      {
        if (v14 == 42)
        {
          __int128 v50 = CFDataGetBytePtr(keyData);
          unsigned int v51 = CFDataGetLength(keyData);
          CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecRSAPublicKeyDescriptor, (uint64_t)v50, v51, 7LL);
          if (CTKKey) {
            goto LABEL_28;
          }
          SecError(-50, (__CFString **)error, @"RSA public key creation from data failed");
        }

        else if (v14 == 43 || v14 == 73)
        {
LABEL_39:
          size_t v26 = CFDataGetBytePtr(keyData);
          unint64_t v27 = CFDataGetLength(keyData);
          CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecECPublicKeyDescriptor, (uint64_t)v26, v27, 7LL);
          if (CTKKey) {
            goto LABEL_28;
          }
          SecError(-50, (__CFString **)error, @"EC public key creation from data failed");
        }

        else
        {
LABEL_37:
          [MEMORY[0x189607968] numberWithLongLong:v14];
          size_t v25 = (void *)objc_claimAutoreleasedReturnValue();
          SecError(-50, (__CFString **)error, @"Unsupported public key type: %@ (algorithm: %@)", v13, v25);
        }
      }

      else
      {
        switch(v14)
        {
          case 'i':
            __int128 v18 = CFDataGetBytePtr(keyData);
            unint64_t v19 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd25519PublicKeyDescriptor, (uint64_t)v18, v19, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"Ed25519 public key creation from data failed");
            break;
          case 'j':
            unint64_t v42 = CFDataGetBytePtr(keyData);
            uint64_t v43 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX25519PublicKeyDescriptor, (uint64_t)v42, v43, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"X25519 public key creation from data failed");
            break;
          case 'k':
            unint64_t v44 = CFDataGetBytePtr(keyData);
            BOOL v45 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd448PublicKeyDescriptor, (uint64_t)v44, v45, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"Ed448 public key creation from data failed");
            break;
          case 'l':
            uint64_t v46 = CFDataGetBytePtr(keyData);
            unsigned int v47 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX448PublicKeyDescriptor, (uint64_t)v46, v47, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"X448 public key creation from data failed");
            break;
          case 'm':
            CFTypeID v48 = CFDataGetBytePtr(keyData);
            uint64_t v49 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecKyberPublicKeyDescriptor, (uint64_t)v48, v49, 0LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"Kyber public key creation from data failed");
            break;
          default:
            goto LABEL_37;
        }
      }
    }

    unint64_t v17 = 0;
    goto LABEL_25;
  }

  CTKKey = (__SecKey *)SecKeyCreateCTKKey(v8, (uint64_t)attributes, error);
  if (!CTKKey)
  {
    _SECKEY_LOG_9790();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      if (error) {
        unint64_t v12 = *error;
      }
      else {
        unint64_t v12 = 0LL;
      }
      *(_DWORD *)__int128 buf = 138543618;
      *(void *)int v54 = Value;
      *(_WORD *)&v54[8] = 2114;
      *(void *)int v55 = v12;
      __int128 v29 = "Failed to create key for tokenID=%{public}@: %{public}@";
      char v30 = v11;
      __int128 v31 = 22;
LABEL_60:
      _os_log_debug_impl(&dword_1804F4000, v30, OS_LOG_TYPE_DEBUG, v29, buf, v31);
      goto LABEL_26;
    }

    goto LABEL_26;
  }

    return 4294967246LL;
  }

  unint64_t v10 = CFDictionaryCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  (int)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"r_PersistentRef",  *MEMORY[0x189604DE8]);
  uint64_t result = 0LL;
  BOOL v11 = SecItemCopyMatching(v10, &result);
  if ((_DWORD)v11)
  {
    secLogObjForScope("SecError");
    unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 2112;
      *(void *)&buf[10] = a1;
      _os_log_impl( &dword_1804F4000,  v12,  OS_LOG_TYPE_DEFAULT,  "SecKeyCopyPersistentRef: received status %i for key %@",  buf,  0x12u);
    }

    char v13 = (__CFString *)CFStringCreateWithFormat(0LL, 0LL, @"Expected to find persistentref for key %@", a1);
    secLogObjForScope("SecError");
    unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "stackshot report, reason: %@, code=%08x", buf, 0x12u);
    }

    if (__simulate_crash_counter == -1) {
      goto LABEL_12;
    }
    if (!CrashReporterSupportLibraryCore_frameworkLibrary)
    {
      *(_OWORD *)__int128 buf = xmmword_189676A60;
      *(void *)&uint8_t buf[16] = 0LL;
      CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
    }

    if (!CrashReporterSupportLibraryCore_frameworkLibrary)
    {
LABEL_12:
      if (!CrashReporterSupportLibraryCore_frameworkLibrary)
      {
        *(_OWORD *)__int128 buf = xmmword_189676A60;
        *(void *)&uint8_t buf[16] = 0LL;
        CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
      }

      if (CrashReporterSupportLibraryCore_frameworkLibrary)
      {
        uint64_t v15 = v13;
        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x2020000000LL;
        unint64_t v16 = getWriteStackshotReportSymbolLoc_ptr;
        unint64_t v27 = getWriteStackshotReportSymbolLoc_ptr;
        if (!getWriteStackshotReportSymbolLoc_ptr)
        {
          unint64_t v17 = CrashReporterSupportLibrary();
          unint64_t v16 = dlsym(v17, "WriteStackshotReport");
          *(void *)(*(void *)&buf[8] + 24LL) = v16;
          getWriteStackshotReportSymbolLoc_ptr = v16;
        }

        _Block_object_dispose(buf, 8);
        if (!v16)
        {
          [MEMORY[0x1896077D8] currentHandler];
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend( NSString,  "stringWithUTF8String:",  "BOOL soft_WriteStackshotReport(NSString *__strong, mach_exception_data_type_t)");
          unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend( v23,  "handleFailureInFunction:file:lineNumber:description:",  v24,  @"simulate_crash.m",  25,  @"%s",  dlerror());

          __break(1u);
        }

        ((void (*)(__CFString *, void))v16)(v15, v11);
      }
    }

    if (v13) {
      CFRelease(v13);
    }
LABEL_32:
    if (result) {
      CFRelease(result);
    }
    goto LABEL_34;
  }

  unint64_t v19 = CFGetTypeID(result);
  if (v19 != CFDataGetTypeID())
  {
    secLogObjForScope("SecError");
    unint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v21 = CFGetTypeID(result);
      *(_DWORD *)__int128 buf = 134218242;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = a1;
      _os_log_impl( &dword_1804F4000,  v20,  OS_LOG_TYPE_DEFAULT,  "SecKeyCopyPersistentRef: SecItemCopyMatching returned success, but we got type %lu instead of CFData for key %@.",  buf,  0x16u);
    }

    BOOL v11 = 4294941996LL;
    goto LABEL_32;
  }

  BOOL v11 = 0LL;
  *a2 = result;
  uint64_t result = 0LL;
LABEL_34:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

        appendError(v1, @"One or more certificates is using a weak signature algorithm.");
        if ((context & 0x200) == 0) {
          goto LABEL_29;
        }
LABEL_27:
        unint64_t v10 = @"One or more certificates have been revoked.";
        goto LABEL_28;
      }

      unint64_t v10 = @"One or more unsupported critical extensions found.";
    }

  if (memchr("0123456789.", __str.__r_.__value_.__s.__data_[0], 0xCuLL)) {
    goto LABEL_32;
  }
  char v13 = v4;
  unint64_t v14 = &__str;
  do
LABEL_34:
    uint64_t v15 = v13--;
  while (memchr("0123456789.", v14->__r_.__value_.__s.__data_[v13], 0xCuLL));
  unint64_t v16 = v14->__r_.__value_.__s.__data_[v15] == 46;
  if (v14->__r_.__value_.__s.__data_[v15] == 46) {
    unint64_t v17 = v15 + 1;
  }
  else {
    unint64_t v17 = v15;
  }
  if ((v4 & 0x80u) == 0) {
    __int128 v18 = v4;
  }
  else {
    __int128 v18 = __str.__r_.__value_.__l.__size_;
  }
  if (v17 < v18)
  {
    unint64_t v19 = (uint64_t)v14->__r_.__value_.__r.__words + v16 + 1;
    while (memchr("0123456789", *(char *)(v19 + v13), 0xBuLL))
    {
      ++v19;
      if (++v17 >= v18)
      {
        unint64_t v17 = v18;
        break;
      }
    }
  }

  std::string::basic_string(a1, &__str, 0LL, v17, (std::allocator<char> *)&v20);
}

unint64_t CTDecompressDate(unint64_t result, void *a2, unint64_t *a3)
{
  unsigned int v4 = *(unsigned __int8 *)result;
  if (v4 >= 0x32)
  {
    if (v4 != 50) {
      goto LABEL_9;
    }
    if (result != -1LL)
    {
      if (*(_BYTE *)(result + 1) != 48) {
        goto LABEL_9;
      }
      if (result <= 0xFFFFFFFFFFFFFFFDLL)
      {
LABEL_9:
        uint64_t v7 = 0LL;
        unint64_t v5 = 14LL;
        unint64_t v6 = 17LL;
        if (!a2) {
          goto LABEL_19;
        }
        goto LABEL_10;
      }
    }

LABEL_2:
  unint64_t v5 = 12LL;
  unint64_t v6 = 15LL;
  uint64_t v7 = 2LL;
  if (!a2)
  {
LABEL_19:
    uint64_t v8 = 0LL;
    if (a3) {
      *a3 = v6;
    }
    return v8;
  }

unint64_t CTCompressGetCommonNameSuffixPointer(unint64_t *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t result = compare_octet_string_partial((uint64_t)&MFi4RootName, (uint64_t)&v7);
  if (!(_DWORD)result)
  {
    unint64_t v4 = v7;
    if (v7 < 0xFFFFFFFFFFFFFFE6LL)
    {
      unint64_t v5 = v8;
      unint64_t result = v7 + 26;
      goto LABEL_11;
    }

uint64_t CTGetGeneralizedTime(uint64_t result, unint64_t a2)
{
  BOOL v2 = (uint64_t **)result;
  uint64_t v3 = *(void *)(result + 8);
  if (v3 != 13)
  {
    if (v3 != 15) {
      return 720909LL;
    }
    unint64_t result = 0LL;
    unint64_t v4 = *v2;
    uint64_t v5 = *v4;
    *(void *)(a2 + 6) = *(uint64_t *)((char *)v4 + 6);
    *(void *)a2 = v5;
    return result;
  }

  if (a2 >= 0xFFFFFFFFFFFFFFFELL)
  {
    __break(0x5513u);
    goto LABEL_12;
  }

  uint64_t v6 = **(void **)result;
  *(_DWORD *)(a2 + 10) = *(_DWORD *)(*(void *)result + 8LL);
  *(void *)(a2 + 2) = v6;
  if (!*(void *)(result + 8))
  {
LABEL_12:
    __break(0x5519u);
    return result;
  }

  if (**(unsigned __int8 **)result > 0x34u)
  {
    unint64_t result = 0LL;
    __int16 v7 = 14641;
  }

  else
  {
    unint64_t result = 0LL;
    __int16 v7 = 12338;
  }

  *(_WORD *)a2 = v7;
  return result;
}

uint64_t X509PolicySetFlagsForCommonNames(uint64_t a1)
{
  unint64_t v4[2] = *MEMORY[0x1895F89C0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  v4[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v4);
  if (!(_DWORD)result)
  {
    uint64_t result = compare_octet_string((uint64_t)&iPhoneCAName, (uint64_t)v4);
    if ((_DWORD)result)
    {
      uint64_t result = compare_octet_string((uint64_t)&CodeSigningCAName, (uint64_t)v4);
      if ((_DWORD)result)
      {
        uint64_t result = compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)v4);
        if ((_DWORD)result)
        {
          uint64_t result = compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)v4);
          if ((_DWORD)result)
          {
            uint64_t result = compare_octet_string_partial((uint64_t)&MFi4ProvisioningCAName, (uint64_t)v4);
            if ((_DWORD)result) {
              return result;
            }
            uint64_t v3 = 0x1000000000LL;
          }

          else
          {
            uint64_t v3 = 0x800000000LL;
          }
        }

        else
        {
          uint64_t v3 = 0x400000000LL;
        }
      }

      else
      {
        uint64_t v3 = 8LL;
      }
    }

    else
    {
      uint64_t v3 = 3840LL;
    }

    *(void *)(a1 + 240) |= v3;
  }

  return result;
}

double X509PolicySetFlagsForMFI(uint64_t a1)
{
  void v6[2] = *MEMORY[0x1895F89C0];
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v6))
  {
    time_t v5 = 0LL;
    if (!X509CertificateGetNotBefore(a1, &v5))
    {
      memset(&v4, 0, sizeof(v4));
      strptime("2006-05-31", "%F", &v4);
      time_t v3 = timegm(&v4);
      double result = difftime(v3, v5);
      if (result < 0.0)
      {
        *(void *)(a1 + 240) |= 0x8000000uLL;
LABEL_3:
      }
    }
  }

  return result;
}

uint64_t X509PolicySetFlagsForRoots(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  if (*(_BYTE *)(result + 16))
  {
    double result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootCASPKI);
    if (!(_DWORD)result
      || (double result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG2SPKI), !(_DWORD)result)
      || (double result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG3SPKI), !(_DWORD)result))
    {
      uint64_t v5 = *(void *)(a2 + 240) | 0x58E30653FFF8LL;
      goto LABEL_11;
    }
  }

  uint64_t v4 = *(void *)(v3 + 8);
  if ((v4 & 0x1000000) != 0)
  {
    double result = compare_octet_string(a2 + 88, (uint64_t)&UcrtRootSpki);
    if (!(_DWORD)result)
    {
      uint64_t v5 = *(void *)(a2 + 240) | 0x1000000LL;
      goto LABEL_11;
    }

LABEL_13:
    if (*(_BYTE *)(v3 + 17)) {
      double result = X509PolicySetFlagsForTestAnchor((void *)v3, a2);
    }
    goto LABEL_15;
  }

  if ((v4 & 0x1C00000000LL) == 0) {
    goto LABEL_15;
  }
  double result = compare_octet_string(a2 + 88, (uint64_t)&MFi4RootSpki);
  if ((_DWORD)result) {
    goto LABEL_13;
  }
  uint64_t v5 = *(void *)(a2 + 240) | 0x1C00000000LL;
LABEL_11:
  *(void *)(a2 + 240) = v5;
LABEL_15:
  if (*(_BYTE *)(v3 + 16))
  {
    if (*(_BYTE *)(v3 + 17))
    {
      double result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootCASPKI);
      if (!(_DWORD)result
        || (double result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG2SPKI), !(_DWORD)result)
        || (double result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG3SPKI), !(_DWORD)result))
      {
        *(void *)(a2 + 240) |= 0x58E30653FFF8uLL;
      }
    }

    if (*(_BYTE *)(v3 + 16) && *(_BYTE *)(v3 + 17))
    {
      double result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootECCSPKI);
      if (!(_DWORD)result) {
        *(void *)(a2 + 240) |= 0x6400000uLL;
      }
    }
  }

  return result;
}

    __break(0x5519u);
  }

  return result;
}

  __break(0x5513u);
  return result;
}

  objc_autoreleasePoolPop(v23);
  [v22 reset];

  objc_autoreleasePoolPop(context);
}

  return v5;
}

  if (v7 && !v11)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
LABEL_21:
    CFRelease(v7);
    goto LABEL_22;
  }

  if (v11) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14) {
    return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
  }
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) &= CFEqual(v7, v11);
  if (!v12) {
    goto LABEL_21;
  }
LABEL_22:
  if (v13) {
    goto LABEL_23;
  }
  return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
}

LABEL_14:
  if (!v7 || [&unk_18969C018 indexOfObject:v7] != 0x7FFFFFFFFFFFFFFFLL)
  {
    [v3 lastPathComponent];
    unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v17 = [v16 stringByDeletingPathExtension];

    __int16 v7 = (id)v17;
  }

  return v7;
}

  if (v2) {
LABEL_14:
  }
    CFRelease(v2);
  if (v4) {
    CFRelease(v4);
  }
  ThreadErrInfo = PR_getThreadErrInfo(1, &v16);
  if (ThreadErrInfo) {
    *ThreadErrInfo = 0xFFFFE02700000000LL;
  }
  return 0LL;
}

    memset(v25, 170, sizeof(v25));
    unint64_t v16 = 0;
    memset(v24, 170, sizeof(v24));
    while (1)
    {
      unint64_t v17 = DERDecodeSeqNext(v25, (unint64_t *)v24);
      if (v17) {
        break;
      }
      if (*(void *)v24 <= 0x1CuLL && ((1LL << SLOBYTE(v24[0])) & 0x1E7C1000) != 0)
      {
        unint64_t v19 = CFGetAllocator(Mutable);
        unint64_t v20 = copyDERThingContentDescription(v19, *(uint64_t *)v24, (uint64_t)&v24[2], a3);
        if (!v20) {
          goto LABEL_25;
        }
        unint64_t v21 = v20;
        appendProperty(Mutable, @"string", @"Data", 0LL, v20, a3);
        CFRelease(v21);
        unint64_t v16 = 1;
      }
    }

    if (v17 != 1 || (v16 & 1) == 0) {
LABEL_25:
    }
      appendRelabeledProperty(Mutable, @"Data", 0LL, a2 + 24, @"Unparsed %@", a3);
  }

  return 4294967246LL;
}

  unint64_t v17 = 0LL;
LABEL_17:
  CFRelease(v7);
  return v17;
}

uint64_t X509PolicySetFlagsForTestAnchor(void *a1, uint64_t a2)
{
  void v6[2] = *MEMORY[0x1895F89C0];
  v6[0] = 0LL;
  v6[1] = 0LL;
  v5[0] = 0LL;
  v5[1] = 0LL;
  uint64_t result = X509CertificateParseSPKI((unint64_t *)(a2 + 88), v6, 0LL, v5);
  if (!(_DWORD)result)
  {
    uint64_t result = compare_octet_string(a1[4], (uint64_t)v6);
    if (!(_DWORD)result)
    {
      uint64_t result = compare_octet_string(a1[3], (uint64_t)v5);
      if (!(_DWORD)result) {
        *(void *)(a2 + 240) |= a1[1];
      }
    }
  }

  return result;
}

uint64_t X509PolicyCheckForBlockedKeys(uint64_t a1)
{
  uint64_t result = compare_octet_string(a1 + 88, (uint64_t)&BlockedYonkersSPKI);
  if (!(_DWORD)result) {
    *(void *)(a1 + 240) &= 0xFFFFFFFFFFF3FFFFLL;
  }
  return result;
}

uint64_t CTParseAmfiCMS_internal( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, __int128 *))
{
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = a1 + 24;
  *(void *)a1 = 4LL;
  *(void *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a5 + 16);
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = 1LL;
  *(_DWORD *)(a2 + 168) = 327681;
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 16);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a5 + 84);
  uint64_t result = CMSParseContentInfoSignedData(*(char **)a5, *(void *)(a5 + 8), (unint64_t *)a1);
  if (!(_DWORD)result)
  {
    uint64_t result = CMSParseSignerInfos(a1, a3, a6);
    if (!(_DWORD)result) {
      return *(unsigned int *)(a2 + 168);
    }
  }

  return result;
}

uint64_t CTAmfiVerifyCertificateChain(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v2;
  v10[1] = v2;
  v9[7] = v2;
  uint8_t v9[8] = v2;
  v9[5] = v2;
  v9[6] = v2;
  unint64_t v9[3] = v2;
  v9[4] = v2;
  v9[1] = v2;
  v9[2] = v2;
  v9[0] = v2;
  memset(v11, 0, sizeof(v11));
  uint64_t v12 = 0LL;
  uint64_t result = CTParseAmfiCMS_internal( (uint64_t)v11,  (uint64_t)v9,  (uint64_t)v13,  (uint64_t)__b,  a1,  (uint64_t (*)(uint64_t, uint64_t, __int128 *))CTBuildPathForVerifiedIndex);
  if (!(_DWORD)result)
  {
    uint64_t v8 = 0LL;
    unint64_t v5 = 0xAAAAAAAAAAAAAA01LL;
    __int128 v4 = xmmword_180651200;
    BYTE1(v5) = *(_BYTE *)(a1 + 20);
    WORD1(v5) = 0;
    __int128 v6 = 0u;
    __int128 v7 = 0u;
    uint64_t result = X509ChainCheckPathWithOptions(29, (uint64_t *)v10 + 1, (uint64_t)&v4, &v8);
    if ((_DWORD)result)
    {
      *(void *)(a1 + 96) = 0LL;
      return X509ChainCheckPathWithOptions(29, (uint64_t *)v10 + 1, 0LL, 0LL);
    }

    else
    {
      *(void *)(a1 + 96) = v8;
    }
  }

  return result;
}

uint64_t CTBuildPathForVerifiedIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  else {
    return CMSBuildPath(a1, a2, a3);
  }
}

uint64_t CTVerifyAmfiCertificateChain(uint64_t a1, uint64_t a2, char a3, int a4, void *a5)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v8 = 0u;
  v7[0] = a1;
  v7[1] = a2;
  LODWORD(v8) = a4;
  BYTE4(v8) = a3;
  uint64_t result = CTAmfiVerifyCertificateChain((uint64_t)v7);
  if (a5)
  {
    if (!(_DWORD)result) {
      *a5 = v13;
    }
  }

  return result;
}

char *find_digest(uint64_t a1)
{
  unint64_t v2 = 0LL;
  while (1)
  {
    uint64_t result = (char *)compare_octet_string_raw((uint64_t)&digests + v2 + 8, *(const void **)a1, *(void *)(a1 + 8));
    if (!(_DWORD)result) {
      break;
    }
    v2 += 32LL;
    if (v2 == 160) {
      return 0LL;
    }
  }

  __break(0x5513u);
  return result;
}

unint64_t validateSignatureRSA(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  unint64_t result = 0LL;
  uint64_t v27 = *MEMORY[0x1895F89C0];
  char v23 = 0;
  if (a1)
  {
    if (a2)
    {
      unint64_t result = 0LL;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            unint64_t result = compare_octet_string((uint64_t)&rsaEncryption, (uint64_t)(a5 + 7));
            if (!(_DWORD)result
              || (unint64_t result = validateOIDs((uint64_t)&rsaAlgs, (uint64_t)(a5 + 3), (uint64_t)(a5 + 7)), (_DWORD)result))
            {
              unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
              unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
              unint64_t v10 = a5[9];
              uint64_t v9 = a5[10];
              if (__CFADD__(v10, v9)) {
                goto LABEL_31;
              }
              if (v10 > v10 + v9) {
                goto LABEL_32;
              }
              unint64_t v21 = a5[9];
              unint64_t v22 = v10 + v9;
              if (!v9 || (unint64_t result = ccder_blob_check_null(), (_DWORD)result))
              {
                if (!__CFADD__(a1, a2))
                {
                  if (a1 + a2 >= a1)
                  {
                    unint64_t result = ccder_decode_rsa_pub_n();
                    if (!result) {
                      return result;
                    }
                    unint64_t v11 = result;
                    if (result >> 58)
                    {
LABEL_33:
                      __break(0x550Cu);
                      return result;
                    }

                    unint64_t v12 = result << 6;
                    if (result << 6 < 0x400) {
                      return 0LL;
                    }
                    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
                    __int16 v26 = -21846;
                    char v24 = 6;
                    if (&vars0 != (uint64_t *)82)
                    {
                      unint64_t v13 = a5[4];
                      LOBYTE(v25) = v13;
                      if ((unint64_t)&v24 <= 0xFFFFFFFFFFFFFFFDLL)
                      {
                        if (v13 <= 9)
                        {
                          uint64_t v14 = __memcpy_chk();
                          if (v12 > 0x1068) {
                            return 0LL;
                          }
                          unint64_t result = MEMORY[0x1895F8858](v14);
                          unint64_t v16 = (unint64_t *)((char *)&v20 - v15);
                          unint64_t v17 = 0LL;
                          *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
                          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
                          do
                          {
                            unint64_t v19 = &v16[v17 / 8];
                            *(_OWORD *)unint64_t v19 = v18;
                            *((_OWORD *)v19 + 1) = v18;
                            v17 += 32LL;
                          }

                          while (v15 != v17);
                          if (v15 >= 1)
                          {
                            *unint64_t v16 = v11;
                            unint64_t result = 0LL;
                            char v23 = 0;
                            return result;
                          }
                        }

                        goto LABEL_32;
                      }
                    }

                    goto LABEL_31;
                  }

LABEL_32:
                  __break(0x5519u);
                  goto LABEL_33;
                }

  unint64_t v19 = CFStringGetLength(a1);
  uint64_t v20 = v19;
  if (!CFStringHasPrefix(a1, @"[")
    || !CFStringHasSuffix(a1, @"]")
    || (v46.length = v20 - 2, v46.location = 1LL, (unint64_t v21 = CFStringCreateWithSubstring(0LL, a1, v46)) == 0LL)
    || (unint64_t v22 = v21, MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, v21), CFRelease(v22), !MutableCopy))
  {
    MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, a1);
  }

  System = CFLocaleGetSystem();
  CFStringUppercase(MutableCopy, System);
  unint64_t v25 = CFCharacterSetCreateWithCharactersInString(0LL, @"0123456789ABCDEF:");
  __int16 v26 = CFCharacterSetCreateInvertedSet(0LL, v25);
  uint64_t v27 = CFDataCreateMutable(0LL, 0LL);
  unint64_t v28 = CFStringCreateArrayBySeparatingStrings(0LL, MutableCopy, @":");
  __int128 v29 = v28;
  if (v28) {
    char v30 = CFArrayGetCount(v28);
  }
  else {
    char v30 = 0LL;
  }
  v47.size_t length = CFStringGetLength(MutableCopy);
  v47.location = 0LL;
  if (CFStringFindCharacterFromSet(MutableCopy, v26, v47, 0x200uLL, 0LL)
    || CFArrayGetCount(v29) < 3
    || CFArrayGetCount(v29) > 8)
  {
    goto LABEL_69;
  }

  unint64_t v42 = a2;
  if (v30 >= 1)
  {
    for (size_t i = 0LL; i != v30; ++i)
    {
      *(_WORD *)unint64_t v44 = 0;
      __int128 v32 = (const __CFString *)CFArrayGetValueAtIndex(v29, i);
      if (v32)
      {
        size_t v33 = v32;
        CFRetain(v32);
        unint64_t v34 = CFStringGetLength(v33);
        __int128 v35 = CFStringGetMaximumSizeForEncoding(v34, 0x8000100u) + 1;
        __int128 v36 = (char *)malloc(v35);
        if (!CFStringGetCString(v33, v36, v35, 0x8000100u)) {
          *__int128 v36 = 0;
        }
        CFRelease(v33);
        if (!v36)
        {
LABEL_56:
          if (i && i != v30 - 1)
          {
            if ((unint64_t)v30 <= 8)
            {
              char v38 = v30 - 9;
              do
                CFDataAppendBytes(v27, v44, 2LL);
              while (!__CFADD__(v38++, 1LL));
            }

            goto LABEL_64;
          }

          goto LABEL_63;
        }
      }

      else
      {
        __int128 v36 = strdup((const char *)&unk_18065A197);
        if (!v36) {
          goto LABEL_56;
        }
      }

      __int128 v37 = strlen(v36);
      if (!v37) {
        goto LABEL_56;
      }
      if (v37 <= 4)
      {
        *(_WORD *)unint64_t v44 = bswap32(strtoul(v36, 0LL, 16)) >> 16;
LABEL_63:
        CFDataAppendBytes(v27, v44, 2LL);
      }

      -[AcmeCertRequest attestationObjectWithCertificates:]( self,  "attestationObjectWithCertificates:",  self->_attestationChain);
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
      if (v46)
      {
        -[SecJWSEncoder base64URLEncodedStringRepresentationWithData:]( self->_encoder,  "base64URLEncodedStringRepresentationWithData:",  v46);
        unsigned int v47 = (void *)objc_claimAutoreleasedReturnValue();
        [v3 setObject:v47 forKeyedSubscript:@"attObj"];
      }

LABEL_35:
      CFTypeID v48 = self->_encoder;
      uint64_t v49 = self->_account;
      __int128 v50 = self->_nonce;
      unsigned int v51 = self->_nextMessageURL;
      int v54 = v36;
      -[SecJWSEncoder encodedJWSWithPayload:kid:nonce:url:error:]( v48,  "encodedJWSWithPayload:kid:nonce:url:error:",  v3,  v49,  v50,  v51,  &v54);
      __int128 v8 = (__CFString *)objc_claimAutoreleasedReturnValue();
      unint64_t v28 = v54;

LABEL_14:
LABEL_15:
      -[__CFString dataUsingEncoding:](v8, "dataUsingEncoding:", 4LL);
      size_t v33 = (void *)objc_claimAutoreleasedReturnValue();

      return v33;
    case 7LL:
      -[SecJWSEncoder base64URLEncodedStringRepresentationWithData:]( self->_encoder,  "base64URLEncodedStringRepresentationWithData:",  self->_csr);
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
      [v3 setObject:v10 forKeyedSubscript:@"csr"];

      unint64_t v11 = self->_encoder;
      unint64_t v12 = self->_account;
      unint64_t v13 = self->_nonce;
      uint64_t v14 = self->_nextMessageURL;
      unint64_t v53 = 0LL;
      -[SecJWSEncoder encodedJWSWithPayload:kid:nonce:url:error:]( v11,  "encodedJWSWithPayload:kid:nonce:url:error:",  v3,  v12,  v13,  v14,  &v53);
      __int128 v8 = (__CFString *)objc_claimAutoreleasedReturnValue();
      uint64_t v9 = v53;
      goto LABEL_13;
    case 8LL:
    case 9LL:
      __int128 v4 = self->_encoder;
      unint64_t v5 = self->_account;
      __int128 v6 = self->_nonce;
      __int128 v7 = self->_nextMessageURL;
      char v52 = 0LL;
      -[SecJWSEncoder encodedJWSWithPayload:kid:nonce:url:error:]( v4,  "encodedJWSWithPayload:kid:nonce:url:error:",  0LL,  v5,  v6,  v7,  &v52);
      __int128 v8 = (__CFString *)objc_claimAutoreleasedReturnValue();
      uint64_t v9 = v52;
LABEL_13:
      unint64_t v28 = v9;
      goto LABEL_14;
    default:
      __int128 v8 = @"{}";
      goto LABEL_15;
  }

      __cxa_end_catch();
      JUMPOUT(0x18061F568LL);
    case 5:
      uint64_t v9 = __cxa_begin_catch(a1);
      unint64_t v10 = (*(uint64_t (**)(void *))(*(void *)v9 + 24LL))(v9);
      if (!v3) {
        goto LABEL_32;
      }
      unint64_t v11 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v10, 0LL);
LABEL_31:
      char *v3 = v11;
      goto LABEL_32;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      unint64_t v16 = (*(uint64_t (**)(void *))(*(void *)v15 + 24LL))(v15);
      if (v3) {
        char *v3 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v16, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v3) {
          char *v3 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
        if (v3) {
          char *v3 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_32;
  }

  unint64_t v12 = __cxa_begin_catch(a1);
  unint64_t v13 = v12[36];
  if (v13 > 0x1A) {
    goto LABEL_28;
  }
  __int128 v8 = -67033;
  uint64_t v14 = 1 << v13;
  if ((v14 & 0x800108) != 0) {
    goto LABEL_29;
  }
  if ((v14 & 0x4014000) != 0) {
    __int128 v8 = -67032;
  }
  else {
LABEL_28:
  }
    __int128 v8 = (*(uint64_t (**)(_DWORD *))(*(void *)v12 + 24LL))(v12);
LABEL_29:
  if (!v3) {
    goto LABEL_32;
  }
  goto LABEL_30;
}

  __cxa_end_catch();
LABEL_33:
  JUMPOUT(0x180624E8CLL);
}

    *a1 = __str;
    return;
  }

      __cxa_end_catch();
      JUMPOUT(0x180646248LL);
    case 5:
      unint64_t v11 = __cxa_begin_catch(a1);
      unint64_t v12 = (*(uint64_t (**)(void *))(*(void *)v11 + 24LL))(v11);
      if (!v2) {
        goto LABEL_32;
      }
      unint64_t v13 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v12, 0LL);
LABEL_31:
      _DWORD *v2 = v13;
      goto LABEL_32;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      unint64_t v17 = __cxa_begin_catch(a1);
      __int128 v18 = (*(uint64_t (**)(void *))(*(void *)v17 + 24LL))(v17);
      if (v2) {
        _DWORD *v2 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v18, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v2) {
          _DWORD *v2 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v19);
        if (v2) {
          _DWORD *v2 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_32;
  }

  uint64_t v14 = __cxa_begin_catch(a1);
  uint64_t v15 = v14[36];
  if (v15 > 0x1A) {
    goto LABEL_28;
  }
  unint64_t v10 = -67033;
  unint64_t v16 = 1 << v15;
  if ((v16 & 0x800108) != 0) {
    goto LABEL_29;
  }
  if ((v16 & 0x4014000) != 0) {
    unint64_t v10 = -67032;
  }
  else {
LABEL_28:
  }
    unint64_t v10 = (*(uint64_t (**)(_DWORD *))(*(void *)v14 + 24LL))(v14);
LABEL_29:
  if (!v2) {
    goto LABEL_32;
  }
  goto LABEL_30;
}

LABEL_31:
                __break(0x5513u);
                goto LABEL_32;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

                            __break(0x5513u);
                            return result;
                          }

                          if (ccec_verify()) {
LABEL_24:
                          }
                            HIBYTE(v17) = 0;
                        }

                        return HIBYTE(v17) != 0;
                      }

  *a3 = v5;
  return AppleCodesigningHashAgility;
}

  *a3 = v5;
  return AppleCodesigningHashAgilityV2;
}

  *((void *)v26 + v27) = 0LL;
  *(void *)&v60[0] = v26;
  if (!v50 || (unint64_t v34 = SecKeyCopyPublicKey(v50)) == 0LL)
  {
    __int128 v35 = (os_log_s *)secLogObjForScope("csr");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)unint64_t v67 = 0;
      _os_log_debug_impl( &dword_1804F4000,  v35,  OS_LOG_TYPE_DEBUG,  "unable to create public key from private, using input public key",  v67,  2u);
      if (a3) {
        goto LABEL_35;
      }
    }

    else if (a3)
    {
LABEL_35:
      CFRetain(a3);
      unint64_t v34 = (__SecKey *)a3;
      goto LABEL_36;
    }

    uint64_t v40 = (os_log_s *)secLogObjForScope("SecError");
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    *(_WORD *)unint64_t v67 = 0;
    uint64_t v41 = "csr: failed to get public key";
LABEL_44:
    _os_log_impl(&dword_1804F4000, v40, OS_LOG_TYPE_DEFAULT, v41, v67, 2u);
LABEL_45:
    unint64_t v34 = 0LL;
LABEL_46:
    unint64_t v42 = 0LL;
    __int128 v37 = 0LL;
    goto LABEL_47;
  }

            if (v21) {
              CFRelease(v21);
            }
            unint64_t v17 = v19 + 1;
          }

          __int16 v26 = (os_log_s *)secLogObjForScope("p12Decode");
          unint64_t v11 = 0;
          if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_31;
          }
          *(_WORD *)__int128 buf = 0;
          char v24 = v26;
          unint64_t v25 = "skipping dup cert";
          goto LABEL_28;
        }
      }

  __int128 v6 = 0LL;
LABEL_32:
  if (a3 && !(_DWORD)v6)
  {
    if (MutableCopy) {
      CFRetain(MutableCopy);
    }
    __int128 v6 = 0LL;
    *a3 = MutableCopy;
  }

  if (MutableCopy) {
LABEL_38:
  }
    CFRelease(MutableCopy);
  return v6;
}

BOOL validateOIDs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = 0LL;
  BOOL v7 = 1;
  do
  {
    BOOL v7 = v6 < 3;
    a1 += 32LL;
    ++v6;
  }

  while (v6 != 4);
  return v7;
}

uint64_t validateSignatureEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 0LL;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  HIBYTE(v17) = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (!compare_octet_string((uint64_t)&ecPublicKey_0, a5 + 56)
              || (uint64_t result = validateOIDs((uint64_t)&ecAlgs, a5 + 24, a5 + 56), (_DWORD)result))
            {
              uint64_t result = ccec_cp_for_oid((int **)(a5 + 72));
              if (result)
              {
                uint64_t v8 = *(void *)result;
                if (*(void *)result >> 61 || !is_mul_ok(8 * v8, 3uLL))
                {
                  __break(0x550Cu);
                }

                else
                {
                  uint64_t v9 = 24 * v8;
                  BOOL v10 = __CFADD__(v9, 16LL);
                  unint64_t v11 = v9 + 16;
                  if (!v10 && v11 < 0xFFFFFFFFFFFFFFF0LL)
                  {
                    uint64_t result = MEMORY[0x1895F8858](result);
                    uint64_t v14 = (uint64_t *)((char *)&v17 - v12);
                    unint64_t v15 = 0LL;
                    do
                    {
                      unint64_t v16 = &v14[v15 / 8];
                      *unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
                      v16[1] = 0xAAAAAAAAAAAAAAAALL;
                      v15 += 16LL;
                    }

                    while (v12 != v15);
                    if (v13 >= 0x10)
                    {
                      uint64_t *v14 = result;
                      if (v12 >= 1)
                      {
                        if (!MEMORY[0x186DFF004]())
                        {
                          uint64_t result = ccec_x963_import_pub_size();
                          if (result == 256 && *(void *)(a5 + 96) == 64LL)
                          {
                            if (*(void *)(a5 + 88) < 0xFFFFFFFFFFFFFFE0LL)
                            {
                              goto LABEL_24;
                            }

LABEL_30:
                      __break(0x5519u);
                      goto LABEL_31;
                    }

    __break(0x5519u);
    goto LABEL_31;
  }

      uint64_t v18 = 0;
LABEL_31:

      goto LABEL_32;
    }

    if ([v12 hasAbc])
    {
      unint64_t v19 = [v8 shouldRatelimit:v10 rule:self];
      getOSLog();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unint64_t v15 = v20;
      if (!v19)
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          -[SFAnalyticsMatchingRule rule](self, "rule");
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue();
          [v40 eventType];
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
          -[SFAnalyticsMatchingRule cachedMatchDictionary](self, "cachedMatchDictionary");
          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)__int128 buf = 138412546;
          __int128 v50 = v41;
          unsigned int v51 = 2112;
          char v52 = v42;
          _os_log_impl( &dword_1804F4000,  v15,  OS_LOG_TYPE_DEFAULT,  "SFACollection action trigger abc: %@ %@",  buf,  0x16u);
        }

        [v12 abc];
        unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        -[os_log_s domain](v15, "domain");
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
        if (v43)
        {
        }

        else
        {
          -[os_log_s type](v15, "type");
          unint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v44) {
            goto LABEL_30;
          }
        }

        -[os_log_s type](v15, "type");
        unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
        -[os_log_s subtype](v15, "subtype");
        unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
        -[os_log_s domain](v15, "domain");
        BOOL v45 = (void *)objc_claimAutoreleasedReturnValue();
        [v8 autoBugCaptureWithType:v21 subType:v22 domain:v45];

LABEL_29:
        goto LABEL_30;
      }

      if (!os_log_type_enabled(v20, OS_LOG_TYPE_INFO)) {
        goto LABEL_30;
      }
      -[SFAnalyticsMatchingRule rule](self, "rule");
      unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      [v21 eventType];
      unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v50 = v22;
      char v23 = "SFACollection ratelimit abc: %@";
      char v24 = v15;
      unint64_t v25 = OS_LOG_TYPE_INFO;
    }

    else
    {
      __int128 v35 = [v12 hasDrop];
      getOSLog();
      unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int128 v36 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if (v35)
      {
        if (v36)
        {
          -[SFAnalyticsMatchingRule rule](self, "rule");
          __int128 v37 = (void *)objc_claimAutoreleasedReturnValue();
          [v37 eventType];
          char v38 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)__int128 buf = 138412290;
          __int128 v50 = v38;
          _os_log_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEFAULT, "SFACollection action trigger drop: %@", buf, 0xCu);
        }

        [v12 drop];
        unint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        CFTypeID v39 = -[os_log_s excludeEvent](v15, "excludeEvent");
        else {
          uint64_t v18 = v39;
        }
        goto LABEL_31;
      }

      if (!v36) {
        goto LABEL_30;
      }
      -[SFAnalyticsMatchingRule rule](self, "rule");
      unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
      [v21 eventType];
      unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v50 = v22;
      char v23 = "SFACollection unknown action: %@";
      char v24 = v15;
      unint64_t v25 = OS_LOG_TYPE_DEFAULT;
    }

    _os_log_impl(&dword_1804F4000, v24, v25, v23, buf, 0xCu);
    goto LABEL_29;
  }

  uint64_t v18 = 0;
LABEL_32:

  return v18;
}

    *a2 = (void *)v26;
    a2[1] = v21;
    a2[2] = (void *)v27;
    if (v28) {
      operator delete(v28);
    }
    goto LABEL_32;
  }

  unint64_t v19 = serializeDict(v3, a2);
LABEL_35:

  return v19;
}

  unint64_t v15 = 0LL;
  if (v7) {
LABEL_21:
  }
    CFRelease(v7);
LABEL_22:
  if (v9) {
    CFRelease(v9);
  }
  return v15;
}

  if (a2 != a3)
  {
    unint64_t v21 = (uint64_t **)(a1 + 8);
    do
    {
      unint64_t v22 = (uint64_t *)operator new(0x20uLL);
      char v23 = *((_DWORD *)a2 + 7);
      *((_DWORD *)v22 + 7) = v23;
      char v24 = *v21;
      unint64_t v25 = (uint64_t **)(a1 + 8);
      __int16 v26 = (uint64_t **)(a1 + 8);
      if (*v21)
      {
        do
        {
          while (1)
          {
            unint64_t v25 = (uint64_t **)v24;
            if (v23 >= *((_DWORD *)v24 + 7)) {
              break;
            }
            char v24 = (uint64_t *)*v24;
            __int16 v26 = v25;
            if (!*v25) {
              goto LABEL_38;
            }
          }

          char v24 = (uint64_t *)v24[1];
        }

        while (v24);
        __int16 v26 = v25 + 1;
      }

uint64_t ccec_cp_for_oid(int **a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = a1[1];
  if (v1 != (int *)7)
  {
    return 0LL;
  }

  uint64_t v3 = *a1;
  int v5 = *v3;
  int v6 = *(int *)((char *)v3 + 3);
  if (v5 != -2127887098 || v6 != 587203713) {
    return 0LL;
  }
  return ccec_cp_521();
}

uint64_t compressECPublicKey(void *a1, int **a2, uint64_t a3, uint64_t a4)
{
  v19[1] = *MEMORY[0x1895F89C0];
  BOOL v7 = (void *)ccec_cp_for_oid(a2);
  if (!v7) {
    return 655366LL;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *v7;
  if (*v7 >> 61 || !is_mul_ok(8 * v9, 3uLL))
  {
    __break(0x550Cu);
    goto LABEL_19;
  }

  uint64_t v10 = 24 * v9;
  BOOL v11 = __CFADD__(v10, 16LL);
  unint64_t v12 = v10 + 16;
  if (v11 || v12 >= 0xFFFFFFFFFFFFFFF0LL) {
LABEL_19:
  }
    __break(0x5500u);
  uint64_t result = MEMORY[0x1895F8858](v7);
  unint64_t v16 = (void *)((char *)v19 - v14);
  unint64_t v17 = 0LL;
  do
  {
    uint64_t v18 = &v16[v17 / 8];
    *uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    v18[1] = 0xAAAAAAAAAAAAAAAALL;
    v17 += 16LL;
  }

  while (v14 != v17);
  if (v15 < 0x10) {
    goto LABEL_21;
  }
  *unint64_t v16 = v8;
  if (v14 < 1)
  {
LABEL_20:
    __break(0x5519u);
LABEL_21:
    __break(1u);
    return result;
  }

  uint64_t result = MEMORY[0x186DFF004](v8, a1[1], *a1, (char *)v19 - v14);
  if (!(_DWORD)result)
  {
    uint64_t result = ccec_compressed_x962_export_pub_size();
    if (result == a4)
    {
      if (!a3 || a4) {
        return ccec_compressed_x962_export_pub();
      }
      goto LABEL_20;
    }

    return 393220LL;
  }

  return result;
}

unint64_t decompressECPublicKey(uint64_t a1, int **a2, uint64_t a3, uint64_t a4)
{
  v18[1] = *MEMORY[0x1895F89C0];
  int v6 = (uint64_t *)ccec_cp_for_oid(a2);
  if (!v6) {
    return 655366LL;
  }
  uint64_t v7 = *v6;
  if ((unint64_t)*v6 >> 61 || !is_mul_ok(8 * v7, 3uLL)) {
LABEL_22:
  }
    __break(0x550Cu);
  uint64_t v8 = 24 * v7;
  BOOL v9 = __CFADD__(v8, 16LL);
  unint64_t v10 = v8 + 16;
  if (v9 || v10 >= 0xFFFFFFFFFFFFFFF0LL)
  {
LABEL_21:
    __break(0x5500u);
    goto LABEL_22;
  }

  unint64_t result = MEMORY[0x1895F8858](v6);
  uint64_t v14 = (void *)((char *)v18 - v12);
  unint64_t v15 = 0LL;
  do
  {
    unint64_t v16 = &v14[v15 / 8];
    *unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = 0xAAAAAAAAAAAAAAAALL;
    v15 += 16LL;
  }

  while (v12 != v15);
  if (v13 < 0x10) {
    goto LABEL_24;
  }
  unint64_t *v14 = result;
  if (v12 >= 1)
  {
    uint64_t v17 = ccec_compressed_x962_import_pub();
    if (!(_DWORD)v17)
    {
      unint64_t result = cczp_bitlen();
      if (result < 0xFFFFFFFFFFFFFFF9LL)
      {
        if (!a3 || a4)
        {
          if ((((result + 7) >> 2) | 1) == a4) {
            uint64_t v17 = 0LL;
          }
          else {
            uint64_t v17 = 393220LL;
          }
          ccec_export_pub();
          return v17;
        }

        goto LABEL_23;
      }

      goto LABEL_21;
    }

    return v17;
  }

uint64_t CMSParseContentInfoSignedDataWithOptions(char *a1, uint64_t a2, unint64_t *a3, char a4)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  unint64_t v28 = (char *)0xAAAAAAAAAAAAAAAALL;
  __int128 v29 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2)) {
    goto LABEL_114;
  }
  if (&a1[a2] < a1) {
    goto LABEL_112;
  }
  int v4 = 65537;
  unint64_t v28 = a1;
  __int128 v29 = &a1[a2];
  __int16 v27 = 0;
  size_t v26 = 0xAAAAAAAAAAAAAAAALL;
  int v7 = ccder_blob_decode_ber_tl((uint64_t)&v28, 0x2000000000000010LL, (_BYTE *)&v27 + 1, &v26);
  uint64_t result = 65537LL;
  if (v7)
  {
    char v24 = (char *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v25 = (char *)0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v28, v26)) {
      goto LABEL_114;
    }
    if (v28 > &v28[v26] || &v28[v26] > v29) {
      goto LABEL_112;
    }
    char v24 = v28;
    unint64_t v25 = &v28[v26];
    if (ccder_blob_decode_tl())
    {
      if (v25 < v24 || v26 > v25 - v24) {
        goto LABEL_112;
      }
      if (__CFADD__(v24, v26)) {
        goto LABEL_114;
      }
      if (v24 > &v24[v26] || &v24[v26] > v25) {
        goto LABEL_112;
      }
      v24 += v26;
      unint64_t v22 = (char *)0xAAAAAAAAAAAAAAAALL;
      char v23 = (char *)0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v24, v26)) {
        goto LABEL_114;
      }
      if (v24 > &v24[v26] || &v24[v26] > v25) {
        goto LABEL_112;
      }
      unint64_t v22 = v24;
      char v23 = &v24[v26];
      __int16 v31 = 0;
      memset(v30, 170, sizeof(v30));
      if (__CFADD__(v22, v30[0])) {
        goto LABEL_114;
      }
      uint64_t v9 = 131080LL;
      if (&v22[v30[0]] != v23) {
        return 131082LL;
      }
      unint64_t v10 = a3 + 11;
      uint64_t result = 131092LL;
      if (*v10 <= 4uLL && ((1LL << *v10) & 0x1A) != 0)
      {
        unsigned __int8 v35 = 0;
        size_t v34 = 0LL;
        __int128 v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
        if (__CFADD__(v22, v34)) {
          goto LABEL_114;
        }
        if (v22 > &v22[v34] || &v22[v34] > v23) {
          goto LABEL_112;
        }
        __int128 v32 = v22;
        unint64_t v33 = (unint64_t)&v22[v34];
        if (__CFADD__(v32, v34)) {
          goto LABEL_114;
        }
        BOOL v11 = &v32[v34];
        v32 += v34;
        int v12 = v35;
        if (v11 != (char *)v33 || v35)
        {
          unsigned __int8 v40 = 0;
          char v38 = (char *)v33;
          unint64_t v39 = 0LL;
          __int128 v37 = v11;
          if (ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000LL, &v40, &v39))
          {
            if (!v12)
            {
              if (__CFADD__(v37, v39)) {
                goto LABEL_114;
              }
            }

            if (v37 > v38) {
              goto LABEL_112;
            }
            __int128 v32 = v37;
            unint64_t v33 = (unint64_t)v38;
            unsigned __int8 v36 = 0;
            int v16 = v40;
            unint64_t v41 = 0LL;
            uint64_t v17 = v32;
            unint64_t v18 = v33;
            unint64_t v19 = v41;
            a3[9] = (unint64_t)v32;
            a3[10] = v19;
            if (__CFADD__(v17, v19))
            {
LABEL_114:
              __break(0x5513u);
              return 0LL;
            }

            uint64_t v20 = &v17[v19];
            __int128 v32 = v20;
          }

          else
          {
            if (!v12) {
              return v9;
            }
            int v16 = v40;
          }

          BOOL v11 = v32;
        }

        if (v11 > v23 || v22 > v11) {
          goto LABEL_112;
        }
        unint64_t v22 = v11;
        __int128 v37 = (char *)0xAAAAAAAAAAAAAAAALL;
        char v38 = (char *)0xAAAAAAAAAAAAAAAALL;
        if (v22 > v23) {
          goto LABEL_112;
        }
        __int128 v37 = v22;
        char v38 = v23;
        if ((ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000LL, &v31, v30) & 1) == 0)
        {
          unint64_t v13 = v22;
          unint64_t v15 = v23;
          goto LABEL_86;
        }

        __int128 v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
        if (!__CFADD__(v37, v30[0]))
        {
          if (v37 > &v37[v30[0]] || &v37[v30[0]] > v38) {
            goto LABEL_112;
          }
          __int128 v32 = v37;
          unint64_t v33 = (unint64_t)&v37[v30[0]];
          unint64_t v13 = v32;
          if (v32 - v37 >= 0 ? v32 >= v37 : v32 < v37)
          {
            if (v37 > v32) {
              goto LABEL_112;
            }
            unint64_t v15 = v38;
            if (v32 > v38) {
              goto LABEL_112;
            }
            unint64_t v22 = v32;
            char v23 = v38;
LABEL_86:
            if (v13 <= v15)
            {
              __int128 v37 = v13;
              char v38 = v15;
              if (ccder_blob_eat_ber_inner((unint64_t *)&v37, 0xA000000000000001LL, 0LL, 125))
              {
                if (v37 > v38) {
                  goto LABEL_112;
                }
                unint64_t v22 = v37;
                char v23 = v38;
              }

              if (v30[2] >= v30[1])
              {
                unint64_t v21 = &v22[-v30[1]];
                if ((unint64_t)&v22[-v30[1]] <= v30[2] - v30[1])
                {
                  a3[5] = v30[1];
                  a3[6] = (unint64_t)v21;
                  if (v22 <= v25 && v24 <= v22)
                  {
                    char v24 = v22;
                    if (ccder_blob_decode_eoc((unint64_t *)&v24, HIBYTE(v27)))
                    {
                      if ((a4 & 1) == 0 && v24 != v29) {
                        return 65543LL;
                      }
                      return 0LL;
                    }

                    return (v4 + 5);
                  }
                }
              }
            }

LABEL_112:
            __break(0x5519u);
            return (v4 + 5);
          }
        }

        goto LABEL_114;
      }
    }

    else
    {
      return 65538LL;
    }
  }

  return result;
}

  if (v19)
  {
    int v66 = *((_DWORD *)v19 + 8);
    unint64_t v67 = bswap32(v66);
    if (v7) {
      int v66 = v67;
    }
    unint64_t v68 = v63 - v66;
    double v69 = (v68 + 0x3FFF) & 0xFFFFC000;
    unint64_t v70 = bswap32(v68);
    if (v7) {
      unint64_t v68 = v70;
    }
    *((_DWORD *)v19 + 9) = v68;
    unint64_t v71 = bswap32(v69);
    if (!v7) {
      unint64_t v71 = v69;
    }
    *((_DWORD *)v19 + 7) = v71;
  }

  else
  {
    unint64_t v72 = *((void *)v18 + 5);
    unint64_t v73 = bswap64(v72);
    if (v7) {
      unint64_t v72 = v73;
    }
    unint64_t v74 = v63 - v72;
    uint64_t v75 = (v74 + 0x3FFF) & 0xFFFFFFFFFFFFC000LL;
    uint64_t v76 = bswap64(v74);
    if (v7) {
      unint64_t v74 = v76;
    }
    *((void *)v18 + 6) = v74;
    unint64_t v77 = bswap64(v75);
    if (!v7) {
      unint64_t v77 = v75;
    }
    *((void *)v18 + 4) = v77;
  }

  return 1LL;
}

uint64_t ccder_blob_decode_ber_tl(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t *a4)
{
  int v8 = ccder_blob_decode_tag();
  uint64_t result = 0LL;
  if (v8)
  {
    if (a2 == 0xAAAAAAAAAAAAAAAALL) {
      return ccder_blob_decode_ber_len(a1, a3, a4);
    }
  }

  return result;
}

uint64_t ccder_blob_decode_eoc(unint64_t *a1, int a2)
{
  if (!a2) {
    return 1LL;
  }
  uint64_t result = ccder_blob_decode_tl();
  if (!(_DWORD)result) {
    return result;
  }
  unint64_t v4 = *a1;
  if (*a1 >= 0x5555555555555556LL)
  {
    __break(0x5513u);
LABEL_12:
    __break(0x5519u);
    return result;
  }

  unint64_t v5 = v4 - 0x5555555555555556LL;
  if (v4 > v4 - 0x5555555555555556LL || v5 > a1[1]) {
    goto LABEL_12;
  }
  *a1 = v5;
  return 1LL;
}

uint64_t CMSParseContentInfoSignedData(char *a1, uint64_t a2, unint64_t *a3)
{
  return CMSParseContentInfoSignedDataWithOptions(a1, a2, a3, 0);
}

uint64_t CMSParseSignerInfos(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, __int128 *))
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v85 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  if (__CFADD__(v4, v3)) {
    goto LABEL_93;
  }
  if (v4 > v4 + v3) {
    goto LABEL_92;
  }
  unint64_t v84 = *(void *)(a1 + 40);
  unint64_t v85 = v4 + v3;
  unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
  if (v4 >= v4 + v3)
  {
    unsigned int v48 = 0;
    uint64_t result = 0LL;
    if (v3) {
      return (v48 << 8) | 0x30008;
    }
    return result;
  }

  unsigned int v6 = 0;
  unsigned __int8 v60 = 0;
  int v7 = 256;
  while (1)
  {
    unsigned __int8 v71 = 0;
    __int128 v82 = 0u;
    __int128 v83 = 0u;
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    __int128 v81 = 0u;
    DWORD2(v83) = 327681;
    LOBYTE(v82) = v6 + 1;
    if ((ccder_blob_decode_ber_tl((uint64_t)&v84, 0x2000000000000010LL, &v71, &v72) & 1) == 0)
    {
      int v49 = 196609;
      return v7 | v49;
    }

    unint64_t v69 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v70 = 0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v84, v72)) {
      goto LABEL_93;
    }
    if (v84 > v84 + v72 || v84 + v72 > v85) {
      goto LABEL_92;
    }
    unint64_t v69 = v84;
    unint64_t v70 = v84 + v72;
    if ((ccder_blob_decode_uint64() & 1) == 0)
    {
      int v49 = 196610;
      return v7 | v49;
    }

    unint64_t v9 = v69;
    unint64_t v8 = v70;
    unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v68 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70) {
      goto LABEL_92;
    }
    unint64_t v67 = v69;
    unint64_t v68 = v70;
    unint64_t v65 = v69;
    unint64_t v66 = v70;
    unint64_t v10 = v69;
LABEL_19:
    if (__CFADD__(v72, v10 - v9)) {
      goto LABEL_94;
    }
    if (v72 + v10 - v9 > v8 - v9) {
      goto LABEL_92;
    }
    *((void *)&v73 + 1) = v9;
    *(void *)&__int128 v74 = v72 + v10 - v9;
    if (__CFADD__(v10, v72)) {
      goto LABEL_93;
    }
    if (v10 > v10 + v72 || v10 + v72 > v70) {
      goto LABEL_92;
    }
    unint64_t v69 = v10 + v72;
    if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v74 + 1))
    {
      int v49 = 196612;
      return v7 | v49;
    }

    unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v64 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70) {
      goto LABEL_92;
    }
    unint64_t v63 = v69;
    unint64_t v64 = v70;
    if (ccder_blob_decode_tl())
    {
      if (v64 < v63 || v72 > v64 - v63) {
        goto LABEL_92;
      }
      *((void *)&v75 + 1) = v63;
      *(void *)&__int128 v76 = v72;
      if (__CFADD__(v63, v72)) {
        goto LABEL_93;
      }
      if (v63 > v63 + v72 || v63 + v72 > v64) {
        goto LABEL_92;
      }
      unint64_t v69 = v63 + v72;
      unint64_t v70 = v64;
    }

    else
    {
      *((void *)&v75 + 1) = 0LL;
      *(void *)&__int128 v76 = 0LL;
    }

    if ((ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v76 + 1) & 1) == 0)
    {
      int v49 = 196613;
      return v7 | v49;
    }

    if ((ccder_blob_decode_tl() & 1) == 0)
    {
      int v49 = 196614;
      return v7 | v49;
    }

    if (v70 < v69 || v72 > v70 - v69) {
      goto LABEL_92;
    }
    *((void *)&v78 + 1) = v69;
    *(void *)&__int128 v79 = v72;
    if (__CFADD__(v69, v72)) {
      goto LABEL_93;
    }
    unint64_t v12 = v69 + v72;
    if (v69 > v69 + v72 || v12 > v70) {
      goto LABEL_92;
    }
    v69 += v72;
    unint64_t v63 = v12;
    unint64_t v64 = v70;
    if (ccder_blob_eat_ber_inner(&v63, 0xA000000000000001LL, 0LL, 125))
    {
      if (v63 > v64) {
        goto LABEL_92;
      }
      unint64_t v69 = v63;
      unint64_t v70 = v64;
    }

    if ((ccder_blob_decode_eoc(&v69, v71) & 1) == 0)
    {
      int v49 = 196615;
      return v7 | v49;
    }

    digest = find_digest((uint64_t)&v74 + 8);
    if (digest)
    {
      uint64_t v14 = digest;
      unsigned int v15 = *(_DWORD *)(a1 + 96);
      if (!v15 || *(_DWORD *)digest <= v15)
      {
        uint64_t result = a3(a2, a1, &v73);
        if ((_DWORD)result != 327710)
        {
          if ((_DWORD)result) {
            return result;
          }
          unint64_t v17 = *(void *)(a1 + 64);
          if (v17 <= v60)
          {
            if (v17)
            {
              int v29 = v60 - 1;
              unint64_t v30 = *(void *)(a1 + 56);
              uint64_t v31 = 176LL * v29;
              if (__CFADD__(v30, v31)) {
                goto LABEL_93;
              }
              unint64_t v32 = v30 + 176LL * v29;
              if (v32 >= v30 + 176 * v17 || v32 < v30) {
                goto LABEL_92;
              }
              unint64_t v33 = find_digest(v30 + 176LL * v29 + 24);
              if (v33)
              {
                if (*(_DWORD *)v14 > *(_DWORD *)v33)
                {
                  unsigned int v34 = *(_DWORD *)(a1 + 96);
                  if (!v34 || *(_DWORD *)v14 <= v34)
                  {
                    unint64_t v35 = *(void *)(a1 + 56);
                    if (__CFADD__(v35, v31)) {
                      goto LABEL_93;
                    }
                    unsigned __int8 v36 = (_OWORD *)(v35 + 176LL * v29);
                    unint64_t v37 = v35 + 176LL * *(void *)(a1 + 64);
                    BOOL v38 = v37 >= (unint64_t)v36;
                    unint64_t v39 = v37 - (void)v36;
                    __int128 v40 = v73;
                    __int128 v41 = v75;
                    v36[1] = v74;
                    v36[2] = v41;
                    *unsigned __int8 v36 = v40;
                    __int128 v42 = v76;
                    __int128 v43 = v77;
                    __int128 v44 = v79;
                    v36[5] = v78;
                    v36[6] = v44;
                    v36[3] = v42;
                    v36[4] = v43;
                    __int128 v45 = v80;
                    __int128 v46 = v81;
                    __int128 v47 = v83;
                    v36[9] = v82;
                    v36[10] = v47;
                    v36[7] = v45;
                    v36[8] = v46;
                  }
                }
              }
            }
          }

          else
          {
            unsigned int v18 = *(_DWORD *)(a1 + 96);
            if (!v18 || *(_DWORD *)v14 <= v18)
            {
              uint64_t v19 = *(void *)(a1 + 56);
              uint64_t v20 = (_OWORD *)(v19 + 176LL * v60);
              if (176 * v17 - 176LL * v60 < 0xB0) {
                goto LABEL_92;
              }
              __int128 v21 = v73;
              __int128 v22 = v75;
              v20[1] = v74;
              v20[2] = v22;
              *uint64_t v20 = v21;
              __int128 v23 = v76;
              __int128 v24 = v77;
              __int128 v25 = v79;
              v20[5] = v78;
              v20[6] = v25;
              unint64_t v20[3] = v23;
              uint8_t v20[4] = v24;
              __int128 v26 = v80;
              __int128 v27 = v81;
              __int128 v28 = v83;
              v20[9] = v82;
              v20[10] = v28;
              v20[7] = v26;
              v20[8] = v27;
              if (v60 == 0xFF)
              {
                __break(0x5507u);
                return result;
              }

              ++v60;
            }
          }
        }
      }
    }

    if (v69 > v85 || v84 > v69) {
      goto LABEL_92;
    }
    unint64_t v84 = v69;
    unsigned int v48 = v6 + 1;
    if (v6 <= 6)
    {
      v7 += 256;
      ++v6;
      if (v69 < v85) {
        continue;
      }
    }

    if (v69 == v85)
    {
      if (v60) {
        return 0LL;
      }
      uint64_t v50 = *(void *)(a1 + 64);
      if (!v50) {
        return 0LL;
      }
      if ((unint64_t)(176 * v50) >= 0xB0)
      {
        uint64_t result = 0LL;
        unsigned int v51 = *(_OWORD **)(a1 + 56);
        __int128 v52 = v73;
        __int128 v53 = v75;
        v51[1] = v74;
        v51[2] = v53;
        _OWORD *v51 = v52;
        __int128 v54 = v76;
        __int128 v55 = v77;
        __int128 v56 = v79;
        v51[5] = v78;
        v51[6] = v56;
        v51[3] = v54;
        v51[4] = v55;
        __int128 v57 = v80;
        __int128 v58 = v81;
        __int128 v59 = v83;
        v51[9] = v82;
        v51[10] = v59;
        v51[7] = v57;
        v51[8] = v58;
        return result;
      }

LABEL_92:
      __break(0x5519u);
LABEL_93:
      __break(0x5513u);
LABEL_94:
      __break(0x5500u);
    }

    return (v48 << 8) | 0x30008;
  }

  if ((ccder_blob_decode_tl() & 1) != 0)
  {
    unint64_t v10 = v67;
    unint64_t v11 = v68;
LABEL_17:
    if (v10 > v11) {
      goto LABEL_92;
    }
    unint64_t v69 = v10;
    unint64_t v70 = v11;
    goto LABEL_19;
  }

  if (ccder_blob_decode_tl())
  {
    unint64_t v10 = v65;
    unint64_t v11 = v66;
    goto LABEL_17;
  }

  int v49 = 196611;
  return v7 | v49;
}

uint64_t CMSBuildPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v3 = *(void *)(a3 + 8);
  uint64_t v4 = *(void *)(a3 + 16);
  if (__CFADD__(v3, v4)) {
LABEL_49:
  }
    __break(0x5513u);
  unint64_t v5 = v3 + v4;
  if (v3 > v5) {
    goto LABEL_48;
  }
  unint64_t v20 = *(void *)(a3 + 8);
  unint64_t v21 = v5;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  if (*(void *)a3 != 3LL)
  {
    if (*(void *)a3 != 1LL) {
      return 524289LL;
    }
    uint64_t v8 = 524293LL;
    if (v21 >= v20 && v19 <= v21 - v20)
    {
      unint64_t v15 = v20;
      unint64_t v16 = v19;
      if (__CFADD__(v20, v19)) {
        goto LABEL_49;
      }
      if (v20 <= v20 + v19 && v20 + v19 <= v21)
      {
        v20 += v19;
        if (v21 >= v20 && v19 <= v21 - v20)
        {
          unint64_t v17 = v20;
          unint64_t v18 = v19;
          if (__CFADD__(v20, v19)) {
            goto LABEL_49;
          }
          if (v20 <= v20 + v19 && v20 + v19 <= v21)
          {
            v20 += v19;
            unint64_t v9 = *(void **)(a2 + 24);
            if (!v9) {
              return v8;
            }
            while (compare_octet_string((uint64_t)&v15, (uint64_t)(v9 + 15))
                 || compare_octet_string((uint64_t)&v17, (uint64_t)(v9 + 17)))
            {
              unint64_t v9 = (void *)v9[34];
              if (!v9) {
                return v8;
              }
            }

            goto LABEL_36;
          }
        }
      }
    }

    goto LABEL_48;
  }

  if (*(void *)(a2 + 88) == 1LL) {
    return 524298LL;
  }
  unint64_t v15 = v3;
  unint64_t v16 = v5;
  if (ccder_blob_decode_tl())
  {
    unint64_t v11 = v20;
    unint64_t v10 = v21;
    goto LABEL_29;
  }

  uint64_t v8 = 524294LL;
  unint64_t v11 = v15;
  unint64_t v10 = v16;
  if (v15 > v16)
  {
LABEL_48:
    __break(0x5519u);
    goto LABEL_49;
  }

  unint64_t v20 = v15;
  unint64_t v21 = v16;
LABEL_29:
  if (v10 < v11 || v19 > v10 - v11) {
    goto LABEL_48;
  }
  unint64_t v17 = v11;
  unint64_t v18 = v19;
  if (__CFADD__(v11, v19)) {
    goto LABEL_49;
  }
  if (v11 > v11 + v19 || v11 + v19 > v10) {
    goto LABEL_48;
  }
  unint64_t v20 = v11 + v19;
  uint64_t CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier((uint64_t *)(a2 + 24), (uint64_t)&v17);
  if (!CertificateUsingKeyIdentifier) {
    return 524295LL;
  }
  unint64_t v9 = (void *)CertificateUsingKeyIdentifier;
LABEL_36:
  if (v20 != v21) {
    return 524543LL;
  }
  uint64_t v13 = X509ChainBuildPath(v9, (uint64_t *)(a2 + 24), (void *)(a3 + 152));
  uint64_t v8 = v13;
  if (*(_DWORD *)(a3 + 168) == 327681) {
    *(_DWORD *)(a3 + 168) = v13;
  }
  return v8;
}

uint64_t ccder_blob_decode_ber_len(uint64_t result, _BYTE *a2, unint64_t *a3)
{
  *a2 = 0;
  unint64_t v3 = *(unsigned __int8 **)result;
  if (!*(void *)result) {
    return 0LL;
  }
  unint64_t v4 = *(void *)(result + 8);
  unint64_t v5 = v3 + 1;
  if (v3 >= v3 + 1 || (unint64_t)v5 > v4)
  {
LABEL_41:
    __break(0x5519u);
LABEL_42:
    __break(0x5513u);
    return result;
  }

  *(void *)uint64_t result = v5;
  unint64_t v7 = *v3;
  if ((char)*v3 < 0)
  {
    switch(*v3)
    {
      case 0x80u:
        unint64_t v7 = v4 - (void)v5;
        *a2 = 1;
        break;
      case 0x81u:
        uint64_t v8 = v3 + 2;
        *(void *)uint64_t result = v8;
        unint64_t v7 = *v5;
        unint64_t v5 = v8;
        break;
      case 0x82u:
        unint64_t v9 = v3 + 3;
        unint64_t v10 = (unint64_t)v3[1] << 8;
        uint64_t v11 = v3[2];
        goto LABEL_40;
      case 0x83u:
        unint64_t v9 = v3 + 4;
        unint64_t v10 = ((unint64_t)v3[1] << 16) | ((unint64_t)v3[2] << 8);
        uint64_t v11 = v3[3];
LABEL_40:
        unint64_t v7 = v10 | v11;
        *(void *)uint64_t result = v9;
        unint64_t v5 = v9;
        break;
      default:
        return 0LL;
    }
  }

  *a3 = v7;
  return 1LL;
}

uint64_t CMSParseImplicitCertificateSet( unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  *a4 = 0LL;
  a4[1] = 0LL;
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  if (*a1 > v6)
  {
LABEL_43:
    __break(0x5519u);
LABEL_44:
    __break(0x5513u);
  }

  unint64_t v30 = *a1;
  unint64_t v31 = v6;
  BOOL v7 = v5 >= v6 || a3 == 0;
  if (v7)
  {
    unint64_t v12 = 0LL;
LABEL_8:
    if (a5) {
      *a5 = v12;
    }
    return 1LL;
  }

  else
  {
    unint64_t v12 = 0LL;
    unint64_t v13 = 304 * a3;
    unint64_t v14 = a2 + 304 * a3;
    unint64_t v25 = ~a2;
    __int128 v27 = (unint64_t **)(a4 + 1);
    __int128 v23 = (unint64_t *)(a2 + 272);
    unint64_t v15 = a2;
    while (1)
    {
      char v29 = 0;
      if (!v32) {
        goto LABEL_8;
      }
      if (v15 > v14) {
        goto LABEL_43;
      }
      if (v15 < a2) {
        goto LABEL_43;
      }
      BOOL v16 = v13 >= 0x130;
      v13 -= 304LL;
      if (!v16) {
        goto LABEL_43;
      }
      *(_OWORD *)(v15 + 272) = 0u;
      *(_OWORD *)(v15 + 288) = 0u;
      *(_OWORD *)(v15 + 240) = 0u;
      *(_OWORD *)(v15 + 256) = 0u;
      *(_OWORD *)(v15 + 208) = 0u;
      *(_OWORD *)(v15 + 224) = 0u;
      *(_OWORD *)(v15 + 176) = 0u;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_OWORD *)(v15 + 128) = 0u;
      *(_OWORD *)(v15 + 80) = 0u;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)unint64_t v15 = 0u;
      if (v12)
      {
        if (v15 + 304 > v14) {
          goto LABEL_43;
        }
        *(void *)(v15 + 272) = 0LL;
        unint64_t v17 = *v27;
        *(void *)(v15 + 280) = *v27;
        if (v15)
        {
          if (v15 >= v14) {
            goto LABEL_43;
          }
        }

        *unint64_t v17 = v15;
        _BYTE *v27 = (unint64_t *)(v15 + 272);
      }

      else
      {
        if (v15 + 304 > v14) {
          goto LABEL_43;
        }
        unint64_t v18 = *a4;
        unint64_t *v23 = *a4;
        unint64_t v19 = (unint64_t **)(v18 + 280);
        BOOL v7 = v18 == 0;
        unint64_t v20 = v27;
        if (!v7) {
          unint64_t v20 = v19;
        }
        *unint64_t v20 = v23;
        if (v15)
        {
          if (v15 >= v14) {
            goto LABEL_43;
          }
        }

        *a4 = v15;
        *(void *)(a2 + 280) = a4;
      }

      if (v6 < v5) {
        goto LABEL_43;
      }
      unint64_t v21 = v30;
      uint64_t v22 = v30 - v5;
      if (v30 - v5 > v6 - v5) {
        goto LABEL_43;
      }
      if (v15 + 304 > v14) {
        goto LABEL_43;
      }
      *(void *)unint64_t v15 = v5;
      *(void *)(v15 + 8) = v22;
      unint64_t v6 = v31;
      if (v21 > v31) {
        goto LABEL_43;
      }
      *a1 = v21;
      a1[1] = v6;
      ++v12;
      if (v21 < v6)
      {
        v15 += 304LL;
        unint64_t v5 = v21;
        if (v12 < a3) {
          continue;
        }
      }

      goto LABEL_8;
    }
  }

uint64_t ccder_blob_eat_ber_inner(unint64_t *a1, uint64_t a2, unint64_t *a3, int a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  char v15 = 0;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  int v8 = ccder_blob_decode_tag();
  uint64_t result = 0LL;
  if (v8 && v14 == a2)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = ccder_blob_decode_ber_len((uint64_t)a1, &v15, &v13);
    if ((result & 1) == 0) {
      return 0LL;
    }
    if (a3)
    {
      unint64_t v10 = a1[1];
      if (*a1 > v10) {
        goto LABEL_18;
      }
      *a3 = *a1;
      a3[1] = v10;
    }

    if (v15)
    {
      if (a4 >= 1)
      {
        uint64_t result = ccder_blob_eat_ber_inner(a1, 0LL, 0LL, (char)(a4 - 1));
        if (!(_DWORD)result) {
          return result;
        }
        return (ccder_blob_decode_eoc(a1, 1) & 1) != 0;
      }

      return 0LL;
    }

    unint64_t v11 = *a1;
    if (__CFADD__(*a1, v13))
    {
LABEL_19:
      __break(0x5513u);
      return result;
    }

    unint64_t v12 = v11 + v13;
    if (v11 <= v11 + v13 && v12 <= a1[1])
    {
      *a1 = v12;
      return 1LL;
    }

uint64_t compare_octet_string(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a1 + 8);
  size_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return memcmp(*(const void **)a1, *(const void **)a2, v2);
  }
  if (v2 > v3) {
    return 0xFFFFFFFFLL;
  }
  return 1LL;
}

uint64_t compare_octet_string_raw(uint64_t a1, const void *a2, size_t a3)
{
  size_t v3 = *(void *)(a1 + 8);
  if (v3 == a3) {
    return memcmp(*(const void **)a1, a2, a3);
  }
  if (v3 > a3) {
    return 0xFFFFFFFFLL;
  }
  return 1LL;
}

uint64_t compare_octet_string_partial(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a1 + 8);
  if (v2 <= *(void *)(a2 + 8)) {
    return memcmp(*(const void **)a2, *(const void **)a1, v2);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ccder_blob_decode_AlgorithmIdentifierNULL(unint64_t *a1, unint64_t *a2)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    if (*a1 > a1[1]) {
      goto LABEL_20;
    }
    unint64_t v5 = *a1;
    unint64_t v6 = *a1;
    uint64_t result = ccder_blob_decode_tl();
    if (!(_DWORD)result) {
      return result;
    }
    if (a2)
    {
      if (v6 < v5) {
        goto LABEL_20;
      }
      *a2 = v5;
      a2[1] = 0LL;
    }

    if (v5 == v6)
    {
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1LL;
      }
    }

    else if (v5 <= v6)
    {
      uint64_t result = ccder_blob_decode_tl();
      if (!(_DWORD)result) {
        return result;
      }
      if (v5 != v6) {
        return 0LL;
      }
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1LL;
      }
    }

uint64_t ccder_blob_decode_Time(void *a1)
{
  if (*a1 > a1[1]) {
    goto LABEL_6;
  }
  if ((ccder_blob_decode_tl() & 1) != 0) {
    return 0LL;
  }
  if (*a1 > a1[1]) {
LABEL_6:
  }
    __break(0x5519u);
  ccder_blob_decode_tl();
  return 0LL;
}

uint64_t ccder_blob_check_null()
{
  return ccder_blob_decode_tl();
}

uint64_t CTParseExtensionValue( unint64_t a1, uint64_t a2, const void *a3, size_t a4, void *a5, void *a6)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  memset(v11, 0, sizeof(v11));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5519u);
  }

  if (a1 + a2 < a1) {
    goto LABEL_11;
  }
  v10[0] = a1;
  v10[1] = a1 + a2;
  uint64_t result = X509CertificateParseWithExtension((unint64_t *)v11, v10, a3, a4);
  if (!(_DWORD)result)
  {
    uint64_t result = 720914LL;
    if (*((void *)&v12 + 1))
    {
      uint64_t v9 = v13;
      if ((void)v13)
      {
        uint64_t result = 0LL;
        if (a5)
        {
          if (a6)
          {
            uint64_t result = 0LL;
            *a5 = *((void *)&v12 + 1);
            *a6 = v9;
          }
        }
      }
    }
  }

  return result;
}

uint64_t X509CertificateParseImplicit(uint64_t a1, unint64_t *a2, const void *a3, size_t a4)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  unint64_t v68 = 0LL;
  uint64_t v69 = 0LL;
  unint64_t v66 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (*a2 > v5) {
    goto LABEL_186;
  }
  uint64_t v10 = 720915LL;
  unint64_t v66 = *a2;
  unint64_t v67 = v5;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  uint64_t result = ccder_blob_decode_tl();
  if (!(_DWORD)result) {
    return v10;
  }
  uint64_t v12 = v69;
  unint64_t v13 = v66;
  unint64_t v14 = v69 + v66 - v4;
  if (__CFADD__(v69, v66 - v4)) {
    goto LABEL_188;
  }
  if (v14 > v5 - v4) {
    goto LABEL_186;
  }
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v14;
  unint64_t v64 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(v13, v12)) {
    goto LABEL_187;
  }
  unint64_t v15 = v13 + v12;
  if (v13 > v15 || v15 > v67) {
    goto LABEL_186;
  }
  unint64_t v64 = v13;
  unint64_t v65 = v15;
  unint64_t v62 = v13;
  unint64_t v63 = v15;
  if (ccder_blob_decode_tl())
  {
    if (__CFADD__(v62, v68)) {
      goto LABEL_187;
    }
    uint64_t v16 = 720916LL;
    if (ccder_blob_decode_uint64() && v62 == v62 + v68)
    {
      if (v62 + v68 > v63) {
        goto LABEL_186;
      }
      unint64_t v64 = v62 + v68;
      unint64_t v65 = v63;
      goto LABEL_14;
    }

    return v16;
  }

LABEL_14:
  unint64_t v18 = v64;
  unint64_t v17 = v65;
  if (v65 < v64) {
    goto LABEL_186;
  }
  unint64_t v19 = v68;
  if (v68 > v65 - v64) {
    goto LABEL_186;
  }
  *(void *)(a1 + 136) = v64;
  *(void *)(a1 + 144) = v19;
  if (__CFADD__(v18, v19)) {
    goto LABEL_187;
  }
  unint64_t v20 = v18 + v19;
  if (v18 > v20 || v20 > v17) {
    goto LABEL_186;
  }
  unint64_t v64 = v20;
  unint64_t v22 = v64;
  unint64_t v21 = v65;
  if (v65 < v64) {
    goto LABEL_186;
  }
  unint64_t v23 = v68;
  if (v68 > v65 - v64) {
    goto LABEL_186;
  }
  *(void *)(a1 + 120) = v64;
  *(void *)(a1 + 128) = v23;
  if (__CFADD__(v22, v23)) {
    goto LABEL_187;
  }
  unint64_t v24 = v22 + v23;
  if (v22 > v24 || v24 > v21) {
    goto LABEL_186;
  }
  unint64_t v64 = v24;
  unint64_t v26 = v64;
  unint64_t v25 = v65;
  if (v65 < v64) {
    goto LABEL_186;
  }
  unint64_t v27 = v68;
  if (v68 > v65 - v64) {
    goto LABEL_186;
  }
  *(void *)(a1 + 72) = v64;
  *(void *)(a1 + 80) = v27;
  if (__CFADD__(v26, v27)) {
    goto LABEL_187;
  }
  unint64_t v28 = v26 + v27;
  if (v26 > v28 || v28 > v25) {
    goto LABEL_186;
  }
  unint64_t v64 = v28;
  unint64_t v29 = v64;
  unint64_t v30 = v65;
  if (v65 < v64) {
    goto LABEL_186;
  }
  unint64_t v31 = v68;
  if (v68 > v65 - v64) {
    goto LABEL_186;
  }
  *(void *)(a1 + 104) = v64;
  *(void *)(a1 + 112) = v31;
  if (__CFADD__(v29, v31)) {
    goto LABEL_187;
  }
  unint64_t v32 = v29 + v31;
  if (v29 > v29 + v31 || v32 > v30) {
    goto LABEL_186;
  }
  unint64_t v64 = v29 + v31;
  uint64_t result = ccder_blob_decode_tl();
  if (!(_DWORD)result) {
    return 720922LL;
  }
  unint64_t v33 = v64;
  unint64_t v34 = v68;
  unint64_t v35 = v64 - v32 + v68;
  if (!__CFADD__(v64 - v32, v68))
  {
    if (v35 > v30 - v32) {
      goto LABEL_186;
    }
    *(void *)(a1 + 88) = v32;
    *(void *)(a1 + 96) = v35;
    if (__CFADD__(v33, v34)) {
      goto LABEL_187;
    }
    unint64_t v36 = v33 + v34;
    if (v33 > v36 || v36 > v65) {
      goto LABEL_186;
    }
    unint64_t v63 = v65;
    unint64_t v64 = v36;
    unint64_t v62 = v36;
    if ((ccder_blob_decode_tl() & 1) != 0) {
      return 720923LL;
    }
    if (v64 > v65) {
      goto LABEL_186;
    }
    unint64_t v62 = v64;
    unint64_t v63 = v65;
    if ((ccder_blob_decode_tl() & 1) != 0) {
      return 720924LL;
    }
    if (v64 > v65) {
      goto LABEL_186;
    }
    unint64_t v62 = v64;
    unint64_t v63 = v65;
    if (ccder_blob_decode_tl())
    {
      unint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v62, v68)) {
        goto LABEL_187;
      }
      if (v62 > v62 + v68 || v62 + v68 > v63) {
        goto LABEL_186;
      }
      unint64_t v60 = v62;
      unint64_t v61 = v62 + v68;
      unint64_t v37 = v60;
      if (__CFADD__(v60, v68)) {
LABEL_187:
      }
        __break(0x5513u);
      unint64_t v38 = v60 + v68;
      if (v60 > v60 + v68 || v38 > v61) {
        goto LABEL_186;
      }
      unint64_t v61 = v60 + v68;
      *(_BYTE *)(a1 + 266) = 0;
      memset(&v70[2], 0, 128);
      if (a3) {
        BOOL v39 = a4 == 0;
      }
      else {
        BOOL v39 = 1;
      }
      int v40 = !v39;
      memset(v70, 0, 32);
      if (v37 < v38)
      {
        unsigned __int8 v53 = 0;
        int v41 = 0;
        do
        {
          unint64_t v58 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v59 = 0xAAAAAAAAAAAAAAAALL;
          char v57 = 0;
          uint64_t v56 = 0LL;
          if ((ccder_blob_decode_tl() & 1) == 0) {
            return 720926LL;
          }
          unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
          if (__CFADD__(v60, v56)) {
            goto LABEL_187;
          }
          if (v60 > v60 + v56 || v60 + v56 > v61) {
            goto LABEL_186;
          }
          unint64_t v54 = v60;
          unint64_t v55 = v60 + v56;
          if (v55 < v54 || v68 > v55 - v54) {
            goto LABEL_186;
          }
          unint64_t v58 = v54;
          unint64_t v59 = v68;
          if (__CFADD__(v54, v68)) {
            goto LABEL_187;
          }
          if (v54 > v54 + v68 || v54 + v68 > v55) {
            goto LABEL_186;
          }
          v54 += v68;
          if (__CFADD__(v54, v68)) {
            goto LABEL_187;
          }
          if (v55 != v54 + v68) {
            return 720929LL;
          }
          if (v40 && !compare_octet_string_raw((uint64_t)&v58, a3, a4))
          {
            if (v55 < v54) {
              goto LABEL_186;
            }
            unint64_t v43 = v68;
            if (v68 > v55 - v54) {
              goto LABEL_186;
            }
            *(void *)(a1 + 248) = v54;
            *(void *)(a1 + 256) = v43;
          }

          if (v59 == 3)
          {
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 15)
            {
              uint64_t v16 = 720930LL;
              if ((v41 & 1) != 0 || (X509ExtensionParseKeyUsage() & 1) == 0) {
                return v16;
              }
              v41 |= 1u;
              goto LABEL_155;
            }

            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 19)
            {
              uint64_t v16 = 720931LL;
              if ((v41 & 2) != 0
                || (X509ExtensionParseBasicConstraints(&v54, (void *)(a1 + 200), (_BYTE *)(a1 + 265)) & 1) == 0)
              {
                return v16;
              }

              v41 |= 2u;
              goto LABEL_155;
            }

            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 35)
            {
              uint64_t v16 = 720932LL;
              if ((v41 & 4) != 0
                || (X509ExtensionParseAuthorityKeyIdentifier(&v54, (unint64_t *)(a1 + 168), (void *)(a1 + 176)) & 1) == 0)
              {
                return v16;
              }

              v41 |= 4u;
              goto LABEL_155;
            }

            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 14)
            {
              uint64_t v16 = 720933LL;
              if ((v41 & 8) != 0
                || (X509ExtensionParseSubjectKeyIdentifier(&v54, (unint64_t *)(a1 + 184), (void *)(a1 + 192)) & 1) == 0)
              {
                return v16;
              }

              v41 |= 8u;
              goto LABEL_155;
            }

            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 37)
            {
              uint64_t v16 = 720934LL;
              if ((v41 & 0x10) != 0
                || (X509ExtensionParseExtendedKeyUsage(&v54, (unint64_t *)(a1 + 208), (void *)(a1 + 216)) & 1) == 0)
              {
                return v16;
              }

              v41 |= 0x10u;
              goto LABEL_155;
            }

            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 17)
            {
              uint64_t v16 = 720935LL;
              if ((v41 & 0x20) != 0
                || (X509ExtensionParseSubjectAltName(&v54, (unint64_t *)(a1 + 224), (void *)(a1 + 232)) & 1) == 0)
              {
                return v16;
              }

              v41 |= 0x20u;
              goto LABEL_155;
            }
          }

          else if (v59 >= 8 && *(_DWORD *)v58 == -2042067414 && *(_DWORD *)(v58 + 3) == 1684273030)
          {
            uint64_t v16 = 720936LL;
            uint64_t result = X509ExtensionParseAppleExtension( (uint64_t)&v54,  v58,  v59,  (uint64_t *)(a1 + 240),  (unint64_t *)(a1 + 248),  v40);
            if (!(_DWORD)result) {
              return v16;
            }
            if (v53 == 0xFF) {
              goto LABEL_189;
            }
            ++v53;
            goto LABEL_155;
          }

          if (__CFADD__(v54, v68)) {
            goto LABEL_187;
          }
          if (v54 > v54 + v68 || v54 + v68 > v55) {
            goto LABEL_186;
          }
          v54 += v68;
          if (v57) {
            *(_BYTE *)(a1 + 266) = 1;
          }
LABEL_155:
          if (v54 != v55) {
            return 720926LL;
          }
          if (__CFADD__(v60, v56)) {
            goto LABEL_187;
          }
          unint64_t v37 = v60 + v56;
          if (v60 > v60 + v56) {
            goto LABEL_186;
          }
          unint64_t v38 = v61;
          if (v37 > v61) {
            goto LABEL_186;
          }
          v60 += v56;
        }

        while (v37 < v61);
      }

      if (v37 != v38) {
        return 720925LL;
      }
      if (v37 > v65 || v64 > v37) {
        goto LABEL_186;
      }
      unint64_t v64 = v37;
    }

    if (*(void *)(a1 + 32) < 3uLL)
    {
      uint64_t v16 = 720915LL;
      if (v64 != v65) {
        return v16;
      }
LABEL_170:
      if (__CFADD__(v66, v69)) {
        goto LABEL_187;
      }
      if (v66 > v66 + v69 || v66 + v69 > v67) {
        goto LABEL_186;
      }
      v66 += v69;
      *(void *)&v70[0] = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v70[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v60 = 0LL;
      uint64_t result = ccder_blob_decode_bitstring();
      if (!(_DWORD)result) {
        return 720938LL;
      }
      if (v60 < 0xFFFFFFFFFFFFFFF9LL)
      {
        if (*((void *)&v70[0] + 1) >= *(void *)&v70[0])
        {
          unint64_t v51 = (v60 + 7) >> 3;
          if (v51 <= *((void *)&v70[0] + 1) - *(void *)&v70[0])
          {
            *(void *)(a1 + 56) = *(void *)&v70[0];
            *(void *)(a1 + 64) = v51;
            unint64_t v52 = v67;
            if (v66 <= v67)
            {
              uint64_t v16 = 0LL;
              *a2 = v66;
              a2[1] = v52;
              return v16;
            }
          }
        }

        goto LABEL_186;
      }

      goto LABEL_188;
    }

    if (v65 <= a2[1] && *a2 <= v65)
    {
      *a2 = v65;
      goto LABEL_170;
    }

    secLogObjForScope("SecWarning");
    uint64_t v9 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      unint64_t v13 = v6;
      _os_log_impl( &dword_1804F4000,  (os_log_t)v9,  OS_LOG_TYPE_DEFAULT,  "skipping signing time that failed to decode: %@",  buf,  0xCu);
    }

    BOOL v7 = 0LL;
    goto LABEL_17;
  }

  BOOL v7 = 0LL;
LABEL_19:

  return v7;
}

  -[SFAnalyticsMatchingRule rule](self, "rule");
  unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v30 = [v29 eventClass];

  unint64_t v31 = 0;
  switch(v30)
  {
    case 0:
      goto LABEL_29;
    case 1:
      goto LABEL_29;
    case 10:
      if (a4) {
        goto LABEL_18;
      }
      goto LABEL_29;
    case 11:
      if (a4 != 1) {
        goto LABEL_18;
      }
      goto LABEL_29;
    case 12:
      if (a4 != 2) {
        goto LABEL_18;
      }
      goto LABEL_29;
    case 13:
      if (a4 != 3) {
        goto LABEL_18;
      }
      goto LABEL_29;
    case 14:
      if (a4 != 4) {
        goto LABEL_18;
      }
LABEL_29:
      unint64_t v31 = 1;
      break;
    default:
      break;
  }

    if ((_DWORD)v53)
    {
      unint64_t v22 = 8LL * v53;
      unint64_t v23 = v16;
      do
      {
        unint64_t v24 = *v23;
        if (*v23)
        {
          unint64_t v25 = v24[1];
          if (v25 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          unint64_t v26 = v25 - 1;
          v24[1] = v26;
          if (!v26) {
            (*(void (**)(void *))(*v24 + 8LL))(v24);
          }
        }

        *v23++ = 0LL;
        v22 -= 8LL;
      }

      while (v22);
    }

    free(v16);
    goto LABEL_22;
  }

  unint64_t v18 = v53;
  if ((_DWORD)v53 == 1)
  {
    uint64_t v16 = (void **)*((void *)&v52 + 1);
    if (!*((void *)&v52 + 1)) {
      goto LABEL_36;
    }
    unint64_t v19 = 8LL * v53;
    if (*((void *)&v52 + 1) + v19 < *((void *)&v52 + 1) || HIDWORD(v19)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v15);
    }
    if ((v19 & 0xFFFFFFF8) == 0) {
LABEL_36:
    }
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v15);
    unint64_t v34 = 0uLL;
    unint64_t v20 = **((void **)&v52 + 1);
    *((void *)&v35 + 1) = v20;
    if (v20)
    {
      unint64_t v21 = *(void *)(v20 + 8);
      if (v21 < 1)
      {
        unint64_t v33 = __cxa_allocate_exception(8uLL);
        char *v33 = "Attempted resurection of an object";
        __cxa_throw(v33, MEMORY[0x1896146E0], 0LL);
      }

      *(void *)(v20 + 8) = v21 + 1;
    }

    goto LABEL_14;
  }

  unint64_t v27 = operator new(0x30uLL);
  v27[2] = 0LL;
  v27[3] = 0LL;
  unint64_t v28 = off_189668340;
  _BYTE *v27 = off_189668340;
  v27[1] = 1LL;
  v27[4] = *((void *)&v52 + 1);
  *((_DWORD *)v27 + 10) = v18;
  *((void *)&v35 + 1) = v27;
LABEL_26:
  *(void *)&unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v50.runtime = v29;
  *(_OWORD *)&v50.lookup.index_size_t count = v29;
  ((void (*)(der_vm_context *__return_ptr, void *, void (***)(TLE::CallbackEncyclopedia *__hidden)))v28[2])( &v50,  v27,  &v43);
  if (LODWORD(v50.runtime)) {
    unint64_t v30 = 1;
  }
  else {
    unint64_t v30 = LOBYTE(v50.dictionary_tag) == 0;
  }
  unint64_t v17 = !v30;
LABEL_32:
  libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::reset((void **)&v35 + 1);

  return v17;
}

        CFRelease(v11);
LABEL_15:
        unint64_t v18 = *v9++;
        int v8 = v18;
        if (!v18) {
          goto LABEL_16;
        }
      }

      SubjectKeyID = SecCertificateGetSubjectKeyID(v10);
      unint64_t v14 = *(size_t **)(a1 + 24);
      unint64_t v15 = *v14;
      if (v15 == CFDataGetLength(SubjectKeyID))
      {
        uint64_t v16 = (const void *)v14[1];
        BytePtr = CFDataGetBytePtr(SubjectKeyID);
        if (!memcmp(v16, BytePtr, *v14))
        {
LABEL_13:
          CFArrayInsertValueAtIndex(Mutable, 0LL, v11);
          goto LABEL_14;
        }
      }

      goto LABEL_12;
    }
  }

      *a2 = v3;
      break;
    case 0x302:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246LL;
      }
      uint64_t result = 0LL;
      size_t v3 = 7;
      goto LABEL_14;
    case 0x303:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246LL;
      }
      uint64_t result = 0LL;
      size_t v3 = 6;
      goto LABEL_14;
    default:
      return 4294967246LL;
  }

  return result;
}

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return Mutable;
}

  unint64_t v17 = Copy;
  unint64_t v18 = CFStringGetLength(Copy);
  MutableCopy = CFStringCreateMutableCopy(v14, v18, v17);
  if (v17) {
    CFRelease(v17);
  }
LABEL_16:
  CharacterAtIndex = CFStringGetCharacterAtIndex(a2, 0LL);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0LL, @"%c:%@ ", CharacterAtIndex, MutableCopy);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = @", ";
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)a1,  (uint64_t)v15,  v16,  v11);
        if (v10) {
          uint64_t v10 = std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v10);
        }
        else {
          uint64_t v10 = 0LL;
        }
        unint64_t v17 = (void *)v12[1];
        if (v17)
        {
          do
          {
            a2 = v17;
            unint64_t v17 = (void *)*v17;
          }

          while (v17);
        }

        else
        {
          do
          {
            a2 = (void *)v12[2];
            unint64_t v18 = *a2 == (void)v12;
            uint64_t v12 = a2;
          }

          while (!v18);
        }

        if (!v9) {
          break;
        }
        unint64_t v11 = v9;
        uint64_t v12 = a2;
      }

      while (a2 != a3);
    }

    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v9);
    if (v10)
    {
      unint64_t v20 = v10;
      goto LABEL_29;
    }
  }

LABEL_186:
    __break(0x5519u);
    goto LABEL_187;
  }

              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordDisallowedCharacters,  (const void **)&v173[2])) {
                v173[2] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordCantEndWithChars,  (const void **)&v173[1])) {
                v173[1] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordCantStartWithChars,  (const void **)v173)) {
                v173[0] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordNumberOfGroups,  (const void **)&v172[2])) {
                v172[2] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters,  (const void **)v172)) {
                v172[0] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsAtLeastNSpecificCharacters,  (const void **)&v171[3])) {
                v171[3] = 0LL;
              }
              if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters,  (const void **)&v171[2])) {
                v171[2] = 0LL;
              }
              uint64_t v56 = alloc;
              if (v74)
              {
                v176.size_t length = CFStringGetLength(v74);
                v176.location = 0LL;
                if (!CFStringFindWithOptions(v74, @"-", v176, 1uLL, 0LL))
                {
LABEL_209:
                  CFIndex Length = CFStringGetLength(v74);
                  MutableCopy = CFStringCreateMutableCopy(alloc, Length, v74);
                  v184.size_t length = CFStringGetLength(v74);
                  v184.location = 0LL;
                  CFStringFindAndReplace(MutableCopy, @"-", &stru_1896794C8, v184, 1uLL);
                  CFRelease(v74);
                  unint64_t v55 = @"false";
                  __int128 v74 = MutableCopy;
LABEL_210:
                  if (CFArrayGetCount(Mutable) > v53 && Mutable)
                  {
                    CFRelease(Mutable);
                    CFMutableArrayRef Mutable = 0LL;
                  }

                  value[0] = (void *)v53;
                  char v96 = CFNumberCreate(alloc, kCFNumberCFIndexType, value);
                  unint64_t v85 = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
                  CFDictionaryAddValue(v85, @"UseDefaultPasswordFormat", v55);
                  CFDictionarySetValue(v85, @"NumberOfRequiredRandomCharacters", v96);
                  CFDictionaryAddValue(v85, @"AllowedCharacters", v74);
                  if (Mutable) {
                    CFDictionaryAddValue(v85, @"RequiredCharacterSets", Mutable);
                  }
                  if (v173[2]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordDisallowedCharacters, v173[2]);
                  }
                  if (v173[1]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantEndWithChars, v173[1]);
                  }
                  if (v173[0]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantStartWithChars, v173[0]);
                  }
                  if (v172[3]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordGroupSize, v172[3]);
                  }
                  if (v172[2]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordNumberOfGroups, v172[2]);
                  }
                  if (v172[1]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordSeparator, v172[1]);
                  }
                  if (v172[0]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, v172[0]);
                  }
                  if (v171[3]) {
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, v171[3]);
                  }
                  if (v171[2]) {
                    CFDictionaryAddValue( v85,  (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters,  v171[2]);
                  }
                  CFRelease(v55);
                  if (v96) {
                    CFRelease(v96);
                  }
                  if (v74) {
                    CFRelease(v74);
                  }
                  if (Mutable) {
                    CFRelease(Mutable);
                  }
                  goto LABEL_239;
                }
              }

              else
              {
                __int128 v74 = @"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789";
                CFRetain(@"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789");
              }

              if (v55 != @"false") {
                goto LABEL_210;
              }
              goto LABEL_209;
            }

            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(Mutable, (const void *)uppercaseLetterCharacterSet);
            unint64_t v54 = a1;
            CFArrayAppendValue(Mutable, (const void *)lowercaseLetterCharacterSet);
LABEL_185:
            CFArrayAppendValue(Mutable, (const void *)decimalDigitCharacterSet);
            goto LABEL_186;
          }

          if (!v173[3] || !v52)
          {
            if (!v173[3] && v52)
            {
              unint64_t v55 = @"false";
              unsigned __int8 v53 = v52;
LABEL_184:
              __int128 v74 = @"0123456789";
              goto LABEL_185;
            }

            if (v173[3]) {
              char v93 = v52 == 0;
            }
            else {
              char v93 = 0;
            }
            if (!v93) {
              unsigned __int8 v53 = 4LL;
            }
          }

          unint64_t v55 = @"false";
          goto LABEL_184;
        }

LABEL_188:
  __break(0x5500u);
LABEL_189:
  __break(0x5507u);
  return result;
}

uint64_t der_get_BOOLean(void *a1, int a2, _BYTE *a3)
{
  if (*a1 > a1[1]) {
    __break(0x5519u);
  }
  if ((ccder_blob_decode_tl() & 1) != 0 || !a2) {
    return 0LL;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1LL;
}

uint64_t X509ExtensionParseKeyUsage()
{
  uint64_t result = ccder_blob_decode_bitstring();
  if ((_DWORD)result) {
    return 0LL;
  }
  return result;
}

uint64_t X509ExtensionParseBasicConstraints(void *a1, void *a2, _BYTE *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    uint64_t result = der_get_BOOLean(a1, 1, a3);
    if ((_DWORD)result)
    {
      if (ccder_blob_decode_uint64())
      {
        if (!*a3) {
          return 0LL;
        }
        *a2 = 0xAAAAAAAAAAAAAAAALL;
        *a2 = 0xAAAAAAAAAAAAAAABLL;
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t X509ExtensionParseAuthorityKeyIdentifier(unint64_t *a1, unint64_t *a2, void *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v7 = *a1;
    if (*a1 >= 0x5555555555555556LL) {
      goto LABEL_15;
    }
    if (v7 - 0x5555555555555556LL != a1[1]) {
      return 0LL;
    }
    if (v7 > v7 - 0x5555555555555556LL) {
      goto LABEL_16;
    }
    unint64_t v10 = *a1;
    unint64_t v11 = v7 - 0x5555555555555556LL;
    uint64_t result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL) {
        goto LABEL_16;
      }
      *a2 = v10;
      *a3 = 0xAAAAAAAAAAAAAAAALL;
    }

    unint64_t v8 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
LABEL_15:
      __break(0x5513u);
    }

    else
    {
      unint64_t v9 = v8 - 0x5555555555555556LL;
      if (v8 <= v8 - 0x5555555555555556LL && v9 <= a1[1])
      {
        *a1 = v9;
        return 1LL;
      }
    }

uint64_t X509ExtensionParseSubjectKeyIdentifier(unint64_t *a1, unint64_t *a2, void *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v7 = a1[1];
    BOOL v8 = v7 >= *a1;
    unint64_t v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL) {
      goto LABEL_13;
    }
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v11 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
      return result;
    }

    unint64_t v12 = v11 - 0x5555555555555556LL;
    if (v11 > v11 - 0x5555555555555556LL || v12 > a1[1]) {
LABEL_13:
    }
      __break(0x5519u);
    *a1 = v12;
  }

  return result;
}

uint64_t X509ExtensionParseExtendedKeyUsage(unint64_t *a1, unint64_t *a2, void *a3)
{
  int v6 = ccder_blob_decode_tl();
  uint64_t result = 0LL;
  if (v6)
  {
    if (*a1 > a1[1]) {
      goto LABEL_11;
    }
    unint64_t v10 = *a1;
    unint64_t v11 = a1[1];
    uint64_t result = ccder_blob_decode_tl();
    if (!(_DWORD)result) {
      return result;
    }
    if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL) {
      goto LABEL_11;
    }
    *a2 = v10;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v8 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
      return result;
    }

    unint64_t v9 = v8 - 0x5555555555555556LL;
    if (v8 > v8 - 0x5555555555555556LL || v9 > a1[1]) {
LABEL_11:
    }
      __break(0x5519u);
    *a1 = v9;
  }

  return result;
}

uint64_t X509ExtensionParseSubjectAltName(unint64_t *a1, unint64_t *a2, void *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result == 1)
  {
    unint64_t v7 = a1[1];
    BOOL v8 = v7 >= *a1;
    unint64_t v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL) {
      goto LABEL_13;
    }
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v11 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
      return result;
    }

    unint64_t v12 = v11 - 0x5555555555555556LL;
    if (v11 > v11 - 0x5555555555555556LL || v12 > a1[1]) {
LABEL_13:
    }
      __break(0x5519u);
    *a1 = v12;
  }

  return result;
}

uint64_t X509CertificateVerifyOnlyOneAppleExtension(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 > 9) {
    return 0LL;
  }
  unint64_t v5 = (void *)result;
  unsigned __int8 v6 = 0;
  unint64_t v7 = ~a2;
  while (v7 >= 16LL * (char)v6)
  {
    uint64_t result = compare_octet_string((uint64_t)v5, a2 + 16LL * v6);
    if (!(_DWORD)result) {
      return result;
    }
    if (a3 <= v6++)
    {
      uint64_t v9 = v5[1];
      unint64_t v10 = (void *)(a2 + 16LL * a3);
      void *v10 = *v5;
      v10[1] = v9;
      return 1LL;
    }
  }

  __break(0x5513u);
  return result;
}

uint64_t X509ExtensionParseAppleExtension( uint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t *a5, int a6)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (a6) {
    a5 = 0LL;
  }
  if (a3 == 11)
  {
    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x10901066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x400000000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x10301066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x200;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x10601066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x800;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x11801066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x2000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x12401066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x100000000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x11901066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x4000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(void *)(a2 + 3) == 0x21901066463F786LL)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x8000;
      goto LABEL_261;
    }

LABEL_157:
    int v44 = 0;
LABEL_158:
    if (*(void *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 27) {
      return X509ExtensionParseServerAuthMarker(result, a2, a3, a4, a5);
    }
    if (!v44) {
      goto LABEL_232;
    }
    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 832)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x400000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3586)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v54 = *a4;
      uint64_t v55 = 37748736LL;
    }

    else
    {
      if (*(void *)a2 != 0x66463F78648862ALL || *(_WORD *)(a2 + 8) != 4354)
      {
        if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 327) {
          return (uint64_t)X509ExtensionParseMFI4Properties((unint64_t *)result, a4, a5);
        }
        if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3841LL)
        {
          unint64_t v52 = *(void *)result;
          unint64_t v51 = *(void *)(result + 8);
          if (a5)
          {
            if (v52 > v51) {
              goto LABEL_265;
            }
            *a5 = v52;
            a5[1] = v51 - v52;
          }

          *a4 |= 0x80000000uLL;
LABEL_233:
          if (v52 <= v51)
          {
            *(void *)uint64_t result = v51;
            return 1LL;
          }

LABEL_265:
          __break(0x5519u);
          return result;
        }

        goto LABEL_232;
      }

      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v54 = *a4;
      uint64_t v55 = 0x8004000000LL;
    }

LABEL_201:
    uint64_t v24 = v54 | v55;
    goto LABEL_261;
  }

  if (a3 == 10)
  {
    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 5122)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x100000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 258)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v54 = *a4;
      uint64_t v55 = 0x58600003F0D0LL;
      goto LABEL_201;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1538) {
      goto LABEL_203;
    }
    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 4610)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0xF00;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3073)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x10;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1793)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x20000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3329)
    {
LABEL_203:
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x20;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 2305)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x40;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 513)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x80;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1025)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x10000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 769)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x100;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1537)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x400;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 6145)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x1000;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 9217)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x80000000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8193)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x2000000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8705)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x4000000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 315) {
      return X509ExtensionParseMFISWAuth((unint64_t *)result, a4, a5);
    }
    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3074)
    {
      uint64_t result = ccder_blob_check_null();
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v24 = *a4 | 0x300000000LL;
      goto LABEL_261;
    }

    if (*(void *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 304) {
      return X509ExtensionParseGenericSSLMarker();
    }
    int v44 = 1;
    goto LABEL_158;
  }

  if (a3 != 9)
  {
    if (a3 < 0xA) {
      goto LABEL_232;
    }
    goto LABEL_157;
  }

  if (*(void *)a2 == 0xB6463F78648862ALL && *(_BYTE *)(a2 + 8) == 1) {
    return X509ExtensionParseComponentAuth((unint64_t *)result, a4, a5);
  }
  if (*(void *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 49)
  {
    if (*(void *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 44) {
      return X509ExtensionParseCertifiedChipIntermediate((unint64_t *)result, a4, a5);
    }
    if (*(void *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 36) {
      return X509ExtensionParseMFIAuthv3Leaf((unint64_t *)result);
    }
    if (*(void *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 22)
    {
      if (*(void *)a2 == 0xC6463F78648862ALL && *(_BYTE *)(a2 + 8) == 19)
      {
        uint64_t result = ccder_blob_check_null();
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v24 = *a4 | 0x8000000000LL;
        goto LABEL_261;
      }

      if (*(void *)a2 != 0xA6463F78648862ALL || *(_BYTE *)(a2 + 8) != 1)
      {
        if (*(void *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 29)
        {
          uint64_t result = ccder_blob_check_null();
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v24 = *a4 | 0x2000000;
        }

        else
        {
          if (*(void *)a2 != 0xC6463F78648862ALL || *(_BYTE *)(a2 + 8) != 14)
          {
            if (*(void *)a2 == 0x86463F78648862ALL && *(_BYTE *)(a2 + 8) == 3) {
              return X509ExtensionParseDeviceAttestationIdentity((unint64_t *)result, a4, a5);
            }
            goto LABEL_232;
          }

          uint64_t result = ccder_blob_check_null();
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v24 = *a4 | 0x4000000;
        }

LABEL_261:
        *a4 = v24;
        return 1LL;
      }

      *a4 |= 0x1000000uLL;
LABEL_232:
      unint64_t v52 = *(void *)result;
      unint64_t v51 = *(void *)(result + 8);
      goto LABEL_233;
    }

    uint64_t result = ccder_blob_check_null();
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v54 = *a4;
    uint64_t v55 = 1048584LL;
    goto LABEL_201;
  }

  char v56 = 0;
  uint64_t result = der_get_BOOLean((void *)result, 0, &v56);
  if ((_DWORD)result)
  {
    uint64_t v53 = 0x10000080002LL;
    if (!v56) {
      uint64_t v53 = 0x20000040001LL;
    }
    *a4 |= v53;
  }

  return result;
}

uint64_t X509CertificateParseWithExtension( unint64_t *a1, unint64_t *a2, const void *a3, size_t a4)
{
  uint64_t v8 = 720939LL;
  unint64_t v9 = *a2;
  unint64_t v10 = a2[1];
  unint64_t v11 = *a2;
  uint64_t result = X509CertificateParseImplicit((uint64_t)a1, a2, a3, a4);
  uint64_t v8 = result;
  if ((_DWORD)result) {
    return v8;
  }
  if (v11 >= 0x5555555555555556LL)
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5500u);
    goto LABEL_12;
  }

  uint64_t v8 = 720939LL;
  if (*a2 != v11 - 0x5555555555555556LL) {
    return v8;
  }
  unint64_t v13 = v11 - v9 - 0x5555555555555556LL;
  if (v11 - v9 >= 0x5555555555555556LL) {
    goto LABEL_11;
  }
  if (v10 >= v9 && v13 <= v10 - v9)
  {
    *a1 = v9;
    a1[1] = v13;
    X509PolicyCheckForBlockedKeys((uint64_t)a1);
    return 0LL;
  }

uint64_t X509CertificateParse(unint64_t *a1, unint64_t *a2)
{
  return X509CertificateParseWithExtension(a1, a2, 0LL, 0LL);
}

uint64_t X509CertificateParseSPKI( unint64_t *a1, unint64_t *a2, unint64_t *a3, void *a4)
{
  unint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  if (__CFADD__(*a1, v5)) {
    goto LABEL_31;
  }
  unint64_t v6 = v4 + v5;
  if (v4 > v6) {
    goto LABEL_30;
  }
  uint64_t v10 = 655361LL;
  unint64_t v14 = *a1;
  unint64_t v15 = v6;
  if (v14 >= 0x5555555555555556LL) {
LABEL_31:
  }
    __break(0x5513u);
  if (v14 > v14 - 0x5555555555555556LL || v14 - 0x5555555555555556LL > v15) {
    goto LABEL_30;
  }
  unint64_t v13 = v14 - 0x5555555555555556LL;
  if (a2)
  {
    if (v13 >= v14)
    {
      *a2 = v14;
      a2[1] = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_12;
    }

uint64_t X509CertificateCheckSignatureDigest(char a1, uint64_t a2, uint64_t *a3, __int128 *a4, __int128 *a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  __int128 v28 = 0uLL;
  __int128 v27 = 0uLL;
  unint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v24 = 0LL;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  uint64_t v9 = X509CertificateParseSPKI((unint64_t *)(a2 + 88), (unint64_t *)&v28, (unint64_t *)&v27, &v25);
  if ((_DWORD)v9) {
    return v9;
  }
  uint64_t v9 = 655632LL;
  if (compare_octet_string((uint64_t)&v28, (uint64_t)&rsaEncryption))
  {
    unint64_t v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))validateSignatureEC;
  }

  else
  {
    unint64_t v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))validateSignatureRSA;
  }

  memset(v14, 0, sizeof(v14));
  __int128 v19 = *a5;
  __int128 v15 = *a4;
  __int128 v17 = v28;
  __int128 v18 = v27;
  if (((a1 & 1) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha1, 5uLL))
    && ((a1 & 4) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha256, 9uLL))
    && ((a1 & 8) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha384, 9uLL))
    && ((a1 & 0x10) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha512, 9uLL)))
  {
    return v9;
  }

  uint64_t result = v25;
  if (v26 || !v25)
  {
    uint64_t v12 = *a3;
    uint64_t v13 = a3[1];
    if (v13 || !v12)
    {
      if (v11(v25, v26, v12, v13, v14)) {
        return 0LL;
      }
      else {
        return 655648LL;
      }
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t X509CertificateCheckSignature(char a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[2] = v8;
  v12[3] = v8;
  v12[0] = v8;
  v12[1] = v8;
  v11[0] = (uint64_t)v12;
  v11[1] = 64LL;
  __int128 v10 = 0uLL;
  uint64_t result = X509MatchSignatureAlgorithm(a3, a4, (uint64_t)v11, &v10);
  if (!(_DWORD)result) {
    return X509CertificateCheckSignatureDigest(a1, a2, v11, &v10, a5);
  }
  return result;
}

uint64_t X509MatchSignatureAlgorithm(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t result = compare_octet_string_raw(a2, &sha1WithRSA_oid, 9uLL);
  if (!(_DWORD)result) {
    goto LABEL_8;
  }
  uint64_t result = compare_octet_string_raw(a2, &sha256WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
  {
LABEL_10:
    *a4 = &CTOidSha256;
    a4[1] = 9LL;
    if (*(void *)(a3 + 8) < 0x20uLL) {
      goto LABEL_15;
    }
    *(void *)(a3 + 8) = 32LL;
    ccsha256_di();
    goto LABEL_14;
  }

  uint64_t result = compare_octet_string_raw(a2, &sha384WithRSA_oid, 9uLL);
  if (!(_DWORD)result) {
    goto LABEL_12;
  }
  uint64_t result = compare_octet_string_raw(a2, &sha1WithECDSA_oid, 7uLL);
  if (!(_DWORD)result)
  {
LABEL_8:
    *a4 = &CTOidSha1;
    a4[1] = 5LL;
    if (*(void *)(a3 + 8) < 0x14uLL) {
      goto LABEL_15;
    }
    *(void *)(a3 + 8) = 20LL;
    ccsha1_di();
LABEL_14:
    ccdigest();
    return 0LL;
  }

  uint64_t result = compare_octet_string_raw(a2, &sha256WithECDSA_oid, 8uLL);
  if (!(_DWORD)result) {
    goto LABEL_10;
  }
  uint64_t result = compare_octet_string_raw(a2, &sha384WithECDSA_oid, 8uLL);
  if ((_DWORD)result) {
    return 656640LL;
  }
LABEL_12:
  *a4 = &CTOidSha384;
  a4[1] = 9LL;
  if (*(void *)(a3 + 8) >= 0x30uLL)
  {
    *(void *)(a3 + 8) = 48LL;
    ccsha384_di();
    goto LABEL_14;
  }

uint64_t X509CertificateCheckSignatureWithPublicKey( uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, __int128 *a5, __int128 *a6)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[2] = v11;
  v32[3] = v11;
  v32[0] = v11;
  v32[1] = v11;
  unint64_t v30 = v32;
  uint64_t v31 = 64LL;
  __int128 v29 = 0uLL;
  uint64_t matched = X509MatchSignatureAlgorithm(a4, (uint64_t)a5, (uint64_t)&v30, &v29);
  if ((_DWORD)matched) {
    return matched;
  }
  uint64_t matched = 655617LL;
  if (compare_octet_string(a2, (uint64_t)&rsaEncryption))
  {
    uint64_t v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))validateSignatureEC;
  }

  else
  {
    uint64_t v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, void *))validateSignatureRSA;
  }

  uint64_t v28 = 0LL;
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v22 = 0u;
  __int128 v20 = 0u;
  __int128 v18 = 0u;
  __int128 v21 = *a5;
  uint64_t v17 = 0LL;
  __int128 v23 = *a6;
  __int128 v19 = v29;
  if (a3) {
    __int128 v14 = *a3;
  }
  else {
    __int128 v14 = null_octet;
  }
  __int128 v22 = v14;
  uint64_t result = *a1;
  uint64_t v16 = a1[1];
  if ((v16 || !result) && (!v30 || v31))
  {
    else {
      return 655648LL;
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t X509CertificateSubjectNameGetCommonName(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v20 = v3;
  if (__CFADD__(*a1, v3)) {
    goto LABEL_59;
  }
  unint64_t v4 = v2 + v3;
  if (v2 > v4)
  {
LABEL_58:
    __break(0x5519u);
    goto LABEL_59;
  }

  uint64_t v6 = 720901LL;
  unint64_t v18 = *a1;
  unint64_t v19 = v4;
  *a2 = 0LL;
  a2[1] = 0LL;
  if (v2 < v4)
  {
    while (1)
    {
      unint64_t v2 = v18;
      if (__CFADD__(v18, v20)) {
        break;
      }
      unint64_t v7 = v18 + v20;
      if (v18 > v18 + v20 || v7 > v19) {
        goto LABEL_58;
      }
      unint64_t v16 = v18;
      unint64_t v17 = v18 + v20;
      while (v2 < v7)
      {
        if (__CFADD__(v16, v20)) {
          goto LABEL_59;
        }
        if (v16 > v16 + v20 || v16 + v20 > v17) {
          goto LABEL_58;
        }
        unint64_t v15 = v16 + v20;
        unint64_t v2 = v16 + v20;
        if (v16 > v15) {
          goto LABEL_58;
        }
        if (__CFADD__(v16, v20)) {
          goto LABEL_59;
        }
        if (v16 > v16 + v20) {
          goto LABEL_58;
        }
        unint64_t v14 = v16 + v20;
        if (v20 == 3 && *(_WORD *)v16 == 1109 && *(_BYTE *)(v16 + 2) == 3)
        {
          unint64_t v12 = v16 + v20;
          unint64_t v13 = v16 + v20;
          if ((ccder_blob_decode_tl() & 1) == 0)
          {
            if (v14 > v15) {
              goto LABEL_58;
            }
            unint64_t v12 = v16 + v20;
            unint64_t v13 = v16 + v20;
            if ((ccder_blob_decode_tl() & 1) == 0)
            {
              if (v14 > v15) {
                goto LABEL_58;
              }
              unint64_t v12 = v16 + v20;
              unint64_t v13 = v16 + v20;
            }
          }

          if (__CFADD__(v12, v20)) {
            goto LABEL_59;
          }
          unint64_t v2 = v12 + v20;
          if (v15 != v12 + v20) {
            return 720902LL;
          }
          if (v13 < v12 || v20 > v13 - v12) {
            goto LABEL_58;
          }
          *a2 = v12;
          a2[1] = v20;
        }

        unint64_t v7 = v18 + v20;
        if (v2 > v17 || v16 > v2) {
          goto LABEL_58;
        }
        unint64_t v16 = v2;
      }

      if (v2 != v7) {
        return 720903LL;
      }
      unint64_t v4 = v19;
      if (v2 > v19 || v18 > v2) {
        goto LABEL_58;
      }
      unint64_t v18 = v2;
      if (v2 >= v19) {
        goto LABEL_46;
      }
    }

LABEL_59:
    __break(0x5513u);
  }

LABEL_46:
  if (v2 != v4) {
    return 720904LL;
  }
  if (a2[1] && *a2) {
    return 0LL;
  }
  *a2 = 0LL;
  a2[1] = 0LL;
  return 720905LL;
}

      unint64_t v12 = (void **)v7;
      goto LABEL_22;
    }

    goto LABEL_43;
  }

  if (v8 >= a3) {
    return v5;
  }
  unint64_t v12 = (void **)(a2 + 1);
  unint64_t v13 = (void **)a2[1];
  if (v13)
  {
    do
    {
      unint64_t v12 = v13;
      unint64_t v13 = (void **)*v13;
      unint64_t v14 = (uint64_t **)v12;
      unint64_t v15 = v12;
    }

    while (v13);
  }

  else
  {
    unint64_t v15 = (void **)a2;
    do
    {
      unint64_t v20 = v15;
      unint64_t v15 = (void **)v15[2];
    }

    while (*v15 != v20);
    unint64_t v14 = (uint64_t **)a2;
  }

  if (v15 != (void **)v7 && *((_DWORD *)v15 + 7) <= a3)
  {
    __int128 v21 = *v7;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v14 = (uint64_t **)v21;
          __int128 v22 = *((_DWORD *)v21 + 7);
          if (v22 <= a3) {
            break;
          }
          __int128 v21 = *v14;
          unint64_t v7 = v14;
          if (!*v14) {
            goto LABEL_44;
          }
        }

        if (v22 >= a3) {
          goto LABEL_46;
        }
        unint64_t v7 = v14 + 1;
        __int128 v21 = v14[1];
        if (!v21) {
          goto LABEL_44;
        }
      }
    }

          if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          goto LABEL_49;
        }
      }

      else
      {
        __int128 v27 = 0;
      }

      operator delete(v84.__r_.__value_.__l.__data_);
      if (v27) {
        goto LABEL_43;
      }
      goto LABEL_46;
    }

BOOL X509CertificateValidAtTime(uint64_t a1, time_t a2)
{
  BOOL result = 0LL;
  v6[1] = *MEMORY[0x1895F89C0];
  time_t v5 = 0LL;
  v6[0] = 0LL;
  if (a1 && a2 != -1) {
    return !X509CertificateGetNotBefore(a1, v6)
  }
        && !X509CertificateGetNotAfter(a1, &v5)
        && difftime(a2, v6[0]) >= 0.0
        && difftime(a2, v5) <= 0.0;
  return result;
}

uint64_t X509CertificateGetNotBefore(uint64_t a1, time_t *a2)
{
  unint64_t v4[2] = *(const char **)MEMORY[0x1895F89C0];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result) {
    return X509TimeConvert(v4, a2);
  }
  return result;
}

uint64_t X509CertificateGetNotAfter(uint64_t a1, time_t *a2)
{
  unint64_t v4[2] = *(const char **)MEMORY[0x1895F89C0];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result) {
    return X509TimeConvert(v4, a2);
  }
  return result;
}

BOOL X509CertificateIsValid(uint64_t a1)
{
  time_t v2 = time(0LL);
  return X509CertificateValidAtTime(a1, v2);
}

uint64_t X509CertificateParseValidity(uint64_t result)
{
  time_t v6[2] = *MEMORY[0x1895F89C0];
  uint64_t v1 = 720906LL;
  if (!result) {
    return v1;
  }
  unint64_t v2 = *(void *)(result + 72);
  uint64_t v3 = *(void *)(result + 80);
  if (!v2 || v3 == 0) {
    return v1;
  }
  if (__CFADD__(v2, v3))
  {
    __break(0x5513u);
  }

  else
  {
    unint64_t v5 = v2 + v3;
    if (v2 <= v5)
    {
      v6[0] = *(void *)(result + 72);
      v6[1] = v5;
      return 720908LL;
    }
  }

  __break(0x5519u);
  return result;
}

uint64_t X509TimeConvert(const char **a1, time_t *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v2 = 720909LL;
  if (!a1) {
    return v2;
  }
  unint64_t v4 = a1[1];
  v11.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v11.tm_mon = v6;
  *(_OWORD *)&v11.tm_isdst = v6;
  *(_OWORD *)&v11.tm_sec = v6;
  unint64_t v7 = *a1;
  if (v4 == (const char *)13)
  {
    uint64_t result = (uint64_t)strptime(v7, "%y%m%d%H%M%SZ", &v11);
    if (result && v11.tm_year >= 150) {
      v11.tm_year -= 100;
    }
  }

  else
  {
    uint64_t result = (uint64_t)strptime(v7, "%Y%m%d%H%M%SZ", &v11);
  }

  uint64_t v9 = a1[1];
  if (!__CFADD__(*a1, v9))
  {
    time_t v10 = timegm(&v11);
    if (v10 == -1) {
      return 720911LL;
    }
    uint64_t v2 = 0LL;
    if (a2) {
      *a2 = v10;
    }
    return v2;
  }

  __break(0x5513u);
  return result;
}

BOOL X509ExtensionParseComponentAuth(unint64_t *a1, void *a2, unint64_t *a3)
{
  unint64_t v3 = a1[1];
  if (*a1 > v3) {
    goto LABEL_19;
  }
  unint64_t v12 = *a1;
  unint64_t v13 = a1[1];
  unint64_t v11 = v3 - *a1;
  if ((ccder_blob_decode_tl() & 1) != 0) {
    goto LABEL_5;
  }
  if (*a1 > a1[1]) {
    goto LABEL_19;
  }
  unint64_t v12 = *a1;
  unint64_t v13 = a1[1];
  if (ccder_blob_decode_tl())
  {
LABEL_5:
    unint64_t v8 = v12;
    unint64_t v7 = v13;
    if (v12 > v13) {
      goto LABEL_19;
    }
    *a1 = v12;
    a1[1] = v13;
    unint64_t v9 = v11;
  }

  else
  {
    unint64_t v8 = *a1;
    unint64_t v7 = a1[1];
    unint64_t v9 = v7 - *a1;
  }

  if (__CFADD__(v8, v9)) {
    goto LABEL_20;
  }
  if (v7 == v8 + v9)
  {
    if (!v9) {
      goto LABEL_16;
    }
    if (!a3)
    {
LABEL_15:
      *a2 |= 0x40000000uLL;
LABEL_16:
      if (v8 <= v7)
      {
        *a1 = v7;
        return v7 == v8 + v9;
      }

      goto LABEL_19;
    }

    if (v8 <= v7 && v9 <= v7 - v8)
    {
      *a3 = v8;
      a3[1] = v9;
      goto LABEL_15;
    }

LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(0x5513u);
  }

  return v7 == v8 + v9;
}

  return v31;
}

  return v25;
}

                  free(v26);
                  free(v25);
                  if (v10) {
                    CFRelease(v10);
                  }
                  if (v12) {
                    CFRelease(v12);
                  }
                  free(v9);
                  if ((v24 & 1) == 0) {
                    return 4294967246LL;
                  }
                  goto LABEL_15;
                }
              }
            }
          }

          unint64_t v20 = 0LL;
          CFIndex Length = 0;
        }

        else
        {
          unint64_t v20 = 0LL;
          CFIndex Length = 0;
          unint64_t v12 = 0LL;
        }

        __int128 v24 = 0;
        __int128 v25 = 0LL;
        __int128 v26 = 0LL;
        goto LABEL_19;
      }

      free(v9);
      return 4294967246LL;
    }
  }

  return v5;
}

    SecError(-50, a8, @"%@: sign - input buffer bad size (%d bytes)", a1, Length);
    return 0LL;
  }

  return Mutable;
}

        CFRelease(Mutable);
        goto LABEL_20;
      }

      unint64_t v17 = (os_log_s *)secLogObjForScope("scep");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        __int128 v22 = ValueAtIndex;
        _os_log_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEFAULT, "failed to create chain %@", buf, 0xCu);
      }
    }

  unint64_t v19 = (const void *)v26[3];
  if (v19) {
    CFRelease(v19);
  }
  _Block_object_dispose(&v25, 8);
  return Mutable;
}

uint64_t X509ExtensionParseCertifiedChipIntermediate(unint64_t *a1, void *a2, unint64_t *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v7 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
      goto LABEL_12;
    }

    unint64_t v8 = v7 - 0x5555555555555556LL;
    if (a1[1] != v7 - 0x5555555555555556LL) {
      return 0LL;
    }
    *a2 |= 0x30000000000uLL;
    if (a3)
    {
      if (v7 > v8) {
        goto LABEL_12;
      }
      *a3 = v7;
      a3[1] = 0xAAAAAAAAAAAAAAAALL;
    }

    if (v7 <= v8)
    {
      *a1 = v8;
      return 1LL;
    }

uint64_t X509ExtensionParseMFIAuthv3Leaf(unint64_t *a1)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v3 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
    }

    else
    {
      unint64_t v4 = a1[1];
      if (v4 != v3 - 0x5555555555555556LL) {
        return 0LL;
      }
      if (v3 <= v4)
      {
        *a1 = v4;
        return 1LL;
      }
    }

    __break(0x5519u);
  }

  return result;
}

uint64_t X509ExtensionParseMFISWAuth(unint64_t *a1, void *a2, unint64_t *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v7 = *a1;
    if (*a1 >= 0x5555555555555556LL)
    {
      __break(0x5513u);
    }

    else
    {
      unint64_t v8 = a1[1];
      if (v8 != v7 - 0x5555555555555556LL) {
        return 0LL;
      }
      if (a3)
      {
        if (v8 < v7 || v8 - v7 < 0xAAAAAAAAAAAAAAAALL) {
          goto LABEL_13;
        }
        *a3 = v7;
        a3[1] = 0xAAAAAAAAAAAAAAAALL;
      }

      *a2 |= 0x30000000uLL;
      if (v7 <= v8)
      {
        *a1 = v8;
        return 1LL;
      }
    }

uint64_t X509ExtensionParseGenericSSLMarker()
{
  return 0LL;
}

uint64_t X509ExtensionParseServerAuthMarker( uint64_t a1, unint64_t a2, uint64_t a3, void *a4, unint64_t *a5)
{
  uint64_t result = ccder_blob_check_null();
  if ((_DWORD)result)
  {
    if (a2 > 0xFFFFFFFFFFFFFFF6LL) {
      goto LABEL_26;
    }
    if (__CFADD__(a2, a3)) {
      goto LABEL_26;
    }
    unint64_t v10 = a2 + a3;
    if (a2 + a3 == -1LL) {
      goto LABEL_26;
    }
    unint64_t v11 = a2 + 9;
    unint64_t v12 = (char *)(a2 + 9);
    while (1)
    {
      BOOL v13 = (unint64_t)v12 < v10 && (unint64_t)v12 >= a2;
      BOOL v14 = v13;
      if (!v14) {
        goto LABEL_25;
      }
      int v15 = *v12++;
      if ((v15 & 0x80000000) == 0) {
        return 0LL;
      }
    }

    if (!v14)
    {
LABEL_25:
      __break(0x5519u);
LABEL_26:
      __break(0x5513u);
      return result;
    }

    if ((*v12 & 0x80000000) == 0)
    {
      if (!a5)
      {
LABEL_22:
        *a4 |= 0x100000000uLL;
        return 1LL;
      }

      if (v11 >= a2 && v11 <= v10)
      {
        *a5 = v11;
        a5[1] = a3 - 9;
        goto LABEL_22;
      }

      goto LABEL_25;
    }

    return 0LL;
  }

  return result;
}

uint64_t X509ExtensionParseDeviceAttestationIdentity(unint64_t *a1, void *a2, unint64_t *a3)
{
  uint64_t result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    unint64_t v7 = *a1;
    if (*a1 >= 0x5555555555555556LL) {
      goto LABEL_17;
    }
    if (a1[1] != v7 - 0x5555555555555556LL) {
      return 0LL;
    }
    if (v7 > v7 - 0x5555555555555556LL) {
      goto LABEL_18;
    }
    unint64_t v10 = *a1;
    unint64_t v11 = v7 - 0x5555555555555556LL;
    uint64_t result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      uint64_t result = ccder_blob_decode_tl();
      if ((_DWORD)result)
      {
        if (a3)
        {
          if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL) {
            goto LABEL_18;
          }
          *a3 = v10;
          a3[1] = 0xAAAAAAAAAAAAAAAALL;
        }

        *a2 |= 0x240000800000uLL;
        unint64_t v8 = *a1;
        if (*a1 < 0x5555555555555556LL)
        {
          unint64_t v9 = v8 - 0x5555555555555556LL;
          if (v8 <= v8 - 0x5555555555555556LL && v9 <= a1[1])
          {
            *a1 = v9;
            return 1LL;
          }

unint64_t *X509ExtensionParseMFI4Properties( unint64_t *result, void *a2, unint64_t *a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  unint64_t v5 = v3 - *result;
  if (v5 != 32) {
    return (unint64_t *)(v5 == 32);
  }
  if (a3)
  {
    if (v4 > v3)
    {
LABEL_12:
      __break(0x5519u);
      goto LABEL_13;
    }

    *a3 = v4;
    a3[1] = 32LL;
  }

  *a2 |= 0xC00000000uLL;
  if (v4 < 0xFFFFFFFFFFFFFFE0LL)
  {
    unint64_t v6 = v4 + 32;
    if (v4 + 32 <= v3 && v4 <= v6)
    {
      *uint64_t result = v6;
      return (unint64_t *)(v5 == 32);
    }

    goto LABEL_12;
  }

uint64_t X509ChainGetCertificateUsingKeyIdentifier(uint64_t *a1, uint64_t a2)
{
  for (uint64_t i = *a1; i; uint64_t i = *(void *)(i + 272))
  {
  }

  return i;
}

uint64_t X509ChainBuildPathPartial(void *a1, uint64_t *a2, void *a3, int a4)
{
  if (!a1) {
    return 327691LL;
  }
  unint64_t v7 = a1;
  *a3 = a1;
  a3[1] = a1 + 36;
  a1[36] = 0LL;
  a1[37] = a3;
  uint64_t v8 = (uint64_t)(a1 + 15);
  uint64_t result = compare_octet_string((uint64_t)(a1 + 15), (uint64_t)(a1 + 13));
  if ((_DWORD)result)
  {
    while (1)
    {
      uint64_t v10 = (uint64_t)(v7 + 21);
      if (!v7[22]
        || (uint64_t CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier(a2, (uint64_t)(v7 + 21))) == 0
        || (unint64_t v7 = (void *)CertificateUsingKeyIdentifier,
            compare_octet_string(CertificateUsingKeyIdentifier + 104, v8)))
      {
        unint64_t v7 = (void *)*a2;
        if (!*a2)
        {
LABEL_16:
          if (X509ChainGetAppleRootUsingKeyIdentifier(v10, 1)) {
            return 0LL;
          }
          uint64_t BAARootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v10);
          if (a4) {
            unsigned int v16 = 0;
          }
          else {
            unsigned int v16 = 524296;
          }
          if (BAARootUsingKeyIdentifier) {
            return 0LL;
          }
          else {
            return v16;
          }
        }

        while (compare_octet_string(v8, (uint64_t)(v7 + 13)))
        {
          unint64_t v7 = (void *)v7[34];
          if (!v7) {
            goto LABEL_16;
          }
        }
      }

      unint64_t v12 = (void *)*a3;
      if (*a3) {
        break;
      }
LABEL_13:
      BOOL v13 = (void *)a3[1];
      v7[36] = 0LL;
      v7[37] = v13;
      *BOOL v13 = v7;
      a3[1] = v7 + 36;
      uint64_t v8 = (uint64_t)(v7 + 15);
      int v14 = compare_octet_string((uint64_t)(v7 + 15), (uint64_t)(v7 + 13));
      uint64_t result = 0LL;
      if (!v14) {
        return result;
      }
    }

    while (v12 != v7)
    {
      unint64_t v12 = (void *)v12[36];
      if (!v12) {
        goto LABEL_13;
      }
    }

    return 524297LL;
  }

  return result;
}

uint64_t X509ChainGetAppleRootUsingKeyIdentifier(uint64_t result, int a2)
{
  uint64_t v2 = &numAppleRoots;
  if (!a2) {
    uint64_t v2 = &numAppleProdRoots;
  }
  uint64_t v3 = *v2;
  if (*v2)
  {
    uint64_t v4 = result;
    for (uint64_t i = (uint64_t *)&AppleRoots; i < (uint64_t *)&UcrtRootSpki && i >= (uint64_t *)&AppleRoots; ++i)
    {
      uint64_t v7 = *i;
      uint64_t result = compare_octet_string(v4, *i + 184);
      if (!(_DWORD)result) {
        return v7;
      }
      if (!--v3) {
        return 0LL;
      }
    }

    __break(0x5519u);
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t X509ChainGetBAARootUsingKeyIdentifier(uint64_t result)
{
  uint64_t v1 = numBAARoots;
  if (numBAARoots)
  {
    uint64_t v2 = result;
    for (uint64_t i = (uint64_t *)&BAARoots; i < digests && i >= (uint64_t *)&BAARoots; ++i)
    {
      uint64_t v5 = *i;
      uint64_t result = compare_octet_string(v2, *i + 184);
      if (!(_DWORD)result) {
        return v5;
      }
      if (!--v1) {
        return 0LL;
      }
    }

    __break(0x5519u);
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t X509ChainBuildPath(void *a1, uint64_t *a2, void *a3)
{
  return X509ChainBuildPathPartial(a1, a2, a3, 0);
}

uint64_t X509ChainCheckPathWithOptions(char a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6 = a2;
  void v35[4] = *MEMORY[0x1895F89C0];
  uint64_t v8 = *a2;
  if (a3)
  {
    uint64_t v9 = *(void *)(a3 + 48);
    if (v9)
    {
      if (*(void *)(v9 + 8))
      {
        uint64_t v8 = *v6;
      }
    }
  }

  if (v8)
  {
    uint64_t v31 = v6;
    unint64_t v32 = a4;
    unint64_t v11 = 0LL;
    int v12 = 0;
    char v33 = 0;
    uint64_t v13 = -1LL;
    while (1)
    {
      unint64_t v14 = *(void *)(v8 + 288);
      unint64_t v15 = v14 + 304;
      if (v14)
      {
LABEL_10:
        char v16 = 0;
        goto LABEL_11;
      }

      if (!compare_octet_string(v8 + 120, v8 + 104))
      {
        char v16 = 0;
        unint64_t v15 = v8 + 304;
        unint64_t v14 = v8;
        goto LABEL_11;
      }

      if (!a3) {
        return v12 | 0x9000Du;
      }
      if (*(_BYTE *)(a3 + 16))
      {
        uint64_t AppleRootUsingKeyIdentifier = X509ChainGetAppleRootUsingKeyIdentifier(v8 + 168, *(unsigned __int8 *)(a3 + 17));
      }

      else
      {
        if (!*(void *)(a3 + 24)) {
          goto LABEL_58;
        }
        uint64_t AppleRootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v8 + 168);
      }

      unint64_t v14 = AppleRootUsingKeyIdentifier;
      v33 |= AppleRootUsingKeyIdentifier != 0;
      unint64_t v15 = AppleRootUsingKeyIdentifier + 304;
      if (AppleRootUsingKeyIdentifier) {
        goto LABEL_10;
      }
LABEL_58:
      if (!*(_BYTE *)(a3 + 19)) {
        return v12 | 0x9000Du;
      }
      unint64_t v14 = 0LL;
      char v16 = 1;
LABEL_11:
      if (v11 && *(void *)(v8 + 32) >= 2uLL)
      {
        if (!*(_BYTE *)(v8 + 265))
        {
          int v30 = 589825;
          return v12 | v30;
        }

        if ((*(_BYTE *)(v8 + 264) & 4) == 0)
        {
          int v30 = 589826;
          return v12 | v30;
        }
      }

      unint64_t v17 = *(void *)(v8 + 200);
      if (v17) {
        BOOL v18 = v17 >= v11;
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18)
      {
        int v30 = 589827;
        return v12 | v30;
      }

      if (*(_BYTE *)(v8 + 266))
      {
        int v30 = 589831;
        return v12 | v30;
      }

      if (compare_octet_string(v8 + 40, v8 + 152))
      {
        int v30 = 589828;
        return v12 | v30;
      }

      if ((v16 & 1) == 0 && *(void *)(v8 + 168) && *(void *)(v8 + 176))
      {
        if (v14 >= v15) {
          goto LABEL_100;
        }
      }

      if (a3 && v11 && (*(void *)(v8 + 240) & *(void *)(a3 + 8)) == 0LL) {
        X509PolicySetFlagsForCommonNames(v8);
      }
      if (v14 == v8 && !*(void *)(v8 + 240))
      {
        X509PolicySetFlagsForRoots(a3, v8);
        if (a3)
        {
LABEL_34:
          if (*(_BYTE *)(a3 + 18) && !X509CertificateIsValid(v8)) {
            return v12 | 0x90009u;
          }
          uint64_t v19 = *(void *)(a3 + 8);
          if (!v11 && (*(void *)(v8 + 240) & v19) == 0)
          {
            X509PolicySetFlagsForMFI(v8);
            uint64_t v19 = *(void *)(a3 + 8);
          }

          v13 &= *(void *)(v8 + 240);
          if (v19 && (v19 & v13) == 0)
          {
            int v30 = 589829;
            return v12 | v30;
          }

          goto LABEL_49;
        }
      }

      else if (a3)
      {
        goto LABEL_34;
      }

      v13 &= *(void *)(v8 + 240);
LABEL_49:
      a1 |= v14 == v8;
      if ((v16 & 1) == 0)
      {
        if (v14 >= v15) {
          goto LABEL_100;
        }
        uint64_t result = X509CertificateCheckSignature(a1, v14, v8 + 16, v8 + 40, (__int128 *)(v8 + 56));
        if ((_DWORD)result) {
          return result;
        }
      }

      unint64_t v21 = v11 + 1;
      if (v11 == -1LL) {
        goto LABEL_99;
      }
      uint64_t v8 = *(void *)(v8 + 288);
      v12 += 256;
      ++v11;
      if (!v8)
      {
        unint64_t v6 = v31;
        a4 = v32;
        LOBYTE(v8) = v33;
        if (a3) {
          goto LABEL_61;
        }
        goto LABEL_87;
      }
    }
  }

  unint64_t v21 = 0LL;
  uint64_t v13 = -1LL;
  if (!a3) {
    goto LABEL_87;
  }
LABEL_61:
  if (*(void *)a3)
  {
    unint64_t v22 = v21;
    if ((v8 & 1) != 0)
    {
      unint64_t v22 = v21 + 1;
      if (v21 == -1LL)
      {
LABEL_99:
        __break(0x5500u);
LABEL_100:
        __break(0x5519u);
      }
    }

    if (*(void *)a3 != v22) {
      return ((_DWORD)v22 << 8) | 0x90006u;
    }
  }

  uint64_t v23 = *(void *)(a3 + 24);
  if (!v23 || !*(void *)(v23 + 8))
  {
    if (!*(_BYTE *)(a3 + 16)) {
      goto LABEL_87;
    }
    int v24 = (_DWORD)v21 << 8;
    uint64_t v25 = **(void **)(v6[1] + 8);
LABEL_75:
    uint64_t v27 = 184LL;
    if ((v8 & 1) != 0) {
      uint64_t v27 = 168LL;
    }
    uint64_t v28 = X509ChainGetAppleRootUsingKeyIdentifier(v25 + v27, *(unsigned __int8 *)(a3 + 17));
    if (!v28) {
      return v24 | 0x9000Bu;
    }
    uint64_t v29 = v28;
    if ((v8 & 1) == 0 && !compare_octet_string(v25 + 88, v28 + 88)
      || !X509CertificateCheckSignature(29, v29, v25 + 16, v25 + 40, (__int128 *)(v25 + 56)))
    {
      goto LABEL_87;
    }

    int v26 = 589836;
    return v24 | v26;
  }

  int v24 = (_DWORD)v21 << 8;
  uint64_t v25 = **(void **)(v6[1] + 8);
  if (*(_BYTE *)(a3 + 16)) {
    goto LABEL_75;
  }
  memset(v35, 170, 32);
  v34[0] = 0xAAAAAAAAAAAAAAAALL;
  v34[1] = 0xAAAAAAAAAAAAAAAALL;
  if (X509CertificateParseSPKI((unint64_t *)(v25 + 88), &v35[2], v34, v35))
  {
LABEL_72:
    int v26 = 589832;
    return v24 | v26;
  }

  if (compare_octet_string((uint64_t)&v35[2], *(void *)(a3 + 32))
    || compare_octet_string((uint64_t)v35, *(void *)(a3 + 24)))
  {
    if (X509CertificateCheckSignatureWithPublicKey( *(uint64_t **)(a3 + 24),  *(void *)(a3 + 32),  *(__int128 **)(a3 + 40),  v25 + 16,  (__int128 *)(v25 + 40),  (__int128 *)(v25 + 56))) {
      goto LABEL_72;
    }
  }

  else if (!compare_octet_string(*(void *)(a3 + 32), (uint64_t)&ecPublicKey_0))
  {
    compare_octet_string((uint64_t)v34, *(void *)(a3 + 40));
  }

LABEL_87:
  uint64_t result = 0LL;
  if (a4) {
    *a4 = v13;
  }
  return result;
}

    Security::UnixError::throwMe((Security::UnixError *)8);
  }

  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 16) = 0;
  *(int8x8_t *)(a1 + 20) = *(int8x8_t *)((char *)v75 + 4);
  uint64_t v7 = (os_log_s *)secLogObjForScope("macho");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = NXGetArchInfoFromCpuType(*(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) & 0xFFFFFF);
    if (v8) {
      name = (__darwin_ino64_t)v8->name;
    }
    else {
      name = 0LL;
    }
    goto LABEL_83;
  }

  return a1;
}

      free(v41);
    }

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3LL;
  }
  uint64_t result = 0LL;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  unint64_t v4[3] = *MEMORY[0x1895F89C0];
  memset(v4, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v4, 0LL);
  if (!(_DWORD)result)
  {
    if (v4[0] - 0x2000000000000012LL >= 0xFFFFFFFFFFFFFFFELL) {
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    }
    else {
      return 2LL;
    }
  }

  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  v9[2] = *MEMORY[0x1895F89C0];
  v9[0] = 0LL;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }

  unint64_t v4 = v2 + v3;
  if (v2 > v4) {
    goto LABEL_13;
  }
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  char v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if ((_DWORD)result) {
      break;
    }
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if ((_DWORD)result) {
      break;
    }
    if (v7) {
      return 0LL;
    }
  }

  else {
    return result;
  }
}

uint64_t DERLengthOfLength(unint64_t a1)
{
  if (a1 < 0x80) {
    return 1LL;
  }
  unint64_t v2 = a1;
  uint64_t result = 1LL;
  do
  {
    ++result;
    BOOL v3 = v2 > 0xFF;
    v2 >>= 8;
  }

  while (v3);
  return result;
}

LABEL_11:
    char v16 = 0LL;
    goto LABEL_12;
  }

  if (![v8 length])
  {
    secLogObjForScope("SecCritical");
    unint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      BOOL v18 = "Cannot init db without schema";
      goto LABEL_10;
    }

    goto LABEL_11;
  }

  v20.receiver = self;
  v20.super_class = (Class)&OBJC_CLASS___SFSQLite;
  uint64_t v9 = -[SFSQLite init](&v20, sel_init);
  uint64_t v10 = v9;
  if (v9)
  {
    objc_storeStrong((id *)&v9->_path, a3);
    objc_storeStrong((id *)&v10->_schema, a4);
    unint64_t v11 = -[SFSQLite _createSchemaHash](v10, "_createSchemaHash");
    schemaVersion = v10->_schemaVersion;
    v10->_schemaVersion = (NSString *)v11;

    uint64_t v13 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
    statementsBySQL = v10->_statementsBySQL;
    v10->_statementsBySQL = v13;

    objectClassPrefix = v10->_objectClassPrefix;
    v10->_objectClassPrefix = (NSString *)@"CK";

    v10->_synchronousMode = 1LL;
    v10->_hasMigrated = 0;
  }

  self = v10;
  char v16 = self;
LABEL_12:

  return v16;
}

    char v7 = 0LL;
    goto LABEL_12;
  }

  -[NSMutableDictionary objectForKeyedSubscript:](self->_statementsBySQL, "objectForKeyedSubscript:", v5);
  unint64_t v6 = (SFSQLiteStatement *)objc_claimAutoreleasedReturnValue();
  if (!v6)
  {
    ppStmt = 0LL;
    uint64_t v9 = (os_log_s *)v5;
    if (!sqlite3_prepare_v2(self->_db, (const char *)-[os_log_s UTF8String](v9, "UTF8String"), -1, &ppStmt, 0LL))
    {
      int v12 = objc_alloc(&OBJC_CLASS___SFSQLiteStatement);
      char v7 = -[SFSQLiteStatement initWithSQLite:SQL:handle:](v12, "initWithSQLite:SQL:handle:", self, v9, ppStmt);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( self->_statementsBySQL,  "setObject:forKeyedSubscript:",  v7,  v9);

      goto LABEL_12;
    }

    secLogObjForScope("SecError");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      unint64_t v15 = v9;
      _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "Error preparing statement: %@", buf, 0xCu);
    }

    goto LABEL_11;
  }

  char v7 = v6;
  if (!-[SFSQLiteStatement isReset](v6, "isReset"))
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    [v8 handleFailureInMethod:a2, self, @"SFSQLite.m", 550, @"Statement not reset after last use: %@", v5 object file lineNumber description];
  }

  return (KCSharingParticipant *)v3;
}

  return (KCSharingParticipant *)v3;
}

  unint64_t v11 = v5[3];
  _Block_object_dispose(&v13, 8);
  return v11;
}

  unint64_t v11 = v5[3];
  _Block_object_dispose(&v13, 8);
  return v11;
}
}

    SecError(-50, a4, @"SecAccessControl: invalid constraint for k-of-n");
    if (MutableForCFTypesWith)
    {
      CFRelease(MutableForCFTypesWith);
      return 0LL;
    }
  }

  return MutableForCFTypesWith;
}

  return v9;
}

  *(_BYTE *)(result + 650) = 1;
  if ((a4 & 8) == 0) {
    return result;
  }
LABEL_7:
  *(void *)(result + 656) = v8;
  return result;
}
    }

    int v12 = -[SecCBORData initWith:](objc_alloc(&OBJC_CLASS___SecCBORData), "initWith:", v9);
    -[SecCBORArray addObject:](v6, "addObject:", v12);

LABEL_10:
    goto LABEL_11;
  }

  unint64_t v6 = 0LL;
LABEL_25:

  return v4;
}

  CFRelease(v4);
  return v6;
}

LABEL_8:
  unint64_t v65 = a3;
  unint64_t v66 = v15;
  BOOL v18 = v6;
  uint64_t v19 = v9;
  [v12 attributesOfItemAtPath:v9 error:&v66];
  unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t v21 = v66;

  unint64_t v22 = *MEMORY[0x189607530];
  [v20 objectForKeyedSubscript:*MEMORY[0x189607530]];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  int v24 = *MEMORY[0x189607518];
  uint64_t v25 = [v23 isEqualToString:*MEMORY[0x189607518]];

  if ((v25 & 1) == 0)
  {
    unint64_t v72 = v22;
    v73[0] = v24;
    [MEMORY[0x189603F68] dictionaryWithObjects:v73 forKeys:&v72 count:1];
    int v26 = (void *)objc_claimAutoreleasedReturnValue();
    [v12 setAttributes:v26 ofItemAtPath:v19 error:0];
  }

  uint64_t v27 = 0LL;
  uint64_t v28 = 1;
  unint64_t v6 = v18;
  a3 = v65;
  uint64_t v9 = v19;
LABEL_13:

  uint64_t v10 = v27;
  if (!v28) {
    goto LABEL_29;
  }
  uint64_t v29 = sqlite3_open_v2(-[NSString fileSystemRepresentation](v6, "fileSystemRepresentation"), &self->_db, 3145734, 0LL);
  if ((_DWORD)v29)
  {
    int v30 = v29;
    uint64_t v31 = sqlite3_system_errno(self->_db);
    unint64_t v32 = (void *)MEMORY[0x189607870];
    char v33 = *MEMORY[0x189607460];
    unint64_t v34 = (int)v30;
    unint64_t v70 = *MEMORY[0x1896075E0];
    [NSString stringWithFormat:@"Error opening db at %@, rc=%d(0x%x), errno=%d(0x%x)", self->_path, v30, v30, v31, v31];
    unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v71 = v35;
    [MEMORY[0x189603F68] dictionaryWithObjects:&v71 forKeys:&v70 count:1];
    unint64_t v36 = v9;
    unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v38 = [v32 errorWithDomain:v33 code:v34 userInfo:v37];

    uint64_t v9 = v36;
    uint64_t v10 = (id)v38;
    goto LABEL_29;
  }

  -[SFSQLite attemptProperDatabasePermissions](self, "attemptProperDatabasePermissions");
  sqlite3_extended_result_codes(self->_db, 1);
  if (!sqlite3_busy_timeout(self->_db, 300000))
  {
    if (-[SFSQLite executeSQL:](self, "executeSQL:", @"pragma journal_mode = WAL"))
    {
      BOOL v39 = (void *)NSString;
      -[SFSQLite _synchronousModeString](self, "_synchronousModeString");
      int v40 = (void *)objc_claimAutoreleasedReturnValue();
      [v39 stringWithFormat:@"pragma synchronous = %@", v40];
      int v41 = (void *)objc_claimAutoreleasedReturnValue();
      __int128 v42 = -[SFSQLite executeSQL:](self, "executeSQL:", v41);

      if (v42
        && (-[SFSQLite autoVacuumSetting](self, "autoVacuumSetting") == 1
         || -[SFSQLite executeSQL:](self, "executeSQL:", @"pragma auto_vacuum = FULL")
         && -[SFSQLite executeSQL:](self, "executeSQL:", @"VACUUM")))
      {
        -[SFSQLite begin](self, "begin");
        -[SFSQLite select:from:where:bindings:]( self,  "select:from:where:bindings:",  &unk_18969BFB8,  @"sqlite_master",  @"type = ? AND name = ?",  &unk_18969BFD0);
        unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue();
        if (![v43 count]) {
          -[SFSQLite executeSQL:]( self,  "executeSQL:",  @"create table if not exists Properties (\n    key    text primary key,\n    value  text\n);\n");
        }
        -[SFSQLite propertyForKey:](self, "propertyForKey:", @"SchemaVersion");
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
        int v44 = -[SFSQLite dbUserVersion](self, "dbUserVersion");
        if (v8)
        {
          __int128 v45 = v44;
          -[SFSQLite schemaVersion](self, "schemaVersion");
          __int128 v46 = (void *)objc_claimAutoreleasedReturnValue();
          if ([v8 isEqualToString:v46])
          {
            if (!-[SFSQLite userVersion](self, "userVersion"))
            {

              goto LABEL_43;
            }

            __int128 v47 = -[SFSQLite userVersion](self, "userVersion");

            if ((_DWORD)v45 == v47)
            {
LABEL_43:
              -[SFSQLite end](self, "end");
              if (!self->_hasMigrated)
              {
LABEL_46:
                ++self->_openCount;

                unint64_t v11 = 1;
                goto LABEL_34;
              }

    abort();
  }

    unint64_t v6 = 0;
  }

    MutableCopy = 0LL;
    goto LABEL_5;
  }

  if (v3) {
    goto LABEL_8;
  }
  char v7 = (os_log_s *)secLogObjForScope("kpid");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 138412290;
    uint64_t v9 = 0LL;
    _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "Couldn't create kpid: %@", (uint8_t *)&v8, 0xCu);
  }

  return 0LL;
}
}

  unint64_t v17 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v10);
  BOOL v18 = (__CFData *)*MEMORY[0x189605018];
  if (CFArrayGetCount((CFArrayRef)a1[2]) < 1) {
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
  uint64_t v19 = *(void *)(*a1 + 16);
  if (*(_DWORD *)v19 >= 4u && (unint64_t v20 = *(uint64_t (**)(void))(v19 + 152)) != 0LL)
  {
    CFMutableArrayRef Mutable = (__CFData *)v20();
  }

  else
  {
    uint64_t AlgorithmId = SecKeyGetAlgorithmId(*a1);
    uint64_t v23 = 0LL;
    int v24 = &qword_189671920;
    while (AlgorithmId != *v24 || !CFEqual(v17, *(CFTypeRef *)*(v24 - 1)))
    {
      ++v23;
      v24 += 3;
      if (v23 == 7) {
        goto LABEL_39;
      }
    }

    uint64_t v25 = LODWORD((&SecKeyCopyBackendOperationResult_paddingMap)[3 * v23 + 2]);
    size_t length = 0LL;
    switch(a1[1])
    {
      case 0LL:
        CFMutableArrayRef Mutable = v18;
        if (!*(void *)(*(void *)(*a1 + 16) + 40LL)) {
          goto LABEL_36;
        }
        if (a1[3]) {
          goto LABEL_30;
        }
        int v26 = v25;
        size_t length = SecKeyGetSize(*a1, 1);
        CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
        CFDataSetLength(Mutable, length);
        uint64_t v27 = *a1;
        uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(void *)(*a1 + 16) + 40LL);
        goto LABEL_32;
      case 1LL:
        uint64_t v29 = *a1;
        int v30 = *(uint64_t (**)(uint64_t))(*(void *)(*a1 + 16) + 48LL);
        CFMutableArrayRef Mutable = v18;
        if (!v30) {
          goto LABEL_36;
        }
        CFMutableArrayRef Mutable = (__CFData *)*MEMORY[0x189604DE8];
        if (a1[3]) {
          goto LABEL_36;
        }
        __int128 v47 = v25;
        CFDataGetBytePtr(a2);
        CFDataGetLength(a2);
        CFDataGetBytePtr(a3);
        CFDataGetLength(a3);
        uint64_t v31 = v29;
        unint64_t v32 = v47;
        char v33 = v30(v31);
        goto LABEL_33;
      case 2LL:
        CFMutableArrayRef Mutable = v18;
        if (!*(void *)(*(void *)(*a1 + 16) + 56LL)) {
          goto LABEL_36;
        }
        if (a1[3]) {
          goto LABEL_30;
        }
        int v26 = v25;
        size_t length = SecKeyGetSize(*a1, 2);
        CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
        CFDataSetLength(Mutable, length);
        uint64_t v27 = *a1;
        uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(void *)(*a1 + 16) + 56LL);
        goto LABEL_32;
      case 3LL:
        CFMutableArrayRef Mutable = v18;
        if (!*(void *)(*(void *)(*a1 + 16) + 64LL)) {
          goto LABEL_36;
        }
        if (a1[3])
        {
LABEL_30:
          CFMutableArrayRef Mutable = (__CFData *)*MEMORY[0x189604DE8];
        }

        else
        {
          int v26 = v25;
          size_t length = SecKeyGetSize(*a1, 2);
          CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
          CFDataSetLength(Mutable, length);
          uint64_t v27 = *a1;
          uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(void *)(*a1 + 16) + 64LL);
LABEL_32:
          unsigned int v48 = v28;
          BytePtr = CFDataGetBytePtr(a2);
          __int128 v45 = CFDataGetLength(a2);
          MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
          unint64_t v35 = v27;
          unint64_t v32 = v26;
          char v33 = v48(v35, v26, BytePtr, v45, MutableBytePtr, &length);
LABEL_33:
          if (v33)
          {
            SecError(v33, a4, @"legacy SecKey backend operation:%d(%d) failed", a1[1], v32);
            if (Mutable)
            {
              CFRelease(Mutable);
              CFMutableArrayRef Mutable = 0LL;
            }

            break;
          }
        }

  v8[2](v8, v4);
}

  __cxa_end_catch();
  return v5;
}

  Security::CFRef<__CFData const*>::~CFRef((const void **)&v15);
  return v8;
}

LABEL_44:
              -[SFSQLite schemaVersion](self, "schemaVersion");
              unint64_t v62 = (void *)objc_claimAutoreleasedReturnValue();
              -[SFSQLite setProperty:forKey:](self, "setProperty:forKey:", v62, @"SchemaVersion");

              if (-[SFSQLite userVersion](self, "userVersion"))
              {
                objc_msgSend( NSString,  "stringWithFormat:",  @"pragma user_version = %ld",  -[SFSQLite userVersion](self, "userVersion"));
                unint64_t v63 = (void *)objc_claimAutoreleasedReturnValue();
                -[SFSQLite executeSQL:](self, "executeSQL:", v63);
              }

              goto LABEL_46;
            }
          }

          else
          {
          }

          uint64_t v53 = -[SFSQLite delegate](self, "delegate");
          if (v53)
          {
            uint64_t v54 = (void *)v53;
            -[SFSQLite delegate](self, "delegate");
            uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue();
            char v56 = [v55 migrateDatabase:self fromVersion:v45];

            if (v56) {
              self->_hasMigrated = 1;
            }
          }

          if (self->_hasMigrated) {
            goto LABEL_43;
          }
          -[SFSQLite removeAllStatements](self, "removeAllStatements");
          -[SFSQLite dropAllTables](self, "dropAllTables");
          self->_hasMigrated = 1;
        }

        -[SFSQLite executeSQL:]( self,  "executeSQL:",  @"create table if not exists Properties (\n    key    text primary key,\n    value  text\n);\n");
        -[SFSQLite schema](self, "schema");
        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue();
        -[SFSQLite executeSQL:](self, "executeSQL:", v57);

        unint64_t v58 = (void *)NSString;
        [MEMORY[0x189603F50] date];
        unint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
        [v59 timeIntervalSinceReferenceDate];
        objc_msgSend(v58, "stringWithFormat:", @"%f", v60);
        unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue();

        -[SFSQLite setProperty:forKey:](self, "setProperty:forKey:", v61, @"Created");
        -[SFSQLite end](self, "end");
        goto LABEL_44;
      }
    }
  }

      ;
    }

    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

    _Block_object_dispose(buf, 8);
    goto LABEL_45;
  }

  uint64_t v28 = _OctagonSignpostGetNanoseconds(v11, v12);
  _OctagonSignpostLogSystem();
  uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  int v30 = v29;
  if (v15 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled(v29))
  {
    *(_DWORD *)__int128 buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = 0;
    _os_signpost_emit_with_name_impl( &dword_1804F4000,  v30,  OS_SIGNPOST_INTERVAL_END,  v11,  "LeaveClique",  " OctagonSignpostNameLeaveClique=%{public,signpost.telemetry:number1,name=OctagonSignpostNameLeaveClique}d ",  buf,  8u);
  }

  _OctagonSignpostLogSystem();
  uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = (double)v28 / 1000000000.0;
    *(_WORD *)&buf[22] = 1026;
    LODWORD(v54) = 0;
    _os_log_impl( &dword_1804F4000,  v31,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: LeaveClique  OctagonSignpostNameLeaveClique=%{public,signpost.telemetry:number1,name=OctagonSignpo stNameLeaveClique}d ",  buf,  0x1Cu);
  }

  uint64_t v27 = 0;
LABEL_45:

  return v27;
}

  uint64_t v29 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v29, OS_LOG_TYPE_DEFAULT, "csr: unsupported signature algorithm", buf, 2u);
  }

  uint64_t v28 = 0LL;
LABEL_47:
  uint64_t v57 = a5;
  int v30 = (const __CFAllocator *)*MEMORY[0x189604DC8];
  uint64_t v27 = CFDataCreateWithBytesNoCopy( allocator,  *((const UInt8 **)&v66 + 1),  (unint64_t)v66 >> 3,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint64_t v31 = CFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)&v65[0] + 1), *(CFIndex *)&v65[0], v30);
  int v26 = v31;
  unint64_t v15 = 0LL;
  if (!v28 || !v27 || !v31) {
    goto LABEL_90;
  }
  if (!SecKeyVerifySignature(v19, v28, v31, v27, 0LL))
  {
    unint64_t v52 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v53 = "csr: failed to verify signature in CSR";
LABEL_109:
      _os_log_impl(&dword_1804F4000, v52, OS_LOG_TYPE_DEFAULT, v53, buf, 2u);
    }

void *SFSQLiteJournalSuffixes()
{
  return &unk_18969BFA0;
}

LABEL_7:
  secLogObjForScope("SecError");
  unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "SFAnalyticsSampler created without proper data", buf, 2u);
  }

LABEL_13:
  char v16 = 0LL;
LABEL_17:

  return v16;
}

  secLogObjForScope("SecError");
  unint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "SFAnalyticsSampler created without proper data", buf, 2u);
  }

LABEL_13:
  char v16 = 0LL;
LABEL_17:

  return v16;
}

  if ((_DWORD)v12)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v15);
    if (ThreadErrInfo) {
      *ThreadErrInfo = 0xFFFFE00200000000LL;
    }
  }

  else if (a3)
  {
    *a3 = dataOutMoved;
  }

  return v12;
}

  free(a1);
}

  uint64_t v9 = v6[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

      uint64_t v10 = [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607670] code:-26275 userInfo:0];
      if (!v10) {
        goto LABEL_12;
      }
      goto LABEL_8;
    }
  }

  if (!v10) {
    goto LABEL_7;
  }
LABEL_10:
  publicKey = self->_publicKey;
  if (publicKey)
  {
    self->_publicKey = 0LL;
    CFRelease(publicKey);
  }

    uint64_t v10 = 0LL;
    goto LABEL_8;
  }

  uint64_t v8 = *MEMORY[0x189604DB0];
  uint64_t v9 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x189604DB0], v6);
  uint64_t v10 = (__SecIdentity *)SecIdentityCreate(v8, v9, v5);
LABEL_6:

LABEL_8:
  return v10;
}

  uint64_t v8 = *MEMORY[0x189604DB0];
  uint64_t v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v3, v4);
  uint64_t v10 = SecKeyCreateFromPublicData(v8, 3LL, v9);
  CFRelease(v9);
  return v10;
}

  if ((a1 & 2) != 0)
  {
    add_ku(v5, 4);
    if ((a1 & 4) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if ((a1 & 4) != 0) {
LABEL_9:
  }
    add_ku(v5, 8);
LABEL_10:
  if ((a1 & 0x38) != 0) {
    add_ku(v5, 16);
  }
  if (a2) {
    CFDictionaryAddValue(v5, @"Email", a2);
  }
  add_eku(v5, 0LL);
  add_eku(v5, (const UInt8 *)&oidExtendedKeyUsageEmailProtection);
  CFDictionaryAddValue(v5, @"EmailProtectionEKU", (const void *)*MEMORY[0x189604DE8]);
  unint64_t v6 = CFArrayCreateMutable(0LL, 2LL, MEMORY[0x189605228]);
  char v7 = CFDateCreate(0LL, 670464000.0);
  uint64_t valuePtr = 0x4198690600000000LL;
  uint64_t v8 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
  CFArrayAppendValue(v6, v7);
  CFArrayAppendValue(v6, v8);
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = CFArrayCreateMutable(0LL, 1LL, MEMORY[0x189605228]);
  CFArrayAppendValue(v9, v6);
  if (v6) {
    CFRelease(v6);
  }
  CFDictionaryAddValue(v5, @"SystemTrustValidityPeriod", v9);
  if (v9) {
    CFRelease(v9);
  }
  if (SecPolicyAddStrongKeySizeOptions(v5) && SecPolicyRemoveWeakHashOptions(v5)) {
    uint64_t v10 = SecPolicyCreate(@"1.2.840.113635.100.1.8", @"SMIME", v5);
  }
  else {
    uint64_t v10 = 0LL;
  }
  CFRelease(v5);
  return v10;
}

  os_release(v4);
  os_activity_scope_leave(&state);
  return v5;
}

  os_release(v2);
  os_activity_scope_leave(&state);
  return v3;
}

void sub_180514FBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1805174D0(_Unwind_Exception *a1)
{
}

void LKAReportKeychainUpgradeOutcome(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  +[SFAnalytics logger](&OBJC_CLASS___LocalKeychainAnalytics, "logger");
  char v7 = (void *)objc_claimAutoreleasedReturnValue();
  [v7 reportKeychainUpgradeFrom:a1 to:a2 outcome:a3 error:0];

  objc_autoreleasePoolPop(v6);
}

void LKAReportKeychainUpgradeOutcomeWithError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (void *)MEMORY[0x186DFF9D0]();
  +[SFAnalytics logger](&OBJC_CLASS___LocalKeychainAnalytics, "logger");
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  [v9 reportKeychainUpgradeFrom:a1 to:a2 outcome:a3 error:a4];

  objc_autoreleasePoolPop(v8);
}

void LKABackupReportStart(int a1, int a2, char a3)
{
  if ((a3 & 1) != 0)
  {
    uint64_t v3 = 4LL;
  }

  else if (a1 && (a2 & 1) != 0)
  {
    uint64_t v3 = 3LL;
  }

  else
  {
    if (a2) {
      unsigned int v4 = 2;
    }
    else {
      unsigned int v4 = 0;
    }
    if (a1) {
      uint64_t v3 = 1LL;
    }
    else {
      uint64_t v3 = v4;
    }
  }

  uint64_t v5 = (void *)MEMORY[0x186DFF9D0]();
  +[SFAnalytics logger](&OBJC_CLASS___LocalKeychainAnalytics, "logger");
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  [v6 reportKeychainBackupStartWithType:v3];

  objc_autoreleasePoolPop(v5);
}

void LKABackupReportEnd(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (void *)MEMORY[0x186DFF9D0]();
  +[SFAnalytics logger](&OBJC_CLASS___LocalKeychainAnalytics, "logger");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  [v5 reportKeychainBackupEnd:a1 error:a2];

  objc_autoreleasePoolPop(v4);
}

void LKAForceClose()
{
  uint64_t v0 = (void *)MEMORY[0x186DFF9D0]();
  +[SFAnalytics logger](&OBJC_CLASS___LocalKeychainAnalytics, "logger");
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  [v1 removeState];

  objc_autoreleasePoolPop(v0);
}

unint64_t __sec_experiment_host_hash_block_invoke()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  v4.tv_sec = 0LL;
  v4.tv_nsec = 0LL;
  memset(uu, 0, sizeof(uu));
  unint64_t result = gethostuuid(uu, &v4);
  if ((_DWORD)result)
  {
    sec_experiment_host_hash_onceToken = 0LL;
  }

  else
  {
    uuid_unparse(uu, sec_experiment_host_hash_hostuuid);
    unint64_t result = strlen(sec_experiment_host_hash_hostuuid);
    if (result)
    {
      uint64_t v1 = 0LL;
      unsigned int v2 = 0;
      do
        unsigned int v2 = sec_experiment_host_hash_hostuuid[v1++] - v2 + 32 * v2;
      while (result > v1);
      unsigned int v3 = v2 % 0x65;
    }

    else
    {
      unsigned int v3 = 0;
    }

    sec_experiment_host_hash_hash = v3;
  }

  return result;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

SecExpConcrete_sec_experiment *sec_experiment_create(uint64_t a1)
{
  return -[SecExpConcrete_sec_experiment initWithName:]( objc_alloc(&OBJC_CLASS___SecExpConcrete_sec_experiment),  "initWithName:",  a1);
}

uint64_t sec_experiment_set_sampling_disabled(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) setSamplingDisabled:a2];
}

uint64_t sec_experiment_copy_configuration(void *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    unsigned int v3 = (void *)[v1 copyExperimentConfiguration];
    timespec v4 = v3;
    if (v3)
    {
      [v3 configurationData];
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
      if (([v2 isSamplingDisabled] & 1) != 0 || objc_msgSend(v4, "isSampled"))
      {
        uint64_t v6 = _CFXPCCreateXPCObjectFromCFObject();
      }

      else
      {
        sec_experiment_copy_log_handle();
        char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v8 = v7;
        if (v7 && os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          uint64_t v9 = [v2 name];
          id v10 = [v4 identifier];
          int v12 = 136446466;
          uint64_t v13 = v9;
          __int16 v14 = 2082;
          uint64_t v15 = [v10 UTF8String];
          _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_INFO,  "Configuration '%{public}s' for experiment '%{public}s' not sampled to run",  (uint8_t *)&v12,  0x16u);
        }

        uint64_t v6 = 0LL;
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

id sec_experiment_copy_log_handle()
{
  if (sec_experiment_copy_log_handle_onceToken != -1) {
    dispatch_once(&sec_experiment_copy_log_handle_onceToken, &__block_literal_global_156);
  }
  return (id)sec_experiment_copy_log_handle_experiment_log;
}

void __sec_experiment_copy_log_handle_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.security", "experiment");
  id v1 = (void *)sec_experiment_copy_log_handle_experiment_log;
  sec_experiment_copy_log_handle_experiment_log = (uint64_t)v0;
}

uint64_t sec_experiment_run_internal(void *a1, int a2, void *a3, void *a4, void *a5, int a6)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v11 = a1;
  int v12 = a3;
  id v13 = a4;
  id v14 = a5;
  if (v13)
  {
    uint64_t v15 = [v11 experimentIsAllowedForProcess];
    if ((v15 & 1) != 0)
    {
      uint64_t v27 = MEMORY[0x1895F87A8];
      uint64_t v28 = 3221225472LL;
      uint64_t v29 = __sec_experiment_run_internal_block_invoke;
      int v30 = &unk_189664D30;
      uint64_t v16 = (os_log_s *)v11;
      uint64_t v31 = v16;
      char v34 = a2;
      id v32 = v13;
      id v33 = v14;
      unint64_t v17 = (void (**)(void))_Block_copy(&v27);
      sec_experiment_copy_log_handle();
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = v18;
      if (!v12 || a6)
      {
        if (v18 && os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          uint64_t v24 = -[os_log_s name](v16, "name", v27, v28, v29, v30);
          uint64_t v25 = "enabled";
          if (a2) {
            uint64_t v25 = "disabled";
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v36 = v24;
          __int16 v37 = 2080;
          unint64_t v38 = v25;
          _os_log_impl( &dword_1804F4000,  v19,  OS_LOG_TYPE_INFO,  "Starting experiment '%s' synchronously with sampling %s",  buf,  0x16u);
        }

        v17[2](v17);
      }

      else
      {
        if (v18 && os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          uint64_t v20 = -[os_log_s name](v16, "name", v27, v28, v29, v30);
          unint64_t v21 = "enabled";
          if (a2) {
            unint64_t v21 = "disabled";
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v36 = v20;
          __int16 v37 = 2080;
          unint64_t v38 = v21;
          _os_log_impl( &dword_1804F4000,  v19,  OS_LOG_TYPE_INFO,  "Starting experiment '%s' asynchronously with sampling %s",  buf,  0x16u);
        }

        dispatch_async(v12, v17);
      }

      uint64_t v23 = v31;
    }

    else
    {
      sec_experiment_copy_log_handle();
      unint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v23 = v22;
      if (v22 && os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v23, OS_LOG_TYPE_INFO, "Not running experiments for disallowed process", buf, 2u);
      }
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  return v15;
}

void __sec_experiment_run_internal_block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v2 = [*(id *)(a1 + 32) isSamplingDisabledWithDefault:*(unsigned __int8 *)(a1 + 56)];
  objc_msgSend( *(id *)(*(void *)(a1 + 32) + 8),  "setSamplingDisabled:",  objc_msgSend(*(id *)(a1 + 32), "isSamplingDisabledWithDefault:", *(unsigned __int8 *)(a1 + 56)));
  unsigned int v3 = (void *)sec_experiment_copy_configuration(*(void **)(a1 + 32));
  uint64_t v4 = [*(id *)(a1 + 32) identifier];
  if (v3)
  {
    ++*(void *)(*(void *)(a1 + 32) + 16LL);
    if ((*(unsigned int (**)(void))(*(void *)(a1 + 40) + 16LL))())
    {
      ++*(void *)(*(void *)(a1 + 32) + 24LL);
      sec_experiment_copy_log_handle();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v6 = v5;
      if (!v5 || !os_log_type_enabled(v5, OS_LOG_TYPE_INFO)) {
        goto LABEL_17;
      }
      uint64_t v7 = [*(id *)(a1 + 32) name];
      int v16 = 136315394;
      uint64_t v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v7;
      uint64_t v8 = "Configuration '%s' for experiment '%s' succeeded";
    }

    else
    {
      sec_experiment_copy_log_handle();
      id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v6 = v14;
      if (!v14 || !os_log_type_enabled(v14, OS_LOG_TYPE_INFO)) {
        goto LABEL_17;
      }
      uint64_t v15 = [*(id *)(a1 + 32) name];
      int v16 = 136315394;
      uint64_t v17 = v4;
      __int16 v18 = 2080;
      uint64_t v19 = v15;
      uint64_t v8 = "Configuration '%s' for experiment '%s' failed";
    }

    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_INFO, v8, (uint8_t *)&v16, 0x16u);
LABEL_17:

    goto LABEL_18;
  }

  sec_experiment_copy_log_handle();
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  id v10 = v9;
  if (v9 && os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = [*(id *)(a1 + 32) name];
    int v12 = "enabled";
    int v16 = 136315650;
    uint64_t v17 = v4;
    __int16 v18 = 2080;
    if (v2) {
      int v12 = "disabled";
    }
    uint64_t v19 = v11;
    __int16 v20 = 2080;
    unint64_t v21 = v12;
    _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_INFO,  "Configuration '%s' for experiment '%s' not configured to run with sampling %s",  (uint8_t *)&v16,  0x20u);
  }

  uint64_t v13 = *(void *)(a1 + 48);
  if (v13) {
    (*(void (**)(uint64_t, uint64_t))(v13 + 16))(v13, [*(id *)(a1 + 32) identifier]);
  }
LABEL_18:
}

uint64_t sec_experiment_run(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = -[SecExpConcrete_sec_experiment initWithName:]( objc_alloc(&OBJC_CLASS___SecExpConcrete_sec_experiment),  "initWithName:",  a1);
  uint64_t v8 = v7;
  if (v7)
  {
    uint64_t v9 = sec_experiment_run_internal(v7, 0, 0LL, v5, v6, 1);
  }

  else
  {
    sec_experiment_copy_log_handle();
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v11 = v10;
    if (v10 && os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v13 = 136315138;
      uint64_t v14 = a1;
      _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v13, 0xCu);
    }

    uint64_t v9 = 0LL;
  }

  return v9;
}

uint64_t sec_experiment_run_async(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = -[SecExpConcrete_sec_experiment initWithName:]( objc_alloc(&OBJC_CLASS___SecExpConcrete_sec_experiment),  "initWithName:",  a1);
  uint64_t v11 = v10;
  if (v10)
  {
    uint64_t v12 = sec_experiment_run_internal(v10, 0, v7, v8, v9, 0);
  }

  else
  {
    sec_experiment_copy_log_handle();
    int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v14 = v13;
    if (v13 && os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v16 = 136315138;
      uint64_t v17 = a1;
      _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v16, 0xCu);
    }

    uint64_t v12 = 0LL;
  }

  return v12;
}

uint64_t sec_experiment_run_with_sampling_disabled(uint64_t a1, void *a2, void *a3, int a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v7 = a2;
  id v8 = a3;
  id v9 = -[SecExpConcrete_sec_experiment initWithName:]( objc_alloc(&OBJC_CLASS___SecExpConcrete_sec_experiment),  "initWithName:",  a1);
  id v10 = v9;
  if (v9)
  {
    uint64_t v11 = sec_experiment_run_internal(v9, a4, 0LL, v7, v8, 1);
  }

  else
  {
    sec_experiment_copy_log_handle();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    int v13 = v12;
    if (v12 && os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      int v15 = 136315138;
      uint64_t v16 = a1;
      _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v15, 0xCu);
    }

    uint64_t v11 = 0LL;
  }

  return v11;
}

uint64_t sec_experiment_run_async_with_sampling_disabled(uint64_t a1, void *a2, void *a3, void *a4, int a5)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  uint64_t v12 = -[SecExpConcrete_sec_experiment initWithName:]( objc_alloc(&OBJC_CLASS___SecExpConcrete_sec_experiment),  "initWithName:",  a1);
  int v13 = v12;
  if (v12)
  {
    uint64_t v14 = sec_experiment_run_internal(v12, a5, v9, v10, v11, 0);
  }

  else
  {
    sec_experiment_copy_log_handle();
    int v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v16 = v15;
    if (v15 && os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      int v18 = 136315138;
      uint64_t v19 = a1;
      _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v18, 0xCu);
    }

    uint64_t v14 = 0LL;
  }

  return v14;
}

id CKKSSetupControlProtocol(void *a1)
{
  id v1 = a1;
  if (CKKSSetupControlProtocol_onceToken != -1) {
    dispatch_once(&CKKSSetupControlProtocol_onceToken, &__block_literal_global_440);
  }
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcResetLocal_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcResetCloudKit_reason_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcResync_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcResyncLocal_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcStatus_fast_waitForNonTransientState_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcFetchAndProcessChanges_classA_onlyIfNoRecentFetch_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcPushOutgoingChanges_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcGetCKDeviceIDWithReply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_rpcCKMetric_attributes_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_proposeTLKForSEView_proposedTLK_wrappedOldTLK_tlkShares_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_fetchSEViewKeyHierarchy_forceFetch_reply_ argumentIndex:3 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_modifyTLKSharesForSEView_adding_deleting_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_deleteSEView_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_errClasses forSelector:sel_pcsMirrorKeysForServices_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_tlkShareArrayClasses forSelector:sel_proposeTLKForSEView_proposedTLK_wrappedOldTLK_tlkShares_reply_ argumentIndex:3 ofReply:0];
  [v1 setClasses:CKKSSetupControlProtocol_tlkArrayClasses forSelector:sel_fetchSEViewKeyHierarchy_forceFetch_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_tlkShareArrayClasses forSelector:sel_fetchSEViewKeyHierarchy_forceFetch_reply_ argumentIndex:2 ofReply:1];
  [v1 setClasses:CKKSSetupControlProtocol_tlkShareArrayClasses forSelector:sel_modifyTLKSharesForSEView_adding_deleting_reply_ argumentIndex:1 ofReply:0];
  [v1 setClasses:CKKSSetupControlProtocol_tlkShareArrayClasses forSelector:sel_modifyTLKSharesForSEView_adding_deleting_reply_ argumentIndex:2 ofReply:0];
  return v1;
}

void sub_1805199DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  if (a2 == 1)
  {
    id v9 = objc_begin_catch(exception_object);
    secLogObjForScope("SecError");
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(a9) = 138412290;
      *(void *)((char *)&a9 + 4) = v9;
      _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "CKKSSetupControlProtocol failed, continuing, but you might crash later: %@",  (uint8_t *)&a9,  0xCu);
    }

    objc_exception_throw(v9);
    __break(1u);
    JUMPOUT(0x180519A64LL);
  }

  _Unwind_Resume(exception_object);
}

void __CKKSSetupControlProtocol_block_invoke()
{
  v16[2] = *MEMORY[0x1895F89C0];
  if (initCloudKit_onceToken != -1) {
    dispatch_once(&initCloudKit_onceToken, &__block_literal_global_35);
  }
  os_log_t v0 = (void (*)(void))dlsym((void *)cloudKit, "CKAcceptableValueClasses");
  if (!v0)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "symbol %s is missing", "CKAcceptableValueClasses");
    abort();
  }

  id v1 = (void *)MEMORY[0x189603FE0];
  v0();
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = [v1 setWithSet:v2];
  uint64_t v4 = (void *)CKKSSetupControlProtocol_errClasses;
  CKKSSetupControlProtocol_errClasses = v3;

  id v5 = (void *)CKKSSetupControlProtocol_errClasses;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  [v5 unionSet:v6];

  id v7 = (void *)MEMORY[0x189604010];
  v16[0] = objc_opt_class();
  v16[1] = objc_opt_class();
  [MEMORY[0x189603F18] arrayWithObjects:v16 count:2];
  id v8 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v9 = [v7 setWithArray:v8];
  id v10 = (void *)CKKSSetupControlProtocol_tlkArrayClasses;
  CKKSSetupControlProtocol_tlkArrayClasses = v9;

  id v11 = (void *)MEMORY[0x189604010];
  v15[0] = objc_opt_class();
  v15[1] = objc_opt_class();
  [MEMORY[0x189603F18] arrayWithObjects:v15 count:2];
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v13 = [v11 setWithArray:v12];
  uint64_t v14 = (void *)CKKSSetupControlProtocol_tlkShareArrayClasses;
  CKKSSetupControlProtocol_tlkShareArrayClasses = v13;
}

void *__initCloudKit_block_invoke()
{
  unint64_t result = dlopen("/System/Library/Frameworks/CloudKit.framework/CloudKit", 1);
  cloudKit = (uint64_t)result;
  return result;
}

id _OctagonSignpostLogSystem()
{
  if (_OctagonSignpostLogSystem_onceToken != -1) {
    dispatch_once(&_OctagonSignpostLogSystem_onceToken, &__block_literal_global_559);
  }
  return (id)_OctagonSignpostLogSystem_log;
}

os_signpost_id_t _OctagonSignpostCreate(os_log_s *a1)
{
  os_signpost_id_t v1 = os_signpost_id_generate(a1);
  mach_continuous_time();
  return v1;
}

unint64_t _OctagonSignpostGetNanoseconds(uint64_t a1, uint64_t a2)
{
  if (_OctagonSignpostGetNanoseconds_onceToken != -1) {
    dispatch_once(&_OctagonSignpostGetNanoseconds_onceToken, &__block_literal_global_3);
  }
  uint64_t v3 = mach_continuous_time();
  LODWORD(v4) = _OctagonSignpostGetNanoseconds_timebase_info;
  LODWORD(v5) = *(_DWORD *)algn_18C5332FC;
  return (unint64_t)((double)v4 / (double)v5 * (double)(v3 - a2));
}

uint64_t SecFrameworkGetBundle()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecFrameworkGetBundle_block_invoke;
  block[3] = &__block_descriptor_tmp;
  block[4] = &SecFrameworkGetBundle_sSecFrameworkGetBundleSingleton;
  if (SecFrameworkGetBundle_sSecFrameworkGetBundleOnce != -1) {
    dispatch_once(&SecFrameworkGetBundle_sSecFrameworkGetBundleOnce, block);
  }
  return SecFrameworkGetBundle_sSecFrameworkGetBundleSingleton;
}

void __SecFrameworkGetBundle_block_invoke(uint64_t a1)
{
  int v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v3 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"/System/Library/Frameworks/Security.framework",  kCFURLPOSIXPathStyle,  1u);
  if (v3)
  {
    unint64_t v4 = v3;
    **(void **)(a1 + 32) = CFBundleCreate(v2, v3);
    CFRelease(v4);
  }

  else
  {
    **(void **)(a1 + 32) = 0LL;
  }

  CFRelease(@"/System/Library/Frameworks/Security.framework");
}

CFStringRef SecFrameworkCopyLocalizedString(const __CFString *a1, const __CFString *a2)
{
  Bundle = (__CFBundle *)SecFrameworkGetBundle();
  if (Bundle) {
    return CFBundleCopyLocalizedString(Bundle, a1, a1, a2);
  }
  if (a1) {
    CFRetain(a1);
  }
  return a1;
}

uint64_t SecFrameworkIsRunningInXcode()
{
  if (SecFrameworkIsRunningInXcode_envCheckOnce != -1) {
    dispatch_once(&SecFrameworkIsRunningInXcode_envCheckOnce, &__block_literal_global_728);
  }
  return SecFrameworkIsRunningInXcode_runningInXcode;
}

const char *__SecFrameworkIsRunningInXcode_block_invoke()
{
  unint64_t result = getenv("NSUnbufferedIO");
  if (result)
  {
    unint64_t result = (const char *)strcmp(result, "YES");
    if (!(_DWORD)result) {
      SecFrameworkIsRunningInXcode_runningInXcode = 1;
    }
  }

  return result;
}

uint64_t SecSecurityFixUpClientWithPersona(uint64_t result, uint64_t a2)
{
  __int128 v3 = *(_OWORD *)(result + 16);
  __int128 v2 = *(_OWORD *)(result + 32);
  __int128 v4 = *(_OWORD *)result;
  *(void *)(a2 + 48) = *(void *)(result + 48);
  *(_OWORD *)(a2 + 16) = v3;
  *(_OWORD *)(a2 + 32) = v2;
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 24) = 0LL;
  if (gSecurityd)
  {
    unint64_t v5 = *(uint64_t (**)(uint64_t))(gSecurityd + 688);
    if (v5) {
      return v5(a2);
    }
  }

  return result;
}

uint64_t SecSecuritySetMusrMode(char a1, int a2)
{
  BYTE4(xmmword_18C4872C8) = a1;
  DWORD1(xmmword_18C4872B8) = a2;
  uint64_t result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 36) = a1;
  *(_DWORD *)(result + 20) = a2;
  return result;
}

void __SecSecurityClientGet_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&gClient = 0LL;
  id v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v9 = CFArrayCreateForCFTypes((CFAllocatorRef)*MEMORY[0x189604DB0], a2, a3, a4, a5, a6, a7, a8, (uint64_t)@"sync");
  if (_os_feature_enabled_impl())
  {
    MutableCopy = CFArrayCreateMutableCopy(v8, 0LL, v9);
    CFArrayAppendValue(MutableCopy, @"com.apple.token");
    if (v9) {
      CFRelease(v9);
    }
  }

  else
  {
    MutableCopy = v9;
  }

  *((void *)&gClient + 1) = MutableCopy;
  LOWORD(xmmword_18C4872B8) = 1;
  WORD2(xmmword_18C4872C8) = 0;
  *((void *)&xmmword_18C4872B8 + 1) = 0LL;
  LOWORD(qword_18C4872D8) = 0;
  *((void *)&xmmword_18C4872C8 + 1) = 0LL;
}

CFArrayRef CFArrayCreateForCFTypes( CFAllocatorRef allocator, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v20 = &a9;
  CFIndex v10 = -1LL;
  do
  {
    id v11 = v20++;
    ++v10;
  }

  while (*v11);
  unint64_t v21 = (const void **)&a9;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, v10, MEMORY[0x189605228]);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v13 = Mutable;
  if (v10)
  {
    uint64_t v14 = (const void *)*MEMORY[0x189605018];
    do
    {
      int v15 = v21++;
      uint64_t v16 = *v15;
      if (v16) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v14;
      }
      CFArrayAppendValue(v13, v17);
      --v10;
    }

    while (v10);
  }

  CFArrayRef Copy = CFArrayCreateCopy(allocator, v13);
  CFRelease(v13);
  return Copy;
}

void SecSecuritySetPersonaMusr(const __CFString *a1)
{
  if (BYTE4(xmmword_18C4872C8)) {
    goto LABEL_8;
  }
  uint64_t v2 = SecSecurityClientGet();
  __int128 v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    *(void *)(v2 + 24) = 0LL;
    CFRelease(v3);
  }

  *(_BYTE *)(v2 + 48) = a1 != 0LL;
  if (a1)
  {
    __int128 v4 = CFUUIDCreateFromString(0LL, a1);
    if (v4)
    {
      unint64_t v5 = v4;
      CFUUIDBytes v6 = CFUUIDGetUUIDBytes(v4);
      CFRelease(v5);
      *(void *)(v2 + 24) = CFDataCreate(0LL, &v6.byte0, 16LL);
      return;
    }

uint64_t SecAccessGroupsGetCurrent()
{
  return *(void *)(SecSecurityClientGet() + 8);
}

void SecAccessGroupsSetCurrent(const void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (os_log_s *)secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412290;
    CFIndex v10 = a1;
    _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "SecAccessGroupsSetCurrent begin! Setting access groups: %@",  (uint8_t *)&v9,  0xCu);
  }

  SecSecurityClientGet();
  __int128 v3 = (os_log_s *)secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "SecAccessGroupsSetCurrent releasing gClient access groups",  (uint8_t *)&v9,  2u);
  }

  __int128 v4 = (const void *)*((void *)&gClient + 1);
  if (*((void *)&gClient + 1))
  {
    *((void *)&gClient + 1) = 0LL;
    CFRelease(v4);
  }

  unint64_t v5 = (os_log_s *)secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "SecAccessGroupsSetCurrent releasing threadLocalClient access groups",  (uint8_t *)&v9,  2u);
  }

  uint64_t v6 = threadLocalClient(&threadLocalClient);
  id v7 = *(const void **)(v6 + 8);
  if (v7)
  {
    *(void *)(v6 + 8) = 0LL;
    CFRelease(v7);
  }

  if (a1)
  {
    CFRetain(a1);
    *((void *)&gClient + 1) = a1;
    CFRetain(a1);
  }

  else
  {
    *((void *)&gClient + 1) = 0LL;
  }

  *(void *)(v6 + 8) = a1;
  id v8 = (os_log_s *)secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "SecAccessGroupsSetCurrent end!", (uint8_t *)&v9, 2u);
  }

uint64_t SecSecurityClientRegularToAppClip()
{
  BYTE5(xmmword_18C4872C8) = 1;
  uint64_t result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 37) = v1;
  return result;
}

uint64_t SecSecurityClientAppClipToRegular()
{
  BYTE5(xmmword_18C4872C8) = 0;
  uint64_t result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 37) = 0;
  return result;
}

void SecSecurityClientSetApplicationIdentifier(const void *a1)
{
  uint64_t v2 = (const void *)*((void *)&xmmword_18C4872C8 + 1);
  if (*((void *)&xmmword_18C4872C8 + 1))
  {
    *((void *)&xmmword_18C4872C8 + 1) = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = threadLocalClient(&threadLocalClient);
  __int128 v4 = *(const void **)(v3 + 40);
  if (v4)
  {
    *(void *)(v3 + 40) = 0LL;
    CFRelease(v4);
  }

  if (a1)
  {
    CFRetain(a1);
    *((void *)&xmmword_18C4872C8 + 1) = a1;
    CFRetain(a1);
  }

  else
  {
    *((void *)&xmmword_18C4872C8 + 1) = 0LL;
  }

  *(void *)(v3 + 40) = a1;
}

uint64_t SecSecurityClientSetKeychainSharingState(int a1)
{
  uint64_t result = SecSecurityClientGet();
  if (a1)
  {
    if (a1 != 1) {
      return result;
    }
    char v3 = 1;
  }

  else
  {
    char v3 = 0;
  }

  BYTE1(qword_18C4872D8) = v3;
  uint64_t result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 49) = v4;
  return result;
}

void SecServerSetTrustdMachServiceName(const char *a1)
{
  if (trustd_connection_once != -1) {
    dispatch_once(&trustd_connection_once, &__block_literal_global_33);
  }
  uint64_t v2 = (void *)sTrustdConnection;
  sTrustdConnection = (uint64_t)securityd_create_connection(a1, -1);
  if (v2) {
    xpc_release(v2);
  }
}

_xpc_connection_s *__trustd_connection_block_invoke()
{
  uint64_t result = securityd_create_connection("com.apple.trustd", -1);
  sTrustdConnection = (uint64_t)result;
  return result;
}

xpc_object_t security_fw_send_message_with_reply_sync_inner( xpc_object_t message, xpc_connection_t connection, unsigned int a3, CFTypeRef *a4)
{
  id v8 = 0LL;
  char v9 = 1;
  int v10 = -3;
  xpc_object_t v11 = (xpc_object_t)MEMORY[0x1895F9198];
  do
  {
    if ((v9 & 1) == 0) {
      xpc_release(v8);
    }
    xpc_object_t v12 = xpc_connection_send_message_with_reply_sync(connection, message);
    char v9 = 0;
    BOOL v13 = v12 != v11 || v10++ == 0;
    id v8 = v11;
  }

  while (!v13);
  xpc_object_t v15 = v12;
  _securityd_process_message_reply(&v15, a4, (uint64_t)connection, a3);
  return_securityd_connection_to_pool(a3, 0, connection);
  return v15;
}

CFMutableArrayRef ___securityd_connection_block_invoke()
{
  sSecuritydConnectionsCFIndex Count = 0;
  os_log_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  sSecuritydConnectionsQueue = (uint64_t)dispatch_queue_create("com.apple.security.securityd_connections", v0);
  CFMutableArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
  sSecuritydConnectionsPool = (uint64_t)result;
  return result;
}

_xpc_connection_s *__trustd_system_connection_block_invoke()
{
  CFMutableArrayRef result = securityd_create_connection("com.apple.trustd", -1);
  sTrustdSystemInstanceConnection = (uint64_t)result;
  return result;
}

uint64_t _SecSecuritydCopyWhoAmI(CFTypeRef *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  xpc_object_t message = securityd_create_message(0x5Eu, a1);
  if (!message) {
    return 0LL;
  }
  char v3 = message;
  uint64_t v4 = securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    unint64_t v5 = (void *)v4;
    uint64_t v6 = _CFXPCCreateCFObjectFromXPCObject();
    xpc_release(v5);
  }

  else
  {
    id v7 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (a1) {
        CFTypeRef v8 = *a1;
      }
      else {
        CFTypeRef v8 = 0LL;
      }
      int v10 = 138412290;
      CFTypeRef v11 = v8;
      _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "Securityd failed getting whoamid with error: %@",  (uint8_t *)&v10,  0xCu);
    }

    uint64_t v6 = 0LL;
  }

  xpc_release(v3);
  return v6;
}

BOOL _SecSyncBubbleTransfer(const __CFString *a1, unsigned int a2, CFTypeRef *a3)
{
  xpc_object_t message = securityd_create_message(0x5Fu, a3);
  if (!message) {
    return 0LL;
  }
  id v7 = message;
  xpc_dictionary_set_int64(message, "uid", a2);
  uint64_t v12 = (void *)securityd_message_with_reply_sync(v7, (uint64_t)a3);
  if (v12)
  {
    BOOL v13 = v12;
    BOOL v14 = xpc_dictionary_get_BOOL(v12, "status");
    if (!v14) {
      securityd_message_no_error((uint64_t)v13, (CFErrorRef *)a3);
    }
    xpc_release(v13);
  }

  else
  {
    BOOL v14 = 0LL;
  }

  xpc_release(v7);
  return v14;
}

BOOL _SecSystemKeychainTransfer(CFTypeRef *a1)
{
  xpc_object_t message = securityd_create_message(0x60u, a1);
  if (!message) {
    return 0LL;
  }
  char v3 = message;
  uint64_t v4 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    unint64_t v5 = v4;
    BOOL v6 = xpc_dictionary_get_BOOL(v4, "status");
    if (!v6) {
      securityd_message_no_error((uint64_t)v5, (CFErrorRef *)a1);
    }
    xpc_release(v5);
  }

  else
  {
    BOOL v6 = 0LL;
  }

  xpc_release(v3);
  return v6;
}

BOOL _SecSystemKeychainTranscrypt(CFTypeRef *a1)
{
  xpc_object_t message = securityd_create_message(0x61u, a1);
  if (!message) {
    return 0LL;
  }
  char v3 = message;
  uint64_t v4 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    unint64_t v5 = v4;
    BOOL v6 = xpc_dictionary_get_BOOL(v4, "status");
    if (!v6) {
      securityd_message_no_error((uint64_t)v5, (CFErrorRef *)a1);
    }
    xpc_release(v5);
  }

  else
  {
    BOOL v6 = 0LL;
  }

  xpc_release(v3);
  return v6;
}

BOOL _SecSyncDeleteUserViews(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message = securityd_create_message(0x63u, a2);
  if (!message) {
    return 0LL;
  }
  unint64_t v5 = message;
  xpc_dictionary_set_int64(message, "uid", a1);
  BOOL v6 = (void *)securityd_message_with_reply_sync(v5, (uint64_t)a2);
  if (v6)
  {
    id v7 = v6;
    BOOL v8 = xpc_dictionary_get_BOOL(v6, "status");
    if (!v8) {
      securityd_message_no_error((uint64_t)v7, (CFErrorRef *)a2);
    }
    xpc_release(v7);
  }

  else
  {
    BOOL v8 = 0LL;
  }

  xpc_release(v5);
  return v8;
}

void *_SecSecuritydCopyEndpoint(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  xpc_object_t message = securityd_create_message(a1, a2);
  if (message)
  {
    uint64_t v4 = message;
    unint64_t v5 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a2);
    if (!v5)
    {
      uint64_t v11 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          CFTypeRef v12 = *a2;
        }
        else {
          CFTypeRef v12 = 0LL;
        }
        int v14 = 138412290;
        CFTypeRef v15 = v12;
        _os_log_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEFAULT,  "Securityd failed getting endpoint with error: %@",  (uint8_t *)&v14,  0xCu);
      }

      BOOL v8 = 0LL;
      goto LABEL_20;
    }

    BOOL v6 = v5;
    xpc_object_t value = xpc_dictionary_get_value(v5, "endpoint");
    if (value)
    {
      BOOL v8 = value;
      if (MEMORY[0x186E0087C]() == MEMORY[0x1895F9260])
      {
        xpc_retain(v8);
        goto LABEL_16;
      }

      uint64_t v9 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        uint64_t v10 = "endpoint was not an endpoint";
LABEL_13:
        _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v14, 2u);
      }
    }

    else
    {
      uint64_t v9 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        uint64_t v10 = "endpoint was null";
        goto LABEL_13;
      }
    }

    BOOL v8 = 0LL;
LABEL_16:
    xpc_release(v6);
LABEL_20:
    xpc_release(v4);
    return v8;
  }

  return 0LL;
}

uint64_t _SecSecuritydCopyCKKSEndpoint()
{
  return 0LL;
}

void *_SecSecuritydCopyKeychainControlEndpoint(CFTypeRef *a1)
{
  return _SecSecuritydCopyEndpoint(0x72u, a1);
}

void *_SecSecuritydCopySFKeychainEndpoint(CFTypeRef *a1)
{
  return _SecSecuritydCopyEndpoint(0x71u, a1);
}

LABEL_36:
        goto LABEL_37;
      }

      uint64_t v9 = objc_alloc_init(&OBJC_CLASS___SECSFAActionTapToRadar);
      if (v9)
      {
        [v5 objectForKeyedSubscript:@"alert"];
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 objectForKeyedSubscript:@"componentID"];
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 objectForKeyedSubscript:@"componentName"];
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 objectForKeyedSubscript:@"componentVersion"];
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
        [v5 objectForKeyedSubscript:@"radarDescription"];
        unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  -[SECSFAActionAutomaticBugCapture setAlert:](v9, "setAlert:", v10);
                  -[SECSFAActionAutomaticBugCapture setComponentID:](v9, "setComponentID:", v11);
                  -[SECSFAActionAutomaticBugCapture setComponentName:](v9, "setComponentName:", v23);
                  -[SECSFAActionAutomaticBugCapture setComponentVersion:](v9, "setComponentVersion:", v22);
                  -[SECSFAActionAutomaticBugCapture setRadarDescription:](v9, "setRadarDescription:", v21);
                  -[SECSFAAction setTtr:](v6, "setTtr:", v9);

LABEL_29:
                  uint64_t v9 = v6;
                  goto LABEL_38;
                }
              }
            }
          }
        }

        if (a4)
        {
          CFTypeRef v15 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:9 description:@"attribute invalid type"];
          *a4 = v15;
        }

        goto LABEL_36;
      }

  return v30;
}

  public_key = make_public_key(v34, (uint64_t)v60 + 8, &v66, &error);
  if (!public_key)
  {
    __int128 v46 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v67 = 0;
      _os_log_impl(&dword_1804F4000, v46, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", v67, 2u);
    }

    goto LABEL_46;
  }

  __int16 v37 = public_key;
  *((void *)&v62 + 1) = nss_attributes_from_parameters_dict((uint64_t)v9, v49);
  SecCmsArraySortByDER(*((int8x16_t **)&v62 + 1), (uint64_t)&kSecAsn1AttributeTemplate, 0LL);
  uint64_t v55 = 0LL;
  char v56 = 0LL;
  if (!SEC_ASN1EncodeItem((uint64_t)v9, &v55, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
  {
    unint64_t v38 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v67 = 0;
      _os_log_impl(&dword_1804F4000, v38, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", v67, 2u);
    }
  }

  if (v49) {
    Value = CFDictionaryGetValue(v49, (const void *)kSecCMSSignHashAlgorithm);
  }
  else {
    Value = 0LL;
  }
  signature = make_signature(v56, v55, v50, Value, v63, (__CFString **)&error);
  if (signature)
  {
    __int128 v42 = signature;
    *((void *)&v64 + 1) = CFDataGetBytePtr(signature);
    *(void *)&unint64_t v64 = 8 * CFDataGetLength(v42);
    uint64_t v53 = 0LL;
    uint64_t v54 = 0LL;
    if (SEC_ASN1EncodeItem((uint64_t)v9, &v53, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestTemplate))
    {
      uint64_t v19 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v54, v53);
      goto LABEL_52;
    }

    unsigned int v48 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v67 = 0;
      _os_log_impl(&dword_1804F4000, v48, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", v67, 2u);
    }
  }

  else
  {
    __int128 v47 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v67 = 0;
      _os_log_impl(&dword_1804F4000, v47, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", v67, 2u);
    }

    __int128 v42 = 0LL;
  }

        uint64_t v36 = CFGetTypeID(Mutable);
        if (v36 == CFDataGetTypeID()) {
          CFDataSetLength(Mutable, length);
        }
        break;
      default:
        goto LABEL_39;
    }
  }

  if (Mutable == v18)
  {
LABEL_39:
    if (v18) {
      CFRelease(v18);
    }
    __int16 v37 = a1[1];
    if (SecKeyGetAlgorithmAdaptor_onceToken != -1) {
      dispatch_once(&SecKeyGetAlgorithmAdaptor_onceToken, &__block_literal_global_10414);
    }
    Value = (uint64_t (*)(uint64_t *, const __CFData *, const __CFData *, __CFString **))CFDictionaryGetValue( (CFDictionaryRef)SecKeyGetAlgorithmAdaptor_adaptors[v37],  v17);
    if (Value)
    {
      CFMutableArrayRef Mutable = (__CFData *)Value(a1, a2, a3, a4);
      if (Mutable != v18) {
        goto LABEL_53;
      }
    }

    else
    {
      if (_SECKEY_LOG_once_10415 != -1) {
        dispatch_once(&_SECKEY_LOG_once_10415, &__block_literal_global_270);
      }
      uint64_t v39 = (void *)_SECKEY_LOG_log_10416;
      if (os_log_type_enabled((os_log_t)_SECKEY_LOG_log_10416, OS_LOG_TYPE_DEBUG))
      {
        __int128 v42 = (const __CFDictionary *)SecKeyGetAlgorithmAdaptor_adaptors[v37];
        unint64_t v43 = v39;
        int v44 = CFDictionaryGetCount(v42);
        LODWORD(length) = 67109634;
        HIDWORD(length) = v37;
        uint64_t v50 = 2114;
        unint64_t v51 = v17;
        unint64_t v52 = 1024;
        uint64_t v53 = v44;
        _os_log_debug_impl( &dword_1804F4000,  v43,  OS_LOG_TYPE_DEBUG,  "failed to find adaptor: operation=%d, algorithm=%{public}@ (adaptors:%d)",  (uint8_t *)&length,  0x18u);
      }
    }

    goto LABEL_50;
  }

                      CFRelease(v4);
                      goto LABEL_37;
                    }

                    uint64_t v31 = (os_log_s *)secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_36;
                    }
                    *(_WORD *)__int128 buf = 0;
                    id v32 = "Failed to parse the current exceptions epoch as a uint64.";
                  }

                  else
                  {
                    uint64_t v31 = (os_log_s *)secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_36;
                    }
                    *(_WORD *)__int128 buf = 0;
                    id v32 = "Failed to get the exception's epoch.";
                  }
                }

                else
                {
                  uint64_t v31 = (os_log_s *)secLogObjForScope("SecError");
                  if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_36;
                  }
                  *(_WORD *)__int128 buf = 0;
                  id v32 = "Failed to get exception for epoch check.";
                }

                id v33 = v31;
                char v34 = 2;
LABEL_42:
                _os_log_impl(&dword_1804F4000, v33, OS_LOG_TYPE_DEFAULT, v32, buf, v34);
                goto LABEL_36;
              }
            }

            else if (v4)
            {
              goto LABEL_36;
            }

  Security::CodeSigning::SecStaticCode::reportProgress(v2);
}

LABEL_50:
            goto LABEL_51;
          }

          if (a5)
          {
            uint64_t v31 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:5 description:@"processName not string"];
            *a5 = v31;
            uint64_t v29 = 1;
            goto LABEL_50;
          }
        }

        uint64_t v29 = 1;
LABEL_51:

        uint64_t v10 = v48;
LABEL_52:

        if (v29)
        {
          id v33 = 0;
          BOOL v8 = v42;
          uint64_t v9 = v44;
          goto LABEL_77;
        }

        ++v11;
      }

      while (v49 != v11);
      id v32 = [v10 countByEnumeratingWithState:&v52 objects:v56 count:16];
      id v33 = 1;
      BOOL v8 = v42;
      uint64_t v9 = v44;
      int v49 = v32;
      if (!v32)
      {
LABEL_77:

        goto LABEL_78;
      }
    }
  }

  if (a5)
  {
    char v34 = [MEMORY[0x189607870] errorWithDomain:@"com.apple.SFAErrorDomain" code:1 description:@"rules key missing"];
    *a5 = v34;
  }

  id v33 = 0;
LABEL_78:

  return v33;
}

    unint64_t v43 = 0LL;
    goto LABEL_61;
  }

  char v3 = ccder_decode_tl();
  if (!v3)
  {
    secLogObjForScope("piggy");
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v10 = "Failed to parse CONS SEQ of ident";
      goto LABEL_15;
    }

    goto LABEL_50;
  }

  uint64_t v4 = v3;
  [MEMORY[0x189603FA8] array];
  unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v6 = v4 - 0x5555555555555556LL;
  id v7 = v4;
  do
  {
    *(void *)__int128 buf = 0LL;
    id v7 = piggy_decode_data(v7, v6, buf);
    BOOL v8 = *(id *)buf;
    uint64_t v9 = v8;
    if (!v7)
    {

      unint64_t v5 = 0LL;
      goto LABEL_17;
    }

    if (v8) {
      -[os_log_s addObject:](v5, "addObject:", v8);
    }
  }

  while (v7 != v6);
  if (v5) {
    [v2 setObject:v5 forKeyedSubscript:@"idents"];
  }
LABEL_17:
  uint64_t v11 = ccder_decode_tl();
  if (!v11)
  {
    secLogObjForScope("piggy");
    __int128 v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v42, OS_LOG_TYPE_DEFAULT, "Failed to parse CONS SEQ of TLKs", buf, 2u);
    }

    goto LABEL_50;
  }

  CFTypeRef v12 = v11;
  unsigned int v48 = a1;
  BOOL v13 = v11 - 0x5555555555555556LL;
  [MEMORY[0x189603FA8] array];
  int v49 = (void *)objc_claimAutoreleasedReturnValue();
  *(void *)&int v14 = 67109120LL;
  __int128 v46 = v14;
  __int128 v47 = v12;
  while (v12 != v13)
  {
    [MEMORY[0x189603FC8] dictionary];
    CFTypeRef v15 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v55 = 0LL;
    uint64_t v16 = ccder_decode_tl();
    if (!v16)
    {
      uint64_t v22 = 0LL;
LABEL_54:

LABEL_55:
      goto LABEL_56;
    }

    uint64_t v17 = v16 + v55;
    uint64_t v54 = 0LL;
    int v18 = piggy_decode_data(v16, v16 + v55, &v54);
    uint64_t v19 = v54;
    [v15 setObject:v19 forKeyedSubscript:@"v_Data"];

    uint64_t v53 = 0LL;
    uint64_t v20 = piggy_decode_data(v18, v17, &v53);
    unint64_t v21 = v53;
    uint64_t v22 = v21;
    if (!v20 || [v21 length] != 16) {
      goto LABEL_54;
    }
    uint64_t v23 = objc_alloc(MEMORY[0x189607AB8]);
    uint64_t v24 = v22;
    uint64_t v25 = (void *)objc_msgSend(v23, "initWithUUIDBytes:", objc_msgSend(v24, "bytes"));
    [v25 UUIDString];
    int v26 = (void *)objc_claimAutoreleasedReturnValue();

    [v15 setObject:v26 forKeyedSubscript:@"acct"];
    unint64_t v52 = 0LL;
    uint64_t v27 = ccder_decode_uint64();
    if (v27)
    {
      uint64_t v31 = v27;
      id v32 = @"Manatee";
      switch(v52)
      {
        case 1LL:
          goto LABEL_40;
        case 2LL:
          id v32 = @"Engram";
          goto LABEL_40;
        case 3LL:
          id v32 = @"AutoUnlock";
          goto LABEL_40;
        case 4LL:
          id v32 = @"Health";
          goto LABEL_40;
        default:
          secLogObjForScope("piggy");
          unint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          *(_DWORD *)__int128 buf = v46;
          *(_DWORD *)&uint8_t buf[4] = v52;
          uint64_t v36 = buf;
          __int16 v37 = v35;
          unint64_t v38 = "unexpected view number: %d";
          uint64_t v39 = 8;
          break;
      }

      goto LABEL_36;
    }

    *(void *)__int128 buf = 0LL;
    CFTypeRef cf = 0LL;
    id v33 = der_decode_string(0LL, (CFStringRef *)&cf, (CFTypeRef *)buf, v20, v17, v28, v29, v30);
    id v32 = (__CFString *)cf;
    if (v33 && cf)
    {
      uint64_t v31 = (uint64_t)v33;
      char v34 = *(const void **)buf;
      if (*(void *)buf)
      {
        *(void *)__int128 buf = 0LL;
        CFRelease(v34);
      }

  uint64_t v31 = sec_asn1d_push_state(*a1, (uint64_t)v29, v25, 0);
  a1 = v31;
  if (v31)
  {
    *((_BYTE *)v31 + 136) = v24;
    if ((v8 & 0xC0) != 0 && (v8 & 0x4000) == 0)
    {
      uint64_t v23 = *(_DWORD *)v31[1] & 0xFFFBFFFF;
LABEL_54:
      if ((v8 & 0x8400) != 0)
      {
        id v32 = 0;
        id v33 = 0LL;
        char v34 = 0LL;
        if ((v8 & 0x8000) != 0) {
          a1[2] = 0LL;
        }
      }

      else
      {
        id v32 = v8 & 0xE0;
        char v34 = v8 & 0x1F;
        unint64_t v35 = 1LL << (v23 & 0x1F);
        uint64_t v36 = v8 & 0xC0 | 0x20;
        if ((v35 & 0x30000) == 0) {
          uint64_t v36 = v8 & 0xE0;
        }
        __int16 v37 = (v35 & 0x55D81018) == 0;
        if ((v35 & 0x55D81018) != 0) {
          unint64_t v38 = v8 & 0xE0;
        }
        else {
          unint64_t v38 = v36;
        }
        if (v37) {
          uint64_t v39 = 255LL;
        }
        else {
          uint64_t v39 = 223LL;
        }
        if ((v23 & 0x1F) == 0x1F)
        {
          id v33 = 255LL;
        }

        else
        {
          id v32 = v38;
          id v33 = v39;
        }
      }

      a1[7] = v33;
      *((_BYTE *)a1 + 53) = v32;
      a1[9] = v34;
      a1[10] = v23;
      *((_BYTE *)a1 + 138) = v19 >> 9;
      *((_BYTE *)a1 + 141) = v20;
      *((_DWORD *)a1 + 12) = 0;
      *((_BYTE *)a1 + 137) = 0;
      *(_WORD *)((char *)a1 + 139) = 0;
      return a1;
    }

    inited = sec_asn1d_init_state_based_on_template(v31, a2, a3);
    a1 = (void *)inited;
    if (inited) {
      *(_BYTE *)(inited + 141) = v20;
    }
  }

  return a1;
}

      appendRelabeledProperty(a1, @"Notice Numbers", 0LL, (uint64_t)&v38, @"Invalid %@", a3);
      uint64_t v4 = v15;
LABEL_51:
      a2 = v34;
      if (*((void *)&v40 + 1)) {
LABEL_52:
      }
        appendDERThingProperty(a1, @"Explicit Text", 0LL, (unsigned __int8 **)&v40, a3);
    }
  }

  if (v8 != 1) {
    goto LABEL_63;
  }
}

    if (a1[3])
    {
      CFMutableArrayRef Mutable = (__CFData *)*MEMORY[0x189605018];
    }

    else
    {
      int v40 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], 0LL);
      SecError(-50, a4, @"%@: algorithm not supported by the key %@", v40, *a1);
      CFMutableArrayRef Mutable = 0LL;
    }

    goto LABEL_53;
  }

                        CFRelease(v4);
                        LOBYTE(trust) = 1;
                        return (char)trust;
                      }

                      int v40 = (os_log_s *)secLogObjForScope("SecError");
                      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)__int128 buf = 134218240;
                        *(void *)&uint8_t buf[4] = valuePtr;
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = ExceptionResetCount;
                        id v32 = "The current exception's epoch (%llu) is not the current epoch. (%llu)";
                        id v33 = v40;
                        char v34 = 22;
                        goto LABEL_42;
                      }

void sub_18051FD2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __Block_byref_object_copy__807(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__808(uint64_t a1)
{
}

id SecEscrowRequestSetupControlProtocol(void *a1)
{
  id v1 = a1;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  [v1 setClasses:v2 forSelector:sel_triggerEscrowUpdate_options_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_cachePrerecord_serializedPrerecord_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchPrerecord_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchRequestWaitingOnPasscode_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchRequestStatuses_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_resetAllRequests_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_storePrerecordsInEscrow_ argumentIndex:1 ofReply:1];

  return v1;
}

CFURLRef SecCopyHomeURL()
{
  uint64_t v0 = sCustomHomeURL;
  if (!sCustomHomeURL) {
    return CFCopyHomeDirectoryURL();
  }
  CFRetain((CFTypeRef)sCustomHomeURL);
  return (CFURLRef)v0;
}

CFURLRef SecCopyBaseFilesURL(int a1)
{
  uint64_t v1 = sCustomHomeURL;
  if (sCustomHomeURL)
  {
    CFRetain((CFTypeRef)sCustomHomeURL);
    return (CFURLRef)v1;
  }

  else if (a1)
  {
    return CFURLCreateWithFileSystemPath(0LL, @"/", kCFURLPOSIXPathStyle, 1u);
  }

  else
  {
    return SecCopyHomeURL();
  }

CFTypeRef SecSetCustomHomeURL(CFTypeRef cf)
{
  uint64_t v1 = (uint64_t)cf;
  if (cf) {
    CFTypeRef cf = CFRetain(cf);
  }
  sCustomHomeURL = v1;
  return cf;
}

void SecSetCustomHomeURLString(CFStringRef filePath)
{
  uint64_t v2 = (const void *)sCustomHomeURL;
  if (sCustomHomeURL)
  {
    sCustomHomeURL = 0LL;
    CFRelease(v2);
  }

  if (filePath) {
    sCustomHomeURL = (uint64_t)CFURLCreateWithFileSystemPath(0LL, filePath, kCFURLPOSIXPathStyle, 1u);
  }
}

BOOL SECSFAActionDropEventReadFrom(uint64_t a1, uint64_t a2)
{
  char v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int *)MEMORY[0x189611CE8];
  unint64_t v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    id v7 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0LL;
        *(_BYTE *)(a1 + 12) |= 2u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1LL || v21 >= *(void *)(a2 + *v4))
          {
            uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
            goto LABEL_38;
          }

          char v22 = *(_BYTE *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            break;
          }
          v17 += 7;
          BOOL v23 = v18++ > 8;
          if (v23)
          {
            uint64_t v19 = 0LL;
            uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
            goto LABEL_41;
          }
        }

        uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
LABEL_39:
        if (*(_BYTE *)(a2 + *v5)) {
          uint64_t v19 = 0LL;
        }
LABEL_41:
        *(_BYTE *)(a1 + *v24) = v19 != 0;
        goto LABEL_42;
      }

      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0LL;
      }
LABEL_42:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
    }

    char v25 = 0;
    unsigned int v26 = 0;
    uint64_t v19 = 0LL;
    *(_BYTE *)(a1 + 12) |= 1u;
    while (1)
    {
      uint64_t v27 = *v3;
      unint64_t v28 = *(void *)(a2 + v27);
      if (v28 == -1LL || v28 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v29 = *(_BYTE *)(*(void *)(a2 + *v7) + v28);
      *(void *)(a2 + v27) = v28 + 1;
      v19 |= (unint64_t)(v29 & 0x7F) << v25;
      if ((v29 & 0x80) == 0)
      {
        uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
        goto LABEL_39;
      }

      v25 += 7;
      BOOL v23 = v26++ > 8;
      if (v23)
      {
        uint64_t v19 = 0LL;
        uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
        goto LABEL_41;
      }
    }

    uint64_t v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
LABEL_38:
    *(_BYTE *)(a2 + *v5) = 1;
    goto LABEL_39;
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t OctagonIsSOSFeatureEnabled()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (OctagonSOSFeatureIsEnabledOverrideSet == 1)
  {
    secLogObjForScope("octagon");
    uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      if (OctagonSOSFeatureIsEnabledOverride) {
        uint64_t v1 = @"enabled";
      }
      else {
        uint64_t v1 = @"disabled";
      }
      int v4 = 138412290;
      unint64_t v5 = v1;
      _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "SOS Feature is %@ (overridden)", (uint8_t *)&v4, 0xCu);
    }

    uint64_t v2 = &OctagonSOSFeatureIsEnabledOverride;
  }

  else
  {
    if (OctagonIsSOSFeatureEnabled_onceToken != -1) {
      dispatch_once(&OctagonIsSOSFeatureEnabled_onceToken, &__block_literal_global_1189);
    }
    uint64_t v2 = &OctagonIsSOSFeatureEnabled_sosEnabled;
  }

  return *v2;
}

void __OctagonIsSOSFeatureEnabled_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  OctagonIsSOSFeatureEnabled_sosEnabled = _os_feature_enabled_impl();
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    if (OctagonIsSOSFeatureEnabled_sosEnabled) {
      uint64_t v1 = @"enabled";
    }
    else {
      uint64_t v1 = @"disabled";
    }
    int v2 = 138412290;
    char v3 = v1;
    _os_log_impl( &dword_1804F4000,  v0,  OS_LOG_TYPE_DEFAULT,  "SOS Feature is %@ (via feature flags)",  (uint8_t *)&v2,  0xCu);
  }
}

uint64_t OctagonSetSOSFeatureEnabled(uint64_t result)
{
  OctagonSOSFeatureIsEnabledOverrideSet = 1;
  OctagonSOSFeatureIsEnabledOverride = result;
  return result;
}

BOOL OctagonSupportsPersonaMultiuser()
{
  if (gOctagonSupportsPersonaMultiuserStatus) {
    return gOctagonSupportsPersonaMultiuserStatus == 1;
  }
  if (OctagonSupportsPersonaMultiuser_onceToken != -1) {
    dispatch_once(&OctagonSupportsPersonaMultiuser_onceToken, &__block_literal_global_26);
  }
  return OctagonSupportsPersonaMultiuser_ffOctagonSupportsPersonaMultiuserStatus != 0;
}

void __OctagonSupportsPersonaMultiuser_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  OctagonSupportsPersonaMultiuser_ffOctagonSupportsPersonaMultiuserStatus = _os_feature_enabled_impl();
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    if (OctagonSupportsPersonaMultiuser_ffOctagonSupportsPersonaMultiuserStatus) {
      uint64_t v1 = "enabled";
    }
    else {
      uint64_t v1 = "disabled";
    }
    int v2 = 136315138;
    char v3 = v1;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser is %s", (uint8_t *)&v2, 0xCu);
  }
}

void OctagonSetSupportsPersonaMultiuser(int a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  gOctagonSupportsPersonaMultiuserStatus = v2;
  secLogObjForScope("octagon");
  char v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "disabled";
    if (a1) {
      uint64_t v4 = "enabled";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "OctagonSupportsMultiuser overridden to %s",  (uint8_t *)&v5,  0xCu);
  }
}

void OctagonClearSupportsPersonaMultiuserOverride()
{
  gOctagonSupportsPersonaMultiuserStatus = 0;
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser override removed", v1, 2u);
  }
}

BOOL SOSCompatibilityModeEnabled()
{
  if (gDeferSOSFromSignInStatus) {
    return gDeferSOSFromSignInStatus == 1;
  }
  if (SOSCompatibilityModeEnabled_onceToken != -1) {
    dispatch_once(&SOSCompatibilityModeEnabled_onceToken, &__block_literal_global_30);
  }
  return SOSCompatibilityModeEnabled_ffDeferSOSFromSignInStatus != 0;
}

void __SOSCompatibilityModeEnabled_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  SOSCompatibilityModeEnabled_ffDeferSOSFromSignInStatus = _os_feature_enabled_impl();
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    if (SOSCompatibilityModeEnabled_ffDeferSOSFromSignInStatus) {
      uint64_t v1 = "enabled";
    }
    else {
      uint64_t v1 = "disabled";
    }
    int v2 = 136315138;
    char v3 = v1;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn is %s", (uint8_t *)&v2, 0xCu);
  }
}

void SetSOSCompatibilityMode(int a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  gDeferSOSFromSignInStatus = v2;
  secLogObjForScope("octagon");
  char v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "disabled";
    if (a1) {
      uint64_t v4 = "enabled";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn overridden to %s", (uint8_t *)&v5, 0xCu);
  }
}

void ClearSOSCompatibilityModeOverride()
{
  gDeferSOSFromSignInStatus = 0;
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn override removed", v1, 2u);
  }
}

BOOL IsRollOctagonIdentityEnabled()
{
  if (gRollOctagonIdentityEnabled) {
    return gRollOctagonIdentityEnabled == 1;
  }
  if (IsRollOctagonIdentityEnabled_onceToken != -1) {
    dispatch_once(&IsRollOctagonIdentityEnabled_onceToken, &__block_literal_global_33_1205);
  }
  return IsRollOctagonIdentityEnabled_ffRollOctagonIdentityEnabled != 0;
}

void __IsRollOctagonIdentityEnabled_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  IsRollOctagonIdentityEnabled_ffRollOctagonIdentityEnabled = _os_feature_enabled_impl();
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    if (IsRollOctagonIdentityEnabled_ffRollOctagonIdentityEnabled) {
      uint64_t v1 = "enabled";
    }
    else {
      uint64_t v1 = "disabled";
    }
    int v2 = 136315138;
    char v3 = v1;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "RollIdentityOnMIDRotation is %s", (uint8_t *)&v2, 0xCu);
  }
}

void SetRollOctagonIdentityEnabled(int a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  gRollOctagonIdentityEnabled = v2;
  secLogObjForScope("octagon");
  char v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "disabled";
    if (a1) {
      uint64_t v4 = "enabled";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "RollIdentityOnMIDRotation overridden to %s",  (uint8_t *)&v5,  0xCu);
  }
}

void ClearRollOctagonIdentityEnabledOverride()
{
  gRollOctagonIdentityEnabled = 0;
  secLogObjForScope("octagon");
  uint64_t v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEFAULT, "RollIdentityOnMIDRotation override removed", v1, 2u);
  }
}

void sub_1805241F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1805242F4(_Unwind_Exception *a1)
{
}

void sub_1805243EC(_Unwind_Exception *a1)
{
}

void sub_180524518(_Unwind_Exception *a1)
{
}

void sub_1805246E8(_Unwind_Exception *a1)
{
}

void sub_180524750( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_180524B0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id obj)
{
}

uint64_t NtlmGeneratorCreate(int a1, void *a2)
{
  uint64_t v4 = malloc(0xCuLL);
  if (!v4) {
    return 4294967188LL;
  }
  int v5 = v4;
  uint64_t result = 0LL;
  v5[1] = 0;
  void v5[2] = 0;
  _DWORD *v5 = a1;
  *a2 = v5;
  return result;
}

void NtlmGeneratorRelease(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t NtlmCreateClientRequest(_DWORD *a1, __CFData **a2)
{
  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  if (!Mutable) {
    return 4294967188LL;
  }
  int v5 = Mutable;
  CFDataAppendBytes(Mutable, (const UInt8 *)"NTLMSSP", 8LL);
  LODWORD(bytes) = 1;
  CFDataAppendBytes(v5, (const UInt8 *)&bytes, 4LL);
  if ((*a1 & 2) != 0) {
    int v6 = 557575;
  }
  else {
    int v6 = 33287;
  }
  a1[2] = v6;
  LODWORD(bytes) = v6;
  CFDataAppendBytes(v5, (const UInt8 *)&bytes, 4LL);
  appendSecBuf(v5, 0, &bytes);
  appendSecBuf(v5, 0, &bytes);
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t NtlmCreateClientResponse( uint64_t a1, const __CFData *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, __CFData **a6)
{
  CFTypeRef v15 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t PasswordHashes = _NtlmGeneratePasswordHashes( (const __CFAllocator *)*MEMORY[0x189604DB0],  a5,  (CFDataRef *)&cf,  (CFDataRef *)&v15);
  CFTypeRef v13 = cf;
  if ((_DWORD)PasswordHashes)
  {
    if (!cf) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  uint64_t PasswordHashes = _NtlmCreateClientResponse(a1, a2, a3, a4, (const __CFData *)cf, v11, a6);
  if (v13) {
LABEL_3:
  }
    CFRelease(v13);
LABEL_4:
  if (v15) {
    CFRelease(v15);
  }
  return PasswordHashes;
}

uint64_t _NtlmGeneratePasswordHashes( const __CFAllocator *a1, const __CFString *a2, CFDataRef *a3, CFDataRef *a4)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  memset(md, 170, sizeof(md));
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  int v14 = -1431655766;
  uint64_t v7 = ntlmStringToLE(a2, &v15, &v14);
  if ((_DWORD)v7) {
    return v7;
  }
  unsigned int v9 = (void *)v15;
  CC_LONG v10 = v14;
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&c.data[13] = v11;
  *(_OWORD *)&c.data[6] = v11;
  *(_OWORD *)&c.data[10] = v11;
  *(_OWORD *)&c.Nl = v11;
  *(_OWORD *)&c.data[2] = v11;
  *(_OWORD *)&c.A = v11;
  CC_MD4_Init(&c);
  CC_MD4_Update(&c, v9, v10);
  CC_MD4_Final(md, &c);
  free(v9);
  CFDataRef v12 = CFDataCreate(a1, md, 16LL);
  *a3 = v12;
  memset(md, 0, sizeof(md));
  if (v12) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = 4294967188LL;
  }
  *a4 = CFDataCreate(0LL, _NtlmGeneratePasswordHashes_zero, 16LL);
  return v8;
}

uint64_t _NtlmCreateClientResponse( uint64_t a1, CFDataRef theData, const __CFString *a3, const __CFString *a4, const __CFData *a5, uint64_t a6, __CFData **a7)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  memset(dataOut, 170, sizeof(dataOut));
  char v56 = 0LL;
  unsigned int v55 = 0;
  uint64_t v53 = 0LL;
  unsigned int v52 = 0;
  uint64_t v50 = 0LL;
  unsigned int v49 = 0;
  v63[0] = (uint8x8_t)0xAAAAAAAAAAAAAAAALL;
  v63[1] = (uint8x8_t)0xAAAAAAAAAAAAAAAALL;
  if (!theData) {
    return 4294967246LL;
  }
  unsigned int v13 = CFDataGetLength(theData);
  if (v13 < 0x20) {
    return 4294967246LL;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (*(void *)BytePtr != 0x5053534D4C544ELL) {
    return 4294967246LL;
  }
  if (*((_DWORD *)BytePtr + 2) != 2) {
    return 4294967246LL;
  }
  CFIndex v57 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v58 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v54 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v51 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v48 = 0xAAAAAAAAAAAAAAAALL;
  int v17 = *((_DWORD *)BytePtr + 5);
  dataOut[6] = *((void *)BytePtr + 3);
  if ((v13 & 0xFFFFFFF0) >= 0x30uLL)
  {
    size_t v19 = *((unsigned __int16 *)BytePtr + 20);
    uint64_t v20 = *((unsigned int *)BytePtr + 11);
    unint64_t v21 = &BytePtr[v20];
    uint64_t v18 = malloc(*((unsigned __int16 *)BytePtr + 20));
    memmove(v18, v21, v19);
  }

  else
  {
    uint64_t v18 = 0LL;
    LODWORD(v19) = 0;
  }

  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  if (!Mutable) {
    goto LABEL_23;
  }
  if (a3)
  {
    MutableCFArrayRef Copy = CFStringCreateMutableCopy(0LL, 0LL, a3);
    a3 = MutableCopy;
    if (MutableCopy)
    {
      CFStringUppercase(MutableCopy, 0LL);
      goto LABEL_16;
    }

uint64_t NtlmGetNegotiatedVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

void sub_180525D70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1805261B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805262C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805263C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805264C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805265DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805266F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526814( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526930( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526A4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526B68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526C84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526DA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526EBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180526FCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805270CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180527184( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_18052722C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_18052732C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_18052742C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_18052752C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1805276C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state)
{
}

void sub_180527870( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state)
{
}

id KCSharingSetupServerProtocol(void *a1)
{
  v7[11] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  char v3 = (void *)MEMORY[0x189604010];
  v7[0] = objc_opt_class();
  v7[1] = objc_opt_class();
  void v7[2] = objc_opt_class();
  v7[3] = objc_opt_class();
  _OWORD v7[4] = objc_opt_class();
  v7[5] = objc_opt_class();
  void v7[6] = objc_opt_class();
  v7[7] = objc_opt_class();
  v7[8] = objc_opt_class();
  v7[9] = objc_opt_class();
  v7[10] = objc_opt_class();
  [MEMORY[0x189603F18] arrayWithObjects:v7 count:11];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setWithArray:v4];
  int v5 = (void *)objc_claimAutoreleasedReturnValue();

  [v1 setClasses:v2 forSelector:sel_provisionWithReply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setChangeTrackingEnabled_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchRemoteChangesWithReply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_saveLocalChangesWithReply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_getGroupByGroupID_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_wipe_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_getGroupsWithRequest_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_getGroupsWithRequest_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_createGroupWithRequest_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_createGroupWithRequest_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_updateGroupWithRequest_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_updateGroupWithRequest_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_leaveGroupWithRequest_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v2 forSelector:sel_leaveGroupWithRequest_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_deleteGroupWithRequest_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v2 forSelector:sel_deleteGroupWithRequest_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_acceptInviteForGroupID_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_declineInviteForGroupID_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_checkAvailabilityForHandles_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v5 forSelector:sel_checkAvailabilityForHandles_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_checkAvailabilityForHandles_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_verifyGroupsInSyncWithCompletion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_performMaintenanceWithCompletion_ argumentIndex:0 ofReply:1];

  return v1;
}

id KCSharingSetupInvitationNotificationProtocol(void *a1)
{
  v6[1] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  int v2 = (void *)MEMORY[0x189604010];
  v6[0] = objc_opt_class();
  [MEMORY[0x189603F18] arrayWithObjects:v6 count:1];
  char v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setWithArray:v3];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();

  [v1 setClasses:v4 forSelector:sel_receivedGroupInvitation_ argumentIndex:0 ofReply:0];
  return v1;
}

uint64_t SECSFAActionReadFrom(uint64_t a1, uint64_t a2)
{
  char v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int *)MEMORY[0x189611CE8];
  int v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    uint64_t v7 = (int *)MEMORY[0x189611CD8];
    do
    {
      if (*(_BYTE *)(a2 + *v5)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((int)(v10 >> 3) <= 99)
      {
        if ((_DWORD)v17)
        {
          if ((_DWORD)v17 != 1)
          {
LABEL_41:
            uint64_t result = PBReaderSkipValueWithTag();
            if (!(_DWORD)result) {
              return result;
            }
            continue;
          }

          uint64_t v19 = PBReaderReadString();
          uint64_t v20 = *(void **)(a1 + 32);
          *(void *)(a1 + 32) = v19;
        }

        else
        {
          unsigned int v21 = 0;
          while (1)
          {
            uint64_t v22 = *v3;
            unint64_t v23 = *(void *)(a2 + v22);
            if (v23 == -1LL || v23 >= *(void *)(a2 + *v4)) {
              break;
            }
            unint64_t v24 = v23 + 1;
            int v25 = *(char *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v24;
            if (v25 < 0 && v21++ <= 8) {
              continue;
            }
            goto LABEL_44;
          }

          *(_BYTE *)(a2 + *v5) = 1;
        }
      }

      else
      {
        switch((_DWORD)v17)
        {
          case 'd':
            [(id)a1 clearOneofValuesForAction];
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 1;
            uint64_t v18 = objc_alloc_init(&OBJC_CLASS___SECSFAActionTapToRadar);
            objc_storeStrong((id *)(a1 + 40), v18);
            if (!PBReaderPlaceMark() || !SECSFAActionTapToRadarReadFrom((uint64_t)v18, a2))
            {
LABEL_46:

              return 0LL;
            }

            break;
          case 'e':
            [(id)a1 clearOneofValuesForAction];
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 2;
            uint64_t v18 = objc_alloc_init(&OBJC_CLASS___SECSFAActionAutomaticBugCapture);
            objc_storeStrong((id *)(a1 + 8), v18);
            break;
          case 'f':
            [(id)a1 clearOneofValuesForAction];
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 3;
            uint64_t v18 = objc_alloc_init(&OBJC_CLASS___SECSFAActionDropEvent);
            objc_storeStrong((id *)(a1 + 24), v18);
            break;
          default:
            goto LABEL_41;
        }

        PBReaderRecallMark();
      }

void sub_18052985C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  if (a2 == 1)
  {
    id v9 = objc_begin_catch(exception_object);
    secLogObjForScope("SecError");
    unint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(a9) = 138412290;
      *(void *)((char *)&a9 + 4) = v9;
      _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "Could not configure SecuritydXPCProtocol: %@",  (uint8_t *)&a9,  0xCu);
    }

    objc_exception_throw(v9);
    __break(1u);
    JUMPOUT(0x1805298ECLL);
  }

  _Unwind_Resume(exception_object);
}

id SecuritydXPCProxyObject(uint64_t a1, void *a2)
{
  v12[1] = *MEMORY[0x1895F89C0];
  char v3 = a2;
  if (gSecurityd && (uint64_t v4 = *(void **)(gSecurityd + 696)) != 0LL)
  {
    id v5 = v4;
  }

  else
  {
    if (SecuritydXPCProxyObject_onceToken != -1) {
      dispatch_once(&SecuritydXPCProxyObject_onceToken, &__block_literal_global_1691);
    }
    if (!SecuritydXPCProxyObject_rpc)
    {
      uint64_t v7 = (void *)MEMORY[0x189607870];
      uint64_t v11 = *MEMORY[0x1896075E0];
      v12[0] = @"Could not create SecuritydXPCClient";
      [MEMORY[0x189603F68] dictionaryWithObjects:v12 forKeys:&v11 count:1];
      char v8 = (void *)objc_claimAutoreleasedReturnValue();
      [v7 errorWithDomain:@"securityd" code:-1 userInfo:v8];
      id v9 = (void *)objc_claimAutoreleasedReturnValue();
      v3[2](v3, v9);

      int v6 = 0LL;
      goto LABEL_10;
    }

    [(id)SecuritydXPCProxyObject_rpc protocolWithSync:a1 errorHandler:v3];
    id v5 = (id)objc_claimAutoreleasedReturnValue();
  }

  int v6 = v5;
LABEL_10:

  return v6;
}

void __SecuritydXPCProxyObject_block_invoke()
{
  uint64_t v0 = objc_alloc_init(&OBJC_CLASS___SecuritydXPCClient);
  id v1 = (void *)SecuritydXPCProxyObject_rpc;
  SecuritydXPCProxyObject_rpCC_MD4_CTX c = (uint64_t)v0;
}

BOOL SecKeychainIsStaticPersistentRefsEnabled()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (SecKeychainStaticPersistentRefsEnabledOverrideSet != 1) {
    return 1LL;
  }
  int v0 = persistentRefOverrideLastValue;
  if (persistentRefOverrideLastValue != SecKeychainStaticPersistentRefsEnabledOverride)
  {
    secLogObjForScope("octagon");
    id v1 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      if (SecKeychainStaticPersistentRefsEnabledOverride) {
        int v2 = @"enabled";
      }
      else {
        int v2 = @"disabled";
      }
      int v4 = 138412290;
      id v5 = v2;
      _os_log_impl( &dword_1804F4000,  v1,  OS_LOG_TYPE_DEFAULT,  "Static Persistent Refs are %@ (overridden)",  (uint8_t *)&v4,  0xCu);
    }

    int v0 = SecKeychainStaticPersistentRefsEnabledOverride;
    persistentRefOverrideLastValue = SecKeychainStaticPersistentRefsEnabledOverride;
  }

  return v0 != 0;
}

uint64_t SecKeychainSetOverrideStaticPersistentRefsIsEnabled(uint64_t result)
{
  SecKeychainStaticPersistentRefsEnabledOverrideSet = 1;
  SecKeychainStaticPersistentRefsEnabledOverride = result;
  return result;
}

id OTSetupControlProtocol(void *a1)
{
  id v1 = a1;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  [v1 setClasses:v2 forSelector:sel_appleAccountSignedIn_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_appleAccountSignedOut_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_notifyIDMSTrustLevelChangeForAltDSID_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_rpcEpochWithArguments_configuration_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_rpcPrepareIdentityAsApplicantWithArguments_configuration_reply_ argumentIndex:5 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_rpcVoucherWithArguments_configuration_peerID_permanentInfo_permanentInfoSig_stableInfo_stableInfoSig_maxCapability_reply_ argumentIndex:2 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_rpcJoinWithArguments_configuration_vouchData_vouchSig_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_status_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_status_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchEgoPeerID_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchCliqueStatus_configuration_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchTrustStatus_configuration_reply_ argumentIndex:4 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_startOctagonStateMachine_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_resetAndEstablish_resetReason_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_accountSettings_isGuitarfish_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_establish_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_leaveClique_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_removeFriendsInClique_peerIDs_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_peerDeviceNamesByPeerID_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchAllViableBottles_source_reply_ argumentIndex:2 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_restoreFromBottle_entropy_bottleID_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchEscrowContents_reply_ argumentIndex:3 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_createRecoveryKey_recoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_joinWithRecoveryKey_recoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_healthCheck_skipRateLimitingCheck_repair_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_simulateReceivePush_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_waitForOctagonUpgrade_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_postCDPFollowupResult_success_type_error_reply_ argumentIndex:3 ofReply:0];
  [v1 setClasses:v2 forSelector:sel_postCDPFollowupResult_success_type_error_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_tapToRadar_description_radar_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_refetchCKKSPolicy_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setCDPEnabled_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_getCDPStatus_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchEscrowRecords_source_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setUserControllableViewsSyncStatus_enabled_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchUserControllableViewsSyncStatus_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_resetAccountCDPContents_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setLocalSecureElementIdentity_secureElementIdentity_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_removeLocalSecureElementIdentityPeerID_secureElementIdentityPeerID_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchTrustedSecureElementIdentities_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setAccountSetting_setting_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchAccountSettings_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchAccountWideSettingsWithForceFetch_arguments_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_waitForPriorityViewKeychainDataRecovery_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_createCustodianRecoveryKey_uuid_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_joinWithCustodianRecoveryKey_custodianRecoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_preflightJoinWithCustodianRecoveryKey_custodianRecoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_removeCustodianRecoveryKey_uuid_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_createInheritanceKey_uuid_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_generateInheritanceKey_uuid_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_storeInheritanceKey_ik_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_joinWithInheritanceKey_inheritanceKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_preflightJoinWithInheritanceKey_inheritanceKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_removeInheritanceKey_uuid_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_tlkRecoverabilityForEscrowRecordData_recordData_source_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_setMachineIDOverride_machineID_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_isRecoveryKeySet_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_recoverWithRecoveryKey_recoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_removeRecoveryKey_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_preflightRecoverOctagonUsingRecoveryKey_recoveryKey_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_clearCliqueFromAccount_resetReason_isGuitarfish_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_performCKServerUnreadableDataRemoval_isGuitarfish_altDSID_reply_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_totalTrustedPeers_reply_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_areRecoveryKeysDistrusted_reply_ argumentIndex:1 ofReply:1];

  return v1;
}

BOOL SECSFAActionAutomaticBugCaptureReadFrom(uint64_t a1, uint64_t a2)
{
  char v3 = (int *)MEMORY[0x189611CF0];
  int v4 = (int *)MEMORY[0x189611CE8];
  id v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    uint64_t v7 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((_DWORD)v17 == 2)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 24LL;
        goto LABEL_24;
      }

      if ((_DWORD)v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 8LL;
LABEL_24:
        uint64_t v20 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_26;
      }

      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0LL;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
    }

    uint64_t v18 = PBReaderReadString();
    uint64_t v19 = 16LL;
    goto LABEL_24;
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_18052B264( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_18052B318(_Unwind_Exception *a1)
{
}

void sub_18052BBD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_18052C01C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_18052C5F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

uint64_t __Block_byref_object_copy__2082(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__2083(uint64_t a1)
{
}

void sub_18052E438(_Unwind_Exception *a1)
{
}

CFIndex appendSecBuf(__CFData *a1, __int16 a2, void *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  v6[0] = a2;
  v6[1] = a2;
  int v7 = 0;
  CFDataAppendBytes(a1, (const UInt8 *)v6, 8LL);
  CFIndex result = CFDataGetLength(a1);
  *a3 = result - 4;
  return result;
}

void secBufOffset(const __CFData *a1, CFIndex a2)
{
  *(_DWORD *)newBytes = CFDataGetLength(a1);
  v5.location = a2;
  v5.CFIndex length = 4LL;
  CFDataReplaceBytes(a1, v5, newBytes, 4LL);
}

uint64_t ntlmStringToLE(const __CFString *a1, void *a2, _DWORD *a3)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length > 2048) {
    return 4294967188LL;
  }
  uint64_t v7 = Length;
  int v8 = 2 * Length;
  unsigned int v9 = malloc(2 * Length);
  if (!v9) {
    return 4294967188LL;
  }
  unint64_t v10 = v9;
  if (v7 >= 1)
  {
    CFIndex v11 = 0LL;
    unint64_t v12 = v9;
    do
      *v12++ = CFStringGetCharacterAtIndex(a1, v11++);
    while (v7 != v11);
  }

  uint64_t result = 0LL;
  *a2 = v10;
  *a3 = v8;
  return result;
}

uint64_t ntlmStringFlatten(CFStringRef theString, int a2, char **a3, unsigned int *a4)
{
  if (a2) {
    return ntlmStringToLE(theString, a3, a4);
  }
  CFIndex Length = CFStringGetLength(theString);
  if (Length <= 2048)
  {
    unsigned int v9 = Length;
    CFIndex v10 = Length + 1;
    CFIndex v11 = (char *)malloc(Length + 1);
    if (v11)
    {
      unint64_t v12 = v11;
      if (CFStringGetCString(theString, v11, v10, 0x600u))
      {
        uint64_t result = 0LL;
        *a3 = v12;
        *a4 = v9;
        return result;
      }

      free(v12);
      ExternalRepresentation = CFStringCreateExternalRepresentation(0LL, theString, 0x8000100u, 0);
      if (!ExternalRepresentation) {
        return 4294967246LL;
      }
      int v14 = ExternalRepresentation;
      unsigned int v15 = CFDataGetLength(ExternalRepresentation);
      *a4 = v15;
      uint64_t v16 = (char *)malloc(v15);
      *a3 = v16;
      if (v16)
      {
        unint64_t v17 = v16;
        BytePtr = CFDataGetBytePtr(v14);
        memcpy(v17, BytePtr, *a4);
        CFRelease(v14);
        return 0LL;
      }

      CFRelease(v14);
    }
  }

  return 4294967188LL;
}

char *ntlmHostName(int a1, void *a2, _DWORD *a3)
{
  if (a1)
  {
    uint64_t result = (char *)malloc(0x16uLL);
    uint64_t v6 = 0LL;
    *a2 = result;
    do
    {
      *(_WORD *)uint64_t result = aWorkstation[v6];
      result += 2;
      ++v6;
    }

    while (v6 != 11);
    *a3 = 22;
  }

  else
  {
    uint64_t result = (char *)malloc(0xCuLL);
    *a2 = result;
    *a3 = 11;
    *(_DWORD *)(result + 7) = 1313818964;
    *(void *)uint64_t result = *(void *)"WORKSTATION";
    a2[11] = 0LL;
  }

  return result;
}

void __ntlmGetBasis_block_invoke(uint64_t a1)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __CFAbsoluteTimeForGregorianZuluDay_block_invoke;
  v3[3] = &unk_189665828;
  v3[4] = &v5;
  void v3[5] = 0x100000641LL;
  int v4 = 1;
  SecCFCalendarDoWithZuluCalendar((uint64_t)v3);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  **(void **)(a1 + 32) = v2;
}

CFAbsoluteTime __CFAbsoluteTimeForGregorianZuluDay_block_invoke(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  uint64_t v4 = *(unsigned int *)(a1 + 44);
  uint64_t v6 = *(unsigned int *)(a1 + 48);
  CFAbsoluteTime at = NAN;
  CFCalendarComposeAbsoluteTime(calendar, &at, "yMd", v3, v4, v6);
  CFAbsoluteTime result = at;
  *(CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = at;
  return result;
}

void ntlmAppendTimestamp(__CFData *a1)
{
  void v3[5] = *MEMORY[0x1895F89C0];
  double Current = CFAbsoluteTimeGetCurrent();
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __ntlmGetBasis_block_invoke;
  v3[3] = &__block_descriptor_tmp_2518;
  v3[4] = &ntlmGetBasis_sntlmGetBasisSingleton;
  if (ntlmGetBasis_sntlmGetBasisOnce != -1) {
    dispatch_once(&ntlmGetBasis_sntlmGetBasisOnce, v3);
  }
  v3[0] = (unint64_t)((Current - *(double *)&ntlmGetBasis_sntlmGetBasisSingleton) * 10000000.0);
  CFDataAppendBytes(a1, (const UInt8 *)v3, 8LL);
}

uint64_t md5Hash(const void *a1, unsigned __int8 *a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.data[13] = v4;
  *(_OWORD *)&v6.data[6] = v4;
  *(_OWORD *)&v6.data[10] = v4;
  *(_OWORD *)&v6.Nl = v4;
  *(_OWORD *)&v6.data[2] = v4;
  *(_OWORD *)&v6.A = v4;
  CC_MD5_Init(&v6);
  CC_MD5_Update(&v6, a1, 0x10u);
  return CC_MD5_Final(a2, &v6);
}

void ntlmHmacMD5(void *key, const void *a2, unsigned int a3, void *a4)
{
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v8.ctx[88] = v7;
  *(_OWORD *)&v8.ctx[92] = v7;
  *(_OWORD *)&v8.ctx[80] = v7;
  *(_OWORD *)&v8.ctx[84] = v7;
  *(_OWORD *)&v8.ctx[72] = v7;
  *(_OWORD *)&v8.ctx[76] = v7;
  *(_OWORD *)&v8.ctx[64] = v7;
  *(_OWORD *)&v8.ctx[68] = v7;
  *(_OWORD *)&v8.ctx[56] = v7;
  *(_OWORD *)&v8.ctx[60] = v7;
  *(_OWORD *)&v8.ctx[48] = v7;
  *(_OWORD *)&v8.ctx[52] = v7;
  *(_OWORD *)&v8.ctx[40] = v7;
  *(_OWORD *)&v8.ctx[44] = v7;
  *(_OWORD *)&v8.ctx[32] = v7;
  *(_OWORD *)&v8.ctx[36] = v7;
  *(_OWORD *)&v8.ctx[24] = v7;
  *(_OWORD *)&v8.ctx[28] = v7;
  *(_OWORD *)&v8.ctx[16] = v7;
  *(_OWORD *)&v8.ctx[20] = v7;
  *(_OWORD *)&v8.ctx[8] = v7;
  *(_OWORD *)&v8.ctx[12] = v7;
  *(_OWORD *)v8.ctx = v7;
  *(_OWORD *)&v8.ctx[4] = v7;
  CCHmacInit(&v8, 1u, key, 0x10uLL);
  CCHmacUpdate(&v8, a2, a3);
  CCHmacFinal(&v8, a4);
}

uint64_t lmv2Response(uint64_t a1, void *dataIn, char *dataOut, uint8x8_t a4, uint8x8_t a5)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  int v7 = *(unsigned __int8 *)(a1 + 4);
  int v8 = *(unsigned __int8 *)(a1 + 5);
  int v9 = *(unsigned __int8 *)(a1 + 6);
  int v10 = *(unsigned __int8 *)(a1 + 11);
  int v11 = *(unsigned __int8 *)(a1 + 12);
  int v12 = *(unsigned __int8 *)(a1 + 13);
  int v13 = *(unsigned __int8 *)(a1 + 14);
  a4.i32[0] = *(_DWORD *)a1;
  int16x8_t v14 = (int16x8_t)vmovl_u8(a4);
  int v15 = *(unsigned __int8 *)(a1 + 15);
  char key = v14.i8[0] & 0xFE;
  a5.i32[0] = *(_DWORD *)(a1 + 1);
  v14.i64[0] = *(void *)&vshl_u16( (uint16x4_t)vorr_s8( (int8x8_t)vshl_n_s16(*(int16x4_t *)v14.i8, 8uLL),  (int8x8_t)*(_OWORD *)&vmovl_u8(a5)),  (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0x80FE80FE80FE80FELL;
  *(int8x8_t *)v14.i8 = vmovn_s16(v14);
  __int32 v31 = v14.i32[0];
  HIDWORD(v16) = v7;
  LODWORD(v16) = v8 << 24;
  char v32 = (v16 >> 29) & 0xFE;
  HIDWORD(v16) = v8;
  LODWORD(v16) = v9 << 24;
  char v33 = (v16 >> 30) & 0xFE;
  char v34 = 2 * v9;
  v14.i32[0] = *(_DWORD *)(a1 + 7);
  int16x8_t v17 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8);
  char v25 = v17.i8[0] & 0xFE;
  int16x4_t v18 = (int16x4_t)vext_s8(*(int8x8_t *)v17.i8, *(int8x8_t *)v17.i8, 2uLL);
  v18.i16[3] = v10;
  v17.i64[0] = *(void *)&vshl_u16( (uint16x4_t)vsli_n_s16(v18, *(int16x4_t *)v17.i8, 8uLL),  (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0x80FE80FE80FE80FELL;
  unsigned __int32 v26 = vmovn_s16(v17).u32[0];
  HIDWORD(v16) = v10;
  LODWORD(v16) = v11 << 24;
  uint64_t v19 = (v16 >> 29) & 0xFE;
  HIDWORD(v16) = v11;
  LODWORD(v16) = v12 << 24;
  char v27 = v19;
  char v28 = (v16 >> 30) & 0xFE;
  char v29 = 2 * v12;
  v22[0] = v13 & 0xFE;
  HIDWORD(v16) = v13;
  LODWORD(v16) = v15 << 24;
  v22[1] = (v16 >> 25) & 0xFE;
  uint64_t v22[2] = (_BYTE)v15 << 6;
  int v23 = 0;
  char v24 = 0;
  size_t dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = CCCrypt(0, 1u, 0, &key, 8uLL, 0LL, dataIn, 8uLL, dataOut, 8uLL, &dataOutMoved);
  if (!(_DWORD)result)
  {
    size_t dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = CCCrypt(0, 1u, 0, &v25, 8uLL, 0LL, dataIn, 8uLL, dataOut + 8, 8uLL, &dataOutMoved);
    if (!(_DWORD)result)
    {
      size_t dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
      return CCCrypt(0, 1u, 0, v22, 8uLL, 0LL, dataIn, 8uLL, dataOut + 16, 8uLL, &dataOutMoved);
    }
  }

  return result;
}

uint64_t SECSFAPropertyValueReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  __int128 v4 = (int *)MEMORY[0x189611CE8];
  uint64_t v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    int v7 = (int *)MEMORY[0x189611CD8];
    do
    {
      if (*(_BYTE *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 101)
      {
        [(id)a1 clearOneofValuesForProperty];
        *(_BYTE *)(a1 + 32) |= 2u;
        *(_DWORD *)(a1 + 16) = 2;
        uint64_t v24 = PBReaderReadString();
        char v25 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v24;
      }

      else if ((_DWORD)v17 == 100)
      {
        [(id)a1 clearOneofValuesForProperty];
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v28 = 0LL;
        *(_BYTE *)(a1 + 32) |= 2u;
        *(_DWORD *)(a1 + 16) = 1;
        *(_BYTE *)(a1 + 32) |= 1u;
        while (1)
        {
          uint64_t v29 = *v3;
          unint64_t v30 = *(void *)(a2 + v29);
          if (v30 == -1LL || v30 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v31 = *(_BYTE *)(*(void *)(a2 + *v7) + v30);
          *(void *)(a2 + v29) = v30 + 1;
          v28 |= (unint64_t)(v31 & 0x7F) << v26;
          if ((v31 & 0x80) == 0) {
            goto LABEL_40;
          }
          v26 += 7;
          BOOL v14 = v27++ >= 9;
          if (v14)
          {
            uint64_t v28 = 0LL;
            goto LABEL_42;
          }
        }

        *(_BYTE *)(a2 + *v5) = 1;
LABEL_40:
        if (*(_BYTE *)(a2 + *v5)) {
          uint64_t v28 = 0LL;
        }
LABEL_42:
        *(void *)(a1 + _Block_object_dispose((const void *)(v27 - 112), 8) = v28;
      }

      else if ((_DWORD)v17)
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result) {
          return result;
        }
      }

      else
      {
        unsigned int v18 = 0;
        while (1)
        {
          uint64_t v19 = *v3;
          unint64_t v20 = *(void *)(a2 + v19);
          if (v20 == -1LL || v20 >= *(void *)(a2 + *v4)) {
            break;
          }
          unint64_t v21 = v20 + 1;
          int v22 = *(char *)(*(void *)(a2 + *v7) + v20);
          *(void *)(a2 + v19) = v21;
          if (v22 < 0 && v18++ <= 8) {
            continue;
          }
          goto LABEL_43;
        }

        *(_BYTE *)(a2 + *v5) = 1;
      }

LABEL_6:
}
}

  return v7;
}

  if (!Mutable) {
    goto LABEL_16;
  }
  return Mutable;
}

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v14;
}

      int v7 = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 24LL))(v4);
      goto LABEL_7;
    case 3:
LABEL_5:
      CC_MD5_CTX v6 = __cxa_begin_catch(a1);
      int v7 = (*(uint64_t (**)(void *))(*(void *)v6 + 24LL))(v6);
LABEL_7:
      uint64_t v5 = v7;
      goto LABEL_8;
  }

  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v5 = 4294967188LL;
  }

  else
  {
    Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v11);
    uint64_t v5 = 4294900248LL;
  }

LABEL_9:
  *((void *)result + 3) = self->_minor;
  *((_BYTE *)result + 36) |= 4u;
  if ((*(_BYTE *)&self->_has & 1) == 0) {
    return result;
  }
LABEL_5:
  *((void *)result + 1) = self->_build;
  *((_BYTE *)result + 36) |= 1u;
  return result;
}

  return v6;
}

  if (CFSetContainsValue(*(CFSetRef *)(a1 + 40), value)) {
    return SOSCircleRejectRequest(a1, a2, value, a4);
  }
  else {
    return 1LL;
  }
}

  uint64_t v24 = v51;
  if (v51)
  {
    CFIndex v51 = 0LL;
    CFRelease(v24);
  }

  char v25 = v50;
  if (v50)
  {
    uint64_t v50 = 0LL;
    CFRelease(v25);
  }

  return v22;
}

    appendRelabeledProperty(a1, @"Authority Key Identifier", 0LL, a2, @"Invalid %@", a3);
  }

          id v1 = 0LL;
          goto LABEL_10;
        }

        unint64_t v10 = v9;
      }

      free(v6);
      uint64_t v11 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        int v15 = v10;
        _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "coretrust decompress failed: %04x", buf, 8u);
      }
    }

    return 0LL;
  }

  return v1;
}

  *a2 = v7;
  return v5;
}

uint64_t SECSFAVersionReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  __int128 v4 = (int *)MEMORY[0x189611CE8];
  uint64_t v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    int v7 = (int *)MEMORY[0x189611CD8];
    do
    {
      if (*(_BYTE *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v17 = 0;
          unsigned int v18 = 0;
          uint64_t v19 = 0LL;
          *(_BYTE *)(a1 + 36) |= 8u;
          while (1)
          {
            uint64_t v20 = *v3;
            unint64_t v21 = *(void *)(a2 + v20);
            if (v21 == -1LL || v21 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v22 = *(_BYTE *)(*(void *)(a2 + *v7) + v21);
            *(void *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0) {
              goto LABEL_50;
            }
            v17 += 7;
            BOOL v14 = v18++ >= 9;
            if (v14)
            {
              LODWORD(v19) = 0;
              goto LABEL_52;
            }
          }

          *(_BYTE *)(a2 + *v5) = 1;
LABEL_50:
          if (*(_BYTE *)(a2 + *v5)) {
            LODWORD(v19) = 0;
          }
LABEL_52:
          *(_DWORD *)(a1 + 32) = v19;
          continue;
        case 2u:
          char v24 = 0;
          unsigned int v25 = 0;
          uint64_t v26 = 0LL;
          *(_BYTE *)(a1 + 36) |= 2u;
          while (2)
          {
            uint64_t v27 = *v3;
            unint64_t v28 = *(void *)(a2 + v27);
            if (v28 == -1LL || v28 >= *(void *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }

            else
            {
              char v29 = *(_BYTE *)(*(void *)(a2 + *v7) + v28);
              *(void *)(a2 + v27) = v28 + 1;
              v26 |= (unint64_t)(v29 & 0x7F) << v24;
              if (v29 < 0)
              {
                v24 += 7;
                BOOL v14 = v25++ >= 9;
                if (v14)
                {
                  uint64_t v26 = 0LL;
                  goto LABEL_56;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + *v5)) {
            uint64_t v26 = 0LL;
          }
LABEL_56:
          uint64_t v40 = 16LL;
          goto LABEL_65;
        case 3u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v26 = 0LL;
          *(_BYTE *)(a1 + 36) |= 4u;
          while (2)
          {
            uint64_t v32 = *v3;
            unint64_t v33 = *(void *)(a2 + v32);
            if (v33 == -1LL || v33 >= *(void *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }

            else
            {
              char v34 = *(_BYTE *)(*(void *)(a2 + *v7) + v33);
              *(void *)(a2 + v32) = v33 + 1;
              v26 |= (unint64_t)(v34 & 0x7F) << v30;
              if (v34 < 0)
              {
                v30 += 7;
                BOOL v14 = v31++ >= 9;
                if (v14)
                {
                  uint64_t v26 = 0LL;
                  goto LABEL_60;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + *v5)) {
            uint64_t v26 = 0LL;
          }
LABEL_60:
          uint64_t v40 = 24LL;
          goto LABEL_65;
        case 4u:
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v26 = 0LL;
          *(_BYTE *)(a1 + 36) |= 1u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result) {
            return result;
          }
          continue;
      }

      while (1)
      {
        uint64_t v37 = *v3;
        unint64_t v38 = *(void *)(a2 + v37);
        if (v38 == -1LL || v38 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v39 = *(_BYTE *)(*(void *)(a2 + *v7) + v38);
        *(void *)(a2 + v37) = v38 + 1;
        v26 |= (unint64_t)(v39 & 0x7F) << v35;
        if ((v39 & 0x80) == 0) {
          goto LABEL_62;
        }
        v35 += 7;
        BOOL v14 = v36++ >= 9;
        if (v14)
        {
          uint64_t v26 = 0LL;
          goto LABEL_64;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_62:
      if (*(_BYTE *)(a2 + *v5)) {
        uint64_t v26 = 0LL;
      }
LABEL_64:
      uint64_t v40 = 8LL;
LABEL_65:
      *(void *)(a1 + v40) = v26;
    }

    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t SECSFAVersionMatchReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  __int128 v4 = (int *)MEMORY[0x189611CE8];
  uint64_t v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    int v7 = (int *)MEMORY[0x189611CD8];
    do
    {
      if (*(_BYTE *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        char v17 = objc_alloc_init(&OBJC_CLASS___SECSFAVersion);
        [a1 addVersions:v17];
        if (!PBReaderPlaceMark() || (SECSFAVersionReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0LL;
        }

        PBReaderRecallMark();
      }

      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result) {
          return result;
        }
      }
    }

    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

LABEL_27:
  return v12;
}

    uint64_t v53 = -25300;
    goto LABEL_28;
  }

  CFIndex v57 = v56;
  [v54 keyData];
  CFIndex v58 = (const __CFData *)objc_claimAutoreleasedReturnValue();
  uint64_t v71 = 0LL;
  LODWORD(v57) = SOSFullPeerInfoSaveOctagonKeysToKeychain(v55, v58, v57, &v71);
  unint64_t v59 = v71;

  if (!(_DWORD)v57 || v59)
  {
    secLogObjForScope("SecError");
    unint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      unint64_t v67 = "Unable to save octagon encryption key to the keychain";
      goto LABEL_26;
    }

    goto LABEL_27;
  }

  uint64_t v53 = SecKeyCopyPersistentRef((uint64_t)a8, (CFTypeRef *)(Instance + 40), v60, v61, v62, v63, v64, v65);
LABEL_28:

LABEL_29:
  if (!SecError(v53, (__CFString **)a9, @"Inflating octagon peer encryption persistent ref"))
  {
LABEL_31:
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

      char v17 = (CFTypeRef)Instance;
LABEL_28:
      uint64_t Instance = 0LL;
      goto LABEL_29;
    }

    char v35 = CFGetTypeID(v23);
    char v34 = CFCopyTypeIDDescription(v35);
    SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"Expected dictionary got %@", v34);
LABEL_25:
    if (v34) {
      CFRelease(v34);
    }
    goto LABEL_27;
  }

  unsigned int v31 = CFGetTypeID(v17);
  uint64_t v32 = CFCopyTypeIDDescription(v31);
  SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"Expected dictionary got %@", v32);
  if (v32) {
    CFRelease(v32);
  }
LABEL_20:
  CFRelease((CFTypeRef)Instance);
  uint64_t Instance = 0LL;
  if (v17)
  {
    CFTypeRef cf = 0LL;
LABEL_29:
    CFRelease(v17);
  }

  return Instance;
}

      return 4294941021LL;
    }
  }

  return result;
}

    unint64_t v12 = 0LL;
    goto LABEL_29;
  }

  BOOL v14 = 0LL;
LABEL_13:

  return v14;
}

      if (v5)
      {
        char v17 = v11[12];
        unsigned int v18 = bswap32(v17);
        if (v6) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = v17;
        }
        uint64_t v20 = bswap64(*((void *)v11 + 5));
        if (v6) {
          unint64_t v21 = v20;
        }
        else {
          unint64_t v21 = *((void *)v11 + 5);
        }
      }

      else
      {
        int v23 = v11[9];
        char v22 = v11[10];
        char v24 = bswap32(v22);
        if (v6) {
          uint64_t v19 = v24;
        }
        else {
          uint64_t v19 = v22;
        }
        unsigned int v25 = bswap32(v23);
        if (v6) {
          unint64_t v21 = v25;
        }
        else {
          unint64_t v21 = v23;
        }
      }

      CFTypeRef cf = Security::MachO::dataAt((Security::MachO *)v2, v19, v21);
    }
  }

uint64_t SECSFAEventRuleReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  __int128 v4 = (int *)MEMORY[0x189611CE8];
  uint64_t v5 = (int *)MEMORY[0x189611CE0];
  int v7 = (int *)MEMORY[0x189611CD8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5)) {
      return *(_BYTE *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0LL;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }

    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5)) {
      unint64_t v10 = 0LL;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(_BYTE *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 32LL;
        goto LABEL_34;
      case 2u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 40LL;
        goto LABEL_34;
      case 3u:
        uint64_t v20 = objc_alloc_init(&OBJC_CLASS___SECSFAAction);
        objc_storeStrong((id *)(a1 + 16), v20);
        goto LABEL_44;
      case 4u:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0LL;
        *(_BYTE *)(a1 + 68) |= 1u;
        while (2)
        {
          uint64_t v24 = *v3;
          unint64_t v25 = *(void *)(a2 + v24);
          if (v25 == -1LL || v25 >= *(void *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }

          else
          {
            char v26 = *(_BYTE *)(*(void *)(a2 + *v7) + v25);
            *(void *)(a2 + v24) = v25 + 1;
            v23 |= (unint64_t)(v26 & 0x7F) << v21;
            if (v26 < 0)
            {
              v21 += 7;
              BOOL v14 = v22++ >= 9;
              if (v14)
              {
                uint64_t v23 = 0LL;
                goto LABEL_55;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + *v5)) {
          uint64_t v23 = 0LL;
        }
LABEL_55:
        *(void *)(a1 + _Block_object_dispose((const void *)(v27 - 112), 8) = v23;
        goto LABEL_64;
      case 5u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 48LL;
LABEL_34:
        uint64_t v27 = *(void **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose((const void *)(v27 - 112), 8) = v17;

        goto LABEL_64;
      case 6u:
        char v28 = 0;
        unsigned int v29 = 0;
        uint64_t v30 = 0LL;
        *(_BYTE *)(a1 + 68) |= 2u;
        while (2)
        {
          uint64_t v31 = *v3;
          unint64_t v32 = *(void *)(a2 + v31);
          if (v32 == -1LL || v32 >= *(void *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }

          else
          {
            char v33 = *(_BYTE *)(*(void *)(a2 + *v7) + v32);
            *(void *)(a2 + v31) = v32 + 1;
            v30 |= (unint64_t)(v33 & 0x7F) << v28;
            if (v33 < 0)
            {
              v28 += 7;
              BOOL v14 = v29++ >= 9;
              if (v14)
              {
                LODWORD(v30) = 0;
                goto LABEL_59;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + *v5)) {
          LODWORD(v30) = 0;
        }
LABEL_59:
        *(_DWORD *)(a1 + 24) = v30;
        goto LABEL_64;
      case 7u:
        uint64_t v20 = objc_alloc_init(&OBJC_CLASS___SECSFAVersionMatch);
        objc_storeStrong((id *)(a1 + 56), v20);
        if (PBReaderPlaceMark() && (SECSFAVersionMatchReadFrom(v20, a2) & 1) != 0)
        {
LABEL_44:
          PBReaderRecallMark();

LABEL_64:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(_BYTE *)(a2 + *v5) == 0;
          }
          continue;
        }

void sub_180539294( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_180539420( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1805395C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_180539750( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_1805398D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_180539A1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_180539B74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180539EE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t __Block_byref_object_copy__3101(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__3102(uint64_t a1)
{
}

void __sec_protocol_options_access_handle_block_invoke()
{
  int v0 = dlopen("/usr/lib/libnetwork.dylib", 5);
  sec_protocol_options_access_handle_libnetworkImage = (uint64_t)v0;
  if (v0)
  {
    sec_protocol_options_access_handle__nw_protocol_options_access_handle = (uint64_t (*)(void, void))dlsym(v0, "nw_protocol_options_access_handle");
    if (!sec_protocol_options_access_handle__nw_protocol_options_access_handle
      && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
    {
      __int16 v5 = 0;
      id v1 = (os_log_s *)MEMORY[0x1895F8DA0];
      uint64_t v2 = "dlsym libnetwork nw_protocol_options_access_handle";
      uint64_t v3 = (uint8_t *)&v5;
LABEL_8:
      _os_log_error_impl(&dword_1804F4000, v1, OS_LOG_TYPE_ERROR, v2, v3, 2u);
    }
  }

  else if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
  {
    __int16 v4 = 0;
    id v1 = (os_log_s *)MEMORY[0x1895F8DA0];
    uint64_t v2 = "dlopen libnetwork";
    uint64_t v3 = (uint8_t *)&v4;
    goto LABEL_8;
  }

void __sec_protocol_metadata_access_handle_block_invoke()
{
  int v0 = dlopen("/usr/lib/libnetwork.dylib", 5);
  sec_protocol_metadata_access_handle_libnetworkImage = (uint64_t)v0;
  if (v0)
  {
    sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle = (uint64_t (*)(void, void))dlsym(v0, "nw_protocol_metadata_access_handle");
    if (!sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle
      && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
    {
      __int16 v5 = 0;
      id v1 = (os_log_s *)MEMORY[0x1895F8DA0];
      uint64_t v2 = "dlsym libnetwork _nw_protocol_metadata_access_handle";
      uint64_t v3 = (uint8_t *)&v5;
LABEL_8:
      _os_log_error_impl(&dword_1804F4000, v1, OS_LOG_TYPE_ERROR, v2, v3, 2u);
    }
  }

  else if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
  {
    __int16 v4 = 0;
    id v1 = (os_log_s *)MEMORY[0x1895F8DA0];
    uint64_t v2 = "dlopen libnetwork";
    uint64_t v3 = (uint8_t *)&v4;
    goto LABEL_8;
  }

uint64_t sec_protocol_options_contents_compare(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  uint64_t result = 1LL;
  if (a1 != a2 && a3 != 1)
  {
    uint64_t result = 0LL;
    if (a1)
    {
      if (a2)
      {
        if (*a1 != *a2) {
          return 0LL;
        }
        if (a1[1] != a2[1]) {
          return 0LL;
        }
        if (*((void *)a1 + 38) != *((void *)a2 + 38)) {
          return 0LL;
        }
        if (*((void *)a1 + 39) != *((void *)a2 + 39)) {
          return 0LL;
        }
        if (*((_DWORD *)a1 + 80) != *((_DWORD *)a2 + 80)) {
          return 0LL;
        }
        unint64_t v6 = *(unsigned int *)((char *)a1 + 361) | ((unint64_t)*((unsigned __int8 *)a1 + 365) << 32);
        unint64_t v7 = *(unsigned int *)((char *)a2 + 361) | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
        if (((v7 ^ v6) & 0x7AEAAAAAFLL) != 0) {
          return 0LL;
        }
        if ((a3 - 4) <= 0xFFFFFFFC)
        {
          uint64_t v8 = v6 & 0x3000000000LL;
          uint64_t v9 = v7 & 0x3000000000LL;
          if (v8 == 0x2000000000LL)
          {
            if (v9 != 0x2000000000LL) {
              return 0LL;
            }
          }

          else if (v9 == 0x2000000000LL)
          {
            return 0LL;
          }
        }

        if ((a3 & 0xFE) == 2)
        {
          uint64_t v10 = *((void *)a1 + 43);
          uint64_t v11 = *((void *)a2 + 43);
          if (v10 | v11) {
            goto LABEL_55;
          }
        }

        uint64_t v12 = *((void *)a1 + 11);
        uint64_t v13 = *((void *)a2 + 11);
        if (v12)
        {
          uint64_t result = 0LL;
          if (!v13 || v12 != v13) {
            return result;
          }
          if (*((void *)a1 + 12) != *((void *)a2 + 12)) {
            return 0LL;
          }
        }

        else if (v13)
        {
          return 0LL;
        }

        uint64_t v14 = *((void *)a1 + 32);
        uint64_t v15 = *((void *)a2 + 32);
        if (v14)
        {
          uint64_t result = 0LL;
          if (!v15 || v14 != v15) {
            return result;
          }
          if (*((void *)a1 + 33) != *((void *)a2 + 33)) {
            return 0LL;
          }
        }

        else if (v15)
        {
          return 0LL;
        }

        uint64_t v16 = *((void *)a1 + 13);
        uint64_t v17 = *((void *)a2 + 13);
        if (v16)
        {
          uint64_t result = 0LL;
          if (!v17 || v16 != v17) {
            return result;
          }
          if (*((void *)a1 + 14) != *((void *)a2 + 14)) {
            return 0LL;
          }
        }

        else if (v17)
        {
          return 0LL;
        }

        uint64_t v18 = *((void *)a1 + 15);
        uint64_t v19 = *((void *)a2 + 15);
        if (v18)
        {
          uint64_t result = 0LL;
          if (!v19 || v18 != v19) {
            return result;
          }
          if (*((void *)a1 + 16) != *((void *)a2 + 16)) {
            return 0LL;
          }
        }

        else if (v19)
        {
          return 0LL;
        }

        uint64_t v20 = *((void *)a1 + 18);
        uint64_t v21 = *((void *)a2 + 18);
        if (v20)
        {
          uint64_t result = 0LL;
          if (!v21 || v20 != v21) {
            return result;
          }
          if (*((void *)a1 + 19) != *((void *)a2 + 19)) {
            return 0LL;
          }
        }

        else if (v21)
        {
          return 0LL;
        }

        uint64_t v22 = *((void *)a1 + 20);
        uint64_t v23 = *((void *)a2 + 20);
        if (!v22)
        {
          if (v23) {
            return 0LL;
          }
          goto LABEL_56;
        }

        uint64_t result = 0LL;
        if (v23 && v22 == v23)
        {
          uint64_t v10 = *((void *)a1 + 21);
          uint64_t v11 = *((void *)a2 + 21);
LABEL_55:
          if (v10 != v11) {
            return 0LL;
          }
LABEL_56:
          uint64_t v24 = (void *)*((void *)a1 + 28);
          unint64_t v25 = (void *)*((void *)a2 + 28);
          if (v24)
          {
            if (!v25 || !sec_protocol_helper_dispatch_data_equal(v24, v25)) {
              return 0LL;
            }
          }

          else if (v25)
          {
            return 0LL;
          }

          char v26 = (void *)*((void *)a1 + 17);
          uint64_t v27 = (void *)*((void *)a2 + 17);
          if (v26)
          {
            if (!v27 || !sec_protocol_helper_dispatch_data_equal(v26, v27)) {
              return 0LL;
            }
          }

          else if (v27)
          {
            return 0LL;
          }

          char v28 = (void *)*((void *)a1 + 10);
          unsigned int v29 = (void *)*((void *)a2 + 10);
          if (v28)
          {
            if (!v29 || !sec_protocol_helper_dispatch_data_equal(v28, v29)) {
              return 0LL;
            }
          }

          else if (v29)
          {
            return 0LL;
          }

          uint64_t v30 = (void *)*((void *)a1 + 6);
          uint64_t v31 = (void *)*((void *)a2 + 6);
          if (v30)
          {
            if (!v31 || !xpc_equal(v30, v31)) {
              return 0LL;
            }
          }

          else if (v31)
          {
            return 0LL;
          }

          unint64_t v32 = (void *)*((void *)a1 + 5);
          char v33 = (void *)*((void *)a2 + 5);
          if (v32)
          {
            if (!v33 || !xpc_equal(v32, v33)) {
              return 0LL;
            }
          }

          else if (v33)
          {
            return 0LL;
          }

          char v34 = (void *)*((void *)a1 + 29);
          unsigned int v35 = (void *)*((void *)a2 + 29);
          if (v34)
          {
            if (!v35 || !xpc_equal(v34, v35)) {
              return 0LL;
            }
          }

          else if (v35)
          {
            return 0LL;
          }

          uint64_t v36 = (void *)*((void *)a1 + 9);
          uint64_t v37 = (void *)*((void *)a2 + 9);
          if (v36)
          {
            if (!v37 || !xpc_equal(v36, v37)) {
              return 0LL;
            }
          }

          else if (v37)
          {
            return 0LL;
          }

          unint64_t v38 = (const char *)*((void *)a1 + 1);
          char v39 = (const char *)*((void *)a2 + 1);
          if (v38)
          {
            if (!v39 || strcmp(v38, v39)) {
              return 0LL;
            }
          }

          else if (v39)
          {
            return 0LL;
          }

          uint64_t v40 = *((void *)a1 + 7);
          uint64_t v41 = *((void *)a2 + 7);
          if (!v40)
          {
            if (v41) {
              return 0LL;
            }
            goto LABEL_111;
          }

          if (!v41) {
            return 0LL;
          }
          __int128 v42 = *(const void **)(v40 + 8);
          if (v42)
          {
            CFTypeRef v43 = CFRetain(v42);
            uint64_t v41 = *((void *)a2 + 7);
            if (!v41) {
              goto LABEL_108;
            }
          }

          else
          {
            CFTypeRef v43 = 0LL;
          }

          int v44 = *(const void **)(v41 + 8);
          if (v44)
          {
            CFTypeRef v45 = CFRetain(v44);
LABEL_109:
            uint64_t result = CFEqual(v43, v45);
            if (!(_DWORD)result) {
              return result;
            }
            CFRelease(v43);
            CFRelease(v45);
LABEL_111:
            uint64_t v46 = *((void *)a1 + 41);
            uint64_t v47 = *((void *)a2 + 41);
            if (v46)
            {
              uint64_t result = 0LL;
              if (!v47 || v46 != v47) {
                return result;
              }
              return 1LL;
            }

            return !v47;
          }

LABEL_108:
          CFTypeRef v45 = 0LL;
          goto LABEL_109;
        }
      }
    }
  }

  return result;
}

        unint64_t v64 = (os_log_s *)secLogObjForScope("notarization");
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
        {
          c.h0 = 67109120;
          c.h1 = 0;
          _os_log_debug_impl(&dword_1804F4000, v64, OS_LOG_TYPE_DEBUG, "isNotarized = %d", (uint8_t *)&c, 8u);
        }

        Security::CFRef<__CFError *>::~CFRef(cf1);
LABEL_111:
        Security::CFRef<__CFData const*>::~CFRef((const void **)md);
LABEL_112:
        LODWORD(v13) = 0;
        return (v4 ^ v13) & 1;
      case 0x17u:
        CFTypeRef v45 = *((void *)this + 2);
        char key = 0LL;
        *(void *)md = 0LL;
        cf1[0] = 0LL;
        CFAbsoluteTime at = 0.0;
        if (!v45) {
          goto LABEL_151;
        }
        uint64_t v46 = Security::CodeSigning::Requirement::Context::cert((CFArrayRef *)v45, 0);
        cf1[0] = 0LL;
        if (SecCertificateGetDeveloperIDDate((uint64_t)v46, &at, (__CFString **)cf1))
        {
          otherDate = (CFDateRef)0xAAAAAAAAAAAAAAAALL;
          uint64_t v47 = CFDateCreate(0LL, at);
          unint64_t v84 = (const __CFDate *)0xAAAAAAAAAAAAAAAALL;
          otherDate = v47;
          unint64_t v84 = Security::CodeSigning::copyCutOffDate(@"AccountCreationCutOffDate", v48, 576374400.0);
          unsigned int v49 = (os_log_s *)secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(void *)&c.h1 = v84;
            _os_log_debug_impl( &dword_1804F4000,  v49,  OS_LOG_TYPE_DEBUG,  "Account Creation Date Cutoff: %@",  (uint8_t *)&c,  0xCu);
          }

          uint64_t v50 = (os_log_s *)secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(void *)&c.h1 = otherDate;
            _os_log_debug_impl( &dword_1804F4000,  v50,  OS_LOG_TYPE_DEBUG,  "Account Creation date: %@",  (uint8_t *)&c,  0xCu);
          }

          if ((CFDateCompare(otherDate, v84, 0LL) & 0x8000000000000000LL) == 0)
          {
            CFIndex v51 = (os_log_s *)secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              c.h0 = 138412546;
              *(void *)&c.h1 = otherDate;
              LOWORD(c.h3) = 2112;
              *(void *)((char *)&c.h3 + 2) = v84;
              _os_log_debug_impl( &dword_1804F4000,  v51,  OS_LOG_TYPE_DEBUG,  "Account creation date %@ is after cut-off %@",  (uint8_t *)&c,  0x16u);
            }

            Security::CFRef<__CFDate const*>::~CFRef((const void **)&v84);
            Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
            goto LABEL_151;
          }

          Security::CFRef<__CFDate const*>::~CFRef((const void **)&v84);
          Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
        }

        else
        {
          int Code = CFErrorGetCode((CFErrorRef)cf1[0]);
          if (Code != -67880)
          {
            unint64_t v59 = (os_log_s *)secLogObjForScope("SecError");
            LODWORD(v13) = 0;
            if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_152;
            }
            c.h0 = 134217984;
            *(void *)&c.h1 = Code;
            unsigned int v60 = "Unexpected error checking account creation date: %ld";
            unint64_t v61 = v59;
            unint64_t v62 = 12;
            goto LABEL_150;
          }
        }

        if (*(void *)(v45 + 72))
        {
          otherDate = (CFDateRef)0xAAAAAAAAAAAAAAAALL;
          otherDate = Security::CodeSigning::copyCutOffDate(@"SecureTimestampCutOffDate", v57, 581040000.0);
          unint64_t v67 = (os_log_s *)secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(void *)&c.h1 = otherDate;
            _os_log_debug_impl( &dword_1804F4000,  v67,  OS_LOG_TYPE_DEBUG,  "Secure Timestamp Cutoff Date cutoff: %@",  (uint8_t *)&c,  0xCu);
          }

          unint64_t v68 = (os_log_s *)secLogObjForScope("meetsDevleoperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            __int128 v78 = *(void *)(v45 + 72);
            c.h0 = 138412290;
            *(void *)&c.h1 = v78;
            _os_log_debug_impl(&dword_1804F4000, v68, OS_LOG_TYPE_DEBUG, "Secure Timestamp: %@", (uint8_t *)&c, 0xCu);
          }

          if (CFDateCompare(*(CFDateRef *)(v45 + 72), otherDate, 0LL) < 0)
          {
            Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
            LODWORD(v13) = 1;
            goto LABEL_152;
          }

          uint64_t v69 = (os_log_s *)secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            __int128 v79 = *(void *)(v45 + 72);
            c.h0 = 138412546;
            *(void *)&c.h1 = v79;
            LOWORD(c.h3) = 2112;
            *(void *)((char *)&c.h3 + 2) = otherDate;
            _os_log_debug_impl( &dword_1804F4000,  v69,  OS_LOG_TYPE_DEBUG,  "Secure timestamp %@ is after cut-off %@",  (uint8_t *)&c,  0x16u);
          }

          Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
        }

        unint64_t v70 = *(Security::CodeSigning::CodeDirectory **)(v45 + 48);
        if (!v70)
        {
          unint64_t v72 = *(void *)(v45 + 56);
          if (v72)
          {
            CFRetain(*(CFTypeRef *)(v45 + 56));
            if (*(void *)md) {
              CFRelease(*(CFTypeRef *)md);
            }
            *(void *)md = v72;
            uint64_t v71 = *(_DWORD *)(v45 + 64);
          }

          else
          {
            uint64_t v71 = 0;
            LODWORD(v13) = *(_DWORD *)md;
            if (!*(void *)md) {
              goto LABEL_152;
            }
          }

          goto LABEL_144;
        }

        uint64_t v13 = (size_t)Security::CodeSigning::CodeDirectory::cdhash(v70, 1);
        if (*(void *)md) {
          CFRelease(*(CFTypeRef *)md);
        }
        *(void *)md = v13;
        uint64_t v71 = *(unsigned __int8 *)(*(void *)(v45 + 48) + 37LL);
        if (v13)
        {
LABEL_144:
          __int128 v73 = *(const char **)(v45 + 80);
          if (v73)
          {
            __int128 v74 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v73, 0x8000100u);
            if (key) {
              CFRelease(key);
            }
            char key = v74;
          }

          __int128 v75 = (os_log_s *)secLogObjForScope("legacy_list");
          LODWORD(v13) = 0;
          if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_152;
          }
          c.h0 = 67109634;
          c.h1 = v71;
          LOWORD(c.h2) = 2112;
          *(void *)((char *)&c.h2 + 2) = *(void *)md;
          HIWORD(c.h4) = 2112;
          *(void *)&c.Nl = key;
          unsigned int v60 = "checking the legacy list for %d, %@, %@";
          unint64_t v61 = v75;
          unint64_t v62 = 28;
LABEL_150:
          _os_log_impl(&dword_1804F4000, v61, OS_LOG_TYPE_DEFAULT, v60, (uint8_t *)&c, v62);
LABEL_151:
          LODWORD(v13) = 0;
        }

uint64_t sec_protocol_options_contents_are_equal(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return sec_protocol_options_contents_compare(a1, a2, 0);
}

BOOL sec_protocol_options_are_equal(sec_protocol_options_t optionsA, sec_protocol_options_t optionsB)
{
  if (optionsA == optionsB) {
    return 1;
  }
  BOOL v4 = 0;
  if (optionsA && optionsB)
  {
    void v6[5] = v2;
    v6[6] = v3;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    _WORD v6[2] = __sec_protocol_options_are_equal_block_invoke;
    void v6[3] = &__block_descriptor_tmp_8;
    void v6[4] = optionsB;
    return sec_protocol_options_access_handle((uint64_t)optionsA, (uint64_t)v6);
  }

  return v4;
}

uint64_t __sec_protocol_options_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __sec_protocol_options_are_equal_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_7;
  unint64_t v4[4] = a2;
  return sec_protocol_options_access_handle(v2, (uint64_t)v4);
}

uint64_t __sec_protocol_options_are_equal_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  return sec_protocol_options_contents_compare(*(unsigned __int16 **)(a1 + 32), a2, 0);
}

void sec_protocol_options_set_local_identity(sec_protocol_options_t options, sec_identity_t identity)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_local_identity_block_invoke;
    v2[3] = &__block_descriptor_tmp_9;
    void v2[4] = identity;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_local_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    BOOL v4 = *(void **)(a2 + 56);
    if (v4) {
      os_release(v4);
    }
    __int16 v5 = *(void **)(a1 + 32);
    if (v5) {
      __int16 v5 = os_retain(v5);
    }
    *(void *)(a2 + 56) = v5;
  }

  return a2 != 0;
}

void sec_protocol_options_append_tls_ciphersuite(sec_protocol_options_t options, tls_ciphersuite_t ciphersuite)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    v2[3] = &__block_descriptor_tmp_10;
    tls_ciphersuite_t v3 = ciphersuite;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_append_tls_ciphersuite_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(xpc_object_t *)(a2 + 40);
    if (!v4)
    {
      xpc_object_t v4 = xpc_array_create(0LL, 0LL);
      *(void *)(a2 + 40) = v4;
    }

    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a1 + 32));
  }

  return a2 != 0;
}

void sec_protocol_options_add_tls_ciphersuite(sec_protocol_options_t options, SSLCipherSuite ciphersuite)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    v2[3] = &__block_descriptor_tmp_10;
    SSLCipherSuite v3 = ciphersuite;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_clear_tls_ciphersuites_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    SSLCipherSuite v3 = *(void **)(a2 + 40);
    if (v3)
    {
      xpc_release(v3);
      *(void *)(a2 + 40) = 0LL;
    }
  }

  return a2 != 0;
}

tls_protocol_version_t sec_protocol_options_get_default_min_tls_protocol_version(void)
{
  return 769;
}

tls_protocol_version_t sec_protocol_options_get_default_min_dtls_protocol_version(void)
{
  return -257;
}

void sec_protocol_options_set_tls_max_version(sec_protocol_options_t options, SSLProtocol version)
{
  uint64_t v2 = 0LL;
  SSLCipherSuite v3 = ssl_protocol_version_map;
  while (1)
  {
    int v4 = *v3;
    v3 += 2;
    if (v4 == version) {
      break;
    }
    if (++v2 == 8) {
      return;
    }
  }

  if (v2 != 7)
  {
    if (options)
    {
      __int16 v5 = ssl_protocol_version_map[2 * v2 + 1];
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 0x40000000LL;
      _WORD v6[2] = __sec_protocol_options_set_max_tls_protocol_version_block_invoke;
      void v6[3] = &__block_descriptor_tmp_15;
      __int16 v7 = v5;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v6);
    }
  }

BOOL __sec_protocol_options_set_max_tls_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 32);
  }
  return a2 != 0;
}

void sec_protocol_options_set_max_tls_protocol_version( sec_protocol_options_t options, tls_protocol_version_t version)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_max_tls_protocol_version_block_invoke;
    v2[3] = &__block_descriptor_tmp_15;
    tls_protocol_version_t v3 = version;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

tls_protocol_version_t sec_protocol_options_get_default_max_tls_protocol_version(void)
{
  return 772;
}

tls_protocol_version_t sec_protocol_options_get_default_max_dtls_protocol_version(void)
{
  return -259;
}

BOOL sec_protocol_options_get_quic_use_legacy_codepoint(sec_protocol_options_t options)
{
  if (!options) {
    return 0;
  }
  uint64_t v4 = 0LL;
  __int16 v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 1;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_options_get_quic_use_legacy_codepoint_block_invoke;
  v3[3] = &unk_189665B68;
  v3[4] = &v4;
  sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
  BOOL v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_options_get_quic_use_legacy_codepoint_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 361) | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    if ((v2 & 0x2000000000LL) != 0) {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (v2 & 0x1000000000LL) != 0;
    }
  }

  return a2 != 0;
}

void sec_protocol_options_add_tls_application_protocol( sec_protocol_options_t options, const char *application_protocol)
{
  if (options)
  {
    if (application_protocol)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_add_tls_application_protocol_block_invoke;
      v2[3] = &__block_descriptor_tmp_18;
      void v2[4] = application_protocol;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }

BOOL __sec_protocol_options_add_tls_application_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(xpc_object_t *)(a2 + 48);
    if (!v4)
    {
      xpc_object_t v4 = xpc_array_create(0LL, 0LL);
      *(void *)(a2 + 4_Block_object_dispose((const void *)(v13 - 80), 8) = v4;
    }

    xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 32));
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_clear_tls_application_protocols(uint64_t result)
{
  if (result) {
    return sec_protocol_options_access_handle(result, (uint64_t)&__block_literal_global_20);
  }
  return result;
}

BOOL __sec_protocol_options_clear_tls_application_protocols_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    tls_protocol_version_t v3 = *(void **)(a2 + 48);
    if (v3) {
      xpc_release(v3);
    }
    *(void *)(a2 + 4_Block_object_dispose((const void *)(v13 - 80), 8) = 0LL;
  }

  return a2 != 0;
}

xpc_object_t sec_protocol_options_copy_transport_specific_application_protocol(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  _WORD v6[2] = __sec_protocol_options_copy_transport_specific_application_protocol_block_invoke;
  void v6[3] = &__block_descriptor_tmp_22;
  void v6[4] = v4;
  int v7 = a2;
  if ((sec_protocol_options_access_handle(a1, (uint64_t)v6) & 1) == 0)
  {
    xpc_release(v4);
    return 0LL;
  }

  return v4;
}

BOOL __sec_protocol_options_copy_transport_specific_application_protocol_block_invoke( uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  unint64_t v2 = *(void **)(a2 + 48);
  if (!v2) {
    return 0LL;
  }
  size_t count = xpc_array_get_count(*(xpc_object_t *)(a2 + 48));
  if (count)
  {
    size_t v5 = count;
    size_t v6 = 0LL;
    uint64_t v7 = MEMORY[0x1895F92E8];
    uint64_t v8 = MEMORY[0x1895F9220];
    do
    {
      xpc_object_t value = xpc_array_get_value(v2, v6);
      if (MEMORY[0x186E0087C]() == v7)
      {
        uint64_t v12 = *(void **)(a1 + 32);
        string_ptr = xpc_string_get_string_ptr(value);
      }

      else
      {
        if (MEMORY[0x186E0087C](value) != v8) {
          goto LABEL_12;
        }
        uint64_t uint64 = xpc_array_get_uint64(value, 1uLL);
        uint64_t v11 = *(unsigned int *)(a1 + 40);
        if ((_DWORD)v11)
        {
        }

        uint64_t v12 = *(void **)(a1 + 32);
        string_ptr = xpc_array_get_string(value, 0LL);
      }

      xpc_array_set_string(v12, 0xFFFFFFFFFFFFFFFFLL, string_ptr);
LABEL_12:
      ++v6;
    }

    while (v5 != v6);
  }

  return xpc_array_get_count(*(xpc_object_t *)(a1 + 32)) != 0;
}

void sec_protocol_options_set_tls_diffie_hellman_parameters( sec_protocol_options_t options, dispatch_data_t params)
{
  if (options)
  {
    if (params)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_tls_diffie_hellman_parameters_block_invoke;
      v2[3] = &__block_descriptor_tmp_24;
      void v2[4] = params;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }

BOOL __sec_protocol_options_set_tls_diffie_hellman_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(dispatch_object_s **)(a2 + 224);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a2 + 224) = *(void *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }

  return a2 != 0;
}

void sec_protocol_options_add_pre_shared_key( sec_protocol_options_t options, dispatch_data_t psk, dispatch_data_t psk_identity)
{
  if (options && psk)
  {
    if (psk_identity)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_add_pre_shared_key_block_invoke;
      v3[3] = &__block_descriptor_tmp_25;
      v3[4] = psk;
      void v3[5] = psk_identity;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }

BOOL __sec_protocol_options_add_pre_shared_key_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!*(void *)(a2 + 72)) {
      *(void *)(a2 + 72) = xpc_array_create(0LL, 0LL);
    }
    xpc_object_t v4 = xpc_data_create_with_dispatch_data(*(dispatch_data_t *)(a1 + 32));
    xpc_object_t v5 = xpc_data_create_with_dispatch_data(*(dispatch_data_t *)(a1 + 40));
    xpc_object_t v6 = xpc_array_create(0LL, 0LL);
    xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v4);
    xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v5);
    xpc_release(v4);
    xpc_release(v5);
    xpc_array_set_value(*(xpc_object_t *)(a2 + 72), 0xFFFFFFFFFFFFFFFFLL, v6);
    xpc_release(v6);
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_pre_shared_key_identity_hint( sec_protocol_options_t options, dispatch_data_t psk_identity_hint)
{
  if (options)
  {
    if (psk_identity_hint)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_tls_pre_shared_key_identity_hint_block_invoke;
      v2[3] = &__block_descriptor_tmp_26;
      void v2[4] = psk_identity_hint;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }

BOOL __sec_protocol_options_set_tls_pre_shared_key_identity_hint_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(dispatch_object_s **)(a2 + 80);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a2 + 80) = *(void *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }

  return a2 != 0;
}

void sec_protocol_options_set_pre_shared_key_selection_block( sec_protocol_options_t options, sec_protocol_pre_shared_key_selection_t psk_selection_block, dispatch_queue_t psk_selection_queue)
{
  if (options && psk_selection_block)
  {
    if (psk_selection_queue)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_pre_shared_key_selection_block_block_invoke;
      v3[3] = &unk_189665CB0;
      v3[4] = psk_selection_block;
      void v3[5] = psk_selection_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }

BOOL __sec_protocol_options_set_pre_shared_key_selection_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 256);
    if (v4) {
      _Block_release(v4);
    }
    xpc_object_t v5 = *(dispatch_object_s **)(a2 + 264);
    if (v5) {
      dispatch_release(v5);
    }
    xpc_object_t v6 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 256) = v6;
    *(void *)(a2 + 264) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_tickets_enabled(sec_protocol_options_t options, BOOL tickets_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_tickets_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_29;
    BOOL v3 = tickets_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_tickets_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFFFE7FF | (*(unsigned __int8 *)(a1 + 32) << 11) | 0x1000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFE7FFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_early_data_enabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_early_data_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_32_3193;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_early_data_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFE7FFFFF | (*(unsigned __int8 *)(a1 + 32) << 23) | 0x1000000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFE7FFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_quic_early_data_context(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 0x40000000LL;
    _DWORD v3[2] = __sec_protocol_options_set_quic_early_data_context_block_invoke;
    v3[3] = &__block_descriptor_tmp_33;
    v3[4] = a3;
    void v3[5] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v3);
  }

  return result;
}

BOOL __sec_protocol_options_set_quic_early_data_context_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(void **)(a2 + 336);
    if (v4)
    {
      free(v4);
      *(void *)(a2 + 352) = 0LL;
    }

    size_t v5 = *(void *)(a1 + 32);
    xpc_object_t v6 = malloc(v5);
    *(void *)(a2 + 336) = v6;
    if (v6)
    {
      memcpy(v6, *(const void **)(a1 + 40), v5);
      *(void *)(a2 + 352) = v5;
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_nw_protocol_joining_context(uint64_t result, uint64_t a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_nw_protocol_joining_context_block_invoke;
    v2[3] = &__block_descriptor_tmp_34;
    void v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_nw_protocol_joining_context_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 344) = *(void *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_sni_disabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_sni_disabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_35;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_sni_disabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFF9FLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFF9F | (32 * *(_BYTE *)(a1 + 32)) | 0x40;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_enforce_ev(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_enforce_ev_block_invoke;
    v2[3] = &__block_descriptor_tmp_36_3194;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_enforce_ev_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFF9FFFF | (*(unsigned __int8 *)(a1 + 32) << 17) | 0x40000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFF9FFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_ocsp_enabled(sec_protocol_options_t options, BOOL ocsp_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_ocsp_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_37;
    BOOL v3 = ocsp_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_ocsp_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFFE7FFF | (*(unsigned __int8 *)(a1 + 32) << 15) | 0x10000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFE7FFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_sct_enabled(sec_protocol_options_t options, BOOL sct_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_sct_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_38;
    BOOL v3 = sct_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_sct_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFFFF9FFF | (*(unsigned __int8 *)(a1 + 32) << 13) | 0x4000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFF9FFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_tls_renegotiation_enabled( sec_protocol_options_t options, BOOL renegotiation_enabled)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_renegotiation_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_39;
    BOOL v3 = renegotiation_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_tls_renegotiation_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    int v3 = v2 & 0xFF9FFFFF | (*(unsigned __int8 *)(a1 + 32) << 21) | 0x400000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFF9FFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }

  return a2 != 0;
}

void sec_protocol_options_set_peer_authentication_required( sec_protocol_options_t options, BOOL peer_authentication_required)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_peer_authentication_required_block_invoke;
    v2[3] = &__block_descriptor_tmp_40_3195;
    BOOL v3 = peer_authentication_required;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_peer_authentication_required_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFFBFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 26);
    *(_DWORD *)(a2 + 361) = v2 & 0xFBFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 26) | 0x10000000;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

void sec_protocol_options_set_peer_authentication_optional( sec_protocol_options_t options, BOOL peer_authentication_optional)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_peer_authentication_optional_block_invoke;
    v2[3] = &__block_descriptor_tmp_41;
    BOOL v3 = peer_authentication_optional;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_peer_authentication_optional_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFE7FFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 27);
    *(_DWORD *)(a2 + 361) = v2 & 0xE7FFFFFF | (*(unsigned __int8 *)(a1 + 32) << 27) | 0x10000000;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

void sec_protocol_options_set_enable_encrypted_client_hello( sec_protocol_options_t options, BOOL enable_encrypted_client_hello)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_enable_encrypted_client_hello_block_invoke;
    v2[3] = &__block_descriptor_tmp_42;
    BOOL v3 = enable_encrypted_client_hello;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_enable_encrypted_client_hello_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(_DWORD *)(a2 + 361) & 0xFDFFFFFF | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 25);
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0xFDFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 25);
    *(_BYTE *)(a2 + 365) = BYTE4(v2);
  }

  return a2 != 0;
}

void sec_protocol_options_set_quic_use_legacy_codepoint( sec_protocol_options_t options, BOOL quic_use_legacy_codepoint)
{
  if (options)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_quic_use_legacy_codepoint_block_invoke;
    v2[3] = &__block_descriptor_tmp_43_3196;
    BOOL v3 = quic_use_legacy_codepoint;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }

BOOL __sec_protocol_options_set_quic_use_legacy_codepoint_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFCFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 36) | 0x2000000000LL;
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

void sec_protocol_options_set_key_update_block( sec_protocol_options_t options, sec_protocol_key_update_t key_update_block, dispatch_queue_t key_update_queue)
{
  if (options)
  {
    if (key_update_queue)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_key_update_block_block_invoke;
      v3[3] = &unk_189665ED8;
      v3[4] = key_update_block;
      void v3[5] = key_update_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }

BOOL __sec_protocol_options_set_key_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 88);
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = *(dispatch_object_s **)(a2 + 96);
    if (v5) {
      dispatch_release(v5);
    }
    *(void *)(a2 + 8_Block_object_dispose((const void *)(v13 - 80), 8) = _Block_copy(*(const void **)(a1 + 32));
    xpc_object_t v6 = (dispatch_object_s *)_Block_copy(*(const void **)(a1 + 40));
    *(void *)(a2 + 96) = v6;
    dispatch_retain(v6);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_session_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_session_update_block_block_invoke;
      v3[3] = &unk_189665F50;
      v3[4] = a2;
      void v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_session_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 176);
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = *(dispatch_object_s **)(a2 + 184);
    if (v5) {
      dispatch_release(v5);
    }
    xpc_object_t v6 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 176) = v6;
    *(void *)(a2 + 184) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_encryption_secret_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_tls_encryption_secret_update_block_block_invoke;
      v3[3] = &unk_189665F78;
      v3[4] = a2;
      void v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_encryption_secret_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 144);
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = *(dispatch_object_s **)(a2 + 152);
    if (v5) {
      dispatch_release(v5);
    }
    xpc_object_t v6 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 144) = v6;
    *(void *)(a2 + 152) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_encryption_level_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_set_tls_encryption_level_update_block_block_invoke;
      v3[3] = &unk_189665FA0;
      v3[4] = a2;
      void v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_encryption_level_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 160);
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = *(dispatch_object_s **)(a2 + 168);
    if (v5) {
      dispatch_release(v5);
    }
    xpc_object_t v6 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 160) = v6;
    *(void *)(a2 + 16_Block_object_dispose((const void *)(v13 - 80), 8) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_session_state(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_session_state_block_invoke;
      v2[3] = &__block_descriptor_tmp_50;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_session_state_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(dispatch_object_s **)(a2 + 192);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a2 + 192) = *(void *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_quic_transport_parameters(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_quic_transport_parameters_block_invoke;
      v2[3] = &__block_descriptor_tmp_51;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_quic_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(dispatch_object_s **)(a2 + 136);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a2 + 136) = *(void *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_required(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_ats_required_block_invoke;
    v2[3] = &__block_descriptor_tmp_52;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_ats_required_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0xFFFFFFFE | *(unsigned __int8 *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_rsa_key_size(uint64_t result, uint64_t a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_minimum_rsa_key_size_block_invoke;
    v2[3] = &__block_descriptor_tmp_53;
    void v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_minimum_rsa_key_size_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 304) = *(void *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_ecdsa_key_size(uint64_t result, uint64_t a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke;
    v2[3] = &__block_descriptor_tmp_54_3198;
    void v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 312) = *(void *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_signature_algorithm(uint64_t result, int a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_minimum_signature_algorithm_block_invoke;
    v2[3] = &__block_descriptor_tmp_55_3199;
    int v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_minimum_signature_algorithm_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_DWORD *)(a2 + 320) = *(_DWORD *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_trusted_peer_certificate(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_trusted_peer_certificate_block_invoke;
    v2[3] = &__block_descriptor_tmp_56;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_trusted_peer_certificate_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFE7LL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFE7 | (8 * *(_BYTE *)(a1 + 32)) | 0x10;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_private_key_blocks(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result && a2 && a3)
  {
    if (a4)
    {
      v4[0] = MEMORY[0x1895F87A8];
      v4[1] = 0x40000000LL;
      unint64_t v4[2] = __sec_protocol_options_set_private_key_blocks_block_invoke;
      unint64_t v4[3] = &unk_1896660A8;
      unint64_t v4[4] = a2;
      void v4[5] = a3;
      v4[6] = a4;
      return sec_protocol_options_access_handle(result, (uint64_t)v4);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_private_key_blocks_block_invoke(uint64_t a1, void *a2)
{
  if (a2)
  {
    xpc_object_t v4 = (const void *)a2[25];
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = (const void *)a2[26];
    if (v5) {
      _Block_release(v5);
    }
    xpc_object_t v6 = (dispatch_object_s *)a2[27];
    if (v6) {
      dispatch_release(v6);
    }
    a2[25] = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v8 = *(dispatch_object_s **)(a1 + 48);
    a2[26] = v7;
    a2[27] = v8;
    dispatch_retain(v8);
  }

  return a2 != 0LL;
}

uint64_t sec_protocol_options_set_local_certificates(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_local_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_58;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_local_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(void **)(a2 + 64);
    if (v4) {
      os_release(v4);
    }
    size_t v5 = *(void **)(a1 + 32);
    *(void *)(a2 + 64) = v5;
    if (v5) {
      os_retain(v5);
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_certificate_compression_enabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_certificate_compression_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_59;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_certificate_compression_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(unsigned int *)(a2 + 361) | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | 0x40000000;
    *(_DWORD *)(a2 + 361) |= 0x40000000u;
    unint64_t v3 = v2 & 0xFFDFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 29);
    *(_DWORD *)(a2 + 361) = v3;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_output_handler_access_block(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_output_handler_access_block_block_invoke;
      v2[3] = &unk_189666110;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_output_handler_access_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 32_Block_object_dispose((const void *)(v13 - 80), 8) = _Block_copy(*(const void **)(a1 + 32));
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_tls_handshake_message_callback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 0x40000000LL;
      _DWORD v3[2] = __sec_protocol_options_tls_handshake_message_callback_block_invoke;
      v3[3] = &unk_189666138;
      v3[4] = a2;
      void v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }

  return result;
}

BOOL __sec_protocol_options_tls_handshake_message_callback_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(const void **)(a2 + 240);
    if (v4) {
      _Block_release(v4);
    }
    size_t v5 = *(dispatch_object_s **)(a2 + 248);
    if (v5) {
      dispatch_release(v5);
    }
    xpc_object_t v6 = _Block_copy(*(const void **)(a1 + 32));
    uint64_t v7 = *(dispatch_object_s **)(a1 + 40);
    *(void *)(a2 + 240) = v6;
    *(void *)(a2 + 24_Block_object_dispose((const void *)(v13 - 80), 8) = v7;
    dispatch_retain(v7);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_eddsa_enabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_eddsa_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_62;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_eddsa_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = *(_DWORD *)(a2 + 361) & 0x7FFFFFFF | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 31);
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0x7FFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 31);
    *(_BYTE *)(a2 + 365) = BYTE4(v2);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_delegated_credentials_enabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_delegated_credentials_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_63;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_delegated_credentials_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFFEFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 32);
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_grease_enabled(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_grease_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_64;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_grease_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFFDFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 33);
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_allow_unknown_alpn_protos(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_allow_unknown_alpn_protos_block_invoke;
    v2[3] = &__block_descriptor_tmp_65;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_allow_unknown_alpn_protos_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFF3FFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 34) | 0x800000000LL;
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_experiment_identifier(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_experiment_identifier_block_invoke;
      v2[3] = &__block_descriptor_tmp_66;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_experiment_identifier_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(void **)(a2 + 16);
    if (v4) {
      free(v4);
    }
    size_t v5 = *(const char **)(a1 + 32);
    if (v5) {
      *(void *)(a2 + 16) = strdup(v5);
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_connection_id(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_connection_id_block_invoke;
      v2[3] = &__block_descriptor_tmp_67;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_OWORD *)(a2 + 24) = *(_OWORD *)*(void *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_ticket_request_count(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_ticket_request_count_block_invoke;
    v2[3] = &__block_descriptor_tmp_68;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_ticket_request_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(a2 + 324) = *(_BYTE *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke;
    v2[3] = &__block_descriptor_tmp_69;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFBLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFFB | (4 * (*(_BYTE *)(a1 + 32) & 0x3F));
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_minimum_tls_version_allowed(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke;
    v2[3] = &__block_descriptor_tmp_70;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 361);
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFDLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFFD | (2 * (*(_BYTE *)(a1 + 32) & 0x7F));
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_append_tls_key_exchange_group(uint64_t result, __int16 a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_71;
    __int16 v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_append_tls_key_exchange_group_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    xpc_object_t v4 = *(xpc_object_t *)(a2 + 232);
    if (!v4)
    {
      xpc_object_t v4 = xpc_array_create(0LL, 0LL);
      *(void *)(a2 + 232) = v4;
    }

    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a1 + 32));
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_add_tls_key_exchange_group(uint64_t result, __int16 a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_71;
    __int16 v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

uint64_t sec_protocol_options_append_tls_key_exchange_group_set(uint64_t result, __int16 a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    v2[3] = &__block_descriptor_tmp_72;
    __int16 v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!*(void *)(a2 + 232)) {
      *(void *)(a2 + 232) = xpc_array_create(0LL, 0LL);
    }
    unint64_t v4 = *(unsigned __int16 *)(a1 + 32);
    if (v4 <= 2)
    {
      uint64_t v5 = qword_180652EB0[v4];
      xpc_object_t v6 = (unsigned __int16 *)*(&off_189667160 + v4);
      do
      {
        unsigned int v7 = *v6++;
        xpc_array_set_uint64(*(xpc_object_t *)(a2 + 232), 0xFFFFFFFFFFFFFFFFLL, v7);
        --v5;
      }

      while (v5);
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_options_add_tls_key_exchange_group_set(uint64_t result, int a2)
{
  if (a2 == 2)
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = MEMORY[0x1895F87A8];
    uint64_t v4 = 0x40000000LL;
    uint64_t v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    xpc_object_t v6 = &__block_descriptor_tmp_72;
    __int16 v2 = 2;
LABEL_10:
    __int16 v7 = v2;
    return sec_protocol_options_access_handle(result, (uint64_t)&v3);
  }

  if (a2 == 1)
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = MEMORY[0x1895F87A8];
    uint64_t v4 = 0x40000000LL;
    uint64_t v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    xpc_object_t v6 = &__block_descriptor_tmp_72;
    __int16 v2 = 1;
    goto LABEL_10;
  }

  if (!a2 && result)
  {
    uint64_t v3 = MEMORY[0x1895F87A8];
    uint64_t v4 = 0x40000000LL;
    uint64_t v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    xpc_object_t v6 = &__block_descriptor_tmp_72;
    __int16 v7 = 0;
    return sec_protocol_options_access_handle(result, (uint64_t)&v3);
  }

  return result;
}

const char *__cdecl sec_protocol_metadata_get_server_name(sec_protocol_metadata_t metadata)
{
  if (!metadata) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_server_name_block_invoke;
  v3[3] = &unk_1896662E8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  BOOL v1 = (const char *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_server_name_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 48);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_time_ms(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_time_ms_block_invoke;
  v3[3] = &unk_189666310;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_time_ms_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 264);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_byte_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_byte_count_block_invoke;
  v3[3] = &unk_189666338;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 272);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_sent_byte_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_sent_byte_count_block_invoke;
  v3[3] = &unk_189666360;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_sent_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 280);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_received_byte_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_received_byte_count_block_invoke;
  v3[3] = &unk_189666388;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_received_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 288);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_read_stall_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_read_stall_count_block_invoke;
  v3[3] = &unk_1896663B0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_read_stall_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 296);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_write_stall_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_write_stall_count_block_invoke;
  v3[3] = &unk_1896663D8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_write_stall_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 304);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_async_call_count(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_async_call_count_block_invoke;
  v3[3] = &unk_189666400;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_async_call_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 312);
  }
  return a2 != 0;
}

dispatch_data_t sec_protocol_metadata_copy_peer_public_key(sec_protocol_metadata_t metadata)
{
  if (!metadata) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_copy_peer_public_key_block_invoke;
  v3[3] = &unk_189666478;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  uint64_t v1 = (dispatch_data_s *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_peer_public_key_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 104);
    uint64_t v3 = *(dispatch_object_s **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v3) {
      dispatch_retain(v3);
    }
  }

  return a2 != 0;
}

BOOL sec_protocol_metadata_get_early_data_accepted(sec_protocol_metadata_t metadata)
{
  if (metadata) {
    LOBYTE(metadata) = sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)&__block_literal_global_90);
  }
  return (char)metadata;
}

uint64_t __sec_protocol_metadata_get_early_data_accepted_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(unsigned __int16 *)(a2 + 328) >> 3) & 1;
  }
  else {
    return 0LL;
  }
}

BOOL sec_protocol_metadata_access_supported_signature_algorithms( sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke;
    unint64_t v4[3] = &unk_189666580;
    unint64_t v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a2 + 112);
  if (result)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke_2;
    applier[3] = &unk_189666558;
    applier[4] = *(void *)(a1 + 32);
    xpc_array_apply((xpc_object_t)result, applier);
    return 1LL;
  }

  return result;
}

uint64_t __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke_2( uint64_t a1, int a2, xpc_object_t xuint)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned __int16 value = xpc_uint64_get_value(xuint);
  (*(void (**)(uint64_t, void))(v3 + 16))(v3, value);
  return 1LL;
}

BOOL sec_protocol_metadata_access_ocsp_response(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_ocsp_response_block_invoke;
    unint64_t v4[3] = &unk_1896665D0;
    unint64_t v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_access_ocsp_response_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a2 + 136);
  if (result)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_ocsp_response_block_invoke_2;
    unint64_t v4[3] = &unk_1896665A8;
    unint64_t v4[4] = *(void *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1LL;
  }

  return result;
}

uint64_t __sec_protocol_metadata_access_ocsp_response_block_invoke_2(uint64_t a1)
{
  return 1LL;
}

uint64_t __sec_protocol_metadata_access_distinguished_names_block_invoke_2(uint64_t a1)
{
  return 1LL;
}

BOOL sec_protocol_metadata_access_pre_shared_keys(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_pre_shared_keys_block_invoke;
    unint64_t v4[3] = &unk_189666670;
    unint64_t v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_access_pre_shared_keys_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a2 + 96);
  if (result)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __sec_protocol_metadata_access_pre_shared_keys_block_invoke_2;
    applier[3] = &unk_189666648;
    applier[4] = *(void *)(a1 + 32);
    xpc_array_apply((xpc_object_t)result, applier);
    return 1LL;
  }

  return result;
}

uint64_t __sec_protocol_metadata_access_pre_shared_keys_block_invoke_2( uint64_t a1, int a2, xpc_object_t xarray)
{
  if (xpc_array_get_count(xarray) != 2) {
    return 1LL;
  }
  unsigned __int16 value = (dispatch_data_s *)xpc_array_get_value(xarray, 0LL);
  uint64_t v6 = (dispatch_data_s *)xpc_array_get_value(xarray, 1uLL);
  dispatch_data_t dispatch_data_from_xpc_data = create_dispatch_data_from_xpc_data(value);
  dispatch_data_t v8 = create_dispatch_data_from_xpc_data(v6);
  uint64_t result = 0LL;
  if (dispatch_data_from_xpc_data && v8)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    return 1LL;
  }

  return result;
}

dispatch_data_t create_dispatch_data_from_xpc_data(dispatch_data_s *xdata)
{
  dispatch_data_t v1 = xdata;
  if (xdata)
  {
    size_t length = xpc_data_get_length(xdata);
    if (length && (v3 = length, (uint64_t v4 = malloc(length)) != 0LL))
    {
      uint64_t v5 = v4;
      size_t bytes = xpc_data_get_bytes(v1, v4, 0LL, v3);
      dispatch_data_t v1 = 0LL;
      if (bytes == v3) {
        dispatch_data_t v1 = dispatch_data_create(v5, v3, 0LL, 0LL);
      }
      free(v5);
    }

    else
    {
      return 0LL;
    }
  }

  return v1;
}

BOOL sec_protocol_metadata_peers_are_equal( sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  BOOL v2 = 0;
  if (metadataA && metadataB)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_peers_are_equal_block_invoke;
    unint64_t v4[3] = &__block_descriptor_tmp_101;
    unint64_t v4[4] = metadataB;
    return sec_protocol_metadata_access_handle((uint64_t)metadataA, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_peers_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __sec_protocol_metadata_peers_are_equal_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_100;
  unint64_t v4[4] = a2;
  return sec_protocol_metadata_access_handle(v2, (uint64_t)v4);
}

BOOL __sec_protocol_metadata_peers_are_equal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 88LL);
  uint64_t v5 = *(void **)(a2 + 88);
  size_t count = sec_array_get_count(v4);
  if (count != sec_array_get_count(v5)) {
    return 0LL;
  }
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 1;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  v9[2] = __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke;
  unint64_t v9[3] = &unk_189666CA8;
  v9[4] = &v10;
  v9[5] = v5;
  sec_array_apply(v4, v9);
  int v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v7) {
    return 0LL;
  }
  BOOL result = sec_protocol_dispatch_data_are_equal( *(dispatch_data_t *)(*(void *)(a1 + 32) + 104LL),  *(dispatch_data_s **)(a2 + 104));
  if (result)
  {
    BOOL result = sec_protocol_xpc_object_are_equal(*(void *)(*(void *)(a1 + 32) + 112LL), *(void *)(a2 + 112));
    if (result)
    {
      BOOL result = sec_protocol_sec_array_of_dispatch_data_are_equal( *(void **)(*(void *)(a1 + 32) + 136LL),  *(void **)(a2 + 136));
      if (result) {
        return sec_protocol_sec_array_of_dispatch_data_are_equal( *(void **)(*(void *)(a1 + 32) + 144LL),  *(void **)(a2 + 144));
      }
    }
  }

  return result;
}

BOOL __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke_2;
  v5[3] = &unk_189666C80;
  void v5[5] = a2;
  void v5[6] = a3;
  size_t v3 = *(void **)(a1 + 40);
  v5[4] = *(void *)(a1 + 32);
  return sec_array_apply(v3, v5);
}

BOOL sec_protocol_dispatch_data_are_equal(dispatch_data_t data, dispatch_data_s *a2)
{
  BOOL v2 = data == a2;
  if (data != a2 && data && a2)
  {
    size_t size = dispatch_data_get_size(data);
    if (size == dispatch_data_get_size(a2))
    {
      uint64_t v8 = 0LL;
      uint64_t v9 = &v8;
      uint64_t v10 = 0x2000000000LL;
      char v11 = 1;
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 0x40000000LL;
      void v7[2] = __sec_protocol_dispatch_data_are_equal_block_invoke;
      v7[3] = &unk_189666CF8;
      _OWORD v7[4] = &v8;
      v7[5] = a2;
      dispatch_data_apply(data, v7);
      BOOL v2 = *((_BYTE *)v9 + 24) != 0;
      _Block_object_dispose(&v8, 8);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

BOOL sec_protocol_xpc_object_are_equal(unint64_t a1, unint64_t a2)
{
  if (!a1 && a2 || a1 && !a2) {
    return 0LL;
  }
  if (a1 | a2) {
    return xpc_equal((xpc_object_t)a1, (xpc_object_t)a2);
  }
  return 1LL;
}

BOOL sec_protocol_sec_array_of_dispatch_data_are_equal(void *a1, void *a2)
{
  size_t count = sec_array_get_count(a1);
  if (count != sec_array_get_count(a2)) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  char v11 = 1;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  void v7[2] = __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke;
  v7[3] = &unk_189666D48;
  _OWORD v7[4] = &v8;
  v7[5] = a2;
  sec_array_apply(a1, v7);
  BOOL v5 = *((_BYTE *)v9 + 24) != 0;
  _Block_object_dispose(&v8, 8);
  return v5;
}

BOOL __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke_2;
  v5[3] = &unk_189666D20;
  void v5[5] = a2;
  void v5[6] = a3;
  size_t v3 = *(void **)(a1 + 40);
  v5[4] = *(void *)(a1 + 32);
  return sec_array_apply(v3, v5);
}

BOOL __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke_2( uint64_t a1, uint64_t a2, dispatch_data_s *a3)
{
  if (*(void *)(a1 + 40) != a2) {
    return 1LL;
  }
  BOOL v4 = sec_protocol_dispatch_data_are_equal(*(dispatch_data_t *)(a1 + 48), a3);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v5 + 24)) {
    BOOL v6 = v4;
  }
  else {
    BOOL v6 = 0;
  }
  *(_BYTE *)(v5 + 24) = v6;
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0;
}

uint64_t __sec_protocol_dispatch_data_are_equal_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  v8[2] = __sec_protocol_dispatch_data_are_equal_block_invoke_2;
  unint64_t v8[3] = &unk_189666CD0;
  BOOL v6 = *(dispatch_data_s **)(a1 + 40);
  unint64_t v8[4] = *(void *)(a1 + 32);
  v8[5] = a3;
  void v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

BOOL __sec_protocol_dispatch_data_are_equal_block_invoke_2( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a1[5];
  }
  unint64_t v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3) {
    unint64_t v10 = a5 + a3;
  }
  else {
    unint64_t v10 = v6 + v7;
  }
  BOOL v11 = v10 > v8;
  size_t v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = memcmp( (const void *)(a4 + v8 - a3),  (const void *)(a1[7] + v8 - v7),  v12) == 0;
  }

  else
  {
    if (v9 < a3) {
      return 0LL;
    }
    if (a5 + a3 < v7) {
      return 1LL;
    }
  }

  return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
}

uint64_t __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke_2( void *a1, uint64_t a2, uint64_t a3)
{
  if (a1[5] != a2) {
    return 1LL;
  }
  uint64_t v5 = a1[6];
  if (v5 && (uint64_t v6 = *(const void **)(v5 + 8)) != 0LL)
  {
    CFTypeRef v7 = CFRetain(v6);
    if (!a3) {
      goto LABEL_12;
    }
  }

  else
  {
    CFTypeRef v7 = 0LL;
    if (!a3)
    {
LABEL_12:
      BOOL v13 = 0;
      BOOL v11 = 0LL;
      BOOL v12 = v7 == 0LL;
      goto LABEL_13;
    }
  }

  unint64_t v9 = *(const void **)(a3 + 8);
  if (!v9) {
    goto LABEL_12;
  }
  CFTypeRef v10 = CFRetain(v9);
  BOOL v11 = v10;
  BOOL v12 = v7 == 0LL;
  BOOL v13 = v10 != 0LL;
  if (!v7 && v10)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
LABEL_23:
    CFRelease(v11);
    return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
  }

BOOL sec_protocol_metadata_challenge_parameters_are_equal( sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  BOOL v2 = 0;
  if (metadataA && metadataB)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke;
    unint64_t v4[3] = &__block_descriptor_tmp_103;
    unint64_t v4[4] = metadataB;
    return sec_protocol_metadata_access_handle((uint64_t)metadataA, (uint64_t)v4);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_102;
  unint64_t v4[4] = a2;
  return sec_protocol_metadata_access_handle(v2, (uint64_t)v4);
}

BOOL __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return a2
      && sec_protocol_xpc_object_are_equal(*(void *)(*(void *)(a1 + 32) + 112LL), *(void *)(a2 + 112))
      && sec_protocol_sec_array_of_dispatch_data_are_equal( *(void **)(*(void *)(a1 + 32) + 144LL),  *(void **)(a2 + 144))
      && sec_protocol_dispatch_data_are_equal( *(dispatch_data_t *)(*(void *)(a1 + 32) + 120LL),  *(dispatch_data_s **)(a2 + 120));
}

dispatch_data_t sec_protocol_metadata_create_secret( sec_protocol_metadata_t metadata, size_t label_len, const char *label, size_t exporter_length)
{
  BOOL v4 = 0LL;
  if (metadata && label_len && label && exporter_length)
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    uint64_t v10 = 0LL;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    _WORD v6[2] = __sec_protocol_metadata_create_secret_block_invoke;
    void v6[3] = &unk_189666718;
    void v6[4] = &v7;
    void v6[5] = label_len;
    v6[6] = label;
    void v6[7] = exporter_length;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v6);
    BOOL v4 = (dispatch_data_s *)v8[3];
    _Block_object_dispose(&v7, 8);
  }

  return v4;
}

BOOL __sec_protocol_metadata_create_secret_block_invoke(void *a1, void *a2)
{
  if (a2)
  {
    size_t v3 = (uint64_t (*)(void, void, void, void, void, void))a2[1];
    if (v3)
    {
      if (*a2) {
        *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3(*a2, a1[5], a1[6], 0LL, 0LL, a1[7]);
      }
    }
  }

  return a2 != 0LL;
}

dispatch_data_t sec_protocol_metadata_create_secret_with_context( sec_protocol_metadata_t metadata, size_t label_len, const char *label, size_t context_len, const uint8_t *context, size_t exporter_length)
{
  uint64_t v6 = 0LL;
  if (metadata && label_len && label && context_len && context && exporter_length)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    uint64_t v12 = 0LL;
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    v8[2] = __sec_protocol_metadata_create_secret_with_context_block_invoke;
    unint64_t v8[3] = &unk_189666740;
    unint64_t v8[4] = &v9;
    v8[5] = label_len;
    void v8[6] = label;
    v8[7] = context_len;
    void v8[8] = context;
    void v8[9] = exporter_length;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v8);
    uint64_t v6 = (dispatch_data_s *)v10[3];
    _Block_object_dispose(&v9, 8);
  }

  return v6;
}

BOOL __sec_protocol_metadata_create_secret_with_context_block_invoke(void *a1, void *a2)
{
  if (a2)
  {
    size_t v3 = (uint64_t (*)(void, void, void, void, void, void))a2[1];
    if (v3)
    {
      if (*a2) {
        *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3(*a2, a1[5], a1[6], a1[7], a1[8], a1[9]);
      }
    }
  }

  return a2 != 0LL;
}

uint64_t sec_protocol_metadata_get_tls_false_start_used(uint64_t result)
{
  if (result) {
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_107);
  }
  return result;
}

uint64_t __sec_protocol_metadata_get_tls_false_start_used_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(unsigned __int16 *)(a2 + 328) >> 4) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sec_protocol_metadata_get_ticket_offered(uint64_t result)
{
  if (result) {
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_109_3203);
  }
  return result;
}

uint64_t __sec_protocol_metadata_get_ticket_offered_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(unsigned __int16 *)(a2 + 328) >> 5) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sec_protocol_metadata_get_ticket_received(uint64_t result)
{
  if (result) {
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_111);
  }
  return result;
}

uint64_t __sec_protocol_metadata_get_ticket_received_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(unsigned __int16 *)(a2 + 328) >> 6) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sec_protocol_metadata_get_session_resumed(uint64_t result)
{
  if (result) {
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_113);
  }
  return result;
}

uint64_t __sec_protocol_metadata_get_session_resumed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(unsigned __int16 *)(a2 + 328) >> 7) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sec_protocol_metadata_get_session_renewed(uint64_t result)
{
  if (result) {
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_115);
  }
  return result;
}

uint64_t __sec_protocol_metadata_get_session_renewed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return HIBYTE(*(unsigned __int16 *)(a2 + 328)) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sec_protocol_metadata_get_connection_strength(uint64_t a1)
{
  uint64_t v1 = 2LL;
  if (a1)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = &v4;
    uint64_t v6 = 0x2000000000LL;
    int v7 = 2;
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 0x40000000LL;
    _DWORD v3[2] = __sec_protocol_metadata_get_connection_strength_block_invoke;
    v3[3] = &unk_1896668A8;
    v3[4] = &v4;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
    uint64_t v1 = *((unsigned int *)v5 + 6);
    _Block_object_dispose(&v4, 8);
  }

  return v1;
}

BOOL __sec_protocol_metadata_get_connection_strength_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v2 = *(unsigned __int16 *)(a2 + 32);
    if (v2 < 0x303)
    {
      int v3 = v2 - 769 > 1 ? 2 : 1;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
    }

    else
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    }

    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    if (*(_DWORD *)(v4 + 24) != 2)
    {
      uint64_t v5 = 0LL;
      int v6 = *(unsigned __int16 *)(a2 + 34);
      do
        int v7 = (unsigned __int16)Listtls_ciphersuite_group_legacy[v5];
      while (v7 != v6 && v5++ != 6);
      if (v7 == v6) {
        *(_DWORD *)(v4 + 24) = 1;
      }
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_serialized_session(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_copy_serialized_session_block_invoke;
  v3[3] = &unk_1896668D0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_serialized_session_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(uint64_t (**)(void))(a2 + 24);
    if (v3)
    {
      if (*(void *)(a2 + 16)) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3();
      }
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_authenticator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0LL;
  if (a1 && a2)
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    uint64_t v10 = 0LL;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    _WORD v6[2] = __sec_protocol_metadata_copy_authenticator_block_invoke;
    void v6[3] = &unk_1896668F8;
    void v6[4] = &v7;
    void v6[5] = a2;
    v6[6] = a3;
    void v6[7] = a4;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v6);
    uint64_t v4 = v8[3];
    _Block_object_dispose(&v7, 8);
  }

  return v4;
}

BOOL __sec_protocol_metadata_copy_authenticator_block_invoke(void *a1, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(uint64_t (**)(uint64_t, void, void, void))(a2 + 336);
    if (v3)
    {
      uint64_t v5 = *(void *)(a2 + 352);
      if (v5) {
        *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3(v5, a1[5], a1[6], a1[7]);
      }
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_authenticator_trust( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0LL;
  if (a1 && a2 && a3)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = 0LL;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __sec_protocol_metadata_copy_authenticator_trust_block_invoke;
    v7[3] = &unk_189666920;
    _OWORD v7[4] = &v8;
    v7[5] = a2;
    void v7[6] = a3;
    v7[7] = a4;
    v7[8] = a5;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v7);
    uint64_t v5 = v9[3];
    _Block_object_dispose(&v8, 8);
  }

  return v5;
}

BOOL __sec_protocol_metadata_copy_authenticator_trust_block_invoke(void *a1, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(uint64_t (**)(uint64_t, void, void, void, void))(a2 + 344);
    if (v3)
    {
      uint64_t v5 = *(void *)(a2 + 352);
      if (v5) {
        *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3(v5, a1[5], a1[6], a1[7], a1[8]);
      }
    }
  }

  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_experiment_identifier(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_experiment_identifier_block_invoke;
  v3[3] = &unk_189666948;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_experiment_identifier_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 56);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_connection_id(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_metadata_copy_connection_id_block_invoke;
      v2[3] = &__block_descriptor_tmp_121;
      void v2[4] = a2;
      return sec_protocol_metadata_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

BOOL __sec_protocol_metadata_copy_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_OWORD *)*(void *)(a1 + 32) = *(_OWORD *)(a2 + 64);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_serialize_with_options(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    xpc_object_t v10 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v8[3])
    {
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 0x40000000LL;
      _WORD v6[2] = __sec_protocol_metadata_serialize_with_options_block_invoke;
      void v6[3] = &unk_1896669B8;
      void v6[4] = &v7;
      void v6[5] = a2;
      sec_protocol_metadata_access_handle(a1, (uint64_t)v6);
      uint64_t v2 = v8[3];
    }

    else
    {
      uint64_t v2 = 0LL;
    }

    _Block_object_dispose(&v7, 8);
  }

  return v2;
}

uint64_t __sec_protocol_metadata_serialize_with_options_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __sec_protocol_metadata_serialize_with_options_block_invoke_2;
  unint64_t v4[3] = &unk_189666990;
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v4[4] = *(void *)(a1 + 32);
  void v4[5] = a2;
  return sec_protocol_options_access_handle(v2, (uint64_t)v4);
}

BOOL __sec_protocol_metadata_serialize_with_options_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v5 = *(void **)(v4 + 24);
    if ((*(_WORD *)(v3 + 328) & 1) != 0)
    {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(v4 + 24), "alert_type", *(void *)(v3 + 216));
      xpc_dictionary_set_uint64(v5, "alert_code", *(void *)(v3 + 224));
      xpc_dictionary_set_uint64(v5, "handshake_state", *(void *)(v3 + 232));
      xpc_dictionary_set_uint64(v5, "stack_error", *(void *)(v3 + 240));
    }

    else
    {
      _serialize_options(*(void **)(v4 + 24), a2);
      xpc_dictionary_set_uint64(v5, "cipher_name", *(unsigned __int16 *)(v3 + 34));
      xpc_dictionary_set_uint64(v5, "version", *(unsigned __int16 *)(v3 + 32));
      xpc_dictionary_set_uint64(v5, "ticket_lifetime", *(void *)(v3 + 200));
      if (*(void *)(v3 + 184)) {
        uint64_t v6 = *(const char **)(v3 + 184);
      }
      else {
        uint64_t v6 = "none";
      }
      xpc_dictionary_set_string(v5, "peer_public_key_type", v6);
      if (*(void *)(v3 + 176)) {
        uint64_t v7 = *(const char **)(v3 + 176);
      }
      else {
        uint64_t v7 = "none";
      }
      xpc_dictionary_set_string(v5, "neg_curve", v7);
      if (*(void *)(v3 + 192)) {
        uint64_t v8 = *(const char **)(v3 + 192);
      }
      else {
        uint64_t v8 = "none";
      }
      xpc_dictionary_set_string(v5, "cert_request_type", v8);
      if (*(void *)(v3 + 40)) {
        uint64_t v9 = *(const char **)(v3 + 40);
      }
      else {
        uint64_t v9 = "none";
      }
      xpc_dictionary_set_string(v5, "negotiated_protocol", v9);
      xpc_dictionary_set_BOOL(v5, "false_start_used", (*(_WORD *)(v3 + 328) & 0x10) != 0);
      xpc_dictionary_set_BOOL(v5, "session_resumed", (*(_WORD *)(v3 + 328) & 0x80) != 0);
      xpc_dictionary_set_BOOL(v5, "ticket_offered", (*(_WORD *)(v3 + 328) & 0x20) != 0);
      xpc_dictionary_set_BOOL(v5, "ticket_received", (*(_WORD *)(v3 + 328) & 0x40) != 0);
      xpc_dictionary_set_BOOL(v5, "session_renewed", *(_WORD *)(v3 + 328) & 0x100);
      xpc_dictionary_set_BOOL(v5, "resumption_attempted", (*(_WORD *)(v3 + 328) & 0x200) != 0);
      xpc_dictionary_set_BOOL(v5, "alpn_used", (*(_WORD *)(v3 + 328) & 0x400) != 0);
      xpc_dictionary_set_BOOL(v5, "npn_used", (*(_WORD *)(v3 + 328) & 0x800) != 0);
      xpc_dictionary_set_BOOL(v5, "ocsp_enabled", (*(_WORD *)(v3 + 328) & 4) != 0);
      xpc_dictionary_set_BOOL(v5, "ocsp_received", *(void *)(v3 + 136) != 0LL);
      xpc_dictionary_set_BOOL(v5, "sct_enabled", (*(_WORD *)(v3 + 328) & 2) != 0);
      xpc_dictionary_set_BOOL(v5, "sct_received", *(void *)(v3 + 128) != 0LL);
    }
  }

  return a2 != 0LL;
}

void _serialize_options(void *a1, unsigned __int16 *a2)
{
  xpc_dictionary_set_BOOL(a1, "ats_minimum_tls_version_allowed", (*(_DWORD *)((_BYTE *)a2 + 361) & 2LL) != 0);
  xpc_dictionary_set_BOOL(a1, "ats_non_pfs_ciphersuite_allowed", (*(_DWORD *)((_BYTE *)a2 + 361) & 4LL) != 0);
  xpc_dictionary_set_BOOL(a1, "trusted_peer_certificate", (*(_DWORD *)((_BYTE *)a2 + 361) & 8LL) != 0);
  xpc_dictionary_set_BOOL(a1, "disable_sni", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_fallback_attempt", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x80LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_false_start", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x200LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_tickets", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x800LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_sct", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_ocsp", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x8000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enforce_ev", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_ech", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000000) != 0LL);
  xpc_dictionary_set_BOOL(a1, "enable_resumption", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x80000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_renegotiation", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x200000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_early_data", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x800000LL) != 0);
  xpc_dictionary_set_BOOL(a1, "quic_use_legacy_codepoint", (*((_BYTE *)a2 + 365) & 0x10) != 0);
  xpc_dictionary_set_BOOL(a1, "peer_authentication_required", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x4000000) != 0LL);
  xpc_dictionary_set_BOOL(a1, "peer_authentication_optional", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x8000000) != 0LL);
  xpc_dictionary_set_BOOL(a1, "certificate_compression_enabled", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20000000) != 0LL);
  xpc_dictionary_set_BOOL(a1, "eddsa_enabled", *(int *)((char *)a2 + 361) < 0);
  xpc_dictionary_set_BOOL(a1, "tls_delegated_credentials_enabled", *((_BYTE *)a2 + 365) & 1);
  xpc_dictionary_set_BOOL(a1, "tls_grease_enabled", (*((_BYTE *)a2 + 365) & 2) != 0);
}

uint64_t sec_protocol_metadata_copy_quic_transport_parameters(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_copy_quic_transport_parameters_block_invoke;
  v3[3] = &unk_1896669E0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_quic_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 152);
    if (v3)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
      dispatch_retain(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    }
  }

  return a2 != 0;
}

BOOL sec_protocol_metadata_get_tls_certificate_compression_used(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_tls_certificate_compression_used_block_invoke;
  v3[3] = &unk_189666A08;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  BOOL v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_certificate_compression_used_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_WORD *)(a2 + 328) & 0x2000) != 0;
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_tls_certificate_compression_algorithm(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  __int16 v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_tls_certificate_compression_algorithm_block_invoke;
  v3[3] = &unk_189666A30;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int16 *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_certificate_compression_algorithm_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_WORD *)(a2 + 256);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_rtt(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_handshake_rtt_block_invoke;
  v3[3] = &unk_189666A58;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_rtt_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 248);
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_access_sent_certificates(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    unint64_t v4[2] = __sec_protocol_metadata_access_sent_certificates_block_invoke;
    unint64_t v4[3] = &unk_189666AF8;
    unint64_t v4[4] = a2;
    return sec_protocol_metadata_access_handle(a1, (uint64_t)v4);
  }

  return v2;
}

BOOL __sec_protocol_metadata_access_sent_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = *(sec_identity **)(a2 + 160);
  if (v2 && *((void *)v2 + 2)) {
    return sec_identity_access_certificates(v2, *(void **)(a1 + 32));
  }
  uint64_t v4 = *(void **)(a2 + 80);
  if (!v4) {
    return 0LL;
  }
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __sec_protocol_metadata_access_sent_certificates_block_invoke_2;
  v5[3] = &unk_189666AD0;
  v5[4] = *(void *)(a1 + 32);
  return sec_array_apply(v4, v5);
}

uint64_t __sec_protocol_metadata_access_sent_certificates_block_invoke_2(uint64_t a1)
{
  return 1LL;
}

uint64_t sec_protocol_metadata_get_tls_negotiated_group(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_metadata_get_tls_negotiated_group_block_invoke;
  v3[3] = &unk_189666B20;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_negotiated_group_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 176);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_create_config(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = &v5;
    uint64_t v7 = 0x2000000000LL;
    xpc_object_t v8 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    xpc_object_t v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
    if (v6[3])
    {
      v4[0] = MEMORY[0x1895F87A8];
      v4[1] = 0x40000000LL;
      unint64_t v4[2] = __sec_protocol_options_create_config_block_invoke;
      unint64_t v4[3] = &unk_189666B48;
      unint64_t v4[4] = &v5;
      char v2 = sec_protocol_options_access_handle(v1, (uint64_t)v4);
      uint64_t v1 = v6[3];
      if ((v2 & 1) != 0)
      {
LABEL_6:
        _Block_object_dispose(&v5, 8);
        return v1;
      }

      xpc_release((xpc_object_t)v6[3]);
    }

    uint64_t v1 = 0LL;
    goto LABEL_6;
  }

  return v1;
}

BOOL __sec_protocol_options_create_config_block_invoke(uint64_t a1, unsigned __int16 *a2)
{
  if (a2) {
    _serialize_options(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a2);
  }
  return a2 != 0LL;
}

BOOL sec_protocol_options_matches_config(uint64_t a1, void *a2)
{
  BOOL v2 = 0LL;
  if (a1 && a2)
  {
    if (MEMORY[0x186E0087C](a2) == MEMORY[0x1895F9250] && (uint64_t config = sec_protocol_options_create_config(a1)) != 0)
    {
      uint64_t v6 = (void *)config;
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 0x40000000LL;
      v8[2] = ___options_config_matches_partial_config_block_invoke;
      unint64_t v8[3] = &__block_descriptor_tmp_202;
      unint64_t v8[4] = config;
      v8[5] = a2;
      BOOL v2 = xpc_dictionary_apply(a2, v8);
      xpc_release(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

BOOL ___options_config_matches_partial_config_block_invoke(uint64_t a1, char *__s1)
{
  size_t v4 = strnlen(__s1, 0x80uLL);
  uint64_t v5 = 0LL;
  while (1)
  {
    uint64_t v6 = _options_uint64_keys[v5];
    size_t v7 = strlen(v6);
    size_t v8 = v4 <= v7 ? v7 : v4;
    if (!strncmp(__s1, v6, v8))
    {
      BOOL result = _dictionary_has_key(*(void **)(a1 + 32), (uint64_t)v6);
      if (!result) {
        return result;
      }
      uint64_t uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 32), v6);
    }

    if (++v5 == 6)
    {
      uint64_t v11 = 0LL;
      while (1)
      {
        uint64_t v12 = _options_BOOL_keys[v11];
        size_t v13 = strlen(v12);
        size_t v14 = v4 <= v13 ? v13 : v4;
        if (!strncmp(__s1, v12, v14))
        {
          BOOL result = _dictionary_has_key(*(void **)(a1 + 32), (uint64_t)v12);
          if (!result) {
            return result;
          }
          BOOL v15 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), v12);
          if (v15 != xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 40), v12)) {
            break;
          }
        }

        if (++v11 == 22) {
          return 1LL;
        }
      }

      return 0LL;
    }
  }

  return 0LL;
}

BOOL _dictionary_has_key(void *a1, uint64_t a2)
{
  if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9250]) {
    return 0LL;
  }
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 0x40000000LL;
  applier[2] = ___dictionary_has_key_block_invoke;
  applier[3] = &__block_descriptor_tmp_203;
  applier[4] = a2;
  return !xpc_dictionary_apply(a1, applier);
}

BOOL ___dictionary_has_key_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v3 = *(const char **)(a1 + 32);
  size_t v4 = strlen(v3);
  return strncmp(a2, v3, v4) != 0;
}

uint64_t sec_protocol_options_apply_config(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    if (MEMORY[0x186E0087C](a2) == MEMORY[0x1895F9250])
    {
      v5[0] = MEMORY[0x1895F87A8];
      v5[1] = 0x40000000LL;
      void v5[2] = ___apply_config_options_block_invoke;
      v5[3] = &__block_descriptor_tmp_207;
      v5[4] = a2;
      void v5[5] = a1;
      return sec_protocol_options_access_handle(a1, (uint64_t)v5);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL ___apply_config_options_block_invoke(int8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = ___apply_config_options_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_206;
  int8x16_t v2 = a1[2];
  int8x16_t v5 = vextq_s8(v2, v2, 8uLL);
  return xpc_dictionary_apply((xpc_object_t)v2.i64[0], v4);
}

uint64_t ___apply_config_options_block_invoke_2(uint64_t a1, char *__s1, void *a3)
{
  size_t v6 = strnlen(__s1, 0x80uLL);
  for (uint64_t i = 0LL; i != 44; i += 2LL)
  {
    size_t v8 = (&_options_BOOL_key_setters)[i];
    size_t v9 = strnlen(v8, 0x80uLL);
    if (v6 <= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = v6;
    }
    if (!strncmp(v8, __s1, v10))
    {
      uint64_t v11 = (&_options_BOOL_key_setters)[i + 1];
      uint64_t v12 = *(void *)(a1 + 32);
      BOOL v13 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 40), __s1);
      ((void (*)(uint64_t, BOOL))v11)(v12, v13);
    }
  }

  for (uint64_t j = 0LL; j != 12; j += 2LL)
  {
    BOOL v15 = (&_options_uint64_key_setters)[j];
    size_t v16 = strnlen(v15, 0x80uLL);
    if (v6 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v6;
    }
    if (!strncmp(v15, __s1, v17))
    {
      uint64_t v18 = (&_options_uint64_key_setters)[j + 1];
      uint64_t v19 = *(void *)(a1 + 32);
      uint64_t uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 40), __s1);
      ((void (*)(uint64_t, uint64_t))v18)(v19, uint64);
    }
  }

  if (!strncmp(__s1, "ciphersuites", v6) && MEMORY[0x186E0087C](a3) == MEMORY[0x1895F9220])
  {
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 0x40000000LL;
    v23[2] = ___apply_config_options_block_invoke_3;
    _OWORD v23[3] = &__block_descriptor_tmp_205;
    uint64_t v21 = *(void *)(a1 + 32);
    v23[4] = a3;
    v23[5] = v21;
    xpc_array_apply(a3, v23);
  }

  return 1LL;
}

uint64_t ___apply_config_options_block_invoke_3(uint64_t a1, size_t a2)
{
  __int16 uint64 = xpc_array_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    _WORD v6[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    void v6[3] = &__block_descriptor_tmp_10;
    __int16 v7 = uint64;
    sec_protocol_options_access_handle(v4, (uint64_t)v6);
  }

  return 1LL;
}

uint64_t sec_protocol_options_set_tls_block_length_padding(uint64_t result, __int16 a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_tls_block_length_padding_block_invoke;
    v2[3] = &__block_descriptor_tmp_134;
    __int16 v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_tls_block_length_padding_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_WORD *)(a2 + 366) = *(_WORD *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_server_raw_public_key_certificates(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_135;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

CFMutableArrayRef __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke( uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(const void **)(a2 + 280);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 280) = 0LL;
  }

  int8x16_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  CFMutableArrayRef result = CFArrayCreateMutable(v5, Count, MEMORY[0x189605228]);
  if (result)
  {
    size_t v8 = result;
    for (CFIndex i = 0LL; i < CFArrayGetCount(*(CFArrayRef *)(a1 + 32)); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      CFArrayAppendValue(v8, ValueAtIndex);
    }

    *(void *)(a2 + 280) = v8;
    return (CFMutableArrayRef)1;
  }

  return result;
}

void sec_protocol_options_add_server_raw_public_key_certificate(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
  size_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 1LL, MEMORY[0x189605228]);
  if (Mutable)
  {
    size_t v8 = Mutable;
    CFDataRef v9 = CFDataCreate(v6, a2, a3);
    if (v9)
    {
      CFDataRef v10 = v9;
      CFArrayAppendValue(v8, v9);
      CFRelease(v10);
      if (a1)
      {
        v11[0] = MEMORY[0x1895F87A8];
        v11[1] = 0x40000000LL;
        uint64_t v11[2] = __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke;
        unint64_t v11[3] = &__block_descriptor_tmp_135;
        v11[4] = v8;
        sec_protocol_options_access_handle(a1, (uint64_t)v11);
      }

      CFRelease(v8);
    }

    else
    {
      CFRelease(v8);
    }
  }

uint64_t sec_protocol_options_set_client_raw_public_key_certificates(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1895F87A8];
      v2[1] = 0x40000000LL;
      v2[2] = __sec_protocol_options_set_client_raw_public_key_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_136;
      void v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }

  return result;
}

CFMutableArrayRef __sec_protocol_options_set_client_raw_public_key_certificates_block_invoke( uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v4 = *(const void **)(a2 + 288);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 28_Block_object_dispose((const void *)(v13 - 80), 8) = 0LL;
  }

  int8x16_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  CFMutableArrayRef result = CFArrayCreateMutable(v5, Count, MEMORY[0x189605228]);
  if (result)
  {
    size_t v8 = result;
    for (CFIndex i = 0LL; i < CFArrayGetCount(*(CFArrayRef *)(a1 + 32)); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      CFArrayAppendValue(v8, ValueAtIndex);
    }

    *(void *)(a2 + 28_Block_object_dispose((const void *)(v13 - 80), 8) = v8;
    return (CFMutableArrayRef)1;
  }

  return result;
}

uint64_t sec_protocol_options_set_new_session_ticket_request(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_new_session_ticket_request_block_invoke;
    v2[3] = &__block_descriptor_tmp_137;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_new_session_ticket_request_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(a2 + 296) = *(_BYTE *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_resumed_session_ticket_request(uint64_t result, char a2)
{
  if (result)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 0x40000000LL;
    v2[2] = __sec_protocol_options_set_resumed_session_ticket_request_block_invoke;
    v2[3] = &__block_descriptor_tmp_138;
    char v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }

  return result;
}

BOOL __sec_protocol_options_set_resumed_session_ticket_request_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(a2 + 297) = *(_BYTE *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_eap_method(uint64_t result, unsigned int a2)
{
  if (result)
  {
    if (a2 <= 1)
    {
      uint64_t v6 = v2;
      uint64_t v7 = v3;
      v4[0] = MEMORY[0x1895F87A8];
      v4[1] = 0x40000000LL;
      unint64_t v4[2] = __sec_protocol_options_set_eap_method_block_invoke;
      unint64_t v4[3] = &__block_descriptor_tmp_139;
      char v5 = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v4);
    }
  }

  return result;
}

BOOL __sec_protocol_options_set_eap_method_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(a2 + 360) = *(_BYTE *)(a1 + 32);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_get_eap_method(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = 0LL;
  char v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _DWORD v3[2] = __sec_protocol_options_get_eap_method_block_invoke;
  v3[3] = &unk_189666C30;
  v3[4] = &v4;
  sec_protocol_options_access_handle(a1, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_options_get_eap_method_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 360);
  }
  return a2 != 0;
}

BOOL sec_protocol_metadata_get_eap_key_material(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = 0LL;
  if (a1 && a2 && (unint64_t)(a3 - 129) >= 0xFFFFFFFFFFFFFF80LL)
  {
    uint64_t v6 = 0LL;
    char v7 = &v6;
    uint64_t v8 = 0x2000000000LL;
    char v9 = 0;
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    void v5[2] = __sec_protocol_metadata_get_eap_key_material_block_invoke;
    v5[3] = &unk_189666C58;
    void v5[5] = a2;
    void v5[6] = a3;
    v5[4] = &v6;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v5);
    BOOL v3 = *((_BYTE *)v7 + 24) != 0;
    _Block_object_dispose(&v6, 8);
  }

  return v3;
}

BOOL __sec_protocol_metadata_get_eap_key_material_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    BOOL v3 = *(const void **)(a2 + 320);
    if (v3)
    {
      memmove(*(void **)(a1 + 40), v3, *(void *)(a1 + 48));
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    }
  }

  return a2 != 0;
}

void sub_180540DFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

Class __getSDRDiagnosticReporterClass_block_invoke(uint64_t a1)
{
  if (!SymptomDiagnosticReporterLibraryCore_frameworkLibrary) {
    SymptomDiagnosticReporterLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!SymptomDiagnosticReporterLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *SymptomDiagnosticReporterLibrary(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"SecABC.m",  16,  @"%s",  0);

    goto LABEL_8;
  }

  Class result = objc_getClass("SDRDiagnosticReporter");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    [MEMORY[0x1896077D8] currentHandler];
    BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getSDRDiagnosticReporterClass(void)_block_invoke"];
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v5,  @"SecABC.m",  17,  @"Unable to find class %s",  "SDRDiagnosticReporter");

LABEL_8:
    __break(1u);
  }

  getSDRDiagnosticReporterClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return result;
}

uint64_t SecABCTrigger(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return +[SecABC triggerAutoBugCaptureWithType:subType:subtypeContext:domain:events:payload:detectedProcess:]( &OBJC_CLASS___SecABC,  "triggerAutoBugCaptureWithType:subType:subtypeContext:domain:events:payload:detectedProcess:",  a1,  a2,  a3,  @"com.apple.security.keychain",  0LL,  a4,  0LL);
}

BOOL sec_protocol_helper_ciphersuite_group_contains_ciphersuite(unsigned int a1, int a2)
{
  if (a1 > 4) {
    return 0LL;
  }
  uint64_t v2 = (unsigned __int16 *)*(&off_189667138 + a1);
  uint64_t v3 = qword_180652E88[a1] - 1LL;
  do
  {
    int v4 = *v2++;
    BOOL result = v4 == a2;
  }

  while (v4 != a2 && v3-- != 0);
  return result;
}

uint64_t sec_protocol_helper_ciphersuite_minimum_TLS_version(int a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37) {
      return 0LL;
    }
  }

  return (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 1];
}

uint64_t sec_protocol_helper_ciphersuite_maximum_TLS_version(int a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37) {
      return 0LL;
    }
  }

  return (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 2];
}

const char *sec_protocol_helper_get_ciphersuite_name(int a1)
{
  if (a1 <= 4866)
  {
    if (a1 > 102)
    {
      if (a1 <= 155)
      {
        if (a1 == 103)
        {
          return "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256";
        }

        else if (a1 == 107)
        {
          return "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256";
        }

        else
        {
          return 0LL;
        }
      }

      else
      {
        switch(a1)
        {
          case 156:
            BOOL result = "TLS_RSA_WITH_AES_128_GCM_SHA256";
            break;
          case 157:
            BOOL result = "TLS_RSA_WITH_AES_256_GCM_SHA384";
            break;
          case 158:
            BOOL result = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
            break;
          case 159:
            BOOL result = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
            break;
          default:
            if (a1 == 4865)
            {
              BOOL result = "TLS_AES_128_GCM_SHA256";
            }

            else
            {
              if (a1 != 4866) {
                return 0LL;
              }
              BOOL result = "TLS_AES_256_GCM_SHA384";
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case '/':
          return "TLS_RSA_WITH_AES_128_CBC_SHA";
        case '0':
        case '1':
        case '2':
        case '4':
        case '6':
        case '7':
        case '8':
        case ':':
        case ';':
          return 0LL;
        case '3':
          return "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
        case '5':
          return "TLS_RSA_WITH_AES_256_CBC_SHA";
        case '9':
          return "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
        case '<':
          return "TLS_RSA_WITH_AES_128_CBC_SHA256";
        case '=':
          return "TLS_RSA_WITH_AES_256_CBC_SHA256";
        default:
          if (a1 == 10)
          {
            BOOL result = "SSL_RSA_WITH_3DES_EDE_CBC_SHA";
          }

          else
          {
            if (a1 != 22) {
              return 0LL;
            }
            BOOL result = "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA";
          }

          break;
      }
    }
  }

  else if (a1 <= 49186)
  {
    switch(a1)
    {
      case 49160:
        BOOL result = "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA";
        break;
      case 49161:
        BOOL result = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
        break;
      case 49162:
        BOOL result = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
        break;
      case 49163:
      case 49164:
      case 49165:
      case 49166:
      case 49167:
      case 49168:
      case 49169:
        return 0LL;
      case 49170:
        BOOL result = "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA";
        break;
      case 49171:
        BOOL result = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
        break;
      case 49172:
        BOOL result = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
        break;
      default:
        if (a1 != 4867) {
          return 0LL;
        }
        BOOL result = "TLS_CHACHA20_POLY1305_SHA256";
        break;
    }
  }

  else
  {
    switch(a1)
    {
      case 49187:
        return "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
      case 49188:
        return "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
      case 49189:
      case 49190:
      case 49193:
      case 49194:
      case 49197:
      case 49198:
        return 0LL;
      case 49191:
        return "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
      case 49192:
        return "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
      case 49195:
        return "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
      case 49196:
        return "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
      case 49199:
        return "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
      case 49200:
        return "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
      default:
        if (a1 == 52392)
        {
          BOOL result = "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
        }

        else
        {
          if (a1 != 52393) {
            return 0LL;
          }
          BOOL result = "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256";
        }

        break;
    }
  }

  return result;
}

BOOL sec_protocol_helper_dispatch_data_equal(void *a1, void *a2)
{
  int v3 = a1;
  int v4 = a2;
  if (v3 == v4)
  {
    BOOL v6 = 1LL;
  }

  else
  {
    size_t size = dispatch_data_get_size(v3);
    if (size == dispatch_data_get_size(v4))
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = &v11;
      uint64_t v13 = 0x2020000000LL;
      char v14 = 1;
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 3221225472LL;
      v8[2] = __sec_protocol_helper_dispatch_data_equal_block_invoke;
      unint64_t v8[3] = &unk_189667118;
      char v9 = v4;
      CFDataRef v10 = &v11;
      dispatch_data_apply(v3, v8);
      BOOL v6 = *((_BYTE *)v12 + 24) != 0;

      _Block_object_dispose(&v11, 8);
    }

    else
    {
      BOOL v6 = 0LL;
    }
  }

  return v6;
}

uint64_t __sec_protocol_helper_dispatch_data_equal_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __sec_protocol_helper_dispatch_data_equal_block_invoke_2;
  unint64_t v8[3] = &unk_1896670F0;
  BOOL v6 = *(dispatch_data_s **)(a1 + 32);
  void v8[4] = *(void *)(a1 + 40);
  v8[5] = a3;
  void v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

BOOL __sec_protocol_helper_dispatch_data_equal_block_invoke_2( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a1[5];
  }
  unint64_t v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3) {
    unint64_t v10 = a5 + a3;
  }
  else {
    unint64_t v10 = v6 + v7;
  }
  BOOL v11 = v10 > v8;
  size_t v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = memcmp( (const void *)(a4 + v8 - a3),  (const void *)(a1[7] + v8 - v7),  v12) == 0;
  }

  else
  {
    if (v9 < a3) {
      return 0LL;
    }
    if (a5 + a3 < v7) {
      return 1LL;
    }
  }

  return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
}

BOOL useMessageSecurityEnabled()
{
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3302);
  }
  return isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound == 0;
}

void __isMessageSecurityAllowedForCurrentBundleID_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      uint64_t v2 = Identifier;
      BOOL v3 = CFStringHasPrefix(Identifier, @"com.apple.mdmclient")
        || CFStringHasPrefix(v2, @"com.apple.managedclient.pds.Certificate")
        || CFStringHasPrefix(v2, @"com.apple.managedconfiguration.profiled")
        || CFStringHasPrefix(v2, @"com.apple.remotemanagementd")
        || CFStringHasPrefix(v2, @"com.apple.RemoteManagementAgent") != 0;
    }

    else
    {
      BOOL v3 = 0;
    }

    isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound = v3;
  }

  secLogObjForScope("SecCMS");
  int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound) {
      char v5 = "false";
    }
    else {
      char v5 = "true";
    }
    int v6 = 136315138;
    unint64_t v7 = v5;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "isMessageSecurityAllowedForCurrentBundleID %s",  (uint8_t *)&v6,  0xCu);
  }
}

uint64_t MS_SecCMSCertificatesOnlyMessageCopyCertificates(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v17 = 0LL;
  [MEMORY[0x189611048] decodeMessageSecurityObject:a1 options:0 error:&v17];
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  id v2 = v17;
  if (v1)
  {
    [v1 contentType];
    BOOL v3 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v3 isEqualToString:*MEMORY[0x189610FF0]]
      && ([v1 embeddedContent], (uint64_t v4 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      char v5 = (void *)v4;
      [v1 embeddedContent];
      int v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        [v1 embeddedContent];
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
        [v8 signers];
        unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v10 = [v9 count];

        if (v10)
        {
          secLogObjForScope("SecError");
          BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "certs-only message has signers", buf, 2u);
          }
        }

        else
        {
          [v8 certificates];
          BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (-[os_log_s count](v11, "count"))
          {
            uint64_t v15 = -[os_log_s allObjects](v11, "allObjects");
LABEL_19:

            goto LABEL_15;
          }
        }

        uint64_t v15 = 0LL;
        goto LABEL_19;
      }
    }

    else
    {
    }

    secLogObjForScope("SecError");
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      size_t v12 = "CMS message does not contain a SignedData";
      uint64_t v13 = (os_log_s *)v8;
      uint32_t v14 = 2;
LABEL_13:
      _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
    }
  }

  else
  {
    secLogObjForScope("SecError");
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v19 = v2;
      size_t v12 = "failed to decode CMS message: %@";
      uint64_t v13 = (os_log_s *)v8;
      uint32_t v14 = 12;
      goto LABEL_13;
    }
  }

  uint64_t v15 = 0LL;
LABEL_15:

  return v15;
}

uint64_t MS_SecCMSVerifySignedData_internal( uint64_t a1, uint64_t a2, void *a3, __SecTrust **a4, uint64_t a5, uint64_t *a6, void *a7)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  if (a5)
  {
    id v14 = objc_alloc_init(MEMORY[0x189611070]);
    [v14 setAdditionalCertificates:a5];
  }

  else
  {
    id v14 = 0LL;
  }

  id v63 = 0LL;
  [MEMORY[0x189611048] decodeMessageSecurityObject:a1 options:v14 error:&v63];
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  id v16 = v63;
  if (v15)
  {
    [v15 contentType];
    id v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v17 isEqualToString:*MEMORY[0x189610FF0]]
      && ([v15 embeddedContent], (uint64_t v18 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      id v19 = (void *)v18;
      CFIndex v58 = a6;
      unint64_t v59 = a7;
      [v15 embeddedContent];
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        [v15 embeddedContent];
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = v22;
        if (a2)
        {
          if (([v22 detached] & 1) == 0)
          {
            secLogObjForScope("SecWarning");
            uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( &dword_1804F4000,  v24,  OS_LOG_TYPE_DEFAULT,  "CMS message has attached content but caller passed in detached contents, using detached contents",  buf,  2u);
            }
          }

          [v23 contentType];
          unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
          char v26 = [v25 isEqualToString:*MEMORY[0x189610FE0]];

          if ((v26 & 1) == 0)
          {
            secLogObjForScope("SecWarning");
            uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( &dword_1804F4000,  v27,  OS_LOG_TYPE_DEFAULT,  "Caller passed a detached content by the content is not a data type.",  buf,  2u);
            }
          }

          [v23 setDataContent:a2];
        }

        char v28 = v59;
        if (!a3)
        {
          secLogObjForScope("SecWarning");
          char v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( &dword_1804F4000,  v33,  OS_LOG_TYPE_DEFAULT,  "SecCMSVerify called without policy -- skipping verification!",  buf,  2u);
          }

          goto LABEL_50;
        }

        CFTypeID v29 = CFGetTypeID(a3);
        if (v29 == SecPolicyGetTypeID())
        {
          unint64_t v64 = a3;
          [MEMORY[0x189603F18] arrayWithObjects:&v64 count:1];
          uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          CFTypeID v34 = CFGetTypeID(a3);
          if (v34 != CFArrayGetTypeID())
          {
            secLogObjForScope("SecError");
            char v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl(&dword_1804F4000, v33, OS_LOG_TYPE_DEFAULT, "policy is not a SecPolicy or CFArr0ay", buf, 2u);
            }

            uint64_t v31 = 4294967246LL;
            goto LABEL_46;
          }

          uint64_t v30 = a3;
        }

        char v33 = v30;
        [v23 signers];
        unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v36 = [v35 count];

        if (v36 == 1)
        {
          [v23 signers];
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue();
          [v37 objectAtIndexedSubscript:0];
          unint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();

          uint64_t v39 = getSigningTime(v38);
          verifyDate = (const __CFDate *)v39;
          if (a4)
          {
            id v62 = v16;
            char v40 = [v23 verifySignatures:&v62];
            id v41 = v62;

            char v28 = v59;
            if ((v40 & 1) != 0)
            {
              id v61 = v41;
              char v56 = v38;
              __int128 v42 = (__SecTrust *)[v38 createTrustObjectWithPolicies:v33 error:&v61];
              id v16 = v61;

              if (v42)
              {
                CFTypeRef v43 = verifyDate;
                if (verifyDate) {
                  SecTrustSetVerifyDate(v42, verifyDate);
                }
                *a4 = v42;
                unint64_t v38 = v56;
                goto LABEL_49;
              }

              secLogObjForScope("SecError");
              unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412290;
                id v66 = v16;
                _os_log_impl( &dword_1804F4000,  v55,  OS_LOG_TYPE_DEFAULT,  "Failed to create trust ref to verify signer: %@",  buf,  0xCu);
              }

              uint64_t v31 = [v16 code];
              id v41 = v16;
              unint64_t v38 = v56;
LABEL_68:

              id v16 = v41;
              goto LABEL_28;
            }

            secLogObjForScope("SecError");
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_DEFAULT))
            {
LABEL_67:

              uint64_t v31 = 4294942003LL;
              goto LABEL_68;
            }

            *(_DWORD *)__int128 buf = 138412290;
            id v66 = v41;
            CFIndex v54 = "CMS signature verification failed: %@";
          }

          else
          {
            id v60 = v16;
            char v47 = [v23 verifySignaturesAndSignersWithPolicies:v33 verifyTime:v39 error:&v60];
            id v41 = v60;

            char v28 = v59;
            if ((v47 & 1) != 0)
            {
              id v16 = v41;
              CFTypeRef v43 = verifyDate;
LABEL_49:

LABEL_50:
              if (v58)
              {
                if ([v23 detached])
                {
                  uint64_t v48 = [MEMORY[0x189603F48] data];
                }

                else
                {
                  [v23 contentType];
                  unsigned int v49 = (void *)objc_claimAutoreleasedReturnValue();
                  char v50 = [v49 isEqualToString:*MEMORY[0x189610FE0]];

                  if ((v50 & 1) == 0)
                  {
                    secLogObjForScope("SecWarning");
                    CFIndex v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      [v23 contentType];
                      unsigned int v52 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)__int128 buf = 138412290;
                      id v66 = v52;
                      _os_log_impl( &dword_1804F4000,  v51,  OS_LOG_TYPE_DEFAULT,  "returning attached embedded content of type %@",  buf,  0xCu);
                    }
                  }

                  uint64_t v48 = [v23 dataContent];
                  char v28 = v59;
                }

                *CFIndex v58 = v48;
              }

              if (v28) {
                addSignedAttribues(v23, v28);
              }
              uint64_t v31 = 0LL;
              goto LABEL_28;
            }

            secLogObjForScope("SecError");
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_67;
            }
            *(_DWORD *)__int128 buf = 138412290;
            id v66 = v41;
            CFIndex v54 = "Signature/signer verification failed: %@";
          }

          _os_log_impl(&dword_1804F4000, (os_log_t)v53, OS_LOG_TYPE_DEFAULT, v54, buf, 0xCu);
          goto LABEL_67;
        }

        secLogObjForScope("SecError");
        int v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          [v23 signers];
          CFTypeRef v45 = (void *)objc_claimAutoreleasedReturnValue();
          int v46 = [v45 count];
          *(_DWORD *)__int128 buf = 67109120;
          LODWORD(v66) = v46;
          _os_log_impl(&dword_1804F4000, v44, OS_LOG_TYPE_DEFAULT, "CMS message has %d signers, expected 1", buf, 8u);
        }

        uint64_t v31 = 4294942003LL;
LABEL_46:

        goto LABEL_28;
      }
    }

    else
    {
    }

    secLogObjForScope("SecError");
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  (os_log_t)v23,  OS_LOG_TYPE_DEFAULT,  "CMS message does not contain a SignedData",  buf,  2u);
    }

    uint64_t v31 = 4294941021LL;
  }

  else
  {
    secLogObjForScope("SecError");
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v66 = v16;
      _os_log_impl(&dword_1804F4000, (os_log_t)v23, OS_LOG_TYPE_DEFAULT, "failed to decode CMS message: %@", buf, 0xCu);
    }

    uint64_t v31 = 4294942003LL;
  }

id getSigningTime(void *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v1 = (void *)MEMORY[0x189611078];
  uint64_t v2 = *MEMORY[0x189610FD8];
  id v3 = a1;
  [v1 OIDWithString:v2 error:0];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 getAttributesWithType:v4];
  char v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    if ((unint64_t)[v5 count] >= 2)
    {
      secLogObjForScope("SecWarning");
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v13) = [v5 count];
        _os_log_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_DEFAULT,  "too many signing time attributes (%d), skipping",  buf,  8u);
      }

      unint64_t v7 = 0LL;
      goto LABEL_18;
    }

    [v5 objectAtIndexedSubscript:0];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      id v11 = 0LL;
      id v9 = (id)[objc_alloc(MEMORY[0x189611068]) initWithAttribute:v8 error:&v11];
      int v6 = (os_log_s *)v11;
      if (!v9) {
        goto LABEL_14;
      }
LABEL_12:
      [v9 signingTime];
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_17:

LABEL_18:
      goto LABEL_19;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      id v9 = v8;
      int v6 = 0LL;
      if (v9) {
        goto LABEL_12;
      }
    }

    else
    {
      int v6 = 0LL;
    }

void addSignedAttribues(void *a1, void *a2)
{
  uint64_t v97 = *MEMORY[0x1895F89C0];
  id v2 = a1;
  [MEMORY[0x189603FC8] dictionary];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 certificates];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    [v2 certificates];
    char v5 = (void *)objc_claimAutoreleasedReturnValue();
    [v5 allObjects];
    int v6 = (void *)objc_claimAutoreleasedReturnValue();
    [v3 setObject:v6 forKeyedSubscript:kSecCMSAllCerts];
  }

  __int128 v81 = v2;
  [v2 signers];
  unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  [v7 objectAtIndexedSubscript:0];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();

  __int128 v85 = 0u;
  __int128 v86 = 0u;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  [v8 protectedAttributes];
  id v9 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v10 = [v9 countByEnumeratingWithState:&v83 objects:v93 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v84;
    do
    {
      for (uint64_t i = 0LL; i != v11; ++i)
      {
        if (*(void *)v84 != v12) {
          objc_enumerationMutation(v9);
        }
        uint64_t v14 = *(void **)(*((void *)&v83 + 1) + 8 * i);
        [v14 attributeType];
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
        [v15 OIDBytes];
        id v16 = (void *)objc_claimAutoreleasedReturnValue();

        [v14 attributeValues];
        id v17 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v18 = (void *)[v17 mutableCopy];

        [v3 objectForKey:v16];
        id v19 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v20 = v19;
        if (v19) {
          [v19 addObjectsFromArray:v18];
        }
        else {
          [v3 setObject:v18 forKey:v16];
        }
      }

      uint64_t v11 = [v9 countByEnumeratingWithState:&v83 objects:v93 count:16];
    }

    while (v11);
  }

  [v8 unprotectedAttributes];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  [v21 removeAllObjects];

  id v22 = v3;
  getSigningTime(v8);
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  [v22 setObject:v23 forKeyedSubscript:kSecCMSSignDate];

  id v24 = v22;
  unint64_t v25 = (void *)MEMORY[0x189611078];
  uint64_t v26 = *MEMORY[0x189610FC8];
  id v27 = v8;
  [v25 OIDWithString:v26 error:0];
  char v28 = (void *)objc_claimAutoreleasedReturnValue();
  [v27 getAttributesWithType:v28];
  CFTypeID v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (v29)
  {
    if ((unint64_t)[v29 count] >= 2)
    {
      secLogObjForScope("SecWarning");
      uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = [v29 count];
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v96) = v31;
        _os_log_impl( &dword_1804F4000,  v30,  OS_LOG_TYPE_DEFAULT,  "too many hash agility attributes (%d), skipping",  buf,  8u);
      }

      goto LABEL_27;
    }

    [v29 objectAtIndexedSubscript:0];
    unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      id v33 = objc_alloc(MEMORY[0x189611030]);
      *(void *)&__int128 v89 = 0LL;
      CFTypeID v34 = (os_log_s *)[v33 initWithAttribute:v32 error:&v89];
      uint64_t v30 = (os_log_s *)(id)v89;
      if (!v34)
      {
LABEL_24:
        secLogObjForScope("SecWarning");
        CFTypeID v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          char v96 = v30;
          _os_log_impl( &dword_1804F4000,  v34,  OS_LOG_TYPE_DEFAULT,  "skipping hash agility attribute that failed to decode: %@",  buf,  0xCu);
        }

        goto LABEL_26;
      }
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        uint64_t v30 = 0LL;
        goto LABEL_24;
      }

      CFTypeID v34 = v32;
      uint64_t v30 = 0LL;
      if (!v34) {
        goto LABEL_24;
      }
    }

    -[os_log_s hashAgilityValue](v34, "hashAgilityValue");
    unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue();
    [v24 setObject:v35 forKeyedSubscript:kSecCMSHashAgility];

LABEL_26:
LABEL_27:
  }

  id v36 = v27;
  id v37 = v24;
  [MEMORY[0x189611078] OIDWithString:*MEMORY[0x189610FD0] error:0];
  unint64_t v38 = (void *)objc_claimAutoreleasedReturnValue();
  [v36 getAttributesWithType:v38];
  uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v39) {
    goto LABEL_57;
  }
  if ((unint64_t)[v39 count] >= 2)
  {
    secLogObjForScope("SecWarning");
    char v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = [v39 count];
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v96) = v41;
      _os_log_impl( &dword_1804F4000,  v40,  OS_LOG_TYPE_DEFAULT,  "too many hash agility V2 attributes (%d), skipping",  buf,  8u);
    }

    goto LABEL_56;
  }

  [v39 objectAtIndexedSubscript:0];
  __int128 v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      char v40 = 0LL;
      goto LABEL_53;
    }

    id v44 = v42;
    char v40 = 0LL;
    if (!v44) {
      goto LABEL_53;
    }
LABEL_37:
    id v79 = v36;
    objc_msgSend(v44, "hashAgilityValues", v44, v40, v42, v39);
    id v45 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x189603FC8], "dictionaryWithCapacity:", objc_msgSend(v45, "count"));
    __int128 v82 = (void *)objc_claimAutoreleasedReturnValue();
    __int128 v89 = 0u;
    __int128 v90 = 0u;
    __int128 v91 = 0u;
    __int128 v92 = 0u;
    id v46 = v45;
    uint64_t v47 = [v46 countByEnumeratingWithState:&v89 objects:buf count:16];
    if (v47)
    {
      uint64_t v48 = v47;
      uint64_t v49 = *(void *)v90;
      do
      {
        for (uint64_t j = 0LL; j != v48; ++j)
        {
          if (*(void *)v90 != v49) {
            objc_enumerationMutation(v46);
          }
          uint64_t v51 = *(void *)(*((void *)&v89 + 1) + 8 * j);
          id v88 = 0LL;
          [MEMORY[0x189611078] OIDWithString:v51 error:&v88];
          unsigned int v52 = (void *)objc_claimAutoreleasedReturnValue();
          id v53 = v88;
          if (v52)
          {
            [v52 OIDBytes];
            CFIndex v54 = (void *)objc_claimAutoreleasedReturnValue();
            memset(v94, 170, sizeof(v94));
            *(void *)__int128 v94 = [v54 length];
            id v55 = v54;
            *(void *)&v94[8] = [v55 bytes];
            uint64_t OID = SECOID_FindOID((uint64_t)v94);
            if (OID) {
              uint64_t v57 = *(unsigned int *)(OID + 16);
            }
            else {
              uint64_t v57 = 0LL;
            }
            [v46 objectForKeyedSubscript:v51];
            CFIndex v58 = (void *)objc_claimAutoreleasedReturnValue();
            [MEMORY[0x189607968] numberWithLongLong:v57];
            unint64_t v59 = (void *)objc_claimAutoreleasedReturnValue();
            [v82 setObject:v58 forKey:v59];
          }

          else
          {
            secLogObjForScope("SecWarning");
            id v55 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 v94 = 138412290;
              *(void *)&v94[4] = v51;
              _os_log_impl( &dword_1804F4000,  (os_log_t)v55,  OS_LOG_TYPE_DEFAULT,  "skipping hash agility entry with invalid OID: %@",  v94,  0xCu);
            }
          }
        }

        uint64_t v48 = [v46 countByEnumeratingWithState:&v89 objects:buf count:16];
      }

      while (v48);
    }

    [MEMORY[0x189603F68] dictionaryWithDictionary:v82];
    id v60 = (void *)objc_claimAutoreleasedReturnValue();

    [v37 setObject:v60 forKeyedSubscript:kSecCMSHashAgilityV2];
    id v36 = v79;
    __int128 v42 = v77;
    uint64_t v39 = v78;
    id v61 = v75;
    char v40 = v76;
    goto LABEL_55;
  }

  id v43 = objc_alloc(MEMORY[0x189611038]);
  id v87 = 0LL;
  id v44 = (id)[v43 initWithAttribute:v42 error:&v87];
  char v40 = (os_log_s *)v87;
  if (v44) {
    goto LABEL_37;
  }
LABEL_53:
  secLogObjForScope("SecWarning");
  id v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    char v96 = v40;
    _os_log_impl( &dword_1804F4000,  v61,  OS_LOG_TYPE_DEFAULT,  "skipping hash agility V2 attribute that failed to decode: %@",  buf,  0xCu);
  }

LABEL_55:
LABEL_56:
LABEL_57:

  id v62 = v37;
  id v63 = (void *)MEMORY[0x189611078];
  uint64_t v64 = *MEMORY[0x189610FC0];
  id v65 = v36;
  [v63 OIDWithString:v64 error:0];
  id v66 = (void *)objc_claimAutoreleasedReturnValue();
  [v65 getAttributesWithType:v66];
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue();

  if (v67)
  {
    if ((unint64_t)[v67 count] >= 2)
    {
      secLogObjForScope("SecWarning");
      unint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        int v69 = [v67 count];
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v96) = v69;
        _os_log_impl( &dword_1804F4000,  v68,  OS_LOG_TYPE_DEFAULT,  "too many expiration time attributes (%d), skipping",  buf,  8u);
      }

      goto LABEL_71;
    }

    [v67 objectAtIndexedSubscript:0];
    unint64_t v70 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      id v71 = objc_alloc(MEMORY[0x189611028]);
      *(void *)&__int128 v89 = 0LL;
      unint64_t v72 = (os_log_s *)[v71 initWithAttribute:v70 error:&v89];
      unint64_t v68 = (os_log_s *)(id)v89;
      if (!v72)
      {
LABEL_68:
        secLogObjForScope("SecWarning");
        unint64_t v72 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          char v96 = v68;
          _os_log_impl( &dword_1804F4000,  v72,  OS_LOG_TYPE_DEFAULT,  "skipping expration time that failed to decode: %@",  buf,  0xCu);
        }

        goto LABEL_70;
      }
    }

    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        unint64_t v68 = 0LL;
        goto LABEL_68;
      }

      unint64_t v72 = v70;
      unint64_t v68 = 0LL;
      if (!v72) {
        goto LABEL_68;
      }
    }

    -[os_log_s expirationTime](v72, "expirationTime");
    __int128 v73 = (void *)objc_claimAutoreleasedReturnValue();
    [v62 setObject:v73 forKeyedSubscript:kSecCMSExpirationDate];

LABEL_70:
LABEL_71:
  }

  [MEMORY[0x189603F68] dictionaryWithDictionary:v62];
  id v74 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v74;
}

uint64_t MS_SecCMSDecodeSignedData(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v20 = 0LL;
  [MEMORY[0x189611048] decodeMessageSecurityObject:a1 options:0 error:&v20];
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  id v6 = v20;
  if (v5)
  {
    [v5 contentType];
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v7 isEqualToString:*MEMORY[0x189610FF0]]
      && ([v5 embeddedContent], (uint64_t v8 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      id v9 = (void *)v8;
      [v5 embeddedContent];
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        [v5 embeddedContent];
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
        uint64_t v13 = v12;
        if (a2)
        {
          if ([v12 detached])
          {
            uint64_t v14 = [MEMORY[0x189603F48] data];
          }

          else
          {
            [v13 contentType];
            id v16 = (void *)objc_claimAutoreleasedReturnValue();
            char v17 = [v16 isEqualToString:*MEMORY[0x189610FE0]];

            if ((v17 & 1) == 0)
            {
              secLogObjForScope("SecWarning");
              uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                [v13 contentType];
                id v19 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)__int128 buf = 138412290;
                id v22 = v19;
                _os_log_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEFAULT,  "returning attached embedded content of type %@",  buf,  0xCu);
              }
            }

            uint64_t v14 = [v13 dataContent];
          }

          *a2 = v14;
        }

        if (a3)
        {
          addSignedAttribues(v13, (void *)a3);
          a3 = 0LL;
        }

        goto LABEL_15;
      }
    }

    else
    {
    }

    secLogObjForScope("SecError");
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  (os_log_t)v13,  OS_LOG_TYPE_DEFAULT,  "CMS message does not contain a SignedData",  buf,  2u);
    }

    a3 = 4294941021LL;
  }

  else
  {
    secLogObjForScope("SecError");
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v22 = v6;
      _os_log_impl(&dword_1804F4000, (os_log_t)v13, OS_LOG_TYPE_DEFAULT, "failed to decode CMS message: %@", buf, 0xCu);
    }

    a3 = 4294942003LL;
  }

uint64_t MS_SecCMSDecryptEnvelopedData(uint64_t a1, __CFData *a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v30 = 0LL;
  [MEMORY[0x189611048] decodeMessageSecurityObject:a1 options:0 error:&v30];
  char v5 = (void *)objc_claimAutoreleasedReturnValue();
  id v6 = v30;
  if (v5)
  {
    [v5 contentType];
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v7 isEqualToString:*MEMORY[0x189610FE8]]
      && ([v5 embeddedContent], (uint64_t v8 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      id v9 = (void *)v8;
      [v5 embeddedContent];
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        [v5 embeddedContent];
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
        [v12 contentType];
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v13 isEqualToString:*MEMORY[0x189610FE0]])
        {
          [v12 dataContent];
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
          if (v14)
          {
            id v15 = v14;
            CFDataAppendBytes(a2, (const UInt8 *)[v15 bytes], objc_msgSend(v15, "length"));

            if (!a3)
            {
              uint64_t v22 = 0LL;
LABEL_30:

              goto LABEL_19;
            }

            [v12 recipients];
            id v16 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v17 = [v16 count];

            if (v17)
            {
              [v12 recipients];
              uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
              [v18 objectAtIndex:0];
              id v19 = (void *)objc_claimAutoreleasedReturnValue();

              id v20 = (const void *)[v19 recipientCertificate];
              uint64_t v21 = v20;
              if (v20) {
                CFRetain(v20);
              }
              uint64_t v22 = 0LL;
              *a3 = v21;
              goto LABEL_29;
            }

            uint64_t v22 = 4294899625LL;
            secLogObjForScope("SecError");
            id v19 = (void *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              id v27 = "failed to read the recipient after decoding";
              goto LABEL_27;
            }
          }

          else
          {
            uint64_t v22 = 4294899625LL;
            secLogObjForScope("SecError");
            id v19 = (void *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              id v27 = "failed to read the decrypted content after decoding";
LABEL_27:
              char v28 = (os_log_s *)v19;
              uint32_t v29 = 2;
              goto LABEL_28;
            }
          }
        }

        else
        {
          uint64_t v22 = 4294899625LL;
          secLogObjForScope("SecError");
          id v19 = (void *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v32 = v13;
            id v27 = "unexpected content type %@";
            char v28 = (os_log_s *)v19;
            uint32_t v29 = 12;
LABEL_28:
            _os_log_impl(&dword_1804F4000, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
          }
        }

uint64_t SECSFAEventFilterReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int *)MEMORY[0x189611CE8];
  char v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    unint64_t v7 = (int *)MEMORY[0x189611CD8];
    do
    {
      if (*(_BYTE *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0LL;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 == -1LL || v23 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(_BYTE *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0) {
            goto LABEL_31;
          }
          v19 += 7;
          BOOL v14 = v20++ >= 9;
          if (v14)
          {
            uint64_t v21 = 0LL;
            goto LABEL_33;
          }
        }

        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5)) {
          uint64_t v21 = 0LL;
        }
LABEL_33:
        *(void *)(a1 + _Block_object_dispose(va, 8) = v21;
      }

      else if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
      }

      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result) {
          return result;
        }
      }
    }

    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

LABEL_51:
  LOBYTE(v20) = *((_BYTE *)a3 + *v6) == 0;
  return v20;
}

              unint64_t v10 = -8059;
              goto LABEL_9;
            }

            return 0LL;
          }

          a1[21] = 0LL;
          goto LABEL_53;
        }
      }
    }
  }

  unint64_t v10 = -8187;
LABEL_9:
  ThreadErrInfo = PR_getThreadErrInfo(1, &v38);
  if (ThreadErrInfo)
  {
    *ThreadErrInfo = 0;
    ThreadErrInfo[1] = v10;
  }

  return 0xFFFFFFFFLL;
}

            if (*((_BYTE *)v9 + 136))
            {
              unint64_t v38 = (char *)sec_asn1d_zalloc(*(void *)(*v9 + 8LL), *(unsigned int *)(v9[1] + 16LL));
              if (!v38) {
                goto LABEL_174;
              }
              v9[2] = &v38[*(unsigned int *)(v9[1] + 4LL)];
              uint64_t v39 = v9[4];
              if (*(_DWORD *)(v39 + 48) == 18) {
                **(void **)(v39 + 16) = v38;
              }
            }

            char v40 = v9[11];
            v9[12] = v40;
            if (*((_BYTE *)v9 + 138))
            {
              *((_DWORD *)v9 + 12) = 15;
              __int128 v42 = *v9;
              int v41 = v9[1];
              id v43 = v9[2];
              id v44 = *(uint64_t (***)(uint64_t, void, unsigned __int8 *, unint64_t))(v41 + 8);
              if (v44 && (*(_BYTE *)(v41 + 1) & 0x40) != 0)
              {
                if (*v44)
                {
                  if (v43) {
                    id v45 = v43 - *(unsigned int *)(v41 + 4);
                  }
                  else {
                    id v45 = 0LL;
                  }
                  id v44 = (uint64_t (**)(uint64_t, void, unsigned __int8 *, unint64_t))(*v44)(v45, 0LL, (unsigned __int8 *)a2, a3);
                  id v43 = v9[2];
                }

                else
                {
                  id v44 = 0LL;
                }
              }

              v173 = sec_asn1d_push_state(v42, (uint64_t)v44, v43, 1);
              if (v173) {
LABEL_336:
              }
                sec_asn1d_init_state_based_on_template(v173, (uint64_t)a2, a3);
              goto LABEL_337;
            }

            v139 = v9[10];
            if ((v139 & 0x2000) == 0)
            {
              if (v139 <= 1023)
              {
                switch(v139)
                {
                  case 3LL:
                  case 4LL:
                  case 12LL:
                  case 19LL:
                  case 20LL:
                  case 22LL:
                  case 23LL:
                  case 26LL:
                    goto LABEL_238;
                  case 5LL:
                    if (v40 || *((_BYTE *)v9 + 139)) {
                      goto LABEL_172;
                    }
                    v189 = (void *)v9[2];
                    if (v189)
                    {
                      *v189 = 0LL;
                      v189[1] = 0LL;
                    }

                    goto LABEL_270;
                  case 16LL:
                    *((_DWORD *)v9 + 12) = 12;
                    v190 = sec_asn1d_push_state(*v9, v9[1] + 24LL, v9[2], 1);
                    BOOL v14 = (unint64_t)v190;
                    if (!v190) {
                      goto LABEL_338;
                    }
                    char v19 = v3;
                    v180 = *v190;
                    goto LABEL_381;
                  case 17LL:
                    goto LABEL_172;
                  case 28LL:
                    if ((v40 & 3) == 0) {
                      goto LABEL_238;
                    }
                    goto LABEL_172;
                  case 30LL:
                    if ((v40 & 1) == 0) {
                      goto LABEL_238;
                    }
                    goto LABEL_172;
                  default:
                    goto LABEL_352;
                }
              }

              if (v139 != 1024 && v139 != 0x8000 && v139 != 66560)
              {
LABEL_352:
                if (!v40) {
                  goto LABEL_172;
                }
                char v19 = v3;
                v174 = (void *)v9[2];
                if (!v174) {
                  goto LABEL_431;
                }
                *v174 = 0LL;
                if (*(_DWORD *)(*v9 + 72LL))
                {
                  v174[1] = 0LL;
LABEL_431:
                  BOOL v14 = 0LL;
                  int v15 = 0;
                  id v16 = 0;
                  uint64_t v17 = 0;
                  *((_DWORD *)v9 + 12) = 10;
                  goto LABEL_385;
                }

                v191 = sec_asn1d_zalloc(*(void *)(*v9 + 8LL), v40);
                v174[1] = v191;
                if (v191) {
                  goto LABEL_431;
                }
LABEL_432:
                BOOL v14 = 0LL;
                int v15 = 0;
                id v16 = 0;
                uint64_t v17 = 0;
                *(_DWORD *)(*v9 + 24LL) = 1;
                goto LABEL_385;
              }

  else {
    v154 = *v11;
  }
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)__p, (char *)&v154);
  Value = CFDictionaryGetValue(v13, __p[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)__p);
  if (((char)v154.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (Value) {
      goto LABEL_58;
    }
LABEL_73:
    if (v3 != 2)
    {
      if (v3 == 1)
      {
        memset(__p, 170, 0x400uLL);
        Security::cfString((Security *)__b, v155);
        if ((__b[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v47 = __b;
        }
        else {
          uint64_t v47 = (std::string *)__b[0].__r_.__value_.__r.__words[0];
        }
        uint64_t v48 = readlink((const char *)v47, (char *)__p, 0x400uLL);
        if (v48 >= 1) {
          return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
        }
      }

            std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)(a2 + 200),  (uint64_t)v41,  v42,  (uint64_t *)v106[2]);
            unint64_t v38 = v106[1];
            v106[2] = v106[1];
            if (v106[1]) {
              v106[1] = (Security::CodeSigning::SecCodeSigner::Signer *)std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v106[1]);
            }
            id v43 = v34[1];
            if (v43)
            {
              do
              {
                uint64_t v39 = (uint64_t **)v43;
                id v43 = (uint64_t *)*v43;
              }

              while (v43);
            }

            else
            {
              do
              {
                uint64_t v39 = (uint64_t **)v34[2];
                uint64_t v26 = *v39 == (uint64_t *)v34;
                CFTypeID v34 = v39;
              }

              while (!v26);
            }

            if (!v38) {
              break;
            }
            CFTypeID v34 = v39;
          }

          while (v39 != &v99);
        }
      }

      else
      {
        uint64_t v39 = v34;
      }

      std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)v106);
      CFTypeID v34 = v39;
    }

    if (v34 != &v99)
    {
      id v44 = (uint64_t **)(a2 + 208);
      do
      {
        memset(v106, 170, 24);
        std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__construct_node<std::pair<unsigned int const,Security::CFCopyRef<__CFData const*>> const&>( v106,  a2 + 200,  *((_DWORD *)v34 + 8),  v34[5]);
        id v45 = *v44;
        id v46 = (uint64_t **)(a2 + 208);
        uint64_t v47 = (uint64_t **)(a2 + 208);
        if (*v44)
        {
          do
          {
            while (1)
            {
              id v46 = (uint64_t **)v45;
              if (*((_DWORD *)v106[0] + 8) >= *((_DWORD *)v45 + 8)) {
                break;
              }
              id v45 = (uint64_t *)*v45;
              uint64_t v47 = v46;
              if (!*v46) {
                goto LABEL_71;
              }
            }

            id v45 = (uint64_t *)v45[1];
          }

          while (v45);
          uint64_t v47 = v46 + 1;
        }

void sub_1805465D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1805468D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180546A08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180546B24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180546C40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180546D5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_180546E5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

id KCSharingSetupMessagingdServerProtocol(void *a1)
{
  _OWORD v7[4] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  id v2 = (void *)objc_claimAutoreleasedReturnValue();
  id v3 = (void *)MEMORY[0x189604010];
  v7[0] = objc_opt_class();
  v7[1] = objc_opt_class();
  void v7[2] = objc_opt_class();
  v7[3] = objc_opt_class();
  [MEMORY[0x189603F18] arrayWithObjects:v7 count:4];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setWithArray:v4];
  char v5 = (void *)objc_claimAutoreleasedReturnValue();

  [v1 setClass:objc_opt_class() forSelector:sel_sendNewInvitesForGroup_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v2 forSelector:sel_sendNewInvitesForGroup_completion_ argumentIndex:0 ofReply:1];
  [v1 setClass:objc_opt_class() forSelector:sel_cancelPendingInvitesForGroup_participantHandles_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v2 forSelector:sel_cancelPendingInvitesForGroup_participantHandles_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_didAcceptInviteForGroupID_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_didDeclineInviteForGroupID_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_fetchReceivedInviteWithGroupID_completion_ argumentIndex:0 ofReply:0];
  [v1 setClasses:v5 forSelector:sel_fetchReceivedInviteWithGroupID_completion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchReceivedInviteWithGroupID_completion_ argumentIndex:1 ofReply:1];
  [v1 setClasses:v5 forSelector:sel_fetchReceivedInvitesWithCompletion_ argumentIndex:0 ofReply:1];
  [v1 setClasses:v2 forSelector:sel_fetchReceivedInvitesWithCompletion_ argumentIndex:1 ofReply:1];

  return v1;
}

id KCSharingLogObject(void *a1)
{
  id v1 = a1;
  uint64_t v11 = 0LL;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x3032000000LL;
  BOOL v14 = __Block_byref_object_copy__3890;
  int v15 = __Block_byref_object_dispose__3891;
  id v2 = (void *)MEMORY[0x1895F8DA8];
  id v3 = MEMORY[0x1895F8DA8];
  id v16 = v2;
  if (KCSharingLogObject_onceToken != -1) {
    dispatch_once(&KCSharingLogObject_onceToken, &__block_literal_global_3892);
  }
  uint64_t v4 = (dispatch_queue_s *)KCSharingLogObject_logQueue;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __KCSharingLogObject_block_invoke_2;
  unint64_t v8[3] = &unk_1896764A8;
  id v9 = v1;
  unint64_t v10 = &v11;
  id v5 = v1;
  dispatch_sync(v4, v8);
  id v6 = (id)v12[5];

  _Block_object_dispose(&v11, 8);
  return v6;
}

uint64_t __Block_byref_object_copy__3890(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__3891(uint64_t a1)
{
}

void __KCSharingLogObject_block_invoke_2(uint64_t a1)
{
  id v2 = (void *)KCSharingLogObject_scopeMap;
  if (!KCSharingLogObject_scopeMap)
  {
    uint64_t v3 = [MEMORY[0x189603FC8] dictionary];
    uint64_t v4 = (void *)KCSharingLogObject_scopeMap;
    KCSharingLogObject_scopeMap = v3;

    id v2 = (void *)KCSharingLogObject_scopeMap;
  }

  uint64_t v5 = [v2 objectForKeyedSubscript:*(void *)(a1 + 32)];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  unint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL))
  {
    os_log_t v8 = os_log_create( "com.apple.security.keychain.sharing", (const char *)[*(id *)(a1 + 32) cStringUsingEncoding:4]);
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    [(id)KCSharingLogObject_scopeMap setObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) forKeyedSubscript:*(void *)(a1 + 32)];
  }

void __KCSharingLogObject_block_invoke()
{
  id v2 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v0 = dispatch_queue_create("kcsharing-logger", v2);
  id v1 = (void *)KCSharingLogObject_logQueue;
  KCSharingLogObject_logQueue = (uint64_t)v0;
}

uint64_t SecPaddingCompute(int a1, unsigned int a2, CFErrorRef *a3)
{
  if (a1)
  {
    if (a3)
    {
      Default = CFAllocatorGetDefault();
      uint64_t v5 = -1LL;
      *a3 = CFErrorCreate(Default, @"com.apple.security.padding", -1LL, 0LL);
    }

    else
    {
      return -1LL;
    }
  }

  else
  {
    uint64_t v6 = (a2 + 0x1FFFLL) & 0x1FFFFE000LL;
    if (a2 <= 0x7D00) {
      uint64_t v6 = (a2 + 1023LL) & 0x1FFFFFC00LL;
    }
    uint64_t v7 = 1LL << -(char)__clz(a2);
    if ((a2 & (a2 - 1LL)) == 0) {
      uint64_t v7 = a2;
    }
    if (a2 <= 0x400) {
      uint64_t v6 = v7;
    }
    if (a2 <= 0x40) {
      uint64_t v6 = 64LL;
    }
    return v6 - a2;
  }

  return v5;
}

LABEL_5:
  return v9;
}

    SOSPeerInfoV2DictionarySetValue(a1, (const void *)sSerialNumberKey, v2);
    CFRelease(v2);
    return;
  }

  id v2 = CFRetain((CFTypeRef)SOSGestaltSerial);
  if (v2) {
    goto LABEL_5;
  }
}

  if ((v9 & 0x18C0) == 0)
  {
    if ((v9 & 0x20000) != 0)
    {
      uint64_t result = 0LL;
      char v24 = 2;
LABEL_100:
      *a5 = v24;
      return result;
    }

    char v19 = v9 & 0xFFDBBCFF;
    if ((int)(v9 & 0xFFDBBCFF) > 8207)
    {
      if ((v19 - 8208) > 1)
      {
LABEL_72:
        unint64_t v23 = *a2;
        goto LABEL_88;
      }

      uint32_t v25 = (uint64_t *)*a2;
      if (*a2)
      {
        uint64_t v26 = *((void *)v8 + 1);
        if (v26 && (v9 & 0x4000) != 0)
        {
          if (*(void *)v26) {
            uint64_t v26 = (*(uint64_t (**)(char *, uint64_t, void, void, unint64_t *))v26)( (char *)a2 - v8[1],  1LL,  0LL,  0LL,  a2);
          }
          else {
            uint64_t v26 = 0LL;
          }
        }

        uint64_t v39 = *v25;
        if (*v25)
        {
          unint64_t v23 = 0LL;
          do
          {
            char v40 = sec_asn1e_contents_length(v26, v39 + *(unsigned int *)(v26 + 4), v10, a4, a5);
            v23 += v40;
            if (!*a5)
            {
              int v41 = 1LL;
              if (v40 >= 0x80)
              {
                do
                {
                  ++v41;
                  int v31 = v40 > 0xFF;
                  v40 >>= 8;
                }

                while (v31);
              }

              v23 += v41 + 1;
            }

            __int128 v42 = v25[1];
            ++v25;
            uint64_t v39 = v42;
          }

          while (v42);
          goto LABEL_88;
        }
      }
    }

    else
    {
      if ((v19 - 16) >= 2)
      {
        if ((_DWORD)v19 != 2)
        {
          if ((_DWORD)v19 == 3)
          {
            unsigned int v20 = *a2 + 7;
            uint64_t v21 = v20 >= 8;
            uint64_t v22 = v20 >> 3;
            if (v21) {
              unint64_t v23 = v22 + 1;
            }
            else {
              unint64_t v23 = 0LL;
            }
            goto LABEL_88;
          }

          goto LABEL_72;
        }

        unint64_t v23 = *a2;
        if (*a2)
        {
          CFTypeID v34 = (_BYTE *)a2[1];
          LOBYTE(v35) = *v34;
          if (*v34)
          {
            id v36 = *a2;
LABEL_66:
            if ((*(void *)&v9 & 0x800000LL) == 0 && (v35 & 0x80u) != 0) {
              unint64_t v23 = v36 + 1;
            }
            else {
              unint64_t v23 = v36;
            }
          }

          else
          {
            unint64_t v38 = v34 + 1;
            while (1)
            {
              id v36 = v23 - 1;
              if (v23 == 1) {
                break;
              }
              unsigned int v35 = *v38;
              if (v35 < 0) {
                break;
              }
              ++v38;
              --v23;
              if ((_BYTE)v35) {
                goto LABEL_66;
              }
            }
          }
        }

void sub_180548AFC(_Unwind_Exception *a1)
{
}

id getOSLog()
{
  if (getOSLog_onceToken != -1) {
    dispatch_once(&getOSLog_onceToken, &__block_literal_global_220);
  }
  return (id)getOSLog_sfaLog;
}

void __getOSLog_block_invoke()
{
  os_log_t v0 = os_log_create("SFA", "log");
  id v1 = (void *)getOSLog_sfaLog;
  getOSLog_sfaLog = (uint64_t)v0;
}

void sub_18054A4BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18054A810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18054A9E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void *__Block_byref_object_copy__4090(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__4091(uint64_t a1)
{
}

void sub_18054B08C(_Unwind_Exception *a1)
{
}

CFStringRef ___is_apple_bundle_block_invoke()
{
  MainBundle = CFBundleGetMainBundle();
  uint64_t result = CFBundleGetIdentifier(MainBundle);
  if (result)
  {
    uint64_t result = (const __CFString *)CFStringHasPrefix(result, @"com.apple.");
    BOOL v2 = (_DWORD)result != 0;
  }

  else
  {
    BOOL v2 = 1;
  }

  _is_apple_bundle_uint64_t result = v2;
  return result;
}

sec_identity_t sec_identity_create(SecIdentityRef identity)
{
  return (sec_identity_t)-[SecConcrete_sec_identity initWithIdentity:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_identity),  "initWithIdentity:",  identity);
}

sec_identity_t sec_identity_create_with_certificates(SecIdentityRef identity, CFArrayRef certificates)
{
  return (sec_identity_t)-[SecConcrete_sec_identity initWithIdentityAndCertificates:certificates:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_identity),  "initWithIdentityAndCertificates:certificates:",  identity,  certificates);
}

SecConcrete_sec_identity *sec_identity_create_with_certificates_and_external_private_key( uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a4;
  id v8 = a3;
  id v9 = a2;
  unint64_t v10 = -[SecConcrete_sec_identity initWithCertificates:signBlock:decryptBlock:queue:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_identity),  "initWithCertificates:signBlock:decryptBlock:queue:",  a1,  v9,  v8,  v7);

  return v10;
}

SecIdentityRef sec_identity_copy_ref(sec_identity_t identity)
{
  else {
    return 0LL;
  }
}

CFArrayRef sec_identity_copy_certificates_ref(sec_identity_t identity)
{
  else {
    return 0LL;
  }
}

BOOL sec_identity_access_certificates(sec_identity_t identity, void *handler)
{
  uint64_t v3 = handler;
  uint64_t v4 = v3;
  if (identity)
  {
    identity = (sec_identity_t)*((void *)identity + 2);
    if (identity)
    {
      context[0] = MEMORY[0x1895F87A8];
      context[1] = 3221225472LL;
      context[2] = __sec_identity_access_certificates_block_invoke;
      context[3] = &unk_18966F028;
      id v7 = v3;
      v8.size_t length = CFArrayGetCount(identity);
      v8.location = 0LL;
      CFArrayApplyFunction(identity, v8, (CFArrayApplierFunction)apply_block_1, context);

      LOBYTE(identity) = 1;
    }
  }

  return (char)identity;
}

void __sec_identity_access_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = -[SecConcrete_sec_certificate initWithCertificate:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_certificate),  "initWithCertificate:",  a2);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

uint64_t apply_block_1(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sec_identity_has_certificates(BOOL result)
{
  if (result) {
    return *(void *)(result + 16) != 0LL;
  }
  return result;
}

void *sec_identity_copy_private_key_sign_block(uint64_t a1)
{
  else {
    return 0LL;
  }
}

void *sec_identity_copy_private_key_decrypt_block(uint64_t a1)
{
  else {
    return 0LL;
  }
}

id sec_identity_copy_private_key_queue(uint64_t a1)
{
  else {
    return 0LL;
  }
}

SecConcrete_sec_protocol_configuration_builder *sec_protocol_configuration_builder_create( uint64_t a1, uint64_t a2)
{
  return -[SecConcrete_sec_protocol_configuration_builder initWithDictionary:andInternalFlag:]( objc_alloc(&OBJC_CLASS___SecConcrete_sec_protocol_configuration_builder),  "initWithDictionary:andInternalFlag:",  a1,  a2);
}

SecConcrete_sec_protocol_configuration *sec_protocol_configuration_create_with_builder(void *a1)
{
  id v1 = a1;
  BOOL v2 = objc_alloc_init(&OBJC_CLASS___SecConcrete_sec_protocol_configuration);
  if (v2)
  {
    int v3 = *((unsigned __int8 *)v1 + 16);
    BOOL v4 = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEBUG);
    if (v3)
    {
      if (v4)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_debug_impl( &dword_1804F4000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEBUG,  "Building default configuration for first-party bundle",  buf,  2u);
      }

      uint64_t v5 = v2->dictionary;
      xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_value(v5, "NSExceptionDomains", v6);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsInWebContent", 1);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsForMedia", 1);
      xpc_dictionary_set_BOOL(v5, "NSAllowsLocalNetworking", 1);
      id v7 = v5;
      BOOL v8 = 1;
    }

    else
    {
      if (v4)
      {
        *(_WORD *)id v16 = 0;
        _os_log_debug_impl( &dword_1804F4000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEBUG,  "Building default configuration for third-party bundle",  v16,  2u);
      }

      uint64_t v5 = v2->dictionary;
      xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_value(v5, "NSExceptionDomains", v6);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsInWebContent", 0);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsForMedia", 0);
      xpc_dictionary_set_BOOL(v5, "NSAllowsLocalNetworking", 0);
      id v7 = v5;
      BOOL v8 = 0;
    }

    xpc_dictionary_set_BOOL(v7, "NSAllowsArbitraryLoads", v8);

    id v9 = v2->dictionary;
    sec_protocol_configuration_register_builtin_exception(v9, "apple.com", 0x303u);
    sec_protocol_configuration_register_builtin_exception(v9, "ls.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "gs.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "geo.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "is.autonavi.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "apple-mapkit.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "setup.icloud.com", 0x303u);

    unint64_t v10 = (void *)v1[1];
    BOOL v11 = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEBUG);
    if (v10)
    {
      if (v11)
      {
        *(_WORD *)int v15 = 0;
        _os_log_debug_impl( &dword_1804F4000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEBUG,  "Setting configuration overrides based on AppTransportSecurity exceptions",  v15,  2u);
      }

      sec_protocol_configuration_set_ats_overrides((uint64_t)v2, v10);
    }

    else if (v11)
    {
      *(_WORD *)BOOL v14 = 0;
      _os_log_debug_impl( &dword_1804F4000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEBUG,  "Using default configuration settings",  v14,  2u);
    }
  }

  else if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
  {
    v13[0] = 0;
    _os_log_error_impl( &dword_1804F4000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_ERROR,  "sec_protocol_configuration_create failed",  (uint8_t *)v13,  2u);
  }

  return v2;
}

void sub_18054C088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_18054C240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

LABEL_3:
    id v7 = v6;
    goto LABEL_13;
  }

  BOOL v8 = [MEMORY[0x189604030] fileURLWithPath:v3 isDirectory:0];
  if (v8)
  {
    id v9 = (void *)v8;
    unint64_t v10 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle();
    BOOL v11 = v10;
    if (v10)
    {
      unint64_t v12 = CFBundleCopyBundleURL(v10);

      if (v12)
      {
        [MEMORY[0x1896077F8] bundleWithURL:v12];
        BOOL v4 = (void *)objc_claimAutoreleasedReturnValue();

        if (v4) {
          goto LABEL_2;
        }
        goto LABEL_20;
      }

      id v9 = 0LL;
    }
  }

  uint64_t v21 = @"Failed to export public bytes";
LABEL_4:
  SOSCreateErrorWithFormat(1034LL, 0LL, a9, 0LL, @"%@", v21);
  uint64_t v22 = 0LL;
LABEL_5:
  CFRelease((CFTypeRef)Instance);
LABEL_6:
  CFRelease(v20);
  unint64_t v23 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v23);
  }

  ThreadErrInfo = PR_getThreadErrInfo(1, &v10);
  if (ThreadErrInfo) {
    *ThreadErrInfo = 0xFFFFE00900000000LL;
  }
  BOOL v4 = 0xFFFFFFFFLL;
LABEL_11:
  PORT_FreeArena(*(void **)a1, 0);
  return v4;
}

void *CoreAnalyticsLibrary()
{
  if (!CoreAnalyticsLibraryCore_frameworkLibrary) {
    CoreAnalyticsLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  os_log_t v0 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
  if (!CoreAnalyticsLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    os_log_t v0 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *CoreAnalyticsLibrary(void)"];
    BOOL v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v0,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"SecCoreAnalytics.m",  195,  @"%s",  0);

    __break(1u);
    free(v3);
  }

  return v0;
}

void SecCoreAnalyticsSendValue(uint64_t a1, uint64_t a2)
{
  v6[1] = *MEMORY[0x1895F89C0];
  uint64_t v5 = @"value";
  [MEMORY[0x189607968] numberWithLong:a2];
  int v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = v3;
  [MEMORY[0x189603F68] dictionaryWithObjects:v6 forKeys:&v5 count:1];
  BOOL v4 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCoreAnalytics sendEvent:event:](&OBJC_CLASS___SecCoreAnalytics, "sendEvent:event:", a1, v4);
}

void SecCoreAnalyticsSendKernEntropyAnalytics()
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v20 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname("kern.entropy.health.startup_done", &v20, (size_t *)&v22, 0LL, 0LL) < 0 || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.startup_done";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
LABEL_37:
    BOOL v8 = (uint8_t *)&v22;
LABEL_38:
    _os_log_error_impl(&dword_1804F4000, v7, OS_LOG_TYPE_ERROR, "failed to read sysctl %s", v8, 0xCu);
    goto LABEL_39;
  }

  int v19 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname("kern.entropy.health.adaptive_proportion_test.failure_count", &v19, (size_t *)&v22, 0LL, 0LL) < 0
    || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.failure_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

  int v18 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname( "kern.entropy.health.adaptive_proportion_test.max_observation_count",  &v18,  (size_t *)&v22,  0LL,  0LL) < 0 || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.max_observation_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

  unsigned int v17 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname("kern.entropy.health.adaptive_proportion_test.reset_count", &v17, (size_t *)&v22, 0LL, 0LL) < 0
    || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.reset_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

  int v16 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname("kern.entropy.health.repetition_count_test.failure_count", &v16, (size_t *)&v22, 0LL, 0LL) < 0
    || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.failure_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

  int v15 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if (sysctlbyname("kern.entropy.health.repetition_count_test.max_observation_count", &v15, (size_t *)&v22, 0LL, 0LL) < 0
    || (void)v22 != 4LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.max_observation_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

  unsigned int v14 = -1431655766;
  *(void *)&__int128 v22 = 4LL;
  if ((sysctlbyname("kern.entropy.health.repetition_count_test.reset_count", &v14, (size_t *)&v22, 0LL, 0LL) & 0x80000000) == 0
    && (void)v22 == 4LL)
  {
    unsigned int v0 = v17;
    uint64_t v1 = 1LL << -(char)__clz(v17);
    if ((v17 & (v17 - 1)) != 0) {
      unsigned int v0 = v1;
    }
    unsigned int v17 = v0;
    unsigned int v2 = v14;
    uint64_t v3 = 1LL << -(char)__clz(v14);
    if ((v14 & (v14 - 1)) != 0) {
      unsigned int v2 = v3;
    }
    unsigned int v14 = v2;
    int v4 = v19 | v16;
    if (!(v19 | v16))
    {
      int v6 = 0;
      int v5 = -1;
      goto LABEL_56;
    }

    time_t v21 = 0xAAAAAAAAAAAAAAAALL;
    time(&v21);
    *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(void *)int v31 = 16LL;
    if ((sysctlbyname("kern.boottime", &v22, (size_t *)v31, 0LL, 0LL) & 0x80000000) == 0 && *(void *)v31 == 16LL)
    {
      int v5 = ((int)v21 - (int)v22) / 60;
      int v4 = v19;
      int v6 = v16;
      unsigned int v0 = v17;
      unsigned int v2 = v14;
LABEL_56:
      *(void *)&__int128 v22 = MEMORY[0x1895F87A8];
      *((void *)&v22 + 1) = 3221225472LL;
      unint64_t v23 = __SecCoreAnalyticsSendKernEntropyHealthAnalytics_block_invoke;
      char v24 = &__block_descriptor_64_e19___NSDictionary_8__0l;
      double v25 = COERCE_DOUBLE(__PAIR64__(v20, v5));
      unint64_t v26 = __PAIR64__(v18, v4);
      unsigned int v27 = v0;
      int v28 = v6;
      int v29 = v15;
      unsigned int v30 = v2;
      +[SecCoreAnalytics sendEventLazy:builder:]( &OBJC_CLASS___SecCoreAnalytics,  "sendEventLazy:builder:",  @"com.apple.kern.entropyHealth",  &v22);
      goto LABEL_39;
    }

    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    *(_DWORD *)int v31 = 136315138;
    *(void *)&v31[4] = "kern.boottime";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    BOOL v8 = v31;
    goto LABEL_38;
  }

  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR))
  {
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.reset_count";
    id v7 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_37;
  }

LABEL_39:
  *(void *)int v31 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v22 = 8LL;
  if (sysctlbyname("kern.entropy.filter.rejected_sample_count", v31, (size_t *)&v22, 0LL, 0LL) < 0
    || (void)v22 != 8LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      return;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.filter.rejected_sample_count";
    uint64_t v13 = (os_log_s *)MEMORY[0x1895F8DA0];
    goto LABEL_54;
  }

  time_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v22 = 8LL;
  if (sysctlbyname("kern.entropy.filter.total_sample_count", &v21, (size_t *)&v22, 0LL, 0LL) < 0 || (void)v22 != 8LL)
  {
    if (!os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
      return;
    }
    LODWORD(v22) = 136315138;
    *(void *)((char *)&v22 + 4) = "kern.entropy.filter.total_sample_count";
    uint64_t v13 = (os_log_s *)MEMORY[0x1895F8DA0];
LABEL_54:
    _os_log_error_impl(&dword_1804F4000, v13, OS_LOG_TYPE_ERROR, "failed to read sysctl %s", (uint8_t *)&v22, 0xCu);
    return;
  }

  time_t v9 = v21;
  *((void *)&v22 + 1) = 3221225472LL;
  double v10 = (double)(unint64_t)v21;
  unint64_t v11 = __clz(v21);
  if (v11) {
    uint64_t v12 = 1LL << -(char)v11;
  }
  else {
    uint64_t v12 = -1LL;
  }
  if ((v21 & (v21 - 1)) != 0) {
    time_t v9 = v12;
  }
  time_t v21 = v9;
  *(void *)&__int128 v22 = MEMORY[0x1895F87A8];
  unint64_t v23 = __SecCoreAnalyticsSendKernEntropyFilterAnalytics_block_invoke;
  char v24 = &__block_descriptor_48_e19___NSDictionary_8__0l;
  double v25 = (double)*(unint64_t *)v31 / v10;
  unint64_t v26 = v9;
  +[SecCoreAnalytics sendEventLazy:builder:]( &OBJC_CLASS___SecCoreAnalytics,  "sendEventLazy:builder:",  @"com.apple.kern.entropy.filter",  &v22);
}

  if (+[OTClique platformSupportsSOS](&OBJC_CLASS___OTClique, "platformSupportsSOS"))
  {
    if (+[OTClique platformSupportsSOS](&OBJC_CLASS___OTClique, "platformSupportsSOS"))
    {
      id v44 = 0LL;
      double v25 = SOSCCRequestToJoinCircle((CFTypeRef *)&v44);
      secLogObjForScope("clique-legacy");
      id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109378;
        *(_DWORD *)uint64_t v48 = v25;
        *(_WORD *)&v48[4] = 2112;
        *(void *)&v48[6] = v44;
        _os_log_impl(&dword_1804F4000, v36, OS_LOG_TYPE_DEFAULT, "sos requestToJoinCircle complete: %d %@", buf, 0x12u);
      }

      if (a3) {
        *a3 = v44;
      }
      else {
    }
      }

    else
    {
      double v25 = 0;
    }

    int v41 = _OctagonSignpostGetNanoseconds(v6, v7);
    _OctagonSignpostLogSystem();
    __int128 v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v43 = v42;
    if (v10 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v42))
    {
      *(_DWORD *)__int128 buf = 67240192;
      *(_DWORD *)uint64_t v48 = v25;
      _os_signpost_emit_with_name_impl( &dword_1804F4000,  v43,  OS_SIGNPOST_INTERVAL_END,  v6,  "RequestToJoinCircle",  " OctagonSignpostNameRequestToJoinCircle=%{public,signpost.telemetry:number1,name=OctagonSignpostNameRequestToJoinCircle}d ",  buf,  8u);
    }

    _OctagonSignpostLogSystem();
    int v19 = (void *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218496;
      *(void *)uint64_t v48 = v6;
      *(_WORD *)&void v48[8] = 2048;
      *(double *)&v48[10] = (double)v41 / 1000000000.0;
      uint64_t v49 = 1026;
      char v50 = v25;
      goto LABEL_59;
    }
  }

  else
  {
    secLogObjForScope("clique-legacy");
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v37,  OS_LOG_TYPE_DEFAULT,  "requestToJoinCircle platform does not support SOS",  buf,  2u);
    }

    unint64_t v38 = _OctagonSignpostGetNanoseconds(v6, v7);
    _OctagonSignpostLogSystem();
    uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v40 = v39;
    if (v10 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v39))
    {
      *(_DWORD *)__int128 buf = 67240192;
      *(_DWORD *)uint64_t v48 = 1;
      _os_signpost_emit_with_name_impl( &dword_1804F4000,  v40,  OS_SIGNPOST_INTERVAL_END,  v6,  "RequestToJoinCircle",  " OctagonSignpostNameRequestToJoinCircle=%{public,signpost.telemetry:number1,name=OctagonSignpostNameRequestToJoinCircle}d ",  buf,  8u);
    }

    _OctagonSignpostLogSystem();
    int v19 = (void *)objc_claimAutoreleasedReturnValue();
    LOBYTE(v25) = 1;
    if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218496;
      *(void *)uint64_t v48 = v6;
      *(_WORD *)&void v48[8] = 2048;
      *(double *)&v48[10] = (double)v38 / 1000000000.0;
      uint64_t v49 = 1026;
      char v50 = 1;
LABEL_59:
      _os_log_impl( &dword_1804F4000,  (os_log_t)v19,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: RequestToJoinCircle  OctagonSignpostNameRequestToJoinCircle=%{public,signpost.telemetry:number1, name=OctagonSignpostNameRequestToJoinCircle}d ",  buf,  0x1Cu);
    }
  }

  Security::CFRef<void const*>::~CFRef(cf);
  unsigned int v35 = CFDictionaryGetValue(theDict, @"cmssize");
  id v36 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v35, (Security::MacOSError *)v132);
  if (v36) {
    id v37 = Security::cfNumber<unsigned long>(v36);
  }
  else {
    id v37 = 18000LL;
  }
  *((void *)this + 16) = v37;
  unint64_t v38 = CFDictionaryGetValue(theDict, @"preserve-metadata");
  uint64_t v39 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v38, (Security::MacOSError *)v132);
  if (v39) {
    LODWORD(v39) = Security::cfNumber<unsigned int>(v39);
  }
  *((_DWORD *)this + 35) = (_DWORD)v39;
  char v40 = CFDictionaryGetValue(theDict, @"signing-time");
  int v41 = v40;
  if (v40)
  {
    __int128 v42 = CFGetTypeID(v40);
    CFRetain(v41);
    id v43 = (const void *)*((void *)this + 6);
    if (v43) {
      CFRelease(v43);
    }
    *((void *)this + 6) = v41;
  }

  id v44 = (const __CFString *)CFDictionaryGetValue(theDict, @"identifier");
  Security::CFRef<__CFString const*>::check<void const*>(v44, (Security::MacOSError *)v132);
  if (v44)
  {
    Security::cfString(&values, v44);
    id v45 = (void **)((char *)this + 176);
    *(_OWORD *)id v45 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 24) = values.__r_.__value_.__l.__cap_;
  }

  id v46 = (const __CFString *)CFDictionaryGetValue(theDict, @"teamidentifier");
  Security::CFRef<__CFString const*>::check<void const*>(v46, (Security::MacOSError *)v132);
  if (v46)
  {
    Security::cfString(&values, v46);
    uint64_t v47 = (void **)((char *)this + 224);
    *(_OWORD *)uint64_t v47 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 30) = values.__r_.__value_.__l.__cap_;
  }

  uint64_t v48 = CFDictionaryGetValue(theDict, @"platform-identifier");
  uint64_t v49 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v48, (Security::MacOSError *)v132);
  if (v49)
  {
    values.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    char v50 = (Security::CFError *)CFNumberGetValue(v49, kCFNumberLongLongType, &values);
    if (!(_DWORD)v50) {
      Security::CFError::throwMe(v50);
    }
    if (values.__r_.__value_.__r.__words[0] >= 0x100) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA43LL);
    }
    *((_BYTE *)this + 24_Block_object_dispose(va, 8) = values.__r_.__value_.__s.__data_[0];
  }

  uint64_t v51 = (const __CFString *)CFDictionaryGetValue(theDict, @"identifier-prefix");
  Security::CFRef<__CFString const*>::check<void const*>(v51, (Security::MacOSError *)v132);
  if (v51)
  {
    Security::cfString(&values, v51);
    unsigned int v52 = (void **)((char *)this + 200);
    *(_OWORD *)unsigned int v52 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((void *)this + 27) = values.__r_.__value_.__l.__cap_;
  }

  id v53 = CFDictionaryGetValue(theDict, @"requirements");
  CFIndex v54 = v53;
  if (v53)
  {
    id v55 = CFGetTypeID(v53);
    if (v55 != CFDataGetTypeID())
    {
      char v56 = CFGetTypeID(v54);
      if (v56 != CFStringGetTypeID()) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
      }
    }

    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 15, v54);
  }

  else
  {
    uint64_t v57 = (const void *)*((void *)this + 15);
    if (v57) {
      CFRelease(v57);
    }
    *((void *)this + 15) = 0LL;
  }

  CFIndex v58 = CFDictionaryGetValue(theDict, @"no-macho");
  unint64_t v59 = Security::CFRef<__CFBoolean const*>::check<void const*>(v58, (Security::MacOSError *)v132);
  if (v59) {
    id v60 = v59 == v11;
  }
  else {
    id v60 = 0;
  }
  id v61 = v60;
  *((_BYTE *)this + 249) = v61;
  id v62 = CFDictionaryGetValue(theDict, @"pagesize");
  Security::CFRef<__CFNumber const*>::check<void const*>(v62, (Security::MacOSError *)v132);
  if (v62) {
    CFRetain(v62);
  }
  id v63 = (const void *)*((void *)this + 32);
  if (v63) {
    CFRelease(v63);
  }
  *((void *)this + 32) = v62;
  uint64_t v64 = CFDictionaryGetValue(theDict, @"detached");
  id v65 = *Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 4, v64);
  if (v65)
  {
    id v66 = CFGetTypeID(v65);
    if (v66 != CFURLGetTypeID() && v66 != CFDataGetTypeID() && v66 != CFNullGetTypeID()) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
    }
  }

  uint64_t v67 = CFDictionaryGetValue(theDict, @"resource-rules");
  unint64_t v68 = v67;
  if (v67)
  {
    uint64_t v3 = v132;
    int v69 = CFGetTypeID(v67);
    if (v69 != CFDictionaryGetTypeID()) {
      goto LABEL_167;
    }
  }

  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 5, v68);
  unint64_t v70 = CFDictionaryGetValue(theDict, @"application-specific");
  Security::CFRef<__CFData const*>::check<void const*>(v70, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 7, v70);
  id v71 = CFDictionaryGetValue(theDict, @"entitlements");
  Security::CFRef<__CFData const*>::check<void const*>(v71, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 8, v71);
  unint64_t v72 = CFDictionaryGetValue(theDict, @"force-library-entitlements");
  __int128 v73 = Security::CFRef<__CFBoolean const*>::check<void const*>(v72, (Security::MacOSError *)v132);
  if (v73) {
    id v74 = v73 == v11;
  }
  else {
    id v74 = 0;
  }
  __int128 v75 = v74;
  *((_BYTE *)this + 72) = v75;
  __int128 v76 = *((void *)this + 10);
  __int128 v77 = (const void **)*((void *)this + 11);
  __int128 v78 = (uint64_t)v77 - v76;
  if ((unint64_t)v77 - v76 > 0x17)
  {
    if (v78 != 24)
    {
      __int128 v92 = (const void **)(v76 + 24);
      while (v77 != v92)
        Security::CFRef<__CFData const*>::~CFRef(--v77);
      *((void *)this + 11) = v92;
    }
  }

  else
  {
    id v79 = 3 - (v78 >> 3);
    __int128 v80 = *((void *)this + 12);
    if (v79 <= (v80 - (uint64_t)v77) >> 3)
    {
      bzero(*((void **)this + 11), 8 * v79);
      *((void *)this + 11) = &v77[v79];
    }

    else
    {
      __int128 v81 = v80 - v76;
      __int128 v82 = v81 >> 2;
      else {
        __int128 v83 = v82;
      }
      __int128 v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v83);
      __int128 v86 = *((void *)this + 10);
      __int128 v85 = *((void *)this + 11);
      id v87 = &v84[8 * (v78 >> 3)];
      __int128 v89 = &v84[8 * v88];
      bzero(v87, 8 * v79);
      __int128 v90 = &v87[8 * v79];
      while (v85 != v86)
      {
        __int128 v91 = *(void *)(v85 - 8);
        v85 -= 8LL;
        *((void *)v87 - 1) = v91;
        v87 -= 8;
      }

      char v93 = *((_OWORD *)this + 5);
      *((void *)this + 10) = v87;
      *((void *)this + 11) = v90;
      *((void *)this + 12) = v89;
      __int128 v94 = (const void **)*((void *)&v93 + 1);
      __int128 v95 = (const void **)v93;
      while (v94 != v95)
        __int128 v94 = Security::CFRef<__CFData const*>::~CFRef(v94 - 1);
      if (v95) {
        operator delete(v95);
      }
    }
  }

  char v96 = CFDictionaryGetValue(theDict, @"lwcr-self");
  Security::CFRef<__CFData const*>::check<void const*>(v96, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=(*((CFTypeRef **)this + 10), v96);
  uint64_t v97 = CFDictionaryGetValue(theDict, @"lwcr-parent");
  Security::CFRef<__CFData const*>::check<void const*>(v97, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((void *)this + 10) + 8LL), v97);
  BOOL v98 = CFDictionaryGetValue(theDict, @"lwcr-responsible");
  Security::CFRef<__CFData const*>::check<void const*>(v98, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((void *)this + 10) + 16LL), v98);
  BOOL v99 = CFDictionaryGetValue(theDict, @"lwcr-library");
  Security::CFRef<__CFData const*>::check<void const*>(v99, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 13, v99);
  BOOL v100 = CFDictionaryGetValue(theDict, @"timestamp-required");
  BOOL v101 = Security::CFRef<__CFBoolean const*>::check<void const*>(v100, (Security::MacOSError *)v132);
  if (v101)
  {
    *((_BYTE *)this + 280) = v101 == v11;
    goto LABEL_129;
  }

  *((_BYTE *)this + 280) = 0;
  BOOL v102 = *((void *)this + 3);
  if (v102 && v102 != *MEMORY[0x189605018])
  {
    values.__r_.__value_.__r.__words[0] = *(void *)(v102 + 16);
    CFRetain(values.__r_.__value_.__l.__data_);
    uint64_t v103 = values.__r_.__value_.__r.__words[0];
    LOBYTE(cf[0]) = 0;
    id v104 = (const __CFString *)CFDataCreateWithBytesNoCopy( 0LL,  Security::CodeSigning::caspianLeafMarker,  10LL,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
    id v105 = v104;
    if (v103 && v104)
    {
      uint64_t v106 = SecCertificateCopyExtensionValue(v103, v104, cf);
      CFTypeRef v107 = v106 != 0LL;
      if (v106)
      {
        CFRelease(v106);
        CFTypeRef v107 = 1;
      }
    }

    else
    {
      if (!v104) {
        goto LABEL_127;
      }
      CFTypeRef v107 = 0;
    }

    CFRelease(v105);
    if (v107)
    {
      *((_BYTE *)this + 280) = 1;
      goto LABEL_174;
    }

id __SecCoreAnalyticsSendKernEntropyHealthAnalytics_block_invoke(unsigned int *a1)
{
  __int16 v13[8] = *MEMORY[0x1895F89C0];
  v12[0] = @"uptime";
  [MEMORY[0x189607968] numberWithInt:a1[8]];
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue();
  v13[0] = v2;
  v12[1] = @"startup_done";
  [MEMORY[0x189607968] numberWithInt:a1[9]];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  v13[1] = v3;
  void v12[2] = @"adaptive_proportion_failure_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[10]];
  int v4 = (void *)objc_claimAutoreleasedReturnValue();
  void v13[2] = v4;
  v12[3] = @"adaptive_proportion_max_observation_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[11]];
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  void v13[3] = v5;
  _OWORD v12[4] = @"adaptive_proportion_reset_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[12]];
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  v13[4] = v6;
  v12[5] = @"repetition_failure_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[13]];
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  v13[5] = v7;
  void v12[6] = @"repetition_max_observation_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[14]];
  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue();
  v13[6] = v8;
  v12[7] = @"repetition_reset_count";
  [MEMORY[0x189607968] numberWithUnsignedInt:a1[15]];
  time_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  v13[7] = v9;
  [MEMORY[0x189603F68] dictionaryWithObjects:v13 forKeys:v12 count:8];
  double v10 = (void *)objc_claimAutoreleasedReturnValue();

  return v10;
}

id __SecCoreAnalyticsSendKernEntropyFilterAnalytics_block_invoke(uint64_t a1)
{
  void v7[2] = *MEMORY[0x1895F89C0];
  v6[0] = @"rejection_rate";
  [MEMORY[0x189607968] numberWithDouble:*(double *)(a1 + 32)];
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue();
  v6[1] = @"total_sample_count";
  v7[0] = v2;
  [MEMORY[0x189607968] numberWithUnsignedLongLong:*(void *)(a1 + 40)];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  v7[1] = v3;
  [MEMORY[0x189603F68] dictionaryWithObjects:v7 forKeys:v6 count:2];
  int v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void SecCoreAnalyticsSendLegacyKeychainUIEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = +[SecCoreAnalytics appNameFromPath:](&OBJC_CLASS___SecCoreAnalytics, "appNameFromPath:", v3);

  uint64_t v5 = [NSString stringWithCString:a1 encoding:4];
  int v6 = (void *)v5;
  if (v4) {
    id v7 = (__CFString *)v4;
  }
  else {
    id v7 = @"unknown";
  }
  if (v5)
  {
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = __SecCoreAnalyticsSendLegacyKeychainUIEvent_block_invoke;
    unint64_t v9[3] = &unk_1896675C0;
    double v10 = v7;
    id v11 = v6;
    +[SecCoreAnalytics sendEventLazy:builder:]( &OBJC_CLASS___SecCoreAnalytics,  "sendEventLazy:builder:",  @"com.apple.security.LegacyAPICounts",  v9);

    BOOL v8 = (os_log_s *)v10;
  }

  else
  {
    secLogObjForScope("SecError");
    BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "Logging keychain UI event failed: couldn't turn dialog type c_str into NSString",  buf,  2u);
    }
  }
}

id __SecCoreAnalyticsSendLegacyKeychainUIEvent_block_invoke(uint64_t a1)
{
  unint64_t v4[2] = *MEMORY[0x1895F89C0];
  v3[0] = @"app";
  v3[1] = @"api";
  uint64_t v1 = *(void *)(a1 + 40);
  v4[0] = *(void *)(a1 + 32);
  v4[1] = v1;
  [MEMORY[0x189603F68] dictionaryWithObjects:v4 forKeys:v3 count:2];
  return (id)objc_claimAutoreleasedReturnValue();
}

void sub_18054D4E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

id sec_protocol_configuration_copy_singleton()
{
  if (sec_protocol_configuration_copy_singleton_onceToken != -1) {
    dispatch_once(&sec_protocol_configuration_copy_singleton_onceToken, &__block_literal_global_4428);
  }
  return (id)sec_protocol_configuration_copy_singleton_singleton;
}

void __sec_protocol_configuration_copy_singleton_block_invoke()
{
  unsigned int v2 = objc_alloc_init(&OBJC_CLASS___SecConcrete_sec_protocol_configuration_builder);
  unsigned int v0 = sec_protocol_configuration_create_with_builder(v2);
  uint64_t v1 = (void *)sec_protocol_configuration_copy_singleton_singleton;
  sec_protocol_configuration_copy_singleton_singleton = (uint64_t)v0;
}

void *sec_protocol_configuration_copy_transformed_options(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = v2;
  if (v2)
  {
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&__block_literal_global_13);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    void v5[2] = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
    v5[3] = &__block_descriptor_tmp_11;
    __int16 v6 = 3;
    sec_protocol_options_access_handle((uint64_t)v3, (uint64_t)v5);
  }

  sec_protocol_configuration_copy_transformed_options_with_ats_minimums(v3);
  objc_claimAutoreleasedReturnValue();

  return v3;
}

id sec_protocol_configuration_copy_transformed_options_with_ats_minimums(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = MEMORY[0x1895F87A8];
    uint64_t v5 = MEMORY[0x1895F87A8];
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_ats_required_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_52;
    LOBYTE(v9) = 1;
    sec_protocol_options_access_handle((uint64_t)v1, (uint64_t)&v5);
    uint64_t v5 = v3;
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_trusted_peer_certificate_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_56;
    LOBYTE(v9) = 1;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    uint64_t v5 = v3;
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_minimum_rsa_key_size_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_53;
    uint64_t v9 = 2048LL;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    uint64_t v5 = v3;
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_54_3198;
    uint64_t v9 = 256LL;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    uint64_t v5 = v3;
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_minimum_signature_algorithm_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_55_3199;
    LODWORD(v9) = 6;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    uint64_t v5 = v3;
    uint64_t v6 = 0x40000000LL;
    id v7 = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
    BOOL v8 = &__block_descriptor_tmp_14;
    LOWORD(v9) = 771;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
  }

  return v2;
}

uint64_t sec_protocol_configuration_copy_transformed_options_for_host(void *a1, void *a2, const char *a3)
{
  id v5 = a2;
  id v6 = a1;
  sec_protocol_configuration_copy_transformed_options_with_ats_minimums(v5);
  objc_claimAutoreleasedReturnValue();
  uint64_t v7 = sec_protocol_configuration_copy_transformed_options_for_host_internal(v6, v5, a3);

  return v7;
}

id sec_protocol_configuration_copy_transformed_options_for_host_internal(void *a1, void *a2, const char *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = v5[1];
  BOOL v8 = v7;
  if (v7)
  {
    xpc_dictionary_get_dictionary(v7, "NSExceptionDomains");
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    double v10 = v9;
    if (!v9)
    {
      id v13 = v6;
LABEL_23:

      goto LABEL_24;
    }

    xpc_dictionary_get_dictionary(v9, a3);
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v12 = v11;
    if (!v11)
    {
      size_t v14 = strlen(a3);
      if (!v14)
      {
LABEL_13:
        sec_protocol_configuration_copy_transformed_options(v14, v6);
        id v13 = v6;
LABEL_22:

        goto LABEL_23;
      }

      int v15 = a3;
      while (1)
      {
        int v16 = *(unsigned __int8 *)v15++;
        if (v16 == 46) {
          break;
        }
        if (!--v14) {
          goto LABEL_13;
        }
      }

      sec_protocol_configuration_copy_transformed_options_for_host_internal(v5, v6, a3 + 1);
      id v19 = (id)objc_claimAutoreleasedReturnValue();
LABEL_21:
      id v13 = v19;
      goto LABEL_22;
    }

    if (xpc_dictionary_get_BOOL(v11, "NSExceptionRequiresForwardSecrecy"))
    {
      if (!v6) {
        goto LABEL_17;
      }
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&__block_literal_global_13);
      uint64_t v21 = MEMORY[0x1895F87A8];
      uint64_t v22 = 0x40000000LL;
      unint64_t v23 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
      char v24 = &__block_descriptor_tmp_11;
      __int16 v25 = 3;
    }

    else
    {
      if (!v6) {
        goto LABEL_17;
      }
      uint64_t v21 = MEMORY[0x1895F87A8];
      uint64_t v22 = 0x40000000LL;
      unint64_t v23 = __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke;
      char v24 = &__block_descriptor_tmp_69;
      LOBYTE(v25) = 1;
    }

    sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
LABEL_17:
    __int16 int64 = xpc_dictionary_get_int64(v12, "NSExceptionMinimumTLSVersion");
    if (int64 && v6)
    {
      uint64_t v18 = MEMORY[0x1895F87A8];
      uint64_t v21 = MEMORY[0x1895F87A8];
      uint64_t v22 = 0x40000000LL;
      unint64_t v23 = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
      char v24 = &__block_descriptor_tmp_14;
      __int16 v25 = int64;
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
      uint64_t v21 = v18;
      uint64_t v22 = 0x40000000LL;
      unint64_t v23 = __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke;
      char v24 = &__block_descriptor_tmp_70;
      LOBYTE(v25) = 1;
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
    }

    id v19 = v6;
    goto LABEL_21;
  }

  id v13 = v6;
LABEL_24:

  return v13;
}

BOOL sec_protocol_configuration_tls_required(uint64_t a1)
{
  id v1 = *(id *)(a1 + 8);
  id v2 = v1;
  if (v1)
  {
    if (xpc_dictionary_get_BOOL(v1, "NSAllowsArbitraryLoadsForMedia"))
    {
      if (client_is_mediaserverd_onceToken != -1) {
        dispatch_once(&client_is_mediaserverd_onceToken, &__block_literal_global_22);
      }
      if (client_is_mediaserverd_is_mediaserverd) {
        goto LABEL_10;
      }
    }

    if (!xpc_dictionary_get_BOOL(v2, "NSAllowsArbitraryLoadsInWebContent")) {
      goto LABEL_12;
    }
    if (client_is_WebKit_onceToken != -1) {
      dispatch_once(&client_is_WebKit_onceToken, &__block_literal_global_25);
    }
    if (client_is_WebKit_is_WebKit) {
LABEL_10:
    }
      BOOL v3 = 0LL;
    else {
LABEL_12:
    }
      BOOL v3 = !xpc_dictionary_get_BOOL(v2, "NSAllowsArbitraryLoads");
  }

  else
  {
    BOOL v3 = 1LL;
  }

  return v3;
}

BOOL process_matches_target(BOOL __s)
{
  if (__s)
  {
    id v1 = (const char *)__s;
    if (get_running_process_onceToken != -1) {
      dispatch_once(&get_running_process_onceToken, &__block_literal_global_24);
    }
    if (get_running_process_processName
      && (size_t v2 = strlen(v1), v2 == strlen((const char *)get_running_process_processName)))
    {
      return strncmp((const char *)get_running_process_processName, v1, v2) == 0;
    }

    else
    {
      return 0LL;
    }
  }

  return __s;
}

uint64_t *__get_running_process_block_invoke()
{
  uint64_t result = (uint64_t *)_CFGetProgname();
  get_running_process_processName = *result;
  return result;
}

BOOL __client_is_mediaserverd_block_invoke()
{
  BOOL result = process_matches_target((BOOL)"mediaserverd");
  client_is_mediaserverd_is_mediaserverd = result;
  return result;
}

BOOL sec_protocol_configuration_tls_required_for_host(void *a1, const char *a2, uint64_t a3)
{
  return sec_protocol_configuration_tls_required_for_host_internal(a1, a2, 0, a3);
}

BOOL sec_protocol_configuration_tls_required_for_host_internal(void *a1, const char *a2, int a3, uint64_t a4)
{
  id v7 = a1;
  id v8 = v7[1];
  uint64_t v9 = v8;
  if (!v8)
  {
    BOOL v10 = 1LL;
    goto LABEL_20;
  }

  if (!(_DWORD)a4 || !xpc_dictionary_get_BOOL(v8, "NSAllowsLocalNetworking"))
  {
    xpc_dictionary_get_dictionary(v9, "NSExceptionDomains");
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v12 = v11;
    if (!v11)
    {
      BOOL v10 = sec_protocol_configuration_tls_required((uint64_t)v7);
LABEL_19:

      goto LABEL_20;
    }

    xpc_dictionary_get_dictionary(v11, a2);
    id v13 = (void *)objc_claimAutoreleasedReturnValue();
    size_t v14 = v13;
    if (v13)
    {
      BOOL v10 = !xpc_dictionary_get_BOOL(v13, "NSExceptionAllowsInsecureHTTPLoads");
      BOOL v15 = xpc_dictionary_get_BOOL(v14, "NSExceptionAllowsInsecureHTTPLoads");
      if (!a3 || !v15) {
        goto LABEL_18;
      }
    }

    else
    {
      size_t v16 = strlen(a2);
      if (v16)
      {
        unsigned int v17 = a2;
        while (1)
        {
          int v18 = *(unsigned __int8 *)v17++;
          if (v18 == 46) {
            break;
          }
          if (!--v16) {
            goto LABEL_16;
          }
        }

        uint64_t v19 = sec_protocol_configuration_tls_required_for_host_internal(v7, a2 + 1, 1LL, a4);
        goto LABEL_17;
      }
    }

BOOL sec_protocol_configuration_tls_required_for_address(uint64_t a1)
{
  id v1 = *(id *)(a1 + 8);
  size_t v2 = v1;
  if (v1) {
    BOOL v3 = !xpc_dictionary_get_BOOL(v1, "NSAllowsLocalNetworking");
  }
  else {
    BOOL v3 = 1LL;
  }

  return v3;
}

uint64_t tls1x_minor_version_digit_to_version(int a1)
{
  else {
    return (unsigned __int16)(a1 + 721);
  }
}

uint64_t dtls1x_minor_version_digit_to_version(int a1)
{
  if (a1 == 50) {
    unsigned __int16 v1 = -259;
  }
  else {
    unsigned __int16 v1 = 0;
  }
  if (a1 == 48) {
    return (unsigned __int16)-257;
  }
  return v1;
}

void sec_protocol_configuration_register_builtin_exception(void *a1, const char *a2, unsigned int a3)
{
  xpc_object_t value = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  if (value)
  {
    xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_value(v5, "NSExceptionDomains", value);
    xpc_dictionary_set_BOOL(v5, "NSIncludesSubdomains", 1);
    xpc_dictionary_set_int64(v5, "NSExceptionMinimumTLSVersion", a3);
    xpc_dictionary_set_BOOL(v5, "NSExceptionAllowsInsecureHTTPLoads", 1);
    xpc_dictionary_set_BOOL(v5, "NSExceptionRequiresForwardSecrecy", 0);
    xpc_dictionary_set_value(value, a2, v5);
  }
}

BOOL sec_protocol_configuration_set_ats_overrides(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  id v3 = *(id *)(a1 + 8);
  if (v3)
  {
    id v4 = a2;
    xpc_object_t v5 = (void *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"%s", "NSAllowsArbitraryLoads");
    [v4 objectForKeyedSubscript:v5];
    id v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      id v7 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsArbitraryLoads");
      [v4 valueForKey:v7];
      id v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (v8) {
        char v9 = [v8 BOOLValue];
      }
      else {
        char v9 = 0;
      }
    }

    else
    {
      char v9 = 0;
    }

    id v11 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsArbitraryLoadsInWebContent");
    [v4 objectForKeyedSubscript:v11];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12)
    {
      id v13 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsArbitraryLoadsInWebContent");
      [v4 valueForKey:v13];
      size_t v14 = (void *)objc_claimAutoreleasedReturnValue();

      if (v14) {
        char v15 = [v14 BOOLValue];
      }
      else {
        char v15 = 0;
      }
    }

    else
    {
      char v15 = 0;
    }

    size_t v16 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsArbitraryLoadsForMedia");
    [v4 objectForKeyedSubscript:v16];
    unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue();

    if (v17)
    {
      int v18 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsArbitraryLoadsForMedia");
      [v4 valueForKey:v18];
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();

      if (v19) {
        char v20 = [v19 BOOLValue];
      }
      else {
        char v20 = 0;
      }
    }

    else
    {
      char v20 = 0;
    }

    uint64_t v21 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsLocalNetworking");
    [v4 objectForKeyedSubscript:v21];
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (v22)
    {
      unint64_t v23 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSAllowsLocalNetworking");
      [v4 valueForKey:v23];
      char v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (v24) {
        char v25 = [v24 BOOLValue];
      }
      else {
        char v25 = 0;
      }
    }

    else
    {
      char v25 = 0;
    }

    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoads", v9);
    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoadsInWebContent", v15);
    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoadsForMedia", v20);
    xpc_dictionary_set_BOOL(v3, "NSAllowsLocalNetworking", v25);
    unint64_t v26 = (void *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"%s", "NSExceptionDomains");
    [v4 valueForKey:v26];
    unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue();

    if (v27)
    {
      xpc_dictionary_get_dictionary(v3, "NSExceptionDomains");
      int v28 = (void *)objc_claimAutoreleasedReturnValue();
      int v29 = v28;
      BOOL v10 = v28 != 0LL;
      if (v28)
      {
        v31[0] = MEMORY[0x1895F87A8];
        v31[1] = 3221225472LL;
        v31[2] = __sec_protocol_configuration_set_ats_overrides_block_invoke;
        unint64_t v31[3] = &unk_1896676A0;
        id v32 = v28;
        [v27 enumerateKeysAndObjectsUsingBlock:v31];
      }
    }

    else
    {
      BOOL v10 = 1LL;
    }
  }

  else
  {
    BOOL v10 = 0LL;
  }

  return v10;
}

void __sec_protocol_configuration_set_ats_overrides_block_invoke(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v40 = a3;
  if (!v40) {
    *a4 = 1;
  }
  id v7 = (objc_class *)NSString;
  id v8 = a2;
  char v9 = (void *)objc_msgSend([v7 alloc], "initWithFormat:", @"%s", "NSExceptionAllowsInsecureHTTPLoads");
  [v40 objectForKeyedSubscript:v9];
  BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();

  if (v10)
  {
    id v11 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSExceptionAllowsInsecureHTTPLoads");
    [v40 valueForKey:v11];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12) {
      char v13 = [v12 BOOLValue];
    }
    else {
      char v13 = 0;
    }
  }

  else
  {
    char v13 = 0;
  }

  size_t v14 = (void *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"%s", "NSIncludesSubdomains");
  [v40 objectForKeyedSubscript:v14];
  char v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    size_t v16 = (void *)objc_msgSend(objc_alloc(NSString), "initWithFormat:", @"%s", "NSIncludesSubdomains");
    [v40 valueForKey:v16];
    unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue();

    if (v17) {
      char v18 = [v17 BOOLValue];
    }
    else {
      char v18 = 0;
    }
  }

  else
  {
    char v18 = 0;
  }

  uint64_t v19 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSExceptionRequiresForwardSecrecy");
  [v40 objectForKeyedSubscript:v19];
  char v20 = (void *)objc_claimAutoreleasedReturnValue();

  if (v20)
  {
    uint64_t v21 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSExceptionRequiresForwardSecrecy");
    [v40 valueForKey:v21];
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (v22) {
      char v23 = [v22 BOOLValue];
    }
    else {
      char v23 = 0;
    }
  }

  else
  {
    char v23 = 0;
  }

  char v24 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSExceptionMinimumTLSVersion");
  [v40 objectForKeyedSubscript:v24];
  char v25 = (void *)objc_claimAutoreleasedReturnValue();

  if (v25)
  {
    unint64_t v26 = (void *)objc_msgSend( objc_alloc(NSString),  "initWithFormat:",  @"%s",  "NSExceptionMinimumTLSVersion");
    [v40 valueForKey:v26];
    unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue();

    if (v27) {
      int v28 = v27;
    }
    else {
      int v28 = @"TLSv1.2";
    }
  }

  else
  {
    int v28 = @"TLSv1.2";
  }

  xpc_object_t v29 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_BOOL(v29, "NSIncludesSubdomains", v18);
  xpc_dictionary_set_BOOL(v29, "NSExceptionAllowsInsecureHTTPLoads", v13);
  xpc_dictionary_set_BOOL(v29, "NSExceptionRequiresForwardSecrecy", v23);
  unsigned int v30 = v28;
  int v31 = (unsigned __int8 *)-[__CFString cStringUsingEncoding:](v30, "cStringUsingEncoding:", 4LL);
  if (v31
    && ((v32 = *v31, v33 = v32 == 68) ? (CFTypeID v34 = v31 + 1) : (CFTypeID v34 = v31),
        !strncmp((const char *)v34, "TLSv1.", 6uLL)
     && (unsigned int v39 = ((uint64_t (*)(void))off_189667688[v33])((char)v34[6])) != 0))
  {
    if (v34[7]) {
      int64_t v35 = 0LL;
    }
    else {
      int64_t v35 = v39;
    }
  }

  else
  {
    int64_t v35 = 0LL;
  }

  xpc_dictionary_set_int64(v29, "NSExceptionMinimumTLSVersion", v35);
  id v36 = *(void **)(a1 + 32);
  id v37 = v8;
  unint64_t v38 = (const char *)[v37 cStringUsingEncoding:4];

  xpc_dictionary_set_value(v36, v38, v29);
}

BOOL SECSFAActionTapToRadarReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x189611CF0];
  id v4 = (int *)MEMORY[0x189611CE8];
  xpc_object_t v5 = (int *)MEMORY[0x189611CE0];
  if (*(void *)(a2 + (int)*MEMORY[0x189611CF0]) < *(void *)(a2 + (int)*MEMORY[0x189611CE8]))
  {
    id v7 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5)) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0LL;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1LL || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(_BYTE *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0LL;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5)) {
        unint64_t v10 = 0LL;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(_BYTE *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 8LL;
          goto LABEL_24;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 40LL;
          goto LABEL_24;
        case 3u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24LL;
          goto LABEL_24;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32LL;
          goto LABEL_24;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16LL;
LABEL_24:
          uint64_t v19 = *(void **)(a1 + v18);
          *(void *)(a1 + v1_Block_object_dispose(va, 8) = v17;

          goto LABEL_25;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0LL;
          }
LABEL_25:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(_BYTE *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }

  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1805507BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_180551044( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1805515F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_18055233C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_180552AFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_18055334C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_180553A00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_180554158( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1805542D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_180557530( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_180557948(_Unwind_Exception *a1)
{
}

void sub_180557E40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4755(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__4756(uint64_t a1)
{
}

id getKCPairingChannelClass()
{
  uint64_t v4 = 0LL;
  xpc_object_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  unsigned int v0 = (void *)getKCPairingChannelClass_softClass;
  uint64_t v7 = getKCPairingChannelClass_softClass;
  if (!getKCPairingChannelClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getKCPairingChannelClass_block_invoke;
    v3[3] = &unk_1896734F0;
    v3[4] = &v4;
    __getKCPairingChannelClass_block_invoke((uint64_t)v3);
    unsigned int v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_180558FB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __getKCPairingChannelClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("KCPairingChannel");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getKCPairingChannelClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    size_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getKCPairingChannelClass(void)_block_invoke"];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"OTClique.m",  69,  @"Unable to find class %s",  "KCPairingChannel");

    __break(1u);
  }

void *KeychainCircleLibrary()
{
  if (!KeychainCircleLibraryCore_frameworkLibrary) {
    KeychainCircleLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  unsigned int v0 = (void *)KeychainCircleLibraryCore_frameworkLibrary;
  if (!KeychainCircleLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    unsigned int v0 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *KeychainCircleLibrary(void)"];
    size_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v0,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"OTClique.m",  64,  @"%s",  0);

    __break(1u);
    free(v3);
  }

  return v0;
}

id getAAFAnalyticsEventSecurityClass()
{
  uint64_t v4 = 0LL;
  xpc_object_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  unsigned int v0 = (void *)getAAFAnalyticsEventSecurityClass_softClass;
  uint64_t v7 = getAAFAnalyticsEventSecurityClass_softClass;
  if (!getAAFAnalyticsEventSecurityClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getAAFAnalyticsEventSecurityClass_block_invoke;
    v3[3] = &unk_1896734F0;
    v3[4] = &v4;
    __getAAFAnalyticsEventSecurityClass_block_invoke((uint64_t)v3);
    unsigned int v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_180559400( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void getkSecurityRTCEventCategoryAccountDataAccessRecovery()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  unsigned int v0 = (id *)getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr;
  uint64_t v8 = getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr;
  if (!getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr)
  {
    id v1 = KeychainCircleLibrary();
    unsigned int v0 = (id *)dlsym(v1, "kSecurityRTCEventCategoryAccountDataAccessRecovery");
    void v6[3] = (uint64_t)v0;
    getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    id v2 = *v0;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"NSNumber *getkSecurityRTCEventCategoryAccountDataAccessRecovery(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"OTClique.m",  74,  @"%s",  dlerror());

    __break(1u);
  }

void sub_1805594FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id getSecurityAnalyticsReporterRTCClass()
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  unsigned int v0 = (void *)getSecurityAnalyticsReporterRTCClass_softClass;
  uint64_t v7 = getSecurityAnalyticsReporterRTCClass_softClass;
  if (!getSecurityAnalyticsReporterRTCClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getSecurityAnalyticsReporterRTCClass_block_invoke;
    v3[3] = &unk_1896734F0;
    v3[4] = &v4;
    __getSecurityAnalyticsReporterRTCClass_block_invoke((uint64_t)v3);
    unsigned int v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1805595B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __getSecurityAnalyticsReporterRTCClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("SecurityAnalyticsReporterRTC");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getSecurityAnalyticsReporterRTCClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getSecurityAnalyticsReporterRTCClass(void)_block_invoke"];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"OTClique.m",  71,  @"Unable to find class %s",  "SecurityAnalyticsReporterRTC");

    __break(1u);
  }

void __getAAFAnalyticsEventSecurityClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("AAFAnalyticsEventSecurity");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getAAFAnalyticsEventSecurityClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getAAFAnalyticsEventSecurityClass(void)_block_invoke"];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"OTClique.m",  72,  @"Unable to find class %s",  "AAFAnalyticsEventSecurity");

    __break(1u);
  }

void sub_18055B3A4(_Unwind_Exception *a1)
{
}

void sub_18055B6D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18055BD04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_18055C4F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_18055C940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055CD48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055D150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055D578( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055D9A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055DDD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055E1FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055E624( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055EA2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055EE34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055F25C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055F688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055FAC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_18055FF20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_180560120( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18056033C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_180560CA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

void sub_180561258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_18056147C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id getSecureBackupClass()
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  unsigned int v0 = (void *)getSecureBackupClass_softClass;
  uint64_t v7 = getSecureBackupClass_softClass;
  if (!getSecureBackupClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getSecureBackupClass_block_invoke;
    v3[3] = &unk_1896734F0;
    v3[4] = &v4;
    __getSecureBackupClass_block_invoke((uint64_t)v3);
    unsigned int v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_180561664( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void getkSecureBackupAuthenticationAppleID()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  unsigned int v0 = (id *)getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr;
  uint64_t v8 = getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr;
  if (!getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr)
  {
    id v1 = CloudServicesLibrary();
    unsigned int v0 = (id *)dlsym(v1, "kSecureBackupAuthenticationAppleID");
    void v6[3] = (uint64_t)v0;
    getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    id v2 = *v0;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"NSString *getkSecureBackupAuthenticationAppleID(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"OTClique.m",  78,  @"%s",  dlerror());

    __break(1u);
  }

void sub_180561760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void getkSecureBackupAuthenticationPassword()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  unsigned int v0 = (id *)getkSecureBackupAuthenticationPasswordSymbolLoc_ptr;
  uint64_t v8 = getkSecureBackupAuthenticationPasswordSymbolLoc_ptr;
  if (!getkSecureBackupAuthenticationPasswordSymbolLoc_ptr)
  {
    id v1 = CloudServicesLibrary();
    unsigned int v0 = (id *)dlsym(v1, "kSecureBackupAuthenticationPassword");
    void v6[3] = (uint64_t)v0;
    getkSecureBackupAuthenticationPasswordSymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    id v2 = *v0;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"NSString *getkSecureBackupAuthenticationPassword(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"OTClique.m",  79,  @"%s",  dlerror());

    __break(1u);
  }

void sub_18056185C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void getkSecureBackupiCloudDataProtectionDeleteAllRecordsKey()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  unsigned int v0 = (id *)getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr;
  uint64_t v8 = getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr;
  if (!getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr)
  {
    id v1 = CloudServicesLibrary();
    unsigned int v0 = (id *)dlsym(v1, "kSecureBackupiCloudDataProtectionDeleteAllRecordsKey");
    void v6[3] = (uint64_t)v0;
    getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    id v2 = *v0;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"NSString *getkSecureBackupiCloudDataProtectionDeleteAllRecordsKey(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"OTClique.m",  80,  @"%s",  dlerror());

    __break(1u);
  }

void sub_180561958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void getkSecureBackupContainsiCDPDataKey()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  unsigned int v0 = (id *)getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr;
  uint64_t v8 = getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr;
  if (!getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr)
  {
    id v1 = CloudServicesLibrary();
    unsigned int v0 = (id *)dlsym(v1, "kSecureBackupContainsiCDPDataKey");
    void v6[3] = (uint64_t)v0;
    getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    id v2 = *v0;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"NSString *getkSecureBackupContainsiCDPDataKey(void)"];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"OTClique.m",  81,  @"%s",  dlerror());

    __break(1u);
  }

void sub_180561A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *CloudServicesLibrary()
{
  if (!CloudServicesLibraryCore_frameworkLibrary) {
    CloudServicesLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  unsigned int v0 = (void *)CloudServicesLibraryCore_frameworkLibrary;
  if (!CloudServicesLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    unsigned int v0 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *CloudServicesLibrary(void)"];
    id v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v0,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"OTClique.m",  65,  @"%s",  0);

    __break(1u);
    free(v3);
  }

  return v0;
}

void __getSecureBackupClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("SecureBackup");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getSecureBackupClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    id v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getSecureBackupClass(void)_block_invoke"];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"OTClique.m",  76,  @"Unable to find class %s",  "SecureBackup");

    __break(1u);
  }

CFStringRef OTCliqueStatusToString(uint64_t a1)
{
  else {
    return off_189667B40[a1 + 1];
  }
}

uint64_t OTCliqueStatusFromString(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"CliqueStatusIn"])
  {
    uint64_t v2 = 0LL;
  }

  else if ([v1 isEqualToString:@"CliqueStatusNotIn"])
  {
    uint64_t v2 = 1LL;
  }

  else if ([v1 isEqualToString:@"CliqueStatusPending"])
  {
    uint64_t v2 = 2LL;
  }

  else if ([v1 isEqualToString:@"CliqueStatusAbsent"])
  {
    uint64_t v2 = 3LL;
  }

  else if ([v1 isEqualToString:@"CliqueStatusNoCloudKitAccount"])
  {
    uint64_t v2 = 4LL;
  }

  else
  {
    [v1 isEqualToString:@"CliqueStatusError"];
    uint64_t v2 = -1LL;
  }

  return v2;
}

CFStringRef OTCDPStatusToString(uint64_t a1)
{
  id v1 = @"unknown";
  if (a1 == 1) {
    id v1 = @"disabled";
  }
  if (a1 == 2) {
    return @"enabled";
  }
  else {
    return v1;
  }
}

id deserializedRecordFromRow(void *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = [v1 indexForColumnName:@"data"];
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    id v3 = 0LL;
  }

  else
  {
    uint64_t v4 = (void *)MEMORY[0x1896079E8];
    [v1 blobAtIndex:v2];
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    id v9 = 0LL;
    [v4 propertyListWithData:v5 options:1 format:0 error:&v9];
    id v3 = (void *)objc_claimAutoreleasedReturnValue();
    id v6 = v9;

    if (!v3)
    {
      secLogObjForScope("SecError");
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543362;
        id v11 = v6;
        _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "SFAnalytics: failed to deserialize record: %{public}@",  buf,  0xCu);
      }
    }
  }

  return v3;
}

id makeLightweightCodeRequirement(const __CFData *a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  id v5 = 0LL;
  +[sec_LWCR withData:withError:](&OBJC_CLASS___sec_LWCR, "withData:withError:", a1, &v5);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  id v2 = v5;
  if (v2)
  {
    secLogObjForScope("SecError");
    id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v7 = "makeLightweightCodeRequirement";
      _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "%s: failed to parse LightweightCodeRequirement",  buf,  0xCu);
    }
  }

  return v1;
}

void bindAndAddBoolFact(void *a1, const char *a2, uint64_t a3)
{
  id v6 = a1;
  +[sec_LWCRFact BOOLFact:](&OBJC_CLASS___sec_LWCRFact, "BOOLFact:", a3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  bindAndAdd(v6, a2, v5);
}

void sub_1805675EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void bindAndAdd(void *a1, const char *a2, void *a3)
{
  id v7 = a1;
  id v5 = a3;
  [v5 bindName:a2 withLength:strlen(a2)];
  [NSString stringWithUTF8String:a2];
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  [v7 setObject:v5 forKeyedSubscript:v6];
}

void sub_180567698( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void bindAndAddIntegerFact(void *a1, const char *a2, uint64_t a3)
{
  id v7 = a1;
  [MEMORY[0x189607968] numberWithLongLong:a3];
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  +[sec_LWCRFact integerFact:](&OBJC_CLASS___sec_LWCRFact, "integerFact:", v5);
  id v6 = (void *)objc_claimAutoreleasedReturnValue();

  bindAndAdd(v7, a2, v6);
}

void sub_180567744( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void bindAndAddStringFact(void *a1, const char *a2, uint64_t a3)
{
  id v7 = a1;
  [NSString stringWithUTF8String:a3];
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  +[sec_LWCRFact stringFact:](&OBJC_CLASS___sec_LWCRFact, "stringFact:", v5);
  id v6 = (void *)objc_claimAutoreleasedReturnValue();

  bindAndAdd(v7, a2, v6);
}

void sub_1805677F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1805678C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)&OBJC_CLASS___sec_LWCR;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void sub_180567E20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *ce_malloc(const CERuntime *a1, size_t __size)
{
  return malloc(__size);
}

void ce_free(const CERuntime *a1, void *a2)
{
}

void ce_log(const CERuntime *a1, const char *a2, ...)
{
}

void ce_abort(const CERuntime *a1, const char *a2, ...)
{
}

void sub_180567F20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)&OBJC_CLASS___sec_LWCRFact;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_180568020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1805680B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1805682C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v16) {
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void sub_180568388(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t serializeDict(void *a1, char **a2)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  id v84 = a1;
  id v3 = a2[1];
  unint64_t v4 = (unint64_t)a2[2];
  if ((unint64_t)v3 >= v4)
  {
    uint64_t v6 = (v3 - *a2) >> 5;
    unint64_t v7 = v6 + 1;
    uint64_t v8 = v4 - (void)*a2;
    if (v8 >> 4 > v7) {
      unint64_t v7 = v8 >> 4;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9) {
      unint64_t v9 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v9);
    }
    else {
      uint64_t v10 = 0LL;
    }
    id v11 = (void *)(v9 + 32 * v6);
    unint64_t v12 = v9 + 32 * v10;
    void *v11 = 7LL;
    v11[1] = 0LL;
    uint64_t v11[2] = 0LL;
    unint64_t v11[3] = 0LL;
    id v5 = (char *)(v11 + 4);
    uint64_t v14 = *a2;
    uint64_t v13 = a2[1];
    if (v13 != *a2)
    {
      do
      {
        __int128 v15 = *((_OWORD *)v13 - 1);
        *((_OWORD *)v11 - 2) = *((_OWORD *)v13 - 2);
        *((_OWORD *)v11 - 1) = v15;
        v11 -= 4;
        v13 -= 32;
      }

      while (v13 != v14);
      uint64_t v13 = *a2;
    }

    *a2 = (char *)v11;
    a2[1] = v5;
    a2[2] = (char *)v12;
    if (v13) {
      operator delete(v13);
    }
  }

  else
  {
    *(void *)id v3 = 7LL;
    *((void *)v3 + 1) = 0LL;
    *((void *)v3 + 2) = 0LL;
    *((void *)v3 + 3) = 0LL;
    id v5 = v3 + 32;
  }

  a2[1] = v5;
  uint64_t v16 = (void *)MEMORY[0x189603FA8];
  [v84 allKeys];
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  [v16 arrayWithArray:v17];
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();

  [v18 sortUsingSelector:sel_compare_];
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  obuint64_t j = v18;
  uint64_t v19 = [obj countByEnumeratingWithState:&v85 objects:v89 count:16];
  if (v19)
  {
    uint64_t v20 = *(void *)v86;
LABEL_19:
    uint64_t v21 = 0LL;
    while (1)
    {
      if (*(void *)v86 != v20) {
        objc_enumerationMutation(obj);
      }
      uint64_t v22 = *(void **)(*((void *)&v85 + 1) + 8 * v21);
      char v23 = a2[1];
      unint64_t v24 = (unint64_t)a2[2];
      if ((unint64_t)v23 >= v24)
      {
        uint64_t v26 = (v23 - *a2) >> 5;
        unint64_t v27 = v26 + 1;
        uint64_t v28 = v24 - (void)*a2;
        if (v28 >> 4 > v27) {
          unint64_t v27 = v28 >> 4;
        }
        else {
          unint64_t v29 = v27;
        }
        if (v29) {
          unint64_t v29 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v29);
        }
        else {
          uint64_t v30 = 0LL;
        }
        int v31 = (void *)(v29 + 32 * v26);
        void *v31 = 5LL;
        v31[1] = 0LL;
        v31[2] = 0LL;
        unint64_t v31[3] = 0LL;
        BOOL v33 = *a2;
        int v32 = a2[1];
        CFTypeID v34 = v31;
        if (v32 != *a2)
        {
          do
          {
            __int128 v35 = *((_OWORD *)v32 - 1);
            *((_OWORD *)v34 - 2) = *((_OWORD *)v32 - 2);
            *((_OWORD *)v34 - 1) = v35;
            v34 -= 4;
            v32 -= 32;
          }

          while (v32 != v33);
          int v32 = *a2;
        }

        char v25 = (char *)(v31 + 4);
        *a2 = (char *)v34;
        a2[1] = (char *)(v31 + 4);
        a2[2] = (char *)(v29 + 32 * v30);
        if (v32) {
          operator delete(v32);
        }
      }

      else
      {
        *(void *)char v23 = 5LL;
        *((void *)v23 + 1) = 0LL;
        char v25 = v23 + 32;
        *((void *)v23 + 2) = 0LL;
        *((void *)v23 + 3) = 0LL;
      }

      a2[1] = v25;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        break;
      }
      id v36 = v22;
      uint64_t v37 = [v36 UTF8String];
      uint64_t v38 = [v36 lengthOfBytesUsingEncoding:4];
      uint64_t v39 = v38;
      id v40 = a2[1];
      int v41 = a2[2];
      if (v40 >= v41)
      {
        uint64_t v43 = (v40 - *a2) >> 5;
        unint64_t v44 = v43 + 1;
        uint64_t v45 = v41 - *a2;
        if (v45 >> 4 > v44) {
          unint64_t v44 = v45 >> 4;
        }
        else {
          unint64_t v46 = v44;
        }
        if (v46) {
          unint64_t v46 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v46);
        }
        else {
          uint64_t v47 = 0LL;
        }
        unint64_t v48 = v46 + 32 * v43;
        *(void *)unint64_t v48 = 3LL;
        *(void *)(v48 + _Block_object_dispose(va, 8) = v37;
        *(void *)(v48 + 16) = v39;
        *(_BYTE *)(v48 + 24) = 0;
        char v50 = *a2;
        uint64_t v49 = a2[1];
        unint64_t v51 = v48;
        if (v49 != *a2)
        {
          do
          {
            __int128 v52 = *((_OWORD *)v49 - 1);
            *(_OWORD *)(v51 - 32) = *((_OWORD *)v49 - 2);
            *(_OWORD *)(v51 - 16) = v52;
            v51 -= 32LL;
            v49 -= 32;
          }

          while (v49 != v50);
          uint64_t v49 = *a2;
        }

        unint64_t v42 = v48 + 32;
        *a2 = (char *)v51;
        a2[1] = (char *)(v48 + 32);
        a2[2] = (char *)(v46 + 32 * v47);
        if (v49) {
          operator delete(v49);
        }
      }

      else
      {
        *(void *)id v40 = 3LL;
        *((void *)v40 + 1) = v37;
        *((void *)v40 + 2) = v38;
        unint64_t v42 = (unint64_t)(v40 + 32);
        v40[24] = 0;
      }

      a2[1] = (char *)v42;
      [v84 objectForKeyedSubscript:v36];
      id v53 = (void *)objc_claimAutoreleasedReturnValue();
      CFIndex v54 = v53;
      if (!v53)
      {
        uint64_t v55 = *MEMORY[0x1896135D0];
LABEL_79:

LABEL_80:
        goto LABEL_96;
      }

      uint64_t v55 = serializeId(v53, (void **)a2);
      if (v55 != *MEMORY[0x1896135D8]) {
        goto LABEL_79;
      }
      char v56 = a2[1];
      unint64_t v57 = (unint64_t)a2[2];
      if ((unint64_t)v56 >= v57)
      {
        uint64_t v59 = (v56 - *a2) >> 5;
        unint64_t v60 = v59 + 1;
        uint64_t v61 = v57 - (void)*a2;
        if (v61 >> 4 > v60) {
          unint64_t v60 = v61 >> 4;
        }
        else {
          unint64_t v62 = v60;
        }
        if (v62) {
          unint64_t v62 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v62);
        }
        else {
          uint64_t v63 = 0LL;
        }
        uint64_t v64 = (void *)(v62 + 32 * v59);
        void *v64 = 6LL;
        v64[1] = 0LL;
        v64[2] = 0LL;
        v64[3] = 0LL;
        id v66 = *a2;
        id v65 = a2[1];
        uint64_t v67 = v64;
        if (v65 != *a2)
        {
          do
          {
            __int128 v68 = *((_OWORD *)v65 - 1);
            *((_OWORD *)v67 - 2) = *((_OWORD *)v65 - 2);
            *((_OWORD *)v67 - 1) = v68;
            v67 -= 4;
            v65 -= 32;
          }

          while (v65 != v66);
          id v65 = *a2;
        }

        CFIndex v58 = (char *)(v64 + 4);
        *a2 = (char *)v67;
        a2[1] = (char *)(v64 + 4);
        a2[2] = (char *)(v62 + 32 * v63);
        if (v65) {
          operator delete(v65);
        }
      }

      else
      {
        *(void *)char v56 = 6LL;
        *((void *)v56 + 1) = 0LL;
        CFIndex v58 = v56 + 32;
        *((void *)v56 + 2) = 0LL;
        *((void *)v56 + 3) = 0LL;
      }

      a2[1] = v58;

      if (++v21 == v19)
      {
        uint64_t v19 = [obj countByEnumeratingWithState:&v85 objects:v89 count:16];
        if (v19) {
          goto LABEL_19;
        }
        goto LABEL_75;
      }
    }

    uint64_t v55 = *MEMORY[0x1896135D0];
    goto LABEL_80;
  }

void sub_1805689A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
}

void std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]()
{
}

void *std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a1);
}

uint64_t serializeId(void *a1, void **a2)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    id v4 = v3;
    uint64_t v5 = [v4 UTF8String];
    uint64_t v6 = [v4 lengthOfBytesUsingEncoding:4];
    unint64_t v7 = (uint64_t *)a2[1];
    uint64_t v8 = (uint64_t *)a2[2];
    if (v7 < v8)
    {
      uint64_t v9 = 2LL;
LABEL_4:
      *unint64_t v7 = v9;
      v7[1] = v5;
      void v7[2] = v6;
LABEL_22:
      *((_BYTE *)v7 + 24) = 0;
      uint64_t v21 = v7 + 4;
LABEL_32:
      a2[1] = v21;

LABEL_33:
      int v31 = (uint64_t *)MEMORY[0x1896135D8];
LABEL_34:
      uint64_t v19 = *v31;
      goto LABEL_35;
    }

    uint64_t v14 = ((char *)v7 - (_BYTE *)*a2) >> 5;
    unint64_t v15 = v14 + 1;
    uint64_t v16 = (char *)v8 - (_BYTE *)*a2;
    if (v16 >> 4 > v15) {
      unint64_t v15 = v16 >> 4;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17) {
      unint64_t v17 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v17);
    }
    else {
      uint64_t v18 = 0LL;
    }
    unint64_t v26 = v17 + 32 * v14;
    unint64_t v27 = v17 + 32 * v18;
    *(void *)unint64_t v26 = 2LL;
    *(void *)(v26 + _Block_object_dispose(va, 8) = v5;
    *(void *)(v26 + 16) = v6;
    *(_BYTE *)(v26 + 24) = 0;
    uint64_t v21 = (void *)(v26 + 32);
    unint64_t v29 = (char *)*a2;
    uint64_t v28 = (char *)a2[1];
    if (v28 != *a2)
    {
      do
      {
        __int128 v30 = *((_OWORD *)v28 - 1);
        *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
        *(_OWORD *)(v26 - 16) = v30;
        v26 -= 32LL;
        v28 -= 32;
      }

      while (v28 != v29);
LABEL_29:
      uint64_t v28 = (char *)*a2;
      goto LABEL_30;
    }

    goto LABEL_30;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    id v4 = v3;
    CFTypeID v10 = CFGetTypeID(v4);
    if (v10 == CFBooleanGetTypeID())
    {
      uint64_t v11 = [v4 BOOLValue];
      unint64_t v7 = (uint64_t *)a2[1];
      unint64_t v12 = (uint64_t *)a2[2];
      if (v7 >= v12)
      {
        uint64_t v33 = ((char *)v7 - (_BYTE *)*a2) >> 5;
        unint64_t v34 = v33 + 1;
        uint64_t v35 = (char *)v12 - (_BYTE *)*a2;
        if (v35 >> 4 > v34) {
          unint64_t v34 = v35 >> 4;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36) {
          unint64_t v36 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v36);
        }
        else {
          uint64_t v37 = 0LL;
        }
        unint64_t v26 = v36 + 32 * v33;
        unint64_t v27 = v36 + 32 * v37;
        *(void *)unint64_t v26 = 1LL;
        *(void *)(v26 + _Block_object_dispose(va, 8) = v11;
        *(void *)(v26 + 16) = 0LL;
        *(_BYTE *)(v26 + 24) = 0;
        uint64_t v21 = (void *)(v26 + 32);
        uint64_t v49 = (char *)*a2;
        uint64_t v28 = (char *)a2[1];
        if (v28 == *a2) {
          goto LABEL_30;
        }
        do
        {
          __int128 v50 = *((_OWORD *)v28 - 1);
          *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
          *(_OWORD *)(v26 - 16) = v50;
          v26 -= 32LL;
          v28 -= 32;
        }

        while (v28 != v49);
        goto LABEL_29;
      }

      uint64_t v13 = 1LL;
    }

    else
    {
      uint64_t v11 = [v4 longLongValue];
      unint64_t v7 = (uint64_t *)a2[1];
      uint64_t v20 = (uint64_t *)a2[2];
      if (v7 >= v20)
      {
        uint64_t v38 = ((char *)v7 - (_BYTE *)*a2) >> 5;
        unint64_t v39 = v38 + 1;
        uint64_t v40 = (char *)v20 - (_BYTE *)*a2;
        if (v40 >> 4 > v39) {
          unint64_t v39 = v40 >> 4;
        }
        else {
          unint64_t v41 = v39;
        }
        if (v41) {
          unint64_t v41 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v41);
        }
        else {
          uint64_t v42 = 0LL;
        }
        unint64_t v26 = v41 + 32 * v38;
        unint64_t v27 = v41 + 32 * v42;
        *(void *)unint64_t v26 = 4LL;
        *(void *)(v26 + _Block_object_dispose(va, 8) = v11;
        *(void *)(v26 + 16) = 0LL;
        *(_BYTE *)(v26 + 24) = 0;
        uint64_t v21 = (void *)(v26 + 32);
        unint64_t v51 = (char *)*a2;
        uint64_t v28 = (char *)a2[1];
        if (v28 == *a2) {
          goto LABEL_30;
        }
        do
        {
          __int128 v52 = *((_OWORD *)v28 - 1);
          *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
          *(_OWORD *)(v26 - 16) = v52;
          v26 -= 32LL;
          v28 -= 32;
        }

        while (v28 != v51);
        goto LABEL_29;
      }

      uint64_t v13 = 4LL;
    }

    *unint64_t v7 = v13;
    v7[1] = v11;
    void v7[2] = 0LL;
    goto LABEL_22;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      id v22 = v3;
      char v23 = a2[1];
      unint64_t v24 = (unint64_t)a2[2];
      if ((unint64_t)v23 >= v24)
      {
        uint64_t v44 = ((char *)v23 - (_BYTE *)*a2) >> 5;
        unint64_t v45 = v44 + 1;
        uint64_t v46 = v24 - (void)*a2;
        if (v46 >> 4 > v45) {
          unint64_t v45 = v46 >> 4;
        }
        else {
          unint64_t v47 = v45;
        }
        if (v47) {
          unint64_t v47 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v47);
        }
        else {
          uint64_t v48 = 0LL;
        }
        CFIndex v58 = (void *)(v47 + 32 * v44);
        unint64_t v59 = v47 + 32 * v48;
        *CFIndex v58 = 5LL;
        v58[1] = 0LL;
        v58[2] = 0LL;
        v58[3] = 0LL;
        char v25 = v58 + 4;
        uint64_t v61 = (char *)*a2;
        unint64_t v60 = (char *)a2[1];
        if (v60 != *a2)
        {
          do
          {
            __int128 v62 = *((_OWORD *)v60 - 1);
            *((_OWORD *)v58 - 2) = *((_OWORD *)v60 - 2);
            *((_OWORD *)v58 - 1) = v62;
            v58 -= 4;
            v60 -= 32;
          }

          while (v60 != v61);
          unint64_t v60 = (char *)*a2;
        }

        *a2 = v58;
        a2[1] = v25;
        a2[2] = (void *)v59;
        if (v60) {
          operator delete(v60);
        }
      }

      else
      {
        void *v23 = 5LL;
        v23[1] = 0LL;
        v23[2] = 0LL;
        _OWORD v23[3] = 0LL;
        char v25 = v23 + 4;
      }

      a2[1] = v25;
      __int128 v84 = 0u;
      __int128 v85 = 0u;
      __int128 v86 = 0u;
      __int128 v87 = 0u;
      id v63 = v22;
      uint64_t v64 = [v63 countByEnumeratingWithState:&v84 objects:v88 count:16];
      if (v64)
      {
        uint64_t v65 = *(void *)v85;
        id v66 = (void *)MEMORY[0x1896135D8];
        while (2)
        {
          uint64_t v67 = 0LL;
          do
          {
            if (*(void *)v85 != v65) {
              objc_enumerationMutation(v63);
            }
            uint64_t v68 = *(void *)(*((void *)&v84 + 1) + 8 * v67);
            if (!v68 || serializeId(v68, a2) != *v66)
            {

              goto LABEL_117;
            }

            ++v67;
          }

          while (v64 != v67);
          uint64_t v64 = [v63 countByEnumeratingWithState:&v84 objects:v88 count:16];
          if (v64) {
            continue;
          }
          break;
        }
      }

      int v69 = a2[1];
      unint64_t v70 = (unint64_t)a2[2];
      if ((unint64_t)v69 >= v70)
      {
        uint64_t v72 = ((char *)v69 - (_BYTE *)*a2) >> 5;
        unint64_t v73 = v72 + 1;
        uint64_t v74 = v70 - (void)*a2;
        if (v74 >> 4 > v73) {
          unint64_t v73 = v74 >> 4;
        }
        else {
          unint64_t v75 = v73;
        }
        if (v75) {
          unint64_t v75 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v75);
        }
        else {
          uint64_t v76 = 0LL;
        }
        id v79 = (void *)(v75 + 32 * v72);
        unint64_t v80 = v75 + 32 * v76;
        *id v79 = 6LL;
        v79[1] = 0LL;
        v79[2] = 0LL;
        v79[3] = 0LL;
        id v71 = v79 + 4;
        __int128 v82 = (char *)*a2;
        __int128 v81 = (char *)a2[1];
        if (v81 != *a2)
        {
          do
          {
            __int128 v83 = *((_OWORD *)v81 - 1);
            *((_OWORD *)v79 - 2) = *((_OWORD *)v81 - 2);
            *((_OWORD *)v79 - 1) = v83;
            v79 -= 4;
            v81 -= 32;
          }

          while (v81 != v82);
          __int128 v81 = (char *)*a2;
        }

        *a2 = v79;
        a2[1] = v71;
        a2[2] = (void *)v80;
        if (v81) {
          operator delete(v81);
        }
      }

      else
      {
        void *v69 = 6LL;
        v69[1] = 0LL;
        v69[2] = 0LL;
        v69[3] = 0LL;
        id v71 = v69 + 4;
      }

      a2[1] = v71;
LABEL_117:

      goto LABEL_33;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      int v31 = (uint64_t *)MEMORY[0x1896135D0];
      goto LABEL_34;
    }

    id v4 = v3;
    uint64_t v5 = [v4 bytes];
    uint64_t v6 = [v4 length];
    unint64_t v7 = (uint64_t *)a2[1];
    uint64_t v43 = (uint64_t *)a2[2];
    if (v7 < v43)
    {
      uint64_t v9 = 9LL;
      goto LABEL_4;
    }

    uint64_t v53 = ((char *)v7 - (_BYTE *)*a2) >> 5;
    unint64_t v54 = v53 + 1;
    uint64_t v55 = (char *)v43 - (_BYTE *)*a2;
    if (v55 >> 4 > v54) {
      unint64_t v54 = v55 >> 4;
    }
    else {
      unint64_t v56 = v54;
    }
    if (v56) {
      unint64_t v56 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v56);
    }
    else {
      uint64_t v57 = 0LL;
    }
    unint64_t v26 = v56 + 32 * v53;
    unint64_t v27 = v56 + 32 * v57;
    *(void *)unint64_t v26 = 9LL;
    *(void *)(v26 + _Block_object_dispose(va, 8) = v5;
    *(void *)(v26 + 16) = v6;
    *(_BYTE *)(v26 + 24) = 0;
    uint64_t v21 = (void *)(v26 + 32);
    __int128 v77 = (char *)*a2;
    uint64_t v28 = (char *)a2[1];
    if (v28 != *a2)
    {
      do
      {
        __int128 v78 = *((_OWORD *)v28 - 1);
        *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
        *(_OWORD *)(v26 - 16) = v78;
        v26 -= 32LL;
        v28 -= 32;
      }

      while (v28 != v77);
      goto LABEL_29;
    }

void sub_180569134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  id v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x189614700], MEMORY[0x189614270]);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_189661D30, MEMORY[0x1896141F8]);
}

void sub_1805691F4(_Unwind_Exception *a1)
{
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x189614778] + 16LL);
  return result;
}

void sub_1805695F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, id a30)
{
  _Unwind_Resume(a1);
}

void sub_1805696EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180569794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180569814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::reset(void **a1)
{
  id v2 = *a1;
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *a1 = 0LL;
  return a1;
}

void TLE::CallbackEncyclopedia::~CallbackEncyclopedia(id *this)
{
}

{

  operator delete(this);
}

uint64_t TLE::CallbackEncyclopedia::getFact(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16LL))();
}

uint64_t TLE::CallbackEncyclopedia::resolveFact(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16LL))();
}

uint64_t TLE::CallbackEncyclopedia::hasFactFor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16LL))();
}

void TLE::andDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a3)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)a4 = 6;
    *(void *)(a4 + _Block_object_dispose(va, 8) = "$and operator disallowed for active fact";
    *(void *)(a4 + 16) = 40LL;
    return;
  }

  uint64_t v23 = 0LL;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v20.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v20.lookup.index_size_t count = v5;
  *(_OWORD *)&v20.sorted = *(_OWORD *)(a2 + 32);
  v20.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v21, a1, &v20);
  if ((_DWORD)v21)
  {
    *(_OWORD *)a4 = v21;
    unint64_t v7 = (void *)*((void *)&v22 + 1);
    *(void *)(a4 + 16) = v22;
    *(void *)(a4 + 24) = 0LL;
    if (!v7) {
      return;
    }
  }

  else
  {
    int v8 = v23;
    if ((_DWORD)v23 != 1)
    {
      unint64_t v17 = operator new(0x30uLL);
      void v17[2] = 0LL;
      void v17[3] = 0LL;
      *unint64_t v17 = off_189668340;
      v17[1] = 1LL;
      v17[4] = *((void *)&v22 + 1);
      *((_DWORD *)v17 + 10) = v8;
      *(void *)a4 = 0LL;
      *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a4 + 16) = 0LL;
      *(void *)(a4 + 24) = v17;
      return;
    }

    unint64_t v7 = (void *)*((void *)&v22 + 1);
    if (!*((void *)&v22 + 1)) {
      goto LABEL_26;
    }
    unint64_t v9 = 8LL * v23;
    if (*((void *)&v22 + 1) + v9 < *((void *)&v22 + 1) || HIDWORD(v9)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v6);
    }
    if ((v9 & 0xFFFFFFF8) == 0) {
LABEL_26:
    }
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v6);
    *(void *)a4 = 0LL;
    *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
    CFTypeID v10 = (void *)*v7;
    *(void *)(a4 + 16) = 0LL;
    *(void *)(a4 + 24) = v10;
    if (v10)
    {
      uint64_t v11 = v10[1];
      if (v11 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
      }

      v10[1] = v11 + 1;
    }
  }

  if ((_DWORD)v23)
  {
    uint64_t v12 = 8LL * v23;
    uint64_t v13 = (void **)v7;
    do
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        uint64_t v15 = v14[1];
        if (v15 <= 0)
        {
          uint64_t v18 = __cxa_allocate_exception(8uLL);
          *uint64_t v18 = "Over-release of an object";
          __cxa_throw(v18, MEMORY[0x1896146E0], 0LL);
        }

        uint64_t v16 = v15 - 1;
        v14[1] = v16;
        if (!v16) {
          (*(void (**)(void *))(*v14 + 8LL))(v14);
        }
      }

      *v13++ = 0LL;
      v12 -= 8LL;
    }

    while (v12);
  }

  free(v7);
}

void sub_180569B60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void TLE::orDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a3)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)a4 = 6;
    *(void *)(a4 + _Block_object_dispose(va, 8) = "$or operator disallowed for active fact";
    *(void *)(a4 + 16) = 39LL;
    return;
  }

  uint64_t v23 = 0LL;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v20.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v20.lookup.index_size_t count = v5;
  *(_OWORD *)&v20.sorted = *(_OWORD *)(a2 + 32);
  v20.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v21, a1, &v20);
  if ((_DWORD)v21)
  {
    *(_OWORD *)a4 = v21;
    unint64_t v7 = (void *)*((void *)&v22 + 1);
    *(void *)(a4 + 16) = v22;
    *(void *)(a4 + 24) = 0LL;
    if (!v7) {
      return;
    }
  }

  else
  {
    int v8 = v23;
    if ((_DWORD)v23 != 1)
    {
      unint64_t v17 = operator new(0x30uLL);
      void v17[2] = 0LL;
      void v17[3] = 0LL;
      *unint64_t v17 = off_1896683B0;
      v17[1] = 1LL;
      v17[4] = *((void *)&v22 + 1);
      *((_DWORD *)v17 + 10) = v8;
      *(void *)a4 = 0LL;
      *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a4 + 16) = 0LL;
      *(void *)(a4 + 24) = v17;
      return;
    }

    unint64_t v7 = (void *)*((void *)&v22 + 1);
    if (!*((void *)&v22 + 1)) {
      goto LABEL_26;
    }
    unint64_t v9 = 8LL * v23;
    if (*((void *)&v22 + 1) + v9 < *((void *)&v22 + 1) || HIDWORD(v9)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v6);
    }
    if ((v9 & 0xFFFFFFF8) == 0) {
LABEL_26:
    }
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v6);
    *(void *)a4 = 0LL;
    *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
    CFTypeID v10 = (void *)*v7;
    *(void *)(a4 + 16) = 0LL;
    *(void *)(a4 + 24) = v10;
    if (v10)
    {
      uint64_t v11 = v10[1];
      if (v11 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
      }

      v10[1] = v11 + 1;
    }
  }

  if ((_DWORD)v23)
  {
    uint64_t v12 = 8LL * v23;
    uint64_t v13 = (void **)v7;
    do
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        uint64_t v15 = v14[1];
        if (v15 <= 0)
        {
          uint64_t v18 = __cxa_allocate_exception(8uLL);
          *uint64_t v18 = "Over-release of an object";
          __cxa_throw(v18, MEMORY[0x1896146E0], 0LL);
        }

        uint64_t v16 = v15 - 1;
        v14[1] = v16;
        if (!v16) {
          (*(void (**)(void *))(*v14 + 8LL))(v14);
        }
      }

      *v13++ = 0LL;
      v12 -= 8LL;
    }

    while (v12);
  }

  free(v7);
}

void sub_180569D94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void TLE::inDeserializer(__int128 *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)a2 > 6u || ((1 << *(_DWORD *)a2) & 0x58) == 0)
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 3;
    CFTypeID v10 = "Got an unexpected type (not an integer, string or data) when trying to generate an In operation.";
    uint64_t v11 = 96LL;
  }

  else
  {
    if (der_vm_CEType_from_context() == 2)
    {
      unint64_t v7 = operator new(0x58uLL);
      __int128 v8 = *a1;
      __int128 v9 = a1[2];
      void v7[3] = a1[1];
      _OWORD v7[4] = v9;
      *((void *)v7 + 10) = *((void *)a1 + 6);
      *(void *)unint64_t v7 = off_1896683F8;
      *((void *)v7 + 1) = 1LL;
      v7[1] = *(_OWORD *)(a2 + 8);
      void v7[2] = v8;
      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      *(void *)(a3 + 24) = v7;
      return;
    }

    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 3;
    CFTypeID v10 = "Got an unexpected type (not a sequence) when trying to read the array of matches.";
    uint64_t v11 = 81LL;
  }

  *(void *)(a3 + _Block_object_dispose(va, 8) = v10;
  *(void *)(a3 + 16) = v11;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__0EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>( uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    uint64_t v4 = der_vm_integer_from_context();
    __int128 v5 = operator new(0x28uLL);
    void *v5 = off_189667FD0;
    v5[1] = 1LL;
    void v5[4] = v4;
    __int128 v6 = *(_OWORD *)(a1 + 8);
    *((_OWORD *)v5 + 1) = v6;
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    a2[3] = v5;
  }

  else
  {
    *(void *)&__int128 v6 = 0LL;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85LL;
  }

  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__1EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>( uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    uint64_t v4 = der_vm_integer_from_context();
    __int128 v5 = operator new(0x28uLL);
    void *v5 = off_189668018;
    v5[1] = 1LL;
    void v5[4] = v4;
    __int128 v6 = *(_OWORD *)(a1 + 8);
    *((_OWORD *)v5 + 1) = v6;
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    a2[3] = v5;
  }

  else
  {
    *(void *)&__int128 v6 = 0LL;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85LL;
  }

  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__2EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>( uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    uint64_t v4 = der_vm_integer_from_context();
    __int128 v5 = operator new(0x28uLL);
    void *v5 = off_189668060;
    v5[1] = 1LL;
    void v5[4] = v4;
    __int128 v6 = *(_OWORD *)(a1 + 8);
    *((_OWORD *)v5 + 1) = v6;
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    a2[3] = v5;
  }

  else
  {
    *(void *)&__int128 v6 = 0LL;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85LL;
  }

  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__3EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>( uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    uint64_t v4 = der_vm_integer_from_context();
    __int128 v5 = operator new(0x28uLL);
    void *v5 = off_1896680A8;
    v5[1] = 1LL;
    void v5[4] = v4;
    __int128 v6 = *(_OWORD *)(a1 + 8);
    *((_OWORD *)v5 + 1) = v6;
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    a2[3] = v5;
  }

  else
  {
    *(void *)&__int128 v6 = 0LL;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85LL;
  }

  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__4EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>( uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    uint64_t v4 = der_vm_integer_from_context();
    __int128 v5 = operator new(0x28uLL);
    void *v5 = off_1896680F0;
    v5[1] = 1LL;
    void v5[4] = v4;
    __int128 v6 = *(_OWORD *)(a1 + 8);
    *((_OWORD *)v5 + 1) = v6;
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    a2[3] = v5;
  }

  else
  {
    *(void *)&__int128 v6 = 0LL;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85LL;
  }

  return *(double *)&v6;
}

void TLE::optionalOpDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = 0LL;
  __int128 v17 = 0u;
  *(_OWORD *)uint64_t v18 = 0u;
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v16.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v16.lookup.index_size_t count = v4;
  *(_OWORD *)&v16.sorted = *(_OWORD *)(a2 + 32);
  v16.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v17, a1, &v16);
  if ((_DWORD)v17)
  {
    *(_OWORD *)a3 = v17;
    *(void **)(a3 + 16) = v18[0];
    *(void *)(a3 + 24) = 0LL;
    __int128 v6 = (void **)v18[1];
    if (!v18[1]) {
      return;
    }
    goto LABEL_12;
  }

  if ((_DWORD)v19 != 1)
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 6;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "$optional only supports a single dependent operation";
    *(void *)(a3 + 16) = 52LL;
    __int128 v6 = (void **)v18[1];
    if (!v18[1]) {
      return;
    }
    goto LABEL_12;
  }

  unint64_t v7 = v18[1];
  if (!v18[1]) {
    goto LABEL_23;
  }
  unint64_t v8 = 8LL * v19;
  if ((char *)v18[1] + v8 < v18[1] || HIDWORD(v8)) {
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [beg in, end) is not a well-formed range",  v5);
  }
  if ((v8 & 0xFFFFFFF8) == 0) {
LABEL_23:
  }
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outs ide of the bounds set originally",  v5);
  __int128 v9 = operator new(0x30uLL);
  v9[2] = 0LL;
  unint64_t v9[3] = 0LL;
  *__int128 v9 = off_189668488;
  v9[1] = 1LL;
  void v9[4] = *v7;
  *unint64_t v7 = 0LL;
  *((_BYTE *)v9 + 40) = 0;
  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  *(void *)(a3 + 24) = v9;
  __int128 v6 = (void **)v18[1];
  if (v18[1])
  {
LABEL_12:
    if ((_DWORD)v19)
    {
      uint64_t v10 = 8LL * v19;
      uint64_t v11 = v6;
      do
      {
        uint64_t v12 = *v11;
        if (*v11)
        {
          uint64_t v13 = v12[1];
          if (v13 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v14 = v13 - 1;
          v12[1] = v14;
          if (!v14) {
            (*(void (**)(void *))(*v12 + 8LL))(v12);
          }
        }

        *v11++ = 0LL;
        v10 -= 8LL;
      }

      while (v10);
    }

    free(v6);
  }

void sub_18056A4F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void TLE::queryOpDeserializer(__int128 *a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    char v12 = 1;
    der_vm_iterate_b();
    if (*((_BYTE *)v10 + 24))
    {
      __int128 v6 = operator new(0x58uLL);
      __int128 v7 = *a1;
      __int128 v8 = a1[2];
      void v6[3] = a1[1];
      void v6[4] = v8;
      *((void *)v6 + 10) = *((void *)a1 + 6);
      *(void *)__int128 v6 = off_189668440;
      *((void *)v6 + 1) = 1LL;
      v6[1] = *(_OWORD *)(a2 + 8);
      void v6[2] = v7;
      *a3 = 0LL;
      a3[1] = 0LL;
      a3[2] = 0LL;
      a3[3] = v6;
    }

    else
    {
      *(_OWORD *)a3 = 0u;
      *((_OWORD *)a3 + 1) = 0u;
      *(_DWORD *)a3 = 6;
      a3[1] = "$query deserialization failed since it has an invalid query definition";
      a3[2] = 70LL;
    }

    _Block_object_dispose(&v9, 8);
  }

  else
  {
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    *(_DWORD *)a3 = 3;
    a3[1] = "Got an unexpected type (not a dictionary) when trying to generate a query operation.";
    a3[2] = 84LL;
  }

void sub_18056A644( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void TLE::andArrayOpDeserializer( uint64_t a1@<X0>, const der_vm_context *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  TLE::opArrayOpDeserializer((uint64_t)&v19, a1, a2, a3);
  if ((_DWORD)v19)
  {
    *(_OWORD *)a4 = v19;
    __int128 v6 = (void *)*((void *)&v20 + 1);
    *(void *)(a4 + 16) = v20;
    *(void *)(a4 + 24) = 0LL;
    if (!v6) {
      return;
    }
  }

  else
  {
    int v7 = v21;
    if ((_DWORD)v21 != 1)
    {
      der_vm_context v16 = operator new(0x30uLL);
      v16[2] = 0LL;
      void v16[3] = 0LL;
      *der_vm_context v16 = off_189668340;
      v16[1] = 1LL;
      _OWORD v16[4] = *((void *)&v20 + 1);
      *((_DWORD *)v16 + 10) = v7;
      *(void *)a4 = 0LL;
      *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a4 + 16) = 0LL;
      *(void *)(a4 + 24) = v16;
      return;
    }

    __int128 v6 = (void *)*((void *)&v20 + 1);
    if (!*((void *)&v20 + 1)) {
      goto LABEL_24;
    }
    unint64_t v8 = 8LL * v21;
    if (*((void *)&v20 + 1) + v8 < *((void *)&v20 + 1) || HIDWORD(v8)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v5);
    }
    if ((v8 & 0xFFFFFFF8) == 0) {
LABEL_24:
    }
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v5);
    *(void *)a4 = 0LL;
    *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
    uint64_t v9 = (void *)*v6;
    *(void *)(a4 + 16) = 0LL;
    *(void *)(a4 + 24) = v9;
    if (v9)
    {
      uint64_t v10 = v9[1];
      if (v10 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
      }

      v9[1] = v10 + 1;
    }
  }

  if ((_DWORD)v21)
  {
    uint64_t v11 = 8LL * v21;
    char v12 = (void **)v6;
    do
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        uint64_t v14 = v13[1];
        if (v14 <= 0)
        {
          __int128 v17 = __cxa_allocate_exception(8uLL);
          *__int128 v17 = "Over-release of an object";
          __cxa_throw(v17, MEMORY[0x1896146E0], 0LL);
        }

        uint64_t v15 = v14 - 1;
        v13[1] = v15;
        if (!v15) {
          (*(void (**)(void *))(*v13 + 8LL))(v13);
        }
      }

      *v12++ = 0LL;
      v11 -= 8LL;
    }

    while (v11);
  }

  free(v6);
}

void sub_18056A81C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TLE::orArrayOpDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  TLE::opArrayOpDeserializer(&v19, a1, a2, a3);
  if ((_DWORD)v19)
  {
    *(_OWORD *)a4 = v19;
    __int128 v6 = (void *)*((void *)&v20 + 1);
    *(void *)(a4 + 16) = v20;
    *(void *)(a4 + 24) = 0LL;
    if (!v6) {
      return;
    }
  }

  else
  {
    int v7 = v21;
    if ((_DWORD)v21 != 1)
    {
      der_vm_context v16 = operator new(0x30uLL);
      v16[2] = 0LL;
      void v16[3] = 0LL;
      *der_vm_context v16 = off_1896683B0;
      v16[1] = 1LL;
      _OWORD v16[4] = *((void *)&v20 + 1);
      *((_DWORD *)v16 + 10) = v7;
      *(void *)a4 = 0LL;
      *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a4 + 16) = 0LL;
      *(void *)(a4 + 24) = v16;
      return;
    }

    __int128 v6 = (void *)*((void *)&v20 + 1);
    if (!*((void *)&v20 + 1)) {
      goto LABEL_24;
    }
    unint64_t v8 = 8LL * v21;
    if (*((void *)&v20 + 1) + v8 < *((void *)&v20 + 1) || HIDWORD(v8)) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  v5);
    }
    if ((v8 & 0xFFFFFFF8) == 0) {
LABEL_24:
    }
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v5);
    *(void *)a4 = 0LL;
    *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
    uint64_t v9 = (void *)*v6;
    *(void *)(a4 + 16) = 0LL;
    *(void *)(a4 + 24) = v9;
    if (v9)
    {
      uint64_t v10 = v9[1];
      if (v10 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
      }

      v9[1] = v10 + 1;
    }
  }

  if ((_DWORD)v21)
  {
    uint64_t v11 = 8LL * v21;
    char v12 = (void **)v6;
    do
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        uint64_t v14 = v13[1];
        if (v14 <= 0)
        {
          __int128 v17 = __cxa_allocate_exception(8uLL);
          *__int128 v17 = "Over-release of an object";
          __cxa_throw(v17, MEMORY[0x1896146E0], 0LL);
        }

        uint64_t v15 = v14 - 1;
        v13[1] = v15;
        if (!v15) {
          (*(void (**)(void *))(*v13 + 8LL))(v13);
        }
      }

      *v12++ = 0LL;
      v11 -= 8LL;
    }

    while (v11);
  }

  free(v6);
}

void sub_18056A9FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TLE::opArrayOpDeserializer(uint64_t a1, uint64_t a2, const der_vm_context *a3, _DWORD *a4)
{
  if (*a4)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 6;
    __int128 v5 = "factless operator disallowed for active fact";
    uint64_t v6 = 44LL;
LABEL_11:
    *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
    *(void *)(a1 + 16) = v6;
    return;
  }

  __int128 v8 = *(_OWORD *)&a3->lookup.index_count;
  __int128 v32 = *(_OWORD *)&a3->runtime;
  __int128 v33 = v8;
  __int128 v34 = *(_OWORD *)&a3->sorted;
  der_end = a3->var0.ccstate.der_end;
  if (der_vm_CEType_from_context() != 2)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 3;
    __int128 v5 = "Got an unexpected type (not a sequence) when trying to read the array of matches.";
    uint64_t v6 = 81LL;
    goto LABEL_11;
  }

  unint64_t v9 = count_ce_elements(a3);
  if (!v9)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 4;
    __int128 v5 = "The array of dependent operations is empty.";
    uint64_t v6 = 43LL;
    goto LABEL_11;
  }

  unint64_t v10 = v9;
  uint64_t v31 = 0LL;
  if (HIDWORD(v9))
  {
    uint64_t v11 = 0LL;
    LODWORD(v10) = 0;
  }

  else
  {
    uint64_t v11 = malloc(8 * v9);
    bzero(v11, 8 * v10);
  }

  __int128 v30 = v11;
  LODWORD(v31) = v10;
  uint64_t v22 = 0LL;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x4002000000LL;
  char v25 = __Block_byref_object_copy__5107;
  unint64_t v26 = __Block_byref_object_dispose__5108;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  uint64_t v27 = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  v21[2] = 0x2000000000LL;
  v21[3] = 0LL;
  der_vm_iterate_b();
  char v12 = v23 + 5;
  if (*((_DWORD *)v23 + 10))
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 24) = 0LL;
    __int128 v13 = *(_OWORD *)v12;
    *(void *)(a1 + 16) = v12[2];
    *(_OWORD *)a1 = v13;
  }

  else
  {
    TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple( a1,  (uint64_t)&v30);
  }

  _Block_object_dispose(v21, 8);
  _Block_object_dispose(&v22, 8);
  uint64_t v14 = v30;
  if (v30)
  {
    if ((_DWORD)v31)
    {
      uint64_t v15 = 8LL * v31;
      der_vm_context v16 = (void **)v30;
      do
      {
        __int128 v17 = *v16;
        if (*v16)
        {
          uint64_t v18 = v17[1];
          if (v18 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v19 = v18 - 1;
          v17[1] = v19;
          if (!v19) {
            (*(void (**)(void *))(*v17 + 8LL))(v17);
          }
        }

        *v16++ = 0LL;
        v15 -= 8LL;
      }

      while (v15);
    }

    free(v14);
  }

void sub_18056ACBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation(v11 - 144);
  _Unwind_Resume(a1);
}

void os_detail::panic_trapping_policy::trap( os_detail::panic_trapping_policy *this, const char *a2)
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = this;
  __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
}

uint64_t TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple( uint64_t a1)
{
  id v2 = *(void **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      uint64_t v4 = 8 * v3;
      __int128 v5 = *(void ***)(a1 + 24);
      do
      {
        uint64_t v6 = *v5;
        if (*v5)
        {
          uint64_t v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v8 = v7 - 1;
          v6[1] = v8;
          if (!v8) {
            (*(void (**)(void *))(*v6 + 8LL))(v6);
          }
        }

        *v5++ = 0LL;
        v4 -= 8LL;
      }

      while (v4);
    }

    free(v2);
  }

  return a1;
}

uint64_t count_ce_elements(const der_vm_context *a1)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  uint64_t v6 = 0LL;
  der_vm_iterate_b();
  uint64_t v1 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_18056AE54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

__n128 __Block_byref_object_copy__5107(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void *___ZN3TLE21opArrayOpDeserializerERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE_block_invoke( void *a1, uint64_t a2)
{
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  uint64_t v3 = (_DWORD *)a1[7];
  if (*v3)
  {
    __int128 v47 = 0uLL;
    __int128 v48 = 0uLL;
    LODWORD(v47) = 6;
    uint64_t v4 = "factless operator disallowed for active fact";
    uint64_t v5 = 44LL;
LABEL_9:
    __n128 result = 0LL;
    *((void *)&v47 + 1) = v4;
    *(void *)&__int128 v48 = v5;
    uint64_t v11 = *(void *)(a1[4] + 8LL);
    *(_OWORD *)(v11 + 40) = v47;
    *(void *)(v11 + 56) = v5;
    return result;
  }

  uint64_t v6 = a1[6];
  uint64_t v7 = (der_vm_context *)(a2 + 56);
  __int128 v8 = *(_OWORD *)(a2 + 72);
  __int128 v68 = *(_OWORD *)(a2 + 56);
  __int128 v69 = v8;
  __int128 v70 = *(_OWORD *)(a2 + 88);
  uint64_t v71 = *(void *)(a2 + 104);
  if (der_vm_CEType_from_context() != 2)
  {
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    LODWORD(v47) = 6;
    uint64_t v4 = "Non array element found in operator Array";
    uint64_t v5 = 41LL;
    goto LABEL_9;
  }

  if (count_ce_elements(v7) != 2)
  {
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    LODWORD(v47) = 6;
    uint64_t v4 = "Incorrect number of elements in operator Array tuple";
    uint64_t v5 = 52LL;
    goto LABEL_9;
  }

  uint64_t v67 = 0LL;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  TLE::keyForContext((TLE *)&v65, v7);
  if ((_DWORD)v65)
  {
    __int128 v47 = v65;
    __int128 v48 = (unint64_t)v66;
    goto LABEL_26;
  }

  uint64_t v64 = 0LL;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v61 = 0u;
  __int128 v12 = *(_OWORD *)&v7->lookup.index_count;
  __int128 v57 = *(_OWORD *)&v7->runtime;
  __int128 v58 = v12;
  __int128 v59 = *(_OWORD *)&v7->sorted;
  der_end = v7->var0.ccstate.der_end;
  der_vm_execute_nocopy();
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  uint64_t v56 = 0LL;
  if (der_vm_CEType_from_context() == 1)
  {
    if (CEBuffer_cmp())
    {
      if (CEBuffer_cmp())
      {
        if (!CEBuffer_cmp())
        {
          TLE::optionalOpDeserializer(v6, (uint64_t)&v61, (uint64_t)&v47);
          goto LABEL_26;
        }

        goto LABEL_19;
      }

      TLE::orDeserializer(v6, (uint64_t)&v61, v3, (uint64_t)&v47);
    }

    else
    {
      TLE::andDeserializer(v6, (uint64_t)&v61, v3, (uint64_t)&v47);
    }
  }

  else
  {
    __int128 v49 = v61;
    __int128 v50 = v62;
    __int128 v51 = v63;
    uint64_t v52 = v64;
    if (der_vm_CEType_from_context() != 2)
    {
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      LODWORD(v47) = 3;
      uint64_t v13 = "Unexpected type in Array tuple";
      uint64_t v14 = 30LL;
      goto LABEL_21;
    }

    if (CEBuffer_cmp())
    {
      if (CEBuffer_cmp())
      {
LABEL_19:
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        LODWORD(v47) = 9;
        uint64_t v13 = "Unexpected operator in Array tuple";
        uint64_t v14 = 34LL;
LABEL_21:
        *((void *)&v47 + 1) = v13;
        *(void *)&__int128 v48 = v14;
        goto LABEL_26;
      }

      TLE::orArrayOpDeserializer(v6, (uint64_t)&v61, (uint64_t)v3, (uint64_t)&v47);
    }

    else
    {
      TLE::andArrayOpDeserializer(&v47, v6, &v61, v3);
    }
  }

void sub_18056B3BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation( uint64_t a1)
{
  id v2 = *(void ***)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      uint64_t v4 = 8 * v3;
      uint64_t v5 = *(void ***)a1;
      do
      {
        uint64_t v6 = *v5;
        if (*v5)
        {
          uint64_t v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v8 = v7 - 1;
          v6[1] = v8;
          if (!v8) {
            (*(void (**)(void *))(*v6 + 8LL))(v6);
          }
        }

        *v5++ = 0LL;
        v4 -= 8LL;
      }

      while (v4);
    }

    free(v2);
  }

  return a1;
}

uint64_t TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple( uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 32) = 0;
  *(_OWORD *)__n128 result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if (result + 24 != a2)
  {
    *(void *)(result + 24) = *(void *)a2;
    *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 8);
    *(void *)a2 = 0LL;
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  }

  return result;
}

uint64_t TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple( uint64_t a1)
{
  id v2 = *(void **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *(void *)(a1 + 24) = 0LL;
  return a1;
}

double TLE::keyForContext(TLE *this, der_vm_context *a2)
{
  if (der_vm_CEType_from_context() == 4)
  {
    uint64_t v3 = der_vm_string_from_context();
    *(void *)this = 0LL;
    *((void *)this + 1) = 0LL;
    *((void *)this + 2) = 0LL;
    *((void *)this + 3) = v3;
    *((void *)this + 4) = v5;
  }

  else
  {
    double result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((void *)this + 4) = 0LL;
    *(_DWORD *)this = 3;
    *((void *)this + 1) = "Expected operator string in Array tuple";
    *((void *)this + 2) = 39LL;
  }

  return result;
}

uint64_t ___ZL17count_ce_elementsRK14der_vm_context_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(void *)(v1 + 24);
  BOOL v3 = __CFADD__(v2, 1LL);
  uint64_t v4 = v2 + 1;
  uint64_t v5 = v3;
  BOOL v6 = v5 << 63 >> 63 != v5 || v5 << 63 >> 63 == -1;
  int v7 = v6;
  if (!v6) {
    *(void *)(v1 + 24) = v4;
  }
  return v7 ^ 1u;
}

uint64_t ___ZN3TLE19queryOpDeserializerERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE_block_invoke( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 116) == 2 && count_ce_elements((const der_vm_context *)(a2 + 56)) == 2) {
    return 1LL;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  return result;
}

void TLE::Executor::getDependentOpsFromDictionary(uint64_t a1, uint64_t a2, const der_vm_context *a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v5 + 1;
  if ((unint64_t)(v5 + 1) >= 6)
  {
    *(void *)(a2 + _Block_object_dispose(va, 8) = v5;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 8;
    BOOL v6 = "Constraint is too deeply nested. Failing to avoid recursion overflow";
    uint64_t v7 = 68LL;
LABEL_11:
    *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
    *(void *)(a1 + 16) = v7;
    return;
  }

  __int128 v9 = *(_OWORD *)&a3->lookup.index_count;
  __int128 v34 = *(_OWORD *)&a3->runtime;
  __int128 v35 = v9;
  __int128 v36 = *(_OWORD *)&a3->sorted;
  der_end = a3->var0.ccstate.der_end;
  if (der_vm_CEType_from_context() != 1)
  {
    --*(void *)(a2 + 8);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 3;
    BOOL v6 = "Got an unexpected type (not a dictionary) when trying to generate dependent operations for evaluation.";
    uint64_t v7 = 102LL;
    goto LABEL_11;
  }

  unint64_t v10 = count_ce_elements(a3);
  if (!v10)
  {
    --*(void *)(a2 + 8);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 4;
    BOOL v6 = "The dictionary of dependent operations is empty.";
    uint64_t v7 = 48LL;
    goto LABEL_11;
  }

  unint64_t v11 = v10;
  uint64_t v33 = 0LL;
  if (HIDWORD(v10))
  {
    __int128 v12 = 0LL;
    LODWORD(v11) = 0;
  }

  else
  {
    __int128 v12 = malloc(8 * v10);
    bzero(v12, 8 * v11);
  }

  uint64_t v32 = v12;
  LODWORD(v33) = v11;
  uint64_t v24 = 0LL;
  unint64_t v25 = &v24;
  uint64_t v26 = 0x4002000000LL;
  BOOL v27 = __Block_byref_object_copy__5107;
  uint64_t v28 = __Block_byref_object_dispose__5108;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v29 = 0LL;
  v23[0] = 0LL;
  v23[1] = v23;
  v23[2] = 0x2000000000LL;
  _OWORD v23[3] = 0LL;
  der_vm_iterate_b();
  uint64_t v13 = v25 + 5;
  int v14 = *((_DWORD *)v25 + 10);
  --*(void *)(a2 + 8);
  if (v14)
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 24) = 0LL;
    __int128 v15 = *(_OWORD *)v13;
    *(void *)(a1 + 16) = v13[2];
    *(_OWORD *)a1 = v15;
  }

  else
  {
    TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple( a1,  (uint64_t)&v32);
  }

  _Block_object_dispose(v23, 8);
  _Block_object_dispose(&v24, 8);
  uint64_t v16 = v32;
  if (v32)
  {
    if ((_DWORD)v33)
    {
      uint64_t v17 = 8LL * v33;
      uint64_t v18 = (void **)v32;
      do
      {
        uint64_t v19 = *v18;
        if (*v18)
        {
          uint64_t v20 = v19[1];
          if (v20 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v21 = v20 - 1;
          v19[1] = v21;
          if (!v21) {
            (*(void (**)(void *))(*v19 + 8LL))(v19);
          }
        }

        *v18++ = 0LL;
        v17 -= 8LL;
      }

      while (v17);
    }

    free(v16);
  }

void sub_18056B988( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation(v13 - 160);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3TLE8Executor29getDependentOpsFromDictionaryE14der_vm_contextRKNS_14FactDefinitionEbmPK8CEBuffer_block_invoke( uint64_t a1, der_vm_context *a2)
{
  uint64_t v149 = *MEMORY[0x1895F89C0];
  v138 = *(void **)(a1 + 48);
  memset(v147, 0, 40);
  BOOL v3 = a2 + 1;
  TLE::keyForContext((TLE *)v147, a2 + 1);
  if (LODWORD(v147[0]))
  {
    uint64_t result = 0LL;
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(_OWORD *)(v5 + 40) = v147[0];
    *(void *)(v5 + 56) = *(void *)&v147[1];
    return result;
  }

  uint64_t v146 = 0LL;
  memset(v145, 0, sizeof(v145));
  __int128 v6 = *(_OWORD *)&v3->lookup.index_count;
  __int128 v141 = *(_OWORD *)&v3->runtime;
  __int128 v142 = v6;
  __int128 v143 = *(_OWORD *)&v3->sorted;
  der_end = v3->var0.ccstate.der_end;
  der_vm_execute_nocopy();
  uint64_t v9 = *(void *)(a1 + 56);
  if (v9)
  {
    unint64_t v10 = (_BYTE *)*((void *)&v147[1] + 1);
    uint64_t v11 = *(void *)(a1 + 64) + 8LL;
    while (1)
    {
      uint64_t result = CEBuffer_cmp();
      if (!(_DWORD)result) {
        break;
      }
      v11 += 16LL;
      if (!--v9) {
        goto LABEL_9;
      }
    }

    uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(_DWORD *)(v25 + 40) = 6;
    uint64_t v26 = "Unexpected key for parsing context";
    uint64_t v27 = 34LL;
    goto LABEL_45;
  }

  unint64_t v10 = (_BYTE *)*((void *)&v147[1] + 1);
LABEL_9:
  if (*v10 != 36)
  {
    if (!*(_BYTE *)(a1 + 88))
    {
      uint64_t result = 0LL;
      uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8LL);
      *(_DWORD *)(v25 + 40) = 6;
      uint64_t v26 = "Fact not allowed in context";
      uint64_t v27 = 27LL;
LABEL_45:
      *(void *)(v25 + 4_Block_object_dispose(va, 8) = v26;
      *(void *)(v25 + 56) = v27;
      return result;
    }

    uint64_t v21 = *(void *)&v147[2];
    if (((*(uint64_t (**)(void, _BYTE *, void))(*(void *)*v138 + 32LL))( *v138,  v10,  *(void *)&v147[2]) & 1) == 0)
    {
      *(_OWORD *)((char *)v148 + 4) = *(_OWORD *)((char *)&v147[1] + 8);
      uint64_t v33 = (char *)operator new(0x38uLL);
      *((_DWORD *)v33 + _Block_object_dispose(va, 8) = 5;
      *(_OWORD *)(v33 + 36) = v148[0];
      *((_DWORD *)v33 + 13) = v148[1];
      *((void *)v33 + 2) = 0LL;
      *((void *)v33 + 3) = 0LL;
      *(void *)uint64_t v33 = off_189668258;
      *((void *)v33 + 1) = 1LL;
      v139 = v33;
      __int128 v34 = *(unint64_t **)(a1 + 80);
      uint64_t v35 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      unint64_t v36 = *v34;
      if (*v34)
      {
        unint64_t v37 = v36 + 8LL * *((unsigned int *)v34 + 2);
        BOOL v38 = v37 >= v36;
        unint64_t v39 = v37 - v36;
        if (!v38 || HIDWORD(v39)) {
          os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, o r [begin, end) is not a well-formed range",  v32);
        }
      }

      else
      {
        LODWORD(v39) = 0;
      }

      if (v35 >= 0) {
        unint64_t v52 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      }
      else {
        unint64_t v52 = -v35;
      }
      unint64_t v53 = ((unint64_t)v35 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
      if (v35 >= 0) {
        uint64_t v54 = 8 * v52;
      }
      else {
        uint64_t v54 = -8LL * v52;
      }
      if (v52 >> 61) {
        BOOL v55 = 1;
      }
      else {
        BOOL v55 = 8 * v52 > v53;
      }
      if (v55)
      {
        uint64_t v56 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would "
              "trigger an overflow";
      }

      else if (v54 == (int)v54)
      {
        uint64_t v56 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
        if ((v54 & 0x80000000) == 0 && (int)v54 + 8 <= v39)
        {
          uint64_t v57 = (int)v54;
          uint64_t v58 = (uint64_t)(int)v54 >> 63;
          __int128 v59 = (void **)(v36 + v57);
          uint64_t v60 = __CFADD__(v36, v57) ? v58 + 1 : v58;
          uint64_t v61 = v60 << 63 >> 63;
          uint64_t v56 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
          if (v61 == v60 && (v61 & 0x8000000000000000LL) == 0)
          {
            __int128 v62 = *v59;
            if (*v59)
            {
              uint64_t v63 = v62[1];
              if (v63 <= 0)
              {
                exception = __cxa_allocate_exception(8uLL);
                void *exception = "Over-release of an object";
                __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
              }

              goto LABEL_156;
            }

LABEL_158:
            *__int128 v59 = v33;
            uint64_t v103 = *(void *)(*(void *)(a1 + 40) + 8LL);
            uint64_t v104 = *(void *)(v103 + 24);
            uint64_t v105 = v104 + 1;
            uint64_t v106 = v104 == -1;
            BOOL v108 = v106 << 63 >> 63 != v106 || v106 << 63 >> 63 == -1;
            if (v108)
            {
              uint64_t v109 = *(void *)(*(void *)(a1 + 32) + 8LL);
              *(_DWORD *)(v109 + 40) = 10;
              *(void *)(v109 + 4_Block_object_dispose(va, 8) = "Too many elements in dictionary";
              *(void *)(v109 + 56) = 31LL;
              return 0LL;
            }

            else
            {
              *(void *)(v103 + 24) = v105;
              return !v108;
            }
          }
        }
      }

      else
      {
        uint64_t v56 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current"
              " position would overflow.";
      }

      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v56, v32);
    }

    v139 = 0LL;
    __int128 v140 = 0uLL;
    (*(void (**)(char **__return_ptr, void, _BYTE *, uint64_t))(*(void *)*v138 + 16LL))( &v139,  *v138,  v10,  v21);
    int v22 = der_vm_CEType_from_context();
    if (v22 == 1)
    {
      memset(v148, 0, sizeof(v148));
      TLE::factOpDeserializer((uint64_t)v148, (uint64_t)v138, (uint64_t)v145, (uint64_t)&v139);
      if (LODWORD(v148[0]))
      {
        uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8LL);
        *(_OWORD *)(v24 + 40) = v148[0];
        *(void *)(v24 + 56) = *(void *)&v148[1];
        TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple((uint64_t)v148);
        return 0LL;
      }

      int v110 = *(unint64_t **)(a1 + 80);
      uint64_t v111 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      unint64_t v112 = *v110;
      if (*v110)
      {
        unint64_t v113 = v112 + 8LL * *((unsigned int *)v110 + 2);
        BOOL v38 = v113 >= v112;
        unint64_t v114 = v113 - v112;
        if (!v38 || HIDWORD(v114)) {
          os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, o r [begin, end) is not a well-formed range",  v23);
        }
      }

      else
      {
        LODWORD(v114) = 0;
      }

      if (v111 >= 0) {
        unint64_t v115 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      }
      else {
        unint64_t v115 = -v111;
      }
      unint64_t v116 = ((unint64_t)v111 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
      if (v111 >= 0) {
        uint64_t v117 = 8 * v115;
      }
      else {
        uint64_t v117 = -8LL * v115;
      }
      if (v115 >> 61) {
        BOOL v118 = 1;
      }
      else {
        BOOL v118 = 8 * v115 > v116;
      }
      if (v118)
      {
        int v119 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would"
               " trigger an overflow";
      }

      else if (v117 == (int)v117)
      {
        int v119 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
        if ((v117 & 0x80000000) == 0 && (int)v117 + 8 <= v114)
        {
          uint64_t v120 = (int)v117;
          uint64_t v121 = (uint64_t)(int)v117 >> 63;
          BOOL v38 = __CFADD__(v112, v120);
          int v122 = (void **)(v112 + v120);
          if (v38) {
            ++v121;
          }
          uint64_t v123 = v121 << 63 >> 63;
          int v119 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
          if (v123 == v121 && (v123 & 0x8000000000000000LL) == 0)
          {
            libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=(v122, (void *)&v148[1] + 1);
            TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple((uint64_t)v148);
LABEL_210:
            uint64_t v82 = *(void *)(*(void *)(a1 + 40) + 8LL);
            uint64_t v83 = *(void *)(v82 + 24);
            goto LABEL_211;
          }
        }
      }

      else
      {
        int v119 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the curren"
               "t position would overflow.";
      }

      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v119, v23);
    }

    if (v22 == (_DWORD)v139)
    {
      unint64_t v45 = TLE::opForContext(v22);
      if (v45)
      {
        *((_OWORD *)v45 + 1) = v140;
        *(void *)&v148[0] = v45;
        __int128 v47 = *(unint64_t **)(a1 + 80);
        uint64_t v48 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        unint64_t v49 = *v47;
        if (*v47)
        {
          unint64_t v50 = v49 + 8LL * *((unsigned int *)v47 + 2);
          BOOL v38 = v50 >= v49;
          unint64_t v51 = v50 - v49;
          if (!v38 || HIDWORD(v51)) {
            os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range",  v46);
          }
        }

        else
        {
          LODWORD(v51) = 0;
        }

        if (v48 >= 0) {
          unint64_t v124 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        }
        else {
          unint64_t v124 = -v48;
        }
        if (v48 >= 0) {
          uint64_t v125 = 8 * v124;
        }
        else {
          uint64_t v125 = -8LL * v124;
        }
        uint64_t v126 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would"
               " trigger an overflow";
        if (!(v124 >> 61) && 8 * v124 <= ((unint64_t)v48 >> 63) + 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v125 == (int)v125)
          {
            uint64_t v126 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
            if ((v125 & 0x80000000) == 0 && (int)v125 + 8 <= v51)
            {
              uint64_t v127 = (uint64_t)(int)v125 >> 63;
              BOOL v38 = __CFADD__(v49, (int)v125);
              uint64_t v128 = (void **)(v49 + (int)v125);
              if (v38) {
                ++v127;
              }
              uint64_t v129 = v127 << 63 >> 63;
              uint64_t v126 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
              if (v129 == v127 && (v129 & 0x8000000000000000LL) == 0)
              {
                libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=(v128, v148);
                libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::~intrusive_shared_ptr((void **)v148);
                goto LABEL_210;
              }
            }
          }

          else
          {
            uint64_t v126 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the cu"
                   "rrent position would overflow.";
          }
        }

        os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v126, v46);
      }

      uint64_t v65 = *(void *)(*(void *)(a1 + 32) + 8LL);
      *(_DWORD *)(v65 + 40) = 3;
      __int128 v66 = "Unexpected type of an fact declaration.";
      uint64_t v67 = 39LL;
    }

    else
    {
      uint64_t v65 = *(void *)(*(void *)(a1 + 32) + 8LL);
      *(_DWORD *)(v65 + 40) = 3;
      __int128 v66 = "Unexpected type of an operation declaration.";
      uint64_t v67 = 44LL;
    }

    *(void *)(v65 + 4_Block_object_dispose(va, 8) = v66;
    *(void *)(v65 + 56) = v67;
    return 0LL;
  }

  if (&__block_descriptor_tmp_37_5128 < (_UNKNOWN *)&TLE::details::operations
    || (unint64_t)(&__block_descriptor_tmp_37_5128 - (_UNKNOWN *)&TLE::details::operations) >> 32)
  {
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [beg in, end) is not a well-formed range",  v7);
  }

  unint64_t v12 = (unint64_t)((unint64_t)&__block_descriptor_tmp_37_5128 - __PAIR128__( v8,  &TLE::details::operations)) >> 64;
  if (v12 & 1 | ((unint64_t)(&__block_descriptor_tmp_37_5128
                                   - (_UNKNOWN *)&TLE::details::operations
                                   + 0x80000000LL) >> 32))
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t",  v7);
  uint64_t v13 = (unint64_t)&TLE::details::operations >= 0xFFFFFFFFFFFFFEE0LL;
  uint64_t v14 = v13 << 63 >> 63;
  uint64_t v15 = v14 ^ v13;
  if (v14 < 0 || v15 != 0) {
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.",  v7);
  }
  for (int64_t i = (&__block_descriptor_tmp_37_5128 - (_UNKNOWN *)&TLE::details::operations) & 0xFFFFFFF8LL; ; i += 0x1800000000LL)
  {
    uint64_t v18 = (char *)&TLE::details::operations + (i >> 32);
    if (__CFADD__(&TLE::details::operations, i >> 32)) {
      uint64_t v19 = (i >> 63) + 1;
    }
    else {
      uint64_t v19 = i >> 63;
    }
    uint64_t v20 = v19 << 63 >> 63;
    if (v20 != v19 || v20 < 0) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.",  v7);
    }
    if (i < 0 || HIDWORD(i) + 24 > i) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  v7);
    }
    if ((unint64_t)((i >> 32) - 2147483624) < 0xFFFFFFFF00000000LL) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the o ffset representing the current position would overflow.",  v7);
    }
  }

  memset(v148, 0, sizeof(v148));
  (*((void (**)(_OWORD *__return_ptr, void *, _OWORD *, void))v18 + 2))( v148,  v138,  v145,  *(void *)(a1 + 72));
  if (!LODWORD(v148[0]))
  {
    uint64_t v40 = *(unint64_t **)(a1 + 80);
    uint64_t v41 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    unint64_t v42 = *v40;
    if (*v40)
    {
      unint64_t v43 = v42 + 8LL * *((unsigned int *)v40 + 2);
      BOOL v38 = v43 >= v42;
      unint64_t v44 = v43 - v42;
      if (!v38 || HIDWORD(v44)) {
        os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range",  v7);
      }
    }

    else
    {
      LODWORD(v44) = 0;
    }

    if (v41 >= 0) {
      unint64_t v68 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    }
    else {
      unint64_t v68 = -v41;
    }
    unint64_t v69 = ((unint64_t)v41 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
    if (v41 >= 0) {
      uint64_t v70 = 8 * v68;
    }
    else {
      uint64_t v70 = -8LL * v68;
    }
    if (v68 >> 61) {
      BOOL v71 = 1;
    }
    else {
      BOOL v71 = 8 * v68 > v69;
    }
    if (v71)
    {
      uint64_t v72 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would tr"
            "igger an overflow";
    }

    else if (v70 == (int)v70)
    {
      uint64_t v72 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
      if ((v70 & 0x80000000) == 0 && (int)v70 + 8 <= v44)
      {
        unint64_t v73 = (void **)(v42 + (int)v70);
        uint64_t v74 = __CFADD__(v42, (int)v70) ? ((uint64_t)(int)v70 >> 63) + 1 : (uint64_t)(int)v70 >> 63;
        uint64_t v75 = v74 << 63 >> 63;
        uint64_t v72 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
        if (v75 == v74 && (v75 & 0x8000000000000000LL) == 0)
        {
          uint64_t v76 = (void *)*((void *)&v148[1] + 1);
          __int128 v77 = *v73;
          if (*v73)
          {
            uint64_t v78 = v77[1];
            if (v78 <= 0)
            {
              v137 = __cxa_allocate_exception(8uLL);
              void *v137 = "Over-release of an object";
              __cxa_throw(v137, MEMORY[0x1896146E0], 0LL);
            }

            uint64_t v79 = v78 - 1;
            v77[1] = v79;
            if (!v79) {
              (*(void (**)(void *))(*v77 + 8LL))(v77);
            }
          }

          *unint64_t v73 = v76;
LABEL_110:
          unint64_t v80 = *(unint64_t **)(a1 + 80);
          uint64_t v81 = *(void *)(a1 + 40);
          uint64_t v82 = *(void *)(v81 + 8);
          uint64_t v83 = *(void *)(v82 + 24);
          unint64_t v84 = *v80;
          if (*v80)
          {
            unint64_t v85 = 8LL * *((unsigned int *)v80 + 2);
            if (v84 + v85 < v84 || HIDWORD(v85)) {
              os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this typ e, or [begin, end) is not a well-formed range",  v7);
            }
          }

          else
          {
            LODWORD(v85) = 0;
          }

          if (v83 >= 0) {
            unint64_t v86 = *(void *)(v82 + 24);
          }
          else {
            unint64_t v86 = -v83;
          }
          if (v83 >= 0) {
            uint64_t v87 = 8 * v86;
          }
          else {
            uint64_t v87 = -8LL * v86;
          }
          if (v86 >> 61) {
            BOOL v88 = 1;
          }
          else {
            BOOL v88 = 8 * v86 > ((unint64_t)v83 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
          }
          if (v88) {
            os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would trigger an overflow",  v7);
          }
          if (v87 != (int)v87) {
            os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current position would overflow.",  v7);
          }
          if ((v87 & 0x80000000) != 0 || (int)v87 + 8 > v85) {
            os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access mem ory outside of the bounds set originally",  v7);
          }
          uint64_t v89 = (int)v87;
          uint64_t v90 = (uint64_t)(int)v87 >> 63;
          BOOL v38 = __CFADD__(v84, v89);
          __int128 v91 = (void *)(v84 + v89);
          if (v38) {
            ++v90;
          }
          uint64_t v92 = v90 << 63 >> 63;
          if (v92 != v90 || v92 < 0) {
            os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represen ted by a native pointer.",  v7);
          }
          if (!*v91)
          {
            *(_OWORD *)((char *)v148 + 4) = *(_OWORD *)((char *)&v147[1] + 8);
            uint64_t v33 = (char *)operator new(0x38uLL);
            *((_DWORD *)v33 + _Block_object_dispose(va, 8) = 1;
            *(_OWORD *)(v33 + 36) = v148[0];
            *((_DWORD *)v33 + 13) = v148[1];
            *((void *)v33 + 2) = 0LL;
            *((void *)v33 + 3) = 0LL;
            *(void *)uint64_t v33 = off_189668258;
            *((void *)v33 + 1) = 1LL;
            v139 = v33;
            uint64_t v94 = *(void *)(*(void *)(v81 + 8) + 24LL);
            unint64_t v95 = *v80;
            if (*v80)
            {
              unint64_t v96 = 8LL * *((unsigned int *)v80 + 2);
              if (v95 + v96 < v95 || HIDWORD(v96)) {
                os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this t ype, or [begin, end) is not a well-formed range",  v93);
              }
            }

            else
            {
              LODWORD(v96) = 0;
            }

            if (v94 >= 0) {
              unint64_t v97 = *(void *)(*(void *)(v81 + 8) + 24LL);
            }
            else {
              unint64_t v97 = -v94;
            }
            if (v94 >= 0) {
              uint64_t v98 = 8 * v97;
            }
            else {
              uint64_t v98 = -8LL * v97;
            }
            BOOL v99 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) wo"
                  "uld trigger an overflow";
            if (!(v97 >> 61) && 8 * v97 <= ((unint64_t)v94 >> 63) + 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v98 == (int)v98)
              {
                BOOL v99 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
                if ((v98 & 0x80000000) == 0 && (int)v98 + 8 <= v96)
                {
                  __int128 v59 = (void **)(v95 + (int)v98);
                  uint64_t v100 = __CFADD__(v95, (int)v98) ? ((uint64_t)(int)v98 >> 63) + 1 : (uint64_t)(int)v98 >> 63;
                  uint64_t v101 = v100 << 63 >> 63;
                  BOOL v99 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
                  if (v101 == v100 && (v101 & 0x8000000000000000LL) == 0)
                  {
                    __int128 v62 = *v59;
                    if (*v59)
                    {
                      uint64_t v63 = v62[1];
                      if (v63 <= 0)
                      {
                        v136 = __cxa_allocate_exception(8uLL);
                        void *v136 = "Over-release of an object";
                        __cxa_throw(v136, MEMORY[0x1896146E0], 0LL);
                      }

    uint64_t v81 = CFErrorCreate(*v3, v80, -909LL, 0LL);
    goto LABEL_159;
  }

  memset(v173, 170, sizeof(v173));
  memset(v172, 170, sizeof(v172));
  memset(v171, 170, sizeof(v171));
  memset(v170, 170, sizeof(v170));
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[1]))
  {
LABEL_374:
    v157 = @"To generate a password, need a min length";
    goto LABEL_381;
  }

  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordRequiredCharactersKey, (const void **)v173))
  {
LABEL_365:
    v157 = @"Need an array of character sets, password must have at least 1 character from each set";
    goto LABEL_381;
  }

  if (v173[3])
  {
    uint64_t v13 = CFGetTypeID(v173[3]);
    if (v13 == CFNullGetTypeID())
    {
LABEL_364:
      v157 = @"Need a string of characters; password must only contain characters in this string";
      goto LABEL_381;
    }
  }

  if (v173[2])
  {
    uint64_t v14 = CFGetTypeID(v173[2]);
    if (v14 == CFNullGetTypeID())
    {
LABEL_373:
      v157 = @"To generate a password, need a max length";
      goto LABEL_381;
    }
  }

  if (v173[1])
  {
    uint64_t v15 = CFGetTypeID(v173[1]);
    if (v15 == CFNullGetTypeID()) {
      goto LABEL_374;
    }
  }

  if (v173[0])
  {
    uint64_t v16 = CFGetTypeID(v173[0]);
    if (v16 == CFNullGetTypeID()) {
      goto LABEL_365;
    }
  }

  if (!v173[3] || (uint64_t v17 = CFGetTypeID(v173[3]), v17 != CFStringGetTypeID()))
  {
    v157 = @"The password's allowed characters must be a CFStringRef";
    goto LABEL_381;
  }

  if (!v173[2] || (uint64_t v18 = CFGetTypeID(v173[2]), v18 != CFNumberGetTypeID()))
  {
    v157 = @"The password's max length must be a CFNumberRef";
    goto LABEL_381;
  }

  if (!v173[1] || (uint64_t v19 = CFGetTypeID(v173[1]), v19 != CFNumberGetTypeID()))
  {
    v157 = @"The password's min length must be a CFNumberRef";
    goto LABEL_381;
  }

  if (!v173[0] || (uint64_t v20 = CFGetTypeID(v173[0]), v20 != CFArrayGetTypeID()))
  {
    v157 = @"The password's required characters must be an array of CFCharacterSetRefs";
    goto LABEL_381;
  }

  CFNumberGetValue((CFNumberRef)v173[1], kCFNumberSInt64Type, v170);
  uint64_t v21 = v170[0];
  CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, v170);
  if (v21 > v170[0])
  {
    v157 = @"The password's length parameters make no sense(is max < min ?)";
    goto LABEL_381;
  }

  if (!CFStringGetLength((CFStringRef)v173[3])) {
    goto LABEL_364;
  }
  if (!CFArrayGetCount((CFArrayRef)v173[0])) {
    goto LABEL_365;
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDisallowedCharacters, (const void **)&v172[3]))
  {
    if (!v172[3]
      || (int v22 = CFGetTypeID(v172[3]), v22 == CFNullGetTypeID())
      || !v172[3]
      || (unint64_t v23 = CFGetTypeID(v172[3]), v23 != CFStringGetTypeID()))
    {
      v157 = @"Disallowed Characters dictionary parameter is either null or not a string";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantEndWithChars, (const void **)&v172[2]))
  {
    if (!v172[2]
      || (uint64_t v24 = CFGetTypeID(v172[2]), v24 == CFNullGetTypeID())
      || !v172[2]
      || (uint64_t v25 = CFGetTypeID(v172[2]), v25 != CFStringGetTypeID()))
    {
      v157 = @"The dictionary parameter 'EndWith' is either null or not a string";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantStartWithChars, (const void **)&v172[1]))
  {
    if (!v172[1]
      || (uint64_t v26 = CFGetTypeID(v172[1]), v26 == CFNullGetTypeID())
      || !v172[1]
      || (uint64_t v27 = CFGetTypeID(v172[1]), v27 != CFStringGetTypeID()))
    {
      v157 = @"The dictionary parameter 'StartWith' is either null or not a string";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordGroupSize, (const void **)v172))
  {
    if (!v172[0]
      || (uint64_t v28 = CFGetTypeID(v172[0]), v28 == CFNullGetTypeID())
      || !v172[0]
      || (uint64_t v29 = CFGetTypeID(v172[0]), v29 != CFNumberGetTypeID()))
    {
      v157 = @"The dictionary parameter 'groupsize' is either null or not a number";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordNumberOfGroups, (const void **)&v171[3]))
  {
    if (!v171[3]
      || (uint64_t v30 = CFGetTypeID(v171[3]), v30 == CFNullGetTypeID())
      || !v171[3]
      || (uint64_t v31 = CFGetTypeID(v171[3]), v31 != CFNumberGetTypeID()))
    {
      v157 = @"The dictionary parameter 'number of groupds' is either null or not a number";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordSeparator, (const void **)&v171[2]))
  {
    if (!v171[2]
      || (uint64_t v32 = CFGetTypeID(v171[2]), v32 == CFNullGetTypeID())
      || !v171[2]
      || (uint64_t v33 = CFGetTypeID(v171[2]), v33 != CFStringGetTypeID()))
    {
      v157 = @"The dictionary parameter 'password separator character' is either null or not a string";
      goto LABEL_381;
    }
  }

  if (CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters,  (const void **)&v171[1]))
  {
    if (!v171[1]) {
      goto LABEL_362;
    }
    __int128 v34 = CFGetTypeID(v171[1]);
    if (v34 == CFNullGetTypeID()) {
      goto LABEL_362;
    }
    if (!v171[1]) {
      goto LABEL_362;
    }
    uint64_t v35 = CFGetTypeID(v171[1]);
    if (v35 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent( (CFDictionaryRef)v171[1],  (const void *)kSecPasswordCharacterCount,  (const void **)&v170[3]))
    {
      goto LABEL_362;
    }

    if (!v170[3]) {
      goto LABEL_360;
    }
    unint64_t v36 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v36 == CFNullGetTypeID()) {
      goto LABEL_360;
    }
    if (!v170[3]) {
      goto LABEL_360;
    }
    unint64_t v37 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v37 != CFNumberGetTypeID()) {
      goto LABEL_360;
    }
    if (!CFDictionaryGetValueIfPresent( (CFDictionaryRef)v171[1],  (const void *)kSecPasswordCharacters,  (const void **)&v170[1]))
    {
LABEL_362:
      v157 = @"The dictionary parameter 'At Most N Characters' is either null or not a string";
      goto LABEL_381;
    }

    if (!v170[1]) {
      goto LABEL_361;
    }
    BOOL v38 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v38 == CFNullGetTypeID()) {
      goto LABEL_361;
    }
    if (!v170[1]) {
      goto LABEL_361;
    }
    unint64_t v39 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v39 != CFStringGetTypeID()) {
      goto LABEL_361;
    }
  }

  if (CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsAtLeastNSpecificCharacters,  (const void **)v171))
  {
    if (!v171[0]) {
      goto LABEL_363;
    }
    uint64_t v40 = CFGetTypeID(v171[0]);
    if (v40 == CFNullGetTypeID()) {
      goto LABEL_363;
    }
    if (!v171[0]) {
      goto LABEL_363;
    }
    uint64_t v41 = CFGetTypeID(v171[0]);
    if (v41 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent( (CFDictionaryRef)v171[0],  (const void *)kSecPasswordCharacterCount,  (const void **)&v170[3]))
    {
      goto LABEL_363;
    }

    if (v170[3])
    {
      unint64_t v42 = CFGetTypeID((CFTypeRef)v170[3]);
      if (v42 != CFNullGetTypeID())
      {
        if (v170[3])
        {
          unint64_t v43 = CFGetTypeID((CFTypeRef)v170[3]);
          if (v43 == CFNumberGetTypeID())
          {
            if (CFDictionaryGetValueIfPresent( (CFDictionaryRef)v171[0],  (const void *)kSecPasswordCharacters,  (const void **)&v170[1]))
            {
              if (v170[1])
              {
                unint64_t v44 = CFGetTypeID((CFTypeRef)v170[1]);
                if (v44 != CFNullGetTypeID())
                {
                  if (v170[1])
                  {
                    unint64_t v45 = CFGetTypeID((CFTypeRef)v170[1]);
                    if (v45 == CFStringGetTypeID()) {
                      goto LABEL_106;
                    }
                  }
                }
              }

LABEL_156:
                      uint64_t v102 = v63 - 1;
                      v62[1] = v102;
                      if (!v102) {
                        (*(void (**)(void *))(*v62 + 8LL))(v62);
                      }
                      goto LABEL_158;
                    }

                    goto LABEL_158;
                  }
                }
              }

              else
              {
                BOOL v99 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the"
                      " current position would overflow.";
              }
            }

            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v99, v93);
          }

  unint64_t v68 = *((void *)this + 1);
  unint64_t v69 = *MEMORY[0x189605018];
  if (*(void *)(v68 + 24) == *MEMORY[0x189605018] && !*(_BYTE *)(v68 + 301)) {
    *((_DWORD *)this + 72) |= 2u;
  }
  uint64_t v70 = *(const void **)(v68 + 120);
  if (v70)
  {
    BOOL v71 = CFGetTypeID(v70);
    CFTypeID TypeID = CFDataGetTypeID();
    unint64_t v73 = *(const __CFData **)(*((void *)this + 1) + 120LL);
    if (v71 == TypeID)
    {
      uint64_t v74 = (unsigned int *)CFDataGetBytePtr(v73);
      if (*v74 != 17620730
        || (uint64_t v75 = bswap32(v74[2]), v76 = 8LL * v75 + 12, v77 = bswap32(v74[1]), v76 > v77))
      {
        *__error() = 22;
LABEL_171:
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14LL);
      }

      uint64_t v78 = (unint64_t)&v74[2 * v75 + 3];
      while (1)
      {
        v78 -= 8LL;
        uint64_t v79 = *(_DWORD *)(v78 + 4);
        if (v79)
        {
          unint64_t v80 = bswap32(v79);
          uint64_t v81 = v76 > v80 || v80 + 8 > v77;
        }
      }
    }

    uint64_t v87 = CFGetTypeID(v73);
    if (v87 != CFStringGetTypeID()) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
    }
    theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    theDict = (CFMutableDictionaryRef)CFStringCreateMutableCopy( 0LL,  0LL,  *(CFStringRef *)(*((void *)this + 1) + 120LL));
    BOOL v88 = CFStringGetLength((CFStringRef)theDict);
    uint64_t v89 = (__CFString *)theDict;
    if (*((char *)this + 159) < 0)
    {
      std::string::__init_copy_ctor_external( &v230,  *((const std::string::value_type **)this + 17),  *((void *)this + 18));
    }

    else
    {
      *(_OWORD *)&v230.__r_.__value_.__l.__data_ = *(_OWORD *)v221;
      v230.__r_.__value_.__l.__cap_ = *((void *)this + 19);
    }

    Security::CFTempString::CFTempString<std::string>((CFStringRef *)v250, (char *)&v230);
    v252.location = 0LL;
    v252.size_t length = v88;
    CFStringFindAndReplace(v89, @"$self.identifier", *(CFStringRef *)v250, v252, 0LL);
    Security::CFRef<__CFString const*>::~CFRef((const void **)v250);
    Security::cfString(&__str, (CFStringRef)theDict);
    else {
      CFDataRef theData = __str;
    }
    memset(v250, 0, 24);
    char v93 = *(uint64_t (**)(_BYTE *, _BYTE *))(*(void *)(Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
                                                                 + 72)
                                                     + 32LL);
    uint64_t v94 = (char)theData.__r_.__value_.__s.__size_;
    if ((char)theData.__r_.__value_.__s.__size_ < 0) {
      std::string::__init_copy_ctor_external( (std::string *)v237,  theData.__r_.__value_.__l.__data_,  theData.__r_.__value_.__l.__size_);
    }
    else {
      *(std::string *)v237 = theData;
    }
    unint64_t v95 = v93(v237, v250);
    if ((v237[23] & 0x80000000) != 0) {
      operator delete(*(void **)v237);
    }
    if (!v95)
    {
      if ((v250[23] & 0x80000000) != 0) {
        std::string::__init_copy_ctor_external( &__p,  *(const std::string::value_type **)v250,  *(std::string::size_type *)&v250[8]);
      }
      else {
        __p = *(std::string *)v250;
      }
      Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v228, (char *)&__p);
      Security::CodeSigning::CSError::throwMe( (Security::CodeSigning::CSError *)0xFFFEFA14LL,  (uint64_t)@"SecRequirementSyntax",  (const __CFString *)v228.__r_.__value_.__l.__data_,  v217);
    }

    if ((v250[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)v250);
      if ((v94 & 0x80000000) == 0) {
        goto LABEL_203;
      }
    }

    else if ((v94 & 0x80000000) == 0)
    {
LABEL_203:
      *((void *)this + 37) = v95;
      Security::CFRef<__CFString *>::~CFRef((const void **)&theDict);
      goto LABEL_206;
    }

    operator delete(theData.__r_.__value_.__l.__data_);
    goto LABEL_203;
  }

  if ((v6 & 2) != 0)
  {
    uint64_t v74 = Security::CodeSigning::SecStaticCode::internalRequirements(*((Security::CodeSigning::SecStaticCode **)this + 2));
    if (v74)
    {
LABEL_183:
      uint64_t v90 = Security::BlobCore::clone((Security::BlobCore *)v74);
      *((void *)this + 37) = Security::Blob<Security::SuperBlob<4208856065u,unsigned int>,4208856065u>::specific(v90);
    }
  }

LABEL_211:
          uint64_t v130 = v83 + 1;
          uint64_t v131 = v83 == -1;
          BOOL v133 = v131 << 63 >> 63 != v131 || v131 << 63 >> 63 == -1;
          if (v133)
          {
            uint64_t v134 = *(void *)(*(void *)(a1 + 32) + 8LL);
            *(_DWORD *)(v134 + 40) = 10;
            *(void *)(v134 + 4_Block_object_dispose(va, 8) = "Too many elements in dictionary";
            *(void *)(v134 + 56) = 31LL;
          }

          else
          {
            *(void *)(v82 + 24) = v130;
          }

          return !v133;
        }
      }
    }

    else
    {
      uint64_t v72 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current p"
            "osition would overflow.";
    }

    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v72, v7);
  }

  uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 8LL);
  *(_OWORD *)(v28 + 40) = v148[0];
  uint64_t v29 = (void *)*((void *)&v148[1] + 1);
  *(void *)(v28 + 56) = *(void *)&v148[1];
  if (v29)
  {
    uint64_t v30 = v29[1];
    if (v30 <= 0)
    {
      v135 = __cxa_allocate_exception(8uLL);
      void *v135 = "Over-release of an object";
      __cxa_throw(v135, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v31 = v30 - 1;
    v29[1] = v31;
    if (!v31) {
      (*(void (**)(void *))(*v29 + 8LL))(v29);
    }
  }

  return 0LL;
}

void sub_18056C5C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void **libkern::intrusive_shared_ptr<TLE::ConstErrorOperation,TLE::RefCountPolicy>::~intrusive_shared_ptr( void **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *a1 = 0LL;
  return a1;
}

__n128 TLE::factOpDeserializer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = 0LL;
  __n128 v22 = 0u;
  *(_OWORD *)unint64_t v23 = 0u;
  __int128 v5 = *(_OWORD *)(a3 + 16);
  v20[0] = *(_OWORD *)a3;
  v20[1] = v5;
  v20[2] = *(_OWORD *)(a3 + 32);
  uint64_t v21 = *(void *)(a3 + 48);
  TLE::Executor::getDependentOpsFromDictionary(&v22, a2, v20, a4, 0LL, 0LL, 0LL);
  if (v22.n128_u32[0])
  {
    __n128 result = v22;
    *(__n128 *)a1 = v22;
    *(void **)(a1 + 16) = v23[0];
    *(void *)(a1 + 24) = 0LL;
    unint64_t v8 = (void **)v23[1];
    if (!v23[1]) {
      return result;
    }
    goto LABEL_13;
  }

  if ((_DWORD)v24 != 1)
  {
    __n128 result = 0uLL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)a1 = 6;
    *(void *)(a1 + _Block_object_dispose(va, 8) = "There should only be one operation to match a fact";
    *(void *)(a1 + 16) = 50LL;
    unint64_t v8 = (void **)v23[1];
    if (!v23[1]) {
      return result;
    }
    goto LABEL_13;
  }

  uint64_t v9 = (uint64_t *)v23[1];
  if (!v23[1]) {
    goto LABEL_27;
  }
  unint64_t v10 = 8LL * v24;
  if ((char *)v23[1] + v10 < v23[1] || HIDWORD(v10)) {
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [beg in, end) is not a well-formed range",  v6);
  }
  if ((v10 & 0xFFFFFFF8) == 0) {
LABEL_27:
  }
    os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outs ide of the bounds set originally",  v6);
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v11 = *v9;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = v11;
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 8);
    if (v12 < 1)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Attempted resurection of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    *(void *)(v11 + _Block_object_dispose(va, 8) = v12 + 1;
  }

  unint64_t v8 = (void **)v23[1];
  if (v23[1])
  {
LABEL_13:
    if ((_DWORD)v24)
    {
      uint64_t v13 = 8LL * v24;
      uint64_t v14 = v8;
      do
      {
        uint64_t v15 = *v14;
        if (*v14)
        {
          uint64_t v16 = v15[1];
          if (v16 <= 0)
          {
            uint64_t v18 = __cxa_allocate_exception(8uLL);
            *uint64_t v18 = "Over-release of an object";
            __cxa_throw(v18, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v17 = v16 - 1;
          v15[1] = v17;
          if (!v17) {
            (*(void (**)(void *))(*v15 + 8LL))(v15);
          }
        }

        *v14++ = 0LL;
        v13 -= 8LL;
      }

      while (v13);
    }

    free(v8);
  }

  return result;
}

void sub_18056C8A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=( void **a1, void *a2)
{
  uint64_t v4 = (void *)*a2;
  __int128 v5 = *a1;
  if (v5)
  {
    uint64_t v6 = v5[1];
    if (v6 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v7 = v6 - 1;
    v5[1] = v7;
    if (!v7) {
      (*(void (**)(void *))(*v5 + 8LL))(v5);
    }
  }

  *a1 = v4;
  *a2 = 0LL;
  return a1;
}

void *TLE::opForContext(int a1)
{
  switch(a1)
  {
    case 3:
      uint64_t v1 = operator new(0x28uLL);
      uint64_t v2 = der_vm_integer_from_context();
      v1[2] = 0LL;
      v1[3] = 0LL;
      void *v1 = off_189668180;
      v1[1] = 1LL;
      v1[4] = v2;
      break;
    case 4:
      uint64_t v1 = operator new(0x30uLL);
      uint64_t v4 = der_vm_string_from_context();
      v1[2] = 0LL;
      v1[3] = 0LL;
      uint64_t v6 = off_1896681C8;
      goto LABEL_7;
    case 5:
      uint64_t v1 = operator new(0x28uLL);
      char v3 = der_vm_BOOL_from_context();
      v1[2] = 0LL;
      v1[3] = 0LL;
      void *v1 = off_189668138;
      v1[1] = 1LL;
      *((_BYTE *)v1 + 32) = v3;
      break;
    case 6:
      uint64_t v1 = operator new(0x30uLL);
      uint64_t v4 = der_vm_data_from_context();
      v1[2] = 0LL;
      v1[3] = 0LL;
      uint64_t v6 = off_189668210;
LABEL_7:
      void *v1 = v6;
      v1[1] = 1LL;
      v1[4] = v4;
      v1[5] = v5;
      break;
    default:
      uint64_t v1 = 0LL;
      break;
  }

  return v1;
}

void sub_18056CAC8(_Unwind_Exception *a1)
{
}

void **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::~intrusive_shared_ptr( void **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *a1 = 0LL;
  return a1;
}

void *_ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEE7ExecuteERNS_12EncyclopediaE@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = 0LL;
  memset(v5, 0, sizeof(v5));
  __n128 result = (*(void *(**)(_OWORD *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( v5,  a2,  *(void *)(a1 + 16),  *(void *)(a1 + 24));
  if (LODWORD(v5[0]) == 6)
  {
    __n128 result = (void *)CEBuffer_cmp();
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = (_DWORD)result == 0;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected data)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 52LL;
  }

  return result;
}

uint64_t TLE::Operation::shouldIgnore(TLE::Operation *this)
{
  return 0LL;
}

void TLE::RefCounted::~RefCounted(TLE::RefCounted *this)
{
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

{
  void *exception;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(this);
}

void *_ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEE7ExecuteERNS_12EncyclopediaE@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = 0LL;
  memset(v5, 0, sizeof(v5));
  __n128 result = (*(void *(**)(_OWORD *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( v5,  a2,  *(void *)(a1 + 16),  *(void *)(a1 + 24));
  if (LODWORD(v5[0]) == 4)
  {
    __n128 result = (void *)CEBuffer_cmp();
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = (_DWORD)result == 0;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected a string)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 56LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = *((void *)&v9 + 1) == a1[4];
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEE7ExecuteERNS_12EncyclopediaE@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v11 = 0LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v9,  a2,  *(void *)(a1 + 16),  *(void *)(a1 + 24));
  if ((_DWORD)v9 == 3 || (_DWORD)v9 == 5)
  {
    BOOL v7 = *((void *)&v10 + 1) == 0LL;
    BOOL v8 = *(_BYTE *)(a1 + 32) != 0;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7 ^ v8;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void TLE::ConstErrorOperation::~ConstErrorOperation(TLE::ConstErrorOperation *this)
{
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

{
  void *exception;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(this);
}

__n128 TLE::ConstErrorOperation::Execute@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  a2[1].n128_u8[8] = 0;
  __n128 result = a1[2];
  *a2 = result;
  a2[1].n128_u64[0] = a1[3].n128_u64[0];
  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = (a1[4] & ~*((void *)&v9 + 1)) == 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = *((void *)&v9 + 1) >= a1[4];
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = *((void *)&v9 + 1) > a1[4];
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = *((void *)&v9 + 1) <= a1[4];
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEED1Ev(void *result)
{
  *__n128 result = off_1896684D0;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEED0Ev(void *a1)
{
  *a1 = off_1896684D0;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(a1);
}

void *_ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEE7ExecuteERNS_12EncyclopediaE@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __n128 result = (*(void *(**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v8,  a2,  a1[2],  a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    BOOL v7 = *((void *)&v9 + 1) < a1[4];
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = v7;
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 66LL;
  }

  return result;
}

void TLE::AndOperation::~AndOperation(TLE::AndOperation *this)
{
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *exception;
  void *v10;
  *(void *)this = off_189668340;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)this + 10);
    if ((_DWORD)v3)
    {
      uint64_t v4 = 8 * v3;
      uint64_t v5 = (void **)*((void *)this + 4);
      do
      {
        uint64_t v6 = *v5;
        if (*v5)
        {
          BOOL v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          __int128 v8 = v7 - 1;
          v6[1] = v8;
          if (!v8) {
            (*(void (**)(void *))(*v6 + 8LL))(v6);
          }
        }

        *v5++ = 0LL;
        v4 -= 8LL;
      }

      while (v4);
    }

    free(v2);
  }

  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    uint64_t v10 = __cxa_allocate_exception(8uLL);
    _BYTE *v10 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v10, MEMORY[0x1896146E0], 0LL);
  }

void *TLE::AndOperation::Execute@<X0>(void *result@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = result[4];
  if (v5)
  {
    unint64_t v6 = v5 + 8LL * *((unsigned int *)result + 10);
    if (v6 < v5 || (8 * (unint64_t)*((unsigned int *)result + 10)) >> 32) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  a2);
    }
    uint64_t v8 = (v6 - (unsigned __int128)v5) >> 64;
    uint64_t v7 = 8LL * *((unsigned int *)result + 10);
    if ((v8 & 1) != (unint64_t)(int)v7 >> 63 || v7 != (int)v7) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t",  a2);
    }
    uint64_t v10 = (8 * *((_DWORD *)result + 10));
  }

  else
  {
    uint64_t v10 = 0LL;
    LODWORD(v7) = 0;
  }

  uint64_t v11 = (int)v7;
  uint64_t v12 = (uint64_t)(int)v7 >> 63;
  uint64_t v13 = (void *)(v5 + v11);
  if (__CFADD__(v5, v11)) {
    uint64_t v14 = v12 + 1;
  }
  else {
    uint64_t v14 = v12;
  }
  BOOL v16 = v14 << 63 >> 63 != v14 || v14 << 63 >> 63 == -1;
  while (1)
  {
    uint64_t v17 = (void *)(v5 + (v10 >> 32));
    if (__CFADD__(v5, v10 >> 32)) {
      uint64_t v18 = (v10 >> 63) + 1;
    }
    else {
      uint64_t v18 = v10 >> 63;
    }
    uint64_t v19 = v18 << 63 >> 63;
    if (v19 != v18 || v19 < 0 || v16) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.",  a2);
    }
    if (v17 == v13)
    {
      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      *(_BYTE *)(a3 + 24) = 1;
      return result;
    }

    if (v10 < 0 || HIDWORD(v10) + 8 > v10) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  a2);
    }
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __n128 result = (*(void *(**)(__int128 *__return_ptr, void, const char *))(*(void *)*v17 + 16LL))( &v20,  *v17,  a2);
    if ((_DWORD)v20)
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = v20;
      *(void *)(a3 + 16) = v21;
      return result;
    }

    if (!BYTE8(v21)) {
      break;
    }
    if ((unint64_t)((v10 >> 32) - 2147483640) < 0xFFFFFFFF00000000LL) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the o ffset representing the current position would overflow.",  a2);
    }
    v10 += 0x800000000LL;
  }

  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0LL;
  return result;
}

void TLE::OrOperation::~OrOperation(TLE::OrOperation *this)
{
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *exception;
  void *v10;
  *(void *)this = off_1896683B0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)this + 10);
    if ((_DWORD)v3)
    {
      uint64_t v4 = 8 * v3;
      unint64_t v5 = (void **)*((void *)this + 4);
      do
      {
        unint64_t v6 = *v5;
        if (*v5)
        {
          uint64_t v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
          }

          uint64_t v8 = v7 - 1;
          v6[1] = v8;
          if (!v8) {
            (*(void (**)(void *))(*v6 + 8LL))(v6);
          }
        }

        *v5++ = 0LL;
        v4 -= 8LL;
      }

      while (v4);
    }

    free(v2);
  }

  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    uint64_t v10 = __cxa_allocate_exception(8uLL);
    _BYTE *v10 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v10, MEMORY[0x1896146E0], 0LL);
  }

uint64_t TLE::OrOperation::Execute@<X0>(uint64_t result@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = *(void *)(result + 32);
  if (v5)
  {
    unint64_t v6 = v5 + 8LL * *(unsigned int *)(result + 40);
    if (v6 < v5 || (8 * (unint64_t)*(unsigned int *)(result + 40)) >> 32) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [b egin, end) is not a well-formed range",  a2);
    }
    uint64_t v8 = (v6 - (unsigned __int128)v5) >> 64;
    uint64_t v7 = 8LL * *(unsigned int *)(result + 40);
    if ((v8 & 1) != (unint64_t)(int)v7 >> 63 || v7 != (int)v7) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t",  a2);
    }
    uint64_t v10 = (8 * *(_DWORD *)(result + 40));
  }

  else
  {
    uint64_t v10 = 0LL;
    LODWORD(v7) = 0;
  }

  uint64_t v11 = (int)v7;
  uint64_t v12 = (uint64_t)(int)v7 >> 63;
  uint64_t v13 = (void *)(v5 + v11);
  if (__CFADD__(v5, v11)) {
    uint64_t v14 = v12 + 1;
  }
  else {
    uint64_t v14 = v12;
  }
  BOOL v16 = v14 << 63 >> 63 != v14 || v14 << 63 >> 63 == -1;
  while (1)
  {
    uint64_t v17 = (void *)(v5 + (v10 >> 32));
    if (__CFADD__(v5, v10 >> 32)) {
      uint64_t v18 = (v10 >> 63) + 1;
    }
    else {
      uint64_t v18 = v10 >> 63;
    }
    uint64_t v19 = v18 << 63 >> 63;
    if (v19 != v18 || v19 < 0 || v16) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.",  a2);
    }
    if (v17 == v13)
    {
      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
      *(_BYTE *)(a3 + 24) = 0;
      *(void *)(a3 + 16) = 0LL;
      return result;
    }

    if (v10 < 0 || HIDWORD(v10) + 8 > v10) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory ou tside of the bounds set originally",  a2);
    }
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __n128 result = (uint64_t)(*(void *(**)(__int128 *__return_ptr, void, const char *))(*(void *)*v17 + 16LL))( &v20,  *v17,  a2);
    if ((_DWORD)v20)
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = v20;
      *(void *)(a3 + 16) = v21;
      return result;
    }

    __n128 result = (*(uint64_t (**)(void))(*(void *)*v17 + 24LL))(*v17);
    if ((result & 1) == 0)
    {
      if (BYTE8(v21)) {
        break;
      }
    }

    if ((unint64_t)((v10 >> 32) - 2147483640) < 0xFFFFFFFF00000000LL) {
      os_detail::panic_trapping_policy::trap( (os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the o ffset representing the current position would overflow.",  a2);
    }
    v10 += 0x800000000LL;
  }

  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void TLE::InOperation::~InOperation(TLE::InOperation *this)
{
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

{
  void *exception;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(this);
}

void TLE::InOperation::Execute(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  uint64_t v6 = 0LL;
  memset(v5, 0, sizeof(v5));
  (*(void (**)(_OWORD *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( v5,  a2,  *(void *)(a1 + 16),  *(void *)(a1 + 24));
  if (LODWORD(v5[0]) == 3 || LODWORD(v5[0]) == 4 || LODWORD(v5[0]) == 6)
  {
    der_vm_iterate_b();
    uint64_t v4 = v8;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_BYTE *)(a3 + 24) = *((_BYTE *)v4 + 24);
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = "In Operation expected the Fact to be an integer, string or data";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 63LL;
  }

  _Block_object_dispose(&v7, 8);
}

void sub_18056E03C(_Unwind_Exception *a1)
{
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 116) != 3) {
    return 1LL;
  }
  uint64_t v3 = der_vm_integer_from_context();
  uint64_t result = 1LL;
  if (v3 == *(void *)(a1 + 40))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 116) != 4) {
    return 1LL;
  }
  der_vm_string_from_context();
  int v3 = CEBuffer_cmp();
  uint64_t result = 1LL;
  if (!v3)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 116) != 6) {
    return 1LL;
  }
  der_vm_data_from_context();
  int v3 = CEBuffer_cmp();
  uint64_t result = 1LL;
  if (!v3)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

void TLE::QueryOperation::~QueryOperation(TLE::QueryOperation *this)
{
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

{
  void *exception;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(this);
}

void TLE::QueryOperation::Execute(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  uint64_t v25 = 0LL;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  (*(void (**)(__int128 *__return_ptr, uint64_t, void, void))(*(void *)a2 + 24LL))( &v23,  a2,  *(void *)(a1 + 16),  *(void *)(a1 + 24));
  if ((_DWORD)v23 == 1)
  {
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    v18[0] = 0LL;
    v18[1] = v18;
    void v18[2] = 0x6002000000LL;
    _OWORD v18[3] = __Block_byref_object_copy__5188;
    v18[4] = __Block_byref_object_dispose__5189;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    uint64_t v22 = 0LL;
    __int128 v5 = *(_OWORD *)(*((void *)&v24 + 1) + 16LL);
    __int128 v4 = *(_OWORD *)(*((void *)&v24 + 1) + 32LL);
    uint64_t v6 = *(void *)(*((void *)&v24 + 1) + 48LL);
    __int128 v19 = **((_OWORD **)&v24 + 1);
    uint64_t v22 = v6;
    __int128 v21 = v4;
    __int128 v20 = v5;
    uint64_t v10 = 0LL;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x4002000000LL;
    uint64_t v13 = __Block_byref_object_copy__5;
    uint64_t v14 = __Block_byref_object_dispose__6;
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v7 = der_vm_iterate_b();
    uint64_t v8 = v11 + 5;
    if (*((_DWORD *)v11 + 10))
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = *(_OWORD *)v8;
      *(void *)(a3 + 16) = v8[2];
    }

    else if (v7 == *MEMORY[0x1896135D8])
    {
      char is_valid = der_vm_context_is_valid();
      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      *(_BYTE *)(a3 + 24) = is_valid;
    }

    else
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(void *)a3 = 0LL;
      *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 64), 8) = "Attempted to execute a non-iterable query";
      *(_DWORD *)a3 = 6;
      *(void *)(a3 + 16) = 41LL;
    }

    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(v18, 8);
  }

  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 64), 8) = "Query Operation expected the Fact to be a CoreEntitlements dictionary";
    *(_DWORD *)a3 = 3;
    *(void *)(a3 + 16) = 69LL;
  }

void sub_18056E500( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

__n128 __Block_byref_object_copy__5188(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  __int128 v4 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZN3TLE14QueryOperation7ExecuteERNS_12EncyclopediaE_block_invoke(uint64_t a1)
{
  unint64_t v2 = der_vm_integer_from_context() & 0xBFFFFFFFFFFFFFFFLL;
  **(void **)(a1 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = v2;
  if (v2 > 0xB) {
    goto LABEL_12;
  }
  if (((1LL << v2) & 0x35A) == 0)
  {
    if (((1LL << v2) & 0xC80) != 0)
    {
      *(void *)(*(void *)(a1 + 48) + 8LL) = der_vm_integer_from_context();
      goto LABEL_8;
    }

    if (v2 == 5)
    {
      *(void *)(*(void *)(a1 + 48) + 8LL) = der_vm_BOOL_from_context();
      goto LABEL_8;
    }

void TLE::OptionalOperation::~OptionalOperation(TLE::OptionalOperation *this)
{
  *(void *)this = off_189668488;
  unint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *((void *)this + 4) = 0LL;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    uint64_t v5 = __cxa_allocate_exception(8uLL);
    void *v5 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v5, MEMORY[0x1896146E0], 0LL);
  }

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *exception;
  *(void *)this = off_189668488;
  unint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1896146E0], 0LL);
    }

    uint64_t v4 = v3 - 1;
    v2[1] = v4;
    if (!v4) {
      (*(void (**)(void *))(*v2 + 8LL))(v2);
    }
  }

  *((void *)this + 4) = 0LL;
  *(void *)this = off_1896684D0;
  if (*((void *)this + 1))
  {
    uint64_t v5 = __cxa_allocate_exception(8uLL);
    void *v5 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v5, MEMORY[0x1896146E0], 0LL);
  }

  operator delete(this);
}

double TLE::OptionalOperation::Execute@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  (*(void (**)(__int128 *__return_ptr))(**(void **)(a1 + 32) + 16LL))(&v7);
  if ((_DWORD)v7)
  {
    if ((_DWORD)v7 != 5 && (_DWORD)v7 != 1)
    {
      *(_BYTE *)(a2 + 24) = 0;
      double result = *(double *)&v7;
      *(_OWORD *)a2 = v7;
      *(void *)(a2 + 16) = v8;
      return result;
    }

    char v6 = 1;
    *(_BYTE *)(a1 + 40) = 1;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    *(void *)a2 = 0LL;
  }

  else
  {
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    char v6 = BYTE8(v8);
  }

  *(_BYTE *)(a2 + 24) = v6;
  return result;
}

uint64_t TLE::OptionalOperation::shouldIgnore(TLE::OptionalOperation *this)
{
  return *((unsigned __int8 *)this + 40);
}

double SecCmsSignedDataCreate(uint64_t a1)
{
  uint64_t v2 = PORT_ArenaAlloc(*(void *)(a1 + 120), 0xB8uLL);
  if (v2)
  {
    double result = 0.0;
    *(void *)(v2 + 176) = 0LL;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
    *(_OWORD *)(v2 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)(v2 + 80) = 0u;
    *(_OWORD *)(v2 + 96) = 0u;
    *(_OWORD *)(v2 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *(void *)(v2 + 24) = a1;
  }

  return result;
}

void SecCmsSignedDataDestroy(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[22];
    if (v2)
    {
      a1[22] = 0LL;
      CFRelease(v2);
    }

    uint64_t v3 = (void *)a1[20];
    if (v3)
    {
      uint64_t v4 = (void *)*v3;
      if (*v3)
      {
        uint64_t v5 = v3 + 1;
        do
        {
          char v6 = (const void *)v4[17];
          if (v6) {
            CFRelease(v6);
          }
          __int128 v7 = (const void *)v4[18];
          if (v7)
          {
            v4[18] = 0LL;
            CFRelease(v7);
          }

          __int128 v8 = (const void *)v4[23];
          if (v8)
          {
            v4[23] = 0LL;
            CFRelease(v8);
          }

          __int128 v9 = (const void *)v4[24];
          if (v9)
          {
            v4[24] = 0LL;
            CFRelease(v9);
          }

          __int128 v10 = (void *)*v5++;
          uint64_t v4 = v10;
        }

        while (v10);
      }
    }

    SecCmsContentInfoDestroy(a1);
  }

uint64_t SecCmsSignedDataEncodeBeforeStart(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2 && (uint64_t v3 = *(void **)(a1 + 168)) != 0LL)
  {
    if (*v2)
    {
      uint64_t v4 = v2 + 1;
      while (1)
      {
        BOOL v5 = *v3 != 0LL;
        if (!*v3) {
          break;
        }
        uint64_t v6 = *v4++;
        ++v3;
        if (!v6) {
          goto LABEL_7;
        }
      }
    }

    else
    {
LABEL_7:
      BOOL v5 = 1;
    }
  }

  else
  {
    BOOL v5 = 0;
  }

  uint64_t v7 = *(void *)(*(void *)(a1 + 24) + 120LL);
  uint64_t OID = *(void *)(a1 + 32);
  if (OID || (uint64_t OID = SECOID_FindOID(a1), (*(void *)(a1 + 32) = OID) != 0LL))
  {
    if (*(_DWORD *)(OID + 16) == 25) {
      unsigned int v9 = 1;
    }
    else {
      unsigned int v9 = 3;
    }
  }

  else
  {
    unsigned int v9 = 3;
  }

  for (uint64_t i = 0LL; ; ++i)
  {
    __int128 v11 = *(uint64_t **)(a1 + 160);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        uint64_t v12 = 0LL;
        while (v11[++v12])
          ;
      }
    }

    else
    {
      LODWORD(v12) = 0;
    }

    uint64_t v14 = (uint64_t *)v11[i];
    uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
    int v15 = SEC_ASN1DecodeInteger(v14, &v22);
    if ((_DWORD)v22 != 1 || v15 != 0) {
      unsigned int v9 = 3;
    }
    uint64_t v17 = SECOID_FindOID((uint64_t)(v14 + 4));
    if (v17) {
      unsigned int v18 = *(_DWORD *)(v17 + 16);
    }
    else {
      unsigned int v18 = 0;
    }
    int IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), v18);
    BOOL v20 = IndexByAlgTag < 0 && v5;
  }

  if (!SEC_ASN1EncodeInteger(v7, (void *)(a1 + 120), v9)) {
    return 0xFFFFFFFFLL;
  }
  if (SecCmsArraySortByDER( *(int8x16_t **)(a1 + 136),  (uint64_t)&SECOID_AlgorithmIDTemplate,  *(int8x16_t **)(a1 + 168))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0LL;
  }
}

uint64_t SecCmsSignedDataAddDigest(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = PORT_ArenaAlloc(a1, 0x20uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v8;
  *(_OWORD *)uint64_t v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  uint64_t result = SecCmsArrayAdd(a1, (char **)(a2 + 168), a4);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsSignedDataSignerInfoCount(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 160);
  if (!v1 || !*v1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v3 = v1 + 1;
  while (v3[result++])
    ;
  return result;
}

uint64_t SecCmsSignedDataGetSignerInfo(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(a1 + 160) + 8LL * a2);
}

uint64_t SecCmsSignedDataEncodeAfterData(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 120LL);
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3)
  {
    *(void *)&__int128 v71 = 0LL;
    Size = 0LL;
    if (SecCmsDigestContextFinishMultiple(v3, &Size, &v71)
      || Size && (void)v71 && SecCmsSignedDataSetDigests((void *)a1, Size, v71))
    {
      return 0xFFFFFFFFLL;
    }

    SecCmsDigestContextCancel(*(void *)(a1 + 104));
    *(void *)(a1 + 104) = 0LL;
  }

  uint64_t v4 = 0LL;
  CFIndex v5 = 0LL;
  uint64_t v6 = *(int8x16_t **)(a1 + 160);
  uint64_t v65 = v6;
  uint64_t v66 = v2;
  if (!v6) {
    goto LABEL_12;
  }
LABEL_8:
  uint64_t v7 = v6->i64[0];
  if (v6->i64[0])
  {
    uint64_t v7 = 0LL;
    while (v6->i64[++v7])
      ;
  }

  while (v4 < (int)v7)
  {
    uint64_t v9 = v6->i64[v4];
    uint64_t OID = SECOID_FindOID(v9 + 32);
    if (OID) {
      unsigned int v11 = *(_DWORD *)(OID + 16);
    }
    else {
      unsigned int v11 = 0;
    }
    unsigned int IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), v11);
    if ((IndexByAlgTag & 0x80000000) != 0
      || (uint64_t v13 = *(void *)(a1 + 168)) == 0
      || (v14 = IndexByAlgTag, (uint64_t v15 = *(void *)(v13 + 8LL * IndexByAlgTag)) == 0))
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v71);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE08500000000LL;
      }
      return 0xFFFFFFFFLL;
    }

    uint64_t v16 = *(unint64_t **)(a1 + 32);
    if (!v16)
    {
      uint64_t v17 = SECOID_FindOID(a1);
      *(void *)(a1 + 32) = v17;
      if (!v17) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v16 = (unint64_t *)v17;
      uint64_t v15 = *(void *)(*(void *)(a1 + 168) + 8LL * v14);
    }

    Size = 0LL;
    uint64_t v74 = 0LL;
    uint64_t v18 = *(void *)(*(void *)(*(void *)(v9 + 128) + 24LL) + 120LL);
    *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v71 = v19;
    __int128 v72 = v19;
    int v20 = *(_DWORD *)(v9 + 16);
    if (v20 == 1)
    {
      __int128 v21 = *(const void **)(v9 + 168);
      __int128 v29 = *(const void **)(v9 + 176);
      *(void *)(v9 + 16_Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
      if (v29)
      {
        *(void *)(v9 + 176) = 0LL;
        CFRelease(v29);
      }

      __int128 v28 = 0LL;
    }

    else
    {
      if (v20)
      {
        unint64_t v45 = PR_getThreadErrInfo(1, (int *)&v69);
        if (v45) {
          *unint64_t v45 = 0xFFFFE08600000000LL;
        }
        goto LABEL_117;
      }

      __int128 v21 = *(const void **)(v9 + 168);
      *(void *)(v9 + 16_Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
      uint64_t v22 = *(void **)(v9 + 136);
      uint64_t v24 = v22[27];
      uint64_t v23 = v22[28];
      __int128 v27 = v22 + 29;
      uint64_t v25 = v22[29];
      uint64_t v26 = v27[1];
      *(void *)&__int128 v71 = v23;
      *((void *)&v71 + 1) = v24;
      *(void *)&__int128 v72 = v26;
      *((void *)&v72 + 1) = v25;
      __int128 v28 = &v71;
    }

    uint64_t v30 = SECOID_FindOID(v9 + 32);
    uint64_t v67 = v4;
    CFIndex v68 = v5;
    if (v30)
    {
      int v31 = *(_DWORD *)(v30 + 16);
      else {
        signed int v33 = 0;
      }
      if (v31 == 3)
      {
        unint64_t v43 = PR_getThreadErrInfo(1, (int *)&v69);
        if (v43)
        {
          unint64_t v44 = 0xFFFFE00600000000LL;
          goto LABEL_104;
        }

        goto LABEL_118;
      }
    }

    else if (v28 && *((void *)v28 + 1) && (uint64_t v34 = SECOID_FindOID((uint64_t)v28)) != 0)
    {
      int v31 = 0;
      signed int v33 = *(_DWORD *)(v34 + 16);
    }

    else
    {
      signed int v33 = 0;
      int v31 = 0;
    }

    if (*(void *)(v9 + 64))
    {
      if (SecCmsAttributeArraySetAttr(v18, (uint64_t **)(v9 + 64), 0x22u, (unint64_t *)v15)
        || SecCmsAttributeArraySetAttr(v18, (uint64_t **)(v9 + 64), 0x21u, v16))
      {
        goto LABEL_118;
      }

      __int128 v35 = PORT_NewArena(1024);
      if (!v35)
      {
        unint64_t v43 = PR_getThreadErrInfo(1, &v75);
        if (v43)
        {
          unint64_t v44 = 0xFFFFE01300000000LL;
LABEL_104:
          void *v43 = v44;
        }

LABEL_118:
        __int128 v36 = 0LL;
LABEL_119:
        if (Size)
        {
          if (v74) {
            free(v74);
          }
          uint64_t v74 = 0LL;
LABEL_123:
          Size = 0LL;
        }

        if (v21) {
          CFRelease(v21);
        }
        if (v36) {
          PORT_FreeArena(v36, 0);
        }
        return 0xFFFFFFFFLL;
      }

      __int128 v36 = v35;
      CFIndex v69 = 0LL;
      uint64_t v70 = 0LL;
      Size = (unint64_t **)SecKeyGetSize((uint64_t)v21, 1);
      __int128 v37 = PORT_ZAlloc((unint64_t)Size);
      uint64_t v74 = v37;
      if (!v37)
      {
        Size = 0LL;
        goto LABEL_119;
      }

      if (SecKeyDigestAndSign( (uint64_t)v21,  (const SecAsn1Oid *)(v9 + 32),  v70,  v69,  (UInt8 *)v37,  (CFIndex *)&Size))
      {
        if (v74) {
          free(v74);
        }
        Size = 0LL;
        PORT_FreeArena(v36, 0);
        if (!v21) {
          goto LABEL_118;
        }
LABEL_116:
        CFRelease(v21);
LABEL_117:
        __int128 v21 = 0LL;
        goto LABEL_118;
      }

      PORT_FreeArena(v36, 0);
    }

    else
    {
      Size = (unint64_t **)SecKeyGetSize((uint64_t)v21, 1);
      __int128 v38 = PORT_ZAlloc((unint64_t)Size);
      uint64_t v74 = v38;
      if (!v38)
      {
        __int128 v36 = 0LL;
        goto LABEL_123;
      }

      if (SecKeySignDigest( (uint64_t)v21,  (const SecAsn1Oid *)(v9 + 32),  *(const UInt8 **)(v15 + 8),  *(void *)v15,  (UInt8 *)v38,  (CFIndex *)&Size))
      {
        if (v74) {
          free(v74);
        }
        Size = 0LL;
        if (v21) {
          goto LABEL_116;
        }
        return 0xFFFFFFFFLL;
      }
    }

    if (v21) {
      CFRelease(v21);
    }
    if (v74) {
      free(v74);
    }
    Size = 0LL;
    uint64_t v74 = 0LL;
    if (v33 > 123)
    {
      if (v33 == 124)
      {
LABEL_72:
        if (v31 == 4) {
          signed int v33 = 125;
        }
        else {
          signed int v33 = 0;
        }
        goto LABEL_75;
      }

      if (v33 != 202) {
        goto LABEL_75;
      }
      if (v31 > 192)
      {
        if (v31 != 193)
        {
          if (v31 == 194)
          {
            signed int v33 = 213;
            goto LABEL_75;
          }

          goto LABEL_87;
        }

        signed int v33 = 212;
      }

      else
      {
        if (v31 != 4)
        {
          if (v31 == 192)
          {
            signed int v33 = 211;
            goto LABEL_75;
          }

          goto LABEL_87;
        }

        signed int v33 = 203;
      }
    }

    else
    {
      if (v33 != 16) {
        goto LABEL_75;
      }
      if (v31 <= 191)
      {
        if (v31 != 1)
        {
          if (v31 == 4)
          {
            signed int v33 = 20;
            goto LABEL_75;
          }

          goto LABEL_87;
        }

        signed int v33 = 17;
      }

      else
      {
        switch(v31)
        {
          case 192:
            signed int v33 = 195;
            break;
          case 193:
            signed int v33 = 196;
            break;
          case 194:
            signed int v33 = 197;
            break;
          default:
LABEL_87:
            signed int v33 = 0;
            break;
        }
      }
    }

uint64_t SecCmsSignedDataSetDigests(void *a1, unint64_t **a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = (void *)a1[17];
    if (v4)
    {
      uint64_t v5 = a1[3];
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 120);
        if (v6)
        {
          uint64_t v9 = (void *)a1[21];
          if (v9)
          {
            if (*v9) {
              return 0LL;
            }
            goto LABEL_23;
          }

          if (*v4)
          {
            uint64_t v13 = v4 + 1;
            unsigned int v14 = -1;
            do
            {
              unsigned int v15 = v14;
              uint64_t v16 = *v13++;
              ++v14;
            }

            while (v16);
            if (v14 > 0xFFFFFFC)
            {
LABEL_53:
              int v10 = -8173;
              goto LABEL_9;
            }

            unsigned int v17 = v15 + 2;
          }

          else
          {
            unsigned int v17 = 0;
          }

          unint64_t v18 = 8LL * (v17 + 1);
          if (v18 <= 1) {
            unint64_t v19 = 1LL;
          }
          else {
            unint64_t v19 = v18;
          }
          int v20 = (void *)PORT_ArenaAlloc(v6, v19);
          if (v20)
          {
            __int128 v21 = v20;
            bzero(v20, v19);
            a1[21] = v21;
            uint64_t v4 = (void *)a1[17];
LABEL_23:
            uint64_t v22 = (unint64_t *)*v4;
            if (*v4)
            {
              uint64_t v23 = 0LL;
              while (a2)
              {
                uint64_t v24 = *a2;
                if (!*a2) {
                  break;
                }
                uint64_t v37 = v23;
                uint64_t v25 = 0LL;
                unint64_t v27 = *v22;
                uint64_t v26 = (const void *)v22[1];
                while (1)
                {
                  unint64_t v28 = *v24;
                  size_t v29 = *v24 >= v27 ? v27 : *v24;
                  if (!memcmp((const void *)v24[1], v26, v29) && v28 == v27)
                  {
                    unint64_t v32 = v24[2];
                    int v31 = (const void *)v24[3];
                    unint64_t v33 = v22[2];
                    size_t v34 = v32 >= v33 ? v22[2] : v32;
                  }

                  uint64_t v24 = a2[++v25];
                  if (!v24) {
                    goto LABEL_51;
                  }
                }

                int v10 = -8059;
                if ((v25 & 0x80000000) != 0) {
                  goto LABEL_9;
                }
                __int128 v36 = SECITEM_AllocItem(*(void *)(a1[3] + 120LL), 0LL, 0LL);
                *(void *)(a1[21] + 8 * v37) = v36;
                if (!v36) {
                  goto LABEL_53;
                }
                uint64_t result = SECITEM_CopyItem( *(void *)(a1[3] + 120LL),  *(unint64_t **)(a1[21] + 8 * v37),  *(void *)(a3 + 8LL * v25));
                if ((_DWORD)result) {
                  goto LABEL_53;
                }
                uint64_t v23 = v37 + 1;
                uint64_t v22 = *(unint64_t **)(a1[17] + 8 * (v37 + 1));
                if (!v22) {
                  return result;
                }
              }

uint64_t SecCmsSignedDataDecodeAfterData(void *a1)
{
  uint64_t result = a1[13];
  if (result)
  {
    uint64_t v3 = (void *)a1[2];
    if (v3 && *v3)
    {
      uint64_t v4 = 0LL;
      uint64_t v5 = 0LL;
      if (SecCmsDigestContextFinishMultiple(result, &v4, &v5)
        || SecCmsSignedDataSetDigests(a1, v4, v5))
      {
        return 0xFFFFFFFFLL;
      }

      uint64_t result = a1[13];
    }

    SecCmsDigestContextCancel(result);
    uint64_t result = 0LL;
    a1[13] = 0LL;
  }

  return result;
}

uint64_t SecCmsSignedDataGetSignerInfos(uint64_t a1)
{
  return *(void *)(a1 + 160);
}

uint64_t SecCmsSignedDataGetDigestAlgs(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

uint64_t SecCmsSignedDataGetCertificateList(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t SecCmsSignedDataImportCerts()
{
  return 4294967292LL;
}

uint64_t SecCmsSignedDataVerifySignerInfo(uint64_t a1, int a2, uint64_t a3, const void *a4, SecTrustRef *a5)
{
  return SecCmsSignedDataVerifySignerInfo_internal(a1, a2, a4, a5);
}

uint64_t SecCmsSignedDataVerifySignerInfo_internal(uint64_t a1, int a2, const void *a3, SecTrustRef *a4)
{
  if (a1)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 160);
    if (v5)
    {
      uint64_t v8 = *v5;
      if (*v5)
      {
        uint64_t v8 = 0LL;
        while (v5[++v8])
          ;
      }

      if ((int)v8 > a2)
      {
        uint64_t v10 = v5[a2];
        uint64_t OID = SECOID_FindOID(v10 + 32);
        if (!OID) {
          return 4294899481LL;
        }
        uint64_t v12 = OID;
        if (!*(void *)(a1 + 168))
        {
          uint64_t started = SecCmsDigestContextStartMultiple(*(uint64_t **)(a1 + 136));
          SecCmsSignedDataSetDigestContext((void *)a1, started);
          SecCmsDigestContextCancel(started);
          if (!*(void *)(a1 + 168)) {
            return 4294941980LL;
          }
        }

        unsigned int IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), *(_DWORD *)(v12 + 16));
        if ((IndexByAlgTag & 0x80000000) != 0) {
          return 4294941980LL;
        }
        uint64_t v15 = *(void *)(*(void *)(a1 + 168) + 8LL * IndexByAlgTag);
        if (!v15) {
          return 4294941980LL;
        }
        uint64_t v16 = *(void *)(a1 + 32);
        if (!v16)
        {
          uint64_t v16 = SECOID_FindOID(a1);
          *(void *)(a1 + 32) = v16;
        }

        CFIndex v31 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v32 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
        if (!v10) {
          return 0xFFFFFFFFLL;
        }
        SigningCert_internal = (__SecCertificate *)SecCmsSignerInfoGetSigningCert_internal(v10);
        if (!SigningCert_internal)
        {
          int v25 = 4;
          goto LABEL_46;
        }

        SecKeyRef v18 = SecCertificateCopyKey(SigningCert_internal);
        if (!v18)
        {
          int v25 = 0;
          goto LABEL_46;
        }

        SecKeyRef v19 = v18;
        int v20 = *(uint64_t **)(v10 + 64);
        if (!v20 || !*v20)
        {
          CFIndex v28 = *(void *)(v10 + 104);
          if (v28)
          {
            if (!SecKeyVerifyDigest( (uint64_t)v19,  (const SecAsn1Oid *)(v10 + 32),  *(const UInt8 **)(v15 + 8),  *(void *)v15,  *(const UInt8 **)(v10 + 112),  v28)) {
              goto LABEL_30;
            }
LABEL_38:
            if (PORT_GetError() == -8182)
            {
              ThreadErrInfo = PR_getThreadErrInfo(1, &v33);
              if (ThreadErrInfo) {
                void *ThreadErrInfo = 0xFFFFE02F00000000LL;
              }
            }

            CFRelease(v19);
            *(_DWORD *)(v10 + 160) = 2;
            return 0xFFFFFFFFLL;
          }

          int v25 = 0;
          goto LABEL_45;
        }

        if (v16)
        {
          uint64_t AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(v20, 0x21u, 1);
          int v20 = *(uint64_t **)(v10 + 64);
        }

        uint64_t v22 = SecCmsAttributeArrayFindAttrByOidTag(v20, 0x22u, 1);
        if (v22)
        {
          if (SecCmsAttributeCompareValue(v22, v15))
          {
            uint64_t v23 = PORT_NewArena(1024);
            if (v23)
            {
              uint64_t v24 = v23;
              CFIndex v31 = 0LL;
              unint64_t v32 = 0LL;
              int v25 = 9;
              if (SEC_ASN1EncodeItem((uint64_t)v23, &v31, v10 + 64, (uint64_t)&nss_cms_set_of_attribute_template)
                && v32
                && v31)
              {
                int v26 = SecKeyDigestAndVerify( (uint64_t)v19,  (const SecAsn1Oid *)(v10 + 32),  v32,  v31,  *(const UInt8 **)(v10 + 112),  *(void *)(v10 + 104));
                PORT_FreeArena(v24, 0);
                if (!v26)
                {
LABEL_30:
                  CFRelease(v19);
                  *(_DWORD *)(v10 + 160) = 1;
                  return SecCmsSignerInfoVerifyCertificate(v10, a3, a4);
                }

                goto LABEL_38;
              }
            }

            else
            {
              int v25 = 9;
            }
          }

          else
          {
            int v25 = 3;
          }

          goto LABEL_45;
        }

uint64_t SecCmsSignedDataSetDigestContext(void *a1, uint64_t a2)
{
  uint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = (unint64_t **)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = SecCmsSignedDataSetDigests(a1, v5, v4);
  if ((_DWORD)result) {
    return PORT_GetError();
  }
  return result;
}

uint64_t SecCmsSignedDataVerifyCertsOnly(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a1 && a2 && (uint64_t v3 = *(uint64_t **)(a1 + 144)) != 0LL)
  {
    uint64_t v4 = *v3;
    if (*v3)
    {
      LODWORD(v6) = 0;
      uint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v8 = v3 + 1;
      do
      {
        if ((*(void *)v4 & 0x8000000000000000LL) != 0
          || (CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL,
              (CFTypeRef cf = SecCertificateCreateWithBytes(0LL, *(const void **)(v4 + 8), *(void *)v4)) == 0LL))
        {
          uint64_t v6 = 0xFFFFFFFFLL;
        }

        else
        {
          CFArrayRef v9 = CFArrayCreate(v7, &cf, 1LL, 0LL);
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          int v11 = CERT_VerifyCert(v9, a3, 0LL, Current);
          if (v9) {
            CFRelease(v9);
          }
          uint64_t v6 = v11 | v6;
          CFTypeRef v12 = cf;
          if (cf)
          {
            CFTypeRef cf = 0LL;
            CFRelease(v12);
          }
        }

        uint64_t v13 = *v8++;
        uint64_t v4 = v13;
      }

      while (v13);
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v17);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00500000000LL;
    }
    return 0xFFFFFFFFLL;
  }

  return v6;
}

uint64_t SecCmsSignedDataVerifyCertsOnlyMessage()
{
  ThreadErrInfo = PR_getThreadErrInfo(1, &v2);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0xFFFFE00500000000LL;
  }
  return 0xFFFFFFFFLL;
}

BOOL SecCmsSignedDataHasDigests(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0LL;
}

uint64_t SecCmsSignedDataAddCertList(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 176))
  {
    v6.size_t length = CFArrayGetCount(theArray);
    v6.location = 0LL;
    CFArrayAppendArray(*(CFMutableArrayRef *)(a1 + 176), theArray, v6);
    return 0LL;
  }

  else
  {
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(0LL, 0LL, theArray);
    uint64_t result = 0LL;
    *(void *)(a1 + 176) = MutableCopy;
  }

  return result;
}

uint64_t SecCmsSignedDataAddCertChain(uint64_t a1, void *a2)
{
  uint64_t v3 = CERT_CertChainFromCert(a2, 0, 0);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = v3;
  uint64_t v5 = SecCmsSignedDataAddCertList(a1, v3);
  CFRelease(v4);
  return v5;
}

uint64_t SecCmsSignedDataAddCertificate(uint64_t a1, void *value)
{
  if (!value) {
    return 0xFFFFFFFFLL;
  }
  CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 176);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    *(void *)(a1 + 176) = Mutable;
  }

  CFArrayAppendValue(Mutable, value);
  return 0LL;
}

BOOL SecCmsSignedDataContainsCertsOrCrls(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 144);
  BOOL result = 1;
  if (!v1 || !*v1)
  {
    int v2 = *(void **)(a1 + 152);
    if (!v2 || !*v2) {
      return 0;
    }
  }

  return result;
}

uint64_t SecCmsSignedDataSetDigestValue(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = *(void *)(v5 + 120);
  if (a3)
  {
    uint64_t v8 = (unint64_t *)PORT_ArenaAlloc(*(void *)(v5 + 120), 0x10uLL);
    uint64_t v9 = (uint64_t)v8;
    if (v8)
    {
      unint64_t *v8 = 0LL;
      v8[1] = 0LL;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if (!a1[21])
  {
    uint64_t v10 = (void *)a1[17];
    if (v10)
    {
      if (*v10)
      {
        int v11 = v10 + 1;
        unsigned int v12 = -1;
        do
        {
          unsigned int v13 = v12;
          uint64_t v14 = *v11++;
          ++v12;
        }

        while (v14);
        if (v12 >= 0xFFFFFFD)
        {
          uint64_t v15 = (int *)&v25;
          goto LABEL_27;
        }

        LODWORD(v10) = v13 + 2;
      }

      else
      {
        LODWORD(v10) = 0;
      }
    }

    unint64_t v16 = 8LL * ((_DWORD)v10 + 1);
    if (v16 <= 1) {
      unint64_t v17 = 1LL;
    }
    else {
      unint64_t v17 = v16;
    }
    SecKeyRef v18 = (void *)PORT_ArenaAlloc(*(void *)(a1[3] + 120LL), v17);
    if (!v18)
    {
      a1[21] = 0LL;
      uint64_t v15 = (int *)&v26;
LABEL_27:
      ThreadErrInfo = PR_getThreadErrInfo(1, v15);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE01300000000LL;
      }
      return 0xFFFFFFFFLL;
    }

    SecKeyRef v19 = v18;
    bzero(v18, v17);
    a1[21] = v19;
  }

  int v20 = (size_t **)a1[17];
  if (v20)
  {
    unsigned int IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(v20, a2);
    if ((IndexByAlgTag & 0x80000000) == 0)
    {
      unsigned int v22 = IndexByAlgTag;
      uint64_t result = 0LL;
      *(void *)(a1[21] + 8LL * v22) = v9;
      return result;
    }
  }

  uint64_t result = SecCmsSignedDataAddDigest(v6, (uint64_t)a1, a2, v9);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t *SecCmsSignedDataCreateCertsOnly(uint64_t a1, void *a2, int a3)
{
  uint64_t v6 = PORT_ArenaAlloc(*(void *)(a1 + 120), 0xB8uLL);
  uint64_t v7 = (uint64_t *)v6;
  if (!v6) {
    return v7;
  }
  *(void *)(v6 + 176) = 0LL;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
  *(_OWORD *)(v6 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *(void *)(v6 + 24) = a1;
  if (!a3)
  {
LABEL_7:
    SecCmsSignedDataDestroy(v7);
    return 0LL;
  }

uint64_t InitOIDHashOnce()
{
  unsigned int v0 = &__simulate_crash_counter;
  oidhash = (uint64_t)PL_NewHashTable((uint64_t)SECITEM_Hash, (uint64_t)SECITEM_HashCompare);
  uint64_t v1 = PL_NewHashTable((uint64_t)secoid_HashNumber, (uint64_t)PL_CompareValues);
  oidmechhash = (uint64_t)v1;
  if (oidhash) {
    BOOL v2 = v1 == 0LL;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    goto LABEL_23;
  }
  for (uint64_t i = 0LL; i != 217; ++i)
  {
    uint64_t v4 = &oids[40 * i];
    uint64_t v5 = *((void *)v0 + 57);
    int v6 = (*(uint64_t (**)(char *))(v5 + 16))(v4);
    uint64_t v7 = PL_HashTableRawLookup(v5, v6, (uint64_t)v4);
    uint64_t v8 = *v7;
    if (*v7)
    {
      uint64_t result = (*(uint64_t (**)(void, char *))(v5 + 32))(*(void *)(v8 + 24), &oids[40 * i]);
      if (!(_DWORD)result)
      {
        if (*(void *)(v8 + 24)) {
          uint64_t result = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(v5 + 40) + 24LL))( *(void *)(v5 + 48),  v8,  0LL);
        }
        *(void *)(v8 + 24) = v4;
      }

      continue;
    }

    uint64_t v10 = v7;
    int v11 = *(_DWORD *)(v5 + 12);
    uint64_t v12 = (1 << -(char)v11);
    if (*(_DWORD *)(v5 + 8) >= v12 - (v12 >> 3))
    {
      unsigned int v13 = v0;
      uint64_t v14 = *(void *)v5;
      size_t v15 = 8LL * (2 << (32 - v11));
      unint64_t v16 = (void *)(**(uint64_t (***)(void, size_t))(v5 + 40))(*(void *)(v5 + 48), v15);
      *(void *)uint64_t v5 = v16;
      if (v16)
      {
        bzero(v16, v15);
        uint64_t v17 = 0LL;
        --*(_DWORD *)(v5 + 12);
        do
        {
          uint64_t v18 = *(void *)(v14 + 8 * v17);
          if (v18)
          {
            do
            {
              uint64_t v19 = *(void *)v18;
              int v20 = PL_HashTableRawLookup(v5, *(_DWORD *)(v18 + 8), *(void *)(v18 + 16));
              *(void *)uint64_t v18 = 0LL;
              *int v20 = v18;
              uint64_t v18 = v19;
            }

            while (v19);
          }

          ++v17;
        }

        while (v17 != v12);
        (*(void (**)(void, uint64_t))(*(void *)(v5 + 40) + 8LL))(*(void *)(v5 + 48), v14);
        uint64_t v10 = PL_HashTableRawLookup(v5, v6, (uint64_t)v4);
        unsigned int v0 = v13;
        goto LABEL_18;
      }

      *(void *)uint64_t v5 = v14;
LABEL_23:
      PORT_SetError(-8191);
      abort();
    }

uint64_t SECOID_FindOID(uint64_t a1)
{
  uint64_t v2 = oidhash;
  int v3 = (*(uint64_t (**)(uint64_t))(oidhash + 16))(a1);
  uint64_t v4 = *(void *)v2 + 8LL * ((-1640531527 * v3) >> *(_DWORD *)(v2 + 12));
  uint64_t v5 = *(void *)v4;
  if (!*(void *)v4) {
    goto LABEL_6;
  }
  int v6 = v3;
  while (1)
  {
    uint64_t v7 = (uint64_t *)v5;
    if (*(_DWORD *)(v5 + 8) == v6)
    {
    }

    uint64_t v5 = *v7;
    uint64_t v4 = (uint64_t)v7;
    if (!*v7) {
      goto LABEL_6;
    }
  }

  if (!*(void *)v4 || (uint64_t result = *(void *)(*(void *)v4 + 24LL)) == 0)
  {
LABEL_6:
    ThreadErrInfo = PR_getThreadErrInfo(1, &v10);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00100000000LL;
    }
    return 0LL;
  }

  return result;
}

uint64_t SecCmsEncryptedDataCreate(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = PORT_ArenaAlloc(*(void *)(a1 + 120), 0x90uLL);
  if (result)
  {
    uint64_t v7 = result;
    *(_OWORD *)(result + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
    *(_OWORD *)(result + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(void *)(result + 24) = a1;
    if (a2 <= 0xA && ((1 << a2) & 0x4A0) != 0) {
      goto LABEL_7;
    }
    uint64_t result = 0LL;
    if (a2 - 184 <= 4 && ((1 << (a2 + 72)) & 0x15) != 0)
    {
LABEL_7:
      int v8 = SECOID_SetAlgorithmID(*(void *)(a1 + 120), (unint64_t *)(v7 + 40), a2, 0LL);
      uint64_t result = 0LL;
      if (!v8)
      {
        *(_DWORD *)(v7 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = a3;
        return v7;
      }
    }
  }

  return result;
}

void SecCmsEncryptedDataDestroy(uint64_t *a1)
{
  if (a1) {
    SecCmsContentInfoDestroy(a1);
  }
}

uint64_t SecCmsEncryptedDataEncodeBeforeStart(void *a1)
{
  uint64_t v2 = (void *)a1[17];
  if (v2) {
    unint64_t v3 = 2LL * (*v2 != 0LL);
  }
  else {
    unint64_t v3 = 0LL;
  }
  if (!SEC_ASN1EncodeInteger(*(void *)(a1[3] + 120LL), a1 + 15, v3)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a1[3];
  uint64_t v5 = *(uint64_t (**)(void, void *))(v4 + 144);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  int v6 = (const void *)v5(*(void *)(v4 + 152), a1 + 5);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  SecCmsContentInfoSetBulkKey((uint64_t)a1, v6);
  CFRelease(v7);
  return 0LL;
}

void SecCmsEncryptedDataEncodeAfterData(uint64_t a1)
{
  uint64_t v1 = *(CCCryptorRef **)(a1 + 96);
  if (v1)
  {
    CCCryptorRelease(*v1);
    free(v1);
    *(void *)(a1 + 96) = 0LL;
  }

uint64_t SecCmsArrayAdd(uint64_t a1, char **a2, uint64_t a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *a2;
  if (!v5)
  {
    uint64_t v9 = PORT_ArenaAlloc(a1, 0x10uLL);
    LODWORD(v6) = 0;
    if (!v9) {
      return 0xFFFFFFFFLL;
    }
LABEL_10:
    uint64_t result = 0LL;
    *(void *)(v9 + 8LL * v6) = a3;
    *(void *)(v9 + 8LL * (v6 + 1)) = 0LL;
    *a2 = (char *)v9;
    return result;
  }

  if (*(void *)v5)
  {
    uint64_t v6 = 0LL;
    while (*(void *)&v5[8 * v6++ + 8])
      ;
  }

  else
  {
    LODWORD(v6) = 0;
  }

  uint64_t v9 = (uint64_t)PORT_ArenaGrow(a1, v5, (8 * v6 + 8), (8 * v6 + 16));
  if (v9) {
    goto LABEL_10;
  }
  return 0xFFFFFFFFLL;
}

void *SecCmsArraySort(void *result, int8x16_t *a2, int8x16_t *a3)
{
  uint64_t v5 = result;
  if (result)
  {
    uint64_t v6 = *result;
    if (*result)
    {
      uint64_t v6 = 0LL;
      while (result[++v6])
        ;
    }

    if (!a2)
    {
LABEL_13:
      unint64_t v21 = 0LL;
      if (!a3) {
        goto LABEL_18;
      }
      goto LABEL_14;
    }
  }

  else
  {
    LODWORD(v6) = 0;
    if (!a2) {
      goto LABEL_13;
    }
  }

  if (!a2->i64[0]) {
    goto LABEL_13;
  }
  uint64_t v8 = 0LL;
  while (a2->i64[++v8])
    ;
  unint64_t v21 = v8;
  if (!a3) {
    goto LABEL_18;
  }
LABEL_14:
  if (a3->i64[0])
  {
    uint64_t v10 = 0LL;
    while (a3->i64[++v10])
      ;
    unint64_t v12 = v10;
    goto LABEL_19;
  }

uint64_t CERT_VerifyCert(const void *a1, const void *a2, SecTrustRef *a3, CFAbsoluteTime a4)
{
  SecTrustRef trust = 0LL;
  uint64_t v6 = SecTrustCreateWithCertificates(a1, a2, &trust);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  uint64_t v7 = CFDateCreate(0LL, a4);
  uint64_t v6 = SecTrustSetVerifyDate(trust, v7);
  if (v7) {
    CFRelease(v7);
  }
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  if (a3)
  {
    uint64_t v6 = 0LL;
    *a3 = trust;
    return v6;
  }

  int v12 = -1431655766;
  uint64_t v6 = SecTrustEvaluateInternal(trust, &v12);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  if (v12 != 4 && v12 != 1)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v14);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE01500000000LL;
    }
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_5:
    SecTrustRef v8 = trust;
    if (trust)
    {
      SecTrustRef trust = 0LL;
      CFRelease(v8);
    }

    return v6;
  }

  SecTrustRef v10 = trust;
  if (trust)
  {
    SecTrustRef trust = 0LL;
    CFRelease(v10);
  }

  return 0LL;
}

__CFDictionary *_create_mail_keychain_query(const __CFDictionary *a1)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Count = CFDictionaryGetCount(a1);
  MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(v2, Count, a1);
  CFDictionarySetValue(MutableCopy, @"sync", @"syna");
  return MutableCopy;
}

CFTypeRef CERT_FindItemInAllAvailableKeychains(const __CFDictionary *a1)
{
  CFTypeRef cf = 0LL;
  CFTypeRef result = 0LL;
  if (SecItemCopyMatching(a1, &result) != -25300) {
    return result;
  }
  uint64_t v2 = (const __CFDictionary *)_SecSecuritydCopyWhoAmI(&cf);
  CFTypeRef v3 = cf;
  if (cf) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v2 == 0LL;
  }
  if (!v4)
  {
    if (CFDictionaryGetValue(v2, @"status"))
    {
      Value = (const __CFData *)CFDictionaryGetValue(v2, @"musr");
      if (CFDictionaryGetValue(v2, @"system-keychain"))
      {
        if (Value && CFDataGetLength(Value) == 16)
        {
          BytePtr = CFDataGetBytePtr(Value);
          if (*(void *)BytePtr == 0x104B57A5353A5AA7LL && *((_DWORD *)BytePtr + 2) == -1803342146)
          {
            CFIndex Count = CFDictionaryGetCount(a1);
            MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0LL, Count + 1, a1);
            CFDictionaryAddValue(MutableCopy, @"u_SystemKeychain", (const void *)*MEMORY[0x189604DE8]);
            SecItemCopyMatching(MutableCopy, &result);
            if (MutableCopy) {
              CFRelease(MutableCopy);
            }
          }
        }
      }
    }

    goto LABEL_17;
  }

  if (v2)
  {
LABEL_17:
    CFRelease(v2);
    CFTypeRef v3 = cf;
  }

  if (v3)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v3);
  }

  return result;
}

__CFBundle *___is_apple_mail_bundle_block_invoke()
{
  CFTypeRef result = CFBundleGetMainBundle();
  if (result)
  {
    CFTypeRef result = (__CFBundle *)CFBundleGetIdentifier(result);
    if (result)
    {
      uint64_t v1 = (const __CFString *)result;
      CFTypeRef result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, @"com.apple.mail");
      if ((_DWORD)result
        || (CFTypeRef result = (__CFBundle *)CFStringHasPrefix(v1, @"com.apple.mobilemail"), (_DWORD)result))
      {
        BOOL v2 = 1;
      }

      else
      {
        CFTypeRef result = (__CFBundle *)CFStringHasPrefix(v1, @"com.apple.email");
        BOOL v2 = (_DWORD)result != 0;
      }
    }

    else
    {
      BOOL v2 = 0;
    }

    _is_apple_mail_bundle_CFTypeRef result = v2;
  }

  return result;
}

CFArrayRef CERT_CertChainFromCert(void *a1, int a2, int a3)
{
  SecTrustRef trust = 0LL;
  SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
  if (!BasicX509) {
    return 0LL;
  }
  SecPolicyRef v7 = BasicX509;
  values = a1;
  if (a1) {
    CFArrayRef v8 = CFArrayCreate(0LL, (const void **)&values, 1LL, MEMORY[0x189605228]);
  }
  else {
    CFArrayRef v8 = 0LL;
  }
  if (!SecTrustCreateWithCertificates(v8, v7, &trust))
  {
    int v22 = -1431655766;
    if (!SecTrustEvaluateInternal(trust, &v22))
    {
      int v12 = SecTrustCopyCertificateChain(trust);
      uint64_t v9 = v12;
      if (!v12) {
        goto LABEL_9;
      }
      uint64_t Count = CFArrayGetCount(v12);
      ValueAtIndex = CFArrayGetValueAtIndex(v9, Count - 1);
      if (!ValueAtIndex) {
        goto LABEL_9;
      }
      uint64_t v15 = (uint64_t)ValueAtIndex;
      BOOL IsSelfSigned = _SecCertificateIsSelfSigned(v15);
      if (IsSelfSigned)
      {
        if (a2) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = IsSelfSigned;
        }
        if (Count >= 2 && v17)
        {
          MutableCFArrayRef Copy = CFArrayCreateMutableCopy(0LL, Count, v9);
          CFArrayRemoveValueAtIndex(MutableCopy, Count - 1);
          CFRelease(v9);
          uint64_t v9 = MutableCopy;
        }

        goto LABEL_9;
      }

      values = 0LL;
      SecCertificateCopyCommonName((SecCertificateRef)a1, (CFStringRef *)&values);
      uint64_t v19 = (FILE *)*MEMORY[0x1895F89D0];
      if (values) {
        CStringPtr = CFStringGetCStringPtr((CFStringRef)values, 0x8000100u);
      }
      else {
        CStringPtr = (const char *)&unk_18065A197;
      }
      fprintf(v19, "Warning: unable to build chain to self-signed root for signer %s\n", CStringPtr);
      unint64_t v21 = values;
      if (values)
      {
        values = 0LL;
        CFRelease(v21);
      }

      if (!a3) {
        goto LABEL_9;
      }
      CFRelease(v9);
    }
  }

  uint64_t v9 = 0LL;
LABEL_9:
  SecTrustRef v10 = trust;
  if (trust)
  {
    SecTrustRef trust = 0LL;
    CFRelease(v10);
  }

  CFRelease(v7);
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

void *CERT_GetCertIssuerAndSN(uint64_t a1, const __CFData *a2)
{
  BOOL v2 = a2;
  BOOL v4 = SecDERItemCopySequence((uint64_t)a2 + 152);
  if (v2)
  {
    uint64_t v5 = (const void *)*((void *)v2 + 71);
    if (!v5)
    {
      BOOL v2 = 0LL;
      if (!v4) {
        goto LABEL_13;
      }
      goto LABEL_5;
    }

    CFRetain(v5);
    BOOL v2 = (const __CFData *)*((void *)v2 + 71);
  }

  if (!v4) {
    goto LABEL_13;
  }
LABEL_5:
  if ((CFDataGetLength(v4) & 0x8000000000000000LL) == 0 && v2)
  {
    if ((CFDataGetLength(v2) & 0x8000000000000000LL) == 0)
    {
      CFIndex Length = CFDataGetLength(v2);
      BytePtr = CFDataGetBytePtr(v2);
      CFIndex v8 = CFDataGetLength(v4);
      uint64_t v9 = CFDataGetBytePtr(v4);
      uint64_t v10 = PORT_ArenaAlloc(a1, 0x28uLL);
      if (v10)
      {
        int v11 = (void *)v10;
        *(void *)(v10 + 32) = 0LL;
        *(_OWORD *)uint64_t v10 = 0u;
        *(_OWORD *)(v10 + 16) = 0u;
        int v12 = (void *)PORT_ArenaAlloc(a1, v8);
        v11[4] = v12;
        if (v12)
        {
          memcpy(v12, v9, v8);
          unint64_t v11[3] = v8;
          int v13 = (void *)PORT_ArenaAlloc(a1, Length);
          uint64_t v11[2] = v13;
          if (v13)
          {
            memcpy(v13, BytePtr, Length);
            v11[1] = Length;
            CFRelease(v2);
            CFRelease(v4);
            return v11;
          }
        }
      }
    }

    goto LABEL_14;
  }

CFTypeRef *CERT_FindByIssuerAndSN(const void *a1, const void *a2, uint64_t a3)
{
  keys[4] = *(void **)MEMORY[0x1895F89C0];
  CFIndex v4 = *(void *)(a3 + 8);
  if (v4 < 0) {
    return 0LL;
  }
  SecPolicyRef v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v8 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const UInt8 **)(a3 + 16),  v4,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint64_t v9 = *(void *)(a3 + 24);
  v27[0] = *(void *)(a3 + 32);
  v27[1] = v9;
  memset(v26, 170, sizeof(v26));
  if (DERDecodeItem((uint64_t)v27, v26)
    || (NormalizedX501Name = createNormalizedX501Name(v7, (uint64_t)&v26[1])) == 0LL)
  {
    ItemInAllAvailableKeychains = 0LL;
    if (!v8) {
      return ItemInAllAvailableKeychains;
    }
    goto LABEL_30;
  }

  int v11 = NormalizedX501Name;
  if (a1)
  {
    CFTypeID v12 = CFGetTypeID(a1);
    if (v12 == CFArrayGetTypeID())
    {
      if (a2)
      {
        if (CFEqual(a2, @"cert"))
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
          if (Count >= 1)
          {
            CFIndex v14 = Count;
            for (CFIndex i = 0LL; v14 != i; ++i)
            {
              ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
              if (ValueAtIndex)
              {
                ItemInAllAvailableKeychains = ValueAtIndex;
                CFTypeRef v18 = ValueAtIndex[72];
                if (v18)
                {
                  if (CFEqual(v18, v11))
                  {
                    CFTypeRef v19 = ItemInAllAvailableKeychains[71];
                    if (v19)
                    {
                      CFRetain(v19);
                      CFTypeRef v20 = ItemInAllAvailableKeychains[71];
                      if (v20)
                      {
                        if (v8)
                        {
                          int v21 = CFEqual(ItemInAllAvailableKeychains[71], v8);
                          CFRelease(v20);
                          if (v21)
                          {
                            CFRetain(ItemInAllAvailableKeychains);
                            goto LABEL_29;
                          }
                        }

                        else
                        {
                          CFRelease(ItemInAllAvailableKeychains[71]);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  keys[0] = @"class";
  keys[1] = @"issr";
  keys[2] = @"slnr";
  keys[3] = @"r_Ref";
  values[0] = (void *)a2;
  values[1] = v11;
  int v22 = (void *)*MEMORY[0x189604DE8];
  values[2] = v8;
  values[3] = v22;
  uint64_t v23 = CFDictionaryCreate(v7, (const void **)keys, (const void **)values, 4LL, 0LL, 0LL);
  if (_is_apple_mail_bundle_onceToken != -1) {
    dispatch_once(&_is_apple_mail_bundle_onceToken, &__block_literal_global_5400);
  }
  if (_is_apple_mail_bundle_result)
  {
    mail_keychain_query = _create_mail_keychain_query(v23);
    if (v23) {
      CFRelease(v23);
    }
  }

  else
  {
    mail_keychain_query = v23;
  }

  ItemInAllAvailableKeychains = (CFTypeRef *)CERT_FindItemInAllAvailableKeychains(mail_keychain_query);
  if (mail_keychain_query) {
    CFRelease(mail_keychain_query);
  }
LABEL_29:
  CFRelease(v11);
  if (v8) {
LABEL_30:
  }
    CFRelease(v8);
  return ItemInAllAvailableKeychains;
}

CFTypeRef CERT_FindBySubjectKeyID(const void *a1, const void *a2, CFIndex *a3)
{
  keys[3] = *(void **)MEMORY[0x1895F89C0];
  if (!a3) {
    return 0LL;
  }
  CFIndex v4 = (const UInt8 *)a3[1];
  if (!v4) {
    return 0LL;
  }
  CFIndex v5 = *a3;
  if (v5 < 1) {
    return 0LL;
  }
  SecPolicyRef v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v4, v5, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  if (a1)
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 == CFArrayGetTypeID())
    {
      if (a2)
      {
        if (CFEqual(a2, @"cert"))
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
          if (Count >= 1)
          {
            CFIndex v11 = Count;
            CFIndex v12 = 0LL;
            while (1)
            {
              ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)a1, v12);
              if (ValueAtIndex)
              {
                CFTypeRef ItemInAllAvailableKeychains = ValueAtIndex;
                CFDataRef SubjectKeyID = SecCertificateGetSubjectKeyID(ValueAtIndex);
                if (SubjectKeyID)
                {
                  if (v8 && CFEqual(SubjectKeyID, v8)) {
                    break;
                  }
                }
              }

              if (v11 == ++v12) {
                goto LABEL_15;
              }
            }

            CFRetain(ItemInAllAvailableKeychains);
            goto LABEL_26;
          }
        }
      }
    }
  }

BOOL CERT_CheckIssuerAndSerial(uint64_t a1, size_t *a2, size_t *a3)
{
  uint64_t v6 = SecDERItemCopySequence(a1 + 152);
  if (!v6) {
    return 0LL;
  }
  SecPolicyRef v7 = v6;
  size_t v8 = *a2;
  if (v8 != CFDataGetLength(v6)) {
    goto LABEL_4;
  }
  CFTypeID v9 = (const void *)a2[1];
  BytePtr = CFDataGetBytePtr(v7);
  if (memcmp(v9, BytePtr, *a2)) {
    goto LABEL_4;
  }
  CFRelease(v7);
  if (!a1) {
    return 0LL;
  }
  CFIndex v12 = *(const void **)(a1 + 568);
  if (!v12) {
    return 0LL;
  }
  CFRetain(v12);
  SecPolicyRef v7 = *(const __CFData **)(a1 + 568);
  if (!v7) {
    return 0LL;
  }
  size_t v13 = *a3;
  if (v13 == CFDataGetLength(v7))
  {
    CFIndex v14 = (const void *)a3[1];
    uint64_t v15 = CFDataGetBytePtr(v7);
    BOOL v11 = memcmp(v14, v15, *a3) == 0;
    goto LABEL_5;
  }

LABEL_4:
  BOOL v11 = 0LL;
LABEL_5:
  CFRelease(v7);
  return v11;
}

  uint64_t v15 = (const __CFString *)CFArrayCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  v6,  v7,  v8,  v9,  v10,  v11,  v12,  (uint64_t)a1);
  DERData = CFPropertyListCreateDERData((uint64_t)v15, v15, 0LL, v16, v17, v18, v19, v20);
  CFRelease(v15);
  if (v13) {
LABEL_5:
  }
    CFRelease(v13);
  return DERData;
}

  *a3 = v5;
  return 0LL;
}

uint64_t SecCmsDecoderCreate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t **a7)
{
  ThreadErrInfo = PR_getThreadErrInfo(1, &v22);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0LL;
  }
  CFIndex v14 = (void *)SecCmsMessageCreate();
  if (v14)
  {
    uint64_t v15 = (uint64_t)v14;
    v14[17] = a4;
    v14[18] = a5;
    v14[19] = a6;
    int v16 = (uint64_t *)PORT_ZAlloc(0x40uLL);
    if (v16)
    {
      BOOL v17 = v16;
      uint64_t v18 = SEC_ASN1DecoderStart(*(void *)(v15 + 120), v15, (uint64_t)&SecCmsMessageTemplate, 0LL, 0LL);
      *BOOL v17 = v18;
      if (v18)
      {
        uint64_t Error = 0LL;
        *(void *)(v18 + 32) = nss_cms_decoder_notify;
        *(void *)(v18 + 40) = v17;
        v17[1] = v15;
        *((_DWORD *)v17 + 4) = 0;
        void v17[6] = a1;
        v17[7] = a2;
        *a7 = v17;
        return Error;
      }

      free(v17);
    }

    SecCmsMessageDestroy(v15);
  }

  uint64_t Error = PORT_GetError();
  CFTypeRef v20 = PR_getThreadErrInfo(1, &v23);
  if (v20) {
    *CFTypeRef v20 = 0LL;
  }
  return Error;
}

void nss_cms_decoder_notify(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v139 = *MEMORY[0x1895F89C0];
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 > 0x1E) {
    goto LABEL_15;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (((1 << v4) & 0x6C000000) != 0)
  {
    BOOL v7 = a2 != 0;
    size_t v8 = (uint64_t *)(v6 + 16);
    uint64_t v9 = *(void *)(a1 + 24);
    if ((v9 || (uint64_t v9 = *v8, *(void *)(a1 + 24) = *v8, v9)) && ((1 << v4) & 0x6C000000) != 0)
    {
      uint64_t v10 = v9;
      if (!a2) {
        goto LABEL_26;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
      if (!a2)
      {
LABEL_26:
        if (v10 + 72 != a3) {
          BOOL v7 = 0;
        }
        if (v7)
        {
          uint64_t v16 = *(void *)a1;
          BOOL v17 = *(void *)(a1 + 48) != 0LL;
          *(void *)(v16 + 56) = nss_cms_decoder_update_filter;
          *(void *)(v16 + 64) = a1;
          *(_DWORD *)(v16 + 72) = v17;
          uint64_t v18 = *(void *)(*(void *)(a1 + 8) + 120LL);
          switch(v4)
          {
            case 0x1Au:
              CFTypeRef v19 = *(void **)(a1 + 24);
              p___int128 plainTextLen = (uint64_t *)v19[17];
              if (!p_plainTextLen) {
                goto LABEL_57;
              }
              if (v19[21]) {
                goto LABEL_56;
              }
              goto LABEL_46;
            case 0x1Bu:
              uint64_t v25 = *(void *)(a1 + 24);
              char v26 = *(uint64_t **)(v25 + 144);
              if (!v26
                || !*v26
                || (int v27 = nss_cms_recipients_traverse(*(uint64_t **)(v25 + 144), 0LL),
                    (v27 - 268435454) <= 0xF0000002))
              {
                ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (ThreadErrInfo) {
                  void *ThreadErrInfo = 0xFFFFE00200000000LL;
                }
                goto LABEL_120;
              }

              int v49 = (char *)PORT_ZAlloc(8LL * (v27 + 1));
              if (!v49) {
                goto LABEL_120;
              }
              unint64_t v50 = v49;
              uint64_t v51 = *(void *)v50;
              if (!*(void *)v50) {
                goto LABEL_116;
              }
              uint64_t v52 = 0LL;
              break;
            case 0x1Du:
              CFTypeRef v19 = *(void **)(a1 + 24);
              if (!v19[17]) {
                goto LABEL_120;
              }
              __int128 plainTextLen = (unint64_t)(v19 + 17);
              p___int128 plainTextLen = (uint64_t *)&plainTextLen;
LABEL_46:
              uint64_t started = SecCmsDigestContextStartMultiple(p_plainTextLen);
              v19[13] = started;
              if (!started) {
                goto LABEL_120;
              }
              goto LABEL_56;
            case 0x1Eu:
              uint64_t v29 = *(void *)(a1 + 24);
              uint64_t v30 = *(void *)(v29 + 24);
              CFIndex v31 = *(uint64_t (**)(void, uint64_t))(v30 + 144);
              if (v31)
              {
                unint64_t v32 = (const __CFData *)v31(*(void *)(v30 + 152), v29 + 40);
                if (v32)
                {
                  int v33 = v32;
                  SecCmsContentInfoSetBulkKey(v29, v32);
                  uint64_t v34 = SecCmsCipherContextStart(0LL, v33, v29 + 40, 0);
                  *(void *)(v29 + 96) = v34;
                  CFRelease(v33);
                  if (v34) {
                    goto LABEL_56;
                  }
                }
              }

              goto LABEL_120;
            default:
              goto LABEL_120;
          }

          while (1)
          {
            int v53 = *(_DWORD *)(v51 + 8);
            if (v53 == 1)
            {
              uint64_t v54 = CERT_FindBySubjectKeyID(0LL, @"idnt", *(CFIndex **)(v51 + 16));
            }

            else
            {
              if (v53) {
                goto LABEL_97;
              }
              uint64_t v54 = CERT_FindByIssuerAndSN(0LL, @"idnt", *(void *)(v51 + 16));
            }

            uint64_t v55 = v54;
            if (v54)
            {
              uint64_t v57 = (const void *)v54[2];
              CFRetain(v57);
              uint64_t v58 = (const void *)v55[3];
              CFRetain(v58);
              CFRelease(v55);
              *(void *)(v51 + 24) = v57;
              *(void *)(v51 + 32) = v58;
              if ((v52 & 0x80000000) != 0)
              {
LABEL_116:
                uint64_t v70 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (!v70) {
                  goto LABEL_119;
                }
                unint64_t v71 = 0xFFFFE02D00000000LL;
              }

              else
              {
                __int128 v59 = *(int **)&v50[8 * v52];
                if (!*((void *)v59 + 3) || !*((void *)v59 + 4)) {
                  goto LABEL_119;
                }
                uint64_t v60 = *(int **)(*(void *)(v25 + 144) + 8LL * *v59);
                if (SecCmsContentInfoGetContentEncAlgTag(v25))
                {
                  uint64_t v61 = v59[1];
                  uint64_t v62 = *((void *)v59 + 3);
                  uint64_t v63 = (__SecKey *)*((void *)v59 + 4);
                  if (v62) {
                    CFRetain(*((CFTypeRef *)v59 + 3));
                  }
                  *((void *)v60 + 1_Block_object_dispose((const void *)(v1 - 64), 8) = v62;
                  int v64 = *v60;
                  if (*v60 == 2) {
                    goto LABEL_140;
                  }
                  if (v64 != 1)
                  {
                    if (!v64)
                    {
                      if (*((void *)v60 + 6))
                      {
                        uint64_t OID = SECOID_FindOID((uint64_t)(v60 + 10));
                        if (OID)
                        {
                          if (*(_DWORD *)(OID + 16) == 16)
                          {
                            size_t v66 = *((void *)v60 + 9);
                            *(void *)&__int128 plainTextLen = v66;
                            if (v66 <= 0x400
                              && (uint64_t v67 = (uint8_t *)malloc(v66)) != 0LL
                              && (CFIndex v68 = v67,
                                  !SecKeyDecrypt( v63,  1u,  *((const uint8_t **)v60 + 10),  v66,  v67,  (size_t *)&plainTextLen)))
                            {
                              CFDataRef v69 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  v68,  plainTextLen,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
                            }

                            else
                            {
                              CFDataRef v69 = 0LL;
                            }

                            goto LABEL_145;
                          }
                        }
                      }

LABEL_140:
                      int v80 = -8144;
LABEL_141:
                      uint64_t v81 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                      if (v81)
                      {
                        _DWORD *v81 = 0;
                        v81[1] = v80;
                      }
                    }

LABEL_119:
                    nss_cms_recipient_list_destroy(v50);
                    goto LABEL_120;
                  }

                  if (!*((void *)v60 + 13)) {
                    goto LABEL_140;
                  }
                  uint64_t v74 = SECOID_FindOID((uint64_t)(v60 + 24));
                  if (!v74 || *(_DWORD *)(v74 + 16) != 204) {
                    goto LABEL_140;
                  }
                  if (v60[6] != 2)
                  {
                    int v80 = -8191;
                    goto LABEL_141;
                  }

                  int v110 = *(UInt8 **)(*((void *)v60 + 16) + 8 * v61);
                  CFTypeRef v112 = (CFTypeRef)*((void *)v60 + 8);
                  publicKey = (const UInt8 *)*((void *)v60 + 9);
                  *(void *)&__int128 v75 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v75 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  __int128 v128 = v75;
                  __int128 v129 = v75;
                  uint64_t v126 = 0LL;
                  iv = 0LL;
                  __int128 v137 = v75;
                  __int128 v138 = v75;
                  __int128 plainTextLen = v75;
                  __int128 v136 = v75;
                  CFIndex length = 0LL;
                  size_t bytes = 0LL;
                  __int16 v123 = 5;
                  int v122 = -1431655766;
                  CCCryptorRef cryptorRef = 0LL;
                  CFTypeRef cf = 0LL;
                  CFTypeRef valuePtr = 0LL;
                  uint64_t v76 = PORT_NewArena(1024);
                  if (v76)
                  {
                    __int128 v77 = v76;
                    __int128 v128 = 0u;
                    __int128 v129 = 0u;
                    if (!SEC_ASN1Decode( (uint64_t)v76,  (uint64_t)&v128,  (uint64_t)&SECOID_AlgorithmIDTemplate,  *((char **)v60 + 15),  *((void *)v60 + 14)))
                    {
                      uint64_t v83 = SECOID_FindOID((uint64_t)&v128);
                      if (v83)
                      {
                        unint64_t v84 = (__int128 *)v83;
                        int v85 = *(_DWORD *)(v83 + 16);
                        switch(v85)
                        {
                          case 183:
                            CCAlgorithm v108 = 0;
                            int v86 = 2;
                            goto LABEL_156;
                          case 184:
                            CCAlgorithm v108 = 0;
                            int v86 = 1;
LABEL_156:
                            CCOptions v107 = v86;
                            int v87 = 128;
                            break;
                          case 185:
                            CCAlgorithm v108 = 0;
                            int v88 = 2;
                            goto LABEL_159;
                          case 186:
                            CCAlgorithm v108 = 0;
                            int v88 = 1;
LABEL_159:
                            CCOptions v107 = v88;
                            int v87 = 192;
                            break;
                          case 187:
                            CCAlgorithm v108 = 0;
                            int v89 = 2;
                            goto LABEL_162;
                          case 188:
                            CCAlgorithm v108 = 0;
                            int v89 = 1;
LABEL_162:
                            CCOptions v107 = v89;
                            int v87 = 256;
                            break;
                          default:
                            CCOptions v107 = 1;
                            CCAlgorithm v108 = 2;
                            unsigned int v109 = 192;
                            switch(v85)
                            {
                              case 7:
                                goto LABEL_164;
                              case 9:
                                CCOptions v107 = 2;
                                break;
                              case 10:
                                break;
                              case 14:
                                CCAlgorithm v108 = 2;
                                unsigned int v109 = 192;
                                CCOptions v107 = 2;
                                goto LABEL_164;
                              default:
                                goto LABEL_131;
                            }

                            CCAlgorithm v108 = 1;
                            int v87 = 64;
                            break;
                        }

                        unsigned int v109 = v87;
LABEL_164:
                        if (!SEC_ASN1Decode( (uint64_t)v77,  (uint64_t)&v126,  (uint64_t)kSecAsn1OctetStringTemplate,  *((char **)&v129 + 1),  v129))
                        {
                          __int128 v137 = 0u;
                          __int128 v138 = 0u;
                          __int128 plainTextLen = 0u;
                          __int128 v136 = 0u;
                          __int128 plainTextLen = *v84;
                          *(void *)&__int128 v136 = 2LL;
                          *((void *)&v136 + 1) = &v123;
                          __int128 v137 = *((_OWORD *)v60 + 5);
                          uint64_t v90 = 3LL;
                          unsigned int v91 = v109;
                          do
                          {
                            *((_BYTE *)&v122 + v90) = v91;
                            v91 >>= 8;
                            --v90;
                          }

                          while (v90 != -1);
                          *(void *)&__int128 v138 = 4LL;
                          *((void *)&v138 + 1) = &v122;
                          if (SEC_ASN1EncodeItem( (uint64_t)v77,  &length,  (uint64_t)&plainTextLen,  (uint64_t)&ECC_CMS_SharedInfoTemplate))
                          {
                            CFTypeRef valuePtr = v112;
                            uint64_t v92 = CFDataCreate(0LL, publicKey, ((unint64_t)v112 + 7) >> 3);
                            CFNumberRef v93 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
                            keys[0] = @"type";
                            keys[1] = @"kcls";
                            keys[2] = @"bsiz";
                            values[0] = @"73";
                            values[1] = @"0";
                            CFNumberRef v105 = v93;
                            values[2] = v93;
                            uint64_t v103 = v92;
                            uint64_t v104 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  3LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
                            publicKeya = SecKeyCreateWithData(v92, v104, (CFErrorRef *)&cf);
                            CFDataRef v69 = 0LL;
                            if (cf)
                            {
                              CFDataRef v106 = 0LL;
                              CFNumberRef v113 = 0LL;
                              uint64_t v94 = 0LL;
                              unint64_t v95 = 0LL;
                            }

                            else
                            {
                              CFDataRef v106 = 0LL;
                              CFNumberRef v113 = 0LL;
                              uint64_t v94 = 0LL;
                              unint64_t v95 = 0LL;
                              if ((length & 0x8000000000000000LL) == 0)
                              {
                                CFDataRef v96 = CFDataCreate(0LL, bytes, length);
                                unsigned int v118 = v109 >> 3;
                                CFNumberRef v97 = CFNumberCreate(0LL, kCFNumberSInt32Type, &v118);
                                v132[0] = @"requestedSize";
                                v132[1] = @"sharedInfo";
                                CFNumberRef v113 = v97;
                                v131[0] = v97;
                                v131[1] = v96;
                                CFDataRef v106 = v96;
                                uint64_t v94 = CFDictionaryCreate( 0LL,  (const void **)v132,  (const void **)v131,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
                                uint64_t v98 = SecKeyCopyKeyExchangeResult( v63,  @"algid:keyexchange:ECDH:KDFX963:SHA1",  publicKeya,  v94,  (CFErrorRef *)&cf);
                                unint64_t v95 = v98;
                                if (cf
                                  || CFDataGetLength(v98) < 0
                                  || (BytePtr = CFDataGetBytePtr(v95),
                                      CFIndex v100 = CFDataGetLength(v95),
                                      CCCryptorCreate(1u, v108, v107, BytePtr, v100, iv, &cryptorRef))
                                  || (uint64_t v101 = v110,
                                      OutputCFIndex Length = CCCryptorGetOutputLength(cryptorRef, *((void *)v110 + 7), 1),
                                      size_t dataOutMoved = 0LL,
                                      uint64_t v111 = (UInt8 *)PORT_ArenaAlloc((uint64_t)v77, OutputLength),
                                      CCCryptorUpdate( cryptorRef,  *((const void **)v101 + 8),  *((void *)v101 + 7),  v111,  OutputLength,  &dataOutMoved))
                                  || (size_t v116 = 0LL,
                                      CCCryptorFinal( cryptorRef,  &v111[dataOutMoved],  OutputLength - dataOutMoved,  &v116))
                                  || (uint64_t)(v116 + dataOutMoved) < 0)
                                {
                                  CFDataRef v69 = 0LL;
                                }

                                else
                                {
                                  CFDataRef v69 = CFDataCreate(0LL, v111, v116 + dataOutMoved);
                                }
                              }
                            }

                            PORT_FreeArena(v77, 0);
                            if (v103) {
                              CFRelease(v103);
                            }
                            if (v105) {
                              CFRelease(v105);
                            }
                            if (publicKeya) {
                              CFRelease(publicKeya);
                            }
                            if (v104) {
                              CFRelease(v104);
                            }
                            if (v106) {
                              CFRelease(v106);
                            }
                            if (v113) {
                              CFRelease(v113);
                            }
                            if (v94) {
                              CFRelease(v94);
                            }
                            if (v95) {
                              CFRelease(v95);
                            }
                            goto LABEL_133;
                          }
                        }
                      }
                    }

          Security::MacOSError::throwMe((Security::MacOSError *)v51);
        }
      }

LABEL_131:
                    PORT_FreeArena(v77, 0);
                  }

                  CFDataRef v69 = 0LL;
LABEL_133:
                  CFTypeRef v78 = cf;
                  if (cf)
                  {
                    CFTypeRef cf = 0LL;
                    CFRelease(v78);
                  }

                  if (cryptorRef) {
                    CCCryptorRelease(cryptorRef);
                  }
                  if (!v69)
                  {
                    uint64_t v79 = PR_getThreadErrInfo(1, &v130);
                    if (v79) {
                      *uint64_t v79 = 0xFFFFE01A00000000LL;
                    }
                  }

                  *(void *)CFAbsoluteTime at = 0LL;
                  CFRelease(v84);
                  goto LABEL_132;
                }

                ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)at, 0LL);
                uint64_t v94 = CFArrayGetValueAtIndex((CFArrayRef)value, 0LL);
                if (ValueAtIndex && v94)
                {
                  if (!CFEqual(ValueAtIndex, v94)) {
                    goto LABEL_165;
                  }
                }

                else if (ValueAtIndex != v94)
                {
                  goto LABEL_165;
                }

                if (!certArrayIsSubset(*(const __CFArray **)at, (CFArrayRef)value)
                  || (certArrayIsSubset((const __CFArray *)value, *(CFArrayRef *)at) & 1) == 0)
                {
LABEL_165:
                  unint64_t v84 = *(const void **)at;
                  CFTypeRef v78 = v103;
                  if (!*(void *)at) {
                    goto LABEL_132;
                  }
                  goto LABEL_131;
                }

                unint64_t v95 = *(const void **)at;
                CFTypeRef v78 = v103;
                if (*(void *)at)
                {
                  *(void *)CFAbsoluteTime at = 0LL;
                  CFRelease(v95);
                }

                CFDataRef v96 = value;
                if (value)
                {
                  xpc_object_t value = 0LL;
                  CFRelease(v96);
                }

                unsigned int v109 = 0.0;
                policies = 0LL;
                if (SecTrustCopyPolicies(v82, &policies) || SecTrustCopyPolicies(v83, (CFArrayRef *)&v109))
                {
                  CFNumberRef v97 = policies;
LABEL_161:
                  if (v97)
                  {
                    policies = 0LL;
                    CFRelease(v97);
                  }

                  int v85 = v109;
                  if (!*(void *)&v109) {
                    goto LABEL_135;
                  }
                  unsigned int v109 = 0.0;
LABEL_134:
                  CFRelease(*(CFTypeRef *)&v85);
                  goto LABEL_135;
                }

                CFNumberRef v97 = policies;
                if (policies && *(void *)&v109)
                {
                  uint64_t v98 = CFEqual(policies, *(CFTypeRef *)&v109);
                  CFNumberRef v97 = policies;
                  if (!v98) {
                    goto LABEL_161;
                  }
                }

                else if (policies != *(CFArrayRef *)&v109)
                {
                  goto LABEL_161;
                }

                if (v97)
                {
                  policies = 0LL;
                  CFRelease(v97);
                }

                BOOL v99 = v109;
                if (*(void *)&v109)
                {
                  unsigned int v109 = 0.0;
                  CFRelease(*(CFTypeRef *)&v99);
                }

                CFAbsoluteTime VerifyTime = SecTrustGetVerifyTime(v82);
                CFTypeRef v78 = v103;
                if (vabdd_f64(VerifyTime, SecTrustGetVerifyTime(v83)) <= 0.1) {
                  goto LABEL_137;
                }
                goto LABEL_135;
              }

LABEL_145:
                  if (!v69) {
                    goto LABEL_119;
                  }
                  SecCmsContentInfoSetBulkKey(v25, v69);
                  CFRetain(*((CFTypeRef *)v59 + 4));
                  *(void *)(v25 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = *((void *)v59 + 4);
                  uint64_t v82 = SecCmsCipherContextStart(0LL, v69, v25 + 40, 0);
                  *(void *)(v25 + 96) = v82;
                  CFRelease(v69);
                  nss_cms_recipient_list_destroy(v50);
                  if (v82)
                  {
LABEL_56:
                    CFTypeRef v19 = *(void **)(a1 + 24);
                    if (v19)
                    {
LABEL_57:
                      unsigned int v35 = *(_DWORD *)(a1 + 16);
                      if (v35 > 0x1E || ((1 << v35) & 0x6C000000) == 0) {
                        CFTypeRef v19 = 0LL;
                      }
                    }

                    uint64_t v36 = v19[4];
                    if (v36 || (uint64_t v36 = SECOID_FindOID((uint64_t)v19), (v19[4] = v36) != 0LL))
                    {
                      int v37 = *(_DWORD *)(v36 + 16);
                      if (v37 == 25)
                      {
                        int v38 = SECITEM_AllocItem(v18, 0LL, 0LL);
                        void v19[2] = v38;
                        if (v38)
                        {
                          *(void *)(a1 + 32) = 0LL;
                          return;
                        }
                      }

                      else
                      {
                        uint64_t v39 = (v37 - 26);
                        if (v39 <= 4 && v37 != 28)
                        {
                          uint64_t v40 = (uint64_t)*(&off_18966A918 + v39);
                          __int128 v41 = (uint64_t *)PORT_ZAlloc(0x40uLL);
                          if (v41)
                          {
                            uint64_t v42 = v41;
                            if (qword_180653958[v39] <= 1uLL) {
                              unint64_t v43 = 1LL;
                            }
                            else {
                              unint64_t v43 = qword_180653958[v39];
                            }
                            unint64_t v44 = (void *)PORT_ArenaAlloc(v18, v43);
                            if (v44)
                            {
                              uint64_t v45 = (uint64_t)v44;
                              bzero(v44, v43);
                              v42[3] = v45;
                              uint64_t v46 = SEC_ASN1DecoderStart(v18, v45, v40, 0LL, 0LL);
                              uint64_t *v42 = v46;
                              if (v46)
                              {
                                *(void *)(v46 + 32) = nss_cms_decoder_notify;
                                *(void *)(v46 + 40) = v42;
                                *(void *)(a1 + 32) = v42;
                                *((_DWORD *)v42 + 4) = v37;
                                v42[1] = *(void *)(a1 + 8);
                                *((_OWORD *)v42 + 3) = *(_OWORD *)(a1 + 48);
                                *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = SecCmsDecoderUpdate;
                                *(void *)(a1 + 56) = v42;
                                return;
                              }
                            }

                            free(v42);
                            *(void *)(a1 + 32) = 0LL;
                          }
                        }
                      }
                    }
                  }

LABEL_120:
                  uint64_t v72 = *(void *)a1;
                  *(void *)(v72 + 56) = 0LL;
                  *(void *)(v72 + 64) = 0LL;
                  *(_DWORD *)(v72 + 72) = 0;
                  *(_DWORD *)(a1 + 44) = PORT_GetError();
                  unint64_t v73 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                  if (v73) {
                    *unint64_t v73 = 0LL;
                  }
                  return;
                }

                uint64_t v70 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (!v70) {
                  goto LABEL_119;
                }
                unint64_t v71 = 0xFFFFE00600000000LL;
              }

              *uint64_t v70 = v71;
              goto LABEL_119;
            }

LABEL_97:
            uint64_t v56 = &v50[8 * v52++];
            uint64_t v51 = *((void *)v56 + 1);
            if (!v51) {
              goto LABEL_116;
            }
          }
        }

        if (a2 || v10 + 72 != a3) {
          return;
        }
        nss_cms_decoder_work_data(a1, 0LL, 0LL, 1);
        int v21 = *(void **)(a1 + 32);
        if (!v21)
        {
          int v22 = -1;
LABEL_77:
          switch(*(_DWORD *)(a1 + 16))
          {
            case 0x19:
              goto LABEL_82;
            case 0x1A:
              int v22 = SecCmsSignedDataDecodeAfterData(*(void **)(a1 + 24));
              goto LABEL_82;
            case 0x1B:
              SecCmsEnvelopedDataDecodeAfterData(*(void *)(a1 + 24));
              goto LABEL_86;
            case 0x1D:
              int v22 = SecCmsDigestedDataEncodeAfterData(*(void **)(a1 + 24));
LABEL_82:
              if (v22) {
                goto LABEL_83;
              }
              goto LABEL_86;
            case 0x1E:
              SecCmsEncryptedDataEncodeAfterData(*(void *)(a1 + 24));
              goto LABEL_86;
            default:
              goto LABEL_83;
          }
        }

        if (!*v21)
        {
          int v23 = -1;
LABEL_75:
          free(v21);
          int v22 = v23;
LABEL_76:
          *(void *)(a1 + 32) = 0LL;
          goto LABEL_77;
        }

        if (!SEC_ASN1DecoderFinish(*v21))
        {
          int v22 = nss_cms_after_end((uint64_t)v21);
          if (!v22)
          {
            int v23 = 0;
            int v21 = *(void **)(a1 + 32);
            if (!v21) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
        }

LABEL_83:
        *(_DWORD *)(a1 + 44) = PORT_GetError();
        uint64_t v47 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
        if (v47) {
          void *v47 = 0LL;
        }
LABEL_86:
        uint64_t v48 = *(void *)a1;
        *(void *)(v48 + 56) = 0LL;
        *(void *)(v48 + 64) = 0LL;
        *(_DWORD *)(v48 + 72) = 0;
        return;
      }
    }

    if (v10 == a3 && ((1 << v4) & 0x6C000000) != 0) {
      *(void *)(v9 + 24) = v6;
    }
    goto LABEL_26;
  }

  if (!v4)
  {
    if (!a2 && v6 == a3)
    {
      uint64_t v14 = *(void *)(a3 + 32);
      if (v14 || (uint64_t v14 = SECOID_FindOID(a3), (*(void *)(a3 + 32) = v14) != 0LL)) {
        int v15 = *(_DWORD *)(v14 + 16);
      }
      else {
        int v15 = 0;
      }
      *(_DWORD *)(a1 + 16) = v15;
      *(void *)(a1 + 24) = *(void *)(a3 + 16);
    }

    return;
  }

  if (v4 != 25)
  {
LABEL_15:
    *(_DWORD *)(a1 + 44) = -8058;
    return;
  }

  uint64_t v11 = v6 + 16;
  if (a2 && v11 == a3)
  {
    uint64_t v12 = *(void *)a1;
    BOOL v13 = *(void *)(a1 + 48) != 0LL;
    *(void *)(v12 + 56) = nss_cms_decoder_update_filter;
    *(void *)(v12 + 64) = a1;
    *(_DWORD *)(v12 + 72) = v13;
    return;
  }

  if (!a2 && v11 == a3) {
    goto LABEL_86;
  }
}

    uint64_t v61 = (os_log_s *)secLogObjForScope("otr");
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
LABEL_85:
      _os_log_impl(&dword_1804F4000, v61, OS_LOG_TYPE_DEFAULT, "%@ Process DH failed %d", buf, 0x12u);
    }
  }

      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(void *)v7 + 16LL))( v7,  4294900242LL,  @"SecCSResourceAltered",  v155);
      goto LABEL_280;
    }

    int v53 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v14, 1);
    if (!Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)text, v53[37]) || (v9 & 1) != 0) {
      goto LABEL_83;
    }
    v170[0] = (void *)0xAAAAAAAAFFFFFFFFLL;
    Security::cfString((Security *)__p, v155);
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v54 = __p;
    }
    else {
      uint64_t v54 = (void **)__p[0];
    }
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v170, (const char *)v54, 0, 4096);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    if (LODWORD(v170[0]) == -1)
    {
      if (((uint64_t)theString[1] & 1) != 0)
      {
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v170);
        goto LABEL_280;
      }

      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(void *)v7 + 16LL))( v7,  4294900242LL,  @"SecCSResourceMissing",  v155);
      goto LABEL_253;
    }

    __p[0] = 0LL;
    __p[1] = __p;
    __p[2] = (void *)0x2000000000LL;
    LOBYTE(__p[3]) = 1;
    v147 = (int)v170[0];
    v148 = BYTE4(v170[0]);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v146, (void *)(v14 + 344));
    v145[0] = MEMORY[0x1895F87A8];
    v145[1] = 0x40000000LL;
    v145[2] = ___ZN8Security11CodeSigning13SecStaticCode16validateResourceEPK14__CFDictionaryNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbRNS1_17ValidationContextEjj_block_invoke;
    _OWORD v145[3] = &unk_1896782B8;
    v145[4] = __p;
    v145[5] = text;
    Security::CodeSigning::CodeDirectory::multipleHashFileData((uint64_t)&v147, 0LL, v146, (uint64_t)v145);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((void *)v146[1]);
    if (!*((_BYTE *)__p[1] + 24))
    {
      if (v3 == 2)
      {
        else {
          v144 = *v11;
        }
        __int16 v123 = Security::CodeSigning::SecStaticCode::checkfix30814861(v14, (const std::string::value_type *)&v144, 0);
        unint64_t v124 = v123;
        if ((char)v144.__r_.__value_.__s.__size_ < 0)
        {
          operator delete(v144.__r_.__value_.__l.__data_);
          if ((v124 & 1) != 0)
          {
LABEL_246:
            uint64_t v125 = (os_log_s *)secLogObjForScope("validateResource");
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(__b[0].__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)__b[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
              _os_log_debug_impl( &dword_1804F4000,  v125,  OS_LOG_TYPE_DEBUG,  "%s check-fixed (altered).",  (uint8_t *)__b,  0xCu);
            }

            goto LABEL_252;
          }
        }

        else if (v123)
        {
          goto LABEL_246;
        }
      }

      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(void *)v7 + 16LL))( v7,  4294900242LL,  @"SecCSResourceAltered",  v155);
    }

  std::string::operator=((std::string *)((char *)this + 160), (const std::string *)(*((void *)this + 1) + 224LL));
  if (*((char *)this + 183) < 0)
  {
    if (*((void *)this + 21)) {
      goto LABEL_90;
    }
  }

  else if (*((_BYTE *)this + 183))
  {
    goto LABEL_90;
  }

  if ((v6 & 0x20) != 0)
  {
    int v33 = (const std::string::value_type *)Security::CodeSigning::SecStaticCode::teamID(*((Security::CodeSigning::SecStaticCode **)this
                                                                                        + 2));
    if (v33) {
      std::string::__assign_external((std::string *)((char *)this + 160), v33);
    }
  }

void nss_cms_decoder_update_filter(uint64_t a1, char *a2, size_t a3, uint64_t a4, int a5)
{
  if (a3)
  {
    *(_BYTE *)(a1 + 40) = 1;
    if (a5 == 2) {
      nss_cms_decoder_work_data(a1, a2, a3, 0);
    }
  }

uint64_t SecCmsDecoderUpdate(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t result = 4294967246LL;
  if (a1 && (a3 & 0x8000000000000000LL) == 0)
  {
    if (*(void *)a1 && !*(_DWORD *)(a1 + 44) && SEC_ASN1DecoderUpdate(*(void *)a1, a2, a3))
    {
      int Error = PORT_GetError();
      if (Error) {
        int v6 = Error;
      }
      else {
        int v6 = -1;
      }
      *(_DWORD *)(a1 + 44) = v6;
    }

    if (*(_DWORD *)(a1 + 44))
    {
      if (*(void *)a1)
      {
        SEC_ASN1DecoderFinish(*(void *)a1);
        *(void *)a1 = 0LL;
      }

      ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0LL;
      }
      return *(unsigned int *)(a1 + 44);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void nss_cms_decoder_work_data(uint64_t a1, char *dataIn, size_t dataInLength, int a4)
{
  if (dataIn) {
    BOOL v4 = dataInLength == 0;
  }
  else {
    BOOL v4 = 1;
  }
  char v6 = v4 && a4 == 0;
  if (!HIDWORD(dataInLength) && (v6 & 1) == 0 && *(void *)(a1 + 24))
  {
    size_t v8 = dataInLength;
    uint64_t v9 = dataIn;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    BOOL v11 = v10 > 0x1E;
    int v12 = (1 << v10) & 0x6C000000;
    if (v11 || v12 == 0) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = *(void *)(a1 + 24);
    }
    uint64_t v15 = *(void *)(v14 + 96);
    if (v15)
    {
      unsigned int v33 = 0;
      unsigned int v17 = *(_DWORD *)(v15 + 12);
      if (a4) {
        int v18 = *(_DWORD *)(v15 + 12);
      }
      else {
        int v18 = 0;
      }
      unsigned int v19 = (dataInLength + v17 - 1) / v17;
      size_t v20 = v18 + v19 * v17;
      if (!dataInLength && !(_DWORD)v20)
      {
        uint64_t v9 = 0LL;
LABEL_46:
        int v21 = v9;
        goto LABEL_47;
      }

      if ((_DWORD)v20)
      {
        uint64_t v24 = (char *)PORT_Alloc(v18 + v19 * v17);
        if (!v24)
        {
          uint64_t v9 = 0LL;
          int Error = -8173;
          goto LABEL_45;
        }

        uint64_t v25 = v24;
        int v26 = SecCmsCipherContextCrypt(*(CCCryptorRef **)(v14 + 96), v24, &v33, v20, v9, v8, a4);
        uint64_t v9 = v25;
        if (v26)
        {
LABEL_34:
          int Error = PORT_GetError();
LABEL_45:
          *(_DWORD *)(a1 + 44) = Error;
          goto LABEL_46;
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      size_t v8 = v33;
      int v21 = v9;
      if (!v33)
      {
LABEL_47:
        if (v21) {
          free(v21);
        }
        return;
      }
    }

    else
    {
      int v21 = 0LL;
      if (!dataInLength) {
        goto LABEL_47;
      }
    }

    uint64_t v22 = *(void *)(v14 + 104);
    if (v22) {
      SecCmsDigestContextUpdate(v22, v9, v8);
    }
    int v23 = *(void (**)(void, char *, size_t))(a1 + 48);
    if (v23)
    {
      v23(*(void *)(a1 + 56), v9, v8);
    }

    else
    {
      uint64_t OID = *(void *)(v14 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v14), (*(void *)(v14 + 32) = OID) != 0LL))
      {
        if (*(_DWORD *)(OID + 16) == 25)
        {
          uint64_t v29 = *(void *)(v14 + 16);
          unint64_t v30 = *(void *)v29;
          if (v8 < 0x7FFFFFFFLL - *(void *)v29
            && ((uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 120LL), !v30)
              ? (uint64_t v32 = PORT_ArenaAlloc(v31, v8))
              : (uint64_t v32 = (uint64_t)PORT_ArenaGrow(v31, *(char **)(v29 + 8), *(void *)v29, v30 + v8)),
                v32))
          {
            *(void *)v29 += v8;
            *(void *)(v29 + _Block_object_dispose((const void *)(v1 - 64), 8) = v32;
            if (v9) {
              memcpy((void *)(v32 + v30), v9, v8);
            }
          }

          else
          {
            *(_DWORD *)(a1 + 44) = -8173;
          }
        }
      }
    }

    goto LABEL_47;
  }

uint64_t nss_cms_after_end(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16) - 25;
  uint64_t result = 0LL;
  switch(v1)
  {
    case 0:
    case 2:
    case 5:
      return result;
    case 1:
      uint64_t v4 = *(void *)(a1 + 24);
      if (!v4) {
        goto LABEL_8;
      }
      CFIndex v5 = *(uint64_t **)(v4 + 160);
      if (v5)
      {
        uint64_t v6 = *v5;
        if (*v5)
        {
          BOOL v7 = v5 + 1;
          do
          {
            *(void *)(v6 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = v4;
            uint64_t v8 = *v7++;
            uint64_t v6 = v8;
          }

          while (v8);
        }
      }

      uint64_t result = 0LL;
      break;
    case 4:
      if (*(void *)(a1 + 24)) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      break;
    default:
LABEL_8:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }

  return result;
}

void SecCmsDecoderDestroy(uint64_t *a1)
{
  a1[1] = 0LL;
  if (*a1) {
    SEC_ASN1DecoderFinish(*a1);
  }
  free(a1);
}

uint64_t SecCmsDecoderFinish(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = v4;
  if (v3)
  {
    if (!SEC_ASN1DecoderFinish(v3) && !nss_cms_after_end((uint64_t)a1))
    {
      uint64_t Error = 0LL;
      *a2 = v4;
      goto LABEL_8;
    }

    uint64_t v6 = a1[1];
  }

  if (v6) {
    SecCmsMessageDestroy(v4);
  }
  uint64_t Error = PORT_GetError();
LABEL_8:
  free(a1);
  ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0LL;
  }
  return Error;
}

uint64_t SecCmsMessageDecode( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v14 = 0LL;
  uint64_t v10 = SecCmsDecoderCreate(a2, a3, a3, a5, a6, a7, &v14);
  if ((_DWORD)v10) {
    return v10;
  }
  if ((*(void *)a1 & 0x8000000000000000LL) != 0) {
    return 4294967246LL;
  }
  int v12 = v14;
  uint64_t v13 = SecCmsDecoderUpdate((uint64_t)v14, *(char **)(a1 + 8), *(void *)a1);
  if ((_DWORD)v13)
  {
    uint64_t v10 = v13;
    SecCmsDecoderDestroy(v12);
    return v10;
  }

  return SecCmsDecoderFinish(v12, a8);
}

CFTypeID CMSDecoderGetTypeID(void)
{
  CFTypeID result = cmsDecoderTypeID;
  if (!cmsDecoderTypeID)
  {
    pthread_once(&CMSDecoderGetTypeID_once, (void (*)(void))cmsDecoderClassInitialize);
    return cmsDecoderTypeID;
  }

  return result;
}

uint64_t cmsDecoderClassInitialize()
{
  uint64_t result = _CFRuntimeRegisterClass();
  cmsDecoderCFTypeID TypeID = result;
  return result;
}

double cmsDecoderInit(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void cmsDecoderFinalize(void *a1)
{
  if (a1)
  {
    BOOL v2 = (uint64_t *)a1[3];
    if (v2)
    {
      SecCmsDecoderDestroy(v2);
      a1[5] = 0LL;
    }

    uint64_t v3 = (const void *)a1[4];
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = a1[5];
    if (v4)
    {
      SecCmsMessageDestroy(v4);
      a1[5] = 0LL;
    }
  }

OSStatus CMSDecoderCreate(CMSDecoderRef *cmsDecoderOut)
{
  if (!cmsDecoderTypeID) {
    pthread_once(&CMSDecoderGetTypeID_once, (void (*)(void))cmsDecoderClassInitialize);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return -108;
  }
  uint64_t v3 = (_CMSDecoder *)Instance;
  OSStatus result = 0;
  *((_DWORD *)v3 + 4) = 0;
  *cmsDecoderOut = v3;
  return result;
}

OSStatus CMSDecoderUpdateMessage(CMSDecoderRef cmsDecoder, const void *msgBytes, size_t msgBytesLen)
{
  if (!cmsDecoder || (int v4 = *((_DWORD *)cmsDecoder + 4), v4 == 2))
  {
    LODWORD(v7) = -50;
  }

  else
  {
    if (v4 != 1)
    {
      if (v4)
      {
        LODWORD(v7) = -2070;
        return v7;
      }

      uint64_t v7 = SecCmsDecoderCreate(0LL, 0LL, msgBytesLen, 0LL, 0LL, 0LL, (uint64_t **)cmsDecoder + 3);
      if ((_DWORD)v7)
      {
        unsigned int v8 = 0;
LABEL_12:
        LODWORD(v7) = cmsRtnToOSStatusDefault(v7, v8);
        return v7;
      }

      *((_DWORD *)cmsDecoder + 4) = 1;
    }

    uint64_t v7 = SecCmsDecoderUpdate(*((void *)cmsDecoder + 3), (char *)msgBytes, msgBytesLen);
    if ((_DWORD)v7)
    {
      unsigned int v8 = -25257;
      goto LABEL_12;
    }
  }

  return v7;
}

OSStatus CMSDecoderFinalizeMessage(CMSDecoderRef cmsDecoder)
{
  if (!cmsDecoder || *((_DWORD *)cmsDecoder + 4) != 1) {
    return -50;
  }
  BOOL v2 = (uint64_t *)((char *)cmsDecoder + 40);
  uint64_t v3 = SecCmsDecoderFinish(*((uint64_t **)cmsDecoder + 3), (uint64_t *)cmsDecoder + 5);
  *((_DWORD *)cmsDecoder + 4) = 2;
  *((void *)cmsDecoder + 3) = 0LL;
  if ((_DWORD)v3) {
    return cmsRtnToOSStatusDefault(v3, 0xFFFF9D57);
  }
  *((_BYTE *)cmsDecoder + 4_Block_object_dispose((const void *)(v1 - 64), 8) = SecCmsMessageIsEncrypted(*((void *)cmsDecoder + 5));
  uint64_t ChildContentInfo = *((void *)cmsDecoder + 5);
  if (ChildContentInfo)
  {
    int v6 = -1;
    do
    {
      uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v6;
    }

    while (ChildContentInfo);
    unsigned int v7 = 0;
    while (1)
    {
      uint64_t v8 = *v2;
      if (*v2) {
        BOOL v9 = v7 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      if (!v9)
      {
        unsigned int v10 = 1;
        do
        {
          uint64_t v8 = SecCmsContentInfoGetChildContentInfo(v8);
          if (!v8) {
            break;
          }
        }

        while (v10++ < v7);
      }

      uint64_t OID = *(void *)(v8 + 32);
      if (!OID)
      {
        uint64_t OID = SECOID_FindOID(v8);
        *(void *)(v8 + 32) = OID;
        if (!OID) {
          goto LABEL_25;
        }
      }

      if (*(_DWORD *)(OID + 16) != 26) {
        goto LABEL_25;
      }
      uint64_t v13 = *(void *)(v8 + 16);
      *((void *)cmsDecoder + 7) = v13;
      if (v13) {
        break;
      }
LABEL_26:
      BOOL v9 = v7++ == v6;
      if (v9) {
        return 0;
      }
    }

    uint64_t v14 = *(void *)(v13 + 32);
    if (!v14)
    {
      uint64_t v14 = SECOID_FindOID(v13);
      *(void *)(v13 + 32) = v14;
    }

    *((void *)cmsDecoder + 9) = v14;
LABEL_25:
    uint64_t v15 = *((void *)cmsDecoder + 7);
    if (v15) {
      goto LABEL_30;
    }
    goto LABEL_26;
  }

  uint64_t v15 = *((void *)cmsDecoder + 7);
  if (v15)
  {
LABEL_30:
    uint64_t v16 = *(uint64_t **)(v15 + 160);
    if (v16)
    {
      uint64_t v17 = *v16;
      if (*v16)
      {
        uint64_t v17 = 0LL;
        int v18 = v16 + 1;
        while (v18[v17++])
          ;
        uint64_t v17 = v17;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    *((void *)cmsDecoder + _Block_object_dispose((const void *)(v1 - 64), 8) = v17;
    if (*((void *)cmsDecoder + 4)) {
      return cmsDigestDetachedContent((uint64_t)cmsDecoder);
    }
  }

  return 0;
}

uint64_t cmsDigestDetachedContent(uint64_t a1)
{
  if (!*(void *)(a1 + 56)) {
    return 4294967246LL;
  }
  BOOL v2 = *(const __CFData **)(a1 + 32);
  if (!v2 || CFDataGetLength(v2) < 0) {
    return 4294967246LL;
  }
  uint64_t v3 = *(uint64_t **)(*(void *)(a1 + 56) + 136LL);
  if (!v3) {
    return 4294942039LL;
  }
  uint64_t started = SecCmsDigestContextStartMultiple(v3);
  if (!started) {
    return 4294967188LL;
  }
  uint64_t v5 = started;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 32));
  SecCmsDigestContextUpdate(v5, BytePtr, Length);
  uint64_t v8 = SecCmsSignedDataSetDigestContext(*(void **)(a1 + 56), v5);
  SecCmsDigestContextCancel(v5);
  if ((_DWORD)v8) {
    return cmsRtnToOSStatusDefault(v8, 0);
  }
  else {
    return 0LL;
  }
}

OSStatus CMSDecoderSetDetachedContent(CMSDecoderRef cmsDecoder, CFDataRef detachedContent)
{
  OSStatus result = -50;
  if (cmsDecoder && detachedContent)
  {
    *((void *)cmsDecoder + 4) = detachedContent;
    CFRetain(detachedContent);
    if (*((void *)cmsDecoder + 7)) {
      return cmsDigestDetachedContent((uint64_t)cmsDecoder);
    }
    else {
      return 0;
    }
  }

  return result;
}

OSStatus CMSDecoderCopyDetachedContent(CMSDecoderRef cmsDecoder, CFDataRef *detachedContentOut)
{
  OSStatus result = -50;
  if (cmsDecoder && detachedContentOut)
  {
    uint64_t v5 = (const void *)*((void *)cmsDecoder + 4);
    if (v5)
    {
      CFRetain(v5);
      int v6 = (const __CFData *)*((void *)cmsDecoder + 4);
    }

    else
    {
      int v6 = 0LL;
    }

    OSStatus result = 0;
    *detachedContentOut = v6;
  }

  return result;
}

OSStatus CMSDecoderGetNumSigners(CMSDecoderRef cmsDecoder, size_t *numSignersOut)
{
  OSStatus result = -50;
  if (cmsDecoder && numSignersOut && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    OSStatus result = 0;
    *numSignersOut = *((void *)cmsDecoder + 8);
  }

  return result;
}

OSStatus CMSDecoderCopySignerStatus( CMSDecoderRef cmsDecoder, size_t signerIndex, CFTypeRef policyOrArray, Boolean evaluateSecTrust, CMSSignerStatus *signerStatusOut, SecTrustRef *secTrustOut, OSStatus *certVerifyResultCodeOut)
{
  if (!cmsDecoder) {
    return -50;
  }
  OSStatus v8 = -50;
  if (signerStatusOut && policyOrArray && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    int v12 = evaluateSecTrust;
    int v13 = signerIndex;
    *signerStatusOut = kCMSSignerUnsigned;
    if (secTrustOut) {
      *secTrustOut = 0LL;
    }
    if (certVerifyResultCodeOut) {
      *certVerifyResultCodeOut = 0;
    }
    uint64_t v14 = *((void *)cmsDecoder + 7);
    if (!v14)
    {
      OSStatus v8 = 0;
      *signerStatusOut = kCMSSignerUnsigned;
      return v8;
    }

    if (*((void *)cmsDecoder + 8) <= signerIndex)
    {
      OSStatus v8 = 0;
      CMSSignerStatus v17 = kCMSSignerInvalidIndex;
    }

    else
    {
      if (*(void *)(v14 + 168))
      {
        CFTypeRef cf = 0LL;
        int v15 = SecCmsSignedDataVerifySignerInfo_internal(v14, signerIndex, policyOrArray, (SecTrustRef *)&cf);
        int v22 = -1431655766;
        if (secTrustOut)
        {
          CFTypeRef v16 = cf;
          *secTrustOut = (SecTrustRef)cf;
          if (v16) {
            CFRetain(v16);
          }
        }

        if (!*(void *)(*(void *)(*((void *)cmsDecoder + 7) + 160LL) + 8LL * v13)) {
          goto LABEL_18;
        }
        if (v12)
        {
          if (SecTrustEvaluateInternal((__SecTrust *)cf, &v22))
          {
LABEL_18:
            OSStatus v8 = -2070;
LABEL_33:
            if (cf) {
              CFRelease(cf);
            }
            return v8;
          }

          unsigned int v20 = v22 - 1;
          if ((v22 - 1) > 3)
          {
            OSStatus v18 = -67843;
            CMSSignerStatus v19 = kCMSSignerInvalidCert;
          }

          else
          {
            CMSSignerStatus v19 = dword_18065A270[v20];
            OSStatus v18 = dword_18065A280[v20];
          }
        }

        else
        {
          OSStatus v18 = 0;
          CMSSignerStatus v19 = kCMSSignerValid;
        }

        if (certVerifyResultCodeOut) {
          *certVerifyResultCodeOut = v18;
        }
        OSStatus v8 = 0;
        if (v15) {
          CMSSignerStatus v19 = kCMSSignerInvalidSignature;
        }
        *signerStatusOut = v19;
        goto LABEL_33;
      }

      OSStatus v8 = 0;
      CMSSignerStatus v17 = kCMSSignerNeedsDetachedContent;
    }

    *signerStatusOut = v17;
  }

  return v8;
}

OSStatus CMSDecoderCopySignerEmailAddress( CMSDecoderRef cmsDecoder, size_t signerIndex, CFStringRef *signerEmailAddressOut)
{
  OSStatus result = -50;
  if (cmsDecoder && signerEmailAddressOut)
  {
    uint64_t v6 = *((void *)cmsDecoder + 7);
    if (v6 && *((void *)cmsDecoder + 8) > signerIndex && *((_DWORD *)cmsDecoder + 4) == 2)
    {
      uint64_t v7 = *(void *)(*(void *)(v6 + 160) + 8LL * (int)signerIndex);
      if (v7)
      {
        SignerEmailAddress = (const __CFString *)SecCmsSignerInfoGetSignerEmailAddress(v7);
        OSStatus result = 0;
        *signerEmailAddressOut = SignerEmailAddress;
      }

      else
      {
        return -2070;
      }
    }

    else
    {
      return -50;
    }
  }

  return result;
}

OSStatus CMSDecoderCopySignerCert( CMSDecoderRef cmsDecoder, size_t signerIndex, SecCertificateRef *signerCertOut)
{
  OSStatus result = -50;
  if (cmsDecoder && signerCertOut)
  {
    uint64_t v6 = *((void *)cmsDecoder + 7);
    if (v6 && *((void *)cmsDecoder + 8) > signerIndex && *((_DWORD *)cmsDecoder + 4) == 2)
    {
      uint64_t v7 = *(void *)(*(void *)(v6 + 160) + 8LL * (int)signerIndex);
      if (v7
        && (SigningCert_internal = (void *)SecCmsSignerInfoGetSigningCert_internal(v7),
            (*signerCertOut = (SecCertificateRef)SigningCert_internal) != 0LL))
      {
        CFRetain(SigningCert_internal);
        return 0;
      }

      else
      {
        return -2070;
      }
    }

    else
    {
      return -50;
    }
  }

  return result;
}

OSStatus CMSDecoderIsContentEncrypted(CMSDecoderRef cmsDecoder, Boolean *isEncryptedOut)
{
  OSStatus result = -50;
  if (cmsDecoder && isEncryptedOut && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    OSStatus result = 0;
    *isEncryptedOut = *((_BYTE *)cmsDecoder + 48);
  }

  return result;
}

OSStatus CMSDecoderCopyEncapsulatedContentType(CMSDecoderRef cmsDecoder, CFDataRef *eContentTypeOut)
{
  OSStatus result = -50;
  if (cmsDecoder && eContentTypeOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) == 2)
    {
      if (!*((void *)cmsDecoder + 7))
      {
        uint64_t v6 = 0LL;
        goto LABEL_9;
      }

      uint64_t v5 = *((void *)cmsDecoder + 9);
      if ((*(void *)v5 & 0x8000000000000000LL) == 0)
      {
        uint64_t v6 = CFDataCreate(0LL, *(const UInt8 **)(v5 + 8), *(void *)v5);
LABEL_9:
        OSStatus result = 0;
        *eContentTypeOut = v6;
        return result;
      }
    }

    return -50;
  }

  return result;
}

OSStatus CMSDecoderCopyAllCerts(CMSDecoderRef cmsDecoder, CFArrayRef *certsOut)
{
  OSStatus result = -50;
  if (cmsDecoder && certsOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) == 2)
    {
      uint64_t v5 = *((void *)cmsDecoder + 7);
      if (v5 && (uint64_t v6 = *(uint64_t **)(v5 + 144)) != 0LL && *v6)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
        uint64_t v8 = *v6;
        if (*v6)
        {
          BOOL v9 = v6 + 1;
          while ((*(void *)v8 & 0x8000000000000000LL) == 0)
          {
            unsigned int v10 = SecCertificateCreateWithBytes(0LL, *(const void **)(v8 + 8), *(void *)v8);
            if (!v10)
            {
              if (Mutable) {
                CFRelease(Mutable);
              }
              return -26275;
            }

            int v11 = v10;
            CFArrayAppendValue(Mutable, v10);
            CFRelease(v11);
            uint64_t v12 = *v9++;
            uint64_t v8 = v12;
            if (!v12) {
              goto LABEL_12;
            }
          }

          if (Mutable) {
            CFRelease(Mutable);
          }
          return -108;
        }

        else
        {
LABEL_12:
          OSStatus result = 0;
          *certsOut = Mutable;
        }
      }

      else
      {
        OSStatus result = 0;
        *certsOut = 0LL;
      }
    }

    else
    {
      return -50;
    }
  }

  return result;
}

OSStatus CMSDecoderCopyContent(CMSDecoderRef cmsDecoder, CFDataRef *contentOut)
{
  OSStatus result = -50;
  if (cmsDecoder && contentOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) != 2) {
      return -50;
    }
    uint64_t v5 = *((void *)cmsDecoder + 5);
    if (!v5) {
      return -50;
    }
    uint64_t InnerContent = SecCmsContentInfoGetInnerContent(v5);
    if (InnerContent && (CFIndex v7 = *(void *)InnerContent) != 0)
    {
      if (v7 < 0) {
        return -108;
      }
      uint64_t v8 = CFDataCreate(0LL, *(const UInt8 **)(InnerContent + 8), v7);
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    OSStatus result = 0;
    *contentOut = v8;
  }

  return result;
}

uint64_t CMSDecoderGetCmsMessage(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(void *)(a1 + 40);
    }
  }

  return result;
}

uint64_t CMSDecoderSetDecoder(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      int v4 = *(_DWORD *)(a1 + 16);
      if ((v4 - 1) >= 2)
      {
        uint64_t result = 0LL;
        if (!v4)
        {
          *(void *)(a1 + 24) = a2;
          *(_DWORD *)(a1 + 16) = 1;
        }
      }
    }
  }

  return result;
}

uint64_t CMSDecoderGetDecoder(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(void *)(a1 + 24);
    }
  }

  return result;
}

OSStatus CMSDecoderCopySignerSigningTime( CMSDecoderRef cmsDecoder, size_t signerIndex, CFAbsoluteTime *signingTime)
{
  if (!cmsDecoder) {
    return -50;
  }
  if (!signingTime) {
    return -50;
  }
  uint64_t v4 = *((void *)cmsDecoder + 5);
  if (!v4) {
    return -50;
  }
  int v5 = signerIndex;
  int v6 = 0;
  uint64_t ChildContentInfo = *((void *)cmsDecoder + 5);
  do
  {
    uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
    ++v6;
  }

  while (ChildContentInfo);
  unsigned int v9 = 0;
  int v10 = v6 <= 1 ? 1 : v6;
  while (1)
  {
    uint64_t v11 = v4;
    if (v9)
    {
      unsigned int v12 = 1;
      uint64_t v11 = v4;
      do
      {
        uint64_t v11 = SecCmsContentInfoGetChildContentInfo(v11);
        if (!v11) {
          break;
        }
      }

      while (v12++ < v9);
    }

    uint64_t OID = *(void *)(v11 + 32);
    if (OID || (uint64_t OID = SECOID_FindOID(v11), (*(void *)(v11 + 32) = OID) != 0LL))
    {
      if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
      {
        uint64_t v16 = *(void *)(v11 + 16);
        if (v16) {
          break;
        }
      }
    }

    if (++v9 == v10) {
      return -50;
    }
  }

  uint64_t v18 = *(void *)(*(void *)(v16 + 160) + 8LL * v5);
  if (!v18) {
    return -50;
  }
  SecCmsSignerInfoGetSigningTime(v18, signingTime, v8);
  return result;
}

uint64_t CMSDecoderCopySignerAppleCodesigningHashAgility(uint64_t a1, int a2, void *a3)
{
  CFTypeRef v5 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t AppleCodesigningHashAgility = 4294967246LL;
  if (a1 && a3)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    if (!v7) {
      goto LABEL_30;
    }
    int v9 = 0;
    uint64_t ChildContentInfo = *(void *)(a1 + 40);
    do
    {
      uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v9;
    }

    while (ChildContentInfo);
    unsigned int v11 = 0;
    int v12 = v9 <= 1 ? 1 : v9;
    while (1)
    {
      uint64_t v13 = v7;
      if (v11)
      {
        unsigned int v14 = 1;
        uint64_t v13 = v7;
        do
        {
          uint64_t v13 = SecCmsContentInfoGetChildContentInfo(v13);
          if (!v13) {
            break;
          }
        }

        while (v14++ < v11);
      }

      uint64_t OID = *(void *)(v13 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v13), (*(void *)(v13 + 32) = OID) != 0LL))
      {
        if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
        {
          uint64_t v18 = *(void *)(v13 + 16);
          if (v18) {
            break;
          }
        }
      }

      if (++v11 == v12)
      {
        CFTypeRef v5 = 0LL;
LABEL_23:
        uint64_t AppleCodesigningHashAgility = 4294967246LL;
        goto LABEL_31;
      }
    }

    CFTypeRef v5 = *(CFTypeRef *)(*(void *)(v18 + 160) + 8LL * a2);
    if (!v5) {
      goto LABEL_23;
    }
    uint64_t AppleCodesigningHashAgility = SecCmsSignerInfoGetAppleCodesigningHashAgility((uint64_t)v5, (CFDataRef *)&cf);
    if ((_DWORD)AppleCodesigningHashAgility || cf == 0LL)
    {
LABEL_30:
      CFTypeRef v5 = 0LL;
    }

    else
    {
      CFTypeRef v5 = CFRetain(cf);
      uint64_t AppleCodesigningHashAgility = 0LL;
    }
  }

uint64_t CMSDecoderCopySignerAppleCodesigningHashAgilityV2(uint64_t a1, int a2, void *a3)
{
  CFTypeRef v5 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t AppleCodesigningHashAgilityV2 = 4294967246LL;
  if (a1 && a3)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    if (!v7) {
      goto LABEL_30;
    }
    int v9 = 0;
    uint64_t ChildContentInfo = *(void *)(a1 + 40);
    do
    {
      uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v9;
    }

    while (ChildContentInfo);
    unsigned int v11 = 0;
    int v12 = v9 <= 1 ? 1 : v9;
    while (1)
    {
      uint64_t v13 = v7;
      if (v11)
      {
        unsigned int v14 = 1;
        uint64_t v13 = v7;
        do
        {
          uint64_t v13 = SecCmsContentInfoGetChildContentInfo(v13);
          if (!v13) {
            break;
          }
        }

        while (v14++ < v11);
      }

      uint64_t OID = *(void *)(v13 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v13), (*(void *)(v13 + 32) = OID) != 0LL))
      {
        if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
        {
          uint64_t v18 = *(void *)(v13 + 16);
          if (v18) {
            break;
          }
        }
      }

      if (++v11 == v12)
      {
        CFTypeRef v5 = 0LL;
LABEL_23:
        uint64_t AppleCodesigningHashAgilityV2 = 4294967246LL;
        goto LABEL_31;
      }
    }

    CFTypeRef v5 = *(CFTypeRef *)(*(void *)(v18 + 160) + 8LL * a2);
    if (!v5) {
      goto LABEL_23;
    }
    uint64_t AppleCodesigningHashAgilityV2 = SecCmsSignerInfoGetAppleCodesigningHashAgilityV2( (uint64_t)v5,  (__CFDictionary **)&cf);
    if ((_DWORD)AppleCodesigningHashAgilityV2 || cf == 0LL)
    {
LABEL_30:
      CFTypeRef v5 = 0LL;
    }

    else
    {
      CFTypeRef v5 = CFRetain(cf);
      uint64_t AppleCodesigningHashAgilityV2 = 0LL;
    }
  }

double CMSDecoderCopySignerAppleExpirationTime(uint64_t a1, int a2, double *a3, double result)
{
  if (a1)
  {
    if (a3)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        int v7 = 0;
        uint64_t ChildContentInfo = *(void *)(a1 + 40);
        do
        {
          uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
          ++v7;
        }

        while (ChildContentInfo);
        unsigned int v9 = 0;
        if (v7 <= 1) {
          int v10 = 1;
        }
        else {
          int v10 = v7;
        }
        while (1)
        {
          uint64_t v11 = v5;
          if (v9)
          {
            unsigned int v12 = 1;
            uint64_t v11 = v5;
            do
            {
              uint64_t v11 = SecCmsContentInfoGetChildContentInfo(v11);
              if (!v11) {
                break;
              }
            }

            while (v12++ < v9);
          }

          uint64_t OID = *(void *)(v11 + 32);
          if (OID || (uint64_t OID = SECOID_FindOID(v11), (*(void *)(v11 + 32) = OID) != 0LL))
          {
            if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
            {
              uint64_t v16 = *(void *)(v11 + 16);
              if (v16) {
                break;
              }
            }
          }

          if (++v9 == v10) {
            return result;
          }
        }

        uint64_t v17 = *(void *)(*(void *)(v16 + 160) + 8LL * a2);
        if (v17) {
          return SecCmsSignerInfoGetAppleExpirationTime(v17, a3, result);
        }
      }
    }
  }

  return result;
}

uint64_t nss_cms_recipients_traverse(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v5 = 0LL;
    int v6 = 0;
    uint64_t v7 = 0LL;
    while (1)
    {
      if (*(_DWORD *)v3 != 1)
      {
        if (!*(_DWORD *)v3)
        {
          if (a2)
          {
            double v8 = PORT_ZAlloc(0x28uLL);
            if (!v8) {
              return 0xFFFFFFFFLL;
            }
            _DWORD *v8 = v5;
            v8[1] = -1;
            unsigned int v9 = *(_DWORD *)(v3 + 24);
            if (v9 <= 1)
            {
              v8[2] = v9;
              *((void *)v8 + 2) = *(void *)(v3 + 32);
            }

            *(void *)(a2 + 8LL * v6++) = v8;
          }

          else
          {
            uint64_t v7 = (v7 + 1);
          }
        }

        goto LABEL_25;
      }

      int v10 = *(uint64_t **)(v3 + 128);
      if (v10)
      {
        uint64_t v11 = *v10;
        if (*v10) {
          break;
        }
      }

void nss_cms_recipient_list_destroy(char *a1)
{
  BOOL v2 = *(void **)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = a1 + 8;
    do
    {
      uint64_t v4 = (const void *)v2[3];
      if (v4)
      {
        v2[3] = 0LL;
        CFRelease(v4);
      }

      uint64_t v5 = (const void *)v2[4];
      if (v5)
      {
        void v2[4] = 0LL;
        CFRelease(v5);
      }

      free(v2);
      int v6 = (void *)*v3++;
      BOOL v2 = v6;
    }

    while (v6);
  }

  free(a1);
}

uint64_t SecSMIMEFindBulkAlgForRecipients(__SecCertificate **a1, _DWORD *a2, _DWORD *a3)
{
  int v6 = PORT_NewArena(1024);
  uint64_t v7 = 65545LL;
  if (v6)
  {
    double v8 = v6;
    uint64_t v9 = PORT_ArenaAlloc((uint64_t)v6, 0x24uLL);
    uint64_t v10 = v9;
    if (v9)
    {
      *(_DWORD *)(v9 + 32) = 0;
      *(_OWORD *)uint64_t v9 = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
    }

    uint64_t v11 = PORT_ArenaAlloc((uint64_t)v8, 0x24uLL);
    uint64_t v7 = 65545LL;
    if (v11)
    {
      uint64_t v12 = v11;
      *(_DWORD *)(v11 + 32) = 0;
      *(_OWORD *)uint64_t v11 = 0u;
      *(_OWORD *)(v11 + 16) = 0u;
      uint64_t v7 = 65545LL;
      if (v10)
      {
        uint64_t v13 = *a1;
        if (*a1)
        {
          uint64_t v14 = 0LL;
          int v15 = a1 + 1;
          do
          {
            uint64_t v16 = v14;
            SecKeyRef v17 = SecCertificateCopyKey(v13);
            if (v17 && (SecKeyRef v18 = v17, Size = SecKeyGetSize((uint64_t)v17, 0), CFRelease(v18), Size >= 0x201))
            {
              ++*(_DWORD *)(v10 + 16);
              *(_DWORD *)(v12 + 16) += 9;
              int v20 = 8;
            }

            else
            {
              int v20 = 9;
            }

            ++*(_DWORD *)(v10 + 4);
            *(_DWORD *)(v12 + 4) += v20;
            uint64_t v14 = v16 + 1;
            uint64_t v13 = v15[v16];
          }

          while (v13);
        }

        else
        {
          LODWORD(v14) = 0;
        }

        unint64_t v21 = 0LL;
        int v22 = 0;
        uint64_t v7 = 65545LL;
        int v23 = smime_cipher_map;
        do
        {
          if (*(_DWORD *)(v10 + 4 * v21) == (_DWORD)v14 && ((0xDuLL >> v21) & 1) == 0 && v21 >= 4 && *v23 != 65561)
          {
            int v24 = *(_DWORD *)(v12 + 4 * v21);
            if (v24 >= v22) {
              uint64_t v7 = *v23;
            }
            if (v24 > v22) {
              int v22 = *(_DWORD *)(v12 + 4 * v21);
            }
          }

          ++v21;
          v23 += 4;
        }

        while (v21 != 9);
      }
    }

    PORT_FreeArena(v8, 0);
  }

  int v25 = smime_keysize_by_cipher(v7);
  uint64_t v26 = 0LL;
  if (v25 < 128) {
    uint64_t v27 = 65546LL;
  }
  else {
    uint64_t v27 = v7;
  }
  CFIndex v28 = smime_cipher_map;
  while (1)
  {
    uint64_t v29 = *v28;
    v28 += 4;
    if (v29 == v27) {
      break;
    }
    if (++v26 == 9) {
      return 0xFFFFFFFFLL;
    }
  }

  if ((v26 & 0x80000000) == 0)
  {
    unint64_t v30 = &smime_cipher_map[4 * v26];
    *a2 = *((_DWORD *)v30 + 2);
    int v31 = smime_keysize_by_cipher(*v30);
    uint64_t result = 0LL;
    *a3 = v31;
    return result;
  }

  return 0xFFFFFFFFLL;
}

uint64_t smime_keysize_by_cipher(uint64_t a1)
{
  uint64_t v1 = a1 - 65537;
  uint64_t result = 40LL;
  switch(v1)
  {
    case 0LL:
      return result;
    case 1LL:
    case 8LL:
      uint64_t result = 64LL;
      break;
    case 2LL:
      uint64_t result = 128LL;
      break;
    case 9LL:
      uint64_t result = 192LL;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }

  return result;
}

void *SecSMIMEGetCertFromEncryptionKeyPreference(int64_t **a1, uint64_t a2)
{
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v16 = (CFIndex *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = PORT_NewArena(1024);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  if (SEC_ASN1Decode( (uint64_t)v4,  (uint64_t)&v15,  (uint64_t)&smime_encryptionkeypref_template,  *(char **)(a2 + 8),  *(void *)a2))
  {
    PORT_FreeArena(v5, 0);
    return 0LL;
  }

  if (a1 && *a1)
  {
    uint64_t v8 = 0LL;
    while (a1[++v8])
      ;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, v8, MEMORY[0x189605228]);
    do
    {
      int64_t v11 = **a1;
      if ((v11 & 0x8000000000000000LL) == 0)
      {
        uint64_t v12 = SecCertificateCreateWithBytes(0LL, (const void *)(*a1)[1], v11);
        if (v12)
        {
          uint64_t v13 = v12;
          CFArrayAppendValue(Mutable, v12);
          CFRelease(v13);
        }
      }

      ++a1;
      --v8;
    }

    while (v8);
  }

  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  }

  if (!CFArrayGetCount(Mutable) && Mutable)
  {
    CFRelease(Mutable);
    CFMutableArrayRef Mutable = 0LL;
  }

  if ((_DWORD)v15 == 2 || (_DWORD)v15 == 1)
  {
    uint64_t v14 = (void *)CERT_FindBySubjectKeyID(Mutable, @"cert", v16);
    goto LABEL_25;
  }

  if (!(_DWORD)v15)
  {
    uint64_t v14 = CERT_FindByIssuerAndSN(Mutable, @"cert", (uint64_t)v16);
LABEL_25:
    int v6 = v14;
    goto LABEL_27;
  }

  int v6 = 0LL;
LABEL_27:
  PORT_FreeArena(v5, 0);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v6;
}

uint64_t SecCmsEncoderCreate( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  ThreadErrInfo = PR_getThreadErrInfo(1, &v27);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0LL;
  }
  a1[17] = a6;
  a1[18] = a7;
  a1[19] = a8;
  SecKeyRef v17 = PORT_ZAlloc(0x50uLL);
  if (!v17) {
    return 4294967188LL;
  }
  SecKeyRef v18 = v17;
  *((void *)v17 + 5) = a2;
  uint64_t v19 = (uint64_t)(v17 + 40);
  *((void *)v17 + 2) = a1;
  *((void *)v17 + 6) = a3;
  *((void *)v17 + 7) = a4;
  *((_DWORD *)v17 + 6) = 0;
  uint64_t OID = a1[4];
  if (!OID)
  {
    uint64_t OID = SECOID_FindOID((uint64_t)a1);
    a1[4] = OID;
    if (!OID)
    {
      uint64_t Error = 4294967246LL;
LABEL_17:
      free(v18);
      return Error;
    }
  }

  uint64_t Error = 4294967246LL;
  switch(*(_DWORD *)(OID + 16))
  {
    case 0x1A:
      uint64_t v22 = SecCmsSignedDataEncodeBeforeStart(a1[2]);
      break;
    case 0x1B:
      uint64_t v22 = SecCmsEnvelopedDataEncodeBeforeStart(a1[2]);
      break;
    case 0x1D:
      uint64_t v22 = SecCmsDigestedDataEncodeBeforeStart((void *)a1[2]);
      break;
    case 0x1E:
      uint64_t v22 = SecCmsEncryptedDataEncodeBeforeStart((void *)a1[2]);
      break;
    default:
      goto LABEL_17;
  }

  uint64_t Error = v22;
  if ((_DWORD)v22) {
    goto LABEL_17;
  }
  uint64_t v23 = SEC_ASN1EncoderStart((uint64_t)a1, (uint64_t)&SecCmsMessageTemplate, (uint64_t)nss_cms_encoder_out, v19);
  *(void *)SecKeyRef v18 = v23;
  if (v23)
  {
    v18[8] = 0;
    *(_DWORD *)(v23 + 20) = 1;
    *(void *)(v23 + 32) = nss_cms_encoder_notify;
    *(void *)(v23 + 40) = v18;
    if (!SEC_ASN1EncoderUpdate(v23, 0LL, 0LL))
    {
      uint64_t Error = 0LL;
      *a9 = v18;
      return Error;
    }

    uint64_t Error = PORT_GetError();
    free(v18);
    int v24 = (int *)&v29;
  }

  else
  {
    uint64_t Error = PORT_GetError();
    free(v18);
    int v24 = (int *)&v28;
  }

  uint64_t v26 = PR_getThreadErrInfo(1, v24);
  if (v26) {
    void *v26 = 0LL;
  }
  return Error;
}

void nss_cms_encoder_out(uint64_t a1, UInt8 *bytes, unint64_t length)
{
  if (*(void *)a1) {
    (*(void (**)(void, UInt8 *, unint64_t))a1)(*(void *)(a1 + 8), bytes, length);
  }
  if (length <= 0x7FFFFFFFFFFFFFFELL)
  {
    int v6 = *(__CFData **)(a1 + 16);
    if (v6) {
      CFDataAppendBytes(v6, bytes, length);
    }
  }

void nss_cms_encoder_notify(uint64_t a1, int a2, uint64_t a3)
{
  v40[2] = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 16);
  unsigned int v7 = *(_DWORD *)(a1 + 24);
  if (v7 > 0x1E) {
    goto LABEL_26;
  }
  if (((1 << v7) & 0x6C000000) == 0)
  {
    if (v7 == 25)
    {
      if (!a2 || v6 + 72 != a3) {
        return;
      }
      uint64_t v17 = *(void *)(v6 + 16);
      if (!v17)
      {
        uint64_t v36 = *(void *)a1;
        *(_DWORD *)(*(void *)a1 + 24LL) = 1;
LABEL_71:
        *(void *)(v36 + 32) = 0LL;
        *(void *)(v36 + 40) = 0LL;
        return;
      }

      nss_cms_encoder_work_data(a1, *(char **)(v17 + 8), *(void *)v17, 1, 1);
LABEL_70:
      uint64_t v36 = *(void *)a1;
      goto LABEL_71;
    }

LABEL_49:
      uint64_t v23 = *(uint64_t **)(a1 + 32);
      if (v23)
      {
LABEL_50:
        unsigned int v26 = *(_DWORD *)(a1 + 24);
        if (v26 > 0x1E || ((1 << v26) & 0x6C000000) == 0) {
          uint64_t v23 = 0LL;
        }
      }

                          free(v25);
                          v11[v20] = *(void *)(*(void *)(a1 + 24) + 8 * v20);
                          v14[v20] = v17;
                          break;
                      }
                    }

                    else
                    {
                      *uint64_t v17 = 0LL;
                      v17[1] = 0LL;
                    }

                    ++v20;
                    v17 += 2;
                    uint64_t v27 = v20;
                    break;
                }

                goto LABEL_53;
              }
            }
          }

          break;
        }
      }
    }
  }

        char v29 = 0LL;
        goto LABEL_50;
      }

      goto LABEL_50;
    }
  }

  char v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))*((void *)v7 + 1);
  if (v29 && (v8 & 0x4000) != 0)
  {
    if (*v29)
    {
      unint64_t v30 = (*v29)(v28 - v7[1], 0LL, a2, a3);
      goto LABEL_48;
    }

    goto LABEL_49;
  }

    *(void *)&CFTypeRef valuePtr = v34;
    if (!SEC_ASN1EncodeItem(a1, &context, (uint64_t)&valuePtr, (uint64_t)kSecAsn1SequenceOfObjectIDTemplate))
    {
      uint64_t v70 = @"failed to encode EKUs";
      unint64_t v71 = -26276;
LABEL_81:
      a4 = v78;
      SecError(v71, v78, v70);
      SecError(-50, (__CFString **)&cf, @"failed to make EKU extension");
      goto LABEL_83;
    }

    *(_OWORD *)&v11[6 * v76 + 4] = context;
    uint64_t v47 = &v11[6 * v76];
    void *v47 = 3LL;
    v47[1] = &_oidExtendedKeyUsage;
    uint64_t v16 = v76 + 1;
    a3 = v77;
    a4 = v78;
  }

  uint64_t v48 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"keyUsage");
  int v80 = 0uLL;
  if (v48)
  {
    int v49 = v48;
    unint64_t v50 = CFGetTypeID(v48);
    if (v50 != CFNumberGetTypeID()
      || (LODWORD(valuePtr) = -1431655766, !CFNumberGetValue(v49, kCFNumberIntType, &valuePtr)))
    {
      SecError(-50, (__CFString **)&cf, @"failed to get key usage value");
      goto LABEL_83;
    }

    uint64_t v51 = valuePtr;
    if ((int)valuePtr >= 1)
    {
      LODWORD(v52) = 0;
      int v53 = 0;
      uint64_t v54 = 0x80000000;
      for (CFIndex i = 1; i != 10; ++i)
      {
        v53 |= ((int)(v51 << 31) >> 31) & v54;
        if ((v51 & 1) != 0) {
          uint64_t v52 = i;
        }
        else {
          uint64_t v52 = v52;
        }
        v51 >>= 1;
        v54 >>= 1;
      }

      LODWORD(valuePtr) = v51;
      LODWORD(v82) = v53;
      *(void *)&uint64_t context = v52;
      *((void *)&context + 1) = (char *)&v82 - (v52 >> 3) + 3;
      if (!SEC_ASN1EncodeItem(a1, &v80, (uint64_t)&context, (uint64_t)kSecAsn1BitStringTemplate))
      {
        SecError(-26276, (__CFString **)&cf, @"failed to encode keyUsage");
        goto LABEL_83;
      }

      uint64_t v56 = &v11[6 * v16];
      *uint64_t v56 = 3LL;
      v56[1] = &_oidKeyUsage;
      *((_OWORD *)v56 + 1) = asn1_true;
      *((_OWORD *)v56 + 2) = v80;
      ++v16;
    }
  }

  uint64_t v57 = v16;
  uint64_t v58 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"certificateExtensions");
  if (v58)
  {
    __int128 v59 = v58;
    uint64_t v60 = CFGetTypeID(v58);
    if (v60 != CFDictionaryGetTypeID())
    {
      __int128 v75 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl( &dword_1804F4000,  v75,  OS_LOG_TYPE_DEFAULT,  "csr: wrong value type for custom extensions",  (uint8_t *)&context,  2u);
      }

      goto LABEL_83;
    }

    *(void *)&uint64_t context = a1;
    *((void *)&context + 1) = v11;
    int v85 = v16 | 0xA00000000LL;
    int v86 = (__CFString **)0xAAAAAAAAAAAAAA01LL;
    int v87 = a4;
    CFDictionaryApplyFunction(v59, (CFDictionaryApplierFunction)add_custom_extension, &context);
    uint64_t v57 = v85;
  }

  uint64_t v61 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"certificateExtensionsEncoded");
  if (v61)
  {
    uint64_t v62 = v61;
    uint64_t v63 = CFGetTypeID(v61);
    if (v63 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for custom extensions");
      goto LABEL_83;
    }

    *(void *)&uint64_t context = a1;
    *((void *)&context + 1) = v11;
    int v85 = v57 | 0xA00000000LL;
    int v86 = (__CFString **)0xAAAAAAAAAAAAAA00LL;
    int v87 = a4;
    CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)add_custom_extension, &context);
    uint64_t v57 = v85;
  }

  if (v57)
  {
    int v64 = v57;
    uint64_t v65 = v9;
    size_t v66 = v11;
    do
    {
      uint64_t v67 = *v66;
      v66 += 6;
      if (v67) {
        CFIndex v68 = v11;
      }
      else {
        CFIndex v68 = 0LL;
      }
      *v65++ = v68;
      uint64_t v11 = v66;
      --v64;
    }

    while (v64);
  }

  *a3 = v9;
  return 1LL;
}

  uint64_t v34 = *(void **)(*((void *)&md + 1) + 40LL);
  if (a3)
  {
    *a3 = v34;
  }

  else
  {
    *(void *)(*((void *)&md + 1) + 40LL) = 0LL;
  }

  unsigned int v26 = (id)v49[5];
  _Block_object_dispose(&md, 8);

LABEL_57:
LABEL_58:
  _Block_object_dispose(&v48, 8);

  return v26;
}

        uint64_t v10 = 0LL;
LABEL_50:

LABEL_51:
        int v22 = (const void *)*((void *)this + 80);
        if (v22) {
          CFRelease(v22);
        }
        *((void *)this + 80) = v10;
        _Block_object_dispose(&v24, 8);
        Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        uint64_t result = *((void *)this + 80);
        break;
      default:
        uint64_t v15 = (id)v25[5];
        uint64_t v16 = v15;
        if (v15 && [v15 count])
        {
          uint64_t v40 = @"cdhash";
          v38[0] = @"$in";
          v39[0] = v16;
          [MEMORY[0x189603F68] dictionaryWithObjects:v39 forKeys:v38 count:1];
          uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          *(void *)&__int128 buf = v17;
          uint64_t v10 = [MEMORY[0x189603F68] dictionaryWithObjects:&buf forKeys:&v40 count:1];
        }

        else
        {
          secLogObjForScope("SecError");
          uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "defaultAdhocLWCR";
            _os_log_impl( &dword_1804F4000,  v17,  OS_LOG_TYPE_DEFAULT,  "%s: no cdhashes for code, cannot generate a LWCR",  (uint8_t *)&buf,  0xCu);
          }

          uint64_t v10 = 0LL;
        }

        goto LABEL_51;
    }
  }

  return result;
}

    switch(v7->fts_info)
    {
      case 1u:
        unsigned int v28 = (os_log_s *)secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          fts_path = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = fts_path;
          _os_log_debug_impl(&dword_1804F4000, v28, OS_LOG_TYPE_DEBUG, "entering %s", (uint8_t *)&v84, 0xCu);
        }

        ++GKBIS_Num_dirs;
        if (((v64 | v5) & 1) != 0) {
          goto LABEL_122;
        }
        std::string::basic_string[abi:ne180100]<0>(v68, (char *)p_str);
        Rule = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)v68);
        unint64_t v30 = Rule;
        if (v69 < 0)
        {
          operator delete(v68[0]);
          if (!v30) {
            goto LABEL_121;
          }
        }

        else if (!Rule)
        {
          goto LABEL_121;
        }

        uint64_t v45 = *(unsigned int *)(v30 + 36);
        if ((v45 & 4) != 0)
        {
          if (strchr(v7->fts_name, 46))
          {
            std::string::basic_string[abi:ne180100]<0>(v66, (char *)p_str);
            (*(void (**)(uint64_t, FTSENT *, uint64_t, void **, uint64_t))(a2 + 16))(a2, v7, v45, v66, v30);
            if (v67 < 0) {
              operator delete(v66[0]);
            }
LABEL_120:
            fts_set(*(FTS **)(a1 + 48), v7, 4);
          }

LABEL_53:
      uint64_t v27 = v23[4];
      if (!v27)
      {
        uint64_t v27 = SECOID_FindOID((uint64_t)v23);
        void v23[4] = v27;
        if (!v27) {
          goto LABEL_64;
        }
      }

      unsigned int v28 = *(_DWORD *)(v27 + 16);
      if (v28 > 0x1E) {
        goto LABEL_64;
      }
      if (((1 << v28) & 0x6C000000) != 0)
      {
        char v29 = PORT_ZAlloc(0x50uLL);
        if (v29)
        {
          unint64_t v30 = v29;
          *((_DWORD *)v29 + 6) = v28;
          uint64_t v31 = v23[2];
          *((void *)v29 + 5) = nss_cms_encoder_update;
          uint64_t v32 = (uint64_t)(v29 + 40);
          *((void *)v29 + 4) = v31;
          *((void *)v29 + 6) = a1;
          *((void *)v29 + 7) = 0LL;
          *((void *)v29 + 2) = *(void *)(a1 + 16);
          unsigned int v33 = v28 - 26;
          if (v28 != 28)
          {
            uint64_t v34 = (uint64_t)*(&off_18966A918 + v33);
            switch(v33)
            {
              case 0u:
                int v35 = SecCmsSignedDataEncodeBeforeStart(v23[2]);
                goto LABEL_76;
              case 1u:
                int v35 = SecCmsEnvelopedDataEncodeBeforeStart(v23[2]);
                goto LABEL_76;
              case 3u:
                int v35 = SecCmsDigestedDataEncodeBeforeStart((void *)v23[2]);
                goto LABEL_76;
              case 4u:
                int v35 = SecCmsEncryptedDataEncodeBeforeStart((void *)v23[2]);
LABEL_76:
                if (!v35) {
                  goto LABEL_77;
                }
                goto LABEL_79;
              default:
LABEL_77:
                uint64_t v38 = SEC_ASN1EncoderStart(v23[2], v34, (uint64_t)nss_cms_encoder_out, v32);
                *(void *)unint64_t v30 = v38;
                if (!v38) {
                  goto LABEL_81;
                }
                v30[8] = 0;
                *(_DWORD *)(v38 + 20) = 1;
                *(void *)(v38 + 32) = nss_cms_encoder_notify;
                *(void *)(v38 + 40) = v30;
                *(void *)(a1 + 72) = v30;
                break;
            }

            return;
          }

  uint64_t result = sec_asn1e_contents_length(v11, (char *)a2 + *(unsigned int *)(v11 + 4), v10, a4, a5);
  if ((v9 & 0x100) != 0 && !result)
  {
LABEL_99:
    int v24 = 3;
    goto LABEL_100;
  }

  if ((v9 & 0x200) != 0)
  {
    if (*a5)
    {
      if (*a5 != 1) {
        return result;
      }
LABEL_104:
      *a5 = 0;
      return result;
    }

    uint64_t v32 = 1LL;
    if (result >= 0x80)
    {
      unsigned int v33 = result;
      do
      {
        ++v32;
        uint64_t v31 = v33 > 0xFF;
        v33 >>= 8;
      }

      while (v31);
    }

    result += v32 + 1;
  }

  return result;
}

  LODWORD(v51) = 0;
  unsigned int v33 = (const CFArrayCallBacks *)MEMORY[0x189605228];
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  int v35 = CFArrayCreateMutable(0LL, 0LL, v33);
  *(void *)&uint64_t context = Mutable;
  *((void *)&context + 1) = &v51;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)collect_certs, &context);
  if (!(_DWORD)v51)
  {
    uint64_t v36 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    *(void *)&uint64_t v47 = v36;
    *((void *)&v47 + 1) = v35;
    *(void *)&uint64_t v48 = Mutable;
    *((void *)&v48 + 1) = &v51;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)build_trust_chains, &v47);
    *items = v36;
  }

  if (v35) {
    CFRelease(v35);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_59:
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  SecAsn1CoderRelease(coder);
  if ((_DWORD)v51)
  {
    if ((_DWORD)v51 == 2)
    {
      return -25293;
    }

    else if ((_DWORD)v51 == 1)
    {
      return -26275;
    }

    else
    {
      return -26276;
    }
  }

  else if (options)
  {
    uint64_t v38 = CFDictionaryGetValue(options, @"nleg");
    int v37 = 0;
    if (v38 && v38 != (const void *)*MEMORY[0x189604DE0])
    {
      *(void *)&uint64_t context = 0LL;
      *((void *)&context + 1) = &context;
      uint64_t v45 = 0x2000000000LL;
      uint64_t v46 = 0;
      uint64_t v39 = *items;
      *(void *)&uint64_t v47 = MEMORY[0x1895F87A8];
      *((void *)&v47 + 1) = 0x40000000LL;
      *(void *)&uint64_t v48 = __SecPKCS12ImportToModernKeychain_block_invoke;
      *((void *)&v48 + 1) = &unk_189670208;
      *(void *)&int v49 = &context;
      *((void *)&v49 + 1) = options;
      v53.CFIndex length = CFArrayGetCount(v39);
      v53.location = 0LL;
      CFArrayApplyFunction(v39, v53, (CFArrayApplierFunction)apply_block_1_8757, &v47);
      int v37 = *(_DWORD *)(*((void *)&context + 1) + 24LL);
      _Block_object_dispose(&context, 8);
    }
  }

  else
  {
    return 0;
  }

  return v37;
}

  objc_autoreleasePoolPop(v8);
  return Mutable;
}

          operator delete(__p);
          if (!v36)
          {
LABEL_54:
            LOBYTE(v57) = 1;
            int v37 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
            uint64_t v39 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x288,  *(void *)(v37 + 200),  v38);
            (*(void (**)(void **__return_ptr))(**(void **)(a1 + 32) + 40LL))(&__p);
            if ((v51 & 0x80u) == 0) {
              uint64_t v40 = (char *)&__p;
            }
            else {
              uint64_t v40 = (char *)__p;
            }
            __int128 v41 = Security::CodeSigning::DiskRep::bestGuess(v40, (unsigned int *)v53);
            Security::CodeSigning::SecStaticCode::SecStaticCode(v39, (Security::CodeSigning::DiskRep *)v41, 0);
            Security::SecPointerBase::assign((Security::SecPointerBase *)&v52, v39);
            LOBYTE(v57) = 0;
          }

LABEL_79:
          if (*(void *)v30) {
            PORT_FreeArena(**(void ***)v30, 0);
          }
LABEL_81:
          free(v30);
        }

LABEL_82:
        *(_DWORD *)(a1 + 64) = PORT_GetError();
        uint64_t v39 = PR_getThreadErrInfo(1, (int *)v40);
        if (v39) {
          *uint64_t v39 = 0LL;
        }
        return;
      }

      if (v28 == 25) {
        *(void *)(a1 + 72) = 0LL;
      }
      else {
LABEL_64:
      }
        *(_DWORD *)(a1 + 64) = -8183;
      break;
    default:
      goto LABEL_82;
  }

      *(void *)&uint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int16 v123 = v62;
      *(_OWORD *)&v122[16] = v62;
      *(_OWORD *)int v122 = v62;
      uint64_t v121 = v62;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = v62;
      unint64_t v124 = (dispatch_group_t)0xAAAAAAAAAAAAAAAALL;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_189676D58;
      Security::Mutex::Mutex((pthread_mutex_t *)&buf.__r_.__value_.__r.__words[1]);
      LOBYTE(v123) = 0;
      *((void *)&v123 + 1) = 0LL;
      unint64_t v124 = dispatch_group_create();
      theDict = 0LL;
      p_theDict = &theDict;
      CCOptions v107 = 0x3002000000LL;
      CCAlgorithm v108 = __Block_byref_object_copy__27;
      unsigned int v109 = __Block_byref_object_dispose__28;
      v110[0] = (const void *)0xAAAAAAAAAAAAAAAALL;
      uint64_t v63 = *(void *)&v111[1];
      int v64 = CFDictionaryCreateMutableCopy(0LL, 0LL, *(CFDictionaryRef *)&v111[1]);
      if (!v64) {
        Security::CFError::throwMe(0LL);
      }
      v110[0] = v64;
      memset(&context, 170, sizeof(context));
      uint64_t v65 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(this);
      Security::cfString((Security *)&context, v65);
      *(void *)&size_t v66 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
      unsigned int v118 = v66;
      int v119 = v66;
      size_t v116 = v66;
      uint64_t v117 = v66;
      unint64_t v114 = v66;
      unint64_t v115 = v66;
      Security::CodeSigning::ResourceBuilder::ResourceBuilder( (std::string::size_type)&v114,  (uint64_t)&context,  &context,  *(const void **)&v111[3],  (a2 & 0x10) != 0,  (uint64_t)this + 144);
      *((void *)this + 41) = &v114;
      (*(void (**)(void, __int128 *))(**((void **)this + 4) + 64LL))(*((void *)this + 4), &v114);
      if ((a2 & 0x40000000) != 0)
      {
        *(void *)&uint64_t v98 = MEMORY[0x1895F87A8];
        *((void *)&v98 + 1) = 0x40000000LL;
        BOOL v99 = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke;
        CFIndex v100 = &__block_descriptor_tmp_33_14749;
        uint64_t v103 = a2;
        uint64_t v101 = this;
        uint64_t v102 = &buf;
        uint64_t v67 = &v98;
      }

      else
      {
        uint64_t v67 = 0LL;
      }

      int v86 = MEMORY[0x1895F87A8];
      int v87 = 0x40000000LL;
      int v88 = (uint64_t)___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_2;
      int v89 = &unk_1896781D8;
      uint64_t v90 = &theDict;
      unsigned int v91 = this;
      CFDataRef v96 = v30;
      CFNumberRef v97 = v28;
      uint64_t v94 = a2;
      unint64_t v95 = v111[0];
      uint64_t v92 = v63;
      CFNumberRef v93 = &buf;
      Security::CodeSigning::ResourceBuilder::scan((uint64_t)&v114, (uint64_t)&v86, (uint64_t)v67);
      Security::Dispatch::Group::wait((Security::Dispatch::Group *)&buf);
      if (!v28)
      {
        CFIndex v68 = CFDictionaryGetCount(p_theDict[5]);
        if (v68)
        {
          CFDataRef v69 = (os_log_s *)secLogObjForScope("staticCode");
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t v125 = 67109120;
            *(_DWORD *)&v125[4] = v68;
            _os_log_debug_impl( &dword_1804F4000,  v69,  OS_LOG_TYPE_DEBUG,  "%d sealed resource(s) not found in code",  v125,  8u);
          }

          CFDictionaryApplyFunction( p_theDict[5],  (CFDictionaryApplierFunction)Security::CodeSigning::SecStaticCode::checkOptionalResource,  *((void **)this + 25));
        }
      }

      *((_BYTE *)this + 192) = 1;
      *((_BYTE *)this + 193) = (a2 & 8) != 0;
      Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)&v114);
      _Block_object_dispose(&theDict, 8);
      Security::CFRef<__CFDictionary *>::~CFRef(v110);
      Security::Dispatch::Group::~Group((Security::Dispatch::Group *)&buf);
      Security::CodeSigning::SecStaticCode::validateResources::_DTFrameCODESIGN_EVAL_STATIC_RESOURCES::~_DTFrameCODESIGN_EVAL_STATIC_RESOURCES();
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_97;
    }

    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }

uint64_t nss_cms_encoder_work_data(uint64_t a1, char *dataIn, size_t dataInLength, int a4, int a5)
{
  size_t v7 = dataInLength;
  BOOL v8 = dataIn;
  if (*(void *)(a1 + 32))
  {
    unsigned int v10 = *(_DWORD *)(a1 + 24);
    BOOL v11 = v10 > 0x1E;
    int v12 = (1 << v10) & 0x6C000000;
    if (v11 || v12 == 0) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = *(void *)(a1 + 32);
    }
    if (!dataInLength) {
      goto LABEL_13;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    if (!dataInLength) {
      goto LABEL_13;
    }
  }

  uint64_t v15 = *(void *)(v14 + 104);
  if (v15) {
    SecCmsDigestContextUpdate(v15, dataIn, dataInLength);
  }
LABEL_13:
  uint64_t v16 = *(void *)(v14 + 96);
  if (!v16)
  {
    int v22 = 0LL;
    goto LABEL_22;
  }

  unsigned int v25 = 0;
  unsigned int v17 = *(_DWORD *)(v16 + 12);
  if (a4) {
    int v18 = *(_DWORD *)(v16 + 12);
  }
  else {
    int v18 = 0;
  }
  unsigned int v19 = (v7 + v17 - 1) / v17;
  size_t v20 = v18 + v19 * v17;
  if (!(_DWORD)v20) {
    return SecCmsCipherContextCrypt((CCCryptorRef *)v16, 0LL, 0LL, 0LL, v8, v7, a4);
  }
  uint64_t v21 = (char *)PORT_Alloc(v18 + v19 * v17);
  if (!v21) {
    return 0xFFFFFFFFLL;
  }
  int v22 = v21;
  uint64_t v23 = SecCmsCipherContextCrypt(*(CCCryptorRef **)(v14 + 96), v21, &v25, v20, v8, v7, a4);
  if (!(_DWORD)v23)
  {
    size_t v7 = v25;
    BOOL v8 = v22;
LABEL_22:
    uint64_t v23 = 0LL;
    if (*(void *)a1 && v7)
    {
      if (a5 && !*(void *)(v14 + 72))
      {
        uint64_t v23 = 0LL;
        if (!v22) {
          return v23;
        }
LABEL_28:
        if (*(void *)(v14 + 96)) {
          free(v22);
        }
        return v23;
      }

      uint64_t v23 = SEC_ASN1EncoderUpdate(*(void *)a1, (uint64_t)v8, v7);
    }

    if (!v22) {
      return v23;
    }
    goto LABEL_28;
  }

  return v23;
}

uint64_t nss_cms_encoder_update(uint64_t a1, char *a2, size_t a3)
{
  return nss_cms_encoder_work_data(a1, a2, a3, 0, 0);
}

uint64_t SecCmsEncoderUpdate(uint64_t a1, char *dataIn, size_t dataInLength)
{
  if ((dataInLength & 0x8000000000000000LL) == 0)
  {
    while (a1)
    {
      uint64_t v5 = a1;
      uint64_t Error = *(unsigned int *)(a1 + 64);
      if ((_DWORD)Error) {
        return Error;
      }
      a1 = *(void *)(a1 + 72);
      if (!a1)
      {
        if (*(void *)(v5 + 32))
        {
          unsigned int v7 = *(_DWORD *)(v5 + 24);
          BOOL v8 = v7 > 0x1E;
          int v9 = (1 << v7) & 0x6C000000;
          if (v8 || v9 == 0) {
            uint64_t v11 = 0LL;
          }
          else {
            uint64_t v11 = *(void *)(v5 + 32);
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        uint64_t OID = *(void *)(v11 + 32);
        if (OID || (uint64_t OID = SECOID_FindOID(v11), (*(void *)(v11 + 32) = OID) != 0LL))
        {
          if (*(_DWORD *)(OID + 16) == 25 && !*(void *)(v11 + 16))
          {
            uint64_t Error = PORT_GetError();
            ThreadErrInfo = PR_getThreadErrInfo(1, &v15);
            if (ThreadErrInfo) {
              void *ThreadErrInfo = 0LL;
            }
            return Error;
          }
        }

        return 4294967246LL;
      }
    }
  }

  return 4294967246LL;
}

void SecCmsEncoderDestroy(uint64_t *a1)
{
  if (a1[9])
  {
    SecCmsEncoderDestroy();
    BOOL v2 = a1[9] == 0;
  }

  else
  {
    BOOL v2 = 1;
  }

  if (!nss_cms_encoder_work_data((uint64_t)a1, 0LL, 0LL, 1, v2))
  {
    a1[9] = 0LL;
    uint64_t v3 = *a1;
    if (*(_DWORD *)(*a1 + 24))
    {
      *(_DWORD *)(v3 + 24) = 0;
      if (*(_DWORD *)(v3 + 16) == 3)
      {
        *(_DWORD *)(v3 + 16) = 2;
        *(_DWORD *)(*(void *)(v3 + 8) + 40LL) = 4;
      }
    }

    *(_DWORD *)(v3 + 20) = 0;
    SEC_ASN1EncoderUpdate(v3, 0LL, 0LL);
  }

  PORT_FreeArena(*(void **)*a1, 0);
  free(a1);
}

uint64_t SecCmsEncoderFinish(_DWORD *a1)
{
  if (*((void *)a1 + 9))
  {
    uint64_t Error = SecCmsEncoderFinish();
    if ((_DWORD)Error) {
      goto LABEL_26;
    }
    BOOL v3 = *((void *)a1 + 9) == 0LL;
  }

  else
  {
    BOOL v3 = 1;
  }

  if (nss_cms_encoder_work_data((uint64_t)a1, 0LL, 0LL, 1, v3))
  {
    uint64_t Error = PORT_GetError();
  }

  else
  {
    *((void *)a1 + 9) = 0LL;
    if (*((void *)a1 + 4))
    {
      unsigned int v4 = a1[6];
      BOOL v5 = v4 > 0x1E;
      int v6 = (1 << v4) & 0x6C000000;
      if (v5 || v6 == 0) {
        uint64_t v8 = 0LL;
      }
      else {
        uint64_t v8 = *((void *)a1 + 4);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    uint64_t OID = *(void *)(v8 + 32);
    if (OID || (uint64_t OID = SECOID_FindOID(v8), (*(void *)(v8 + 32) = OID) != 0LL))
    {
      if (*(_DWORD *)(OID + 16) == 25 && !*(void *)(v8 + 16))
      {
        uint64_t v14 = *(void *)a1;
        if (*(_DWORD *)(*(void *)a1 + 24LL))
        {
          *(_DWORD *)(v14 + 24) = 0;
          if (*(_DWORD *)(v14 + 16) == 3)
          {
            *(_DWORD *)(v14 + 16) = 2;
            *(_DWORD *)(*(void *)(v14 + 8) + 40LL) = 4;
          }
        }

        LODWORD(OID) = SEC_ASN1EncoderUpdate(v14, 0LL, 0LL);
        if ((_DWORD)OID) {
          LODWORD(OID) = PORT_GetError();
        }
      }

      else
      {
        LODWORD(OID) = 0;
      }
    }

    *(_DWORD *)(*(void *)a1 + 20LL) = 0;
    unsigned int v10 = a1[16];
    if ((_DWORD)OID) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v10 == 0;
    }
    if (v11) {
      uint64_t Error = OID;
    }
    else {
      uint64_t Error = v10;
    }
  }

uint64_t SecCmsMessageEncode(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)unsigned int v10 = 0LL;
  uint64_t v5 = 4294967246LL;
  if (!a1 || !a3) {
    return v5;
  }
  if (a2)
  {
    if ((*(void *)a2 & 0x8000000000000000LL) != 0) {
      return v5;
    }
    uint64_t v5 = SecCmsEncoderCreate(a1, 0LL, 0LL, a3, a5, 0LL, 0LL, 0LL, v10);
    if ((_DWORD)v5) {
      return v5;
    }
    unsigned int v7 = *(uint64_t **)v10;
    uint64_t v8 = SecCmsEncoderUpdate(*(uint64_t *)v10, *(char **)(a2 + 8), *(void *)a2);
    if ((_DWORD)v8)
    {
      uint64_t v5 = v8;
      SecCmsEncoderDestroy(v7);
      return v5;
    }
  }

  else
  {
    uint64_t v5 = SecCmsEncoderCreate(a1, 0LL, 0LL, a3, a5, 0LL, 0LL, 0LL, v10);
    if ((_DWORD)v5) {
      return v5;
    }
    unsigned int v7 = *(uint64_t **)v10;
  }

  return SecCmsEncoderFinish(v7);
}

uint64_t SecCmsArraySortByDER(int8x16_t *a1, uint64_t a2, int8x16_t *a3)
{
  if (!a1) {
    return 0LL;
  }
  if (!a1->i64[0]) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  while (a1->i64[++v6])
    ;
  if ((_DWORD)v6 == 1) {
    return 0LL;
  }
  uint64_t v8 = PORT_NewArena(1024);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  int v9 = v8;
  if ((v6 - 1) <= 0xFFFFFFC)
  {
    unint64_t v10 = 8 * (unint64_t)(v6 + 1) <= 1 ? 1LL : 8LL * (v6 + 1);
    BOOL v11 = (void *)PORT_ArenaAlloc((uint64_t)v8, v10);
    if (v11)
    {
      int v12 = v11;
      bzero(v11, v10);
      uint64_t v13 = 0LL;
      uint64_t v14 = v6;
      while (1)
      {
        int v15 = SEC_ASN1EncodeItem((uint64_t)v9, 0LL, a1->i64[v13], a2);
        v12[v13] = v15;
        if (!v15) {
          break;
        }
        ++v13;
        if (!--v6)
        {
          v12[v14] = 0LL;
          SecCmsArraySort(v12, a1, a3);
          uint64_t v16 = 0LL;
          goto LABEL_19;
        }
      }
    }
  }

  uint64_t v16 = 0xFFFFFFFFLL;
LABEL_19:
  PORT_FreeArena(v9, 0);
  return v16;
}

uint64_t SecCmsAlgArrayGetIndexByAlgTag(size_t **a1, unsigned int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*a1) {
    return 0xFFFFFFFFLL;
  }
  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  unsigned int v4 = a2 <= 0xD8 ? &oids[40 * a2] : 0LL;
  if (a2 > 0xD8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = *a1;
  if (*a1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = a1 + 1;
    while (!SECITEM_ItemsAreEqual(v6, v4))
    {
      unsigned int v9 = v7 + 1;
      uint64_t v6 = (size_t *)v8[v7++];
      if (!v6) {
        goto LABEL_16;
      }
    }

    unsigned int v9 = v7;
  }

  else
  {
    unsigned int v9 = 0;
  }

const char *SecCmsUtilVerificationStatusToString(unsigned int a1)
{
  if (a1 > 9) {
    return "Unknown";
  }
  else {
    return off_18966A940[a1];
  }
}

uint64_t SecCmsDigestedDataCreate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v5 = PORT_ArenaAlloc(v4, 0xC8uLL);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  *(void *)(v5 + 192) = 0LL;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = a1;
  return v6;
}

void SecCmsDigestedDataDestroy(uint64_t *a1)
{
  if (a1) {
    SecCmsContentInfoDestroy(a1);
  }
}

uint64_t SecCmsDigestedDataEncodeBeforeStart(void *a1)
{
  uint64_t OID = a1[4];
  else {
    unint64_t v3 = 2LL;
  }
  if (SEC_ASN1EncodeInteger(*(void *)(a1[3] + 120LL), a1 + 15, v3)) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SecCmsDigestedDataEncodeAfterData(void *a1)
{
  uint64_t result = a1[13];
  if (result)
  {
    uint64_t v5 = (__int128 **)0xAAAAAAAAAAAAAAAALL;
    if (SecCmsDigestContextFinishMultiple(result, &v4, &v5)
      || (__int128 v3 = **v5, SECITEM_CopyItem(*(void *)(a1[3] + 120LL), a1 + 21, (uint64_t)&v3)))
    {
      uint64_t result = 0xFFFFFFFFLL;
    }

    else
    {
      SecCmsDigestContextCancel(a1[13]);
      uint64_t result = 0LL;
    }

    a1[13] = 0LL;
  }

  return result;
}

uint64_t SecCmsDigestContextStartMultiple(uint64_t *a1)
{
  BOOL v2 = PORT_NewArena(1024);
  if (!v2) {
    return 0LL;
  }
  __int128 v3 = v2;
  if (a1 && *a1)
  {
    uint64_t v4 = 0LL;
    while (a1[++v4])
      ;
  }

  else
  {
    LODWORD(v4) = 0;
  }

  uint64_t v6 = PORT_ArenaAlloc((uint64_t)v2, 0x20uLL);
  if (!v6)
  {
LABEL_35:
    PORT_FreeArena(v3, 0);
    return 0LL;
  }

  uint64_t v7 = v6;
  *(void *)uint64_t v6 = v3;
  if ((int)v4 >= 1)
  {
    if (v4 <= 0xFFFFFFD)
    {
      uint64_t v8 = PORT_ArenaAlloc((uint64_t)v3, 8LL * v4);
      *(void *)(v7 + 16) = v8;
      if (v8)
      {
        else {
          unint64_t v9 = 8LL * (v4 + 1);
        }
        unint64_t v10 = (void *)PORT_ArenaAlloc((uint64_t)v3, v9);
        if (v10)
        {
          BOOL v11 = v10;
          uint64_t v4 = v4;
          bzero(v10, v9);
          *(void *)(v7 + 24) = v11;
          *(_DWORD *)(v7 + 12) = 0;
          while (1)
          {
            uint64_t OID = SECOID_FindOID(*a1);
            if (OID)
            {
              int v13 = *(_DWORD *)(OID + 16);
              switch(v13)
              {
                case 191:
                  uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0x68uLL);
                  CC_SHA224_Init(v14);
                  break;
                case 192:
                  uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0x68uLL);
                  CC_SHA256_Init(v14);
                  break;
                case 193:
                  uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0xD0uLL);
                  CC_SHA384_Init((CC_SHA512_CTX *)v14);
                  break;
                case 194:
                  uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0xD0uLL);
                  CC_SHA512_Init((CC_SHA512_CTX *)v14);
                  break;
                default:
                  if (v13 == 3)
                  {
                    uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0x5CuLL);
                    CC_MD5_Init((CC_MD5_CTX *)v14);
                  }

                  else
                  {
                    if (v13 != 4) {
                      goto LABEL_23;
                    }
                    uint64_t v14 = (CC_SHA256_CTX *)calloc(1uLL, 0x60uLL);
                    CC_SHA1_Init((CC_SHA1_CTX *)v14);
                  }

                  break;
              }
            }

            else
            {
LABEL_23:
              uint64_t v14 = 0LL;
            }

            *(void *)(*(void *)(v7 + 16) + 8LL * *(int *)(v7 + 12)) = v14;
            uint64_t v15 = PORT_ArenaAlloc((uint64_t)v3, 0x20uLL);
            uint64_t v16 = *(int *)(v7 + 12);
            *(void *)(*(void *)(v7 + 24) + 8 * v16) = v15;
            if (SECITEM_CopyItem( (uint64_t)v3,  *(unint64_t **)(*(void *)(v7 + 24) + 8 * v16),  *a1)
              || SECITEM_CopyItem( (uint64_t)v3,  (unint64_t *)(*(void *)(*(void *)(v7 + 24) + 8LL * *(int *)(v7 + 12)) + 16LL),  *a1 + 16))
            {
              break;
            }

            ++*(_DWORD *)(v7 + 12);
            ++a1;
            if (!--v4) {
              goto LABEL_33;
            }
          }
        }

        else
        {
          *(void *)(v7 + 24) = 0LL;
        }
      }
    }

    goto LABEL_35;
  }

  *(_DWORD *)(v6 + 12) = 0;
LABEL_33:
  *(_BYTE *)(v7 + _Block_object_dispose((const void *)(v1 - 64), 8) = 0;
  return v7;
}

void SecCmsDigestContextUpdate(uint64_t a1, const void *a2, unint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (HIDWORD(a3))
  {
    uint64_t v4 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134217984;
      unint64_t v12 = a3;
      _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "SecCmsDigestContextUpdate: data size too big (%zu), skipping",  (uint8_t *)&v11,  0xCu);
    }
  }

  else
  {
    *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 64), 8) = 1;
    if (*(int *)(a1 + 12) >= 1)
    {
      uint64_t v7 = 0LL;
      do
      {
        if (*(void *)(*(void *)(a1 + 16) + 8 * v7))
        {
          uint64_t v8 = *(void *)(*(void *)(a1 + 24) + 8 * v7);
          if (v8)
          {
            if (*(void *)(v8 + 8))
            {
              uint64_t OID = SECOID_FindOID(v8);
              if (OID)
              {
                int v10 = *(_DWORD *)(OID + 16);
                switch(v10)
                {
                  case 191:
                    CC_SHA224_Update(*(CC_SHA256_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 192:
                    CC_SHA256_Update(*(CC_SHA256_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 193:
                    CC_SHA384_Update(*(CC_SHA512_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 194:
                    CC_SHA512_Update(*(CC_SHA512_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  default:
                    if (v10 == 3)
                    {
                      CC_MD5_Update(*(CC_MD5_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    }

                    else if (v10 == 4)
                    {
                      CC_SHA1_Update(*(CC_SHA1_CTX **)(*(void *)(a1 + 16) + 8 * v7), a2, a3);
                    }

                    break;
                }
              }
            }
          }
        }

        ++v7;
      }

      while (v7 < *(int *)(a1 + 12));
    }
  }

void SecCmsDigestContextCancel(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 12);
  if (v2 >= 1)
  {
    for (uint64_t i = 0LL; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = *(void **)(v4 + 8 * i);
        if (v5)
        {
          free(v5);
          *(void *)(*(void *)(a1 + 16) + 8 * i) = 0LL;
          int v2 = *(_DWORD *)(a1 + 12);
        }
      }
    }
  }

  PORT_FreeArena(*(void **)a1, 1);
}

uint64_t SecCmsDigestContextFinishMultiple(uint64_t a1, void *a2, void *a3)
{
  int v4 = *(_DWORD *)(a1 + 12);
  if (v4 <= 134217725)
  {
    uint64_t v7 = *(void *)a1;
    unint64_t v8 = 8LL * (v4 + 1);
    if (v8 <= 1) {
      unint64_t v9 = 1LL;
    }
    else {
      unint64_t v9 = v8;
    }
    int v10 = (void *)PORT_ArenaAlloc(v7, v9);
    int v11 = v10;
    if (v10) {
      bzero(v10, v9);
    }
    else {
      unint64_t v12 = 8LL * *(int *)(a1 + 12) + 8;
    }
    uint64_t v13 = (void *)PORT_ArenaAlloc(*(void *)a1, v12);
    uint64_t v14 = v13;
    if (v13) {
      bzero(v13, v12);
    }
    unint64_t v15 = (unint64_t)(16LL * *(int *)(a1 + 12)) <= 1 ? 1LL : 16LL * *(int *)(a1 + 12);
    uint64_t v16 = (unint64_t *)PORT_ArenaAlloc(*(void *)a1, v15);
    if (v16)
    {
      unsigned int v17 = v16;
      bzero(v16, v15);
      if (v11 && v14 != 0LL)
      {
        if (*(int *)(a1 + 12) < 1)
        {
          uint64_t v27 = 0LL;
LABEL_53:
          uint64_t result = 0LL;
          v11[v27] = 0LL;
          v14[v27] = 0LL;
          *a2 = v11;
          *a3 = v14;
          goto LABEL_22;
        }

        uint64_t v20 = 0LL;
        while (2)
        {
          uint64_t v21 = *(void *)(*(void *)(a1 + 24) + 8 * v20);
          if (v21)
          {
            if (*(void *)(v21 + 8))
            {
              uint64_t OID = SECOID_FindOID(v21);
              if (OID)
              {
                int v23 = *(_DWORD *)(OID + 16);
                switch(v23)
                {
                  case 191:
                    unint64_t v24 = 28LL;
                    goto LABEL_37;
                  case 192:
                    unint64_t v24 = 32LL;
                    goto LABEL_37;
                  case 193:
                    unint64_t v24 = 48LL;
                    goto LABEL_37;
                  case 194:
                    unint64_t v24 = 64LL;
                    goto LABEL_37;
                  default:
                    if (v23 == 4)
                    {
                      unint64_t v24 = 20LL;
                    }

                    else
                    {
                      if (v23 != 3) {
                        goto LABEL_21;
                      }
                      unint64_t v24 = 16LL;
                    }

LABEL_37:
                    unsigned int v25 = *(CC_SHA256_CTX **)(*(void *)(a1 + 16) + 8 * v20);
                    if (v25)
                    {
                      unsigned int v26 = (unsigned __int8 *)PORT_ArenaAlloc(*(void *)a1, v24);
                      v17[1] = (unint64_t)v26;
                      if (!v26) {
                        goto LABEL_21;
                      }
                      *unsigned int v17 = v24;
                      switch(v23)
                      {
                        case 191:
                          CC_SHA224_Final(v26, v25);
                          goto LABEL_49;
                        case 192:
                          CC_SHA256_Final(v26, v25);
                          goto LABEL_49;
                        case 193:
                          CC_SHA384_Final(v26, (CC_SHA512_CTX *)v25);
                          goto LABEL_49;
                        case 194:
                          CC_SHA512_Final(v26, (CC_SHA512_CTX *)v25);
                          goto LABEL_49;
                        default:
                          if (v23 == 3)
                          {
                            CC_MD5_Final(v26, (CC_MD5_CTX *)v25);
                          }

                          else
                          {
                            if (v23 != 4) {
                              goto LABEL_21;
                            }
                            CC_SHA1_Final(v26, (CC_SHA1_CTX *)v25);
                          }

    uint64_t v40 = 0;
    uint64_t v32 = 0LL;
LABEL_45:

    if ((v40 & 1) == 0) {
      goto LABEL_55;
    }
  }

  if (v49)
  {
    [v2 setObject:v49 forKeyedSubscript:@"tlks"];
  }

    uint64_t v39 = 0LL;
    goto LABEL_32;
  }

  free(v3);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v5 & (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                              + 24LL) != 0);
}

            unint64_t v30 = (dispatch_queue_s *)*((void *)v2 + 17);
            v42[0] = v7;
            v42[1] = 0x40000000LL;
            v42[2] = __SecTrustSetExceptions_block_invoke_2;
            v42[3] = &__block_descriptor_tmp_221;
            v42[4] = v2;
            dispatch_sync(v30, v42);
            LOBYTE(trust) = 0;
            return (char)trust;
          }
        }

      ++*(void *)this;
      return MutableCopy;
    }

    if (v8 == 125) {
      return MutableCopy;
    }
    if (v8 != 123) {
      goto LABEL_43;
    }
    ++*(void *)this;
    if (Security::CFMunge::next(this) == 43)
    {
      ++*(void *)this;
      ++*(void *)this;
      uint64_t v13 = (CFDictionaryRef **)*((void *)this + 1);
      ++*(void *)this;
      uint64_t v14 = (*v13)++;
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0LL, *v14);
    }

    else
    {
      MutableCFArrayRef Copy = CFDictionaryCreateMutable( *((CFAllocatorRef *)this + 2),  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    }

    if (!MutableCopy || Security::CFMake::add(this, MutableCopy)) {
      return MutableCopy;
    }
LABEL_60:
    CFRelease(MutableCopy);
    return 0LL;
  }

  if (v8 <= 36)
  {
    if (!v8) {
      return MutableCopy;
    }
    if (v8 == 35)
    {
      MutableCFArrayRef Copy = 0LL;
      int v10 = *(char **)this;
      *(void *)this += 2LL;
      int v11 = v10[1];
      if (v11 <= 83)
      {
        if (v11 != 70)
        {
          if (v11 == 78)
          {
            unint64_t v12 = MEMORY[0x189605018];
            return *(CFDataRef *)v12;
          }

          return MutableCopy;
        }
      }

      else
      {
        if (v11 == 84)
        {
LABEL_14:
          unint64_t v12 = MEMORY[0x189604DE8];
          return *(CFDataRef *)v12;
        }

        if (v11 != 102)
        {
          if (v11 == 116) {
            goto LABEL_14;
          }
          return MutableCopy;
        }
      }

      unint64_t v12 = MEMORY[0x189604DE0];
      return *(CFDataRef *)v12;
    }

    goto LABEL_43;
  }

  if (v8 != 37)
  {
    if (v8 == 39) {
      return (CFDataRef)Security::CFMake::makestring((CFAllocatorRef *)this);
    }
LABEL_43:
    uint64_t v27 = **(char **)this;
    if ((v27 & 0x80000000) != 0)
    {
      int v35 = __maskrune(**(char **)this, 0x100uLL);
    }

    else
    {
      if (v27 == 45 || (*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v27 + 60) & 0x400) != 0)
      {
        CFTypeRef valuePtr = strtod(*(const char **)this, (char **)this);
        char v29 = (const __CFAllocator *)*((void *)this + 2);
        unint64_t v30 = kCFNumberDoubleType;
        return CFNumberCreate(v29, v30, &valuePtr);
      }

      int v35 = *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v27 + 60) & 0x100;
    }

    if (v35) {
      return (CFDataRef)Security::CFMake::makestring((CFAllocatorRef *)this);
    }
    return 0LL;
  }

  MutableCFArrayRef Copy = 0LL;
  unsigned int v19 = *(void *)this;
  *(void *)this += 2LL;
  uint64_t v20 = *(char *)(v19 + 1);
  if (v20 <= 99)
  {
    if (v20 != 66)
    {
      if (v20 == 79)
      {
        uint64_t v38 = (CFTypeRef **)*((void *)this + 1);
        uint64_t v39 = (*v38)++;
        return (CFDataRef)CFRetain(*v39);
      }

      if (v20 == 98)
      {
        uint64_t v21 = (const UInt8 ***)*((void *)this + 1);
        int v22 = (*v21)++;
        int v23 = *v22;
        unint64_t v24 = (CFIndex **)*((void *)this + 1);
        unsigned int v25 = (*v24)++;
        return CFDataCreate(*((CFAllocatorRef *)this + 2), v23, *v25);
      }

      return MutableCopy;
    }

    uint64_t v36 = (_DWORD **)*((void *)this + 1);
    int v37 = *v36;
    *v36 += 2;
    unint64_t v12 = MEMORY[0x189604DE8];
    if (!*v37) {
      unint64_t v12 = MEMORY[0x189604DE0];
    }
    return *(CFDataRef *)v12;
  }

  if (v20 == 100)
  {
    uint64_t v40 = (_DWORD **)*((void *)this + 1);
    __int128 v41 = *v40;
    *v40 += 2;
    LODWORD(valuePtr) = *v41;
    char v29 = 0LL;
    unint64_t v30 = kCFNumberIntType;
    return CFNumberCreate(v29, v30, &valuePtr);
  }

  if (v20 != 115)
  {
    if (v20 != 117) {
      return MutableCopy;
    }
    unsigned int v33 = (unsigned int **)*((void *)this + 1);
    uint64_t v34 = *v33;
    *v33 += 2;
    *(void *)&CFTypeRef valuePtr = *v34;
    char v29 = 0LL;
    unint64_t v30 = kCFNumberLongLongType;
    return CFNumberCreate(v29, v30, &valuePtr);
  }

  unint64_t v43 = (const char ***)*((void *)this + 1);
  uint64_t v42 = (const __CFAllocator *)*((void *)this + 2);
  unint64_t v44 = (*v43)++;
  return (CFDataRef)CFStringCreateWithCString(v42, *v44, 0x8000100u);
}

void *SECITEM_AllocItem(uint64_t a1, void *a2, unint64_t a3)
{
  int v4 = a2;
  if (a1)
  {
    if (!a2)
    {
      uint64_t v6 = PORT_ArenaAlloc(a1, 0x10uLL);
      int v4 = (void *)v6;
      if (!v6) {
        return v4;
      }
      *(void *)(v6 + _Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
    }

    void *v4 = a3;
    if (a3)
    {
      uint64_t v7 = PORT_ArenaAlloc(a1, a3);
LABEL_11:
      v4[1] = v7;
    }
  }

  else if (a2 || (int v4 = PORT_ZAlloc(0x10uLL)) != 0LL)
  {
    void *v4 = a3;
    if (a3)
    {
      uint64_t v7 = (uint64_t)PORT_Alloc(a3);
      goto LABEL_11;
    }
  }

  return v4;
}

BOOL SECITEM_ItemsAreEqual(size_t *a1, void *a2)
{
  size_t v2 = *a1;
  if (*a1 != *a2) {
    return 0LL;
  }
  if (!v2) {
    return 1LL;
  }
  __int128 v3 = (const void *)a1[1];
  int v4 = (const void *)a2[1];
  if (v3 && v4) {
    return memcmp(v3, v4, v2) == 0;
  }
  else {
    return v3 == v4;
  }
}

uint64_t SECITEM_CopyItem(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if (!*(void *)(a3 + 8) || !*(void *)a3)
  {
    unint64_t v6 = 0LL;
    a2[1] = 0LL;
LABEL_9:
    uint64_t result = 0LL;
    *a2 = v6;
    return result;
  }

  if (a1) {
    uint64_t v5 = (void *)PORT_ArenaAlloc(a1, *(void *)a3);
  }
  else {
    uint64_t v5 = PORT_Alloc(*(void *)a3);
  }
  a2[1] = (unint64_t)v5;
  if (v5)
  {
    memcpy(v5, *(const void **)(a3 + 8), *(void *)a3);
    unint64_t v6 = *(void *)a3;
    goto LABEL_9;
  }

  return 0xFFFFFFFFLL;
}

uint64_t SECITEM_Hash(uint64_t *a1)
{
  unsigned int v5 = 0;
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = a1[1];
  do
  {
    *(_BYTE *)((unint64_t)&v5 | v2 & 3) ^= *(_BYTE *)(v3 + v2);
    ++v2;
  }

  while (v1 != v2);
  return v5;
}

BOOL SECITEM_HashCompare(size_t *a1, void *a2)
{
  return SECITEM_ItemsAreEqual(a1, a2);
}

uint64_t SecCmsMessageCreate()
{
  uint64_t result = (uint64_t)PORT_NewArena(1024);
  if (result)
  {
    uint64_t v1 = (void *)result;
    uint64_t result = PORT_ArenaAlloc(result, 0xA0uLL);
    if (result)
    {
      *(_OWORD *)(result + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
      *(_OWORD *)(result + 144) = 0u;
      *(_OWORD *)(result + 96) = 0u;
      *(_OWORD *)(result + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
      *(_OWORD *)(result + 64) = 0u;
      *(_OWORD *)(result + 80) = 0u;
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
      *(_OWORD *)uint64_t result = 0u;
      *(_OWORD *)(result + 16) = 0u;
      *(void *)(result + 120) = v1;
      *(void *)(result + 24) = result;
      *(_DWORD *)(result + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 1;
    }

    else
    {
      PORT_FreeArena(v1, 0);
      return 0LL;
    }
  }

  return result;
}

void SecCmsMessageDestroy(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 128);
  BOOL v2 = __OFSUB__(v1, 1);
  int v3 = v1 - 1;
  if (v3 < 0 == v2)
  {
    *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = v3;
    if (!v3)
    {
      SecCmsContentInfoDestroy((uint64_t *)a1);
      unsigned int v5 = *(void **)(a1 + 120);
      if (v5) {
        PORT_FreeArena(v5, 1);
      }
    }
  }

uint64_t SecCmsMessageCopy(uint64_t result)
{
  if (result) {
    ++*(_DWORD *)(result + 128);
  }
  return result;
}

uint64_t SecCmsMessageContentLevelCount(uint64_t ChildContentInfo)
{
  for (uint64_t i = 0LL; ChildContentInfo; ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo))
    uint64_t i = (i + 1);
  return i;
}

uint64_t SecCmsMessageContentLevel(uint64_t result, int a2)
{
  if (result && a2 >= 1)
  {
    int v3 = 1;
    do
    {
      uint64_t result = SecCmsContentInfoGetChildContentInfo(result);
      if (!result) {
        break;
      }
    }

    while (v3++ < a2);
  }

  return result;
}

uint64_t SecCmsMessageContainsCertsOrCrls(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    while (1)
    {
      uint64_t OID = *(void *)(v1 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v1), (*(void *)(v1 + 32) = OID) != 0LL))
      {
        if (*(_DWORD *)(OID + 16) == 26)
        {
          uint64_t v3 = *(void *)(v1 + 16);
          int v4 = *(void **)(v3 + 144);
          if (v4)
          {
            if (*v4) {
              break;
            }
          }

          unsigned int v5 = *(void **)(v3 + 152);
          if (v5)
          {
            if (*v5) {
              break;
            }
          }
        }
      }

      uint64_t result = SecCmsContentInfoGetChildContentInfo(v1);
      uint64_t v1 = result;
      if (!result) {
        return result;
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t SecCmsMessageIsEncrypted(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    while (1)
    {
      uint64_t OID = *(void *)(v1 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v1), (*(void *)(v1 + 32) = OID) != 0LL))
      {
        int v3 = *(_DWORD *)(OID + 16);
        if (v3 == 27 || v3 == 30) {
          break;
        }
      }

      uint64_t result = SecCmsContentInfoGetChildContentInfo(v1);
      uint64_t v1 = result;
      if (!result) {
        return result;
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t SecCmsMessageIsSigned(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    while (1)
    {
      uint64_t OID = *(void *)(v1 + 32);
      if (OID || (uint64_t OID = SECOID_FindOID(v1), (*(void *)(v1 + 32) = OID) != 0LL))
      {
        if (*(_DWORD *)(OID + 16) == 26)
        {
          int v3 = *(void **)(*(void *)(v1 + 16) + 160LL);
          if (v3)
          {
            if (*v3) {
              break;
            }
          }
        }
      }

      uint64_t result = SecCmsContentInfoGetChildContentInfo(v1);
      uint64_t v1 = result;
      if (!result) {
        return result;
      }
    }

    return 1LL;
  }

  return result;
}

BOOL SecCmsMessageIsContentEmpty(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    return 1LL;
  }
  unsigned int v4 = *(_DWORD *)(v3 + 16);
  BOOL result = 1LL;
  BOOL v6 = v4 >= 0x1E;
  BOOL v8 = v4 == 30;
  int v7 = (1 << v4) & 0x6E000000;
  BOOL v8 = !v8 && v6 || v7 == 0;
  if (!v8)
  {
    unint64_t v9 = *(void **)(a1 + 16);
    if (v9) {
      return *v9 <= (unint64_t)a2;
    }
  }

  return result;
}

uint64_t nss_cms_choose_content_template(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    BOOL result = *(void *)(result + 32);
    if (result || (BOOL result = SECOID_FindOID(v1), (*(void *)(v1 + 32) = result) != 0LL))
    {
      unsigned int v2 = *(_DWORD *)(result + 16) - 25;
      if (v2 > 5) {
        return 0LL;
      }
      else {
        return (uint64_t)*(&off_18966B310 + v2);
      }
    }
  }

  return result;
}

uint64_t SECOID_SetAlgorithmID(uint64_t a1, unint64_t *a2, unsigned int a3, uint64_t a4)
{
  if (a3 >= 0xD9)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00600000000LL;
    }
    return 0xFFFFFFFFLL;
  }

  if (a3 <= 0x14 && ((1 << a3) & 0x1F001E) != 0 || a3 - 192 < 6)
  {
    if (!a4)
    {
      SECITEM_AllocItem(a1, a2 + 2, 2uLL);
      int v10 = (_BYTE *)a2[3];
      if (!v10) {
        return 0xFFFFFFFFLL;
      }
      _BYTE *v10 = 5;
      *(_BYTE *)(a2[3] + 1) = 0;
      return 0LL;
    }
  }

  else if (!a4)
  {
    return 0LL;
  }

  return 0LL;
}

uint64_t SECOID_CopyAlgorithmID(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  else {
    return SECITEM_CopyItem(a1, a2 + 2, a3 + 16);
  }
}

uint64_t SecCmsEnvelopedDataCreate(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = PORT_ArenaAlloc(*(void *)(a1 + 120), 0xA0uLL);
  if (result)
  {
    uint64_t v7 = result;
    *(_OWORD *)(result + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(void *)(result + 24) = a1;
    int v8 = SECOID_SetAlgorithmID(*(void *)(a1 + 120), (unint64_t *)(result + 40), a2, 0LL);
    uint64_t result = 0LL;
    if (!v8)
    {
      *(_DWORD *)(v7 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = a3;
      return v7;
    }
  }

  return result;
}

uint64_t SecCmsEnvelopedDataDestroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = *(uint64_t **)(result + 144);
    if (v2)
    {
      uint64_t v3 = *v2;
      if (*v2)
      {
        unsigned int v4 = v2 + 1;
        do
        {
          unsigned int v5 = *(const void **)(v3 + 144);
          if (v5) {
            CFRelease(v5);
          }
          if (!*(_DWORD *)v3 && *(_DWORD *)(v3 + 24) == 1)
          {
            BOOL v6 = *(const void **)(v3 + 96);
            if (v6) {
              CFRelease(v6);
            }
          }

          uint64_t v7 = *v4++;
          uint64_t v3 = v7;
        }

        while (v7);
      }

      return SecCmsContentInfoDestroy(v1);
    }
  }

  return result;
}

uint64_t SecCmsEnvelopedDataEncodeBeforeStart(uint64_t a1)
{
  iv[1] = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(uint64_t **)(a1 + 144);
  if (!v1)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v90);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00200000000LL;
    }
    return 0xFFFFFFFFLL;
  }

  uint64_t v3 = *(void *)(*(void *)(a1 + 24) + 120LL);
  if (*(void *)(a1 + 136) || *(void *)(a1 + 152))
  {
    unint64_t v4 = 2LL;
  }

  else
  {
    uint64_t v64 = *v1;
    if (*v1)
    {
      uint64_t v65 = v1 + 1;
      unint64_t v4 = 2LL;
      while (1)
      {
        if (*(_DWORD *)v64 <= 2u)
        {
          *(void *)&__int128 v90 = 0xAAAAAAAAAAAAAAAALL;
          if (!SEC_ASN1DecodeInteger((uint64_t *)(v64 + 8), (uint64_t *)&v90))
          {
            if ((_DWORD)v90) {
              break;
            }
          }
        }

        uint64_t v66 = *v65++;
        uint64_t v64 = v66;
        if (!v66) {
          goto LABEL_105;
        }
      }
    }

    else
    {
LABEL_105:
      unint64_t v4 = 0LL;
    }
  }

  if (!SEC_ASN1EncodeInteger(v3, (void *)(a1 + 120), v4)) {
    return 0xFFFFFFFFLL;
  }
  if (SecCmsContentInfoGetContentEncAlgTag(a1))
  {
    int v5 = *(_DWORD *)(a1 + 88);
    int v6 = v5 + 7;
    if (v5 < -7) {
      int v6 = v5 + 14;
    }
    if (v5 < -14) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = (uint64_t)v6 >> 3;
  }

  else
  {
    if (SECOID_SetAlgorithmID( *(void *)(*(void *)(a1 + 24) + 120LL),  (unint64_t *)(a1 + 40),  7u,  0LL)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = 192;
    uint64_t v7 = 24LL;
  }

  unint64_t v9 = (const UInt8 *)malloc(v7);
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  int v10 = v9;
  CFDataRef v11 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v10, v7, (CFAllocatorRef)*MEMORY[0x189604DB8]);
  CFDataRef v12 = v11;
  uint64_t v13 = *v1;
  if (!*v1)
  {
LABEL_106:
    SecCmsContentInfoSetBulkKey(a1, v12);
    if (v12) {
      CFRelease(v12);
    }
    return 0LL;
  }

  uint64_t v14 = v1 + 1;
  CFDataRef theData = v11;
  while (1)
  {
    __int16 v79 = 5;
    unint64_t v15 = *(__SecCertificate **)(v13 + 144);
    if (!v15) {
      break;
    }
    uint64_t v16 = *(void *)(*(void *)(*(void *)(v13 + 136) + 24LL) + 120LL);
    uint64_t v17 = *((void *)v15 + 27);
    v80[0] = *((void *)v15 + 28);
    v80[1] = v17;
    uint64_t v18 = *((void *)v15 + 29);
    v80[2] = *((void *)v15 + 30);
    v80[3] = v18;
    if (!v17 || (uint64_t OID = SECOID_FindOID((uint64_t)v80)) == 0)
    {
LABEL_110:
      CFIndex v68 = PR_getThreadErrInfo(1, (int *)&v90);
      if (!v68) {
        goto LABEL_116;
      }
      unint64_t v69 = 0xFFFFE00600000000LL;
      goto LABEL_115;
    }

    int v20 = *(_DWORD *)(OID + 16);
    if (v20 != 16)
    {
      if (v20 != 202) {
        goto LABEL_110;
      }
      uint64_t v21 = **(void **)(v13 + 128);
      if (!v21) {
        goto LABEL_116;
      }
      v78[1] = &v79;
      v78[0] = 2LL;
      SecKeyRef privateKey = 0LL;
      SecKeyRef publicKey = 0LL;
      iv[0] = 0xAAAAAAAAAAAAAAAALL;
      v96[0] = 8LL;
      v96[1] = iv;
      *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v94 = v22;
      __int128 v95 = v22;
      __int128 v92 = v22;
      __int128 v93 = v22;
      __int128 v91 = v22;
      __int128 v90 = v22;
      CFIndex length = 0LL;
      size_t bytes = 0LL;
      __int16 v87 = 5;
      int v86 = -1431655766;
      CCCryptorRef cryptorRef = 0LL;
      CFTypeRef v85 = 0LL;
      *(void *)(v21 + 56) = 0LL;
      *(void *)(v21 + 64) = 0LL;
      int v23 = (void *)(v21 + 56);
      uint64_t v74 = (void *)(v13 + 80);
      unint64_t v24 = SecCertificateCopyKey(v15);
      if (v24)
      {
        CFTypeRef cf = v24;
        unsigned int v25 = SecKeyCopyAttributes(v24);
        unsigned int v26 = v25;
        if (!v25)
        {
          int v30 = 0;
          CFDataRef v31 = 0LL;
          uint64_t v76 = 0LL;
          CFNumberRef v77 = 0LL;
          uint64_t v34 = 0LL;
          __int128 v41 = cf;
          goto LABEL_46;
        }

        Value = (void *)CFDictionaryGetValue(v25, @"type");
        uint64_t v72 = v26;
        unsigned int v28 = (void *)CFDictionaryGetValue(v26, @"bsiz");
        if (CFEqual(@"73", Value))
        {
          keys[0] = @"type";
          keys[1] = @"bsiz";
          values[0] = Value;
          values[1] = v28;
          char v29 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
          int v30 = SecKeyGeneratePair(v29, &publicKey, &privateKey);
          CFDataRef v31 = 0LL;
          if (!v30 && publicKey && privateKey)
          {
            uint64_t v32 = PORT_Alloc(8uLL);
            *(void *)(v13 + 80) = 8LL;
            *(void *)(v13 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = v32;
            int v33 = CCRandomCopyBytes();
            if (v33) {
              goto LABEL_33;
            }
            if (*(void *)(v13 + 88))
            {
              void *v74 = 8LL;
              int v33 = CCRandomCopyBytes();
              if (!v33)
              {
                unint64_t v71 = v29;
                __int128 v94 = 0u;
                __int128 v95 = 0u;
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                __int128 v94 = xmmword_189668658;
                *(_OWORD *)(v13 + 96) = 0u;
                *(_OWORD *)(v13 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
                if (!SEC_ASN1EncodeItem( v16,  (void *)(v13 + 112),  (uint64_t)&v94,  (uint64_t)&SECOID_AlgorithmIDTemplate)) {
                  goto LABEL_83;
                }
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                *(_OWORD *)(v13 + 96) = *(__int128 *)((char *)&xmmword_189668658 + 7880);
                __int128 v90 = 0u;
                __int128 v91 = 0u;
                __int128 v92 = 0u;
                __int128 v93 = 0u;
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                __int128 v90 = xmmword_189668658;
                *((void *)&v91 + 1) = &v87;
                *(void *)&__int128 v91 = 2LL;
                __int128 v92 = *(_OWORD *)v74;
                int v86 = -1073741824;
                *(void *)&__int128 v93 = 4LL;
                *((void *)&v93 + 1) = &v86;
                if (!SEC_ASN1EncodeItem(v16, &length, (uint64_t)&v90, (uint64_t)&ECC_CMS_SharedInfoTemplate))
                {
LABEL_83:
                  CFDataRef v31 = 0LL;
                  uint64_t v76 = 0LL;
                  CFNumberRef v77 = 0LL;
                  unsigned int v26 = 0LL;
                  uint64_t v34 = 0LL;
                  int v30 = -2070;
                  goto LABEL_84;
                }

                if (length < 0)
                {
                  CFDataRef v31 = 0LL;
                  uint64_t v76 = 0LL;
                  CFNumberRef v77 = 0LL;
                  unsigned int v26 = 0LL;
                  uint64_t v34 = 0LL;
                  int v30 = -108;
                  goto LABEL_84;
                }

                CFDataRef v31 = CFDataCreate(0LL, bytes, length);
                int valuePtr = 24;
                CFNumberRef v49 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
                v100[0] = @"requestedSize";
                v100[1] = @"sharedInfo";
                CFNumberRef v77 = v49;
                v99[0] = v49;
                v99[1] = v31;
                uint64_t v76 = CFDictionaryCreate( 0LL,  (const void **)v100,  (const void **)v99,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
                unint64_t v50 = SecKeyCopyKeyExchangeResult( privateKey,  @"algid:keyexchange:ECDH:KDFX963:SHA1",  cf,  v76,  (CFErrorRef *)&v85);
                unsigned int v26 = v50;
                if (v85 || CFDataGetLength(v50) < 0) {
                  goto LABEL_80;
                }
                BytePtr = CFDataGetBytePtr(v26);
                CFIndex v52 = CFDataGetLength(v26);
                CCCryptorStatus v53 = CCCryptorCreate(0, 2u, 1u, BytePtr, v52, iv, &cryptorRef);
                if (v53) {
                  goto LABEL_88;
                }
                if (CFDataGetLength(theData) < 0)
                {
LABEL_80:
                  int v30 = 0;
                }

                else
                {
                  uint64_t v54 = cryptorRef;
                  CFIndex v55 = CFDataGetLength(theData);
                  OutputCFIndex Length = CCCryptorGetOutputLength(v54, v55, 1);
                  *(void *)(v21 + 64) = PORT_ArenaAlloc(v16, OutputLength);
                  size_t dataOutMoved = 0LL;
                  uint64_t v70 = cryptorRef;
                  uint64_t v57 = CFDataGetBytePtr(theData);
                  CFIndex v58 = CFDataGetLength(theData);
                  CCCryptorStatus v53 = CCCryptorUpdate(v70, v57, v58, *(void **)(v21 + 64), OutputLength, &dataOutMoved);
                  if (!v53)
                  {
                    size_t v81 = 0LL;
                    CCCryptorStatus v53 = CCCryptorFinal( cryptorRef,  (void *)(*(void *)(v21 + 64) + dataOutMoved),  OutputLength - dataOutMoved,  &v81);
                    if (!v53)
                    {
                      void *v23 = v81 + dataOutMoved;
                      __int128 v59 = SecKeyCopyExternalRepresentation(publicKey, (CFErrorRef *)&v85);
                      uint64_t v34 = v59;
                      if (v85 || CFDataGetLength(v59) < 0)
                      {
                        int v30 = 0;
                      }

                      else
                      {
                        CFIndex v60 = CFDataGetLength(v34);
                        *(void *)(v13 + 64) = v60;
                        uint64_t v61 = malloc(v60);
                        *(void *)(v13 + 72) = v61;
                        if (v61)
                        {
                          uint64_t v62 = v61;
                          uint64_t v63 = CFDataGetBytePtr(v34);
                          CFIndex v60 = *(void *)(v13 + 64);
                          memcpy(v62, v63, v60);
                          int v30 = 0;
                        }

                        else
                        {
                          int v30 = -108;
                        }

                        *(void *)(v13 + 64) = 8 * v60;
                      }

LABEL_84:
                      uint64_t v42 = cf;
                      char v29 = v71;
LABEL_45:
                      CFRelease(v42);
                      CFRelease(v72);
                      __int128 v41 = v29;
                      if (v29) {
LABEL_46:
                      }
                        CFRelease(v41);
LABEL_47:
                      SecKeyRef v43 = publicKey;
                      if (publicKey)
                      {
                        SecKeyRef publicKey = 0LL;
                        CFRelease(v43);
                      }

                      SecKeyRef v44 = privateKey;
                      if (privateKey)
                      {
                        SecKeyRef privateKey = 0LL;
                        CFRelease(v44);
                      }

                      if (v31) {
                        CFRelease(v31);
                      }
                      if (v77) {
                        CFRelease(v77);
                      }
                      CFDataRef v12 = theData;
                      if (v76) {
                        CFRelease(v76);
                      }
                      if (v26) {
                        CFRelease(v26);
                      }
                      CFTypeRef v45 = v85;
                      if (v85)
                      {
                        CFTypeRef v85 = 0LL;
                        CFRelease(v45);
                      }

                      if (v34) {
                        CFRelease(v34);
                      }
                      if (cryptorRef) {
                        CCCryptorRelease(cryptorRef);
                      }
                      if (v30)
                      {
                        uint64_t v46 = *(void **)(v21 + 64);
                        if (v46)
                        {
                          free(v46);
                          void *v23 = 0LL;
                          *(void *)(v21 + 64) = 0LL;
                        }

                        uint64_t v47 = *(void **)(v13 + 88);
                        if (v47)
                        {
                          free(v47);
                          void *v74 = 0LL;
                          *(void *)(v13 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
                        }
                      }

                      goto LABEL_70;
                    }
                  }

LABEL_88:
                  int v30 = v53;
                }

                uint64_t v34 = 0LL;
                goto LABEL_84;
              }

        if ((_DWORD)a4) {
          SecKeyRef v43 = v23 == 0;
        }
        else {
          SecKeyRef v43 = 0;
        }
        SecKeyRef v44 = v43;
        if ((((_DWORD)v10 == 0) & *(_DWORD *)&v44 & (v9 >> 18)) != 0) {
          uint64_t result = 1LL;
        }
        else {
          uint64_t result = v23;
        }
        if ((v9 & 0x100) == 0 || result)
        {
          if (v19 != 1024) {
            goto LABEL_104;
          }
          unint64_t v24 = 1;
          goto LABEL_100;
        }

        goto LABEL_99;
      }

      uint64_t v27 = v8 + 6;
      if (v8[6])
      {
        int v23 = 0LL;
        do
        {
          unsigned int v28 = v8[7];
          int v8 = v27;
          char v29 = sec_asn1e_contents_length(v27, (char *)a2 + v28, v10, a4, a5);
          v23 += v29;
          if (!*a5)
          {
            int v30 = 1LL;
            if (v29 >= 0x80)
            {
              do
              {
                ++v30;
                CFDataRef v31 = v29 > 0xFF;
                v29 >>= 8;
              }

              while (v31);
            }

            v23 += v30 + 1;
          }

          uint64_t v27 = v8 + 6;
        }

        while (v8[6]);
        goto LABEL_88;
      }
    }

    int v23 = 0LL;
    goto LABEL_88;
  }

  CFDataRef v11 = *((void *)v8 + 1);
  if (v11 && (v9 & 0x4000) != 0)
  {
    CFDataRef v12 = *(uint64_t (**)(uint64_t, uint64_t, void, void, unint64_t *))v11;
    if (*(void *)v11)
    {
      if (a2) {
        uint64_t v13 = (uint64_t)a2 - v8[1];
      }
      else {
        uint64_t v13 = 0LL;
      }
      CFDataRef v11 = v12(v13, 1LL, 0LL, 0LL, a2);
      if ((v9 & 0x1000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_33;
    }

    CFDataRef v11 = 0LL;
  }

  if ((v9 & 0x1000) == 0) {
    goto LABEL_53;
  }
LABEL_33:
  a2 = (unint64_t *)*a2;
  if (!a2)
  {
    uint64_t result = 0LL;
    if ((v9 & 0x100) != 0) {
      unint64_t v24 = 3;
    }
    else {
      unint64_t v24 = 0;
    }
    goto LABEL_100;
  }

    uint64_t v34 = writeFile(v17, (char *)v20, v21, &v86);
    goto LABEL_89;
  }

  int v8 = (char *)this + 120;
  unint64_t v9 = (char *)this + 144;
  *(void *)__int128 buf = 0LL;
  __dst = 0LL;
  size_t size = 0LL;
  if ((mapFile(v8, (const void **)buf, (off_t *)&size, &v86) & 1) == 0)
  {
LABEL_117:
    uint64_t v76 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v86;
      _os_log_impl(&dword_1804F4000, v76, OS_LOG_TYPE_DEFAULT, "codesign deallocation failed: %s", buf, 0xCu);
    }

    free(v86);
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18LL);
  }

  int v10 = *(void **)buf;
  CFDataRef v11 = size;
  if (HIDWORD(size))
  {
    log_error(&v86, "input file is too big: %lld\n", size);
    LODWORD(v11) = 0;
    goto LABEL_116;
  }

  CFDataRef v12 = 0LL;
  uint64_t v13 = 0;
  uint64_t v14 = **(_DWORD **)buf;
  if ((int)**(_DWORD **)buf > -17958195)
  {
    unint64_t v15 = 0LL;
    if ((v14 + 17958194) >= 2)
    {
LABEL_57:
      uint64_t v39 = writeFile(v9, v12, v13, &v86);
      goto LABEL_66;
    }
  }

  else
  {
    if (v14 == -1095041334)
    {
      CFNumberRef v49 = *(_DWORD *)(*(void *)buf + 4LL);
      unint64_t v50 = bswap32(v49);
      unint64_t v15 = (size + ((_DWORD)v50 << 14));
      if (vm_alloc((vm_address_t *)&__dst, v15, &v86))
      {
        CFDataRef v12 = (char *)__dst;
        *(void *)__dst = *v10;
        if (!v49)
        {
          uint64_t v13 = 0;
          goto LABEL_57;
        }

        uint64_t v51 = 0LL;
        CFIndex v52 = v12 + 0x4000;
        while (1)
        {
          CCCryptorStatus v53 = &v12[v51];
          uint64_t v54 = *(_OWORD *)((char *)v10 + v51 + 8);
          *((_DWORD *)v53 + 6) = *(_DWORD *)((char *)v10 + v51 + 24);
          *(_OWORD *)(v53 + _Block_object_dispose((const void *)(v1 - 64), 8) = v54;
          CFIndex v55 = bswap32(*(_DWORD *)((char *)v10 + v51 + 20));
          memcpy(v52, (char *)v10 + bswap32(*(_DWORD *)((char *)v10 + v51 + 16)), v55);
          __int16 v87 = v55;
          uint64_t v56 = v52 - v12;
          if (v52 < v12)
          {
            log_error(&v86, "new architecture offset underflows");
            break;
          }

          if (HIDWORD(v56))
          {
            log_error(&v86, "new architecture offset is too large");
            break;
          }

          uint64_t v57 = &v12[v51];
          CFIndex v58 = v87;
          __int128 v59 = bswap32(v87);
          *((_DWORD *)v57 + 4) = bswap32(v56);
          *((_DWORD *)v57 + 5) = v59;
          *((_DWORD *)v57 + 6) = 234881024;
          v52 += (v58 + 0x3FFF) & 0xFFFFC000;
          v51 += 20LL;
          if (!--v50)
          {
            uint64_t v13 = v58 + v56;
            goto LABEL_57;
          }
        }

        uint64_t v39 = 0;
        goto LABEL_66;
      }

void SecCmsEnvelopedDataDecodeAfterData(uint64_t a1)
{
  if (a1)
  {
    unsigned int v2 = *(CCCryptorRef **)(a1 + 96);
    if (v2)
    {
      CCCryptorRelease(*v2);
      free(v2);
      *(void *)(a1 + 96) = 0LL;
    }
  }

CFTypeID CMSEncoderGetTypeID(void)
{
  CFTypeID result = cmsEncoderTypeID;
  if (!cmsEncoderTypeID)
  {
    pthread_once(&CMSEncoderGetTypeID_once, (void (*)(void))cmsEncoderClassInitialize);
    return cmsEncoderTypeID;
  }

  return result;
}

uint64_t cmsEncoderClassInitialize()
{
  uint64_t result = _CFRuntimeRegisterClass();
  cmsEncoderCFTypeID TypeID = result;
  return result;
}

double cmsEncoderInit(uint64_t a1)
{
  *(void *)(a1 + 144) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void cmsEncoderFinalize(void *a1)
{
  if (a1)
  {
    unsigned int v2 = (void *)a1[5];
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (const void *)a1[6];
    if (v3) {
      CFRelease(v3);
    }
    unint64_t v4 = (const void *)a1[7];
    if (v4) {
      CFRelease(v4);
    }
    int v5 = (const void *)a1[8];
    if (v5) {
      CFRelease(v5);
    }
    int v6 = (const void *)a1[13];
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = a1[11];
    if (v7)
    {
      SecCmsMessageDestroy(v7);
      a1[11] = 0LL;
    }

    int v8 = (uint64_t *)a1[12];
    if (v8) {
      SecCmsEncoderDestroy(v8);
    }
  }

OSStatus CMSEncoderCreate(CMSEncoderRef *cmsEncoderOut)
{
  if (!cmsEncoderTypeID) {
    pthread_once(&CMSEncoderGetTypeID_once, (void (*)(void))cmsEncoderClassInitialize);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return -108;
  }
  uint64_t v3 = Instance;
  OSStatus result = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(void *)(v3 + 116) = 0x200000004LL;
  *cmsEncoderOut = (CMSEncoderRef)v3;
  return result;
}

OSStatus CMSEncoderSetSignerAlgorithm(CMSEncoderRef cmsEncoder, CFStringRef digestAlgorithm)
{
  if (CFEqual(digestAlgorithm, @"sha1"))
  {
    int v4 = 4;
LABEL_5:
    OSStatus result = 0;
    *((_DWORD *)cmsEncoder + 29) = v4;
    return result;
  }

  if (CFEqual(digestAlgorithm, @"sha256"))
  {
    int v4 = 192;
    goto LABEL_5;
  }

  return -50;
}

OSStatus CMSEncoderAddSigners(CMSEncoderRef cmsEncoder, CFTypeRef signerOrArray)
{
  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4)) {
    return -50;
  }
  int v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 48);
  CFTypeID TypeID = SecIdentityGetTypeID();
  return cmsAppendToArray((uint64_t)signerOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopySigners(CMSEncoderRef cmsEncoder, CFArrayRef *signersOut)
{
  OSStatus result = -50;
  if (cmsEncoder && signersOut)
  {
    int v5 = (const void *)*((void *)cmsEncoder + 6);
    if (v5)
    {
      CFRetain(v5);
      int v6 = (const __CFArray *)*((void *)cmsEncoder + 6);
    }

    else
    {
      int v6 = 0LL;
    }

    OSStatus result = 0;
    *signersOut = v6;
  }

  return result;
}

OSStatus CMSEncoderAddRecipients(CMSEncoderRef cmsEncoder, CFTypeRef recipientOrArray)
{
  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4)) {
    return -50;
  }
  int v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 56);
  CFTypeID TypeID = SecCertificateGetTypeID();
  return cmsAppendToArray((uint64_t)recipientOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopyRecipients(CMSEncoderRef cmsEncoder, CFArrayRef *recipientsOut)
{
  OSStatus result = -50;
  if (cmsEncoder && recipientsOut)
  {
    int v5 = (const void *)*((void *)cmsEncoder + 7);
    if (v5)
    {
      CFRetain(v5);
      int v6 = (const __CFArray *)*((void *)cmsEncoder + 7);
    }

    else
    {
      int v6 = 0LL;
    }

    OSStatus result = 0;
    *recipientsOut = v6;
  }

  return result;
}

OSStatus CMSEncoderAddSupportingCerts(CMSEncoderRef cmsEncoder, CFTypeRef certOrArray)
{
  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4)) {
    return -50;
  }
  int v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 64);
  CFTypeID TypeID = SecCertificateGetTypeID();
  return cmsAppendToArray((uint64_t)certOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopySupportingCerts(CMSEncoderRef cmsEncoder, CFArrayRef *certsOut)
{
  OSStatus result = -50;
  if (cmsEncoder && certsOut)
  {
    int v5 = (const void *)*((void *)cmsEncoder + 8);
    if (v5)
    {
      CFRetain(v5);
      int v6 = (const __CFArray *)*((void *)cmsEncoder + 8);
    }

    else
    {
      int v6 = 0LL;
    }

    OSStatus result = 0;
    *certsOut = v6;
  }

  return result;
}

OSStatus CMSEncoderSetHasDetachedContent(CMSEncoderRef cmsEncoder, Boolean detachedContent)
{
  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4)) {
    return -50;
  }
  OSStatus result = 0;
  *((_BYTE *)cmsEncoder + 24) = detachedContent;
  return result;
}

OSStatus CMSEncoderGetHasDetachedContent(CMSEncoderRef cmsEncoder, Boolean *detachedContentOut)
{
  OSStatus result = -50;
  if (cmsEncoder)
  {
    if (detachedContentOut)
    {
      OSStatus result = 0;
      *detachedContentOut = *((_BYTE *)cmsEncoder + 24);
    }
  }

  return result;
}

OSStatus CMSEncoderSetEncapsulatedContentTypeOID(CMSEncoderRef cmsEncoder, CFTypeRef eContentTypeOID)
{
  v5.CFIndex Length = 0LL;
  v5.Data = 0LL;
  OSStatus v3 = CMSEncoderSetEncapsulatedContentType(cmsEncoder, &v5);
  if (v5.Data) {
    free(v5.Data);
  }
  return v3;
}

uint64_t convertOid(const __CFString *a1, void *a2)
{
  if (!a2) {
    return 4294967246LL;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
  {
    CFTypeID v22 = CFGetTypeID(a1);
    if (v22 == CFDataGetTypeID())
    {
      unsigned int Length = CFDataGetLength((CFDataRef)a1);
      int v20 = malloc(Length);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      memcpy(v20, BytePtr, Length);
LABEL_15:
      uint64_t v5 = 0LL;
      *a2 = Length;
      a2[1] = v20;
      return v5;
    }

    return 4294967246LL;
  }

  uint64_t v5 = 4294899624LL;
  CFIndex v6 = CFStringGetLength(a1);
  if ((v6 & 0x8000000000000000LL) == 0)
  {
    uint64_t v7 = 3 * v6;
    int v8 = (char *)malloc(3 * v6);
    if (v8)
    {
      unint64_t v9 = v8;
      if (CFStringGetCString(a1, v8, v7 - 1, 0x600u))
      {
        int v10 = CFStringCreateWithCString(0LL, v9, 0x600u);
        if (v10)
        {
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, v10, @".");
          CFDataRef v12 = ArrayBySeparatingStrings;
          if (ArrayBySeparatingStrings)
          {
            CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
            if (Count >= 3)
            {
              unint64_t v14 = Count;
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, 0LL);
              int v16 = cfStringToNumber(ValueAtIndex);
              if ((v16 & 0x80000000) == 0)
              {
                char v17 = v16;
                uint64_t v18 = (const __CFString *)CFArrayGetValueAtIndex(v12, 1LL);
                int v19 = cfStringToNumber(v18);
                if ((v19 & 0x80000000) == 0 && v14 <= 0x1000000000000000LL)
                {
                  uint64_t v51 = v9;
                  char v50 = v19 + 40 * v17;
                  unint64_t v28 = v14 - 2;
                  unsigned int v26 = malloc(8 * (v14 - 2));
                  unsigned int v25 = malloc(4 * (v14 - 2));
                  uint64_t v29 = 0LL;
                  int v30 = 1;
                  CFIndex v52 = v12;
                  CCCryptorStatus v53 = v10;
                  unint64_t v54 = v28;
                  do
                  {
                    CFDataRef v31 = (const __CFString *)CFArrayGetValueAtIndex(v12, v29 + 2);
                    unsigned int v32 = cfStringToNumber(v31);
                    if ((v32 & 0x80000000) != 0)
                    {
                      int v20 = 0LL;
                      unsigned int Length = 0;
                      char v24 = 0;
                      unint64_t v9 = v51;
                      goto LABEL_19;
                    }

                    unsigned int v33 = v32;
                    if (v32)
                    {
                      uint64_t v34 = 0LL;
                      LODWORD(v35) = 0;
                      uint64_t v36 = 1LL;
                      unsigned int v37 = v32;
                      do
                      {
                        int v38 = v35;
                        uint64_t v39 = v34;
                        uint64_t v40 = v36;
                        size_t v35 = (v35 + 1);
                        ++v34;
                        ++v36;
                        BOOL v41 = v37 > 0x7F;
                        v37 >>= 7;
                      }

                      while (v41);
                      uint64_t v42 = malloc(v35);
                      uint64_t v43 = v39;
                      do
                      {
                        v42[--v40] = v33 & 0x7F;
                        v33 >>= 7;
                        --v43;
                      }

                      while (v43 != -1);
                      if (v38)
                      {
                        uint64_t v44 = 0LL;
                        do
                          v42[v44++] |= 0x80u;
                        while (v39 != v44);
                      }

                      v26[v29] = v42;
                      CFDataRef v12 = v52;
                      int v10 = v53;
                      unint64_t v28 = v54;
                    }

                    else
                    {
                      LODWORD(v35) = 1;
                      CFTypeRef v45 = malloc(1uLL);
                      v26[v29] = v45;
                      *CFTypeRef v45 = 0;
                    }

                    v25[v29] = v35;
                    v30 += v35;
                    ++v29;
                  }

                  while (v29 != v28);
                  unsigned int Length = v30 + 2;
                  int v20 = malloc((v30 + 2));
                  uint64_t v46 = 0LL;
                  *int v20 = 6;
                  v20[1] = v30;
                  v20[2] = v50;
                  uint64_t v47 = v20 + 3;
                  unint64_t v9 = v51;
                  do
                  {
                    if (v25[v46])
                    {
                      unint64_t v48 = 0LL;
                      do
                      {
                        v47[v48] = *(_BYTE *)(v26[v46] + v48);
                        ++v48;
                      }

                      while (v48 < v25[v46]);
                      v47 += v48;
                    }

                    ++v46;
                  }

                  while (v46 != v28);
                  if (v26)
                  {
                    uint64_t v49 = 0LL;
                    char v24 = 1;
                    do
                      free((void *)v26[v49++]);
                    while (v54 != v49);
                  }

                  else
                  {
                    char v24 = 1;
                  }

OSStatus CMSEncoderSetEncapsulatedContentType(CMSEncoderRef cmsEncoder, const SecAsn1Oid *eContentType)
{
  OSStatus result = -50;
  if (cmsEncoder && eContentType && !*((_DWORD *)cmsEncoder + 4))
  {
    uint64_t v5 = (void *)*((void *)cmsEncoder + 5);
    if (v5) {
      free(v5);
    }
    size_t Length = eContentType->Length;
    uint64_t v7 = malloc(eContentType->Length);
    *((void *)cmsEncoder + 5) = v7;
    memmove(v7, eContentType->Data, Length);
    OSStatus result = 0;
    *((void *)cmsEncoder + 4) = Length;
  }

  return result;
}

uint64_t cfStringToNumber(const __CFString *a1)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = v1;
  v3[1] = v1;
  else {
    return 0xFFFFFFFFLL;
  }
}

OSStatus CMSEncoderCopyEncapsulatedContentType(CMSEncoderRef cmsEncoder, CFDataRef *eContentTypeOut)
{
  OSStatus result = -50;
  if (cmsEncoder && eContentTypeOut)
  {
    uint64_t v5 = (const UInt8 *)*((void *)cmsEncoder + 5);
    if (!v5)
    {
      uint64_t v7 = 0LL;
      goto LABEL_7;
    }

    CFIndex v6 = *((void *)cmsEncoder + 4);
    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v7 = CFDataCreate(0LL, v5, v6);
LABEL_7:
      OSStatus result = 0;
      *eContentTypeOut = v7;
      return result;
    }

    return -108;
  }

  return result;
}

OSStatus CMSEncoderAddSignedAttributes(CMSEncoderRef cmsEncoder, CMSSignedAttributes signedAttributes)
{
  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4)) {
    return -50;
  }
  OSStatus result = 0;
  *((_DWORD *)cmsEncoder + 18) |= signedAttributes;
  return result;
}

uint64_t CMSEncoderSetSigningTime(uint64_t a1, double a2)
{
  if (!a1 || *(_DWORD *)(a1 + 16)) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *(double *)(a1 + 80) = a2;
  return result;
}

uint64_t CMSEncoderSetAppleCodesigningHashAgility(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 4294967246LL;
  }
  if (*(_DWORD *)(a1 + 16)) {
    return 4294967246LL;
  }
  if (cf) {
    CFRetain(cf);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = cf;
  return result;
}

uint64_t CMSEncoderSetAppleCodesigningHashAgilityV2(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 4294967246LL;
  }
  if (*(_DWORD *)(a1 + 16)) {
    return 4294967246LL;
  }
  if (cf) {
    CFRetain(cf);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 136) = cf;
  return result;
}

uint64_t CMSEncoderSetAppleExpirationTime(uint64_t a1, double a2)
{
  if (!a1 || *(_DWORD *)(a1 + 16)) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *(double *)(a1 + 144) = a2;
  return result;
}

OSStatus CMSEncoderSetCertificateChainMode(CMSEncoderRef cmsEncoder, CMSCertificateChainMode chainMode)
{
  if (!cmsEncoder) {
    return -50;
  }
  OSStatus result = -50;
  if (chainMode <= kCMSCertificateChainWithRootOrFail && !*((_DWORD *)cmsEncoder + 4))
  {
    OSStatus result = 0;
    *((_DWORD *)cmsEncoder + 30) = chainMode;
  }

  return result;
}

OSStatus CMSEncoderGetCertificateChainMode(CMSEncoderRef cmsEncoder, CMSCertificateChainMode *chainModeOut)
{
  if (!cmsEncoder) {
    return -50;
  }
  OSStatus result = 0;
  *chainModeOut = *((CMSCertificateChainMode *)cmsEncoder + 30);
  return result;
}

OSStatus CMSEncoderUpdateContent(CMSEncoderRef cmsEncoder, const void *content, size_t contentLen)
{
  if (cmsEncoder)
  {
    CMSEncoderRef v3 = cmsEncoder;
    int v4 = *((_DWORD *)cmsEncoder + 4);
    LODWORD(cmsEncoder) = -50;
    switch(v4)
    {
      case 0:
        LODWORD(cmsEncoder) = cmsSetupCmsMsg((uint64_t)v3);
        if (!(_DWORD)cmsEncoder) {
          goto LABEL_4;
        }
        break;
      case 1:
LABEL_4:
        LODWORD(cmsEncoder) = cmsSetupEncoder((uint64_t)v3);
        if (!(_DWORD)cmsEncoder)
        {
          *((_DWORD *)v3 + 4) = 2;
          goto LABEL_6;
        }

        break;
      case 2:
LABEL_6:
        cmsEncoder = (CMSEncoderRef)SecCmsEncoderUpdate(*((void *)v3 + 12), (char *)content, contentLen);
        if ((_DWORD)cmsEncoder) {
          LODWORD(cmsEncoder) = cmsRtnToOSStatusDefault((uint64_t)cmsEncoder, 0);
        }
        break;
      case 3:
        return (int)cmsEncoder;
      default:
        LODWORD(cmsEncoder) = -2070;
        break;
    }
  }

  else
  {
    LODWORD(cmsEncoder) = -50;
  }

  return (int)cmsEncoder;
}

uint64_t cmsSetupCmsMsg(uint64_t a1)
{
  if (*(void *)(a1 + 48) || *(void *)(a1 + 64))
  {
    *(_DWORD *)(a1 + 20) = 2 * (*(void *)(a1 + 56) != 0LL);
    uint64_t v2 = cmsSetupForSignedData(a1);
  }

  else
  {
    uint64_t v5 = *(const __CFArray **)(a1 + 56);
    if (!v5) {
      return 4294967246LL;
    }
    *(_DWORD *)(a1 + 20) = 1;
    unint64_t Count = CFArrayGetCount(v5);
    if (Count > 0xFFFFFFFFFFFFFFDLL)
    {
      uint64_t v3 = 4294967188LL;
      goto LABEL_5;
    }

    uint64_t v7 = Count;
    int v8 = (__SecCertificate **)malloc(8 * Count + 8);
    if (v7)
    {
      for (CFIndex i = 0LL; i != v7; ++i)
        v8[i] = (__SecCertificate *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), i);
    }

    int v18 = -1431655766;
    unsigned int v19 = -1431655766;
    v8[v7] = 0LL;
    uint64_t v3 = SecSMIMEFindBulkAlgForRecipients(v8, &v19, &v18);
    free(v8);
    if ((_DWORD)v3) {
      goto LABEL_5;
    }
    uint64_t v10 = *(void *)(a1 + 88);
    if (v10) {
      SecCmsMessageDestroy(v10);
    }
    uint64_t v11 = SecCmsMessageCreate();
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = v11;
    if (!v11 || (unint64_t v12 = SecCmsEnvelopedDataCreate(v11, v19, v18)) == 0)
    {
      uint64_t v3 = 4294965226LL;
      goto LABEL_5;
    }

    uint64_t v13 = v12;
    uint64_t v14 = SecCmsContentInfoSetContent(*(unint64_t **)(a1 + 88), 0x1Bu, v12);
    if (!(_DWORD)v14)
    {
      uint64_t v14 = *(void *)(a1 + 40)
          ? SecCmsContentInfoSetContentOther(v13, 0LL, 0, a1 + 32)
          : SecCmsContentInfoSetContentData((unint64_t *)v13, 0LL, *(unsigned __int8 *)(a1 + 24));
      if (!(_DWORD)v14)
      {
        if (v7 < 1)
        {
          uint64_t v3 = 0LL;
          goto LABEL_5;
        }

        CFIndex v15 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v15);
          uint64_t v17 = nss_cmsrecipientinfo_create(v13, 0, ValueAtIndex, 0LL);
          uint64_t v3 = 0LL;
          if (v7 == ++v15) {
            goto LABEL_5;
          }
        }

        uint64_t v14 = 0xFFFFFFFFLL;
      }
    }

    uint64_t v2 = cmsRtnToOSStatusDefault(v14, 0);
  }

  uint64_t v3 = v2;
LABEL_5:
  *(_DWORD *)(a1 + 16) = 1;
  return v3;
}

uint64_t cmsSetupEncoder(uint64_t a1)
{
  CFMutableDataRef Mutable = CFDataCreateMutable(0LL, 0LL);
  *(void *)(a1 + 104) = Mutable;
  if (!Mutable) {
    return 4294967188LL;
  }
  uint64_t result = SecCmsEncoderCreate( *(uint64_t **)(a1 + 88),  0LL,  0LL,  (uint64_t)Mutable,  v3,  0LL,  0LL,  0LL,  (void *)(a1 + 96));
  if ((_DWORD)result) {
    return cmsRtnToOSStatusDefault(result, 0);
  }
  return result;
}

uint64_t cmsSetupForSignedData(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2) {
    SecCmsMessageDestroy(v2);
  }
  uint64_t v3 = SecCmsMessageCreate();
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = v3;
  if (!v3) {
    return 4294965226LL;
  }
  uint64_t v4 = v3;
  unint64_t v5 = PORT_ArenaAlloc(*(void *)(v3 + 120), 0xB8uLL);
  if (!v5) {
    return 4294965226LL;
  }
  CFIndex v6 = (unint64_t *)v5;
  *(void *)(v5 + 176) = 0LL;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
  *(_OWORD *)(v5 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)unint64_t v5 = 0u;
  *(void *)(v5 + 24) = v4;
  uint64_t v7 = SecCmsContentInfoSetContent(*(unint64_t **)(a1 + 88), 0x1Au, v5);
  if (!(_DWORD)v7)
  {
    if (*(void *)(a1 + 40))
    {
      uint64_t v7 = SecCmsContentInfoSetContentOther((uint64_t)v6, 0LL, *(unsigned __int8 *)(a1 + 24), a1 + 32);
      if (!(_DWORD)v7)
      {
LABEL_12:
        uint64_t v10 = *(const __CFArray **)(a1 + 64);
        if (v10 && SecCmsSignedDataAddCertList((uint64_t)v6, v10))
        {
          uint64_t v7 = 0xFFFFFFFFLL;
          return cmsRtnToOSStatusDefault(v7, 0);
        }

        uint64_t v11 = *(const __CFArray **)(a1 + 48);
        if (!v11) {
          return 0LL;
        }
        CFIndex Count = CFArrayGetCount(v11);
        int v13 = *(_DWORD *)(a1 + 120) >= 5u ? 2 : *(_DWORD *)(a1 + 120);
        if (Count < 1) {
          return 0LL;
        }
        CFIndex v14 = Count;
        CFIndex v15 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v15);
          uint64_t v17 = (const void *)ValueAtIndex[2];
          CFRetain(v17);
          uint64_t v18 = SecCmsSignerInfoCreate((uint64_t)v6, (uint64_t)ValueAtIndex, *(_DWORD *)(a1 + 116));
          if (!v18)
          {
            uint64_t v8 = 4294965226LL;
            goto LABEL_59;
          }

          uint64_t v19 = v18;
          if (SecCmsSignerInfoIncludeCerts(v18, v13))
          {
LABEL_55:
            uint64_t v23 = 0xFFFFFFFFLL;
            goto LABEL_58;
          }

          int v20 = *(_DWORD *)(a1 + 72);
          if ((v20 & 1) != 0)
          {
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 2) != 0)
          {
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 4) != 0)
          {
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 8) != 0)
          {
            double Current = *(double *)(a1 + 80);
            if (Current == 0.0)
            {
              double Current = CFAbsoluteTimeGetCurrent();
              *(double *)(a1 + 80) = Current;
            }

            uint64_t v22 = SecCmsSignerInfoAddSigningTime(v19, Current);
            if ((_DWORD)v22) {
              break;
            }
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 0x10) != 0)
          {
            uint64_t v23 = SecCmsSignerInfoAddAppleCodesigningHashAgility(v19, *(CFDataRef *)(a1 + 128));
            char v24 = *(const void **)(a1 + 128);
            if (v24)
            {
              *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0LL;
              CFRelease(v24);
            }

            if ((_DWORD)v23) {
              goto LABEL_58;
            }
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 0x20) != 0)
          {
            uint64_t v23 = SecCmsSignerInfoAddAppleCodesigningHashAgilityV2(v19, *(const __CFDictionary **)(a1 + 136));
            unsigned int v25 = *(const void **)(a1 + 136);
            if (v25)
            {
              *(void *)(a1 + 136) = 0LL;
              CFRelease(v25);
            }

            if ((_DWORD)v23) {
              goto LABEL_58;
            }
            int v20 = *(_DWORD *)(a1 + 72);
          }

          if ((v20 & 0x40) != 0)
          {
            uint64_t v22 = SecCmsSignerInfoAddAppleExpirationTime(v19, *(CFAbsoluteTime *)(a1 + 144));
            if ((_DWORD)v22) {
              break;
            }
          }

          if (v17) {
            CFRelease(v17);
          }
          uint64_t v8 = 0LL;
          if (v14 == ++v15) {
            return v8;
          }
        }

        uint64_t v23 = v22;
LABEL_58:
        uint64_t v8 = cmsRtnToOSStatusDefault(v23, 0);
LABEL_59:
        if ((_DWORD)v8 && v17) {
          CFRelease(v17);
        }
        return v8;
      }
    }

    else
    {
      uint64_t v7 = SecCmsContentInfoSetContentData(v6, 0LL, *(unsigned __int8 *)(a1 + 24));
      if (!(_DWORD)v7) {
        goto LABEL_12;
      }
    }
  }

  return cmsRtnToOSStatusDefault(v7, 0);
}

OSStatus CMSEncoderCopyEncodedContent(CMSEncoderRef cmsEncoder, CFDataRef *encodedContentOut)
{
  OSStatus v2 = -50;
  if (!cmsEncoder || !encodedContentOut) {
    return v2;
  }
  unsigned int v5 = *((_DWORD *)cmsEncoder + 4);
  if (v5 >= 2)
  {
    if (v5 == 3) {
      return v2;
    }
  }

  else
  {
    if (*((void *)cmsEncoder + 6)) {
      return v2;
    }
    if (*((void *)cmsEncoder + 7)) {
      return v2;
    }
    if (!*((void *)cmsEncoder + 8)) {
      return v2;
    }
    OSStatus v2 = cmsSetupForSignedData((uint64_t)cmsEncoder);
    if (v2) {
      return v2;
    }
    OSStatus v2 = cmsSetupEncoder((uint64_t)cmsEncoder);
    if (v2) {
      return v2;
    }
  }

  uint64_t v7 = SecCmsEncoderFinish(*((_DWORD **)cmsEncoder + 12));
  *((void *)cmsEncoder + 12) = 0LL;
  if (!(_DWORD)v7)
  {
    *((_DWORD *)cmsEncoder + 4) = 3;
    uint64_t v8 = (const __CFData *)*((void *)cmsEncoder + 13);
    if (v8)
    {
      if (!*((_BYTE *)cmsEncoder + 112))
      {
        if (*((_DWORD *)cmsEncoder + 5) > 1u)
        {
          SecAsn1CoderRef coder = 0LL;
          __int128 v11 = 0uLL;
          OSStatus v2 = SecAsn1CoderCreate(&coder);
          if (!v2)
          {
            if (CFDataGetLength(*((CFDataRef *)cmsEncoder + 13)) < 0)
            {
              return -108;
            }

            else
            {
              CFIndex Length = CFDataGetLength(*((CFDataRef *)cmsEncoder + 13));
              MutableBytePtr = (char *)CFDataGetMutableBytePtr(*((CFMutableDataRef *)cmsEncoder + 13));
              OSStatus v2 = cmsContentInfoContent((uint64_t *)coder, Length, MutableBytePtr, &v11);
              if (!v2) {
                OSStatus v2 = CMSEncode( 0LL,  *((CFTypeRef *)cmsEncoder + 7),  &CSSMOID_PKCS7_SignedData,  0,  0,  *((const void **)&v11 + 1),  v11,  encodedContentOut);
              }
              if (coder) {
                SecAsn1CoderRelease(coder);
              }
            }
          }
        }

        else
        {
          OSStatus v2 = 0;
          *encodedContentOut = CFDataCreateCopy(0LL, v8);
        }

        return v2;
      }
    }

    else if (!*((_BYTE *)cmsEncoder + 112))
    {
      return -2070;
    }

    OSStatus v2 = 0;
    *encodedContentOut = 0LL;
    return v2;
  }

  return cmsRtnToOSStatusDefault(v7, 0);
}

uint64_t cmsContentInfoContent(uint64_t *a1, unint64_t a2, char *a3, _OWORD *a4)
{
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  uint64_t result = 4294967246LL;
  if (a1 && a3)
  {
    if (SEC_ASN1Decode(*a1, (uint64_t)&v7, (uint64_t)&cmsSimpleContentInfoTemplate, a3, a2))
    {
      return 4294941021LL;
    }

    else if (*((void *)&v8 + 1))
    {
      uint64_t result = 0LL;
      *a4 = v8;
    }

    else
    {
      return 4294965226LL;
    }
  }

  return result;
}

OSStatus CMSEncode( CFTypeRef signers, CFTypeRef recipients, const SecAsn1Oid *eContentType, Boolean detachedContent, CMSSignedAttributes signedAttributes, const void *content, size_t contentLen, CFDataRef *encodedContentOut)
{
  OSStatus updated = -50;
  if (!encodedContentOut) {
    return updated;
  }
  int v13 = detachedContent;
  CMSEncoderRef cmsEncoderOut = (CMSEncoderRef)0xAAAAAAAAAAAAAAAALL;
  OSStatus updated = CMSEncoderCreate(&cmsEncoderOut);
  if (updated) {
    return updated;
  }
  CMSEncoderRef v17 = cmsEncoderOut;
  if ((!signers || (OSStatus updated = CMSEncoderAddSigners(cmsEncoderOut, signers)) == 0)
    && (!recipients || (OSStatus updated = CMSEncoderAddRecipients(v17, recipients)) == 0)
    && (!eContentType || (OSStatus updated = CMSEncoderSetEncapsulatedContentType(v17, eContentType)) == 0))
  {
    if (v13)
    {
      if (!v17) {
        return -50;
      }
      if (*((_DWORD *)v17 + 4))
      {
LABEL_17:
        OSStatus updated = -50;
LABEL_23:
        CFRelease(v17);
        return updated;
      }

      *((_BYTE *)v17 + 24) = v13;
    }

    if (!signedAttributes)
    {
LABEL_20:
      OSStatus updated = CMSEncoderUpdateContent(v17, content, contentLen);
      if (!updated) {
        OSStatus updated = CMSEncoderCopyEncodedContent(v17, encodedContentOut);
      }
      goto LABEL_22;
    }

    if (v17)
    {
      if (*((_DWORD *)v17 + 4)) {
        goto LABEL_17;
      }
      *((_DWORD *)v17 + 18) |= signedAttributes;
      goto LABEL_20;
    }

    return -50;
  }

OSStatus CMSEncodeContent( CFTypeRef signers, CFTypeRef recipients, CFTypeRef eContentTypeOID, Boolean detachedContent, CMSSignedAttributes signedAttributes, const void *content, size_t contentLen, CFDataRef *encodedContentOut)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  if (eContentTypeOID)
  {
    CFIndex v15 = (const SecAsn1Oid *)&v18;
  }

  else
  {
    CFIndex v15 = 0LL;
  }

  OSStatus v16 = CMSEncode(signers, recipients, v15, detachedContent, signedAttributes, content, contentLen, encodedContentOut);
  if (v19) {
    free(v19);
  }
  return v16;
}

uint64_t CMSEncoderGetCmsMessage(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v5 = *(void *)(a1 + 88);
    if (v5)
    {
      uint64_t result = 0LL;
      *a2 = v5;
    }

    else
    {
      uint64_t result = cmsSetupCmsMsg(a1);
      if (!(_DWORD)result)
      {
        *a2 = *(void *)(a1 + 88);
        *(_DWORD *)(a1 + 16) = 1;
      }
    }
  }

  return result;
}

uint64_t CMSEncoderSetEncoder(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      int v5 = *(_DWORD *)(a1 + 16);
      if (v5 == 1 || !v5 && (uint64_t result = cmsSetupCmsMsg(a1), !(_DWORD)result))
      {
        uint64_t result = 0LL;
        *(void *)(a1 + 96) = a2;
        *(_DWORD *)(a1 + 16) = 2;
        *(_BYTE *)(a1 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 1;
      }
    }
  }

  return result;
}

uint64_t CMSEncoderGetEncoder(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(void *)(a1 + 96);
    }
  }

  return result;
}

uint64_t SecCmsRecipientInfoCreate(uint64_t a1, void *a2)
{
  return nss_cmsrecipientinfo_create(a1, 0, a2, 0LL);
}

uint64_t nss_cmsrecipientinfo_create(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 24) + 120LL);
  uint64_t v9 = PORT_ArenaAlloc(v8, 0x98uLL);
  if (!v9) {
    return 0LL;
  }
  uint64_t v10 = v9;
  *(_OWORD *)(v9 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = 0u;
  *(_OWORD *)(v9 + 12_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  *(void *)(v9 + 136) = a1;
  *(void *)(v9 + 144) = 0LL;
  if (!a3) {
    return 0LL;
  }
  CFRetain(a3);
  *(void *)(v10 + 144) = a3;
  uint64_t v11 = a3[27];
  v27[0] = a3[28];
  v27[1] = v11;
  uint64_t v12 = a3[29];
  void v27[2] = a3[30];
  v27[3] = v12;
  if (!v11 || (uint64_t OID = SECOID_FindOID((uint64_t)v27)) == 0)
  {
    int v15 = -8186;
    goto LABEL_11;
  }

  int v14 = *(_DWORD *)(OID + 16);
  int v15 = -8186;
  if (v14 > 57)
  {
    switch(v14)
    {
      case 58:
        goto LABEL_21;
      case 174:
        if (a2 == 1) {
          return 0LL;
        }
        *(_DWORD *)uint64_t v10 = 1;
        if (!*(void *)(v10 + 32)) {
          return 0LL;
        }
        break;
      case 202:
        if (a2 == 1) {
          return 0LL;
        }
        *(_DWORD *)uint64_t v10 = 1;
        CertIssuerAndSN = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
        *(void *)(v10 + 32) = CertIssuerAndSN;
        if (!CertIssuerAndSN) {
          return 0LL;
        }
        break;
      default:
        goto LABEL_11;
    }

    uint64_t v21 = PORT_ArenaAlloc(v8, 0x48uLL);
    if (!v21) {
      return 0LL;
    }
    uint64_t v22 = v21;
    *(void *)(v21 + 64) = 0LL;
    *(_OWORD *)(v21 + 32) = 0u;
    *(_OWORD *)(v21 + 4_Block_object_dispose((const void *)(v1 - 64), 8) = 0u;
    *(_OWORD *)uint64_t v21 = 0u;
    *(_OWORD *)(v21 + 16) = 0u;
    uint64_t v23 = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
    *(void *)(v22 + _Block_object_dispose((const void *)(v1 - 64), 8) = v23;
    if (!v23) {
      return 0LL;
    }
    *(_DWORD *)(v10 + 24) = 2;
  }

  else
  {
    if (v14 != 16)
    {
      if (v14 != 54 && v14 != 56)
      {
LABEL_11:
        ThreadErrInfo = PR_getThreadErrInfo(1, &v28);
        if (ThreadErrInfo)
        {
          _DWORD *ThreadErrInfo = 0;
          ThreadErrInfo[1] = v15;
        }

        return 0LL;
      }

LABEL_35:
  int v24 = *(_DWORD *)v10;
  if (*(_DWORD *)v10 == 2)
  {
    uint64_t v26 = v8;
    unint64_t v25 = 4LL;
  }

  else if (v24 == 1)
  {
    uint64_t v26 = v8;
    unint64_t v25 = 3LL;
  }

  else
  {
    if (v24) {
      goto LABEL_42;
    }
    unint64_t v25 = 2LL * (*(_DWORD *)(v10 + 24) != 0);
    uint64_t v26 = v8;
  }

  if (SEC_ASN1EncodeInteger(v26, (void *)(v10 + 8), v25))
  {
LABEL_42:
  }

  return 0LL;
}

          sec_asn1e_init_state_based_on_template(v23);
        }

        goto LABEL_131;
      case 1:
        if (!*(_DWORD *)(a1 + 24))
        {
          uint64_t v36 = *(void *)(v10 + 48);
          if (v36 <= 15)
          {
            if (v36 == 2)
            {
              uint64_t v66 = *(uint64_t **)(v10 + 16);
              uint64_t v67 = *v66;
              if (*v66)
              {
                CFIndex v68 = (char *)v66[1];
                unint64_t v69 = *(_DWORD *)(v10 + 84);
                uint64_t v70 = *v68;
                if ((*v68 & 0x80000000) == 0)
                {
                  unint64_t v71 = v67;
                  uint64_t v72 = v68;
                  goto LABEL_136;
                }

  if (v9) {
    goto LABEL_36;
  }
  return v6;
}

uint64_t SecCmsRecipientInfoCreateWithSubjKeyID(uint64_t a1, uint64_t a2)
{
  return nss_cmsrecipientinfo_create(a1, 1, 0LL, a2);
}

CFDataRef SecCmsRecipientInfoCreateWithSubjKeyIDFromCert(uint64_t a1, const __CFData *a2)
{
  uint64_t result = 0LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = SecCertificateGetSubjectKeyID(a2);
      if (result)
      {
        int v5 = result;
        if (CFDataGetLength(result) < 0)
        {
          return 0LL;
        }

        else
        {
          v6[0] = CFDataGetLength(v5);
          v6[1] = CFDataGetBytePtr(v5);
          return (const __CFData *)nss_cmsrecipientinfo_create(a1, 1, a2, (uint64_t)v6);
        }
      }
    }
  }

  return result;
}

void SecCmsContentInfoDestroy(uint64_t *a1)
{
  if (a1)
  {
    uint64_t OID = a1[4];
    if (OID || (uint64_t OID = SECOID_FindOID((uint64_t)a1), (a1[4] = OID) != 0))
    {
      switch(*(_DWORD *)(OID + 16))
      {
        case 0x1A:
          SecCmsSignedDataDestroy(a1[2]);
          break;
        case 0x1B:
          SecCmsEnvelopedDataDestroy(a1[2]);
          break;
        case 0x1D:
        case 0x1E:
          uint64_t v3 = a1[2];
          if (v3) {
            SecCmsContentInfoDestroy(v3);
          }
          break;
        default:
          break;
      }
    }

    uint64_t v4 = a1[13];
    if (v4)
    {
      SecCmsDigestContextCancel(v4);
      a1[13] = 0LL;
    }

    int v5 = (const void *)a1[10];
    if (v5)
    {
      a1[10] = 0LL;
      CFRelease(v5);
    }

    CFIndex v6 = (const void *)a1[14];
    if (v6)
    {
      a1[14] = 0LL;
      CFRelease(v6);
    }

    __int128 v7 = (CCCryptorRef *)a1[12];
    if (v7)
    {
      CCCryptorRelease(*v7);
      free(v7);
      a1[12] = 0LL;
    }
  }

uint64_t SecCmsContentInfoGetContentTypeTag(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  uint64_t result = SECOID_FindOID(a1);
  *(void *)(a1 + 32) = result;
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t SecCmsContentInfoGetChildContentInfo(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result || (uint64_t result = SECOID_FindOID(a1), (*(void *)(a1 + 32) = result) != 0LL))
  {
    unsigned int v3 = *(_DWORD *)(result + 16);
    BOOL v4 = v3 > 0x1E;
    int v5 = (1 << v3) & 0x6C000000;
    if (v4 || v5 == 0) {
      return 0LL;
    }
    else {
      return *(void *)(a1 + 16);
    }
  }

  return result;
}

uint64_t SecCmsContentInfoSetContent(unint64_t *a1, unsigned int a2, unint64_t a3)
{
  if (a2 <= 0xD8) {
    CFIndex v6 = &oids[40 * a2];
  }
  else {
    CFIndex v6 = 0LL;
  }
  a1[4] = (unint64_t)v6;
  if (a2 > 0xD8) {
    return 4294967246LL;
  }
  a1[2] = a3;
  if (a2 != 25)
  {
    uint64_t v9 = SECITEM_AllocItem(*(void *)(a1[3] + 120), 0LL, 1uLL);
    a1[9] = (unint64_t)v9;
    if (!v9)
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE01300000000LL;
      }
      return 4294967188LL;
    }
  }

  return 0LL;
}

uint64_t SecCmsContentInfoSetContentData(unint64_t *a1, CFDataRef theData, int a3)
{
  if (theData)
  {
    if (CFDataGetLength(theData) < 0) {
      return 4294967188LL;
    }
    CFIndex v6 = (size_t *)PORT_ArenaAlloc(*(void *)(a1[3] + 120), 0x10uLL);
    CFIndex Length = CFDataGetLength(theData);
    size_t *v6 = Length;
    if (Length)
    {
      uint64_t v8 = (void *)PORT_ArenaAlloc(*(void *)(a1[3] + 120), Length);
      v6[1] = (size_t)v8;
      BytePtr = CFDataGetBytePtr(theData);
      memcpy(v8, BytePtr, *v6);
    }

    else
    {
      v6[1] = 0LL;
    }
  }

  else
  {
    CFIndex v6 = 0LL;
  }

  if (SecCmsContentInfoSetContent(a1, 0x19u, (unint64_t)v6))
  {
    uint64_t Error = PORT_GetError();
    ThreadErrInfo = PR_getThreadErrInfo(1, &v13);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0LL;
    }
  }

  else
  {
    if (a3)
    {
      CFIndex v6 = 0LL;
    }

    else if (!v6)
    {
      CFIndex v6 = SECITEM_AllocItem(*(void *)(a1[3] + 120), 0LL, 1uLL);
    }

    uint64_t Error = 0LL;
    a1[9] = (unint64_t)v6;
  }

  return Error;
}

uint64_t SecCmsContentInfoSetContentSignedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Au, a2);
}

uint64_t SecCmsContentInfoSetContentEnvelopedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Bu, a2);
}

uint64_t SecCmsContentInfoSetContentDigestedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Du, a2);
}

uint64_t SecCmsContentInfoSetContentEncryptedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Eu, a2);
}

uint64_t SecCmsContentInfoSetContentOther(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  uint64_t v8 = PORT_ArenaAlloc(*(void *)(*(void *)(a1 + 24) + 120LL), 0x28uLL);
  if (v8)
  {
    *(void *)(v8 + 32) = 0LL;
    *(_OWORD *)uint64_t v8 = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
  }

  *(void *)(a1 + 32) = v8;
  *(_OWORD *)uint64_t v8 = xmmword_18966A4A8;
  *(_OWORD *)(v8 + 16) = unk_18966A4B8;
  *(void *)(v8 + 32) = 0LL;
  *(void *)(a1 + 16) = a2;
  if (a3)
  {
    a2 = 0LL;
  }

  else if (!a2)
  {
    a2 = SECITEM_AllocItem(*(void *)(*(void *)(a1 + 24) + 120LL), 0LL, 1uLL);
  }

  uint64_t result = 0LL;
  *(void *)(a1 + 72) = a2;
  return result;
}

uint64_t SecCmsContentInfoGetContent(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 32);
    if (!v1) {
      return 0LL;
    }
    unsigned int v2 = *(_DWORD *)(v1 + 16);
    BOOL v3 = v2 > 0x1E;
    int v4 = (1 << v2) & 0x6E000000;
    if (v3 || v4 == 0) {
      return 0LL;
    }
    else {
      return *(void *)(result + 16);
    }
  }

  return result;
}

uint64_t SecCmsContentInfoGetInnerContent(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 || (uint64_t result = SECOID_FindOID(a1), v2 = result, (*(void *)(v1 + 32) = result) != 0LL))
  {
    uint64_t result = 0LL;
    unsigned int v4 = *(_DWORD *)(v2 + 16);
    if (v4 <= 0x1E)
    {
      if (((1 << v4) & 0x6C000000) != 0)
      {
        uint64_t result = SecCmsContentInfoGetChildContentInfo(v1);
        if (!result) {
          return result;
        }
        uint64_t v1 = result;
        uint64_t v5 = *(void *)(result + 32);
        if (!v5) {
          return 0LL;
        }
        unsigned int v6 = *(_DWORD *)(v5 + 16);
        BOOL v7 = v6 > 0x1E;
        int v8 = (1 << v6) & 0x6E000000;
        if (v7 || v8 == 0) {
          return 0LL;
        }
      }

      else if (v4 != 25)
      {
        return result;
      }

      return *(void *)(v1 + 16);
    }
  }

  return result;
}

uint64_t SecCmsContentInfoGetContentTypeOID(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!result)
  {
    uint64_t result = SECOID_FindOID(a1);
    *(void *)(a1 + 32) = result;
  }

  return result;
}

uint64_t SecCmsContentInfoGetContentEncAlgTag(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 92);
  if (!(_DWORD)result)
  {
    if (*(void *)(a1 + 48))
    {
      uint64_t result = SECOID_FindOID(a1 + 40);
      if (result) {
        uint64_t result = *(unsigned int *)(result + 16);
      }
    }

    else
    {
      uint64_t result = 0LL;
    }

    *(_DWORD *)(a1 + 92) = result;
  }

  return result;
}

uint64_t SecCmsContentInfoGetContentEncAlg(uint64_t a1)
{
  return a1 + 40;
}

uint64_t SecCmsContentInfoSetContentEncAlg(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t result = SECOID_SetAlgorithmID(*(void *)(*(void *)(a1 + 24) + 120LL), (unint64_t *)(a1 + 40), a2, a3);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = a4;
  return result;
}

uint64_t SecCmsContentInfoSetContentEncAlgID(uint64_t a1, uint64_t a2, int a3)
{
  if (SECOID_CopyAlgorithmID( *(void *)(*(void *)(a1 + 24) + 120LL),  (unint64_t *)(a1 + 40),  a2)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  if ((a3 & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = a3;
  }
  return result;
}

void SecCmsContentInfoSetBulkKey(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
    if (a1)
    {
      *(void *)(a1 + 80) = cf;
      CFIndex Length = CFDataGetLength((CFDataRef)cf);
      if (Length > 0xFFFFFFF)
      {
        unsigned int v6 = *(const void **)(a1 + 80);
        if (v6)
        {
          *(void *)(a1 + 80) = 0LL;
          CFRelease(v6);
        }

        int v5 = 0;
      }

      else
      {
        int v5 = 8 * Length;
      }

      *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 64), 8) = v5;
    }
  }

uint64_t SecCmsContentInfoGetBulkKey(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 80));
  }
  return v1;
}

uint64_t SecCmsContentInfoGetBulkKeySize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

const SecAsn1Template *cms_attr_choose_attr_value_template(const SecAsn1Template *result, int a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (a2 && LOBYTE(result[1].sub)) {
    return kSecAsn1AnyTemplate;
  }
  uint64_t OID = *(void *)&result[1].kind;
  if (OID || (uint64_t OID = SECOID_FindOID(v3), (*(void *)(v3 + 24) = OID) != 0LL))
  {
    int v5 = *(_DWORD *)(OID + 16);
    char v6 = 1;
    uint64_t result = kSecAsn1AnyTemplate;
    if (v5 <= 33)
    {
      if ((v5 - 31) >= 2)
      {
        if (v5 == 33)
        {
          uint64_t result = kSecAsn1ObjectIDTemplate;
          char v6 = 0;
        }

        else
        {
          char v6 = 1;
        }

        if (!a2) {
          goto LABEL_21;
        }
        return result;
      }

uint64_t SecCmsAttributeCreate(uint64_t a1, unsigned int a2, unint64_t *a3, char a4)
{
  uint64_t result = PORT_ArenaAlloc(a1, 0x28uLL);
  if (result)
  {
    uint64_t v9 = result;
    *(void *)(result + 32) = 0LL;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
    uint64_t result = 0LL;
    uint64_t v10 = a2 <= 0xD8 ? &oids[40 * a2] : 0LL;
    *(void *)(v9 + 24) = v10;
    if (a2 <= 0xD8)
    {
      if (!a3)
      {
LABEL_13:
        *(_BYTE *)(v9 + 32) = a4;
        return v9;
      }

      uint64_t result = (uint64_t)SECITEM_AllocItem(a1, 0LL, *a3);
      if (result)
      {
        uint64_t v11 = result;
        if (SECITEM_CopyItem(a1, (unint64_t *)result, (uint64_t)a3)
          || SecCmsArrayAdd(a1, (char **)(v9 + 16), v11))
        {
          return 0LL;
        }

        goto LABEL_13;
      }
    }
  }

  return result;
}

const void *SecCmsAttributeCompareValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(size_t **)v2;
  if (!*(void *)v2) {
    return 0LL;
  }
  uint64_t result = (const void *)v3[1];
  if (!result) {
    return result;
  }
  size_t v5 = *v3;
  if (*v3 && !*(void *)(v2 + 8) && v5 == *(void *)a2) {
    return (const void *)(memcmp(result, *(const void **)(a2 + 8), v5) == 0);
  }
  else {
    return 0LL;
  }
}

uint64_t SecCmsAttributeArrayFindAttrByOidTag(uint64_t *a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 0LL;
  }
  size_t v5 = a1;
  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  uint64_t v6 = 0LL;
  if (a2 <= 0xD8) {
    BOOL v7 = (size_t *)&oids[40 * a2];
  }
  else {
    BOOL v7 = 0LL;
  }
  if (a2 <= 0xD8)
  {
    uint64_t v6 = *v5;
    if (*v5)
    {
      size_t v8 = *v7;
      while (1)
      {
        uint64_t v9 = v5 + 1;
        if (*(void *)v6 == v8)
        {
          uint64_t v10 = (const void *)v7[1];
        }

        uint64_t v6 = *v9;
        ++v5;
        if (!*v9) {
          return v6;
        }
      }

      if (a3)
      {
        uint64_t v11 = *v9;
        if (*v9)
        {
          uint64_t v12 = 2LL;
          while (*(void *)v11 != v8 || memcmp(*(const void **)(v11 + 8), v10, v8))
          {
            uint64_t v11 = v5[v12++];
            if (!v11) {
              return v6;
            }
          }

          return 0LL;
        }
      }
    }
  }

  return v6;
}

uint64_t SecCmsAttributeArrayAddAttr(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t OID = SECOID_FindOID(a3);
  if (OID) {
    unsigned int v7 = *(_DWORD *)(OID + 16);
  }
  else {
    unsigned int v7 = 0;
  }
  if (SecCmsAttributeArrayFindAttrByOidTag(*a2, v7, 0)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = SecCmsArrayAdd(a1, (char **)a2, a3);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsAttributeArraySetAttr(uint64_t a1, uint64_t **a2, unsigned int a3, unint64_t *a4)
{
  uint64_t AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*a2, a3, 0);
  if (AttrByOidTag)
  {
    uint64_t v9 = AttrByOidTag;
    uint64_t result = 0LL;
    **(void **)(v9 + 16) = a4;
    *(_BYTE *)(v9 + 32) = 0;
  }

  else
  {
    uint64_t v11 = SecCmsAttributeCreate(a1, a3, a4, 0);
    if (!v11) {
      return 0xFFFFFFFFLL;
    }
    uint64_t result = SecCmsArrayAdd(a1, (char **)a2, v11);
    if ((_DWORD)result) {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t SecCmsCipherContextStart(uint64_t a1, CFDataRef theData, uint64_t a3, int a4)
{
  v24[2] = *MEMORY[0x1895F89C0];
  v24[0] = 0xAAAAAAAAAAAAAAAALL;
  v24[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v22 = 8LL;
  iv = v24;
  CCCryptorRef cryptorRef = 0LL;
  if (CFDataGetLength(theData) < 0) {
    return 0LL;
  }
  uint64_t result = SECOID_FindOID(a3);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  uint64_t result = 0LL;
  int v10 = *(_DWORD *)(v9 + 16);
  CCAlgorithm v11 = 1;
  if (v10 > 183)
  {
    CCAlgorithm v11 = 0;
    uint64_t v13 = 16LL;
    uint64_t v22 = 16LL;
    int v14 = 16;
    if (!a4) {
      goto LABEL_23;
    }
LABEL_13:
    if (v10 <= 0xE && ((1 << v10) & 0x5EC0) != 0
      || (uint64_t result = 0LL, (v10 - 153) <= 0x23)
      && ((1LL << (v10 + 103)) & 0xFC0000001LL) != 0)
    {
      uint64_t result = (uint64_t)SEC_ASN1EncodeItem(a1, (void *)(a3 + 16), (uint64_t)&v22, (uint64_t)kSecAsn1OctetStringTemplate);
      if (result) {
        goto LABEL_31;
      }
    }

    return result;
  }

  switch(v10)
  {
    case 5:
      CCAlgorithm v11 = 5;
      break;
    case 7:
      CCAlgorithm v11 = 2;
      break;
    case 10:
      break;
    default:
      return result;
  }

  uint64_t v13 = 8LL;
  int v14 = 8;
  if (a4) {
    goto LABEL_13;
  }
LABEL_23:
  if (v10 <= 0xE && ((1 << v10) & 0x5EC0) != 0
    || (uint64_t result = 0LL, (v10 - 153) <= 0x23) && ((1LL << (v10 + 103)) & 0xFC0000001LL) != 0)
  {
    uint64_t v19 = 0LL;
    int v20 = 0LL;
    if (!SEC_ASN1Decode( 0LL,  (uint64_t)&v19,  (uint64_t)kSecAsn1OctetStringTemplate,  *(char **)(a3 + 24),  *(void *)(a3 + 16)))
    {
      int v15 = v20;
      if (v13 == v19)
      {
        __memcpy_chk();
        if (v15) {
          free(v15);
        }
LABEL_31:
        BytePtr = CFDataGetBytePtr(theData);
        CFIndex Length = CFDataGetLength(theData);
        if (CCCryptorCreate(a4 == 0, v11, 1u, BytePtr, Length, iv, &cryptorRef))
        {
          uint64_t v18 = cryptorRef;
        }

        else
        {
          uint64_t result = (uint64_t)PORT_ZAlloc(0x10uLL);
          uint64_t v18 = cryptorRef;
          if (result)
          {
            *(void *)uint64_t result = cryptorRef;
            *(_BYTE *)(result + _Block_object_dispose((const void *)(v1 - 64), 8) = a4;
            *(_DWORD *)(result + 12) = v14;
            return result;
          }
        }

        if (v18) {
          CCCryptorRelease(v18);
        }
        return 0LL;
      }

      if (v20) {
        free(v20);
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t SecCmsCipherContextCrypt( CCCryptorRef *a1, char *dataOut, _DWORD *a3, size_t dataOutAvailable, void *dataIn, size_t dataInLength, int a7)
{
  unsigned int v8 = dataOutAvailable;
  size_t dataOutMoved = 0LL;
  if ((_DWORD)dataInLength)
  {
    uint64_t v12 = CCCryptorUpdate( *a1,  dataIn,  dataInLength,  dataOut,  dataOutAvailable,  &dataOutMoved);
    if (!a7) {
      goto LABEL_7;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
    if (!a7) {
      goto LABEL_7;
    }
  }

  if (!(_DWORD)v12)
  {
    size_t v15 = 0LL;
    uint64_t v12 = CCCryptorFinal(*a1, &dataOut[dataOutMoved], v8 - dataOutMoved, &v15);
    dataOutMoved += v15;
  }

void *PL_NewHashTable(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = defaultHashAllocOps(0LL, 0x38uLL);
  size_t v5 = v4;
  if (v4)
  {
    *(_OWORD *)unsigned int v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    void v4[6] = 0LL;
    *((_OWORD *)v4 + 2) = 0u;
    *((_DWORD *)v4 + 3) = 28;
    uint64_t v6 = defaultHashAllocOps(0LL, 0x80uLL);
    void *v5 = v6;
    if (v6)
    {
      void v6[6] = 0u;
      void v6[7] = 0u;
      void v6[4] = 0u;
      void v6[5] = 0u;
      void v6[2] = 0u;
      void v6[3] = 0u;
      _OWORD *v6 = 0u;
      v6[1] = 0u;
      _OWORD v5[2] = a1;
      v5[3] = a2;
      void v5[4] = PL_CompareValues;
      void v5[5] = &defaultHashAllocOps;
      void v5[6] = 0LL;
    }

    else
    {
      off_18C530D78(0, v5);
      return 0LL;
    }
  }

  return v5;
}

void *DefaultAllocTable(uint64_t a1, size_t a2)
{
  if (a2 <= 1) {
    return malloc(1uLL);
  }
  else {
    return malloc(a2);
  }
}

void DefaultFreeTable(int a1, void *a2)
{
}

void *DefaultAllocEntry()
{
  return malloc(0x20uLL);
}

void DefaultFreeEntry(int a1, void *a2, int a3)
{
  if (a3 == 1) {
    free(a2);
  }
}

uint64_t *PL_HashTableRawLookup(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = (uint64_t *)(*(void *)a1 + 8LL * ((-1640531527 * a2) >> *(_DWORD *)(a1 + 12)));
  uint64_t v4 = *v3;
  if (*v3)
  {
    unsigned int v8 = (uint64_t *)(*(void *)a1 + 8LL * ((-1640531527 * a2) >> *(_DWORD *)(a1 + 12)));
    while (1)
    {
      uint64_t v9 = (uint64_t *)v4;
      if (*(_DWORD *)(v4 + 8) == a2)
      {
      }

      uint64_t v4 = *v9;
      unsigned int v8 = v9;
      if (!*v9) {
        return v9;
      }
    }

    if (v8 != v3)
    {
      uint64_t *v8 = *v9;
      *uint64_t v9 = *v3;
      uint64_t *v3 = (uint64_t)v9;
    }
  }

  return v3;
}

BOOL PL_CompareValues(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t cmsAppendToArray(uint64_t cf, CFMutableArrayRef *a2, uint64_t a3)
{
  if (cf)
  {
    size_t v5 = (const void *)cf;
    if (!*a2) {
      *a2 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    }
    CFTypeID v6 = CFGetTypeID(v5);
    if (v6 == CFArrayGetTypeID())
    {
      v7.CFIndex length = CFArrayGetCount((CFArrayRef)v5);
      v7.location = 0LL;
      CFArrayAppendArray(*a2, (CFArrayRef)v5, v7);
      return 0LL;
    }

    if (v6 == a3)
    {
      CFArrayAppendValue(*a2, v5);
      return 0LL;
    }

    return 4294967246LL;
  }

  return cf;
}

uint64_t cmsRtnToOSStatusDefault(uint64_t a1, unsigned int a2)
{
  uint64_t Error = a1;
  if ((_DWORD)a1 == -1)
  {
    uint64_t Error = PORT_GetError();
    ThreadErrInfo = PR_getThreadErrInfo(1, &v7);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0LL;
    }
    if (!(_DWORD)Error)
    {
LABEL_13:
      if (a2) {
        return a2;
      }
      else {
        return 4294965226LL;
      }
    }
  }

  if ((int)Error > -8106)
  {
    switch((_DWORD)Error)
    {
      case 0xFFFFE057:
        return 4294967168LL;
      case 0xFFFFE05A:
        return 4294899565LL;
      case 0xFFFFE08C:
        return 4294941988LL;
    }

    goto LABEL_13;
  }

  int v5 = Error + 0x2000;
  uint64_t Error = 4294942039LL;
  switch(v5)
  {
    case 0:
      uint64_t Error = 4294967260LL;
      break;
    case 2:
    case 9:
      return Error;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      uint64_t Error = 4294967246LL;
      break;
    case 10:
    case 47:
      uint64_t Error = 4294899608LL;
      break;
    case 11:
    case 30:
      uint64_t Error = 4294899478LL;
      break;
    case 12:
      uint64_t Error = 4294899476LL;
      break;
    case 13:
    case 20:
    case 21:
      uint64_t Error = 4294899453LL;
      break;
    case 19:
      uint64_t Error = 4294967188LL;
      break;
    case 38:
      return 4294899565LL;
    case 39:
      uint64_t Error = 4294965226LL;
      break;
    default:
      goto LABEL_13;
  }

  return Error;
}

uint64_t SecCmsSignerInfoCreateWithSubjKeyID( uint64_t a1, uint64_t a2, const void *a3, const void *a4, unsigned int a5)
{
  return nss_cmssignerinfo_create(a1, 1, 0LL, a2, a3, a4, a5);
}

uint64_t nss_cmssignerinfo_create( uint64_t a1, int a2, const void *a3, uint64_t a4, const void *a5, const void *a6, unsigned int a7)
{
  uint64_t v14 = *(void *)(*(void *)(a1 + 24) + 120LL);
  size_t v15 = (_OWORD *)PORT_ArenaAlloc(v14, 0xD0uLL);
  uint64_t v16 = (uint64_t)v15;
  if (!v15) {
    return v16;
  }
  v15[11] = 0u;
  v15[12] = 0u;
  v15[9] = 0u;
  v15[10] = 0u;
  v15[7] = 0u;
  uint8_t v15[8] = 0u;
  v15[5] = 0u;
  void v15[6] = 0u;
  void v15[3] = 0u;
  v15[4] = 0u;
  v15[1] = 0u;
  void v15[2] = 0u;
  *size_t v15 = 0u;
  *((void *)v15 + 16) = a1;
  if (a2 != 1)
  {
    if (a2) {
      return 0LL;
    }
    if (!a3) {
      return 0LL;
    }
    CFRetain(a3);
    *(void *)(v16 + 136) = a3;
    CertIssuerAndSN = CERT_GetCertIssuerAndSN(v14, (const __CFData *)a3);
    *(void *)(v16 + 24) = CertIssuerAndSN;
    if (!a6 || !CertIssuerAndSN) {
      return 0LL;
    }
    goto LABEL_12;
  }

  *((_DWORD *)v15 + 4) = 1;
  if (!a4) {
    return 0LL;
  }
  uint64_t v18 = (unint64_t *)PORT_ArenaAlloc(v14, 0x10uLL);
  *(void *)(v16 + 24) = v18;
  if (!a5)
  {
    *(void *)(v16 + 176) = 0LL;
    return 0LL;
  }

  CFRetain(a5);
  *(void *)(v16 + 176) = a5;
  if (!a6) {
    return 0LL;
  }
LABEL_12:
  CFRetain(a6);
  *(void *)(v16 + 16_Block_object_dispose((const void *)(v1 - 64), 8) = a6;
  if (*(_DWORD *)(v16 + 16) == 1) {
    unint64_t v19 = 3LL;
  }
  else {
    unint64_t v19 = 1LL;
  }
  SEC_ASN1EncodeInteger(v14, (void *)v16, v19);
  if (SECOID_SetAlgorithmID(v14, (unint64_t *)(v16 + 32), a7, 0LL)
    || SecCmsArrayAdd(*(void *)(*(void *)(a1 + 24) + 120LL), (char **)(a1 + 160), v16))
  {
    return 0LL;
  }

  uint64_t OID = SECOID_FindOID(v16 + 32);
  unsigned int v21 = OID ? *(_DWORD *)(OID + 16) : 0;
  return v16;
}

uint64_t SecCmsSignerInfoCreate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  CFTypeID v6 = *(const void **)(a2 + 16);
  CFRetain(v6);
  int v7 = *(void **)(a2 + 24);
  CFRetain(v7);
  unsigned int v8 = SecKeyCopyAttributes((SecKeyRef)v7);
  uint64_t v9 = v8;
  if (!v8
    || (Value = CFDictionaryGetValue(v8, @"kcls")) == 0LL
    || (v11 = Value, CFTypeID v12 = CFGetTypeID(Value), v12 != CFStringGetTypeID())
    || !CFEqual(v11, @"1"))
  {
    uint64_t v13 = 0LL;
    if (!v6) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  uint64_t v13 = nss_cmssignerinfo_create(a1, 0, v6, 0LL, 0LL, v7, a3);
  if (v6) {
LABEL_8:
  }
    CFRelease(v6);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v13;
}

uint64_t SecCmsSignerInfoGetDigestAlgTag(uint64_t a1)
{
  uint64_t result = SECOID_FindOID(a1 + 32);
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t SecCmsSignerInfoVerifyCertificate(uint64_t a1, const void *a2, SecTrustRef *a3)
{
  *(double *)&uint64_t v28 = NAN;
  CFMutableDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  int v7 = *(uint64_t **)(*(void *)(a1 + 128) + 144LL);
  if (v7)
  {
    uint64_t v8 = *v7;
    if (*v7)
    {
      uint64_t v9 = v7 + 1;
      while (1)
      {
        if ((*(void *)v8 & 0x8000000000000000LL) != 0)
        {
          while (1)
            ;
        }

        int v10 = (const __CFData *)SecCertificateCreateWithBytes(0LL, *(const void **)(v8 + 8), *(void *)v8);
        if (!v10) {
          goto LABEL_15;
        }
        CCAlgorithm v11 = v10;
        int v12 = *(_DWORD *)(a1 + 16);
        if (v12 == 1) {
          break;
        }
        if (!v12)
        {
          if (CERT_CheckIssuerAndSerial( (uint64_t)v10,  (size_t *)(*(void *)(a1 + 24) + 24LL),  (size_t *)(*(void *)(a1 + 24) + 8LL)))
          {
            goto LABEL_13;
          }

double SecCmsSignerInfoGetSigningTime(uint64_t a1, double *a2, double result)
{
  if (a1)
  {
    uint64_t result = *(double *)(a1 + 152);
    if (result == 0.0)
    {
      uint64_t AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0x23u, 1);
      if (AttrByOidTag)
      {
        uint64_t v6 = *(void *)(AttrByOidTag + 16);
        int v7 = *(void **)v6;
        if (*(void *)v6)
        {
          if (v7[1] && *v7 && !*(void *)(v6 + 8) && !SecAsn1DecodeTime((uint64_t)v7, a2))
          {
            uint64_t result = *a2;
            *(double *)(a1 + 152) = *a2;
          }
        }
      }
    }

    else
    {
      *a2 = result;
    }
  }

  return result;
}

const void *SecCmsSignerInfoGetSigningCert_internal(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 136);
  if (!v1)
  {
    uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 128) + 144LL);
    if (v4)
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        uint64_t v6 = v4 + 1;
        do
        {
          if ((*(void *)v5 & 0x8000000000000000LL) != 0)
          {
            while (1)
              ;
          }

          int v7 = (const __CFData *)SecCertificateCreateWithBytes(0LL, *(const void **)(v5 + 8), *(void *)v5);
          if (v7)
          {
            uint64_t v1 = v7;
            int v8 = *(_DWORD *)(a1 + 16);
            if (v8 == 1)
            {
              CFDataRef SubjectKeyID = SecCertificateGetSubjectKeyID(v7);
              int v10 = *(size_t **)(a1 + 24);
              size_t v11 = *v10;
              if (v11 == CFDataGetLength(SubjectKeyID))
              {
                int v12 = (const void *)v10[1];
                BytePtr = CFDataGetBytePtr(SubjectKeyID);
                if (!memcmp(v12, BytePtr, *v10)) {
                  goto LABEL_21;
                }
              }
            }

            else if (!v8 {
                   && CERT_CheckIssuerAndSerial( (uint64_t)v7,  (size_t *)(*(void *)(a1 + 24) + 24LL),  (size_t *)(*(void *)(a1 + 24) + 8LL)))
            }
            {
              goto LABEL_21;
            }

            if (*(void *)(a1 + 136)) {
              return v1;
            }
            CFRelease(v1);
          }

          uint64_t v14 = *v6++;
          uint64_t v5 = v14;
        }

        while (v14);
        if (*(void *)(a1 + 136)) {
          return 0LL;
        }
      }
    }

    int v15 = *(_DWORD *)(a1 + 16);
    if (!v15)
    {
      uint64_t v1 = CERT_FindByIssuerAndSN(*(const void **)(*(void *)(a1 + 128) + 176LL), @"cert", *(void *)(a1 + 24));
      *(void *)(a1 + 136) = v1;
      if (v1) {
        return v1;
      }
      int v15 = *(_DWORD *)(a1 + 16);
    }

    if (v15 != 1)
    {
      return 0LL;
    }

    else
    {
      uint64_t v1 = CERT_FindBySubjectKeyID( *(const void **)(*(void *)(a1 + 128) + 176LL),  @"cert",  *(CFIndex **)(a1 + 24));
LABEL_21:
      *(void *)(a1 + 136) = v1;
    }
  }

  return v1;
}

uint64_t SecCmsSignerInfoGetVerificationStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

uint64_t SecCmsSignerInfoGetDigestAlg(uint64_t a1)
{
  return SECOID_FindOID(a1 + 32);
}

uint64_t SecCmsSignerInfoGetCertList(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t SecCmsSignerInfoGetAppleCodesigningHashAgility(uint64_t a1, CFDataRef *a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    *a2 = 0LL;
    CFDataRef v5 = *(CFDataRef *)(a1 + 184);
    if (v5)
    {
LABEL_4:
      uint64_t result = 0LL;
      *a2 = v5;
      return result;
    }

    uint64_t result = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD6u, 1);
    if (result)
    {
      uint64_t v6 = *(void *)(result + 16);
      int v7 = *(CFIndex **)v6;
      if (*(void *)v6 && (v8 = (const UInt8 *)v7[1]) != 0LL && (CFIndex v9 = *v7) != 0 && !*(void *)(v6 + 8))
      {
        if ((v9 & 0x8000000000000000LL) == 0)
        {
          CFDataRef v5 = CFDataCreate(0LL, v8, v9);
          *(void *)(a1 + 184) = v5;
          if (v5) {
            goto LABEL_4;
          }
        }

        return 4294967188LL;
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t SecCmsSignerInfoGetAppleCodesigningHashAgilityV2(uint64_t a1, __CFDictionary **a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    *a2 = 0LL;
    CFDataRef v5 = *(__CFDictionary **)(a1 + 192);
    if (v5)
    {
      uint64_t result = 0LL;
      *a2 = v5;
      return result;
    }

    uint64_t result = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD7u, 1);
    if (result)
    {
      uint64_t v6 = result;
      int v7 = *(uint64_t **)(result + 16);
      if (v7)
      {
        if (*v7)
        {
          uint64_t v8 = 0LL;
          while (v7[++v8])
            ;
          CFIndex v10 = v8;
        }

        else
        {
          CFIndex v10 = 0LL;
        }

        CFMutableDataRef Mutable = CFDictionaryCreateMutable(0LL, v10, MEMORY[0x189605240], MEMORY[0x189605250]);
        uint64_t v12 = *v7;
        if (*v7)
        {
          uint64_t v13 = v7 + 1;
          do
          {
            *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v28 = v14;
            __int128 v29 = v14;
            int v15 = PORT_NewArena(1024);
            if (v15)
            {
              uint64_t v16 = v15;
              if (!SEC_ASN1Decode( (uint64_t)v15,  (uint64_t)&v28,  (uint64_t)&CMSAppleAgileHashTemplate,  *(char **)(v12 + 8),  *(void *)v12)
                && (v29 & 0x8000000000000000LL) == 0)
              {
                uint64_t OID = SECOID_FindOID((uint64_t)&v28);
                if (OID) {
                  uint64_t v18 = *(unsigned int *)(OID + 16);
                }
                else {
                  uint64_t v18 = 0LL;
                }
                uint64_t valuePtr = v18;
                CFNumberRef v19 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
                CFDataRef v20 = CFDataCreate(0LL, *((const UInt8 **)&v29 + 1), v29);
                CFDictionaryAddValue(Mutable, v19, v20);
                if (v20) {
                  CFRelease(v20);
                }
                if (v19) {
                  CFRelease(v19);
                }
              }

              PORT_FreeArena(v16, 0);
            }

            uint64_t v21 = *v13++;
            uint64_t v12 = v21;
          }

          while (v21);
        }

        CFIndex Count = CFDictionaryGetCount(Mutable);
        uint64_t v23 = *(uint64_t **)(v6 + 16);
        if (v23)
        {
          uint64_t v24 = *v23;
          if (*v23)
          {
            uint64_t v24 = 0LL;
            unint64_t v25 = v23 + 1;
            while (v25[v24++])
              ;
            uint64_t v24 = v24;
          }
        }

        else
        {
          uint64_t v24 = 0LL;
        }

        if (Count == v24)
        {
          *(void *)(a1 + 192) = Mutable;
          if (!Mutable) {
            return 4294967188LL;
          }
          uint64_t result = 0LL;
          *a2 = Mutable;
          return result;
        }

        if (Mutable) {
          CFRelease(Mutable);
        }
      }

      return 4294941021LL;
    }
  }

  return result;
}

double SecCmsSignerInfoGetAppleExpirationTime(uint64_t a1, double *a2, double result)
{
  if (a1 && a2)
  {
    uint64_t result = *(double *)(a1 + 200);
    if (result == 0.0)
    {
      uint64_t AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD8u, 1);
      if (AttrByOidTag)
      {
        uint64_t v6 = *(void *)(AttrByOidTag + 16);
        int v7 = *(void **)v6;
        if (*(void *)v6)
        {
          if (v7[1] && *v7 && !*(void *)(v6 + 8) && !SecAsn1DecodeTime((uint64_t)v7, a2))
          {
            uint64_t result = *a2;
            *(double *)(a1 + 200) = *a2;
          }
        }
      }
    }

    else
    {
      *a2 = result;
    }
  }

  return result;
}

const void *SecCmsSignerInfoGetSignerCommonName(uint64_t a1)
{
  SigningCert_internal = SecCmsSignerInfoGetSigningCert_internal(a1);
  uint64_t v2 = SecCertificateCopyCommonNames((uint64_t)SigningCert_internal);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  CFIndex Count = CFArrayGetCount(v2);
  ValueAtIndex = CFArrayGetValueAtIndex(v3, Count - 1);
  uint64_t v6 = ValueAtIndex;
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  CFRelease(v3);
  return v6;
}

const void *SecCmsSignerInfoGetSignerEmailAddress(uint64_t a1)
{
  SigningCert_internal = SecCmsSignerInfoGetSigningCert_internal(a1);
  uint64_t v2 = SecCertificateCopyRFC822Names((uint64_t)SigningCert_internal);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  if (CFArrayGetCount(v2) < 1)
  {
    CFDataRef v5 = 0LL;
  }

  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0LL);
    CFDataRef v5 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
  }

  CFRelease(v3);
  return v5;
}

uint64_t SecCmsSignerInfoAddSigningTime(uint64_t a1, CFAbsoluteTime a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  memset(v6, 170, sizeof(v6));
  uint64_t v5 = SecCmsAttributeCreate(v3, 0x23u, v7, 1);
  if (!v5) {
    return 4294941020LL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v5);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsSignerInfoAddSMIMECaps(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  uint64_t v3 = SECITEM_AllocItem(v2, 0LL, 0LL);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = v3;
  uint64_t v5 = PORT_ZAlloc(0x50uLL);
  unint64_t v25 = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v5;
  uint64_t v23 = v2;
  uint64_t v24 = a1;
  int v7 = 0;
  uint64_t v8 = &qword_18966A878;
  for (uint64_t i = 8LL; i != -1; --i)
  {
    if (((0xDuLL >> i) & 1) == 0)
    {
      uint64_t v10 = *(v8 - 2);
      if (v10 != 65561)
      {
        size_t v11 = PORT_ZAlloc(0x28uLL);
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        v6[v7] = v11;
        int v13 = *((_DWORD *)v8 - 2);
        pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
        uint64_t v14 = *(void *)&oids[40 * v13 + 8];
        *uint64_t v12 = *(void *)&oids[40 * v13];
        v12[1] = v14;
        if (((0x1F2uLL >> i) & 1) != 0)
        {
          uint64_t v15 = 0LL;
          uint64_t v16 = 0LL;
        }

        else
        {
          uint64_t v16 = *(void *)*v8;
          uint64_t v15 = *(void *)(*v8 + 8);
        }

        ++v7;
        void v12[2] = v16;
        v12[3] = v15;
        _OWORD v12[4] = v10;
      }
    }

    v8 -= 4;
  }

  v6[v7] = 0LL;
  CMSEncoderRef v17 = SEC_ASN1EncodeItem(v23, v4, (uint64_t)&v25, (uint64_t)&NSSSMIMECapabilitiesTemplate);
  uint64_t v18 = v25;
  CFNumberRef v19 = *(void **)v25;
  if (*(void *)v25)
  {
    uint64_t v20 = 8LL;
    do
    {
      free(v19);
      uint64_t v18 = v25;
      CFNumberRef v19 = *(void **)((char *)v25 + v20);
      v20 += 8LL;
    }

    while (v19);
  }

  free(v18);
  if (!v17) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v21 = SecCmsAttributeCreate(v23, 0x28u, v4, 1);
  if (!v21) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(v24 + 128) + 24LL) + 120LL),  (uint64_t **)(v24 + 64),  v21);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsSignerInfoAddSMIMEEncKeyPrefs_internal(uint64_t a1, const __CFData *a2)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  uint64_t v5 = SECITEM_AllocItem(v4, 0LL, 0LL);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v12 = 0xAAAAAAAA00000000LL;
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v5;
  int v7 = PORT_NewArena(1024);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  if (!CERT_GetCertIssuerAndSN((uint64_t)v7, a2))
  {
    PORT_FreeArena(v8, 0);
    return 0xFFFFFFFFLL;
  }

  CFIndex v9 = SEC_ASN1EncodeItem(v4, v6, (uint64_t)&v12, (uint64_t)&smime_encryptionkeypref_template);
  PORT_FreeArena(v8, 0);
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = SecCmsAttributeCreate(v4, 0xB6u, v6, 1);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v10);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsSignerInfoAddMSSMIMEEncKeyPrefs_internal(uint64_t a1, const __CFData *a2)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  uint64_t v5 = SECITEM_AllocItem(v4, 0LL, 0LL);
  if (v5) {
    BOOL v6 = a2 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v5;
  uint64_t v8 = PORT_NewArena(1024);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  CFIndex v9 = v8;
  CertIssuerAndSN = CERT_GetCertIssuerAndSN((uint64_t)v8, a2);
  if (!CertIssuerAndSN)
  {
    PORT_FreeArena(v9, 0);
    return 0xFFFFFFFFLL;
  }

  size_t v11 = SEC_ASN1EncodeItem(v4, v7, (uint64_t)CertIssuerAndSN, (uint64_t)&SecCmsIssuerAndSNTemplate);
  PORT_FreeArena(v9, 0);
  if (!v11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = SecCmsAttributeCreate(v4, 0xBEu, v7, 1);
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v12);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsSignerInfoAddCounterSignature()
{
  return 0xFFFFFFFFLL;
}

uint64_t SecCmsSignerInfoAddAppleCodesigningHashAgility(uint64_t a1, CFDataRef theData)
{
  if (!theData) {
    return 4294967246LL;
  }
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  if (CFDataGetLength(theData) < 0) {
    return 4294967246LL;
  }
  v7[0] = CFDataGetLength(theData);
  v7[1] = (unint64_t)CFDataGetBytePtr(theData);
  uint64_t v5 = SecCmsAttributeCreate(v4, 0xD6u, v7, 0);
  if (!v5) {
    return 4294967188LL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v5);
  if ((_DWORD)result) {
    return 4294941020LL;
  }
  return result;
}

uint64_t SecCmsSignerInfoAddAppleCodesigningHashAgilityV2(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  unint64_t v10 = v3;
  if (a2)
  {
    uint64_t v5 = SecCmsAttributeCreate(v3, 0xD7u, 0LL, 1);
    v12[3] = v5;
    if (v5)
    {
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 0x40000000LL;
      v8[2] = __SecCmsSignerInfoAddAppleCodesigningHashAgilityV2_block_invoke;
      unint64_t v8[3] = &unk_18966B4A8;
      void v8[4] = v9;
      v8[5] = &v11;
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2, v8);
      if (SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v12[3])) {
        uint64_t v6 = 4294941020LL;
      }
      else {
        uint64_t v6 = 0LL;
      }
    }

    else
    {
      uint64_t v6 = 4294967188LL;
    }
  }

  else
  {
    uint64_t v6 = 4294967246LL;
  }

  _Block_object_dispose(v9, 8);
  _Block_object_dispose(&v11, 8);
  return v6;
}

void __SecCmsSignerInfoAddAppleCodesigningHashAgilityV2_block_invoke( uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFNumberGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFDataGetTypeID())
        {
          uint64_t v9 = *(void *)(a1 + 40);
          uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          uint64_t v11 = *(void *)(*(void *)(v9 + 8) + 24LL);
          unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
          v22[0] = 0LL;
          v22[1] = 0LL;
          if (CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr))
          {
            if ((CFDataGetLength((CFDataRef)a3) & 0x8000000000000000LL) == 0)
            {
              unsigned int v12 = valuePtr;
              int v13 = valuePtr;
              pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
              unint64_t v14 = v12 <= 0xD8 ? &oids[40 * v13] : 0LL;
              _OWORD v23[3] = CFDataGetBytePtr((CFDataRef)a3);
              CFIndex Length = CFDataGetLength((CFDataRef)a3);
              uint64_t v16 = *(void *)v14;
              v23[1] = *((void *)v14 + 1);
              v23[2] = Length;
              v23[0] = v16;
              CMSEncoderRef v17 = PORT_NewArena(1024);
              if (v17)
              {
                uint64_t v18 = v17;
                if (SEC_ASN1EncodeItem((uint64_t)v17, v22, (uint64_t)v23, (uint64_t)&CMSAppleAgileHashTemplate))
                {
                  CFNumberRef v19 = SECITEM_AllocItem(v10, 0LL, v22[0]);
                  if (v19)
                  {
                    uint64_t v20 = (uint64_t)v19;
                    if (!SECITEM_CopyItem(v10, v19, (uint64_t)v22))
                    {
                      uint64_t v21 = (char **)(v11 + 16);
                    }
                  }
                }

                PORT_FreeArena(v18, 0);
              }
            }
          }
        }
      }
    }
  }

uint64_t apply_block_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t SecCmsSignerInfoAddAppleExpirationTime(uint64_t a1, CFAbsoluteTime a2)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL);
  v7[0] = 0LL;
  v7[1] = 0LL;
  memset(v6, 170, sizeof(v6));
  uint64_t v5 = SecCmsAttributeCreate(v3, 0xD8u, v7, 1);
  if (!v5) {
    return 4294941020LL;
  }
  uint64_t result = SecCmsAttributeArrayAddAttr( *(void *)(*(void *)(*(void *)(a1 + 128) + 24LL) + 120LL),  (uint64_t **)(a1 + 64),  v5);
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t *SecCmsSignerInfoCopyCertFromEncryptionKeyPreference(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 160) != 1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    uint64_t v3 = *(int64_t ***)(v2 + 144);
  }
  else {
    uint64_t v3 = 0LL;
  }
  uint64_t result = *(uint64_t **)(a1 + 64);
  if (result)
  {
    if (*result)
    {
      uint64_t AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(result, 0xB6u, 1);
      if (!AttrByOidTag) {
        goto LABEL_13;
      }
      uint64_t v6 = *(void *)(AttrByOidTag + 16);
      int v7 = *(void **)v6;
      if (*(void *)v6 && v7[1] && *v7 && !*(void *)(v6 + 8))
      {
        uint64_t result = (uint64_t *)SecSMIMEGetCertFromEncryptionKeyPreference(v3, (uint64_t)v7);
        if (result) {
          return result;
        }
LABEL_13:
        uint64_t result = *(uint64_t **)(a1 + 64);
        if (!result) {
          return result;
        }
        if (*result)
        {
          uint64_t result = (uint64_t *)SecCmsAttributeArrayFindAttrByOidTag(result, 0xBEu, 1);
          if (!result) {
            return result;
          }
          uint64_t v8 = result[2];
          uint64_t v9 = *(void **)v8;
          if (*(void *)v8 && v9[1] && *v9 && !*(void *)(v8 + 8)) {
            return (uint64_t *)SecSMIMEGetCertFromEncryptionKeyPreference(v3, (uint64_t)v9);
          }
        }
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t SecCmsSignerInfoSaveSMIMEProfile()
{
  return 4294967292LL;
}

uint64_t SecCmsSignerInfoIncludeCerts(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 136)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(const void **)(a1 + 144);
  if (v4)
  {
    *(void *)(a1 + 144) = 0LL;
    CFRelease(v4);
  }

  switch(a2)
  {
    case 0:
      *(void *)(a1 + 144) = 0LL;
      return 0LL;
    case 1:
      values = *(void **)(a1 + 136);
      if (values) {
        CFArrayRef v5 = CFArrayCreate(0LL, (const void **)&values, 1LL, MEMORY[0x189605228]);
      }
      else {
        CFArrayRef v5 = 0LL;
      }
      goto LABEL_14;
    case 2:
      uint64_t v6 = *(void **)(a1 + 136);
      int v7 = 0;
      goto LABEL_11;
    case 3:
      uint64_t v6 = *(void **)(a1 + 136);
      int v7 = 1;
LABEL_11:
      int v8 = 0;
      goto LABEL_13;
    case 4:
      uint64_t v6 = *(void **)(a1 + 136);
      int v7 = 1;
      int v8 = 1;
LABEL_13:
      CFArrayRef v5 = CERT_CertChainFromCert(v6, v7, v8);
LABEL_14:
      *(void *)(a1 + 144) = v5;
      break;
    default:
      CFArrayRef v5 = *(CFArrayRef *)(a1 + 144);
      break;
  }

  if (v5) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SOSRKNullKey()
{
  if (SOSRKNullKey_onceToken != -1) {
    dispatch_once(&SOSRKNullKey_onceToken, &__block_literal_global_5675);
  }
  return SOSRKNullKey_localNullKey;
}

CFDataRef __SOSRKNullKey_block_invoke()
{
  CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)"nullkey", 8LL);
  SOSRKNullKey_localNullKey = (uint64_t)result;
  return result;
}

uint64_t SOSBackupSliceKeyBagGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSBackupSliceKeyBagGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDSingleton;
  if (SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDOnce != -1) {
    dispatch_once(&SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDOnce, block);
  }
  return SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDSingleton;
}

uint64_t __SOSBackupSliceKeyBagGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SOSBackupSliceKeyBagDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0LL;
    CFRelease(v4);
  }

__CFString *SOSBackupSliceKeyBagCopyFormatDescription(uint64_t a1)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  uint64_t v4 = CFSetCreateMutable(v2, 0LL, MEMORY[0x189605258]);
  uint64_t v5 = MEMORY[0x1895F87A8];
  if (v4)
  {
    uint64_t v6 = *(const __CFSet **)(a1 + 24);
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SOSBackupSliceKeyBagCopyPeerNames_block_invoke;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    void context[4] = v4;
    CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5678, context);
  }

  v8[0] = v5;
  v8[1] = 3221225472LL;
  v8[2] = __SOSBackupSliceKeyBagCopyFormatDescription_block_invoke;
  unint64_t v8[3] = &__block_descriptor_48_e21_v16__0____CFString__8l;
  void v8[4] = Mutable;
  v8[5] = a1;
  CFStringSetPerformWithDescription(v4, (uint64_t)v8);
  if (v4) {
    CFRelease(v4);
  }
  CFStringAppend(Mutable, @">");
  return Mutable;
}

__CFString *SOSBackupSliceKeyBagCopyDescription(uint64_t a1)
{
  return SOSBackupSliceKeyBagCopyFormatDescription(a1);
}

void __SOSBackupSliceKeyBagCopyPeerNames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(__CFSet **)(a1 + 32);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 32), @"ComputerName");
  CFSetAddValue(v2, Value);
}

uint64_t apply_block_1_5678(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __SOSBackupSliceKeyBagCopyFormatDescription_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(__CFString **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  CFIndex Count = *(const __CFSet **)(v4 + 24);
  if (Count) {
    CFIndex Count = (const __CFSet *)CFSetGetCount(Count);
  }
  CFStringAppendFormat(v3, 0LL, @"<SOSBackupSliceKeyBag@%p %ld %@", v4, Count, a2);
}

uint64_t der_decode_BackupSliceKeyBag(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3, const UInt8 *a4, uint64_t a5)
{
  CFNumberRef v19 = a4;
  if (!a4) {
    return 0LL;
  }
  SOSBackupSliceKeyBagGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!SecAllocationError(Instance, a3, @"View bag allocation failed")
    || (uint64_t v9 = (const UInt8 *)ccder_decode_sequence_tl(), v19 = v9, a5))
  {
    if (!Instance) {
      return 0LL;
    }
LABEL_11:
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  int v13 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFNumberRef v19 = der_decode_data( (const __CFAllocator *)*MEMORY[0x189604DB0],  (CFDataRef *)(Instance + 16),  a3,  (uint64_t)v9,  0LL,  v10,  v11,  v12);
  *(void *)(Instance + 24) = SOSPeerInfoSetCreateFromArrayDER(v13, &kSOSPeerSetCallbacks, a3, (uint64_t *)&v19);
  CMSEncoderRef v17 = (const UInt8 *)der_decode_dictionary( v13,  (CFMutableDictionaryRef *)(Instance + 32),  a3,  (uint64_t)v19,  0LL,  v14,  v15,  v16);
  CFNumberRef v19 = v17;
  SecRequirementError(v17 == 0LL, a3, @"Extra space in sequence");
  if (v17 || !a2) {
    goto LABEL_11;
  }
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = (CFTypeRef)Instance;
  return 0LL;
}

uint64_t der_sizeof_BackupSliceKeyBag(const __CFData **a1, CFTypeRef *a2)
{
  SecRequirementError(a1 != 0LL, a2, @"Null BackupSliceKeyBag");
  if (a1
    && (uint64_t v4 = a1[2], SecRequirementError(v4 != 0LL, a2, @"null aks_bag in BackupSliceKeyBag"), v4)
    && (uint64_t v5 = a1[2]) != 0LL
    && (CFDataGetLength(v5), ccder_sizeof_raw_octet_string())
    && SOSPeerInfoSetGetDEREncodedArraySize(a1[3], (uint64_t)a2)
    && der_sizeof_dictionary(a1[4], (uint64_t)a2))
  {
    return ccder_sizeof();
  }

  else
  {
    return 0LL;
  }

uint64_t der_encode_BackupSliceKeyBag(const __CFData **a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0LL;
  }
  SecRequirementError(a1 != 0LL, a2, @"Null set passed to encode");
  if (!a1) {
    return 0LL;
  }
  int v7 = a1[2];
  SecRequirementError(v7 != 0LL, a2, @"Null set passed to encode");
  if (!v7) {
    return 0LL;
  }
  int v8 = a1[2];
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = a1[3];
  uint64_t v10 = der_encode_dictionary_repair(a1[4], a2, 0);
  SOSPeerInfoSetEncodeToArrayDER(v9, (uint64_t)a2, a3, v10);
  der_encode_data(v8, a2);
  uint64_t result = ccder_encode_constructed_tl();
  if (result != a3) {
    return 0LL;
  }
  return result;
}

CFTypeRef SOSBackupSliceKeyBagCreateFromData(uint64_t a1, CFDataRef theData, CFTypeRef *a3)
{
  CFTypeRef cf = 0LL;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  int v8 = &BytePtr[Length];
  uint64_t v9 = der_decode_BackupSliceKeyBag(a1, &cf, a3, BytePtr, (uint64_t)&BytePtr[Length]);
  SecRequirementError(v9 == (void)v8, a3, @"Didn't consume all data supplied");
  CFTypeRef result = cf;
  if ((const UInt8 *)v9 != v8)
  {
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(result);
      return 0LL;
    }
  }

  return result;
}

BOOL SOSBSKBIsGoodBackupPublic(const __CFData *a1, CFTypeRef *a2)
{
  v10[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1895F8858](v4);
  if (v6 >= 0x10)
  {
    int v7 = (void *)((char *)v10 - v5);
    do
    {
      *int v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16LL;
    }

    while (v5);
  }

  SOSGetBackupKeyCurveParameters();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  int v8 = ccec_compact_import_pub();
  if (v8) {
    SOSErrorCreate(1029LL, a2, 0LL, @"Unable to decode public key: %@", a1);
  }
  return v8 == 0;
}

__CFData *SOSBSKBCopyEncoded(const __CFData **a1, CFTypeRef *a2)
{
  uint64_t v4 = der_sizeof_BackupSliceKeyBag(a1, a2);
  if (!v4) {
    return 0LL;
  }
  CFIndex v5 = v4;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataSetLength(Mutable, v5);
  if (!SecAllocationError((uint64_t)Mutable, a2, @"Faild to create scratch")
    || (MutableBytePtr = CFDataGetMutableBytePtr(Mutable),
        CFIndex Length = CFDataGetLength(Mutable),
        MutableBytePtr != (UInt8 *)der_encode_BackupSliceKeyBag( a1,  a2,  (uint64_t)MutableBytePtr,  (uint64_t)&MutableBytePtr[Length])))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

void *SOSBackupSliceKeyBagCreate(const __CFAllocator *a1, const __CFSet *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFIndex v5 = SOSBackupSliceKeyBagCreateWithAdditionalKeys(a1, a2, (uint64_t)Mutable, 0LL);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v5;
}

void *SOSBackupSliceKeyBagCreateWithAdditionalKeys( const __CFAllocator *a1, const __CFSet *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  SOSBackupSliceKeyBagGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (!SecAllocationError((uint64_t)Instance, a4, @"View bag allocation failed")
    || (CFIndex Count = CFSetGetCount(a2), SecRequirementError(Count > 0, a4, @"Need peers"), Count < 1))
  {
    if (!Instance) {
      return Instance;
    }
LABEL_8:
    CFRelease(Instance);
    return 0LL;
  }

  CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  uint64_t v11 = MEMORY[0x1895F87A8];
  uint64_t v15 = MEMORY[0x1895F87A8];
  uint64_t v16 = 3221225472LL;
  CMSEncoderRef v17 = __SOSBackupSliceKeyBagCreatePeerSet_block_invoke;
  uint64_t v18 = &__block_descriptor_40_e10_v16__0r_v8l;
  CFNumberRef v19 = Mutable;
  CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_5678, &v15);
  Instance[3] = Mutable;
  Instance[4] = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v12 = (const void *)Instance[2];
  if (v12)
  {
    Instance[2] = 0LL;
    CFRelease(v12);
  }

  CMSEncoderRef v17 = __SOSBackupSliceKeyBagCreateBackupBag_block_invoke;
  uint64_t v18 = &__block_descriptor_56_e11_v24__0Q8_16l;
  uint64_t v15 = v11;
  uint64_t v16 = 3221225472LL;
  CFNumberRef v19 = a4;
  uint64_t v20 = Instance;
  uint64_t v21 = a3;
  v22[0] = v11;
  v22[1] = 0x40000000LL;
  unint64_t v22[2] = __PerformWithBufferAndClear_block_invoke;
  _BYTE v22[3] = &unk_189676A80;
  v22[4] = &v15;
  *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[0] = v13;
  v23[1] = v13;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v22, 0x20uLL, v23);
  if (!Instance[2]) {
    goto LABEL_8;
  }
  return Instance;
}

void __SOSBackupSliceKeyBagCreatePeerSet_block_invoke(uint64_t a1, const void *a2)
{
}

void __SOSBackupSliceKeyBagCreateBackupBag_block_invoke(uint64_t a1, unint64_t a2, const UInt8 *a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  int v6 = CCRandomCopyBytes();
  if (SecError(v6, *(__CFString ***)(a1 + 32), @"SecRandom falied!"))
  {
    int v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFDataRef v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a3, a2, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v9 = *(const __CFDictionary **)(a1 + 48);
    uint64_t v11 = *(void **)(a1 + 32);
    __int128 v29 = v7;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    CFIndex length = 0LL;
    p_CFIndex length = &length;
    uint64_t v33 = 0x2020000000LL;
    char v34 = 1;
    __int128 v13 = *(const __CFSet **)(v10 + 24);
    uint64_t v14 = MEMORY[0x1895F87A8];
    context[0] = (void *)MEMORY[0x1895F87A8];
    context[1] = (void *)3221225472LL;
    context[2] = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke;
    context[3] = &unk_18966B630;
    context[6] = Mutable;
    context[7] = v11;
    void context[4] = &length;
    void context[5] = v8;
    CFSetApplyFunction(v13, (CFSetApplierFunction)apply_block_1_5678, context);
    *(void *)__int128 buf = v14;
    uint64_t v37 = 3221225472LL;
    int v38 = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_54;
    uint64_t v39 = &unk_18966B658;
    CFMutableDictionaryRef v42 = Mutable;
    uint64_t v43 = v11;
    uint64_t v40 = &length;
    CFDataRef v41 = v8;
    CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_5704, buf);
    CFDataRef v15 = v8;
    int v16 = *((unsigned __int8 *)p_length + 24);
    if (!*((_BYTE *)p_length + 24) && Mutable) {
      CFRelease(Mutable);
    }
    if (v16) {
      CFMutableDictionaryRef v17 = Mutable;
    }
    else {
      CFMutableDictionaryRef v17 = 0LL;
    }
    _Block_object_dispose(&length, 8);
    uint64_t v18 = *(const void **)(v10 + 32);
    if (v18) {
      CFRelease(v18);
    }
    *(void *)(v10 + 32) = v17;
    uint64_t v21 = a1 + 32;
    CFNumberRef v19 = *(CFTypeRef **)(a1 + 32);
    uint64_t v20 = *(void *)(v21 + 8);
    context[0] = 0LL;
    LODWORD(length) = 0;
    unsigned int v35 = -1;
    SecRequirementError(a2 >> 31 == 0, v19, @"Invalid size: %zu", a2);
    if (!(a2 >> 31)
      && (uint64_t v22 = aks_create_bag((uint64_t)a3, a2, 4u, &v35),
          SecKernError(v22, v19, @"bag allocation failed: %d", v22))
      && (uint64_t v23 = aks_save_bag(v35), SecKernError(v23, v19, @"save bag failed: %d", v23)))
    {
      int v24 = aks_unload_bag(v35);
      if (v24)
      {
        int v25 = v24;
        uint64_t v26 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v25;
          _os_log_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEFAULT, "unload bag failed: %d", buf, 8u);
        }
      }

      CFDataRef v27 = CFDataCreate(v29, (const UInt8 *)context[0], (int)length);
      SecAllocationError((uint64_t)v27, v19, @"Bag CFData Allocation Failed");
    }

    else
    {
      CFDataRef v27 = 0LL;
    }

    if (context[0]) {
      free(context[0]);
    }
    __int128 v28 = *(const void **)(v20 + 16);
    if (v28) {
      CFRelease(v28);
    }
    *(void *)(v20 + 16) = v27;
    if (v15) {
      CFRelease(v15);
    }
  }

void sub_18057B13C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == SOSPeerInfoGetTypeID())
    {
      CFIndex v5 = (const void *)*((void *)cf + 5);
      int v6 = SOSPeerInfoV2DictionaryCopyData((uint64_t)cf, (const void *)sBackupKeyKey);
      if (v6)
      {
        int v7 = v6;
        *(void *)__int128 buf = 0LL;
        CFDataRef v8 = SOSCopyECWrapped(v6, *(const __CFData **)(a1 + 40), (CFTypeRef *)buf);
        if (v8)
        {
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), v5, v8);
          v32[0] = MEMORY[0x1895F87A8];
          v32[1] = 3221225472LL;
          uint64_t v33 = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_2;
          char v34 = &__block_descriptor_48_e21_v16__0____CFString__8l;
          unsigned int v35 = v8;
          uint64_t v36 = v5;
          uint64_t v9 = v32;
          uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          CFIndex Length = CFDataGetLength(v7);
          CFMutableDictionaryRef Mutable = CFStringCreateMutable(v10, 2 * Length);
          BytePtr = CFDataGetBytePtr(v7);
          CFIndex v14 = CFDataGetLength(v7);
          if (v14 >= 1)
          {
            CFIndex v15 = v14;
            do
            {
              unsigned int v16 = *BytePtr++;
              CFStringAppendFormat(Mutable, 0LL, @"%02X", v16);
              --v15;
            }

            while (v15);
          }

          v33((uint64_t)v9, (uint64_t)Mutable);
          CFRelease(Mutable);

          CFRelease(v8);
        }

        else
        {
          v27[0] = MEMORY[0x1895F87A8];
          v27[1] = 3221225472LL;
          __int128 v28 = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_53;
          __int128 v29 = &__block_descriptor_48_e21_v16__0____CFString__8l;
          int v30 = v5;
          uint64_t v31 = *(void *)buf;
          uint64_t v18 = v27;
          CFNumberRef v19 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          CFIndex v20 = CFDataGetLength(v7);
          uint64_t v21 = CFStringCreateMutable(v19, 2 * v20);
          uint64_t v22 = CFDataGetBytePtr(v7);
          CFIndex v23 = CFDataGetLength(v7);
          if (v23 >= 1)
          {
            CFIndex v24 = v23;
            do
            {
              unsigned int v25 = *v22++;
              CFStringAppendFormat(v21, 0LL, @"%02X", v25);
              --v24;
            }

            while (v24);
          }

          v28((uint64_t)v18, (uint64_t)v21);
          CFRelease(v21);

          if (*(void *)buf)
          {
            uint64_t v26 = *(void **)(a1 + 56);
            if (v26 && !*v26) {
              void *v26 = *(void *)buf;
            }
            else {
              CFRelease(*(CFTypeRef *)buf);
            }
          }

          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
        }

        CFRelease(v7);
      }

      else
      {
        secLogObjForScope("bskb");
        CFMutableDictionaryRef v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v5;
          _os_log_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEFAULT, "Skipping id %@, no backup key.", buf, 0xCu);
        }
      }
    }
  }

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_54(uint64_t a1, const __CFString *cf, const void *a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (!cf || (CFIndex v5 = cf, v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())) {
    CFIndex v5 = 0LL;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    if (v7 == CFDataGetTypeID())
    {
      *(void *)cfa = 0LL;
      CFDataRef v8 = SOSKeyedPubKeyIdentifierCreateWithData(v5, (const __CFData *)a3);
      if (v8)
      {
        uint64_t v9 = SOSCopyECWrapped((const __CFData *)a3, *(const __CFData **)(a1 + 40), (CFTypeRef *)cfa);
        if (v9) {
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), v8, v9);
        }
        if (*(void *)cfa)
        {
          v28[0] = MEMORY[0x1895F87A8];
          v28[1] = 3221225472LL;
          __int128 v29 = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_58;
          int v30 = &__block_descriptor_40_e21_v16__0____CFString__8l;
          uint64_t v31 = *(void *)cfa;
          uint64_t v10 = v28;
          uint64_t v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          CFIndex Length = CFDataGetLength((CFDataRef)a3);
          CFMutableDictionaryRef Mutable = CFStringCreateMutable(v11, 2 * Length);
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          CFIndex v15 = CFDataGetLength((CFDataRef)a3);
          if (v15 >= 1)
          {
            CFIndex v16 = v15;
            do
            {
              unsigned int v17 = *BytePtr++;
              CFStringAppendFormat(Mutable, 0LL, @"%02X", v17);
              --v16;
            }

            while (v16);
          }

          v29((uint64_t)v10, (uint64_t)Mutable);
          CFRelease(Mutable);

          if (*(void *)cfa)
          {
            uint64_t v18 = *(void **)(a1 + 56);
            if (v18 && !*v18) {
              *uint64_t v18 = *(void *)cfa;
            }
            else {
              CFRelease(*(CFTypeRef *)cfa);
            }
          }

          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
          if (!v9) {
            goto LABEL_23;
          }
          goto LABEL_22;
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      v32[0] = MEMORY[0x1895F87A8];
      v32[1] = 3221225472LL;
      uint64_t v33 = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_2_55;
      char v34 = &__block_descriptor_40_e21_v16__0____CFString__8l;
      unsigned int v35 = v9;
      CFIndex v20 = v32;
      uint64_t v21 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex v22 = CFDataGetLength((CFDataRef)a3);
      CFIndex v23 = CFStringCreateMutable(v21, 2 * v22);
      CFIndex v24 = CFDataGetBytePtr((CFDataRef)a3);
      CFIndex v25 = CFDataGetLength((CFDataRef)a3);
      if (v25 >= 1)
      {
        CFIndex v26 = v25;
        do
        {
          unsigned int v27 = *v24++;
          CFStringAppendFormat(v23, 0LL, @"%02X", v27);
          --v26;
        }

        while (v26);
      }

      v33((uint64_t)v20, (uint64_t)v23);
      CFRelease(v23);

      if (!v9) {
        goto LABEL_23;
      }
LABEL_22:
      CFRelease(v9);
LABEL_23:
      if (v8) {
        CFRelease(v8);
      }
      return;
    }
  }

  secLogObjForScope("bskb");
  CFNumberRef v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)cfa = 138412290;
    *(void *)&cfa[4] = a3;
    _os_log_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEFAULT, "Skipping %@, not data.", cfa, 0xCu);
  }
}

uint64_t apply_block_2_5704(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

__CFData *SOSCopyECWrapped(const __CFData *a1, const __CFData *a2, CFTypeRef *a3)
{
  v12[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1895F8858](v6);
  CFDataRef v8 = (char *)v12 - v7;
  if (v9 >= 0x10)
  {
    uint64_t v10 = (void *)((char *)v12 - v7);
    do
    {
      void *v10 = 0xAAAAAAAAAAAAAAAALL;
      v10[1] = 0xAAAAAAAAAAAAAAAALL;
      v10 += 2;
      v7 -= 16LL;
    }

    while (v7);
  }

  SOSGetBackupKeyCurveParameters();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  SOSErrorCreate(1029LL, a3, 0LL, @"Unable to decode public key: %@", a1);
  return 0LL;
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_2_55(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFData **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  _OWORD v3[2] = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_3_56;
  v3[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
  v3[4] = a2;
  CFDataPerformWithHexString(v2, v3);
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_58(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  secLogObjForScope("bskb");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = a2;
    __int16 v8 = 2112;
    uint64_t v9 = v5;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Failed at bk: %@ error: %@", (uint8_t *)&v6, 0x16u);
  }
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_3_56(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  secLogObjForScope("bskb");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Add for bk: %@, wrapped: %@", (uint8_t *)&v6, 0x16u);
  }
}

void CFDataPerformWithHexString(const __CFData *a1, void *a2)
{
  uint64_t v10 = a2;
  if (a1)
  {
    uint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex Length = CFDataGetLength(a1);
    CFMutableDictionaryRef Mutable = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex v7 = CFDataGetLength(a1);
    if (v7 >= 1)
    {
      CFIndex v8 = v7;
      do
      {
        unsigned int v9 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v9);
        --v8;
      }

      while (v8);
    }
  }

  else
  {
    CFMutableDictionaryRef Mutable = @"(null)";
  }

  v10[2](v10, Mutable);
  CFRelease(Mutable);
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_2(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  _OWORD v3[2] = __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_3;
  v3[3] = &__block_descriptor_48_e21_v16__0____CFString__8l;
  uint64_t v2 = *(const __CFData **)(a1 + 32);
  v3[4] = *(void *)(a1 + 40);
  void v3[5] = a2;
  CFDataPerformWithHexString(v2, v3);
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_53(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  secLogObjForScope("bskb");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Failed at id: %@, bk: %@ error: %@", (uint8_t *)&v7, 0x20u);
  }
}

void __SOSBackupSliceKeyBagCopyWrappedKeys_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  secLogObjForScope("bskb");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "Add for id: %@, bk: %@, wrapped: %@",  (uint8_t *)&v7,  0x20u);
  }
}

void *SOSBackupSliceKeyBagCreateDirect(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (SecAllocationError((uint64_t)Instance, a3, @"View bag allocation failed")
    && (SecRequirementError(a2 != 0LL, a3, @"Need aks bag"), a2))
  {
    CFRetain(a2);
    Instance[2] = a2;
    Instance[3] = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
    Instance[4] = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }

  else if (Instance)
  {
    CFRelease(Instance);
    return 0LL;
  }

  return Instance;
}

BOOL SOSBSKBIsDirect(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 24)) == 0;
}

uint64_t SOSBSKBCopyAKSBag(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 16));
  }
  return v1;
}

uint64_t SOSBSKBGetPeers(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

CFSetRef SOSBSKBCountPeers(uint64_t a1)
{
  CFTypeRef result = *(const __CFSet **)(a1 + 24);
  if (result) {
    return (const __CFSet *)CFSetGetCount(result);
  }
  return result;
}

BOOL SOSBSKBPeerIsInKeyBag(uint64_t a1, const void *a2)
{
  return CFSetGetValue(*(CFSetRef *)(a1 + 24), a2) != 0LL;
}

BOOL SOSBKSBKeyIsInKeyBag(uint64_t a1, const __CFData *a2)
{
  CFStringRef v3 = SOSCopyIDOfDataBuffer(a2);
  if (!v3) {
    return 0LL;
  }
  CFStringRef v4 = v3;
  BOOL v5 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v3) != 0;
  CFRelease(v4);
  return v5;
}

uint64_t SOSBKSBPeerBackupKeyIsInKeyBag(uint64_t a1, const void *a2)
{
  CFMutableDataRef v4 = SOSPeerInfoV2DictionaryCopyData((uint64_t)a2, (const void *)sBackupKeyKey);
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 24), a2);
  if (!Value || (v6 = (uint64_t)Value, CFTypeID v7 = CFGetTypeID(Value), v7 != SOSPeerInfoGetTypeID()))
  {
    if (!v4) {
      return 1LL;
    }
    BOOL v10 = 0LL;
    goto LABEL_8;
  }

  CFMutableDataRef v8 = SOSPeerInfoV2DictionaryCopyData(v6, (const void *)sBackupKeyKey);
  CFMutableDataRef v9 = v8;
  if (v4 && v8)
  {
    BOOL v10 = CFEqual(v4, v8) != 0;
    CFRelease(v9);
LABEL_8:
    CFRelease(v4);
    return v10;
  }

  BOOL v10 = v4 == v8;
  if (v8) {
    CFRelease(v8);
  }
  if (v4) {
    goto LABEL_8;
  }
  return v10;
}

BOOL SOSBSKBAllPeersBackupKeysAreInKeyBag(uint64_t a1, CFSetRef theSet)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  BOOL v2 = 1LL;
  char v8 = 1;
  if (a1 && theSet)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 3221225472LL;
    unint64_t v4[2] = __SOSBSKBAllPeersBackupKeysAreInKeyBag_block_invoke;
    void v4[3] = &unk_18966C8F8;
    void v4[4] = &v5;
    void v4[5] = a1;
    CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5678, v4);
    BOOL v2 = *((_BYTE *)v6 + 24) != 0;
  }

  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18057C09C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __SOSBSKBAllPeersBackupKeysAreInKeyBag_block_invoke(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    CFTypeRef result = SOSPeerInfoGetTypeID();
    if (v4 == result)
    {
      CFTypeRef result = SOSPeerInfoHasBackupKey((uint64_t)cf);
      if ((_DWORD)result)
      {
        CFTypeRef result = SOSBKSBPeerBackupKeyIsInKeyBag(*(void *)(v3 + 40), cf);
        uint64_t v5 = *(void *)(*(void *)(v3 + 32) + 8LL);
        if (*(_BYTE *)(v5 + 24)) {
          char v6 = result;
        }
        else {
          char v6 = 0;
        }
        *(_BYTE *)(v5 + 24) = v6;
      }
    }
  }

  return result;
}

BOOL SOSBKSBPrefixedKeyIsInKeyBag(uint64_t a1, const __CFString *a2, const __CFData *a3)
{
  CFTypeID v4 = SOSKeyedPubKeyIdentifierCreateWithData(a2, a3);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v4) != 0;
  CFRelease(v5);
  return v6;
}

uint64_t SOSBSKBLoadLocked(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  unsigned int v12 = -1;
  uint64_t v5 = *(void *)(a1 + 16);
  SecRequirementError(v5 != 0, a2, @"No aks bag to load");
  if (v5)
  {
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    SecRequirementError(Length < 0x7FFFFFFF, a2, @"No aks bag to load");
    if (Length > 2147483646) {
      return 0xFFFFFFFFLL;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    int v8 = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    uint64_t v9 = aks_load_bag(BytePtr, v8, &v12);
    BOOL v10 = SecKernError(v9, a2, @"aks_load_bag failed: %d", v9);
    uint64_t v4 = v12;
    if (!v10 && v12 != -1)
    {
      aks_unload_bag(v12);
      return 0xFFFFFFFFLL;
    }
  }

  return v4;
}

uint64_t SOSBSKBLoadAndUnlockWithPeerIDAndSecret( uint64_t a1, const void *a2, const __CFData *a3, CFTypeRef *a4)
{
  uint64_t v13 = 0LL;
  CFIndex v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  int v16 = -1;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  SecRequirementError(Value != 0LL, a4, @"%@ has no wrapped key in %@", a2, a1);
  if (Value)
  {
    uint64_t v9 = SOSGetBackupKeyCurveParameters();
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    void v12[2] = __SOSBSKBLoadAndUnlockWithPeerIDAndSecret_block_invoke;
    v12[3] = &unk_18966B578;
    _OWORD v12[4] = &v13;
    v12[5] = Value;
    void v12[6] = a4;
    v12[7] = a1;
    SOSPerformWithDeviceBackupFullKey(v9, a3, a4, v12);
  }

  uint64_t v10 = *((unsigned int *)v14 + 6);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_18057C350( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __SOSBSKBLoadAndUnlockWithPeerIDAndSecret_block_invoke(uint64_t a1, uint64_t a2)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSBSKBLoadAndUnlockWithPeerIDAndSecret_block_invoke_2;
  void v6[3] = &unk_18966B550;
  uint64_t v3 = *(const __CFData **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  int8x16_t v4 = *(int8x16_t *)(a1 + 48);
  int8x16_t v7 = vextq_s8(v4, v4, 8uLL);
  return SOSPerformWithUnwrappedData(a2, v3, v4.i64[0], (uint64_t)v6);
}

uint64_t __SOSBSKBLoadAndUnlockWithPeerIDAndSecret_block_invoke_2( uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = SOSBSKBLoadAndUnlockBagWithSecret(*(void *)(a1 + 40), a2, a3, *(CFTypeRef **)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t SOSBSKBLoadAndUnlockBagWithSecret(uint64_t a1, unint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = 0xFFFFFFFFLL;
  unsigned int v18 = -1;
  uint64_t v9 = *(void *)(a1 + 16);
  SecRequirementError(v9 != 0, a4, @"No aks bag to load");
  if (v9)
  {
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    SecRequirementError(Length < 0x7FFFFFFF, a4, @"No aks bag to load");
    if (Length > 2147483646) {
      return 0xFFFFFFFFLL;
    }
    SecRequirementError(a2 >> 31 == 0, a4, @"secret too big");
    if (a2 >> 31) {
      return 0xFFFFFFFFLL;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    int v12 = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    uint64_t v13 = aks_load_bag(BytePtr, v12, &v18);
    BOOL v14 = SecKernError(v13, a4, @"aks_load_bag failed: %d", v13);
    uint64_t v8 = v18;
    if (!v14
      || (uint64_t v15 = aks_unlock_bag(v18, a3, a2),
          BOOL v16 = SecKernError(v15, a4, @"failed to unlock bag: %d", v15),
          uint64_t v8 = v18,
          !v16))
    {
      if ((_DWORD)v8 != -1)
      {
        aks_unload_bag(v8);
        return 0xFFFFFFFFLL;
      }
    }
  }

  return v8;
}

uint64_t SOSBSKBLoadAndUnlockWithPeerSecret(uint64_t a1, void *a2, const __CFData *a3, CFTypeRef *a4)
{
  if (a2) {
    a2 = (void *)a2[5];
  }
  return SOSBSKBLoadAndUnlockWithPeerIDAndSecret(a1, a2, a3, a4);
}

uint64_t SOSBSKBLoadAndUnlockWithDirectSecret(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 24));
  SecRequirementError(Count == 0, a3, @"Not direct bag");
  if (Count) {
    return 0xFFFFFFFFLL;
  }
  CFIndex Length = CFDataGetLength(a2);
  BytePtr = CFDataGetBytePtr(a2);
  return SOSBSKBLoadAndUnlockBagWithSecret(a1, Length, (uint64_t)BytePtr, a3);
}

uint64_t SOSBSKBLoadAndUnlockWithWrappingSecret(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  uint64_t v10 = 0LL;
  __int16 v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  int v13 = -1;
  CFDataRef v6 = SOSBSKBCopyRecoveryKey(a1);
  SecRequirementError(v6 != 0LL, a3, @"no recovery key found in %@", a1);
  if (v6)
  {
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = __SOSBSKBLoadAndUnlockWithWrappingSecret_block_invoke;
    void v9[3] = &unk_18966B5A0;
    void v9[4] = &v10;
    v9[5] = v6;
    void v9[6] = a3;
    v9[7] = a1;
    SOSPerformWithRecoveryKeyFullKey(a2, a3, v9);
    CFRelease(v6);
  }

  uint64_t v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_18057C6C4(_Unwind_Exception *a1)
{
}

CFDataRef SOSBSKBCopyRecoveryKey(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  BOOL v2 = SOSBSKBCopyAdditionalKeysWithPrefix((const __CFAllocator *)*MEMORY[0x189604DB0], a1, bskbRkbgPrefix);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  if (CFDictionaryGetCount(v2) == 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2020000000LL;
    uint64_t v10 = 0LL;
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SOSBSKBCopyRecoveryKey_block_invoke;
    context[3] = &unk_18966B5C8;
    void context[4] = &v7;
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_5704, context);
    CFDataRef Copy = CFDataCreateCopy(v1, (CFDataRef)v8[3]);
    _Block_object_dispose(&v7, 8);
  }

  else
  {
    CFDataRef Copy = 0LL;
  }

  CFRelease(v3);
  return Copy;
}

void sub_18057C7D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __SOSBSKBLoadAndUnlockWithWrappingSecret_block_invoke(uint64_t a1, uint64_t a2)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSBSKBLoadAndUnlockWithWrappingSecret_block_invoke_2;
  void v6[3] = &unk_18966B550;
  uint64_t v3 = *(const __CFData **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  int8x16_t v4 = *(int8x16_t *)(a1 + 48);
  int8x16_t v7 = vextq_s8(v4, v4, 8uLL);
  return SOSPerformWithUnwrappedData(a2, v3, v4.i64[0], (uint64_t)v6);
}

void SOSPerformWithRecoveryKeyFullKey(const __CFData *a1, CFTypeRef *a2, void *a3)
{
  v26[1] = *(id *)MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFDataRef v6 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v9 = (__CFString *)CFStringCreateWithBytes(v6, BytePtr, Length, 0x8000100u, 0);
  if (v9)
  {
    uint64_t v10 = v9;
    v26[0] = 0LL;
    SecRKCreateRecoveryKeyWithError(v9, v26);
    __int16 v11 = (void *)objc_claimAutoreleasedReturnValue();
    id v12 = v26[0];
    int v13 = v12;
    if (v11)
    {
      RKBackupCreateECKey((uint64_t)v11, 1);
      BOOL v14 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      RKBackupCreateECKey((uint64_t)v11, 0);
      uint64_t v15 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      BOOL v16 = v15;
      if (v14 && v15)
      {
        CFStringRef v17 = SOSCopyIDOfDataBuffer(v15);
        if (v17)
        {
          CFStringRef v18 = v17;
          CFIndex v24 = a2;
          CFIndex v25 = v13;
          CFDataGetLength(v14);
          ccec_compact_import_priv_size();
          MEMORY[0x186DFEF8C]();
          MEMORY[0x186DFEF98]();
          ccec_cp_521();
          uint64_t v19 = ccec_curve_for_length_lookup();
          MEMORY[0x1895F8858](v19);
          uint64_t v21 = (char *)&v24 - v20;
          uint64_t v22 = 0LL;
          do
          {
            CFIndex v23 = &v21[v22];
            *(void *)CFIndex v23 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v22 += 16LL;
          }

          while (v20 != v22);
          CFDataGetLength(v14);
          CFDataGetBytePtr(v14);
          if (ccec_compact_import_priv())
          {
            SOSErrorCreate(1028LL, v24, 0LL, @"Unable to perform crypto operation from fullKeyBytes.");
          }

          else
          {
            v5[2](v5, v21, v18);
            cc_clear();
          }

          int v13 = v25;
          CFRelease(v18);
        }
      }

      else
      {
        SOSErrorCreate(1029LL, a2, 0LL, @"Unable to get recovery key public and private keys.");
      }
    }

    else
    {
      BOOL v16 = 0LL;
      BOOL v14 = 0LL;
      if (a2) {
        *a2 = v12;
      }
    }

    CFRelease(v10);
  }

  else
  {
    SOSErrorCreate(1029LL, a2, 0LL, @"Unable to create key string from data.");
  }
}

uint64_t __SOSBSKBLoadAndUnlockWithWrappingSecret_block_invoke_2( uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = SOSBSKBLoadAndUnlockBagWithSecret(*(void *)(a1 + 40), a2, a3, *(CFTypeRef **)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

CFMutableDictionaryRef SOSBSKBCopyAdditionalKeysWithPrefix(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a2 + 32)) {
    return 0LL;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    CFDataRef v6 = *(const __CFDictionary **)(a2 + 32);
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    v8[2] = __SOSBSKBCopyAdditionalKeysWithPrefix_block_invoke;
    unint64_t v8[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
    void v8[4] = a3;
    v8[5] = Mutable;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)apply_block_2_5704, v8);
  }

  return Mutable;
}

CFTypeID __SOSBSKBCopyRecoveryKey_block_invoke(CFTypeID result, int a2, CFTypeRef cf)
{
  uint64_t v3 = result;
  if (!cf || (v4 = cf, v5 = CFGetTypeID(cf), uint64_t result = CFDataGetTypeID(), v5 != result)) {
    CFTypeRef v4 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = v4;
  return result;
}

void __SOSBSKBCopyAdditionalKeysWithPrefix_block_invoke(uint64_t a1, const __CFString *cf, const void *a3)
{
  if (!cf || (CFTypeID v5 = cf, v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())) {
    CFTypeID v5 = 0LL;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    CFTypeID TypeID = CFDataGetTypeID();
    if (v5)
    {
      if (v7 == TypeID && (unint64_t)CFStringFind(v5, @"-", 0LL).location == 2)
      {
        CFStringRef v9 = SOSKeyedPubKeyIdentifierCopyPrefix(v5);
        CFStringRef v10 = v9;
        CFStringRef v11 = *(CFStringRef *)(a1 + 32);
        if (v9 && v11)
        {
          if (!CFEqual(v9, v11))
          {
LABEL_15:
            CFRelease(v10);
            return;
          }
        }

        else if (v9 != v11)
        {
          goto LABEL_14;
        }

        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v5, a3);
LABEL_14:
        if (!v10) {
          return;
        }
        goto LABEL_15;
      }
    }
  }

void SOSBSKBRemoveRecoveryKey(uint64_t a1)
{
  if (a1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    uint64_t v3 = *(const __CFDictionary **)(a1 + 32);
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SOSBSKBRemoveRecoveryKey_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    void context[4] = Mutable;
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_5704, context);
    CFTypeRef v4 = *(const void **)(a1 + 32);
    if (v4)
    {
      *(void *)(a1 + 32) = 0LL;
      CFRelease(v4);
    }

    if (Mutable)
    {
      CFRetain(Mutable);
      *(void *)(a1 + 32) = Mutable;
      CFRelease(Mutable);
    }

    else
    {
      *(void *)(a1 + 32) = 0LL;
    }
  }

  else
  {
    secLogObjForScope("SecError");
    CFTypeID v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "bskb-backup: caller passed a nil backup slice keybag",  buf,  2u);
    }
  }

void __SOSBSKBRemoveRecoveryKey_block_invoke(uint64_t a1, const __CFString *cf, const void *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!cf || (CFTypeID v5 = cf, v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())) {
    CFTypeID v5 = 0LL;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    if (v7 == CFDataGetTypeID())
    {
      if (v5 && (unint64_t)CFStringFind(v5, @"-", 0LL).location == 2)
      {
        CFStringRef v8 = SOSKeyedPubKeyIdentifierCopyPrefix(v5);
        CFStringRef v9 = v8;
        if (v8 && bskbRkbgPrefix)
        {
          if (CFEqual(v8, (CFTypeRef)bskbRkbgPrefix))
          {
LABEL_11:
            secLogObjForScope("bskb-backup");
            CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v12) = 0;
              _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "skipping recovery key entry",  (uint8_t *)&v12,  2u);
            }

            goto LABEL_21;
          }
        }

        else if (v8 == (CFStringRef)bskbRkbgPrefix)
        {
          goto LABEL_11;
        }

        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), v5, a3);
LABEL_21:
        if (v9) {
          CFRelease(v9);
        }
        return;
      }
    }

    else
    {
      a3 = 0LL;
    }
  }

  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), v5, a3);
  secLogObjForScope("bskb-backup");
  CFStringRef v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138412546;
    int v13 = v5;
    __int16 v14 = 2112;
    uint64_t v15 = a3;
    _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "adding: %@:%@", (uint8_t *)&v12, 0x16u);
  }
}

BOOL SOSBSKBHasRecoveryKey(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    BOOL v2 = SOSBSKBCopyAdditionalKeysWithPrefix((const __CFAllocator *)*MEMORY[0x189604DB0], result, bskbRkbgPrefix);
    if (v2 && (v3 = v2, CFIndex v4 = CFDictionaryGetCount(v2), CFRelease(v3), v4 > 0))
    {
      return 1LL;
    }

    else
    {
      CFTypeID v5 = *(const __CFDictionary **)(v1 + 32);
      if (v5) {
        int Count = CFDictionaryGetCount(v5);
      }
      else {
        int Count = 0;
      }
      CFTypeID v7 = *(const __CFSet **)(v1 + 24);
      if (v7)
      {
        int v8 = CFSetGetCount(v7);
        CFTypeID v7 = *(const __CFSet **)(v1 + 24);
      }

      else
      {
        int v8 = 0;
      }

      if (CFSetGetCount(v7)) {
        BOOL v9 = Count <= v8;
      }
      else {
        BOOL v9 = 1;
      }
      return !v9;
    }
  }

  return result;
}

uint64_t SOSBSKBHasThisRecoveryKey(uint64_t a1, const __CFData *a2)
{
  if (!a2) {
    return 1LL;
  }
  uint64_t v3 = SOSKeyedPubKeyIdentifierCreateWithData((const __CFString *)bskbRkbgPrefix, a2);
  CFIndex v4 = v3;
  if (a1 && v3)
  {
    BOOL v5 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v3) != 0;
  }

  else
  {
    BOOL v5 = 0LL;
    uint64_t result = 0LL;
    if (!v4) {
      return result;
    }
  }

  CFRelease(v4);
  return v5;
}

uint64_t SOSCircleCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  *a3 = ccder_decode_constructed_tl();
  if (!v29)
  {
    if (!a2)
    {
      CFIndex v25 = @"Bad Circle DER";
      goto LABEL_18;
    }

    uint64_t v21 = (__CFString *)*a2;
    uint64_t v22 = @"Bad Circle DER";
LABEL_13:
    CFIndex v26 = v22;
    CFIndex v23 = 1035LL;
    goto LABEL_14;
  }

  uint64_t v28 = 0LL;
  uint64_t v7 = ccder_decode_uint64();
  *a3 = v7;
  if (v28 != 1)
  {
    CFIndex v26 = @"Bad Circle Version";
    CFIndex v23 = 5LL;
    uint64_t v21 = 0LL;
LABEL_14:
    CFIndex v24 = a2;
LABEL_19:
    SOSCreateErrorWithFormat(v23, v21, v24, 0LL, @"%@", v26);
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  *a3 = (uint64_t)der_decode_string(a1, (CFStringRef *)(Instance + 16), a2, v7, v29, v8, v9, v10);
  CFStringRef v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  *(void *)(Instance + 24) = SOSGenCountCreateFromDER( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  a3,  v29,  v12,  v13,  v14,  v15);
  *(void *)(Instance + 32) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  *(void *)(Instance + 40) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  *(void *)(Instance + 4_Block_object_dispose(va, 8) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  CFDictionaryRef theDict = 0LL;
  *a3 = der_decode_dictionary(a1, &theDict, a2, *a3, v29, v16, v17, v18);
  CFDictionaryRef v19 = theDict;
  if (!theDict)
  {
    if (!a2)
    {
      CFIndex v25 = @"Bad Circle DER1";
      goto LABEL_18;
    }

    uint64_t v21 = (__CFString *)*a2;
    uint64_t v22 = @"Bad Circle DER1";
    goto LABEL_13;
  }

  *(void *)(Instance + 56) = CFDictionaryCreateMutableCopy(v11, 0LL, theDict);
  CFRelease(v19);
  if (*a3 != v29)
  {
    if (a2)
    {
      uint64_t v21 = (__CFString *)*a2;
      uint64_t v22 = @"Bad Circle DER2";
      goto LABEL_13;
    }

    CFIndex v25 = @"Bad Circle DER2";
LABEL_18:
    CFIndex v26 = v25;
    CFIndex v23 = 1035LL;
    uint64_t v21 = 0LL;
    CFIndex v24 = 0LL;
    goto LABEL_19;
  }

  return Instance;
}

uint64_t SOSCircleCreateFromData(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  return SOSCircleCreateFromDER(a1, a3, (uint64_t *)&BytePtr);
}

uint64_t SOSCircleGetDEREncodedSize(uint64_t a1, CFTypeRef *a2)
{
  if (ccder_sizeof_uint64()
    && der_sizeof_string(*(const __CFString **)(a1 + 16))
    && der_sizeof_number(*(const __CFNumber **)(a1 + 24), a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 32), (uint64_t)a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 40), (uint64_t)a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 48), (uint64_t)a2)
    && der_sizeof_dictionary(*(const __CFDictionary **)(a1 + 56), (uint64_t)a2))
  {
    return ccder_sizeof();
  }

  SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v4,  @"don't know how to encode",  v5,  v6,  v8);
  return 0LL;
}

uint64_t SOSCircleEncodeToDER(uint64_t a1, CFTypeRef *a2, UInt8 *a3)
{
  uint64_t v5 = *(const __CFString **)(a1 + 16);
  uint64_t v6 = *(const __CFNumber **)(a1 + 24);
  uint64_t v7 = *(const __CFSet **)(a1 + 32);
  char v8 = *(const __CFSet **)(a1 + 40);
  uint64_t v9 = *(const __CFSet **)(a1 + 48);
  uint64_t v10 = der_encode_dictionary_repair(*(const __CFDictionary **)(a1 + 56), a2, 0);
  uint64_t v11 = SOSPeerInfoSetEncodeToArrayDER(v9, (uint64_t)a2, (uint64_t)a3, v10);
  uint64_t v12 = SOSPeerInfoSetEncodeToArrayDER(v8, (uint64_t)a2, (uint64_t)a3, v11);
  uint64_t v13 = SOSPeerInfoSetEncodeToArrayDER(v7, (uint64_t)a2, (uint64_t)a3, v12);
  uint64_t v14 = der_encode_number(v6, a2, (uint64_t)a3, v13);
  der_encode_string(v5, a2, a3, v14, v15, v16, v17, v18);
  ccder_encode_uint64();
  return ccder_encode_constructed_tl();
}

__CFData *SOSCircleCreateIncompatibleCircleDER()
{
  CFIndex v0 = ccder_sizeof();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataSetLength(Mutable, v0);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(Mutable);
  ccder_encode_uint64();
  uint64_t v3 = ccder_encode_constructed_tl();
  if (MutableBytePtr) {
    BOOL v4 = MutableBytePtr == (UInt8 *)v3;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4 && Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

__CFData *SOSCircleCopyEncodedData(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  DEREncodedunint64_t Size = SOSCircleGetDEREncodedSize(a1, a3);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  v8[2] = __SOSCircleCopyEncodedData_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_5758;
  void v8[4] = a1;
  v8[5] = a3;
  return CFDataCreateWithDER(v5, DEREncodedSize, v8);
}

uint64_t __SOSCircleCopyEncodedData_block_invoke(uint64_t a1, uint64_t a2, UInt8 *a3)
{
  return SOSCircleEncodeToDER(*(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40), a3);
}

uint64_t der_sizeof_data_or_null(const __CFData *a1)
{
  if (!a1) {
    return ccder_sizeof();
  }
  CFDataGetLength(a1);
  return ccder_sizeof_raw_octet_string();
}

uint64_t der_encode_data_or_null(const __CFData *a1, CFTypeRef *a2)
{
  if (a1) {
    return der_encode_data(a1, a2);
  }
  else {
    return der_encode_null(a2);
  }
}

uint64_t der_decode_data_or_null( uint64_t a1, void *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0LL;
  uint64_t v9 = der_decode_plist(a1, (uint64_t)&cf, a3, a4, a5, a6, a7, a8);
  CFTypeRef v10 = cf;
  if (cf)
  {
    CFTypeID v11 = CFGetTypeID(cf);
    if (v11 != CFDataGetTypeID())
    {
      CFRelease(v10);
      CFTypeRef v10 = 0LL;
    }
  }

  if (a2) {
    *a2 = v10;
  }
  return v9;
}

uint64_t SOSCircleGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SOSCircleGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_5762;
  block[4] = &SOSCircleGetTypeID_sSOSCircleGetTypeIDSingleton;
  if (SOSCircleGetTypeID_sSOSCircleGetTypeIDOnce != -1) {
    dispatch_once(&SOSCircleGetTypeID_sSOSCircleGetTypeIDOnce, block);
  }
  return SOSCircleGetTypeID_sSOSCircleGetTypeIDSingleton;
}

uint64_t __SOSCircleGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SOSCircleDestroy(void *a1)
{
  BOOL v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  BOOL v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0LL;
    CFRelease(v4);
  }

  uint64_t v5 = (const void *)a1[5];
  if (v5)
  {
    a1[5] = 0LL;
    CFRelease(v5);
  }

  uint64_t v6 = (const void *)a1[6];
  if (v6)
  {
    a1[6] = 0LL;
    CFRelease(v6);
  }

  uint64_t v7 = (const void *)a1[7];
  if (v7)
  {
    a1[7] = 0LL;
    CFRelease(v7);
  }

uint64_t SOSCircleCompare(const void *a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != SOSCircleGetTypeID()) {
    return 0LL;
  }
  CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
  if (v5 != SOSCircleGetTypeID()) {
    return 0LL;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == SOSCircleGetTypeID()) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = 0LL;
  }
  CFTypeID v8 = CFGetTypeID((CFTypeRef)a2);
  uint64_t TypeID = SOSCircleGetTypeID();
  uint64_t result = 0LL;
  if (v8 != TypeID) {
    a2 = 0LL;
  }
  if (v7 && a2)
  {
    CFTypeID v11 = (const void *)*((void *)v7 + 3);
    uint64_t v12 = *(const void **)(a2 + 24);
    if (v11 && v12)
    {
      uint64_t result = CFEqual(v11, v12);
      if (!(_DWORD)result) {
        return result;
      }
      goto LABEL_17;
    }

    if (v11 == v12)
    {
LABEL_17:
      uint64_t result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 4), *(CFTypeRef *)(a2 + 32));
      if ((_DWORD)result)
      {
        uint64_t result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 5), *(CFTypeRef *)(a2 + 40));
        if ((_DWORD)result)
        {
          uint64_t result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 6), *(CFTypeRef *)(a2 + 48));
          if ((_DWORD)result)
          {
            uint64_t v13 = (const void *)*((void *)v7 + 7);
            uint64_t v14 = *(const void **)(a2 + 56);
            if (v13 && v14) {
              return CFEqual(v13, v14) != 0;
            }
            else {
              return v13 == v14;
            }
          }
        }
      }

      return result;
    }

    return 0LL;
  }

  return result;
}

__CFString *SOSCircleCopyFormatDescription(uint64_t a1, const __CFDictionary *a2)
{
  if (!a2) {
    return defaultDescriptionCreate((const __CFNumber **)a1);
  }
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!CFDictionaryContainsKey(a2, @"SyncD"))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return defaultDescriptionCreate((const __CFNumber **)a1);
  }

  CFTypeID v5 = SOSGenerationCountCopyDescription(*(const __CFNumber **)(a1 + 24));
  CFStringAppendFormat(Mutable, 0LL, @"<C: gen:'%@' %@>\n", v5, *(void *)(a1 + 16));
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v26 = 0LL;
  unsigned int v27 = &v26;
  uint64_t v28 = 0x2000000000LL;
  uint64_t v29 = @"\t\t";
  uint64_t v6 = MEMORY[0x1895F87A8];
  v25[0] = MEMORY[0x1895F87A8];
  v25[1] = 0x40000000LL;
  void v25[2] = __descriptionCreateWithFormatOptions_block_invoke;
  v25[3] = &unk_18966BD48;
  v25[6] = Mutable;
  v25[7] = a2;
  v25[4] = &v26;
  v25[5] = a1;
  uint64_t v7 = *(const __CFSet **)(a1 + 32);
  uint64_t context = MEMORY[0x1895F87A8];
  uint64_t v19 = 0x40000000LL;
  uint64_t v20 = __SOSCircleForEachPeerMatching_block_invoke;
  uint64_t v21 = &unk_18966BEC8;
  uint64_t v22 = (uint64_t *)&__block_literal_global_54;
  p_isa = v25;
  CFSetApplyFunction(v7, (CFSetApplierFunction)apply_block_1_5768, &context);
  CFStringAppend(Mutable, @"\n\t\t<A:[");
  v27[3] = (uint64_t)&stru_1896794C8;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 40)))
  {
    uint64_t context = v6;
    uint64_t v19 = 0x40000000LL;
    uint64_t v20 = __descriptionCreateWithFormatOptions_block_invoke_2;
    uint64_t v21 = &unk_18966BD70;
    p_isa = &Mutable->isa;
    CFIndex v24 = a2;
    uint64_t v22 = &v26;
    CFTypeID v8 = *(const __CFSet **)(a1 + 40);
    uint64_t v11 = v6;
    uint64_t v12 = 0x40000000LL;
    uint64_t v13 = __SOSCircleForEachApplicant_block_invoke;
    uint64_t v14 = &unk_18966BAC0;
    p_uint64_t context = &context;
    CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5768, &v11);
  }

  else
  {
    CFStringAppendFormat(Mutable, 0LL, @"-");
  }

  CFStringAppend(Mutable, @"]> \n\t\t<R:[");
  v27[3] = (uint64_t)&stru_1896794C8;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 48)))
  {
    CFTypeRef v10 = *(const __CFSet **)(a1 + 48);
    uint64_t v11 = v6;
    uint64_t v12 = 0x40000000LL;
    uint64_t v13 = __descriptionCreateWithFormatOptions_block_invoke_3;
    uint64_t v14 = &unk_18966BD98;
    CFMutableStringRef v16 = Mutable;
    uint64_t v17 = a2;
    p_uint64_t context = &v26;
    CFSetApplyFunction(v10, (CFSetApplierFunction)apply_block_1_5768, &v11);
  }

  else
  {
    CFStringAppendFormat(Mutable, 0LL, @"-");
  }

  CFStringAppend(Mutable, @"]>");
  _Block_object_dispose(&v26, 8);
  return Mutable;
}

__CFString *SOSCircleCopyDescription(uint64_t a1)
{
  DebugDescriptionFormatOptions = (const __CFDictionary *)SecGetDebugDescriptionFormatOptions();
  return SOSCircleCopyFormatDescription(a1, DebugDescriptionFormatOptions);
}

void __descriptionCreateWithFormatOptions_block_invoke(uint64_t a1, CFDictionaryRef *a2)
{
  if ((SOSCircleVerifyPeerSigned(*(void *)(a1 + 40), a2, 0LL) & 1) != 0)
  {
    CFTypeID v4 = @"√";
  }

  else
  {
    CFTypeID v5 = _SOSPeerInfoCopyPubKey(a2, @"PublicSigningKey", 0LL);
    CFTypeID v4 = @"-";
    if (v5)
    {
      uint64_t v6 = v5;
      CFRelease(v6);
    }
  }

  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 48),  *(CFDictionaryRef *)(a1 + 56),  @"%@%@ %@",  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  a2,  v4);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = @"\n\t\t";
}

uint64_t __SOSCircleForEachPeerMatching_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }
  return result;
}

uint64_t apply_block_1_5768(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __descriptionCreateWithFormatOptions_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = @"\n\t\t\t";
}

uint64_t __SOSCircleForEachApplicant_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __descriptionCreateWithFormatOptions_block_invoke_3(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = @"\n\t\t";
}

__CFString *defaultDescriptionCreate(const __CFNumber **a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  uint64_t v3 = a1[3];
  uint64_t v4 = MEMORY[0x1895F87A8];
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 0x40000000LL;
  v16[2] = __defaultDescriptionCreate_block_invoke;
  void v16[3] = &__block_descriptor_tmp_129_5778;
  _OWORD v16[4] = Mutable;
  void v16[5] = a1;
  SOSGenerationCountWithDescription(v3, (uint64_t)v16);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  uint64_t v15 = @"\n";
  v11[0] = v4;
  v11[1] = 0x40000000LL;
  uint64_t v11[2] = __defaultDescriptionCreate_block_invoke_2;
  unint64_t v11[3] = &unk_18966BDE0;
  v11[4] = &v12;
  void v11[5] = a1;
  void v11[6] = Mutable;
  _OWORD v11[7] = @"\n";
  CFTypeID v5 = a1[4];
  uint64_t context = v4;
  uint64_t v18 = 0x40000000LL;
  uint64_t v19 = __SOSCircleForEachPeerMatching_block_invoke;
  uint64_t v20 = &unk_18966BEC8;
  uint64_t v21 = &__block_literal_global_54;
  uint64_t v22 = v11;
  CFSetApplyFunction(v5, (CFSetApplierFunction)apply_block_1_5768, &context);
  CFStringAppend(Mutable, @"], A:[");
  void v13[3] = (uint64_t)@"\n";
  if (CFSetGetCount(a1[5]))
  {
    v10[0] = v4;
    v10[1] = 0x40000000LL;
    void v10[2] = __defaultDescriptionCreate_block_invoke_3;
    unint64_t v10[3] = &unk_18966BE08;
    v10[4] = &v12;
    void v10[5] = Mutable;
    v10[6] = @"\n";
    uint64_t v6 = a1[5];
    uint64_t context = v4;
    uint64_t v18 = 0x40000000LL;
    uint64_t v19 = __SOSCircleForEachApplicant_block_invoke;
    uint64_t v20 = &unk_18966BAC0;
    uint64_t v21 = v10;
    CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5768, &context);
  }

  else
  {
    CFStringAppendFormat(Mutable, 0LL, @"-");
  }

  CFStringAppend(Mutable, @"], R:[");
  void v13[3] = (uint64_t)@"\n";
  if (CFSetGetCount(a1[6]))
  {
    uint64_t v7 = a1[6];
    v9[0] = v4;
    v9[1] = 0x40000000LL;
    v9[2] = __defaultDescriptionCreate_block_invoke_4;
    void v9[3] = &unk_18966BE30;
    void v9[4] = &v12;
    v9[5] = Mutable;
    void v9[6] = @"\n";
    CFSetApplyFunction(v7, (CFSetApplierFunction)apply_block_1_5768, v9);
  }

  else
  {
    CFStringAppendFormat(Mutable, 0LL, @"-");
  }

  CFStringAppend(Mutable, @"]>");
  _Block_object_dispose(&v12, 8);
  return Mutable;
}

void __defaultDescriptionCreate_block_invoke(uint64_t a1, uint64_t a2)
{
}

void __defaultDescriptionCreate_block_invoke_2(uint64_t a1, CFDictionaryRef *a2)
{
  if ((SOSCircleVerifyPeerSigned(*(void *)(a1 + 40), a2, 0LL) & 1) != 0)
  {
    uint64_t v4 = @"√";
  }

  else
  {
    CFTypeID v5 = _SOSPeerInfoCopyPubKey(a2, @"PublicSigningKey", 0LL);
    uint64_t v4 = @"-";
    if (v5)
    {
      uint64_t v6 = v5;
      CFRelease(v6);
    }
  }

  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 48),  0LL,  @"%@%@ %@",  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  a2,  v4);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a1 + 56);
}

void __defaultDescriptionCreate_block_invoke_3(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a1 + 48);
}

void __defaultDescriptionCreate_block_invoke_4(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a1 + 48);
}

__SecKey *SOSCircleVerifyPeerSigned(uint64_t a1, CFDictionaryRef *a2, CFTypeRef *a3)
{
  uint64_t result = (__SecKey *)_SOSPeerInfoCopyPubKey(a2, @"PublicSigningKey", a3);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = SOSCircleVerify(a1, result, a3);
    CFRelease(v6);
    return v7;
  }

  return result;
}

const void *SOSCircleGetSignature(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFStringRef v4 = SOSCopyIDOfKey(a2, a3);
  if (!v4) {
    return 0LL;
  }
  CFStringRef v5 = v4;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v4);
  uint64_t v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFDataGetTypeID()) {
      uint64_t v7 = 0LL;
    }
  }

  CFRelease(v5);
  return v7;
}

CFDataRef SOSCircleVerify(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  v15[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (size_t *)ccsha256_di();
  MEMORY[0x1895F8858](v6);
  CFTypeID v8 = (const uint8_t *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v7) {
    memset((char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v7);
  }
  SOSCircleHashGenAndPeers( (uint64_t)v6,  *(const __CFNumber **)(a1 + 24),  *(const __CFSet **)(a1 + 32),  (uint64_t)v8,  (uint64_t)a3);
  uint64_t result = (const __CFData *)SOSCircleGetSignature(a1, (uint64_t)a2, a3);
  if (result)
  {
    CFTypeRef v10 = result;
    size_t v11 = *v6;
    BytePtr = CFDataGetBytePtr(result);
    CFIndex Length = CFDataGetLength(v10);
    OSStatus v14 = SecKeyRawVerify(a2, 0, v8, v11, BytePtr, Length);
    return (const __CFData *)SecError(v14, (__CFString **)a3, @"Signature verification failed.");
  }

  return result;
}

uint64_t SOSCircleHashGenAndPeers( uint64_t a1, const __CFNumber *a2, const __CFSet *a3, uint64_t a4, uint64_t a5)
{
  valuePtr[1] = *MEMORY[0x1895F89C0];
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)valuePtr - v11;
  if (v13 >= 8) {
    memset((char *)valuePtr - v11, 170, v10);
  }
  ccdigest_init();
  if (a2)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a2, kCFNumberSInt64Type, valuePtr);
    uint64_t v14 = valuePtr[0];
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  valuePtr[0] = v14;
  ccdigest_update();
  uint64_t v15 = CFSetCopyValuesCFArray(a3);
  SOSCircleDigestArray(a1, v15, a4, a5);
  if (v15) {
    CFRelease(v15);
  }
  ccdigest_update();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v12, a4);
}

__CFArray *CFSetCopyValuesCFArray(const __CFSet *a1)
{
  v9[1] = *MEMORY[0x1895F89C0];
  CFIndex Count = CFSetGetCount(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFStringRef v4 = Mutable;
  if (Count >= 1)
  {
    MEMORY[0x1895F8858](Mutable);
    uint64_t v6 = (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    memset(v6, 170, v5);
    CFSetGetValues(a1, v6);
    do
    {
      size_t v7 = *v6++;
      CFArrayAppendValue(v4, v7);
      --Count;
    }

    while (Count);
  }

  return v4;
}

void SOSCircleDigestArray(uint64_t a1, const __CFArray *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  v14[0] = 0LL;
  v14[1] = v14;
  v14[2] = 0x2000000000LL;
  char v15 = 1;
  MEMORY[0x1895F8858](a1);
  size_t v10 = (char *)&context[-1] - v9;
  if (v11 >= 8) {
    memset((char *)&context[-1] - v9, 170, v8);
  }
  ccdigest_init();
  v17.CFIndex length = CFArrayGetCount(a2);
  v17.location = 0LL;
  CFArraySortValues(a2, v17, (CFComparatorFunction)SOSPeerInfoCompareByID, 0LL);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleDigestArray_block_invoke;
  context[3] = &unk_18966BCB0;
  context[6] = v10;
  context[7] = a4;
  void context[4] = v14;
  void context[5] = a1;
  v18.CFIndex length = CFArrayGetCount(a2);
  v18.location = 0LL;
  CFArrayApplyFunction(a2, v18, (CFArrayApplierFunction)apply_block_1_5768, context);
  (*(void (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v10, a3);
  _Block_object_dispose(v14, 8);
}

BOOL __SOSCircleDigestArray_block_invoke(uint64_t a1, uint64_t a2)
{
  BOOL result = SOSPeerInfoUpdateDigestWithPublicKeyBytes( a2,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(CFTypeRef **)(a1 + 56));
  if (!result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return result;
}

uint64_t __SOSCircleForEachActivePeer_block_invoke()
{
  return 1LL;
}

void *SOSCircleCreate(const __CFAllocator *a1, const __CFString *a2)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = CFStringCreateCopy(a1, a2);
  Instance[3] = sosGenerationCreateOrIncrement(0LL);
  Instance[4] = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  Instance[5] = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  Instance[6] = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  Instance[7] = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  return Instance;
}

void *SOSCircleCopyCircle(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 16));
  Instance[3] = SOSGenerationCopy(*(const __CFNumber **)(a2 + 24));
  Instance[4] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 32));
  Instance[5] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 40));
  Instance[6] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 48));
  Instance[7] = CFDictionaryCreateMutableCopy(a1, 0LL, *(CFDictionaryRef *)(a2 + 56));
  return Instance;
}

uint64_t CFSetOfPeerInfoDeepCopy(const __CFAllocator *a1, const __CFSet *a2)
{
  uint64_t v7 = 0LL;
  size_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  void v6[2] = __CFSetOfPeerInfoDeepCopy_block_invoke;
  void v6[3] = &unk_18966BC88;
  void v6[4] = &v7;
  void v6[5] = a1;
  CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_5768, v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void __CFSetOfPeerInfoDeepCopy_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  size_t v10 = (const void *)SOSPeerInfoCreateCopy(*(const __CFAllocator **)(a1 + 40), a2, &cf, a4, a5, a6, a7, a8);
  if (v10)
  {
    unint64_t v11 = v10;
    CFSetAddValue(*(CFMutableSetRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v10);
    CFRelease(v11);
  }

  else
  {
    uint64_t v12 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v15 = a2;
      __int16 v16 = 2112;
      CFTypeRef v17 = cf;
      _os_log_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEFAULT, "Failed to copy peer: %@ (%@)", buf, 0x16u);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
}

BOOL SOSCircleSetSignature(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  CFStringRef v6 = SOSCopyIDOfKey(a2, a4);
  if (v6)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), v6, a3);
    CFRelease(v6);
  }

  return v6 != 0LL;
}

CFDictionaryRef SOSCircleCopyAllSignatures(uint64_t a1)
{
  return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], *(CFDictionaryRef *)(a1 + 56));
}

BOOL SOSCircleSign(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFStringRef v6 = (size_t *)ccsha256_di();
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  if (!a2) {
    goto LABEL_6;
  }
  size_t v7 = *v6;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 0x40000000LL;
  void v12[2] = __SOSCircleSign_block_invoke;
  v12[3] = &unk_18966B720;
  void v12[6] = a1;
  v12[7] = a3;
  _OWORD v12[4] = &v13;
  v12[5] = v6;
  void v12[8] = a2;
  PerformWithBuffer(v7, (uint64_t)v12);
  size_t v8 = (const void *)v14[3];
  if (v8)
  {
    BOOL v9 = SOSCircleSetSignature(a1, a2, v8, a3);
    size_t v10 = (const void *)v14[3];
    if (v10)
    {
      void v14[3] = 0LL;
      CFRelease(v10);
    }
  }

  else
  {
LABEL_6:
    BOOL v9 = 0LL;
  }

  _Block_object_dispose(&v13, 8);
  return v9;
}

__CFData *SecKeyCopyRawHashSignature(size_t *a1, const uint8_t *a2, __SecKey *a3, __CFString **a4)
{
  size_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Size = SecKeyGetSize((uint64_t)a3, 1);
  CFMutableSetRef Mutable = CFDataCreateMutable(v8, 0LL);
  CFDataSetLength(Mutable, Size);
  size_t sigLen = CFDataGetLength(Mutable);
  size_t v11 = *a1;
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v13 = SecKeyRawSign(a3, 0, a2, v11, MutableBytePtr, &sigLen);
  if (SecError(v13, a4, @"Signing failed: %d", v13))
  {
    size_t v14 = sigLen;
    if (v14 < CFDataGetLength(Mutable)) {
      CFDataSetLength(Mutable, sigLen);
    }
  }

  else if (Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t SOSCircleCopyNextGenSignatureWithPeerAdded(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = (size_t *)ccsha256_di();
  uint64_t v13 = 0LL;
  size_t v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  if (a3)
  {
    size_t v9 = *v8;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 0x40000000LL;
    void v12[2] = __SOSCircleCopyNextGenSignatureWithPeerAdded_block_invoke;
    v12[3] = &unk_18966B748;
    void v12[6] = a1;
    v12[7] = a2;
    _OWORD v12[4] = &v13;
    v12[5] = v8;
    void v12[8] = a4;
    void v12[9] = a3;
    PerformWithBuffer(v9, (uint64_t)v12);
    uint64_t v10 = v14[3];
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  _Block_object_dispose(&v13, 8);
  return v10;
}

BOOL SOSCircleVerifySignatureExists(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if (a2) {
    return SOSCircleGetSignature(a1, a2, a3) != 0LL;
  }
  size_t v5 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "SOSCircleVerifySignatureExists no pubKey", buf, 2u);
  }

  if (a3) {
    SOSCreateErrorWithFormat( 1035LL,  (__CFString *)*a3,  a3,  0LL,  @"%@",  @"SOSCircleVerifySignatureExists no pubKey");
  }
  else {
    SOSCreateErrorWithFormat(1035LL, 0LL, 0LL, 0LL, @"%@", @"SOSCircleVerifySignatureExists no pubKey");
  }
  return 0LL;
}

CFStringRef SOSCircleCopyHashString(uint64_t a1)
{
  v5[1] = *MEMORY[0x1895F89C0];
  BOOL v2 = (size_t *)ccsha256_di();
  size_t v3 = *v2;
  MEMORY[0x1895F8858](v2);
  if (v3) {
    memset((char *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v3);
  }
  SOSCircleHashGenAndPeers( (uint64_t)v2,  *(const __CFNumber **)(a1 + 24),  *(const __CFSet **)(a1 + 32),  (uint64_t)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL),  0LL);
  return SOSCopyHashBufAsString((unsigned __int8 *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL), v3);
}

BOOL SOSCircleVerifyPeerSignatureExists(uint64_t a1, CFDictionaryRef *a2)
{
  size_t v3 = _SOSPeerInfoCopyPubKey(a2, @"PublicSigningKey", 0LL);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  BOOL v5 = SOSCircleGetSignature(a1, (uint64_t)v3, 0LL) != 0LL;
  CFRelease(v4);
  return v5;
}

uint64_t SOSCircleSignOldStyleResetToOfferingCircle( const __CFSet **a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t result = (uint64_t)SOSFullPeerInfoCopyDeviceKey(a2, a4);
  if (!result) {
    return result;
  }
  size_t v9 = (__SecKey *)result;
  if ((SOSCircleUpgradePeerInfo(a1, a3, a2) & 1) == 0)
  {
    SecKeyRef v12 = v9;
    goto LABEL_14;
  }

  SOSCircleRemoveRetired((uint64_t)a1);
  CFSetRemoveAllValues(a1[6]);
  SecKeyRef v10 = SecKeyCopyPublicKey(a3);
  SOSCircleRejectNonValidApplicants((uint64_t)a1, (uint64_t)v10);
  size_t v11 = (os_log_s *)secLogObjForScope("Development");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 0;
    _os_log_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEFAULT,  "SOSCircleEnsureRingConsistency requires ring membership and generation count consistency check",  (uint8_t *)v13,  2u);
  }

  CFDictionaryRemoveAllValues(a1[7]);
  if (!SOSCircleSign((uint64_t)a1, (uint64_t)a3, a4) || !SOSCircleSign((uint64_t)a1, (uint64_t)v9, a4))
  {
    CFRelease(v9);
    if (!v10) {
      return 0LL;
    }
    SecKeyRef v12 = v10;
LABEL_14:
    CFRelease(v12);
    return 0LL;
  }

  CFRelease(v9);
  if (v10) {
    CFRelease(v10);
  }
  return 1LL;
}

uint64_t SOSCircleUpgradePeerInfo(const __CFSet **a1, SecKeyRef key, uint64_t a3)
{
  SecKeyRef v6 = SecKeyCopyPublicKey(key);
  if (a3 && (uint64_t v7 = *(void *)(a3 + 16)) != 0) {
    uint64_t v8 = *(void *)(v7 + 40);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = SOSCircleCopyPeerInfo(a1[4], v8);
  SecKeyRef v10 = (const void *)v9;
  if (!v9) {
    goto LABEL_17;
  }
  if (SOSPeerInfoApplicationVerify(v9, v6, 0LL))
  {
    if (v6) {
      CFRelease(v6);
    }
    CFRelease(v10);
    return 1LL;
  }

  uint64_t v13 = (os_log_s *)secLogObjForScope("circle");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v21 = 0;
    _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "SOSCircleGenerationSign: Upgraded peer's Application Signature",  v21,  2u);
  }

  size_t v14 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, 0LL);
  if (v14)
  {
    uint64_t v19 = v14;
    uint64_t v20 = (const void *)SOSPeerInfoCopyAsApplication((uint64_t)v10, key, v14, 0LL, v15, v16, v17, v18);
    uint64_t updated = SOSCircleUpdatePeerInfo(a1, v20);
    if (v20) {
      CFRelease(v20);
    }
    CFRelease(v19);
  }

  else
  {
LABEL_17:
    uint64_t updated = 0LL;
  }

  if (v6) {
    CFRelease(v6);
  }
  if (v10) {
    CFRelease(v10);
  }
  return updated;
}

uint64_t SOSCircleRemoveRetired(uint64_t a1)
{
  uint64_t v1 = *(const __CFSet **)(a1 + 32);
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
  uint64_t v3 = MEMORY[0x1895F87A8];
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __CFSetRemoveAllPassing_block_invoke;
  context[3] = &unk_18966BE58;
  void context[4] = &__block_literal_global_5830;
  void context[5] = Mutable;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5768, context);
  v5[0] = v3;
  v5[1] = 0x40000000LL;
  void v5[2] = __CFSetRemoveAllPassing_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_140_5832;
  void v5[4] = v1;
  v7.CFIndex length = CFArrayGetCount(Mutable);
  v7.location = 0LL;
  CFArrayApplyFunction(Mutable, v7, (CFArrayApplierFunction)apply_block_1_5768, v5);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return 1LL;
}

void SOSCircleRejectNonValidApplicants(uint64_t a1, uint64_t a2)
{
  MutableCFDataRef Copy = CFSetCreateMutableCopy(0LL, 0LL, *(CFSetRef *)(a1 + 40));
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleRejectNonValidApplicants_block_invoke;
  v5[3] = &__block_descriptor_tmp_87_5829;
  void v5[4] = a2;
  void v5[5] = a1;
  CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)apply_block_1_5768, v5);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void __SOSCircleRejectNonValidApplicants_block_invoke(uint64_t a1, const void *a2)
{
  if ((SOSPeerInfoApplicationVerify((uint64_t)a2, *(__SecKey **)(a1 + 32), 0LL) & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    BOOL v5 = *(__CFSet **)(v4 + 40);
    CFSetAddValue(*(CFMutableSetRef *)(v4 + 48), a2);
    CFSetRemoveValue(v5, a2);
  }

void __CFSetRemoveAllPassing_block_invoke(uint64_t a1, const void *a2)
{
}

void __CFSetRemoveAllPassing_block_invoke_2(uint64_t a1, const void *a2)
{
}

uint64_t SOSCircleCopyPeerInfo(const __CFSet *a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  CFRange v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleCopyPeerInfo_block_invoke;
  v5[3] = &unk_18966BEA0;
  void v5[4] = &v6;
  void v5[5] = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_5768, v5);
  BOOL v2 = (const void *)v7[3];
  if (v2)
  {
    CFRetain(v2);
    uint64_t v3 = v7[3];
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t SOSCircleUpdatePeerInfo(const __CFSet **a1, const void *a2)
{
  if ((sosCircleUpdatePeerInfoSet(a1[4], a2) & 1) != 0 || (sosCircleUpdatePeerInfoSet(a1[5], a2) & 1) != 0) {
    return 1LL;
  }
  else {
    return sosCircleUpdatePeerInfoSet(a1[6], a2);
  }
}

uint64_t sosCircleUpdatePeerInfoSet(const __CFSet *a1, const void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = (uint64_t)CFSetGetValue(a1, a2);
  if (result)
  {
    if (CFEqual((CFTypeRef)result, a2))
    {
      return 0LL;
    }

    else
    {
      CFSetReplaceValue(a1, a2);
      return 1LL;
    }
  }

  return result;
}

uint64_t __SOSCircleCopyPeerInfo_block_invoke(uint64_t result, uint64_t a2)
{
  if (!*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v3 = result;
    if (a2) {
      uint64_t v4 = *(const void **)(a2 + 40);
    }
    else {
      uint64_t v4 = 0LL;
    }
    uint64_t result = CFEqual(v4, *(CFTypeRef *)(v3 + 40));
    if ((_DWORD)result) {
      *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = a2;
    }
  }

  return result;
}

uint64_t SOSCirclePreGenerationSign(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t SOSCircleGenerationSign(const __CFSet **a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8 = SecKeyCopyPublicKey(key);
  SOSCirclePreGenerationSign((uint64_t)a1, (uint64_t)v8);
  SOSCircleGenerationIncrement((uint64_t)a1);
  uint64_t v9 = SOSCircleGenerationSign_Internal(a1, key, a3, a4);
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

void SOSCircleGenerationIncrement(uint64_t a1)
{
  uint64_t v1 = *(const __CFNumber **)(a1 + 24);
  *(void *)(a1 + 24) = sosGenerationCreateOrIncrement(v1);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t SOSCircleGenerationSign_Internal(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v8 = SOSFullPeerInfoCopyDeviceKey(a3, a4);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = v8;
  BOOL v10 = SOSCircleUpgradePeerInfo(a1, a2, a3)
  CFRelease(v9);
  return v10;
}

uint64_t SOSCircleCountPeers(uint64_t a1)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleCountPeers_block_invoke;
  void v4[3] = &unk_18966B798;
  void v4[4] = &v5;
  uint64_t v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_48;
  void context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SOSCircleCountPeers_block_invoke(uint64_t result)
{
  return result;
}

BOOL __SOSCircleForEachPeer_block_invoke(uint64_t a1, uint64_t a2)
{
  return (!a2 || (uint64_t v3 = *(const __CFDictionary **)(a2 + 16)) == 0LL || !CFDictionaryGetValue(v3, @"RetirementDate"))
      && !SOSPeerInfoIsCloudIdentity(a2);
}

BOOL SOSCircleConcordanceSign(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef v5 = SOSFullPeerInfoCopyDeviceKey(a2, a3);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  BOOL v7 = SOSCircleSign(a1, (uint64_t)v5, a3);
  int v8 = (os_log_s *)secLogObjForScope("Development");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v10 = 0;
    _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "SOSCircleEnsureRingConsistency requires ring signing op",  v10,  2u);
  }

  CFRelease(v6);
  return v7;
}

BOOL SOSCircleIsOlderGeneration(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = CFNumberCompare(*(CFNumberRef *)(a1 + 24), *(CFNumberRef *)(a2 + 24), 0LL) + 1;
  return (v2 & 7) == 0 && v2 < 3;
}

uint64_t SOSCircleSharedTrustedPeers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  void v6[2] = __SOSCircleSharedTrustedPeers_block_invoke;
  void v6[3] = &unk_18966B770;
  void v6[5] = a3;
  void v6[6] = a2;
  void v6[4] = &v7;
  uint64_t v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_48;
  void context[5] = v6;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *__SOSCircleSharedTrustedPeers_block_invoke(uint64_t a1, const void **a2)
{
  uint64_t result = (const void *)CFEqual(*(CFTypeRef *)(a1 + 40), a2);
  if (a2 && !(_DWORD)result)
  {
    uint64_t result = SOSCircleHasPeerWithID(*(void *)(a1 + 48), a2[5]);
    if ((_DWORD)result) {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

const void *SOSCircleHasPeerWithID(uint64_t a1, const void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (result)
  {
    uint64_t v3 = (uint64_t)result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 != SOSPeerInfoGetTypeID()) {
      return 0LL;
    }
    CFTypeRef v5 = *(const __CFDictionary **)(v3 + 16);
    if (v5 && CFDictionaryGetValue(v5, @"RetirementDate")) {
      return 0LL;
    }
    else {
      return (const void *)!SOSPeerInfoIsCloudIdentity(v3);
    }
  }

  return result;
}

void SOSCircleForEachPeer(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _OWORD v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_18966BEC8;
  v3[4] = &__block_literal_global_48;
  void v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, v3);
}

const void *SOSCircleHasPeer(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return SOSCircleHasPeerWithID(a1, *(const void **)(a2 + 40));
  }
  else {
    return 0LL;
  }
}

uint64_t SOSCircleConcordanceTrust(uint64_t a1, uint64_t a2, int a3, __SecKey *a4, uint64_t a5, CFTypeRef *a6)
{
  if (a4)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberCFIndexType, valuePtr);
    if ((valuePtr[0] || SOSCircleCountPeers(a2))
      && (SOSCircleCountPeers(a2)
       || ((CFComparisonResult v11 = CFNumberCompare(*(CFNumberRef *)(a1 + 24), *(CFNumberRef *)(a2 + 24), 0LL),
            (unint64_t)(v11 + 1) <= 2)
         ? (BOOL v12 = ((v11 + 1) & 7) == 0)
         : (BOOL v12 = 0),
           !v12)))
    {
      if (SOSCircleGetSignature(a2, (uint64_t)a4, a6))
      {
        if ((SOSCircleVerify(a2, a4, a6) & 1) != 0)
        {
          if (SOSCircleCountPeers(a1))
          {
            valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
            CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberCFIndexType, valuePtr);
            if (!valuePtr[0] && SOSCircleIsOffering(a2))
            {
              uint64_t v13 = a2;
              uint64_t v14 = a2;
              uint64_t v15 = (uint64_t)a4;
              uint64_t v16 = 0LL;
              return GetSignersStatus(v13, v14, v15, v16, (uint64_t)a6);
            }

            CFComparisonResult v18 = CFNumberCompare(*(CFNumberRef *)(a2 + 24), *(CFNumberRef *)(a1 + 24), 0LL);
            if ((unint64_t)(v18 + 1) > 2 || (((_BYTE)v18 + 1) & 7) != 0)
            {
              uint64_t v13 = a1;
              uint64_t v14 = a2;
              uint64_t v15 = (uint64_t)a4;
              uint64_t v16 = a5;
              return GetSignersStatus(v13, v14, v15, v16, (uint64_t)a6);
            }

            SOSCreateErrorWithFormat( 1039LL,  0LL,  a6,  0LL,  @"%@",  @"Bad generation - proposed circle gencount is older than known circle gencount");
            debugDumpCircle(@"isOlderGeneration known_circle", a1);
            debugDumpCircle(@"isOlderGeneration proposed_circle", a2);
            return 1LL;
          }

          else
          {
            uint64_t v23 = 0LL;
            CFIndex v24 = &v23;
            uint64_t v25 = 0x2000000000LL;
            int v26 = 4;
            valuePtr[0] = MEMORY[0x1895F87A8];
            valuePtr[1] = 0x40000000LL;
            void valuePtr[2] = __GetSignersStatus_block_invoke;
            valuePtr[3] = &unk_18966BCF8;
            valuePtr[6] = a4;
            valuePtr[7] = a6;
            valuePtr[8] = 0LL;
            valuePtr[4] = &v23;
            valuePtr[5] = a2;
            uint64_t v19 = *(const __CFSet **)(a2 + 32);
            context[0] = MEMORY[0x1895F87A8];
            context[1] = 0x40000000LL;
            context[2] = __SOSCircleForEachPeerMatching_block_invoke;
            context[3] = &unk_18966BEC8;
            void context[4] = &__block_literal_global_54;
            void context[5] = valuePtr;
            CFSetApplyFunction(v19, (CFSetApplierFunction)apply_block_1_5768, context);
            uint64_t v17 = *((unsigned int *)v24 + 6);
            _Block_object_dispose(&v23, 8);
          }
        }

        else
        {
          if (a6) {
            SOSCreateErrorWithFormat( 1038LL,  (__CFString *)*a6,  a6,  0LL,  @"%@",  @"Bad user public signature");
          }
          else {
            SOSCreateErrorWithFormat(1038LL, 0LL, 0LL, 0LL, @"%@", @"Bad user public signature");
          }
          debugDumpCircle(@"proposed_circle", a2);
          return 5LL;
        }
      }

      else
      {
        if (a6) {
          SOSCreateErrorWithFormat( 1038LL,  (__CFString *)*a6,  a6,  0LL,  @"%@",  @"No public signature to match current user key");
        }
        else {
          SOSCreateErrorWithFormat( 1038LL,  0LL,  0LL,  0LL,  @"%@",  @"No public signature to match current user key");
        }
        return 2LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    SOSCreateErrorWithFormat(2LL, 0LL, a6, 0LL, @"%@", @"Concordance with no user public key");
    return 3LL;
  }

  return v17;
}

void debugDumpCircle(__CFString *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  CFTypeRef v16 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  CFTypeID v4 = (os_log_s *)secLogObjForScope("circledebug");
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (!a2) {
      return;
    }
LABEL_3:
    uint64_t v6 = SOSCircleCopyEncodedData(a2, v5, &v16);
    if (!v6) {
      return;
    }
    uint64_t v7 = v6;
    int v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex Length = CFDataGetLength(v6);
    CFMutableSetRef Mutable = CFStringCreateMutable(v8, 2 * Length);
    BytePtr = CFDataGetBytePtr(v7);
    CFIndex v12 = CFDataGetLength(v7);
    if (v12 >= 1)
    {
      CFIndex v13 = v12;
      do
      {
        unsigned int v14 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v14, v16);
        --v13;
      }

      while (v13);
    }

    uint64_t v15 = (os_log_s *)secLogObjForScope("circledebug");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFComparisonResult v18 = Mutable;
      _os_log_debug_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEBUG, "Full contents: %@", buf, 0xCu);
      if (!Mutable) {
        goto LABEL_10;
      }
    }

    else if (!Mutable)
    {
LABEL_10:
      CFRelease(v7);
      return;
    }

    CFRelease(Mutable);
    goto LABEL_10;
  }

  *(_DWORD *)__int128 buf = 138412546;
  CFComparisonResult v18 = a1;
  __int16 v19 = 2112;
  uint64_t v20 = a2;
  _os_log_debug_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEBUG, "%@: %@", buf, 0x16u);
  if (a2) {
    goto LABEL_3;
  }
}

uint64_t GetSignersStatus(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a4) {
    uint64_t v5 = *(void *)(a4 + 40);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v10 = 0LL;
  CFComparisonResult v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  int v13 = 4;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  void v9[2] = __GetSignersStatus_block_invoke;
  void v9[3] = &unk_18966BCF8;
  void v9[6] = a3;
  void v9[7] = a5;
  void v9[8] = v5;
  void v9[4] = &v10;
  v9[5] = a2;
  uint64_t v6 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_54;
  void context[5] = v9;
  CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

BOOL SOSCircleIsOffering(uint64_t a1)
{
  return !SOSCircleCountRetiredPeers(a1) && SOSCircleCountPeers(a1) == 1;
}

uint64_t GetOfferingStatus(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  int v10 = 4;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  void v6[2] = __GetOfferingStatus_block_invoke;
  void v6[3] = &unk_18966BD20;
  void v6[4] = &v7;
  void v6[5] = a1;
  void v6[6] = a2;
  void v6[7] = a3;
  uint64_t v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_48;
  void context[5] = v6;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void __GetOfferingStatus_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  uint64_t v5 = (__SecKey *)a1[6];
  uint64_t v6 = (CFTypeRef *)a1[7];
  uint64_t v7 = (__SecKey *)_SOSPeerInfoCopyPubKey((CFDictionaryRef *)a2, @"PublicSigningKey", v6);
  if (v7)
  {
    int v8 = v7;
    if (a2 && SOSCircleHasActiveValidPeerWithID(v4, *(const void **)(a2 + 40), v5))
    {
      if (SOSCircleGetSignature(v4, (uint64_t)v8, v6))
      {
        else {
          int v9 = 6;
        }
      }

      else
      {
        int v9 = 7;
      }
    }

    else
    {
      int v9 = 4;
    }

    CFRelease(v8);
  }

  else
  {
    int v9 = 4;
  }

  *(_DWORD *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v9;
  uint64_t v10 = *(void *)(a1[4] + 8LL);
  if (*(_DWORD *)(v10 + 24)) {
    *(_DWORD *)(v10 + 24) = 4;
  }
}

uint64_t SOSCircleHasActiveValidPeerWithID(uint64_t a1, const void *a2, __SecKey *a3)
{
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  else {
    return 0LL;
  }
}

uint64_t SOSCircleCountRetiredPeers(uint64_t a1)
{
  uint64_t v5 = 0LL;
  CFTypeID v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleCountRetiredPeers_block_invoke;
  void v4[3] = &unk_18966B838;
  void v4[4] = &v5;
  uint64_t v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_50;
  void context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SOSCircleCountRetiredPeers_block_invoke(uint64_t result)
{
  return result;
}

void __GetSignersStatus_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  uint64_t v5 = (__SecKey *)a1[6];
  CFTypeID v6 = (CFTypeRef *)a1[7];
  uint64_t v7 = (__SecKey *)_SOSPeerInfoCopyPubKey((CFDictionaryRef *)a2, @"PublicSigningKey", v6);
  if (!v7) {
    goto LABEL_29;
  }
  int v8 = v7;
  if (a2 && SOSCircleHasActiveValidPeerWithID(v4, *(const void **)(a2 + 40), v5))
  {
    if (SOSCircleGetSignature(v4, (uint64_t)v8, v6))
    {
      else {
        int v9 = 6;
      }
      goto LABEL_8;
    }

    CFRelease(v8);
    uint64_t v15 = *(const void **)(a2 + 40);
    CFTypeRef v16 = (const void *)a1[8];
    if (v15 && v16)
    {
      if (!CFEqual(v15, v16))
      {
LABEL_28:
        if (!SOSPeerInfoIsCloudIdentity(a2))
        {
          int v9 = 7;
          goto LABEL_9;
        }
      }
    }

    else if (v15 != v16)
    {
      goto LABEL_28;
    }

uint64_t SOSCircleGetName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

char *SOSCircleGetNameC(uint64_t a1)
{
  if (!a1) {
    return strdup((const char *)&unk_18065A197);
  }
  uint64_t v1 = *(const __CFString **)(a1 + 16);
  if (!v1) {
    return strdup((const char *)&unk_18065A197);
  }
  CFRetain(*(CFTypeRef *)(a1 + 16));
  CFIndex Length = CFStringGetLength(v1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  uint64_t v4 = (char *)malloc(v3);
  if (!CFStringGetCString(v1, v4, v3, 0x8000100u)) {
    char *v4 = 0;
  }
  CFRelease(v1);
  return v4;
}

uint64_t SOSCircleGetGeneration(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void SOSCircleSetGeneration(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 24) = 0LL;
    CFRelease(v4);
  }

  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 24) = cf;
}

CFNumberRef SOSCircleGetGenerationSint(uint64_t a1)
{
  uint64_t result = *(const __CFNumber **)(a1 + 24);
  if (result)
  {
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }

  return result;
}

void SOSCircleGenerationSetValue(uint64_t a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 24) = v3;
}

uint64_t SOSCircleCountActivePeers(uint64_t a1)
{
  uint64_t v5 = 0LL;
  CFTypeID v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleCountActivePeers_block_invoke;
  void v4[3] = &unk_18966B7C0;
  void v4[4] = &v5;
  uint64_t v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_54;
  void context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SOSCircleCountActivePeers_block_invoke(uint64_t result)
{
  return result;
}

void SOSCircleForEachActivePeer(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _OWORD v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_18966BEC8;
  v3[4] = &__block_literal_global_54;
  void v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, v3);
}

uint64_t SOSCircleCountActiveValidPeers(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = 0;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleCountActiveValidPeers_block_invoke;
  v5[3] = &unk_18966B7E8;
  void v5[4] = &v6;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __SOSCircleForEachActiveValidPeer_block_invoke;
  unint64_t v10[3] = &__block_descriptor_tmp_55_5866;
  v10[4] = a2;
  uint64_t v2 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v10;
  void context[5] = v5;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __SOSCircleCountActiveValidPeers_block_invoke(uint64_t result)
{
  return result;
}

void SOSCircleForEachActiveValidPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleForEachActiveValidPeer_block_invoke;
  void v4[3] = &__block_descriptor_tmp_55_5866;
  void v4[4] = a2;
  context[0] = MEMORY[0x1895F87A8];
  uint64_t v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v4;
  void context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
}

uint64_t __SOSCircleForEachActiveValidPeer_block_invoke(uint64_t a1, uint64_t a2)
{
  return SOSPeerInfoApplicationVerify(a2, *(__SecKey **)(a1 + 32), 0LL);
}

uint64_t SOSCircleCountValidSyncingPeers(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = 0;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleCountValidSyncingPeers_block_invoke;
  v5[3] = &unk_18966B810;
  void v5[4] = &v6;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __SOSCircleForEachValidPeer_block_invoke;
  unint64_t v10[3] = &__block_descriptor_tmp_56_5868;
  v10[4] = a2;
  uint64_t v2 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v10;
  void context[5] = v5;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, context);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __SOSCircleCountValidSyncingPeers_block_invoke(uint64_t result)
{
  return result;
}

void SOSCircleForEachValidPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleForEachValidPeer_block_invoke;
  void v4[3] = &__block_descriptor_tmp_56_5868;
  void v4[4] = a2;
  context[0] = MEMORY[0x1895F87A8];
  uint64_t v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v4;
  void context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
}

uint64_t __SOSCircleForEachValidPeer_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = *(const __CFDictionary **)(a2 + 16);
    if (v4)
    {
      if (CFDictionaryGetValue(v4, @"RetirementDate")) {
        return 0LL;
      }
    }
  }

  if (SOSPeerInfoIsCloudIdentity(a2)) {
    return 0LL;
  }
  else {
    return SOSPeerInfoApplicationVerify(a2, *(__SecKey **)(a1 + 32), 0LL);
  }
}

void SOSCircleForEachValidSyncingPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleForEachValidPeer_block_invoke;
  void v4[3] = &__block_descriptor_tmp_56_5868;
  void v4[4] = a2;
  context[0] = MEMORY[0x1895F87A8];
  uint64_t v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v4;
  void context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
}

void SOSCircleForEachRetiredPeer(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _OWORD v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_18966BEC8;
  v3[4] = &__block_literal_global_50;
  void v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, v3);
}

CFIndex SOSCircleCountApplicants(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 40));
}

BOOL SOSCircleHasApplicant(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2) != 0;
}

CFMutableSetRef SOSCircleCopyApplicants(uint64_t a1, CFAllocatorRef allocator)
{
  return CFSetCreateMutableCopy(allocator, 0LL, *(CFSetRef *)(a1 + 40));
}

CFIndex SOSCircleCountRejectedApplicants(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 48));
}

BOOL SOSCircleHasRejectedApplicant(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 48), a2) != 0;
}

const void *SOSCircleCopyRejectedApplicant(uint64_t a1, const void *a2)
{
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 48), a2);
  uint64_t v3 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v3;
}

__CFArray *SOSCircleCopyRejectedApplicants(uint64_t a1)
{
  return CFSetCopyValuesCFArray(*(const __CFSet **)(a1 + 48));
}

uint64_t SOSCircleResetToEmpty(const __CFNumber **a1)
{
  CFNumberRef v2 = SOSGenerationCreateWithBaseline(a1[3]);
  SOSCircleSetGeneration((uint64_t)a1, v2);
  if (v2) {
    CFRelease(v2);
  }
  return 1LL;
}

uint64_t SOSCircleResetToEmptyWithSameGeneration(const __CFNumber **a1)
{
  CFNumberRef v2 = SOSGenerationCopy(a1[3]);
  SOSCircleResetToEmpty(a1);
  SOSCircleSetGeneration((uint64_t)a1, v2);
  if (v2) {
    CFRelease(v2);
  }
  return 1LL;
}

uint64_t SOSCircleResetToOffering(const __CFNumber **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t result = SOSCircleRequestAdmission((uint64_t)a1, a2, a3, a4);
  if ((_DWORD)result)
  {
    if (a3) {
      int v9 = *(void **)(a3 + 16);
    }
    else {
      int v9 = 0LL;
    }
    return SOSCircleAcceptRequest(a1, a2, a3, v9, a4);
  }

  return result;
}

uint64_t SOSCircleRequestAdmission(uint64_t a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8 = SecKeyCopyPublicKey(key);
  if (v8)
  {
    SecKeyRef v9 = v8;
    if (SOSFullPeerInfoPromoteToApplication(a3, key, a4))
    {
      if (a3) {
        int v10 = *(const void ***)(a3 + 16);
      }
      else {
        int v10 = 0LL;
      }
      uint64_t v11 = SOSCircleRecordAdmissionRequest(a1, v10, a4);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    CFRelease(v9);
  }

  else
  {
    SOSCreateErrorWithFormat(1034LL, 0LL, a4, 0LL, @"%@", @"No public key for key");
    return 0LL;
  }

  return v11;
}

uint64_t SOSCircleAcceptRequest(const __CFSet **a1, __SecKey *a2, uint64_t a3, void *value, CFTypeRef *a5)
{
  if (!CFSetContainsValue(a1[5], value))
  {
    SOSCreateErrorWithFormat(1031LL, 0LL, a5, 0LL, @"%@", @"Cannot accept non-applicant");
    return 0LL;
  }

  int v10 = SecKeyCopyPublicKey(a2);
  if (!SOSPeerInfoApplicationVerify((uint64_t)value, v10, a5))
  {
    uint64_t v12 = 0LL;
    if (!v10) {
      return v12;
    }
    goto LABEL_4;
  }

  uint64_t v11 = a1[5];
  CFSetAddValue(a1[4], value);
  CFSetRemoveValue(v11, value);
  uint64_t v12 = SOSCircleGenerationSign(a1, a2, a3, a5);
  if (v10) {
LABEL_4:
  }
    CFRelease(v10);
  return v12;
}

uint64_t SOSCircleRecordAdmissionRequest(uint64_t a1, const void **value, CFTypeRef *a3)
{
  if (value && SOSCircleHasPeerWithID(a1, value[5]))
  {
    SOSCreateErrorWithFormat(1030LL, 0LL, a3, 0LL, @"%@", @"Cannot request admission when already a peer");
    return 0LL;
  }

  else
  {
    uint64_t v6 = *(__CFSet **)(a1 + 48);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), value);
    CFSetRemoveValue(v6, value);
    return 1LL;
  }

uint64_t SOSCircleRequestReadmission(uint64_t a1, __SecKey *a2, const void **a3, CFTypeRef *a4)
{
  uint64_t result = SOSPeerInfoApplicationVerify((uint64_t)a3, a2, a4);
  if ((_DWORD)result) {
    return SOSCircleRecordAdmissionRequest(a1, a3, a4);
  }
  return result;
}

uint64_t SOSCircleRemovePeers(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFSetRef theSet, CFTypeRef *a5)
{
  uint64_t v12 = 0LL;
  int v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 1;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  uint64_t v11[2] = __SOSCircleRemovePeers_block_invoke;
  unint64_t v11[3] = &unk_18966B8A0;
  v11[4] = &v12;
  void v11[5] = a1;
  void v11[6] = a3;
  _OWORD v11[7] = a5;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5768, v11);
  if (*((_BYTE *)v13 + 24)) {
    uint64_t v9 = SOSCircleGenerationSign(a1, a2, a3, a5);
  }
  else {
    uint64_t v9 = 0LL;
  }
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t __SOSCircleRemovePeers_block_invoke(uint64_t result, void *cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = SOSPeerInfoGetTypeID();
    if (v4 == result)
    {
      uint64_t result = SOSCircleRemovePeerInternal( *(void *)(v3 + 40),  *(void **)(v3 + 48),  (const void **)cf,  *(CFTypeRef **)(v3 + 56));
      uint64_t v5 = *(void *)(*(void *)(v3 + 32) + 8LL);
      if (*(_BYTE *)(v5 + 24)) {
        char v6 = result;
      }
      else {
        char v6 = 0;
      }
      *(_BYTE *)(v5 + 24) = v6;
    }
  }

  return result;
}

uint64_t SOSCircleRemovePeerInternal(uint64_t a1, void *a2, const void **value, CFTypeRef *a4)
{
  if (a2)
  {
    uint64_t v8 = a2[2];
    if (!value) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    if (!value) {
      goto LABEL_9;
    }
  }

  if (SOSCircleHasPeerWithID(a1, value[5]))
  {
    if (!v8 || (SOSCircleHasPeerWithID(a1, *(const void **)(v8 + 40)) & 1) == 0)
    {
      SOSCreateErrorWithFormat(1030LL, 0LL, a4, 0LL, @"%@", @"Must be peer to remove peer");
      return 0LL;
    }

    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 32), value);
  }

uint64_t SOSCircleRejectRequest(uint64_t a1, void *a2, void *a3, CFTypeRef *a4)
{
  if (a3)
  {
    uint64_t v7 = (const void *)a3[5];
    if (!a2) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
    if (!a2) {
      goto LABEL_8;
    }
  }

  uint64_t v8 = a2[2];
  if (v8) {
    a2 = *(void **)(v8 + 40);
  }
  else {
    a2 = 0LL;
  }
LABEL_8:
  int v9 = CFEqual(v7, a2);
  int v10 = *(__CFSet **)(a1 + 40);
  if (v9)
  {
LABEL_11:
    CFSetRemoveValue(v10, a3);
    return 1LL;
  }

  if (CFSetContainsValue(v10, a3))
  {
    uint64_t v11 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), a3);
    int v10 = v11;
    goto LABEL_11;
  }

  SOSCreateErrorWithFormat(1031LL, 0LL, a4, 0LL, @"%@", @"Cannot reject non-applicant");
  return 0LL;
}

uint64_t SOSCircleRemovePeersByID( const __CFSet **a1, __SecKey *a2, uint64_t a3, CFSetRef theSet, CFTypeRef *a5)
{
  uint64_t v12 = 0LL;
  int v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 1;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  uint64_t v11[2] = __SOSCircleRemovePeersByID_block_invoke;
  unint64_t v11[3] = &unk_18966B8C8;
  v11[4] = &v12;
  void v11[5] = a1;
  void v11[6] = a3;
  _OWORD v11[7] = a5;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5768, v11);
  if (*((_BYTE *)v13 + 24)) {
    uint64_t v9 = SOSCircleGenerationSign(a1, a2, a3, a5);
  }
  else {
    uint64_t v9 = 0LL;
  }
  _Block_object_dispose(&v12, 8);
  return v9;
}

void __SOSCircleRemovePeersByID_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v5 = (const void **)SOSCircleCopyPeerInfo(*(const __CFSet **)(*(void *)(a1 + 40) + 32LL), (uint64_t)cf);
      if (v5)
      {
        char v6 = v5;
        char v7 = SOSCircleRemovePeerInternal(*(void *)(a1 + 40), *(void **)(a1 + 48), v5, *(CFTypeRef **)(a1 + 56));
        uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
        if (*(_BYTE *)(v8 + 24)) {
          char v9 = v7;
        }
        else {
          char v9 = 0;
        }
        *(_BYTE *)(v8 + 24) = v9;
        CFRelease(v6);
      }
    }
  }

uint64_t SOSCircleRemovePeersByIDUnsigned(uint64_t a1, CFSetRef theSet)
{
  uint64_t v5 = 0LL;
  char v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 1;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  unint64_t v4[2] = __SOSCircleRemovePeersByIDUnsigned_block_invoke;
  void v4[3] = &unk_18966B8F0;
  void v4[4] = &v5;
  void v4[5] = a1;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5768, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void __SOSCircleRemovePeersByIDUnsigned_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v5 = SOSCircleCopyPeerInfo(*(const __CFSet **)(*(void *)(a1 + 40) + 32LL), v3);
  if (v5)
  {
    char v6 = (const void *)v5;
    uint64_t v7 = *(void *)(a1 + 40);
    unsigned int v8 = SOSCircleHasPeerWithID(v7, *(const void **)(v5 + 40));
    if (v8) {
      CFSetRemoveValue(*(CFMutableSetRef *)(v7 + 32), v6);
    }
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
    if (*(_BYTE *)(v9 + 24)) {
      char v10 = v8;
    }
    else {
      char v10 = 0;
    }
    *(_BYTE *)(v9 + 24) = v10;
    CFRelease(v6);
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0;
  }

uint64_t SOSCircleRemovePeer(const __CFSet **a1, __SecKey *a2, void *a3, const void **value, CFTypeRef *a5)
{
  uint64_t result = SOSCircleRemovePeerInternal((uint64_t)a1, a3, value, a5);
  if ((_DWORD)result) {
    return SOSCircleGenerationSign(a1, a2, (uint64_t)a3, a5);
  }
  return result;
}

uint64_t SOSCircleWithdrawRequest(uint64_t a1, const void *a2)
{
  return 1LL;
}

uint64_t SOSCircleRemoveRejectedPeer(uint64_t a1, const void *a2)
{
  return 1LL;
}

uint64_t SOSCircleAcceptRequests(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  char v16 = 0;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 0x40000000LL;
  void v12[2] = __SOSCircleAcceptRequests_block_invoke;
  v12[3] = &unk_18966B918;
  void v12[6] = a2;
  v12[7] = a3;
  void v12[8] = a4;
  _OWORD v12[4] = &v13;
  v12[5] = a1;
  unsigned int v8 = a1[5];
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_18966BAC0;
  void context[4] = v12;
  CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5768, context);
  if (*((_BYTE *)v14 + 24))
  {
    SOSCircleGenerationSign(a1, a2, a3, a4);
    uint64_t v9 = (os_log_s *)secLogObjForScope("circle");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "Countersigned accepted requests", (uint8_t *)context, 2u);
    }
  }

  uint64_t v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void __SOSCircleAcceptRequests_block_invoke(uint64_t a1, void *value)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  char v4 = SOSCircleAcceptRequest( *(const __CFSet ***)(a1 + 40),  *(__SecKey **)(a1 + 48),  *(void *)(a1 + 56),  value,  *(CFTypeRef **)(a1 + 64));
  uint64_t v5 = (os_log_s *)secLogObjForScope("circle");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if ((v4 & 1) != 0)
  {
    if (v6)
    {
      int v7 = 138412290;
      unsigned int v8 = value;
      _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Accepted peer: %@", (uint8_t *)&v7, 0xCu);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  else if (v6)
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "error in SOSCircleAcceptRequest\n", (uint8_t *)&v7, 2u);
  }

void SOSCircleForEachApplicant(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFSet **)(a1 + 40);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_18966BAC0;
  void context[4] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, context);
}

uint64_t SOSCirclePeerSigUpdate(const __CFSet **a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8 = SecKeyCopyPublicKey(key);
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 0x40000000LL;
  v14[2] = __SOSCirclePeerSigUpdate_block_invoke;
  void v14[3] = &__block_descriptor_tmp_45_5884;
  void v14[4] = v8;
  v14[5] = a1;
  v14[6] = a3;
  context[0] = MEMORY[0x1895F87A8];
  uint64_t v9 = a1[5];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_18966BAC0;
  void context[4] = v14;
  CFSetApplyFunction(v9, (CFSetApplierFunction)apply_block_1_5768, context);
  if (a3) {
    uint64_t v10 = *(const void **)(a3 + 16);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t updated = SOSCircleUpdatePeerInfo(a1, v10);
  if ((_DWORD)updated)
  {
    SOSCircleGenerationSign(a1, key, a3, a4);
    uint64_t v12 = (os_log_s *)secLogObjForScope("circle");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v12,  OS_LOG_TYPE_DEFAULT,  "Generation signed updated signatures on peerinfo",  (uint8_t *)context,  2u);
    }
  }

  return updated;
}

uint64_t __SOSCirclePeerSigUpdate_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = SOSPeerInfoApplicationVerify((uint64_t)a2, *(__SecKey **)(a1 + 32), 0LL);
  if ((result & 1) == 0) {
    return SOSCircleRejectRequest(*(void *)(a1 + 40), *(void **)(a1 + 48), a2, 0LL);
  }
  return result;
}

void SOSCircleForEachiCloudIdentityPeer(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  _OWORD v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_18966BEC8;
  v3[4] = &__block_literal_global_52;
  void v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, v3);
}

BOOL __SOSCircleForEachiCloudIdentityPeer_block_invoke(uint64_t a1, uint64_t a2)
{
  return SOSPeerInfoIsCloudIdentity(a2);
}

void SOSCircleForEachBackupCapablePeerForView(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleForEachBackupCapablePeerForView_block_invoke;
  v5[3] = &__block_descriptor_tmp_57_5887;
  void v5[4] = a3;
  void v5[5] = a2;
  char v4 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v5;
  void context[5] = a4;
  CFSetApplyFunction(v4, (CFSetApplierFunction)apply_block_1_5768, context);
}

uint64_t __SOSCircleForEachBackupCapablePeerForView_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    char v4 = *(const __CFDictionary **)(a2 + 16);
    if (v4)
    {
      if (CFDictionaryGetValue(v4, @"RetirementDate")) {
        return 0LL;
      }
    }
  }

  else {
    return SOSPeerInfoApplicationVerify(a2, *(__SecKey **)(a1 + 40), 0LL);
  }
}

void SOSCircleForEachRejectedApplicant(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFSet **)(a1 + 48);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachRejectedApplicant_block_invoke;
  context[3] = &unk_18966BAE8;
  void context[4] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5768, context);
}

uint64_t __SOSCircleForEachRejectedApplicant_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t SOSCircleCopyPeerWithID(uint64_t a1, const void *a2)
{
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  else {
    return 0LL;
  }
}

BOOL SOSCircleHasActivePeerWithID(uint64_t a1, const void *a2)
{
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    return v3 == SOSPeerInfoGetTypeID();
  }

  else
  {
    return 0;
  }

BOOL SOSCircleHasActivePeer(uint64_t a1, uint64_t a2)
{
  return a2 && SOSCircleHasActivePeerWithID(a1, *(const void **)(a2 + 40));
}

uint64_t SOSCircleHasValidSyncingPeer(uint64_t a1, const void *a2, __SecKey *a3)
{
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (!Value) {
    return 0LL;
  }
  uint64_t v5 = (uint64_t)Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != SOSPeerInfoGetTypeID()) {
    return 0LL;
  }
  uint64_t v7 = *(const __CFDictionary **)(v5 + 16);
  if (v7)
  {
    if (CFDictionaryGetValue(v7, @"RetirementDate")) {
      return 0LL;
    }
  }

  if (SOSPeerInfoIsCloudIdentity(v5)) {
    return 0LL;
  }
  else {
    return SOSPeerInfoApplicationVerify(v5, a3, 0LL);
  }
}

uint64_t SOSCircleHasActiveValidPeer(uint64_t a1, uint64_t a2, __SecKey *a3)
{
  if (a2) {
    return SOSCircleHasActiveValidPeerWithID(a1, *(const void **)(a2 + 40), a3);
  }
  else {
    return 0LL;
  }
}

CFMutableSetRef SOSCircleCopyPeers(uint64_t a1, CFAllocatorRef allocator)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(allocator, 0LL, &kSOSPeerSetCallbacks);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  void v6[2] = __SOSCircleCopyPeers_block_invoke;
  void v6[3] = &__block_descriptor_tmp_60_5889;
  void v6[4] = Mutable;
  context[0] = MEMORY[0x1895F87A8];
  CFTypeID v4 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_48;
  void context[5] = v6;
  CFSetApplyFunction(v4, (CFSetApplierFunction)apply_block_1_5768, context);
  return Mutable;
}

void __SOSCircleCopyPeers_block_invoke(uint64_t a1, const void *a2)
{
}

CFMutableSetRef SOSCircleCopyBackupCapablePeersForView( uint64_t a1, CFAllocatorRef allocator, uint64_t a3, uint64_t a4)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(allocator, 0LL, &kSOSPeerSetCallbacks);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __SOSCircleCopyBackupCapablePeersForView_block_invoke;
  unint64_t v10[3] = &__block_descriptor_tmp_61_5890;
  v10[4] = Mutable;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  uint64_t v11[2] = __SOSCircleForEachBackupCapablePeerForView_block_invoke;
  unint64_t v11[3] = &__block_descriptor_tmp_57_5887;
  v11[4] = a4;
  void v11[5] = a3;
  uint64_t v8 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = v11;
  void context[5] = v10;
  CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5768, context);
  return Mutable;
}

void __SOSCircleCopyBackupCapablePeersForView_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t SOSCircleAppendConcurringPeers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __SOSCircleAppendConcurringPeers_block_invoke;
  v5[3] = &__block_descriptor_tmp_62_5891;
  void v5[4] = a1;
  void v5[5] = a3;
  void v5[6] = a2;
  CFTypeID v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_54;
  void context[5] = v5;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
  return 1LL;
}

void __SOSCircleAppendConcurringPeers_block_invoke(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  if (SOSCircleVerifyPeerSigned(*(void *)(a1 + 32), a2, &cf))
  {
    CFDataRef Copy = (const void *)SOSPeerInfoCreateCopy( (const __CFAllocator *)*MEMORY[0x189604DB0],  (uint64_t)a2,  *(CFTypeRef **)(a1 + 40),  v4,  v5,  v6,  v7,  v8);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), Copy);
    CFRelease(Copy);
  }

  else if (*(void *)(a1 + 40))
  {
    uint64_t v10 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v14 = cf;
      _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "Error checking concurrence: %@", buf, 0xCu);
    }
  }

  CFTypeRef v11 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v11);
  }

CFMutableArrayRef SOSCircleCopyConcurringPeers(uint64_t a1, uint64_t a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  SOSCircleAppendConcurringPeers(a1, (uint64_t)Mutable, a2);
  return Mutable;
}

uint64_t SOSCircleCopyiCloudFullPeerInfoRef(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v15 = 0LL;
  char v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  uint64_t v18 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = (CFTypeRef *)&v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __SOSCircleCopyiCloudFullPeerInfoRef_block_invoke;
  unint64_t v10[3] = &unk_18966BB70;
  v10[4] = &v15;
  void v10[5] = &v11;
  v10[6] = a1;
  CFTypeID v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_54;
  void context[5] = v10;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
  if (!v16[3] && !v12[3])
  {
    SOSErrorCreate(1044LL, v12 + 3, 0LL, @"No iCloud identity PeerInfo found in circle");
    uint64_t v4 = (os_log_s *)secLogObjForScope("icloud-identity");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "No iCloud identity PeerInfo found in circle",  (uint8_t *)context,  2u);
    }
  }

  uint64_t v5 = v12;
  if (a2)
  {
    CFTypeRef v6 = v12[3];
    v12[3] = 0LL;
    if (*a2)
    {
      CFRelease(*a2);
      uint64_t v5 = v12;
    }

    *a2 = v6;
  }

  CFTypeRef v7 = v5[3];
  if (v7)
  {
    v5[3] = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = v16[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v8;
}

void __SOSCircleCopyiCloudFullPeerInfoRef_block_invoke(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (SOSPeerInfoIsCloudIdentity((uint64_t)a2))
  {
    if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
    {
      uint64_t v4 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v5 = a1[6];
      int v15 = 138412290;
      uint64_t v16 = v5;
      CFTypeRef v6 = "Additional cloud identity found in circle after successful creation: %@";
      CFTypeRef v7 = v4;
      uint32_t v8 = 12;
      goto LABEL_5;
    }

    if (*(void *)(*(void *)(a1[5] + 8LL) + 24LL))
    {
      uint64_t v9 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v15) = 0;
        _os_log_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEFAULT,  "More than one cloud identity found, first had error, trying new one.",  (uint8_t *)&v15,  2u);
      }
    }

    uint64_t v10 = *(void *)(a1[5] + 8LL);
    uint64_t v11 = *(const void **)(v10 + 24);
    if (v11)
    {
      *(void *)(v10 + 24) = 0LL;
      CFRelease(v11);
      uint64_t v10 = *(void *)(a1[5] + 8LL);
    }

    *(void *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = SOSFullPeerInfoCreateCloudIdentity( *MEMORY[0x189604DB0],  a2,  (CFTypeRef *)(v10 + 24));
    if (!*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
    {
      uint64_t v12 = (os_log_s *)secLogObjForScope("icloud-identity");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
        uint64_t v14 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
        int v15 = 138412546;
        uint64_t v16 = v13;
        __int16 v17 = 2112;
        uint64_t v18 = v14;
        CFTypeRef v6 = "Failed to make FullPeer for iCloud Identity: %@ (%@)";
        CFTypeRef v7 = v12;
        uint32_t v8 = 22;
LABEL_5:
        _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v15, v8);
      }
    }
  }

uint64_t SOSCircleCopyiCloudFullPeerInfoVerifier(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = (CFTypeRef *)&v15;
  uint64_t v17 = 0x2000000000LL;
  uint64_t v18 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __SOSCircleCopyiCloudFullPeerInfoVerifier_block_invoke;
  unint64_t v10[3] = &unk_18966BB98;
  void v10[5] = &v15;
  v10[6] = a1;
  v10[4] = &v11;
  CFTypeID v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_18966BEC8;
  void context[4] = &__block_literal_global_54;
  void context[5] = v10;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5768, context);
  if (!v12[3] && !v16[3])
  {
    SOSErrorCreate(1044LL, v16 + 3, 0LL, @"No iCloud identity PeerInfo found in circle");
    uint64_t v4 = (os_log_s *)secLogObjForScope("icloud-identity");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "No iCloud identity PeerInfo found in circle",  (uint8_t *)context,  2u);
    }
  }

  uint64_t v5 = v16;
  if (a2)
  {
    CFTypeRef v6 = v16[3];
    void v16[3] = 0LL;
    if (*a2)
    {
      CFRelease(*a2);
      uint64_t v5 = v16;
    }

    *a2 = v6;
  }

  CFTypeRef v7 = v5[3];
  if (v7)
  {
    v5[3] = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v8;
}

void *__SOSCircleCopyiCloudFullPeerInfoVerifier_block_invoke(void *result, CFDictionaryRef *a2)
{
  if (!*(void *)(*(void *)(result[4] + 8LL) + 24LL))
  {
    CFTypeID v3 = result;
    uint64_t result = (void *)SOSPeerInfoIsCloudIdentity((uint64_t)a2);
    if ((_DWORD)result)
    {
      uint64_t result = (void *)SOSCircleVerifyPeerSignatureExists(v3[6], a2);
      if ((_DWORD)result)
      {
        uint64_t result = SOSFullPeerInfoCreateCloudIdentity( *MEMORY[0x189604DB0],  a2,  (CFTypeRef *)(*(void *)(v3[5] + 8LL) + 24LL));
        *(void *)(*(void *)(v3[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
      }
    }
  }

  return result;
}

BOOL SOSCircleAcceptPeerFromHSA2( const __CFSet **a1, __SecKey *a2, const __CFNumber *a3, __SecKey *a4, const void *a5, uint64_t a6, CFTypeRef *a7)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a6) {
    uint64_t v14 = *(const void **)(a6 + 16);
  }
  else {
    uint64_t v14 = 0LL;
  }
  CFSetAddValue(a1[4], v14);
  CFComparisonResult v15 = CFNumberCompare(a1[3], a3, 0LL);
  if ((unint64_t)(v15 + 1) > 2 || ((v15 + 1) & 7) != 0)
  {
    SOSCreateErrorWithFormat(1039LL, 0LL, a7, 0LL, @"%@", @"Generation Count for new circle is too old");
LABEL_26:
    CFIndex v24 = SOSGenerationCountCopyDescription(a3);
    uint64_t v25 = SOSGenerationCountCopyDescription(a1[3]);
    int v26 = (os_log_s *)secLogObjForScope("circleOps");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      if (a7) {
        CFTypeRef v27 = *a7;
      }
      else {
        CFTypeRef v27 = 0LL;
      }
      *(_DWORD *)__int128 buf = 138412802;
      uint64_t v29 = v24;
      __int16 v30 = 2112;
      uint64_t v31 = v25;
      __int16 v32 = 2112;
      CFTypeRef v33 = v27;
      _os_log_impl( &dword_1804F4000,  v26,  OS_LOG_TYPE_DEFAULT,  "Failed to regenerate circle with new gen count: %@  current gencount: %@  error: %@",  buf,  0x20u);
    }

    if (v24) {
      CFRelease(v24);
    }
    if (v25) {
      CFRelease(v25);
    }
    return 0LL;
  }

  SOSCirclePreGenerationSign((uint64_t)a1, (uint64_t)a2);
  SOSCircleSetGeneration((uint64_t)a1, a3);
  if ((SOSCircleGenerationSign_Internal(a1, a2, a6, a7) & 1) == 0) {
    goto LABEL_26;
  }
  if (!SOSCircleSetSignature((uint64_t)a1, (uint64_t)a4, a5, a7))
  {
    uint64_t v18 = (os_log_s *)secLogObjForScope("circleOps");
    BOOL v20 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0LL;
    if (!v20) {
      return result;
    }
    if (a7) {
      uint64_t v21 = (__CFString *)*a7;
    }
    else {
      uint64_t v21 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v29 = v21;
    uint64_t v23 = "Failed to set signature: %@";
LABEL_25:
    _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, v23, buf, 0xCu);
    return 0LL;
  }

  unsigned __int8 v17 = SOSCircleVerify((uint64_t)a1, a4, a7);
  uint64_t v18 = (os_log_s *)secLogObjForScope("circleOps");
  BOOL result = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if ((v17 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    if (a7) {
      uint64_t v22 = (__CFString *)*a7;
    }
    else {
      uint64_t v22 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v29 = v22;
    uint64_t v23 = "Circle failed to validate after peer signature: %@";
    goto LABEL_25;
  }

  if (result)
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "Circle accepted successfully", buf, 2u);
  }

  return 1LL;
}

CFStringRef SOSCirclePeerInfoCopyStateString(uint64_t a1, __SecKey *a2, const void *a3, CFDictionaryRef *a4)
{
  if (SOSCircleVerifyPeerSignatureExists(a1, a4)) {
    int v7 = 86;
  }
  else {
    int v7 = 118;
  }
  return SOSPeerInfoCopyStateString((uint64_t)a4, a2, a3, v7);
}

CFStringRef SOSCircleCopyStateString(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = SOSGenerationCountCopyDescription(*(const __CFNumber **)(a1 + 24));
  uint64_t v5 = 118LL;
  if (a2)
  {
    if (SOSCircleGetSignature(a1, a2, 0LL)) {
      uint64_t v5 = 86LL;
    }
    else {
      uint64_t v5 = 118LL;
    }
  }

  CFStringRef v6 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"CIRCLE:    [%20@] UserSigned: %c",  v4,  v5);
  if (v4) {
    CFRelease(v4);
  }
  return v6;
}

void SOSCircleLogState(const char *a1, CFSetRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    CFStringRef v8 = SOSCircleCopyStateString((uint64_t)a2, a3);
    uint64_t v9 = (os_log_s *)secLogObjForScope(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "CIRCLE:    %@", (uint8_t *)&buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    CFIndex Count = CFSetGetCount(a2[4]);
    uint64_t v11 = (os_log_s *)secLogObjForScope(a1);
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    uint64_t v13 = MEMORY[0x1895F87A8];
    if (Count)
    {
      if (v12)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "Peers In Circle:", (uint8_t *)&buf, 2u);
      }

      v29[0] = v13;
      v29[1] = 0x40000000LL;
      v29[2] = __SOSCircleLogState_block_invoke;
      v29[3] = &__block_descriptor_tmp_72_5915;
      _OWORD v29[4] = a1;
      v29[5] = a2;
      v29[6] = a3;
      v29[7] = a4;
      uint64_t v14 = a2[4];
      *(void *)&__int128 buf = v13;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v31 = __SOSCircleForEachPeerMatching_block_invoke;
      __int16 v32 = &unk_18966BEC8;
      CFTypeRef v33 = &__block_literal_global_48;
      uint64_t v34 = v29;
      CFSetApplyFunction(v14, (CFSetApplierFunction)apply_block_1_5768, &buf);
      v28[0] = v13;
      v28[1] = 0x40000000LL;
      void v28[2] = __SOSCircleLogState_block_invoke_2;
      v28[3] = &__block_descriptor_tmp_73_5916;
      v28[4] = a1;
      v28[5] = a2;
      v28[6] = a3;
      v28[7] = a4;
      CFComparisonResult v15 = a2[4];
      *(void *)&__int128 buf = v13;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v31 = __SOSCircleForEachPeerMatching_block_invoke;
      __int16 v32 = &unk_18966BEC8;
      CFTypeRef v33 = &__block_literal_global_50;
      uint64_t v34 = v28;
      CFSetApplyFunction(v15, (CFSetApplierFunction)apply_block_1_5768, &buf);
      v27[0] = v13;
      v27[1] = 0x40000000LL;
      void v27[2] = __SOSCircleLogState_block_invoke_3;
      v27[3] = &__block_descriptor_tmp_74_5917;
      void v27[4] = a1;
      v27[5] = a2;
      v27[6] = a3;
      v27[7] = a4;
      uint64_t v16 = a2[4];
      *(void *)&__int128 buf = v13;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v31 = __SOSCircleForEachPeerMatching_block_invoke;
      __int16 v32 = &unk_18966BEC8;
      CFTypeRef v33 = &__block_literal_global_52;
      uint64_t v34 = v27;
      CFSetApplyFunction(v16, (CFSetApplierFunction)apply_block_1_5768, &buf);
    }

    else if (v12)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "Peers In Circle: None", (uint8_t *)&buf, 2u);
    }

    CFIndex v17 = CFSetGetCount(a2[5]);
    uint64_t v18 = (os_log_s *)secLogObjForScope(a1);
    BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v17)
    {
      if (v19)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "Applicants To Circle:", (uint8_t *)&buf, 2u);
      }

      v26[0] = v13;
      v26[1] = 0x40000000LL;
      id v26[2] = __SOSCircleLogState_block_invoke_75;
      unint64_t v26[3] = &__block_descriptor_tmp_76_5920;
      v26[4] = a1;
      v26[5] = a3;
      v26[6] = a4;
      BOOL v20 = a2[5];
      *(void *)&__int128 buf = v13;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v31 = __SOSCircleForEachApplicant_block_invoke;
      __int16 v32 = &unk_18966BAC0;
      CFTypeRef v33 = v26;
      CFSetApplyFunction(v20, (CFSetApplierFunction)apply_block_1_5768, &buf);
    }

    else if (v19)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "Applicants To Circle: None", (uint8_t *)&buf, 2u);
    }

    CFIndex v21 = CFSetGetCount(a2[6]);
    uint64_t v22 = (os_log_s *)secLogObjForScope(a1);
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    if (v21)
    {
      if (v23)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEFAULT, "Rejected Applicants To Circle:", (uint8_t *)&buf, 2u);
      }

      CFIndex v24 = a2[6];
      v25[0] = v13;
      v25[1] = 0x40000000LL;
      void v25[2] = __SOSCircleLogState_block_invoke_77;
      v25[3] = &__block_descriptor_tmp_78_5923;
      v25[4] = a1;
      v25[5] = a3;
      v25[6] = a4;
      CFSetApplyFunction(v24, (CFSetApplierFunction)apply_block_1_5768, v25);
    }

    else if (v23)
    {
      LOWORD(buf) = 0;
      _os_log_impl( &dword_1804F4000,  v22,  OS_LOG_TYPE_DEFAULT,  "Rejected Applicants To Circle: None",  (uint8_t *)&buf,  2u);
    }
  }

void __SOSCircleLogState_block_invoke(void *a1, CFDictionaryRef *a2)
{
  CFTypeID v3 = (const char *)a1[4];
  uint64_t v4 = (__SecKey *)a1[6];
  uint64_t v5 = (const void *)a1[7];
  if (SOSCircleVerifyPeerSignatureExists(a1[5], a2)) {
    int v6 = 86;
  }
  else {
    int v6 = 118;
  }
  SOSPeerInfoLogState(v3, (uint64_t)a2, v4, v5, v6);
}

void __SOSCircleLogState_block_invoke_2(void *a1, CFDictionaryRef *a2)
{
  CFTypeID v3 = (const char *)a1[4];
  uint64_t v4 = (__SecKey *)a1[6];
  uint64_t v5 = (const void *)a1[7];
  if (SOSCircleVerifyPeerSignatureExists(a1[5], a2)) {
    int v6 = 86;
  }
  else {
    int v6 = 118;
  }
  SOSPeerInfoLogState(v3, (uint64_t)a2, v4, v5, v6);
}

void __SOSCircleLogState_block_invoke_3(void *a1, CFDictionaryRef *a2)
{
  CFTypeID v3 = (const char *)a1[4];
  uint64_t v4 = (__SecKey *)a1[6];
  uint64_t v5 = (const void *)a1[7];
  if (SOSCircleVerifyPeerSignatureExists(a1[5], a2)) {
    int v6 = 86;
  }
  else {
    int v6 = 118;
  }
  SOSPeerInfoLogState(v3, (uint64_t)a2, v4, v5, v6);
}

void __SOSCircleLogState_block_invoke_75(uint64_t a1, uint64_t a2)
{
}

void __SOSCircleLogState_block_invoke_77(uint64_t a1, uint64_t a2)
{
}

uint64_t SOSCircleIsLegacy(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v11 = 0LL;
  BOOL v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  uint64_t v4 = (os_log_s *)secLogObjForScope("SOSMonitorMode");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = a1;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Checking if circle %@ is legacy", (uint8_t *)&buf, 0xCu);
  }

  if (a1 && a2)
  {
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 0x40000000LL;
    void v10[2] = __SOSCircleIsLegacy_block_invoke;
    unint64_t v10[3] = &unk_18966BC60;
    v10[4] = &v11;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 0x40000000LL;
    void v15[2] = __SOSCircleForEachValidPeer_block_invoke;
    void v15[3] = &__block_descriptor_tmp_56_5868;
    v15[4] = a2;
    uint64_t v5 = *(const __CFSet **)(a1 + 32);
    *(void *)&__int128 buf = MEMORY[0x1895F87A8];
    *((void *)&buf + 1) = 0x40000000LL;
    CFIndex v17 = __SOSCircleForEachPeerMatching_block_invoke;
    uint64_t v18 = &unk_18966BEC8;
    BOOL v19 = v15;
    BOOL v20 = v10;
    CFSetApplyFunction(v5, (CFSetApplierFunction)apply_block_1_5768, &buf);
  }

  int v6 = (os_log_s *)secLogObjForScope("SOSMonitorMode");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)v12 + 24)) {
      int v7 = "Legacy";
    }
    else {
      int v7 = "Not Legacy";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "END: Circle is %s", (uint8_t *)&buf, 0xCu);
  }

  uint64_t v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v8;
}

BOOL __SOSCircleIsLegacy_block_invoke(uint64_t a1, uint64_t a2)
{
  BOOL result = SOSPeerInfoIsLegacy(a2);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) |= result;
  return result;
}

uint64_t SOSPeerInfoGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSPeerInfoGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDSingleton;
  if (SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDOnce != -1) {
    dispatch_once(&SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDOnce, block);
  }
  return SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDSingleton;
}

uint64_t __SOSPeerInfoGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SOSPeerInfoDestroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      *(void *)(a1 + 16) = 0LL;
      CFRelease(v2);
    }

    CFTypeID v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      *(void *)(a1 + 24) = 0LL;
      CFRelease(v3);
    }

    uint64_t v4 = *(const void **)(a1 + 32);
    if (v4)
    {
      *(void *)(a1 + 32) = 0LL;
      CFRelease(v4);
    }

    uint64_t v5 = *(const void **)(a1 + 40);
    if (v5)
    {
      *(void *)(a1 + 40) = 0LL;
      CFRelease(v5);
    }

    int v6 = *(const void **)(a1 + 48);
    if (v6)
    {
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
      CFRelease(v6);
    }

    int v7 = *(const void **)(a1 + 64);
    if (v7)
    {
      *(void *)(a1 + 64) = 0LL;
      CFRelease(v7);
    }

    uint64_t v8 = *(const void **)(a1 + 80);
    if (v8)
    {
      *(void *)(a1 + 80) = 0LL;
      CFRelease(v8);
    }

    *(_BYTE *)(a1 + 72) = 0;
  }

uint64_t SOSPeerInfoCompare(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    uint64_t v5 = *(const void **)(a1 + 16);
    int v6 = *(const void **)(a2 + 16);
    if (v5) {
      BOOL v7 = v6 == 0LL;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7)
    {
      if (v5 != v6) {
        return 0LL;
      }
    }

    else
    {
      uint64_t result = CFEqual(v5, v6);
      if (!(_DWORD)result) {
        return result;
      }
    }

    uint64_t v8 = *(const void **)(a1 + 24);
    uint64_t v9 = *(const void **)(a2 + 24);
    if (v8 && v9) {
      return CFEqual(v8, v9) != 0;
    }
    else {
      return v8 == v9;
    }
  }

  return result;
}

CFHashCode SOSPeerInfoHash(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return CFHash(*(CFTypeRef *)(a1 + 24)) ^ v2;
}

CFStringRef SOSPeerInfoCopyFormatDescription(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(const __CFDictionary **)(a1 + 16);
  uint64_t v5 = 114LL;
  if (v4)
  {
    if (CFDictionaryGetValue(v4, @"RetirementDate")) {
      uint64_t v5 = 82LL;
    }
    else {
      uint64_t v5 = 114LL;
    }
  }

  int v36 = SOSPeerInfoVerify((CFDictionaryRef *)a1, 0LL);
  BOOL HasBackupKey = SOSPeerInfoHasBackupKey(a1);
  BOOL v34 = SOSPeerInfoKVSOnly(a1);
  BOOL v33 = SOSPeerInfoSupportsCKKSForAll(a1);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"OSVersion");
  BOOL v7 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sDeviceID);
  if (v7)
  {
    uint64_t v8 = v7;
    CFIndex Length = CFStringGetLength(v7);
    uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    if (Length > 8)
    {
      v37.location = 0LL;
      v37.CFIndex length = 8LL;
      CFStringRef Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], v8, v37);
    }

    else
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v8);
    }

    uint64_t v13 = Copy;
    CFRelease(v8);
  }

  else
  {
    uint64_t v13 = 0LL;
    uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  }

  CFMutableStringRef v14 = SOSPeerInfoCopySerialNumber(a1);
  CFStringRef v15 = CFStringCreateWithFormat(v10, a2, @"PI@%p", a1);
  uint64_t v16 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ComputerName");
  if (v16) {
    CFIndex v17 = v16;
  }
  else {
    CFIndex v17 = @"Unknown ";
  }
  uint64_t v18 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ModelName");
  if (v18) {
    BOOL v19 = v18;
  }
  else {
    BOOL v19 = @"Unknown ";
  }
  BOOL v20 = *(const __CFString **)(a1 + 48);
  if (!v20) {
    BOOL v20 = @"Unknown ";
  }
  if (Value) {
    uint64_t v21 = Value;
  }
  else {
    uint64_t v21 = @"Unknown ";
  }
  if (v13) {
    uint64_t v22 = v13;
  }
  else {
    uint64_t v22 = @"Unknown ";
  }
  if (v14) {
    BOOL v23 = v14;
  }
  else {
    BOOL v23 = @"Unknown ";
  }
  __int16 v32 = v21;
  uint64_t v31 = v19;
  uint64_t v24 = 95LL;
  if (v33) {
    uint64_t v24 = 67LL;
  }
  uint64_t v30 = v24;
  uint64_t v25 = 73LL;
  if (v34) {
    uint64_t v25 = 75LL;
  }
  uint64_t v26 = 98LL;
  if (HasBackupKey) {
    uint64_t v26 = 66LL;
  }
  uint64_t v29 = v25;
  uint64_t v27 = 115LL;
  if (v36) {
    uint64_t v27 = 83LL;
  }
  CFStringRef v12 = CFStringCreateWithFormat( v10,  a2,  @"<%@: [name: %20@] [%c%c%c%c%c%c%c%c] [type: %-20@] [spid: %8@] [os: %10@] [devid: %10@] [serial: %12@]",  v15,  v17,  45LL,  45LL,  v27,  v5,  v26,  v29,  45LL,  v30,  v31,  v20,  v32,  v22,  v23);
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v12;
}

CFStringRef SOSPeerInfoCopyDescription(uint64_t a1)
{
  DebugDescriptionFormatOptions = (const __CFDictionary *)SecGetDebugDescriptionFormatOptions();
  return SOSPeerInfoCopyFormatDescription(a1, DebugDescriptionFormatOptions);
}

uint64_t SOSPeerInfoVerify(CFDictionaryRef *a1, CFTypeRef *a2)
{
  v11[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = (size_t *)ccsha256_di();
  MEMORY[0x1895F8858]();
  int v6 = (const uint8_t *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v5) {
    memset((char *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v5);
  }
  BOOL v7 = (__SecKey *)_SOSPeerInfoCopyPubKey(a1, @"PublicSigningKey", a2);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = v7;
  if (!sosVerifyHash(v8, *v4, v6, a1[3]))
  {
    SOSErrorCreate(1038LL, a2, 0LL, @"Signature didn't verify for %@", a1);
LABEL_11:
    uint64_t v9 = 0LL;
    goto LABEL_7;
  }

  uint64_t v9 = 1LL;
LABEL_7:
  CFRelease(v8);
  return v9;
}

BOOL SOSPeerInfoHasBackupKey(uint64_t a1)
{
  CFMutableDataRef v1 = SOSPeerInfoV2DictionaryCopyData(a1, (const void *)sBackupKeyKey);
  CFMutableDataRef v2 = v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2 != 0LL;
}

BOOL SOSPeerInfoKVSOnly(uint64_t a1)
{
  CFMutableStringRef v1 = SOSPeerInfoCopyTransportType(a1);
  if (!v1) {
    return 0LL;
  }
  CFMutableStringRef v2 = v1;
  BOOL v3 = CFEqual(v1, @"KVS") != 0;
  CFRelease(v2);
  return v3;
}

CFMutableStringRef SOSPeerInfoCopyTransportType(uint64_t a1)
{
  CFMutableStringRef result = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sTransportType);
  if (!result) {
    return (CFMutableStringRef)CFRetain(@"KVS");
  }
  return result;
}

void *_SOSPeerInfoCopyPubKey(CFDictionaryRef *a1, const void *a2, CFTypeRef *a3)
{
  Value = (const __CFData *)CFDictionaryGetValue(a1[2], a2);
  int v6 = Value;
  if (Value && (CFTypeID v7 = CFGetTypeID(Value), v7 == CFDataGetTypeID()))
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    uint64_t v9 = SecKeyCreateFromPublicData((uint64_t)v8, 3LL, v6);
    SecAllocationError((uint64_t)v9, a3, @"Failed to create public key from data %@", v6);
  }

  else
  {
    if (a3) {
      SecError(-50, (__CFString **)a3, @"object %@ is not a data", v6);
    }
    return 0LL;
  }

  return v9;
}

uint64_t SOSDescriptionHash(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  v18[1] = *MEMORY[0x1895F89C0];
  MEMORY[0x1895F8858]();
  uint64_t v10 = (char *)v18 - v9;
  if (v11 >= 8) {
    memset((char *)v18 - v9, 170, v8);
  }
  ccdigest_init();
  uint64_t updated = SOSPeerInfoUpdateDigestWithDescription(a1, a2, (uint64_t)v10, a4, v12, v13, v14, v15);
  if ((_DWORD)updated) {
    (*(void (**)(uint64_t, char *, uint64_t))(a2 + 56))(a2, v10, a3);
  }
  return updated;
}

BOOL sosVerifyHash(__SecKey *a1, size_t a2, const uint8_t *a3, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  return SecKeyRawVerify(a1, 0, a3, a2, BytePtr, Length) == 0;
}

uint64_t SOSPeerInfoUpdateDigestWithDescription( uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10 = der_sizeof_plist(*(const __CFString **)(a1 + 16), a4, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v10)
  {
    size_t v11 = v10;
    uint64_t v12 = (UInt8 *)malloc(v10);
    if (v12)
    {
      uint64_t v16 = v12;
      if (der_encode_plist_repair( *(const __CFString **)(a1 + 16),  a4,  0LL,  v12,  (unint64_t)&v12[v11],  v13,  v14,  v15))
      {
        ccdigest_update();
        free(v16);
        return 1LL;
      }

      free(v16);
      SOSCreateErrorWithFormat(1025LL, 0LL, a4, 0LL, @"Description encode failed");
    }

    else
    {
      SOSCreateErrorWithFormat(1025LL, 0LL, a4, 0LL, @"Description alloc failed");
    }
  }

  else
  {
    SOSCreateErrorWithFormat(1025LL, 0LL, a4, 0LL, @"Description length failed");
  }

  return 0LL;
}

void *SOSPeerInfoCopyPubKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, @"PublicSigningKey", a2);
}

void *SOSPeerInfoCopyOctagonSigningPublicKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, @"OctagonPublicSigningKey", a2);
}

void *SOSPeerInfoCopyOctagonEncryptionPublicKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, @"OctagonPublicEncryptionKey", a2);
}

const void *SOSPeerInfoGetAutoAcceptInfo(uint64_t a1)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"PublicSigningKey");
  if (!Value) {
    return 0LL;
  }
  CFMutableStringRef v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFDataGetTypeID()) {
    return 0LL;
  }
  return v2;
}

uint64_t SOSPeerInfoSign(__SecKey *a1, uint64_t a2, CFTypeRef *a3)
{
  v14[1] = *MEMORY[0x1895F89C0];
  int v6 = (size_t *)ccsha256_di();
  MEMORY[0x1895F8858](v6);
  size_t v8 = (const uint8_t *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v7) {
    memset((char *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v7);
  }
  if ((SOSDescriptionHash(a2, (uint64_t)v6, (uint64_t)v8, a3) & 1) == 0)
  {
    uint64_t v13 = @"Failed to hash description for peer";
LABEL_11:
    SOSCreateErrorWithFormat(1040LL, 0LL, a3, 0LL, @"%@", v13);
    return 0LL;
  }

  CFDataRef v9 = sosCopySignedHash(a1, v6, v8);
  if (!v9)
  {
    uint64_t v13 = @"Failed to sign peerinfo for peer";
    goto LABEL_11;
  }

  CFDataRef v10 = v9;
  size_t v11 = *(const void **)(a2 + 24);
  if (v11)
  {
    *(void *)(a2 + 24) = 0LL;
    CFRelease(v11);
  }

  *(void *)(a2 + 24) = v10;
  return 1LL;
}

CFDataRef sosCopySignedHash(__SecKey *a1, size_t *a2, const uint8_t *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  size_t sigLen = 128LL;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v12 = v3;
  __int128 v13 = v3;
  __int128 v10 = v3;
  __int128 v11 = v3;
  __int128 v8 = v3;
  __int128 v9 = v3;
  *(_OWORD *)sig = v3;
  __int128 v7 = v3;
  if (SecKeyRawSign(a1, 0, a3, *a2, sig, &sigLen)) {
    return 0LL;
  }
  else {
    return CFDataCreate(0LL, sig, sigLen);
  }
}

uint64_t SOSPeerInfoCreate( const __CFAllocator *a1, const void *a2, const void *a3, __SecKey *a4, __SecKey *a5, __SecKey *a6, int a7, CFTypeRef *a8)
{
  return SOSPeerInfoCreate_Internal(a1, a2, a3, 0LL, a4, a5, a6, a7, a8, &__block_literal_global_6004);
}

uint64_t SOSPeerInfoCreate_Internal( const __CFAllocator *a1, const void *a2, const void *a3, const void *a4, __SecKey *a5, __SecKey *a6, __SecKey *a7, int a8, CFTypeRef *a9, void *a10)
{
  CFIndex v17 = a10;
  SOSPeerInfoGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 32) = a2;
  CFRetain(a2);
  *(void *)(Instance + 56) = SOSPeerInfoGetPeerProtocolVersion(Instance);
  CFTypeRef v51 = 0LL;
  CFTypeRef cf = 0LL;
  CFTypeRef v50 = 0LL;
  SecKeyRef v19 = SecKeyCopyPublicKey(a5);
  if (!v19)
  {
    SOSCreateErrorWithFormat(1034LL, 0LL, a9, 0LL, @"%@", @"Unable to get public");
    CFRelease((CFTypeRef)Instance);
    uint64_t v22 = 0LL;
    goto LABEL_9;
  }

  SecKeyRef v20 = v19;
  int v48 = a8;
  if (a6)
  {
    SecKeyRef v27 = SecKeyCopyPublicKey(a6);
    if (!v27) {
      goto LABEL_27;
    }
    SecKeyRef v28 = v27;
    int v29 = SecKeyCopyPublicBytes((uint64_t)v27, (uint64_t)&v51);
    CFRelease(v28);
    if (v29) {
      goto LABEL_3;
    }
  }

  if (!a7) {
    goto LABEL_20;
  }
  SecKeyRef v30 = SecKeyCopyPublicKey(a7);
  if (!v30)
  {
LABEL_27:
    uint64_t v21 = @"Unable to get public key";
    goto LABEL_4;
  }

  SecKeyRef v31 = v30;
  int v32 = SecKeyCopyPublicBytes((uint64_t)v30, (uint64_t)&v50);
  CFRelease(v31);
  if (!v32)
  {
LABEL_20:
    *(void *)(Instance + 24) = CFDataCreateMutable(a1, 0LL);
    uint64_t valuePtr = *(void *)(Instance + 56);
    CFNumberRef v33 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith( a1,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  @"ConflictVersion",  (uint64_t)v33);
    CFMutableDictionaryRef v42 = MutableForCFTypesWith;
    *(void *)(Instance + 16) = MutableForCFTypesWith;
    if (v51)
    {
      CFDictionarySetValue(MutableForCFTypesWith, @"OctagonPublicSigningKey", v51);
      CFMutableDictionaryRef v42 = *(__CFDictionary **)(Instance + 16);
    }

    if (v50)
    {
      CFDictionarySetValue(v42, @"OctagonPublicEncryptionKey", v50);
      CFMutableDictionaryRef v42 = *(__CFDictionary **)(Instance + 16);
    }

    v17[2](v17, v42);
    CFStringRef Copy = SOSCopyIDOfKey((uint64_t)v20, a9);
    *(void *)(Instance + 40) = Copy;
    if (Copy)
    {
      uint64_t v44 = Copy;
      CFIndex Length = CFStringGetLength(Copy);
      uint64_t v46 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (Length > 8)
      {
        v54.location = 0LL;
        v54.CFIndex length = 8LL;
        CFStringRef Copy = CFStringCreateWithSubstring(v46, v44, v54);
      }

      else
      {
        CFStringRef Copy = CFStringCreateCopy(v46, v44);
      }
    }

    *(void *)(Instance + 4_Block_object_dispose(va, 8) = Copy;
    *(void *)(Instance + 64) = 0LL;
    *(_BYTE *)(Instance + 72) = 0;
    if (*(void *)(Instance + 40))
    {
      if (!SOSPeerInfoUpdateToV2(Instance, a9)) {
        goto LABEL_36;
      }
      if (a3) {
        SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sBackupKeyKey, a3);
      }
      SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sViewsKey, a4);
      uint64_t v47 = (const void **)MEMORY[0x189604DE0];
      if (v48) {
        uint64_t v47 = (const void **)MEMORY[0x189604DE8];
      }
      SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sCKKSForAll, *v47);
      if ((SOSPeerInfoSign(a5, Instance, a9) & 1) == 0)
      {
LABEL_36:
        CFRelease((CFTypeRef)Instance);
        uint64_t Instance = 0LL;
      }
    }

    uint64_t v22 = Instance;
    uint64_t Instance = (uint64_t)v33;
    if (!v33) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

uint64_t SOSPeerInfoGetPeerProtocolVersion(uint64_t a1)
{
  uint64_t v1 = 3LL;
  uint64_t valuePtr = 3LL;
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"MessageProtocolVersion");
  if (Value)
  {
    __int128 v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
      return valuePtr;
    }

    else
    {
      return 3LL;
    }
  }

  return v1;
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith( const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v14 = (const void **)&a10;
  __int128 v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      __int128 v12 = v14 + 1;
      v14 += 2;
      __int128 v11 = *v12;
    }

    while (*v12);
  }

  return Mutable;
}

uint64_t SOSPeerInfoCreateWithTransportAndViews( const __CFAllocator *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, __SecKey *a10, __SecKey *a11, __SecKey *a12, unsigned __int8 a13, CFTypeRef *a14)
{
  return SOSPeerInfoCreate_Internal(a1, a2, a3, a9, a10, a11, a12, a13, a14, &__block_literal_global_40);
}

uint64_t SOSPeerInfoCreateCloudIdentity(const __CFAllocator *a1, const void *a2, __SecKey *a3, CFTypeRef *a4)
{
  return SOSPeerInfoCreate_Internal(a1, a2, 0LL, 0LL, a3, 0LL, 0LL, 0, a4, &__block_literal_global_41_6012);
}

void __SOSPeerInfoCreateCloudIdentity_block_invoke(int a1, CFMutableDictionaryRef theDict)
{
}

uint64_t SOSPeerInfoCreateCopy( const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0LL;
  }
  SOSPeerInfoPackV2Data(a2, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  SOSPeerInfoGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = CFDictionaryCreateMutableCopy(a1, 0LL, *(CFDictionaryRef *)(a2 + 16));
  *(void *)(Instance + 24) = CFDataCreateCopy(a1, *(CFDataRef *)(a2 + 24));
  *(void *)(Instance + 32) = CFDictionaryCreateCopy(a1, *(CFDictionaryRef *)(a2 + 32));
  *(void *)(Instance + 40) = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 40));
  CFStringRef Copy = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 48));
  *(void *)(Instance + 64) = 0LL;
  *(_BYTE *)(Instance + 72) = 0;
  uint64_t v13 = *(void *)(a2 + 56);
  *(void *)(Instance + 4_Block_object_dispose(va, 8) = Copy;
  *(void *)(Instance + 56) = v13;
  if (v13 <= 1) {
    SOSPeerInfoExpandV2Data(Instance, a3);
  }
  return Instance;
}

BOOL SOSPeerInfoVersionHasV2Data(uint64_t a1)
{
  return *(void *)(a1 + 56) > 1LL;
}

BOOL SOSPeerInfoVersionIsCurrent(uint64_t a1)
{
  return *(void *)(a1 + 56) > 2LL;
}

const void *SOSPeerInfoCreateCurrentCopy( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, __SecKey *a9, CFTypeRef *a10)
{
  uint64_t Copy = SOSPeerInfoCreateCopy(a1, a2, a10, a4, a5, a6, a7, (uint64_t)a8);
  __int128 v12 = (const void *)Copy;
  if (a8) {
    SOSPeerInfoV2DictionarySetValue((uint64_t)v12, (const void *)sViewsKey, a8);
  }
  if ((SOSPeerInfoSign(a9, (uint64_t)v12, a10) & 1) == 0)
  {
    CFRelease(v12);
    return 0LL;
  }

  return v12;
}

const void *SOSPeerInfoCopyWithModification( const __CFAllocator *a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, void *a5)
{
  __int128 v9 = a5;
  uint64_t Copy = (const void *)SOSPeerInfoCreateCopy(a1, a2, a4, v10, v11, v12, v13, v14);
  LODWORD(a1) = v9[2](v9, Copy, a4);

  if (!(_DWORD)a1 || (SOSPeerInfoSign(a3, (uint64_t)Copy, a4) & 1) == 0)
  {
    if (Copy)
    {
      CFRelease(Copy);
      return 0LL;
    }
  }

  return Copy;
}

const void *SOSPeerInfoCopyWithGestaltUpdate( const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSPeerInfoCopyWithGestaltUpdate_block_invoke;
  void v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  void v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

uint64_t __SOSPeerInfoCopyWithGestaltUpdate_block_invoke(uint64_t a1, uint64_t a2)
{
  CFMutableStringRef v2 = *(const void **)(a1 + 32);
  if (a2) {
    BOOL v3 = v2 == 0LL;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3)
  {
    if (*(const void **)(a2 + 32) != v2)
    {
      CFRetain(*(CFTypeRef *)(a1 + 32));
      int v6 = *(const void **)(a2 + 32);
      if (v6) {
        CFRelease(v6);
      }
      *(void *)(a2 + 32) = v2;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 16), @"DeviceGestalt", v2);
  }

  return v4;
}

const void *SOSPeerInfoCopyWithBackupKeyUpdate( const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSPeerInfoCopyWithBackupKeyUpdate_block_invoke;
  void v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  void v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

uint64_t __SOSPeerInfoCopyWithBackupKeyUpdate_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(const __CFData **)(a1 + 32);
  if (v4)
  {
    size_t v5 = SOSCopyIDOfDataBufferWithLength(v4, 8LL);
    secLogObjForScope("backup");
    int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      uint64_t v10 = v5;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Setting peerInfo backupKey to %@", (uint8_t *)&v9, 0xCu);
    }

    if (v5) {
      CFRelease(v5);
    }
    SOSPeerInfoV2DictionarySetValue(a2, (const void *)sBackupKeyKey, *(const void **)(a1 + 32));
  }

  else
  {
    secLogObjForScope("backup");
    __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "Setting peerInfo backupKey to NULL", (uint8_t *)&v9, 2u);
    }

    SOSPeerInfoV2DictionaryRemoveValue(a2, (const void *)sBackupKeyKey);
  }

  return 1LL;
}

const void *SOSPeerInfoCopyWithReplacedEscrowRecords( const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSPeerInfoCopyWithReplacedEscrowRecords_block_invoke;
  void v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  void v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

uint64_t __SOSPeerInfoCopyWithReplacedEscrowRecords_block_invoke(uint64_t a1, uint64_t a2)
{
  CFMutableStringRef v2 = *(const void **)(a1 + 32);
  if (v2) {
    SOSPeerInfoV2DictionarySetValue(a2, (const void *)sEscrowRecord, v2);
  }
  return 1LL;
}

CFMutableDataRef SOSPeerInfoCopyBackupKey(uint64_t a1)
{
  return SOSPeerInfoV2DictionaryCopyData(a1, (const void *)sBackupKeyKey);
}

const void *SOSPeerInfoCopyWithViewsChange( const __CFAllocator *a1, uint64_t a2, int a3, const void *a4, _DWORD *a5, __SecKey *a6, CFTypeRef *a7, uint64_t a8)
{
  uint64_t Copy = SOSPeerInfoCreateCopy(a1, a2, a7, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  uint64_t v14 = (const void *)Copy;
  if (a3 == 2)
  {
    int v16 = SOSViewsDisable(Copy, a4, a7);
    *a5 = v16;
    if (v16 != 2) {
      goto LABEL_9;
    }
  }

  else if (a3 == 1)
  {
    int v15 = SOSViewsEnable(Copy, a4, a7);
    *a5 = v15;
    if (v15 != 1) {
      goto LABEL_9;
    }
  }

  *a5 = 0;
LABEL_9:
  if (v14)
  {
    CFRelease(v14);
    return 0LL;
  }

  return v14;
}

uint64_t SOSPeerInfoCopyWithPing( const __CFAllocator *a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy = SOSPeerInfoCreateCopy(a1, a2, a4, (uint64_t)a4, a5, a6, a7, a8);
  uint64_t v11 = (const void *)CFDataCreateWithRandomBytes(8uLL);
  SOSPeerInfoV2DictionarySetValue(Copy, @"Ping", v11);
  uint64_t v12 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)Copy, @"PublicSigningKey", a4);
  uint64_t v13 = v12;
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v14 = SOSCopyIDOfKey((uint64_t)v12, a4);
  *(void *)(Copy + 40) = v14;
  if (!v14)
  {
    *(void *)(Copy + 4_Block_object_dispose(va, 8) = 0LL;
    if (!v11) {
      goto LABEL_12;
    }
LABEL_11:
    CFRelease(v11);
    goto LABEL_12;
  }

  int v15 = v14;
  CFIndex Length = CFStringGetLength(v14);
  CFIndex v17 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (Length > 8)
  {
    v21.location = 0LL;
    v21.CFIndex length = 8LL;
    CFStringRef v18 = CFStringCreateWithSubstring(v17, v15, v21);
  }

  else
  {
    CFStringRef v18 = CFStringCreateCopy(v17, v15);
  }

  uint64_t v19 = *(void *)(Copy + 40);
  *(void *)(Copy + 4_Block_object_dispose(va, 8) = v18;
  if (!v19 || (SOSPeerInfoSign(a3, Copy, a4) & 1) != 0)
  {
LABEL_10:
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  CFRelease((CFTypeRef)Copy);
  uint64_t Copy = 0LL;
  if (v11) {
    goto LABEL_11;
  }
LABEL_12:
  if (v13) {
    CFRelease(v13);
  }
  return Copy;
}

CFComparisonResult SOSPeerInfoCompareByID(const __CFString *info, const __CFString *a2)
{
  if (info && a2)
  {
    info = (const __CFString *)info[1].info;
    a2 = (const __CFString *)a2[1].info;
    if (info && a2 != 0LL) {
      return CFStringCompare(info, a2, 0LL);
    }
  }

  return (unint64_t)(info != a2);
}

uint64_t SOSPeerInfoGetPeerID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t SOSPeerInfoCompareByApplicationDate(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    Date = (const __CFDate *)sosPeerInfoGetDate(a1, @"ApplicationDate");
    uint64_t v4 = (const __CFDate *)sosPeerInfoGetDate(a2, @"ApplicationDate");
    size_t v5 = v4;
    if (Date && v4)
    {
      CFComparisonResult v6 = CFDateCompare(Date, v4, 0LL);
      CFRelease(Date);
      CFRelease(v5);
      return v6;
    }

    else
    {
      if (Date) {
        CFRelease(Date);
      }
      if (v5) {
        CFRelease(v5);
      }
      if (Date - v5 < 0) {
        return -1LL;
      }
      else {
        return Date != v5;
      }
    }
  }

  else if (a1 - a2 < 0)
  {
    return -1LL;
  }

  else
  {
    return a1 != a2;
  }

unint64_t sosPeerInfoGetDate(uint64_t a1, const void *a2)
{
  if (a1 && (Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2)) != 0LL) {
    return sosCreateCFDate(Value);
  }
  else {
    return 0LL;
  }
}

unint64_t sosCreateCFDate(const __CFData *a1)
{
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  BytePtr = CFDataGetBytePtr(a1);
  BOOL v3 = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  der_decode_date(0LL, (CFDateRef *)&v9, 0LL, (uint64_t)BytePtr, (uint64_t)&v3[Length], v5, v6, v7);
  return v9;
}

unint64_t SOSPeerInfoGetApplicationDate(uint64_t a1)
{
  return sosPeerInfoGetDate(a1, @"ApplicationDate");
}

CFStringRef SOSPeerInfoCopyStateString(uint64_t a1, __SecKey *a2, const void *a3, int a4)
{
  if (!a1) {
    return 0LL;
  }
  int v7 = SOSPeerInfoApplicationVerify(a1, a2, 0LL);
  __int128 v8 = *(const __CFDictionary **)(a1 + 16);
  uint64_t v9 = 114LL;
  if (v8)
  {
    if (CFDictionaryGetValue(v8, @"RetirementDate")) {
      uint64_t v9 = 82LL;
    }
    else {
      uint64_t v9 = 114LL;
    }
  }

  BOOL HasBackupKey = SOSPeerInfoHasBackupKey(a1);
  uint64_t v11 = *(const void **)(a1 + 40);
  int v52 = v7;
  int v51 = a4;
  BOOL v50 = HasBackupKey;
  if (a3 && v11) {
    BOOL v12 = CFEqual(v11, a3) != 0;
  }
  else {
    BOOL v12 = v11 == a3;
  }
  BOOL v47 = v12;
  BOOL v49 = SOSPeerInfoKVSOnly(a1);
  BOOL v48 = SOSPeerInfoSupportsCKKSForAll(a1);
  int HasUserVisibleViewsEnabled = SOSPeerInfoHasUserVisibleViewsEnabled(a1);
  BOOL IsLegacy = SOSPeerInfoIsLegacy(a1);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"OSVersion");
  CFIndex v17 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sMachineIDKey);
  if (v17)
  {
    CFStringRef v18 = v17;
    CFIndex Length = CFStringGetLength(v17);
    SecKeyRef v20 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    if (Length > 8)
    {
      v53.location = 0LL;
      v53.CFIndex length = 8LL;
      CFStringRef Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], v18, v53);
    }

    else
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v18);
    }

    uint64_t v22 = Copy;
    CFRelease(v18);
  }

  else
  {
    uint64_t v22 = 0LL;
    SecKeyRef v20 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  }

  CFMutableStringRef v23 = SOSPeerInfoCopySerialNumber(a1);
  CFTypeRef v24 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ComputerName");
  if (v24) {
    CFTypeRef v25 = v24;
  }
  else {
    CFTypeRef v25 = @"Unknown ";
  }
  uint64_t v26 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ModelName");
  if (v26) {
    SecKeyRef v27 = v26;
  }
  else {
    SecKeyRef v27 = @"Unknown ";
  }
  SecKeyRef v28 = *(const __CFString **)(a1 + 48);
  if (!v28) {
    SecKeyRef v28 = @"Unknown ";
  }
  if (Value) {
    int v29 = Value;
  }
  else {
    int v29 = @"Unknown ";
  }
  if (v22) {
    SecKeyRef v30 = v22;
  }
  else {
    SecKeyRef v30 = @"Unknown ";
  }
  if (v23) {
    SecKeyRef v31 = v23;
  }
  else {
    SecKeyRef v31 = @"Unknown ";
  }
  CFTypeRef v45 = v28;
  uint64_t v46 = v29;
  uint64_t v44 = v27;
  uint64_t v32 = 79LL;
  if (IsLegacy) {
    uint64_t v32 = 76LL;
  }
  uint64_t v33 = 85LL;
  if (!HasUserVisibleViewsEnabled) {
    uint64_t v33 = 95LL;
  }
  uint64_t v43 = v32;
  uint64_t v34 = 67LL;
  if (!v48) {
    uint64_t v34 = 95LL;
  }
  uint64_t v35 = 73LL;
  if (v49) {
    uint64_t v35 = 75LL;
  }
  uint64_t v41 = v35;
  uint64_t v42 = v34;
  uint64_t v36 = 98LL;
  if (v50) {
    uint64_t v36 = 66LL;
  }
  uint64_t v40 = v36;
  uint64_t v37 = 97LL;
  if (v52) {
    uint64_t v37 = 65LL;
  }
  uint64_t v38 = 109LL;
  if (v47) {
    uint64_t v38 = 77LL;
  }
  CFStringRef v13 = CFStringCreateWithFormat( v20,  0LL,  @"[name: %-20@] [%c%c%c%c%c%c%c%c%c%c] [type: %-20@] [spid: %8@] [os: %10@] [mid: %10@] [serial: %12@]",  v25,  v38,  v37,  83LL,  v9,  v40,  v41,  v42,  v33,  v43,  v51,  v44,  v45,  v46,  v30,  v31);
  if (v22) {
    CFRelease(v22);
  }
  if (v23) {
    CFRelease(v23);
  }
  return v13;
}

uint64_t SOSPeerInfoApplicationVerify(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  v17[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (size_t *)ccsha256_di();
  MEMORY[0x1895F8858](v6);
  __int128 v8 = (const uint8_t *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v7) {
    memset((char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v7);
  }
  if (!a2)
  {
    SOSErrorCreate(1033LL, a3, 0LL, @"Can't validate PeerInfos with no userKey");
    return 0LL;
  }

  CFStringRef v9 = SOSCopyIDOfKey((uint64_t)a2, a3);
  uint64_t v10 = v9;
  CFStringRef v11 = *(CFStringRef *)(a1 + 64);
  if (!v9 || !v11)
  {
    if (v9 != v11) {
      goto LABEL_9;
    }
LABEL_19:
    uint64_t v14 = *(_BYTE *)(a1 + 72) != 0;
    goto LABEL_15;
  }

  if (CFEqual(v9, v11)) {
    goto LABEL_19;
  }
  CFStringRef v11 = *(CFStringRef *)(a1 + 64);
LABEL_9:
  if (v11)
  {
    *(void *)(a1 + 64) = 0LL;
    CFRelease(v11);
  }

  *(_BYTE *)(a1 + 72) = 0;
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"ApplicationUsig");
  if (Value)
  {
    CFStringRef v13 = Value;
    if (sospeer_application_hash(a1, (uint64_t)v6, (uint64_t)v8))
    {
      if (sosVerifyHash(a2, *v6, v8, v13))
      {
        *(void *)(a1 + 64) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v10);
        *(_BYTE *)(a1 + 72) = 1;
        uint64_t v14 = SOSPeerInfoVerify((CFDictionaryRef *)a1, a3);
        goto LABEL_15;
      }

      int v16 = @"user signature of public key hash fails to verify";
    }

    else
    {
      int v16 = @"Failed to create hash for peer applicant";
    }
  }

  else
  {
    int v16 = @"Peer is not an applicant";
  }

  SOSCreateErrorWithFormat(1040LL, 0LL, a3, 0LL, @"%@", v16);
  uint64_t v14 = 0LL;
LABEL_15:
  if (v10) {
    CFRelease(v10);
  }
  return v14;
}

BOOL SOSPeerInfoIsLegacy(uint64_t a1)
{
  int Class = SOSPeerInfoGetClass(a1);
  if (Class)
  {
    if (Class == 3)
    {
      Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"OSVersion");
      BOOL v4 = (int)majorVersion(Value) < 21;
      uint64_t v5 = "MacOS";
    }

    else
    {
      if (Class != 2)
      {
        reportLegacyStatus((uint64_t)"Default", a1, 0);
        return 0LL;
      }

      BOOL v3 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"OSVersion");
      BOOL v4 = (int)majorVersion(v3) < 19;
      uint64_t v5 = "IOS";
    }

    uint64_t v6 = a1;
    int v7 = v4;
  }

  else
  {
    uint64_t v5 = "Unknown";
    BOOL v4 = 1LL;
    uint64_t v6 = a1;
    int v7 = 1;
  }

  reportLegacyStatus((uint64_t)v5, v6, v7);
  return v4;
}

uint64_t SOSPeerInfoGetClass(uint64_t a1)
{
  if (SOSPeerInfoIsCloudIdentity(a1)) {
    return 1LL;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ModelName");
  if (result)
  {
    BOOL v3 = (const __CFString *)result;
    if (CFStringHasPrefix((CFStringRef)result, @"Mac") || CFStringHasPrefix(v3, @"iMac"))
    {
      return 3LL;
    }

    else if (CFStringHasPrefix(v3, @"iPhone") {
           || CFStringHasPrefix(v3, @"iPad")
    }
           || CFStringHasPrefix(v3, @"iPod"))
    {
      return 2LL;
    }

    else if (CFStringHasPrefix(v3, @"Watch"))
    {
      return 4LL;
    }

    else if (CFStringHasPrefix(v3, @"AppleTV"))
    {
      return 5LL;
    }

    else
    {
      return 6LL;
    }
  }

  return result;
}

uint64_t majorVersion(const __CFString *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  secLogObjForScope("SOSMonitorMode");
  CFMutableStringRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v3)
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "Parsing :%@:", buf, 0xCu);
    }

    memset(buf, 170, 20);
    if (CFStringGetCString(a1, (char *)buf, 20LL, 0x600u))
    {
      int v4 = (char)buf[0];
      if (((char)buf[0] - 48) > 9)
      {
        uint64_t v5 = 0LL;
      }

      else
      {
        LODWORD(v5) = 0;
        uint64_t v6 = &buf[1];
        do
        {
          uint64_t v5 = (v4 + 10 * v5 - 48);
          int v7 = (char)*v6++;
          int v4 = v7;
        }

        while ((v7 - 48) < 0xA);
      }

      secLogObjForScope("SOSMonitorMode");
      __int128 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v10[0] = 67109120;
        v10[1] = v5;
        _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "majorVersion: %d", (uint8_t *)v10, 8u);
      }
    }

    else
    {
      secLogObjForScope("SOSMonitorMode");
      __int128 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "No OS CString to parse", (uint8_t *)v10, 2u);
      }

      uint64_t v5 = 0xFFFFFFFFLL;
    }
  }

  else
  {
    if (v3)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "No OS String to parse", buf, 2u);
    }

    return 0xFFFFFFFFLL;
  }

  return v5;
}

void reportLegacyStatus(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  secLogObjForScope("SOSMonitorMode");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = "Not Legacy";
    int v8 = 136315650;
    uint64_t v9 = a1;
    if (a3) {
      int v7 = "Legacy";
    }
    __int16 v10 = 2112;
    uint64_t v11 = a2;
    __int16 v12 = 2080;
    CFStringRef v13 = v7;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "%s Peer %@ is %s", (uint8_t *)&v8, 0x20u);
  }
}

BOOL SOSPeerInfoIsCloudIdentity(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(const __CFDictionary **)(a1 + 16)) != 0LL)
  {
    Value = CFDictionaryGetValue(v1, @"CloudIdentity");
    BOOL v3 = (const void *)*MEMORY[0x189604DE8];
    if (Value) {
      BOOL v4 = v3 == 0LL;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4) {
      return CFEqual(Value, v3) != 0;
    }
  }

  else
  {
    Value = 0LL;
    BOOL v3 = (const void *)*MEMORY[0x189604DE8];
  }

  return Value == v3;
}

BOOL sospeer_application_hash(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v16[1] = *MEMORY[0x1895F89C0];
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"ApplicationDate");
  if (!Value) {
    return 0LL;
  }
  int v7 = Value;
  CFTypeID v8 = CFGetTypeID(Value);
  CFTypeID TypeID = CFDataGetTypeID();
  if (v8 != TypeID) {
    return 0LL;
  }
  MEMORY[0x1895F8858](TypeID);
  __int16 v12 = (char *)v16 - v11;
  if (v13 >= 8) {
    memset((char *)v16 - v11, 170, v10);
  }
  ccdigest_init();
  CFDataGetLength(v7);
  CFDataGetBytePtr(v7);
  ccdigest_update();
  BOOL updated = SOSPeerInfoUpdateDigestWithPublicKeyBytes(a1, a2, (uint64_t)v12, 0LL);
  if (updated) {
    (*(void (**)(uint64_t, char *, uint64_t))(a2 + 56))(a2, v12, a3);
  }
  return updated;
}

BOOL SOSPeerInfoUpdateDigestWithPublicKeyBytes(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"PublicSigningKey");
  uint64_t v6 = Value;
  if (Value)
  {
    CFDataGetLength(Value);
    CFDataGetBytePtr(v6);
    ccdigest_update();
  }

  else
  {
    SOSCreateErrorWithFormat(1025LL, 0LL, a4, 0LL, @"Digest failed – no public key");
  }

  return v6 != 0LL;
}

CFDictionaryRef SOSPeerInfoIsRetirementTicket(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)*((void *)result + 2);
    if (result) {
      return CFDictionaryGetValue(result, @"RetirementDate" != 0LL);
    }
  }

  return result;
}

const void *SOSPeerInfoGetPeerName(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ComputerName");
}

const void *SOSPeerInfoGetPeerDeviceType(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), @"ModelName");
}

uint64_t SOSPeerInfoGetSPID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

void SOSPeerInfoLogState(const char *a1, uint64_t a2, __SecKey *a3, const void *a4, int a5)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    CFStringRef v6 = SOSPeerInfoCopyStateString(a2, a3, a4, a5);
    secLogObjForScope(a1);
    int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      CFStringRef v9 = v6;
      _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "PI:    %@", (uint8_t *)&v8, 0xCu);
    }

    if (v6) {
      CFRelease(v6);
    }
  }

uint64_t SOSPeerInfoCopyPeerGestalt(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t SOSPeerGetGestalt(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

const void *SOSPeerInfoLookupGestaltValue(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
}

BOOL SOSPeerInfoPeerIDEqual(uint64_t a1, CFTypeRef cf1)
{
  if (a1)
  {
    CFTypeRef v2 = *(CFTypeRef *)(a1 + 40);
    if (cf1 && v2) {
      return CFEqual(cf1, v2) != 0;
    }
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  return v2 == cf1;
}

uint64_t SOSPeerInfoGetVersion(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t SOSPeerInfoCopyAsApplication( uint64_t a1, __SecKey *a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t Copy = SOSPeerInfoCreateCopy((const __CFAllocator *)*MEMORY[0x189604DB0], a1, a4, (uint64_t)a4, a5, a6, a7, a8);
  __int16 v12 = (size_t *)ccsha256_di();
  MEMORY[0x1895F8858](v12);
  uint64_t v14 = &buf[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  if (v13) {
    memset(&buf[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL)], 170, v13);
  }
  CFDataRef Date = sosCreateDate();
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Copy + 16), @"ApplicationDate", Date);
  if (Date) {
    CFRelease(Date);
  }
  if (!sospeer_application_hash(Copy, (uint64_t)v12, (uint64_t)v14))
  {
    uint64_t v22 = @"Failed to create hash for peer applicant";
LABEL_16:
    SOSCreateErrorWithFormat(1040LL, 0LL, a4, 0LL, @"%@", v22);
LABEL_17:
    CFRelease((CFTypeRef)Copy);
    return 0LL;
  }

  CFDataRef v16 = sosCopySignedHash(a2, v12, v14);
  if (!v16)
  {
    uint64_t v22 = @"Failed to sign public key hash for peer";
    goto LABEL_16;
  }

  CFDataRef v17 = v16;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Copy + 16), @"ApplicationUsig", v16);
  CFStringRef v18 = SOSCopyIDOfKey((uint64_t)a2, a4);
  *(void *)(Copy + 64) = v18;
  if (v18)
  {
    *(_BYTE *)(Copy + 72) = 1;
  }

  else
  {
    secLogObjForScope("PICache");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEFAULT, "failed to get userKeyID", buf, 2u);
    }
  }

  char v20 = SOSPeerInfoSign(a3, Copy, a4);
  CFRelease(v17);
  if ((v20 & 1) == 0) {
    goto LABEL_17;
  }
  return Copy;
}

CFDataRef sosCreateDate()
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v1 = CFDateCreate(0LL, Current);
  uint64_t v2 = der_sizeof_date();
  uint64_t v3 = MEMORY[0x1895F8858](v2);
  uint64_t v10 = (const UInt8 *)&v12[-v9];
  if (v3) {
    memset(&v12[-v9], 170, v2);
  }
  der_encode_date((uint64_t)v1, (uint64_t)v10, (unint64_t)&v10[v2], v4, v5, v6, v7, v8, v12[0]);
  if (v1) {
    CFRelease(v1);
  }
  return CFDataCreate(0LL, v10, v2);
}

unint64_t SOSPeerInfoGetRetirementDate(uint64_t a1)
{
  return sosPeerInfoGetDate(a1, @"RetirementDate");
}

CFDictionaryRef SOSPeerGestaltGetName(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"ComputerName");
    if (result)
    {
      CFDateRef v1 = result;
      CFTypeID v2 = CFGetTypeID(result);
      if (v2 == CFStringGetTypeID()) {
        return v1;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

CFDictionaryRef SOSPeerGestaltGetAnswer(CFDictionaryRef theDict, const void *key)
{
  if (theDict) {
    return (CFDictionaryRef)CFDictionaryGetValue(theDict, key);
  }
  return theDict;
}

CFMutableDictionaryRef *SOSPeerInfoCreateRetirementTicket( const __CFAllocator *a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy = (CFMutableDictionaryRef *)SOSPeerInfoCreateCopy(a1, a3, a4, (uint64_t)a4, a5, a6, a7, a8);
  if (Copy)
  {
    CFDataRef Date = sosCreateDate();
    CFDictionaryAddValue(Copy[2], @"RetirementDate", Date);
    if (Date) {
      CFRelease(Date);
    }
    if ((SOSPeerInfoSign(a2, (uint64_t)Copy, a4) & 1) == 0)
    {
      CFRelease(Copy);
      return 0LL;
    }
  }

  return Copy;
}

uint64_t SOSPeerInfoInspectRetirementTicket(uint64_t a1, CFTypeRef *a2)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = CFDateCreate(0LL, Current);
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"RetirementDate");
  if (!Value)
  {
    SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"%@", @"PeerInfo doesn't have a retirement date");
LABEL_11:
    CFCFDataRef Date = 0LL;
    goto LABEL_15;
  }

  CFCFDataRef Date = (const __CFDate *)sosCreateCFDate(Value);
  if (CFDate)
  {
    if (CFDateCompare(v5, CFDate, 0LL) == kCFCompareGreaterThan)
    {
      uint64_t v8 = *(void *)(a1 + 40);
      if (!v5) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }

    uint64_t v10 = @"Retirement date is after current date";
  }

  else
  {
    uint64_t v10 = @"Peer is not retired";
  }

  SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"%@", v10);
LABEL_15:
  uint64_t v8 = 0LL;
  if (v5) {
LABEL_6:
  }
    CFRelease(v5);
LABEL_7:
  if (CFDate) {
    CFRelease(CFDate);
  }
  return v8;
}

BOOL SOSPeerInfoRetireRetirementTicket(unint64_t a1, uint64_t a2)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = CFDateCreate(0LL, Current);
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), @"RetirementDate");
  CFCFDataRef Date = (const __CFDate *)sosCreateCFDate(Value);
  TimeIntervalSinceCFDataRef Date = CFDateGetTimeIntervalSinceDate(v5, CFDate);
  if (v5) {
    CFRelease(v5);
  }
  if (CFDate) {
    CFRelease(CFDate);
  }
  return TimeIntervalSinceDate > (double)a1;
}

uint64_t SOSPeerInfoUpgradeSignatures(int a1, SecKeyRef key, __SecKey *a3, uint64_t a4, CFTypeRef *a5)
{
  SecKeyRef v9 = SecKeyCopyPublicKey(key);
  uint64_t v14 = SOSPeerInfoCopyAsApplication(a4, key, a3, a5, v10, v11, v12, v13);
  if (v9) {
    CFRelease(v9);
  }
  return v14;
}

uint64_t SOSPeerInfoSetOctagonKeysInDescription(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFTypeRef cf = 0LL;
  xpc_object_t value = 0LL;
  int v7 = SecKeyCopyPublicBytes(a2, (uint64_t)&value);
  int v8 = SecKeyCopyPublicBytes(a3, (uint64_t)&cf);
  if (v7)
  {
    SecError(v7, a4, @"failed to copy signing public key bytes", cf);
  }

  else
  {
    if (!v8)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"OctagonPublicSigningKey", value);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"OctagonPublicEncryptionKey", cf);
      uint64_t v9 = 1LL;
      goto LABEL_4;
    }

    SecError(v8, a4, @"failed to copy encryption public key bytes", cf);
  }

  uint64_t v9 = 0LL;
LABEL_4:
  uint64_t v10 = value;
  if (value)
  {
    xpc_object_t value = 0LL;
    CFRelease(v10);
  }

  CFTypeRef v11 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v11);
  }

  return v9;
}

const void *SOSPeerInfoSetOctagonKeys( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __SecKey *a5, __CFString **a6)
{
  uint64_t v19 = 0LL;
  CFTypeRef cf = 0LL;
  int v11 = SecKeyCopyPublicBytes(a3, (uint64_t)&v19);
  int v12 = SecKeyCopyPublicBytes(a4, (uint64_t)&cf);
  if (v11)
  {
    SecError(v11, a6, @"failed to copy signing public key bytes");
  }

  else
  {
    if (!v12)
    {
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 3221225472LL;
      void v17[2] = __SOSPeerInfoSetBothOctagonKeys_block_invoke;
      void v17[3] = &__block_descriptor_64_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
      v17[4] = v19;
      void v17[5] = @"OctagonPublicSigningKey";
      void v17[6] = cf;
      v17[7] = @"OctagonPublicEncryptionKey";
      uint64_t v13 = SOSPeerInfoCopyWithModification(a1, a2, a5, (CFTypeRef *)a6, v17);
      goto LABEL_4;
    }

    SecError(v12, a6, @"failed to copy encryption public key bytes");
  }

  uint64_t v13 = 0LL;
LABEL_4:
  uint64_t v14 = v19;
  if (v19)
  {
    uint64_t v19 = 0LL;
    CFRelease(v14);
  }

  CFTypeRef v15 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v15);
  }

  return v13;
}

uint64_t __SOSPeerInfoSetBothOctagonKeys_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  if (a2
    && (uint64_t v5 = *(__CFDictionary **)(a2 + 16)) != 0LL
    && *(void *)(a1 + 32)
    && (uint64_t v6 = *(const void **)(a1 + 40)) != 0LL
    && *(void *)(a1 + 48)
    && *(void *)(a1 + 56))
  {
    CFDictionarySetValue(v5, v6, *(const void **)(a1 + 32));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 16), *(const void **)(a1 + 56), *(const void **)(a1 + 48));
  }

  else
  {
    SecError(-50, a3, @"Bad key bytes or dictionary key");
  }

  return 1LL;
}

const void *SOSPeerInfoSetOctagonSigningKey( const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  return SOSPeerInfoSetOctagonKey(a1, a2, (uint64_t)@"OctagonPublicSigningKey", a3, a4, a5);
}

const void *SOSPeerInfoSetOctagonKey( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __SecKey *a5, __CFString **a6)
{
  CFTypeRef cf = 0LL;
  int v11 = SecKeyCopyPublicBytes(a4, (uint64_t)&cf);
  if (v11)
  {
    SecError(v11, a6, @"failed to copy public key bytes");
    int v12 = 0LL;
  }

  else
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    void v15[2] = __SOSPeerInfoSetOctagonKey_block_invoke;
    void v15[3] = &__block_descriptor_48_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
    v15[4] = cf;
    void v15[5] = a3;
    int v12 = SOSPeerInfoCopyWithModification(a1, a2, a5, (CFTypeRef *)a6, v15);
  }

  CFTypeRef v13 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v13);
  }

  return v12;
}

uint64_t __SOSPeerInfoSetOctagonKey_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  if (a2
    && (uint64_t v4 = *(__CFDictionary **)(a2 + 16)) != 0LL
    && *(void *)(a1 + 32)
    && (uint64_t v5 = *(const void **)(a1 + 40)) != 0LL)
  {
    CFDictionarySetValue(v4, v5, *(const void **)(a1 + 32));
  }

  else
  {
    SecError(-50, a3, @"Bad key bytes or dictionary key");
  }

  return 1LL;
}

const void *SOSPeerInfoSetOctagonEncryptionKey( const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  return SOSPeerInfoSetOctagonKey(a1, a2, (uint64_t)@"OctagonPublicEncryptionKey", a3, a4, a5);
}

CFStringRef SOSPeerInfoCopyDeviceID()
{
  return @"not implemented";
}

uint64_t SOSCloudCopyKVSState()
{
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  uint64_t v6 = 0LL;
  if (SOSCloudCopyKVSState_onceToken != -1) {
    dispatch_once(&SOSCloudCopyKVSState_onceToken, &__block_literal_global_6106);
  }
  if (SOSCloudCopyKVSState_processQueue)
  {
    CFIndex v0 = dispatch_semaphore_create(0LL);
    SOSCloudKeychainGetAllObjectsFromCloud();
    dispatch_semaphore_wait(v0, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v0);
    uint64_t v1 = v4[3];
  }

  else
  {
    uint64_t v1 = 0LL;
  }

  _Block_object_dispose(&v3, 8);
  return v1;
}

uint64_t __SOSCloudCopyKVSState_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v3) {
    CFRetain(v3);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

uint64_t SOSCloudKeychainGetAllObjectsFromCloud()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 32))();
  }
  return result;
}

void __SOSCloudTransportDefaultTransport_block_invoke()
{
  if (!defaultTransport)
  {
    CFIndex v0 = calloc(1uLL, 0x98uLL);
    void *v0 = SOSCloudTransportPut;
    v0[1] = SOSCloudTransportUpdateKeys;
    v0[3] = SOSCloudTransportGet;
    v0[4] = SOSCloudTransportGetAll;
    v0[5] = SOSCloudTransportSync;
    v0[6] = SOSCloudTransportSyncAndWait;
    v0[7] = SOSCloudTransportClearAll;
    v0[9] = SOSCloudTransportHasPendingKey;
    v0[10] = SOSCloudTransportRequestSyncWithPeers;
    v0[11] = SOSCloudTransportRequestEnsurePeerRegistration;
    v0[12] = SOSCloudTransportRequestPerfCounters;
    v0[13] = SOSCloudTransportFlush;
    v0[15] = SOSCloudTransportRemoveKeys;
    v0[14] = _Block_copy(&__block_literal_global_22_6111);
    uint64_t v1 = dispatch_queue_create("com.apple.security.cloudkeychainproxy3", 0LL);
    uint64_t v2 = MEMORY[0x1895F87A8];
    v0[18] = v1;
    block[0] = v2;
    block[1] = 0x40000000LL;
    block[2] = __SOSXPCCloudTransportInit_block_invoke;
    block[3] = &__block_descriptor_tmp_25_6112;
    block[4] = v0;
    dispatch_sync(v1, block);
    int out_token = -1431655766;
    uint64_t v3 = (dispatch_queue_s *)v0[18];
    handler[0] = v2;
    handler[1] = 0x40000000LL;
    handler[2] = __SOSXPCCloudTransportInit_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_28_6113;
    handler[4] = v0;
    notify_register_dispatch("com.apple.system.loginwindow.desktopUp", &out_token, v3, handler);
    defaultTransport = (uint64_t)v0;
  }

void SOSCloudTransportPut(uint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4)
{
  if (a2)
  {
    xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_uint64(v7, "version", 1uLL);
    xpc_dictionary_set_string(v7, "operation", "PUTDictionary");
    int v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v8)
    {
      uint64_t v9 = v8;
      xpc_dictionary_set_value(v7, "value", v8);
      xpc_release(v9);
      talkWithKVS(a1, (uint64_t)v7, a3, a4);
      xpc_release(v7);
      return;
    }

    CFIndex v10 = 2LL;
  }

  else
  {
    CFIndex v10 = 1LL;
  }

  CFErrorRef v11 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"com.apple.security.sos.transport.error", v10, 0LL);
  if (a4) {
    (*(void (**)(uint64_t, void, CFErrorRef))(a4 + 16))(a4, 0LL, v11);
  }
  if (v11) {
    CFRelease(v11);
  }
}

void SOSCloudTransportUpdateKeys(uint64_t a1, uint64_t a2, uint64_t a3, dispatch_queue_s *a4, uint64_t a5)
{
  xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
  SecXPCDictionarySetCFObject(v10, "AllKeys", a2);
  xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v11, "version", 1uLL);
  xpc_dictionary_set_string(v11, "operation", "RegisterKeys");
  xpc_dictionary_set_value(v11, "value", v10);
  SecXPCDictionarySetCFObject(v11, "AcctUUID", a3);
  talkWithKVS(a1, (uint64_t)v11, a4, a5);
  xpc_release(v11);
  xpc_release(v10);
}

void SOSCloudTransportGet(uint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
  if (a2)
  {
    uint64_t v9 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v9)
    {
      xpc_object_t v10 = v9;
      xpc_dictionary_set_value(v8, "KeysToGet", v9);
LABEL_5:
      xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v11, "version", 1uLL);
      xpc_dictionary_set_string(v11, "operation", "GETv2");
      xpc_dictionary_set_value(v11, "value", v8);
      talkWithKVS(a1, (uint64_t)v11, a3, a4);
      xpc_release(v10);
      xpc_release(v8);
      xpc_release(v11);
      return;
    }
  }

  else
  {
    xpc_object_t v10 = xpc_null_create();
    if (v10) {
      goto LABEL_5;
    }
  }

  CFErrorRef v12 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"com.apple.security.sos.transport.error", 1LL, 0LL);
  if (v8) {
    xpc_release(v8);
  }
  if (a4) {
    (*(void (**)(uint64_t, void, CFErrorRef))(a4 + 16))(a4, 0LL, v12);
  }
  if (v12) {
    CFRelease(v12);
  }
}

void SOSCloudTransportGetAll(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
}

void SOSCloudTransportSync(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "Synchronize");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportSyncAndWait(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  xpc_object_t v6 = (os_log_s *)secLogObjForScope("sync");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315394;
    uint64_t v9 = "EFRESH";
    __int16 v10 = 2080;
    xpc_object_t v11 = "SynchronizeAndWait";
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "%s XPC request to CKD: %s", (uint8_t *)&v8, 0x16u);
  }

  xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v7, "version", 1uLL);
  xpc_dictionary_set_string(v7, "operation", "SynchronizeAndWait");
  talkWithKVS(a1, (uint64_t)v7, a2, a3);
  xpc_release(v7);
}

void SOSCloudTransportClearAll(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "ClearStore");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRequestSyncWithPeers( uint64_t a1, uint64_t a2, uint64_t a3, dispatch_queue_s *a4, uint64_t a5)
{
  xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v10, "version", 1uLL);
  xpc_dictionary_set_string(v10, "operation", "requestSyncWithPeers");
  SecXPCDictionarySetCFObject(v10, "peerIDList", a2);
  SecXPCDictionarySetCFObject(v10, "backupPeerIDList", a3);
  talkWithKVS(a1, (uint64_t)v10, a4, a5);
  xpc_release(v10);
}

BOOL SOSCloudTransportHasPendingKey(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v12 = 0LL;
  CFTypeRef v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "hasPendingKey");
  SecXPCDictionarySetCFObject(v6, "key", a2);
  xpc_object_t v7 = dispatch_semaphore_create(0LL);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  void v11[2] = __SOSCloudTransportHasPendingKey_block_invoke;
  unint64_t v11[3] = &unk_18966C218;
  v11[4] = &v12;
  void v11[5] = v7;
  if (messageToProxy(a1, (uint64_t)v6, a3, (uint64_t)global_queue, (uint64_t)v11))
  {
    dispatch_semaphore_wait(v7, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v7);
    BOOL v9 = *((_BYTE *)v13 + 24) != 0;
  }

  else
  {
    dispatch_release(v7);
    BOOL v9 = 0LL;
  }

  _Block_object_dispose(&v12, 8);
  return v9;
}

void SOSCloudTransportRequestEnsurePeerRegistration(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "requestEnsurePeerRegistration");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRequestPerfCounters(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "PerfCounters");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportFlush(uint64_t a1, dispatch_queue_s *a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "Flush");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRemoveKeys(uint64_t a1, uint64_t a2, uint64_t a3, dispatch_queue_s *a4, uint64_t a5)
{
  xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v10, "version", 1uLL);
  xpc_dictionary_set_string(v10, "operation", "RemoveKeys");
  SecXPCDictionarySetCFObject(v10, "AcctUUID", a3);
  SecXPCDictionarySetCFObject(v10, "value", a2);
  talkWithKVS(a1, (uint64_t)v10, a4, a5);
  xpc_release(v10);
}

void __SOSXPCCloudTransportInit_block_invoke(uint64_t a1)
{
}

void __SOSXPCCloudTransportInit_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)secLogObjForScope("sync");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "CKP Transport: desktopUp happened, reestablishing xpc connections",  v3,  2u);
  }

  teardownServiceConnection(*(void *)(a1 + 32));
}

void teardownServiceConnection(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)secLogObjForScope("sync");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "CKP Transport: tearing down xpc connection", v4, 2u);
  }

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 144));
  uint64_t v3 = *(void **)(a1 + 136);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(a1 + 136) = 0LL;
  }

void setupServiceConnection(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)secLogObjForScope("sync");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "CKP Transport: setting up xpc connection", buf, 2u);
  }

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 144));
  mach_service = xpc_connection_create_mach_service( "com.apple.security.cloudkeychainproxy3",  *(dispatch_queue_t *)(a1 + 144),  0LL);
  uint64_t v4 = MEMORY[0x1895F87A8];
  *(void *)(a1 + 136) = mach_service;
  handler[0] = v4;
  handler[1] = 0x40000000LL;
  handler[2] = __setupServiceConnection_block_invoke;
  handler[3] = &__block_descriptor_tmp_17_6120;
  handler[4] = a1;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_activate(*(xpc_connection_t *)(a1 + 136));
}

void __setupServiceConnection_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 == MEMORY[0x1895F91A0])
  {
    uint64_t v10 = v2;
    uint64_t v11 = v3;
    uint64_t v5 = (os_log_s *)secLogObjForScope("sync");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v9 = 0;
      _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "CKP Transport: xpc connection invalid. Will tear down connection.",  v9,  2u);
    }

    uint64_t v6 = *(void *)(a1 + 32);
    xpc_object_t v7 = *(dispatch_queue_s **)(v6 + 144);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __setupServiceConnection_block_invoke_15;
    block[3] = &__block_descriptor_tmp_16_6123;
    block[4] = v6;
    dispatch_async(v7, block);
  }

void __setupServiceConnection_block_invoke_15(uint64_t a1)
{
}

uint64_t __SOSCloudTransportCreateXPCTransport_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    uint64_t v6 = a2;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "Calling default itemsChangedBlock - fatal: %@",  (uint8_t *)&v5,  0xCu);
  }

  return 0LL;
}

void SecXPCDictionarySetCFObject(void *a1, const char *a2, uint64_t a3)
{
  if (a3) {
    int v5 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  }
  else {
    int v5 = xpc_null_create();
  }
  uint64_t v6 = v5;
  xpc_dictionary_set_value(a1, a2, v5);
  xpc_release(v6);
}

void talkWithKVS(uint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((OctagonIsSOSFeatureEnabled() & 1) != 0)
  {
    uint64_t v14 = 0LL;
    dispatch_retain(a3);
    uint64_t v8 = *(void *)(a1 + 144);
    uint64_t v9 = MEMORY[0x1895F87A8];
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 0x40000000LL;
    void v13[2] = __talkWithKVS_block_invoke;
    void v13[3] = &unk_18966C0E0;
    v13[4] = a4;
    v13[5] = a3;
    if (!messageToProxy(a1, a2, &v14, v8, (uint64_t)v13))
    {
      uint64_t v10 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v16 = v14;
        _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "talkWithKVS error: %@", buf, 0xCu);
      }

      v12[0] = v9;
      v12[1] = 0x40000000LL;
      void v12[2] = __talkWithKVS_block_invoke_11;
      v12[3] = &unk_18966C108;
      _OWORD v12[4] = a4;
      v12[5] = v14;
      void v12[6] = a3;
      dispatch_async(a3, v12);
    }
  }

  else if (a4)
  {
    CFErrorRef v11 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"com.apple.security.sos.transport.error", 9LL, 0LL);
    (*(void (**)(uint64_t, void, CFErrorRef))(a4 + 16))(a4, 0LL, v11);
    if (v11) {
      CFRelease(v11);
    }
  }

void __talkWithKVS_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (MEMORY[0x186E0087C](a2) == MEMORY[0x1895F9250])
  {
    if (xpc_dictionary_get_value(a2, "value"))
    {
      uint64_t v6 = _CFXPCCreateCFObjectFromXPCObject();
    }

    else
    {
      uint64_t v7 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "missing value reply", buf, 2u);
      }

      uint64_t v6 = 0LL;
    }

    xpc_object_t value = xpc_dictionary_get_value(a2, "error");
    if (value) {
      CFErrorRef CFErrorWithXPCObject = SecCreateCFErrorWithXPCObject(value);
    }
    else {
      CFErrorRef CFErrorWithXPCObject = 0LL;
    }
  }

  else
  {
    CFErrorRef CFErrorWithXPCObject = CFErrorCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"com.apple.security.sos.transport.error",  8LL,  0LL);
    int v5 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v12 = a2;
      __int16 v13 = 2112;
      CFErrorRef v14 = CFErrorWithXPCObject;
      _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Odd reply from CloudKeychainProxy: %@: %@", buf, 0x16u);
    }

    uint64_t v6 = 0LL;
  }

  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  void v10[2] = __talkWithKVS_block_invoke_7;
  unint64_t v10[3] = &unk_18966C0B8;
  uint64_t v9 = *(dispatch_queue_s **)(a1 + 40);
  _DWORD v10[4] = *(void *)(a1 + 32);
  void v10[5] = v6;
  v10[6] = CFErrorWithXPCObject;
  void v10[7] = v9;
  dispatch_async(v9, v10);
}

BOOL messageToProxy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = 0LL;
  CFErrorRef v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  uint64_t v6 = *(dispatch_queue_s **)(a1 + 144);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __messageToProxy_block_invoke;
  block[3] = &unk_18966C130;
  void block[6] = a1;
  block[7] = a2;
  void block[8] = a4;
  block[4] = a5;
  void block[5] = &v10;
  dispatch_sync(v6, block);
  uint64_t v7 = (const void *)v11[3];
  if (v7)
  {
    if (a3 && !*a3) {
      *a3 = v7;
    }
    else {
      CFRelease(v7);
    }
  }

  _Block_object_dispose(&v10, 8);
  return v7 == 0LL;
}

void __talkWithKVS_block_invoke_11(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, 0LL, *(void *)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

void __messageToProxy_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(_xpc_connection_s **)(v2 + 136);
  if ((v3 || (setupServiceConnection(v2), (uint64_t v3 = *(_xpc_connection_s **)(*(void *)(a1 + 48) + 136LL)) != 0LL))
    && (uint64_t v4 = *(void **)(a1 + 56)) != 0LL)
  {
    xpc_connection_send_message_with_reply(v3, v4, *(dispatch_queue_t *)(a1 + 64), *(xpc_handler_t *)(a1 + 32));
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = CFErrorCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"com.apple.security.sos.transport.error",  6LL,  0LL);
  }

void __talkWithKVS_block_invoke_7(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *(void *)(a1 + 40), *(void *)(a1 + 48));
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  if (*(void *)(a1 + 48))
  {
    uint64_t v4 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 48);
      int v7 = 138412290;
      uint64_t v8 = v5;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "callback error: %@", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v6 = *(const void **)(a1 + 48);
    if (v6) {
      CFRelease(v6);
    }
  }

  dispatch_release(*(dispatch_object_t *)(a1 + 56));
}

uint64_t __SOSCloudTransportHasPendingKey_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  BOOL v3 = xpc_dictionary_get_BOOL(xdict, "value");
  uint64_t v4 = *(dispatch_semaphore_s **)(a1 + 40);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v3;
  return dispatch_semaphore_signal(v4);
}

dispatch_queue_t __SOSCloudCopyKVSState_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("KVSStateCapture", 0LL);
  SOSCloudCopyKVSState_processQueue = (uint64_t)result;
  return result;
}

uint64_t SOSCloudTransportSetDefaultTransport(uint64_t result)
{
  defaultTransport = result;
  return result;
}

void SOSCloudKeychainSetItemsChangedBlock(const void *a1)
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t v2 = defaultTransport;
  if (*(const void **)(defaultTransport + 112) != a1)
  {
    BOOL v3 = (os_log_s *)secLogObjForScope("sync");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "Changing itemsChangedBlock", v5, 2u);
    }

    uint64_t v4 = *(const void **)(v2 + 112);
    if (v4) {
      _Block_release(v4);
    }
    *(void *)(v2 + TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112) = _Block_copy(a1);
  }

uint64_t SOSCloudKeychainPutObjectsInCloud()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))defaultTransport)();
  }
  return result;
}

uint64_t SOSCloudKeychainUpdateKeys()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 8))();
  }
  return result;
}

uint64_t SOSCloudKeychainRemoveKeys()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 120))();
  }
  return result;
}

uint64_t SOSCloudKeychainHandleUpdateMessage(uint64_t a1)
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = *(void *)(defaultTransport + 112);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, a1);
  }
  return result;
}

uint64_t SOSCloudKeychainGetObjectsFromCloud()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 24))();
  }
  return result;
}

uint64_t SOSCloudKeychainSynchronizeAndWait()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 48))();
  }
  return result;
}

uint64_t SOSCloudKeychainSynchronize()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 40))();
  }
  return result;
}

void SOSCloudKeychainClearAll(uint64_t a1, uint64_t a2)
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t v4 = defaultTransport;
  uint64_t v5 = (os_log_s *)secLogObjForScope("circleOps");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainClearAll called", v6, 2u);
  }

  if (v4) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 56))(v4, a1, a2);
  }
}

uint64_t SOSCloudKeychainRequestSyncWithPeers()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 80))();
  }
  return result;
}

uint64_t SOSCloudKeychainHasPendingKey()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 72))();
  }
  return result;
}

uint64_t SOSCloudKeychainRequestEnsurePeerRegistration()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 88))();
  }
  return result;
}

uint64_t SOSCloudKeychainRequestPerfCounters()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 96))();
  }
  return result;
}

uint64_t SOSCloudKeychainFlush()
{
  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1) {
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_6108);
  }
  uint64_t result = defaultTransport;
  if (defaultTransport) {
    return (*(uint64_t (**)(void))(defaultTransport + 104))();
  }
  return result;
}

__CFData *SOSPiggyBackBlobCopyEncodedData( const __CFNumber *a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFTypeRef cf = 0LL;
  if (SecKeyCopyPublicBytes(a2, (uint64_t)&cf))
  {
    SOSCreateErrorWithFormat(1034LL, 0LL, a4, 0LL, @"%@", @"Failed to export public bytes");
LABEL_3:
    CFIndex v9 = 0LL;
    goto LABEL_10;
  }

  if (!der_sizeof_number(a1, a4) || !der_sizeof_data_or_null((const __CFData *)cf) || !der_sizeof_data_or_null(a3))
  {
    SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a4,  v10,  @"don't know how to encode",  v11,  v12,  v16);
    CFTypeRef v15 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v15);
    }

    goto LABEL_3;
  }

  CFTypeRef v13 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v13);
  }

  CFIndex v9 = ccder_sizeof();
LABEL_10:
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  void v17[2] = __SOSPiggyBackBlobCopyEncodedData_block_invoke;
  void v17[3] = &__block_descriptor_64_e11__24__0Q8_16l;
  v17[4] = a1;
  void v17[5] = a2;
  void v17[6] = a3;
  v17[7] = a4;
  return CFDataCreateWithDER(v8, v9, v17);
}

uint64_t __SOSPiggyBackBlobCopyEncodedData_block_invoke(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (const __CFNumber *)a1[4];
  uint64_t v4 = a1[5];
  int v7 = (const __CFData *)a1[6];
  uint64_t v6 = (CFTypeRef *)a1[7];
  CFTypeRef cf = 0LL;
  if (SecKeyCopyPublicBytes(v4, (uint64_t)&cf))
  {
    SOSCreateErrorWithFormat(1034LL, 0LL, v6, 0LL, @"%@", @"Failed to export public bytes");
    return 0LL;
  }

  else
  {
    CFIndex v9 = (const __CFData *)cf;
    der_encode_data_or_null(v7, v6);
    uint64_t v10 = der_encode_data_or_null(v9, v6);
    der_encode_number(v5, v6, a3, v10);
    uint64_t v8 = ccder_encode_constructed_tl();
    CFTypeRef v11 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v11);
    }
  }

  return v8;
}

uint64_t SOSPiggyBackAddToKeychain(void *a1, void *a2)
{
  id v3 = a1;
  [a2 enumerateObjectsUsingBlock:&__block_literal_global_6159];
  [v3 enumerateObjectsUsingBlock:&__block_literal_global_11];

  return 1LL;
}

void __SOSPiggyBackAddToKeychain_block_invoke_9(uint64_t a1, void *a2)
{
  v30[2] = *MEMORY[0x1895F89C0];
  uint64_t v2 = a2;
  v29[0] = @"kcls";
  v29[1] = @"type";
  v30[0] = @"1";
  v30[1] = @"73";
  [MEMORY[0x189603F68] dictionaryWithObjects:v30 forKeys:v29 count:2];
  id v3 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = SecKeyCreateWithData(v2, v3, 0LL);
  if (!v4)
  {
    secLogObjForScope("piggy");
    char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEFAULT, "privKey failed to be created", buf, 2u);
    }

    goto LABEL_25;
  }

  uint64_t v5 = v4;
  SecKeyRef v6 = SecKeyCopyPublicKey(v4);
  if (!v6)
  {
    secLogObjForScope("piggy");
    CFRange v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v21, OS_LOG_TYPE_DEFAULT, "public key failed to be created", buf, 2u);
    }

    CFRelease(v5);
LABEL_25:
    CFErrorRef v14 = 0LL;
    goto LABEL_16;
  }

  SecKeyRef v7 = v6;
  uint64_t v8 = SecKeyCopyPublicKeyHash(v6);
  if (v8)
  {
    uint64_t v22 = v3;
    CFStringRef v9 = SOSCopyIDOfKey((uint64_t)v7, 0LL);
    v27[0] = @"class";
    v27[1] = @"nleg";
    v28[0] = @"keys";
    v28[1] = MEMORY[0x189604A88];
    void v27[2] = @"agrp";
    v27[3] = @"klbl";
    void v28[2] = @"com.apple.security.sos";
    v28[3] = v8;
    void v27[4] = @"labl";
    [NSString stringWithFormat:@"Cloud Identity-piggy-%@", v9];
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v11 = *MEMORY[0x189604DE8];
    v28[4] = v10;
    v28[5] = v11;
    v27[5] = @"sync";
    v27[6] = @"u_Tomb";
    v27[7] = @"v_Data";
    v28[6] = v11;
    v28[7] = v2;
    uint64_t v12 = v2;
    [MEMORY[0x189603F68] dictionaryWithObjects:v28 forKeys:v27 count:8];
    CFTypeRef v13 = (void *)objc_claimAutoreleasedReturnValue();
    CFErrorRef v14 = (const __CFDictionary *)[v13 mutableCopy];

    OSStatus v15 = SecItemAdd(v14, 0LL);
    if (v15 == -25299)
    {
      CFTypeRef v25 = @"v_Data";
      uint64_t v26 = v12;
      [MEMORY[0x189603F68] dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      char v16 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = (const __CFDictionary *)[v16 mutableCopy];

      -[__CFDictionary setObject:forKeyedSubscript:](v14, "setObject:forKeyedSubscript:", 0LL, @"v_Data");
      OSStatus v15 = SecItemUpdate(v14, v17);
    }

    if (!v15)
    {
      id v3 = v22;
      uint64_t v2 = v12;
      goto LABEL_12;
    }

    secLogObjForScope("SecError");
    CFStringRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v2 = v12;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      OSStatus v24 = v15;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "Couldn't save backupV0 to keychain %d", buf, 8u);
    }

    id v3 = v22;
  }

  else
  {
    secLogObjForScope("piggy");
    CFStringRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "can't create public key hash", buf, 2u);
    }

    CFStringRef v9 = 0LL;
    CFErrorRef v14 = 0LL;
  }

LABEL_12:
  CFRelease(v7);
  CFRelease(v5);
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
LABEL_16:
  secLogObjForScope("piggy");
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEFAULT, "key not available", buf, 2u);
  }
}

void __SOSPiggyBackAddToKeychain_block_invoke(uint64_t a1, void *a2)
{
  v21[11] = *MEMORY[0x1895F89C0];
  id v2 = a2;
  [v2 objectForKeyedSubscript:@"v_Data"];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 objectForKeyedSubscript:@"acct"];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 objectForKeyedSubscript:@"srvr"];
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();

  [v3 base64EncodedDataWithOptions:0];
  SecKeyRef v6 = (void *)objc_claimAutoreleasedReturnValue();
  v20[0] = @"class";
  v20[1] = @"nleg";
  uint64_t v7 = MEMORY[0x189604A88];
  v21[0] = @"inet";
  v21[1] = MEMORY[0x189604A88];
  v20[2] = @"agrp";
  _OWORD v20[3] = @"desc";
  v21[2] = @"com.apple.security.ckks";
  v21[3] = @"tlk-piggy";
  uint64_t v8 = *MEMORY[0x189604DE0];
  uint8_t v20[4] = @"sync";
  v20[5] = @"vwht";
  void v21[4] = v8;
  v21[5] = @"PCS-MasterKey";
  void v21[6] = v5;
  v20[6] = @"srvr";
  v20[7] = @"acct";
  [NSString stringWithFormat:@"%@-piggy", v4];
  CFStringRef v9 = (void *)objc_claimAutoreleasedReturnValue();
  v21[7] = v9;
  v21[8] = v4;
  v20[8] = @"path";
  v20[9] = @"invi";
  v20[10] = @"v_Data";
  v21[9] = v7;
  v21[10] = v6;
  [MEMORY[0x189603F68] dictionaryWithObjects:v21 forKeys:v20 count:11];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v11 = (const __CFDictionary *)[v10 mutableCopy];

  OSStatus v12 = SecItemAdd(v11, 0LL);
  if (v12 == -25299)
  {
    CFStringRef v18 = @"v_Data";
    uint64_t v19 = v3;
    [MEMORY[0x189603F68] dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    CFTypeRef v13 = (void *)objc_claimAutoreleasedReturnValue();
    CFErrorRef v14 = (const __CFDictionary *)[v13 mutableCopy];

    OSStatus v12 = SecItemUpdate(v11, v14);
  }

  if (v12)
  {
    secLogObjForScope("SecError");
    OSStatus v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      OSStatus v17 = v12;
      _os_log_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEFAULT, "Couldn't save tlks to keychain %d", buf, 8u);
    }
  }
}

id SOSPiggyCopyInitialSyncData(void *a1)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  [MEMORY[0x189603FC8] dictionary];
  id v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!ccder_decode_tl())
  {
    secLogObjForScope("piggy");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v10 = "Failed to parse CONS SEQ";
LABEL_15:
      _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
    }

LABEL_40:
      objc_msgSend(v15, "setObject:forKeyedSubscript:", v32, @"srvr", v46);
      if (v31 == v17)
      {
        secLogObjForScope("piggy");
        uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v32;
          __int16 v57 = 2112;
          CFIndex v58 = v26;
          _os_log_impl(&dword_1804F4000, v41, OS_LOG_TYPE_DEFAULT, "Adding %@ %@", buf, 0x16u);
        }

        [v49 addObject:v15];
        char v40 = 1;
        uint64_t v12 = v17;
      }

      else
      {
        char v40 = 0;
      }

      goto LABEL_45;
    }

    if (cf) {
      CFRelease(cf);
    }
    secLogObjForScope("piggy");
    uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v50 = 0;
      uint64_t v36 = (uint8_t *)&v50;
      uint64_t v37 = v35;
      uint64_t v38 = "Failed to parse view name";
      uint32_t v39 = 2;
LABEL_36:
      _os_log_impl(&dword_1804F4000, v37, OS_LOG_TYPE_DEFAULT, v38, v36, v39);
    }

  id v19 = v4 >> 9;
  if ((v3 & 0x400) != 0)
  {
    uint64_t v30 = 0;
    id v24 = 0;
    uint64_t v29 = 1;
  }

  else
  {
    uint64_t v20 = v16 & 0x1F;
    id v21 = (v16 >> 9) & 1;
    uint64_t v22 = v16 & 0x20 | v3 & 0xE0;
    if ((v3 & 0x4000) != 0)
    {
      LODWORD(v19) = v21;
      id v23 = v22;
    }

    else
    {
      id v23 = v3 & 0xE0;
    }

    if ((v3 & 0x4000) != 0) {
      id v24 = v20;
    }
    else {
      id v24 = v3 & 0x1F;
    }
    CFTypeRef v25 = 1LL << (v18 & 0x1F);
    uint64_t v26 = v23 | 0x20;
    if ((v25 & 0x30000) == 0) {
      uint64_t v26 = v23;
    }
    uint64_t v6 = (v25 & 0x55D81018) == 0;
    uint64_t v27 = (v25 & 0x55D81018) != 0;
    if (v6) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = v23;
    }
    uint64_t v29 = (v18 & 0x1F) != 0x1F && v27;
    if ((v18 & 0x1F) == 0x1F) {
      uint64_t v30 = v23;
    }
    else {
      uint64_t v30 = v28;
    }
  }

  *(_BYTE *)(a1 + 44) = v30;
  *(_BYTE *)(a1 + 45) = v24;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v18;
  *(_DWORD *)(a1 + 6_Block_object_dispose(va, 8) = v29;
  *(_DWORD *)(a1 + 72) = v14;
  *(_DWORD *)(a1 + 76) = v5;
  *(_DWORD *)(a1 + 80) = v15;
  *(_DWORD *)(a1 + 84) = (v3 >> 23) & 1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = v19;
  *(_DWORD *)(a1 + 64) = 0;
  return a1;
}

LABEL_56:
  void *v48 = v47 - 0x5555555555555556LL;
  if (!objc_msgSend(v2, "count", v46))
  {
    secLogObjForScope("piggy");
    uint64_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v44,  OS_LOG_TYPE_DEFAULT,  "NO DATA, falling back to waiting 5 minutes for initial sync to finish",  buf,  2u);
    }

    id v2 = 0LL;
  }

  id v43 = v2;
  id v2 = v43;
LABEL_61:

  return v43;
}

            public_char key = make_public_key(a3, (uint64_t)&v71, &v80, &error);
            if (!public_key)
            {
              id v43 = (os_log_s *)secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_53;
              }
              *(_WORD *)size_t v81 = 0;
              uint64_t v44 = "csr: failed to encode public key";
              goto LABEL_52;
            }

            uint64_t v30 = public_key;
            uint64_t v28 = *(void **)(a1 + 24);
            CFRetain(v28);
            signature = make_signature(0LL, 0LL, (__SecKey *)v28, Value, (DERSize *)v67, (__CFString **)&error);
            if (signature) {
              CFRelease(signature);
            }
            CFIndex v60 = 0LL;
            uint64_t v61 = 0LL;
            if (!SEC_ASN1EncodeItem((uint64_t)v14, &v60, (uint64_t)buf, (uint64_t)&kSecAsn1TBSCertificateTemplate))
            {
              BOOL v48 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)size_t v81 = 0;
                _os_log_impl(&dword_1804F4000, v48, OS_LOG_TYPE_DEFAULT, "csr: failed to encode TBS", v81, 2u);
              }
            }

            BOOL v49 = make_signature(v61, v60, (__SecKey *)v28, Value, (DERSize *)&v76[2] + 1, (__CFString **)&error);
            if (!v49)
            {
              __int16 v57 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)size_t v81 = 0;
                _os_log_impl(&dword_1804F4000, v57, OS_LOG_TYPE_DEFAULT, "csr: failed to make signature", v81, 2u);
              }

              uint64_t v22 = 0LL;
              uint64_t v29 = 0LL;
              goto LABEL_25;
            }

            uint64_t v29 = v49;
            CFTypeRef v78 = CFDataGetBytePtr(v49);
            *((void *)&v77 + 1) = 8 * CFDataGetLength(v29);
            CFIndex v58 = 0LL;
            uint64_t v59 = 0LL;
            if (SEC_ASN1EncodeItem((uint64_t)v14, &v58, (uint64_t)buf, (uint64_t)&kSecAsn1SignedCertTemplate))
            {
              __int16 v50 = SecCertificateCreateWithBytes(*MEMORY[0x189604DB0], v59, v58);
              if (v50)
              {
                uint64_t v17 = v50;
                uint64_t v22 = 0LL;
                goto LABEL_66;
              }

              id v54 = (os_log_s *)secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_87;
              }
              *(_WORD *)size_t v81 = 0;
              uint64_t v55 = "csr: failed to decode encoded certificate";
            }

            else
            {
              id v54 = (os_log_s *)secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_87;
              }
              *(_WORD *)size_t v81 = 0;
              uint64_t v55 = "csr: failed to encode certificate";
            }

            _os_log_impl(&dword_1804F4000, v54, OS_LOG_TYPE_DEFAULT, v55, v81, 2u);
LABEL_87:
            uint64_t v22 = 0LL;
            goto LABEL_25;
          }

          if (!a5)
          {
            uint64_t v36 = CFGetTypeID(theDict);
            if (v36 == CFDictionaryGetTypeID() && !parameters_contains_extensions(theDict))
            {
LABEL_54:
              CFTypeRef v45 = (os_log_s *)secLogObjForScope("csr");
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)size_t v81 = 0;
                _os_log_debug_impl(&dword_1804F4000, v45, OS_LOG_TYPE_DEBUG, "no extensions set", v81, 2u);
              }

              goto LABEL_56;
            }

        if (v29) {
          return a1;
        }
        goto LABEL_57;
      }

      Security::UnixError::throwMe((Security::UnixError *)8);
    }
  }

  return 0LL;
}

uint64_t piggy_decode_data(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = ccder_decode_tl();
  if (result)
  {
    uint64_t v5 = result;
    [MEMORY[0x189603F48] dataWithBytes:result length:0];
    *a3 = (id)objc_claimAutoreleasedReturnValue();
    return v5;
  }

  return result;
}

uint64_t SOSPiggyBackBlobCreateFromDER( void *a1, void *a2, void *a3, uint64_t *a4, uint64_t a5, int a6, _BYTE *a7, CFTypeRef *a8)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  CFNumberRef v47 = 0LL;
  uint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  CFTypeRef cf = 0LL;
  uint64_t v46 = 0LL;
  *a7 = 1;
  uint64_t v16 = ccder_decode_constructed_tl();
  *a4 = v16;
  if (!v48)
  {
    if (a8)
    {
      uint64_t v42 = (__CFString *)*a8;
      id v43 = @"Bad Blob DER";
LABEL_22:
      SOSCreateErrorWithFormat(1035LL, v42, a8, 0LL, @"%@", v43);
      goto LABEL_15;
    }

    uint64_t v44 = @"Bad Blob DER";
LABEL_25:
    SOSCreateErrorWithFormat(1035LL, 0LL, 0LL, 0LL, @"%@", v44);
    goto LABEL_15;
  }

  uint64_t v20 = *MEMORY[0x189604DB0];
  uint64_t v21 = der_decode_number((const __CFAllocator *)*MEMORY[0x189604DB0], &v47, a8, v16, v48, v17, v18, v19);
  *a4 = v21;
  uint64_t v25 = der_decode_data_or_null(v20, &cf, a8, v21, v48, v22, v23, v24);
  *a4 = v25;
  uint64_t v29 = der_decode_data_or_null(v20, &v46, a8, v25, v48, v26, v27, v28);
  *a4 = v29;
  if (!a6 || v29 == a5)
  {
    secLogObjForScope("piggy");
    uint64_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v38,  OS_LOG_TYPE_DEFAULT,  "Piggybacking version 0, setting initial sync timeout to 5 minutes",  buf,  2u);
    }

    *a7 = 1;
    if (*a4 && *a4 == a5) {
      goto LABEL_13;
    }
    if (a8)
    {
      uint64_t v42 = (__CFString *)*a8;
      id v43 = @"Didn't consume all bytes for pbblob";
      goto LABEL_22;
    }

    uint64_t v44 = @"Didn't consume all bytes for pbblob";
    goto LABEL_25;
  }

  SOSPiggyCopyInitialSyncData(a4);
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v31 = v30;
  if (v30)
  {
    [v30 objectForKeyedSubscript:@"idents"];
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue();
    [v31 objectForKeyedSubscript:@"tlks"];
    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue();
    secLogObjForScope("piggy");
    uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = [v32 count];
      int v36 = [v33 count];
      *(_DWORD *)__int128 buf = 67109376;
      int v50 = v35;
      __int16 v51 = 1024;
      int v52 = v36;
      _os_log_impl( &dword_1804F4000,  v34,  OS_LOG_TYPE_DEFAULT,  "Piggybacking include identities(%d) and tlks(%d)",  buf,  0xEu);
    }

    id v37 = v32;
    [v33 enumerateObjectsUsingBlock:&__block_literal_global_6159];
    [v37 enumerateObjectsUsingBlock:&__block_literal_global_11];

    *a7 = 0;
  }

LABEL_13:
  uint32_t v39 = SecKeyCreateFromPublicData(v20, 3LL, (CFDataRef)cf);
  *a2 = v39;
  if (v39)
  {
    *a1 = v47;
    *a3 = v46;
  }

uint64_t SOSPiggyBackBlobCreateFromData( void *a1, void *a2, void *a3, CFDataRef theData, int a5, _BYTE *a6, CFTypeRef *a7)
{
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  SOSPiggyBackBlobCreateFromDER(a1, a2, a3, (uint64_t *)&BytePtr, (uint64_t)&BytePtr[Length], a5, a6, a7);
  return 1LL;
}

__CFData *SOSCopyECWrappedData(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  SecRequirementError(a2 != 0LL, a3, @"data required for wrapping");
  if (!a2) {
    return 0LL;
  }
  SecRequirementError(a1 != 0, a3, @"ec pub key required for wrapping");
  if (!a1) {
    return 0LL;
  }
  CFDataGetLength(a2);
  CFIndex v6 = ccec_rfc6637_wrap_key_size();
  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  CFDataSetLength(Mutable, v6);
  if (!SecAllocationError((uint64_t)Mutable, a3, @"%s CFData allocation failed", "SOSCopyECWrappedData"))
  {
LABEL_7:
    if (!Mutable) {
      return Mutable;
    }
    CFRelease(Mutable);
    return 0LL;
  }

  CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  uint64_t v10 = ccrng();
  uint64_t v8 = ccec_rfc6637_wrap_key();
  if ((_DWORD)v8)
  {
    SOSErrorCreate(1028LL, a3, 0LL, @"Wrap failed with %d", v8, v10);
    goto LABEL_7;
  }

  return Mutable;
}

uint64_t SOSPerformWithUnwrappedData(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 0;
  CFIndex Length = CFDataGetLength(theData);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  void v11[2] = __SOSPerformWithUnwrappedData_block_invoke;
  unint64_t v11[3] = &unk_18966C320;
  void v11[6] = a1;
  _OWORD v11[7] = theData;
  void v11[8] = a3;
  v11[4] = a4;
  void v11[5] = &v12;
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 0x40000000LL;
  void v16[2] = __PerformWithBufferAndClear_block_invoke;
  void v16[3] = &unk_189676A80;
  _OWORD v16[4] = v11;
  PerformWithBuffer(Length, (uint64_t)v16);
  uint64_t v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t __SOSPerformWithUnwrappedData_block_invoke(uint64_t a1)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  uint64_t v2 = ccec_rfc6637_unwrap_key();
  if ((_DWORD)v2) {
    return SOSErrorCreate( 1028LL,  *(CFTypeRef **)(a1 + 64),  0LL,  @"ccec_rfc6637_unwrap_key failed with %d",  v2,  BytePtr);
  }
  else {
    return SecRequirementError(0LL, *(CFTypeRef **)(a1 + 64), @"Unexpected algorithm: %d", 170LL);
  }
}

__CFData *SOSCopyECUnwrappedData(int a1, CFDataRef theData, CFTypeRef *a3)
{
  CFIndex length = CFDataGetLength(theData);
  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  CFDataSetLength(Mutable, length);
  if (SecAllocationError((uint64_t)Mutable, a3, @"%s CFData allocation failed", "SOSCopyECUnwrappedData"))
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(theData);
    BytePtr = CFDataGetBytePtr(theData);
    uint64_t v6 = ccec_rfc6637_unwrap_key();
    if ((_DWORD)v6) {
      SOSErrorCreate(1028LL, a3, 0LL, @"Unwrap failed with %d", v6, BytePtr, length);
    }
    else {
      SecRequirementError(0LL, a3, @"Unexpected algorithm: %d", 170LL);
    }
  }

  if (Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t SOSFullPeerInfoGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSFullPeerInfoGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDSingleton;
  if (SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDOnce != -1) {
    dispatch_once(&SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDOnce, block);
  }
  return SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDSingleton;
}

uint64_t __SOSFullPeerInfoGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SOSFullPeerInfoDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0LL;
    CFRelease(v4);
  }

  uint64_t v5 = (const void *)a1[5];
  if (v5)
  {
    a1[5] = 0LL;
    CFRelease(v5);
  }

uint64_t SOSFullPeerInfoCompare(uint64_t a1, uint64_t a2)
{
  if (!CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16))) {
    return 0LL;
  }
  if (CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24))) {
    return 1LL;
  }
  CFTypeRef v5 = SOSFullPeerInfoCopyDeviceKey(a1, 0LL);
  CFTypeRef v6 = SOSFullPeerInfoCopyDeviceKey(a2, 0LL);
  uint64_t v7 = v6;
  if (v5 && v6)
  {
    BOOL v8 = CFEqual(v5, v6) != 0;
  }

  else
  {
    BOOL v8 = 0LL;
    BOOL v4 = 0LL;
    if (!v5) {
      goto LABEL_10;
    }
  }

  CFRelease(v5);
  BOOL v4 = v8;
LABEL_10:
  if (v7) {
    CFRelease(v7);
  }
  return v4;
}

CFHashCode SOSFullPeerInfoHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

CFStringRef SOSFullPeerInfoCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"<SOSFullPeerInfo@%p: %@>", a1, *(void *)(a1 + 16));
}

CFStringRef SOSFullPeerInfoCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"<SOSFullPeerInfo@%p: %@>", a1, *(void *)(a1 + 16));
}

CFTypeRef SOSFullPeerInfoCopyDeviceKey(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(CFDictionaryRef **)(a1 + 16);
  if (!v3) {
    return 0LL;
  }
  CFTypeRef v5 = _SOSPeerInfoCopyPubKey(v3, @"PublicSigningKey", a2);
  if (!v5) {
    return 0LL;
  }
  CFTypeRef v6 = v5;
  CFTypeRef v7 = SecKeyCopyMatchingPrivateKey(v5, (__CFString **)a2);
  if (!v7)
  {
    secLogObjForScope("circleOp");
    BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (v9) {
        uint64_t v9 = *(void *)(v9 + 48);
      }
      int v11 = 138412290;
      uint64_t v12 = v9;
      _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "Failed to find my private key for spid %@",  (uint8_t *)&v11,  0xCu);
    }
  }

  CFRelease(v6);
  return v7;
}

BOOL SOSFullPeerInfoUpdate(uint64_t a1, CFTypeRef *a2, void *a3)
{
  CFTypeRef v5 = a3;
  CFTypeRef v6 = SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (v6)
  {
    CFTypeRef v7 = v6;
    uint64_t v8 = v5[2](v5, *(void *)(a1 + 16), v6, a2);
    BOOL v9 = v8 != 0;
    if (v8)
    {
      uint64_t v10 = v8;
      int v11 = *(const void **)(a1 + 16);
      if (v11) {
        CFRelease(v11);
      }
      *(void *)(a1 + 16) = v10;
    }

    CFRelease(v7);
  }

  else
  {
    BOOL v9 = 0LL;
  }

  return v9;
}

BOOL SOSFullPeerInfoUpdateToThisPeer(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateToThisPeer_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateToThisPeer_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  CFTypeRef v5 = *(const void **)(a1 + 32);
  if (v5) {
    CFRetain(v5);
  }
  return v5;
}

uint64_t SOSFullPeerInfoCreate( const __CFAllocator *a1, const void *a2, void *a3, const void *a4, __SecKey *a5, __SecKey *a6, __SecKey *a7, CFTypeRef *a8)
{
  return SOSFullPeerInfoCreateWithViews(a1, a3, a2, a4, 0LL, a5, a6, a7, a8);
}

uint64_t SOSFullPeerInfoCreateWithViews( const __CFAllocator *a1, void *a2, const void *a3, const void *a4, const void *a5, __SecKey *a6, __SecKey *a7, __SecKey *a8, CFTypeRef *a9)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t Internal = SOSPeerInfoCreate_Internal(a1, a3, a4, a5, a6, a7, a8, 1, a9, &__block_literal_global_40);
  *(void *)(Instance + 16) = Internal;
  if (!Internal) {
    goto LABEL_31;
  }
  int v25 = SecKeyCopyPersistentRef((uint64_t)a6, (CFTypeRef *)(Instance + 24), v19, v20, v21, v22, v23, v24);
  if (!SecError(v25, (__CFString **)a9, @"Inflating persistent ref")) {
    goto LABEL_31;
  }
  int v32 = SecKeyCopyPersistentRef((uint64_t)a7, (CFTypeRef *)(Instance + 32), v26, v27, v28, v29, v30, v31);
  if (v32 == -25300)
  {
    uint64_t v33 = (void *)[objc_alloc((Class)get_SFECKeyPairClass()) initWithSecKey:a7];
    createKeyLabel((const __CFDictionary *)a3, a2, @"Octagon Peer Signing ");
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue();
    SecKeyRef v35 = SecKeyCopyPublicKey(a7);
    if (v35)
    {
      SecKeyRef v36 = v35;
      unint64_t v69 = v33;
      uint64_t v70 = a2;
      [v33 keyData];
      id v37 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      uint64_t v72 = 0LL;
      LODWORD(v36) = SOSFullPeerInfoSaveOctagonKeysToKeychain(v34, v37, v36, &v72);
      uint64_t v38 = v72;

      if (!(_DWORD)v36 || v38)
      {
        secLogObjForScope("SecError");
        uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( &dword_1804F4000,  v46,  OS_LOG_TYPE_DEFAULT,  "Unable to save octagon signing key to the keychain",  buf,  2u);
        }

        int v32 = -25300;
      }

      else
      {
        int v32 = SecKeyCopyPersistentRef((uint64_t)a7, (CFTypeRef *)(Instance + 32), v39, v40, v41, v42, v43, v44);
      }

      uint64_t v33 = v69;
      a2 = v70;
    }

    else
    {
      secLogObjForScope("SecError");
      CFTypeRef v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( &dword_1804F4000,  v45,  OS_LOG_TYPE_DEFAULT,  "Unable to get public from octagon peer signing key",  buf,  2u);
      }

      int v32 = -25300;
    }
  }

  if (!SecError(v32, (__CFString **)a9, @"Inflating octagon peer signing persistent ref")) {
    goto LABEL_31;
  }
  int v53 = SecKeyCopyPersistentRef((uint64_t)a8, (CFTypeRef *)(Instance + 40), v47, v48, v49, v50, v51, v52);
  if (v53 != -25300) {
    goto LABEL_29;
  }
  id v54 = (void *)[objc_alloc((Class)get_SFECKeyPairClass()) initWithSecKey:a8];
  createKeyLabel((const __CFDictionary *)a3, a2, @"Octagon Peer Encryption ");
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue();
  SecKeyRef v56 = SecKeyCopyPublicKey(a8);
  if (!v56)
  {
    secLogObjForScope("SecError");
    uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v67 = "Unable to get public from octagon peer encryption key";
LABEL_26:
      _os_log_impl(&dword_1804F4000, v66, OS_LOG_TYPE_DEFAULT, v67, buf, 2u);
    }

id get_SFECKeyPairClass()
{
  uint64_t v4 = 0LL;
  CFTypeRef v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  CFIndex v0 = (void *)get_SFECKeyPairClass_softClass;
  uint64_t v7 = get_SFECKeyPairClass_softClass;
  if (!get_SFECKeyPairClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    _OWORD v3[2] = __get_SFECKeyPairClass_block_invoke;
    v3[3] = &unk_1896734F0;
    v3[4] = &v4;
    __get_SFECKeyPairClass_block_invoke((uint64_t)v3);
    CFIndex v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18058A7A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id createKeyLabel(const __CFDictionary *a1, void *a2, void *a3)
{
  CFTypeRef v5 = (void *)NSString;
  id v6 = a3;
  id v7 = a2;
  [v5 stringWithFormat:@"ID for %@-%@", SOSPeerGestaltGetName(a1), v7];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();

  [v6 stringByAppendingString:v8];
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

BOOL SOSFullPeerInfoSaveOctagonKeysToKeychain(void *a1, const __CFData *a2, const void *a3, void *a4)
{
  id v7 = a1;
  CFDictionaryRef v8 = SecKeyCopyAttributeDictionaryWithLocalKey(a3, (uint64_t)@"73", a2);
  BOOL v9 = (void *)-[__CFDictionary mutableCopy](v8, "mutableCopy");

  [v9 setObject:v7 forKeyedSubscript:@"labl"];
  [v9 setObject:MEMORY[0x189604A88] forKeyedSubscript:@"nleg"];
  [v9 setObject:*MEMORY[0x189604DE0] forKeyedSubscript:@"sync"];
  [v9 setObject:@"com.apple.security.sos" forKeyedSubscript:@"agrp"];
  CFTypeRef result = 0LL;
  uint64_t v10 = SecItemAdd((CFDictionaryRef)v9, &result);
  if ((_DWORD)v10)
  {
    if ((_DWORD)v10 == -25299)
    {
      id v11 = objc_alloc_init(MEMORY[0x189603FC8]);
      [v9 objectForKeyedSubscript:@"class"];
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v12 forKeyedSubscript:@"class"];

      [v9 objectForKeyedSubscript:@"73"];
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v13 forKeyedSubscript:@"type"];

      [v9 objectForKeyedSubscript:@"1"];
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v14 forKeyedSubscript:@"kcls"];

      [v9 objectForKeyedSubscript:@"agrp"];
      char v15 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v15 forKeyedSubscript:@"agrp"];

      [v9 objectForKeyedSubscript:@"labl"];
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v16 forKeyedSubscript:@"labl"];

      [v9 objectForKeyedSubscript:@"klbl"];
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v17 forKeyedSubscript:@"klbl"];

      [v9 objectForKeyedSubscript:@"nleg"];
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
      [v11 setObject:v18 forKeyedSubscript:@"nleg"];

      int v19 = (void *)[v9 mutableCopy];
      [v19 setObject:0 forKeyedSubscript:@"class"];
      int v20 = (void *)SecItemUpdate((CFDictionaryRef)v11, (CFDictionaryRef)v19);
      if ((_DWORD)v20)
      {
        int v21 = (void *)MEMORY[0x189607870];
        uint64_t v22 = *MEMORY[0x189607670];
        objc_msgSend(NSString, "stringWithFormat:", @"SecItemUpdate: %d", v20);
        int v23 = (void *)objc_claimAutoreleasedReturnValue();
        [v21 errorWithDomain:v22 code:(int)v20 description:v23];
        int v24 = (void *)objc_claimAutoreleasedReturnValue();
      }

      else
      {
        int v24 = 0LL;
      }
    }

    else
    {
      int v20 = (void *)MEMORY[0x189607870];
      uint64_t v26 = *MEMORY[0x189607670];
      uint64_t v27 = (int)v10;
      objc_msgSend(NSString, "stringWithFormat:", @"SecItemAdd: %d", v10);
      id v11 = (id)objc_claimAutoreleasedReturnValue();
      [v20 errorWithDomain:v26 code:v27 description:v11];
      int v24 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v20) = 1;
    }

    if (a4 && v24) {
      *a4 = v24;
    }
    BOOL v25 = (_DWORD)v20 == 0;
  }

  else
  {
    BOOL v25 = 1LL;
  }

  return v25;
}

void *SOSFullPeerInfoCopyFullPeerInfo(uint64_t a1)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  SOSFullPeerInfoGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  BOOL v9 = (void *)Instance;
  if (!a1 || ((uint64_t v10 = *(void *)(a1 + 16)) != 0 ? (v11 = Instance == 0) : (v11 = 1), v11))
  {
    if (!Instance) {
      return v9;
    }
LABEL_11:
    CFRelease(v9);
    return 0LL;
  }

  uint64_t Copy = SOSPeerInfoCreateCopy(v2, v10, 0LL, v4, v5, v6, v7, v8);
  void v9[2] = Copy;
  if (!Copy) {
    goto LABEL_11;
  }
  uint64_t v13 = *(const void **)(a1 + 24);
  if (v13) {
    CFRetain(v13);
  }
  void v9[3] = v13;
  return v9;
}

uint64_t SOSFullPeerInfoGetPeerInfo(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

BOOL SOSFullPeerInfoUpdateOctagonKeys(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = __SOSFullPeerInfoUpdateOctagonKeys_block_invoke;
  v5[3] = &__block_descriptor_48_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v5[4] = a2;
  void v5[5] = a3;
  return SOSFullPeerInfoUpdate(a1, a4, v5);
}

const void *__SOSFullPeerInfoUpdateOctagonKeys_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, __CFString **a4)
{
  return SOSPeerInfoSetOctagonKeys( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a3,  a4);
}

BOOL SOSFullPeerInfoUpdateOctagonSigningKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateOctagonSigningKey_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateOctagonSigningKey_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, __CFString **a4)
{
  return SOSPeerInfoSetOctagonKey( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  (uint64_t)@"OctagonPublicSigningKey",  *(void *)(a1 + 32),  a3,  a4);
}

BOOL SOSFullPeerInfoUpdateOctagonEncryptionKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateOctagonEncryptionKey_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateOctagonEncryptionKey_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, __CFString **a4)
{
  return SOSPeerInfoSetOctagonKey( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  (uint64_t)@"OctagonPublicEncryptionKey",  *(void *)(a1 + 32),  a3,  a4);
}

BOOL SOSFullPeerInfoSetCKKS4AllSupport(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a1) {
    a1 = *(void *)(a1 + 16);
  }
  if (SOSPeerInfoSupportsCKKSForAll(a1) == a2) {
    return 1LL;
  }
  secLogObjForScope("circleChange");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = @"not supported";
    if (a2) {
      uint64_t v7 = @"supported";
    }
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v12 = v7;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Setting CKKS4All status to '%@'", buf, 0xCu);
  }

  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = __SOSFullPeerInfoSetCKKS4AllSupport_block_invoke;
  void v9[3] = &__block_descriptor_33_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  char v10 = a2;
  return SOSFullPeerInfoUpdate(v5, a3, v9);
}

const void *__SOSFullPeerInfoSetCKKS4AllSupport_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSFullPeerInfoSetCKKS4AllSupport_block_invoke_2;
  void v6[3] = &__block_descriptor_33_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  char v7 = *(_BYTE *)(a1 + 32);
  return SOSPeerInfoCopyWithModification(v4, a2, a3, a4, v6);
}

uint64_t __SOSFullPeerInfoSetCKKS4AllSupport_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 32)) {
    uint64_t v2 = (const void **)MEMORY[0x189604DE8];
  }
  else {
    uint64_t v2 = (const void **)MEMORY[0x189604DE0];
  }
  SOSPeerInfoV2DictionarySetValue(a2, (const void *)sCKKSForAll, *v2);
  return 1LL;
}

CFTypeRef SOSPeerInfoCopyData(CFDictionaryRef *a1, CFTypeRef *a2)
{
  CFTypeRef result = 0LL;
  uint64_t v3 = _SOSPeerInfoCopyPubKey(a1, @"PublicSigningKey", a2);
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v4 = v3;
  uint64_t v5 = SecKeyCopyPublicKeyHash(v3);
  uint64_t v13 = CFDictionaryCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  v6,  v7,  v8,  v9,  v10,  v11,  v12,  (uint64_t)@"class",  (uint64_t)@"keys");
  if (v5) {
    CFRelease(v5);
  }
  OSStatus v14 = SecItemCopyMatching(v13, &result);
  SecError(v14, (__CFString **)a2, @"Error finding persistent ref to key from public: %@", v4);
  if (v13) {
    CFRelease(v13);
  }
  CFRelease(v4);
  CFTypeRef v15 = result;
  if (!result)
  {
LABEL_7:
    secLogObjForScope("fpi");
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "no private key found", buf, 2u);
    }

    return result;
  }

  return v15;
}

CFDictionaryRef CFDictionaryCreateForCFTypes( CFAllocatorRef allocator, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  int v23 = &a10;
  unint64_t v11 = 0LL;
  if (a9)
  {
    do
    {
      v11 += 2LL;
      int v12 = v23;
      v23 += 2;
    }

    while (v12[1]);
  }

  unint64_t v13 = v11 >> 1;
  int v24 = (const void **)&a9;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, v11 >> 1, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeRef v15 = Mutable;
  if (v11)
  {
    uint64_t v16 = (const void *)*MEMORY[0x189605018];
    do
    {
      uint64_t v17 = v24;
      uint64_t v18 = *v24;
      v24 += 2;
      int v19 = v17[1];
      if (v19) {
        int v20 = v19;
      }
      else {
        int v20 = v16;
      }
      CFDictionarySetValue(v15, v18, v20);
      --v13;
    }

    while (v13);
  }

  CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, v15);
  CFRelease(v15);
  return Copy;
}

void *SOSFullPeerInfoCreateCloudIdentity(uint64_t a1, void *a2, CFTypeRef *a3)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = a2;
  if (!a2 || (CFRetain(a2), !Instance[2]))
  {
    int v7 = Instance;
    goto LABEL_7;
  }

  int v6 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)a2, @"PublicSigningKey", a3);
  if (v6)
  {
    int v7 = v6;
    CFTypeRef PersistentRefToMatchingPrivateKey = SecKeyCreatePersistentRefToMatchingPrivateKey(v6, (__CFString **)a3);
    Instance[3] = PersistentRefToMatchingPrivateKey;
    if (PersistentRefToMatchingPrivateKey)
    {
LABEL_8:
      CFRelease(v7);
      return Instance;
    }

    CFRelease(Instance);
LABEL_7:
    uint64_t Instance = 0LL;
    goto LABEL_8;
  }

  return Instance;
}

uint64_t SOSFullPeerInfoCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *a3 = ccder_decode_constructed_tl();
  int v7 = *(const void **)(Instance + 16);
  if (v7)
  {
    *(void *)(Instance + 16) = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = SOSPeerInfoCreateFromDER(a1, a2, a3);
  *(void *)(Instance + 16) = v8;
  if (!v8
    || (int v12 = der_decode_data(a1, (CFDataRef *)(Instance + 24), a2, *a3, 0xAAAAAAAAAAAAAAAALL, v9, v10, v11),
        (*a3 = (uint64_t)v12) == 0))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t SOSFullPeerInfoCreateFromData(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  if (!theData) {
    return 0LL;
  }
  CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SOSFullPeerInfoCreateFromDER(a1, a3, (uint64_t *)&BytePtr);
}

BOOL SOSFullPeerInfoUpdateGestalt(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateGestalt_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateGestalt_block_invoke(uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v5 = *(void *)(a1 + 32);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  unint64_t v7[2] = __SOSPeerInfoCopyWithGestaltUpdate_block_invoke;
  void v7[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  _OWORD v7[4] = v5;
  return SOSPeerInfoCopyWithModification(v4, a2, a3, a4, v7);
}

BOOL SOSFullPeerInfoUpdateV2Dictionary(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateV2Dictionary_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateV2Dictionary_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SOSPeerInfoCopyWithV2DictionaryUpdate(a1, a2, *(const __CFDictionary **)(a1 + 32), a3, a4, a6, a7, a8);
}

BOOL SOSFullPeerInfoUpdateBackupKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoUpdateBackupKey_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoUpdateBackupKey_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v5 = *(void *)(a1 + 32);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  unint64_t v7[2] = __SOSPeerInfoCopyWithBackupKeyUpdate_block_invoke;
  void v7[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  _OWORD v7[4] = v5;
  return SOSPeerInfoCopyWithModification(v4, a2, a3, a4, v7);
}

BOOL SOSFullPeerInfoReplaceEscrowRecords(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  unint64_t v4[2] = __SOSFullPeerInfoReplaceEscrowRecords_block_invoke;
  void v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  void v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

const void *__SOSFullPeerInfoReplaceEscrowRecords_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v5 = *(void *)(a1 + 32);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  unint64_t v7[2] = __SOSPeerInfoCopyWithReplacedEscrowRecords_block_invoke;
  void v7[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  _OWORD v7[4] = v5;
  return SOSPeerInfoCopyWithModification(v4, a2, a3, a4, v7);
}

uint64_t SOSFullPeerInfoUpdateViews(uint64_t a1, int a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v14 = 0LL;
  CFTypeRef v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  int v17 = 0;
  secLogObjForScope("viewChange");
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v9 = off_18966C9C8[a2 - 1];
    }
    *(_DWORD *)__int128 buf = 136315394;
    int v19 = v9;
    __int16 v20 = 2112;
    uint64_t v21 = a3;
    _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "%s view %@", buf, 0x16u);
  }

  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  void v12[2] = __SOSFullPeerInfoUpdateViews_block_invoke;
  v12[3] = &unk_18966C428;
  int v13 = a2;
  _OWORD v12[4] = &v14;
  v12[5] = a3;
  if (SOSFullPeerInfoUpdate(a1, a4, v12)) {
    uint64_t v10 = *((unsigned int *)v15 + 6);
  }
  else {
    uint64_t v10 = 0LL;
  }
  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_18058B9BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

const void *__SOSFullPeerInfoUpdateViews_block_invoke( uint64_t a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SOSPeerInfoCopyWithViewsChange( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  *(_DWORD *)(a1 + 48),  *(const void **)(a1 + 40),  (_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  a3,  a4,  a8);
}

uint64_t SOSFullPeerInfoUpdateToCurrent(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  CFTypeRef v24 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(uint64_t *)(v6 + 56) >= 3 && SOSPeerInfoSerialNumberIsSet(v6))
  {
    CFMutableSetRef v7 = SOSFullPeerInfoCopyViewUpdate(a1, a2, a3);
    if (!v7)
    {
      uint64_t v18 = 0LL;
      uint64_t v14 = 0LL;
      goto LABEL_11;
    }

    CFRelease(v7);
  }

  CFMutableSetRef v8 = SOSFullPeerInfoCopyViewUpdate(a1, a2, a3);
  uint64_t v14 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, &cf);
  if (!v14)
  {
    secLogObjForScope("upgrade");
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v27 = cf;
    int v23 = "SOSFullPeerInfoCopyDeviceKey failed: %@";
    goto LABEL_22;
  }

  CFTypeRef v15 = SOSPeerInfoCreateCurrentCopy( (const __CFAllocator *)*MEMORY[0x189604DB0],  *(void *)(a1 + 16),  v9,  v10,  v11,  v12,  v13,  v8,  v14,  &v24);
  if (v15)
  {
    uint64_t v16 = v15;
    int v17 = *(const void **)(a1 + 16);
    if (v17) {
      CFRelease(v17);
    }
    *(void *)(a1 + 16) = v16;
    uint64_t v18 = 1LL;
    if (v8) {
      goto LABEL_10;
    }
    goto LABEL_11;
  }

  secLogObjForScope("upgrade");
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v27 = v24;
    int v23 = "Peer info v2 create copy failed: %@";
LABEL_22:
    _os_log_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEFAULT, v23, buf, 0xCu);
  }

CFMutableSetRef SOSFullPeerInfoCopyViewUpdate(uint64_t a1, const void *a2, const void *a3)
{
  CFMutableSetRef v6 = SOSPeerInfoCopyEnabledViews(*(void *)(a1 + 16));
  CFMutableSetRef v7 = SOSPeerInfoCopyEnabledViews(*(void *)(a1 + 16));
  if (a2)
  {
    CFTypeID v8 = CFGetTypeID(a2);
    if (v8 == CFSetGetTypeID())
    {
      uint64_t context = MEMORY[0x1895F87A8];
      uint64_t v16 = 3221225472LL;
      int v17 = __CFSetUnion_block_invoke;
      uint64_t v18 = &__block_descriptor_40_e10_v16__0r_v8l;
      CFMutableSetRef v19 = v7;
      CFSetApplyFunction((CFSetRef)a2, (CFSetApplierFunction)apply_block_1_6389, &context);
    }
  }

  if (a3)
  {
    CFTypeID v9 = CFGetTypeID(a3);
    if (v9 == CFSetGetTypeID())
    {
      uint64_t context = MEMORY[0x1895F87A8];
      uint64_t v16 = 3221225472LL;
      int v17 = __CFSetSubtract_block_invoke;
      uint64_t v18 = &__block_descriptor_40_e10_v16__0r_v8l;
      CFMutableSetRef v19 = v7;
      CFSetApplyFunction((CFSetRef)a3, (CFSetApplierFunction)apply_block_1_6389, &context);
    }
  }

  if (v6) {
    BOOL v10 = v7 == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    if (v7 == v6) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = v7;
    }
    if (v7 != v6 || v7 == 0LL)
    {
      CFMutableSetRef v7 = v11;
      if (!v6) {
        return v7;
      }
      goto LABEL_24;
    }
  }

  else if (!CFEqual(v7, v6))
  {
    goto LABEL_24;
  }

  CFRelease(v7);
  CFMutableSetRef v7 = 0LL;
  if (v6) {
LABEL_24:
  }
    CFRelease(v6);
  return v7;
}

void __CFSetUnion_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t apply_block_1_6389(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __CFSetSubtract_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t SOSFullPeerInfoViewStatus(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  if (a1 && (uint64_t v3 = *(void *)(a1 + 16)) != 0) {
    return SOSViewsQuery(v3, a2, a3);
  }
  else {
    return 0LL;
  }
}

void *SOSFullPeerInfoCopyPubKey(uint64_t a1, CFTypeRef *a2)
{
  if (a1 && (uint64_t v2 = *(CFDictionaryRef **)(a1 + 16)) != 0LL) {
    return _SOSPeerInfoCopyPubKey(v2, @"PublicSigningKey", a2);
  }
  else {
    return 0LL;
  }
}

void *SOSFullPeerInfoCopyOctagonPublicSigningKey(uint64_t a1, CFTypeRef *a2)
{
  if (a1 && (uint64_t v2 = *(CFDictionaryRef **)(a1 + 16)) != 0LL) {
    return _SOSPeerInfoCopyPubKey(v2, @"OctagonPublicSigningKey", a2);
  }
  else {
    return 0LL;
  }
}

void *SOSFullPeerInfoCopyOctagonPublicEncryptionKey(uint64_t a1, CFTypeRef *a2)
{
  if (a1 && (uint64_t v2 = *(CFDictionaryRef **)(a1 + 16)) != 0LL) {
    return _SOSPeerInfoCopyPubKey(v2, @"OctagonPublicEncryptionKey", a2);
  }
  else {
    return 0LL;
  }
}

BOOL SOSFullPeerInfoValidate(uint64_t a1, CFTypeRef *a2)
{
  return SOSFullPeerInfoGetMatchingPrivateKeyStatus(a1, a2) == 0;
}

uint64_t SOSFullPeerInfoGetMatchingPrivateKeyStatus(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2) {
    return 4294967246LL;
  }
  uint64_t v4 = _SOSPeerInfoCopyPubKey(v2, @"PublicSigningKey", a2);
  if (!v4) {
    return 4294967246LL;
  }
  uint64_t v5 = v4;
  uint64_t MatchingPrivateKeyStatus = SecKeyGetMatchingPrivateKeyStatus(v4, (__CFString **)a2);
  CFRelease(v5);
  return MatchingPrivateKeyStatus;
}

BOOL SOSFullPeerInfoPrivKeyExists(uint64_t a1)
{
  int MatchingPrivateKeyStatus = SOSFullPeerInfoGetMatchingPrivateKeyStatus(a1, 0LL);
  return MatchingPrivateKeyStatus != -25300 && MatchingPrivateKeyStatus != -50;
}

uint64_t SOSFullPeerInfoPurgePersistentKey(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(CFDictionaryRef **)(a1 + 16);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = _SOSPeerInfoCopyPubKey(v3, @"PublicSigningKey", a2);
  CFMutableSetRef v6 = *(CFDictionaryRef **)(a1 + 16);
  if (v6)
  {
    CFMutableSetRef v7 = _SOSPeerInfoCopyPubKey(v6, @"OctagonPublicSigningKey", a2);
    CFTypeID v8 = *(CFDictionaryRef **)(a1 + 16);
    if (v8)
    {
      CFTypeID v9 = _SOSPeerInfoCopyPubKey(v8, @"OctagonPublicEncryptionKey", a2);
      if (v5) {
        goto LABEL_6;
      }
      goto LABEL_30;
    }
  }

  else
  {
    CFMutableSetRef v7 = 0LL;
  }

  CFTypeID v9 = 0LL;
  if (v5)
  {
LABEL_6:
    PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(v5);
    uint64_t v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, PrivateKeyMatchingQuery);
    uint64_t v13 = (const void *)*MEMORY[0x189604DE0];
    CFDictionaryAddValue(MutableCopy, @"u_Tomb", (const void *)*MEMORY[0x189604DE0]);
    OSStatus v14 = SecItemDelete(MutableCopy);
    uint64_t v15 = SecError(v14, (__CFString **)a2, @"Deleting while purging");
    CFTypeRef cf = v7;
    if (v7)
    {
      uint64_t v16 = CreatePrivateKeyMatchingQuery(v7);
      int v17 = CFDictionaryCreateMutableCopy(v11, 0LL, v16);
      CFDictionaryAddValue(v17, @"u_Tomb", v13);
      OSStatus v18 = SecItemDelete(v17);
      uint64_t v15 = v15 & SecError(v18, (__CFString **)a2, @"Deleting signing key while purging");
      if (v16) {
        CFRelease(v16);
      }
      if (v17) {
        CFRelease(v17);
      }
    }

    if (v9)
    {
      CFMutableSetRef v19 = CreatePrivateKeyMatchingQuery(v9);
      CFTypeRef v20 = CFDictionaryCreateMutableCopy(v11, 0LL, v19);
      CFDictionaryAddValue(v20, @"u_Tomb", v13);
      OSStatus v21 = SecItemDelete(v20);
      uint64_t v15 = v15 & SecError(v21, (__CFString **)a2, @"Deleting encryption key while purging");
      if (!PrivateKeyMatchingQuery) {
        goto LABEL_14;
      }
    }

    else
    {
      CFTypeRef v20 = 0LL;
      CFMutableSetRef v19 = 0LL;
      if (!PrivateKeyMatchingQuery)
      {
LABEL_14:
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        CFRelease(v5);
        if (v19) {
          CFRelease(v19);
        }
        if (v20) {
          CFRelease(v20);
        }
        CFMutableSetRef v7 = cf;
        if (!cf) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }

    CFRelease(PrivateKeyMatchingQuery);
    goto LABEL_14;
  }

CFTypeRef SOSFullPeerInfoCopyOctagonSigningKey(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2) {
    return 0LL;
  }
  uint64_t v4 = _SOSPeerInfoCopyPubKey(v2, @"OctagonPublicSigningKey", a2);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  CFTypeRef v6 = SecKeyCopyMatchingPrivateKey(v4, (__CFString **)a2);
  CFRelease(v5);
  return v6;
}

CFTypeRef SOSFullPeerInfoCopyOctagonEncryptionKey(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2) {
    return 0LL;
  }
  uint64_t v4 = _SOSPeerInfoCopyPubKey(v2, @"OctagonPublicEncryptionKey", a2);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  CFTypeRef v6 = SecKeyCopyMatchingPrivateKey(v4, (__CFString **)a2);
  CFRelease(v5);
  return v6;
}

uint64_t SOSFullPeerInfoGetDEREncodedSize( uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (SOSPeerInfoGetDEREncodedSize(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)
    && (CFDataGetLength(*(CFDataRef *)(a1 + 24)), ccder_sizeof_raw_octet_string()))
  {
    return ccder_sizeof();
  }

  else
  {
    return 0LL;
  }

uint64_t SOSFullPeerInfoEncodeToDER(uint64_t a1, CFTypeRef *a2, UInt8 *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = der_encode_data(*(const __CFData **)(a1 + 24), a2);
  SOSPeerInfoEncodeToDER(v5, a2, a3, v6, v7, v8, v9, v10);
  return ccder_encode_constructed_tl();
}

__CFData *SOSFullPeerInfoCopyEncodedData( uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  DEREncodedCFIndex Size = SOSFullPeerInfoGetDEREncodedSize(a1, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SOSFullPeerInfoCopyEncodedData_block_invoke;
  void v13[3] = &__block_descriptor_48_e11__24__0Q8_16l;
  v13[4] = a1;
  v13[5] = a3;
  return CFDataCreateWithDER(v10, DEREncodedSize, v13);
}

uint64_t __SOSFullPeerInfoCopyEncodedData_block_invoke(uint64_t a1, uint64_t a2, UInt8 *a3)
{
  return SOSFullPeerInfoEncodeToDER(*(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40), a3);
}

BOOL SOSFullPeerInfoPromoteToApplication(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  uint64_t v6 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a3);
  if (!v6) {
    return 0LL;
  }
  uint64_t v11 = v6;
  uint64_t v12 = *(const void **)(a1 + 16);
  uint64_t v13 = SOSPeerInfoCopyAsApplication((uint64_t)v12, a2, v6, a3, v7, v8, v9, v10);
  *(void *)(a1 + 16) = v13;
  BOOL v14 = v13 != 0;
  if (v13)
  {
    if (v12) {
      CFRelease(v12);
    }
  }

  else
  {
    *(void *)(a1 + 16) = v12;
  }

  CFRelease(v11);
  return v14;
}

BOOL SOSFullPeerInfoUpgradeSignatures(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  uint64_t v6 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a3);
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(const void **)(a1 + 16);
  uint64_t v9 = SOSPeerInfoUpgradeSignatures((int)v6, a2, v6, (uint64_t)v8, a3);
  *(void *)(a1 + 16) = v9;
  BOOL v10 = v9 != 0;
  if (v9)
  {
    if (v8) {
      CFRelease(v8);
    }
  }

  else
  {
    *(void *)(a1 + 16) = v8;
  }

  CFRelease(v7);
  return v10;
}

CFMutableDictionaryRef *SOSFullPeerInfoPromoteToRetiredAndCopy(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (!v4) {
    return 0LL;
  }
  uint64_t v9 = v4;
  RetirementTicket = SOSPeerInfoCreateRetirementTicket(0LL, v4, *(void *)(a1 + 16), a2, v5, v6, v7, v8);
  uint64_t v11 = RetirementTicket;
  if (!RetirementTicket
    || (uint64_t v12 = *(__SecKey **)(a1 + 16),
        *(void *)(a1 + 16) = RetirementTicket,
        CFRetain(RetirementTicket),
        CFRelease(v9),
        (uint64_t v9 = v12) != 0LL))
  {
    CFRelease(v9);
  }

  return v11;
}

BOOL SOSFullPeerInfoPing(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (!v4) {
    return 0LL;
  }
  uint64_t v9 = v4;
  uint64_t v10 = SOSPeerInfoCopyWithPing( (const __CFAllocator *)*MEMORY[0x189604DB0],  *(void *)(a1 + 16),  v4,  a2,  v5,  v6,  v7,  v8);
  BOOL v11 = v10 != 0;
  if (v10)
  {
    uint64_t v12 = v10;
    uint64_t v13 = *(const void **)(a1 + 16);
    if (v13)
    {
      *(void *)(a1 + 16) = 0LL;
      CFRelease(v13);
    }

    *(void *)(a1 + 16) = v12;
  }

  CFRelease(v9);
  return v11;
}

void SOSGenerationCountWithDescription(const __CFNumber *a1, uint64_t a2)
{
  uint64_t v3 = SOSGenerationCountCopyDescription(a1);
  (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, v3);
  if (v3) {
    CFRelease(v3);
  }
}

__CFString *SOSGenerationCountCopyDescription(const __CFNumber *a1)
{
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"[");
  uint64_t v3 = MutableCopy;
  if (a1)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a1, kCFNumberSInt64Type, valuePtr);
    uint64_t v4 = valuePtr[0];
    double v5 = (double)((valuePtr[0] >> 31) & 0xFFFFFFFE);
    uint64_t v6 = MEMORY[0x1895F87A8];
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    void v9[2] = __SOSGenerationCountCopyDescription_block_invoke;
    void v9[3] = &__block_descriptor_tmp_6404;
    void v9[4] = v3;
    valuePtr[0] = MEMORY[0x1895F87A8];
    uint64_t v11 = 0LL;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2000000000LL;
    uint64_t v14 = 0LL;
    valuePtr[1] = 0x40000000LL;
    void valuePtr[2] = __withStringOfAbsoluteTime_block_invoke;
    valuePtr[3] = &unk_189676848;
    valuePtr[4] = &v11;
    *(double *)&valuePtr[5] = v5;
    uint64_t block = MEMORY[0x1895F87A8];
    uint64_t v16 = 0x40000000LL;
    int v17 = __GetShortDateFormatterQueue_block_invoke;
    OSStatus v18 = &__block_descriptor_tmp_41_13315;
    CFMutableSetRef v19 = &GetShortDateFormatterQueue_sGetShortDateFormatterQueueSingleton;
    if (GetShortDateFormatterQueue_sGetShortDateFormatterQueueOnce != -1) {
      dispatch_once(&GetShortDateFormatterQueue_sGetShortDateFormatterQueueOnce, &block);
    }
    uint64_t block = v6;
    uint64_t v16 = 0x40000000LL;
    int v17 = __withShortDateFormatter_block_invoke;
    OSStatus v18 = &unk_189676918;
    CFMutableSetRef v19 = valuePtr;
    dispatch_sync((dispatch_queue_t)GetShortDateFormatterQueue_sGetShortDateFormatterQueueSingleton, &block);
    __SOSGenerationCountCopyDescription_block_invoke((uint64_t)v9, (const __CFString *)v12[3]);
    uint64_t v7 = (const void *)v12[3];
    if (v7)
    {
      v12[3] = 0LL;
      CFRelease(v7);
    }

    _Block_object_dispose(&v11, 8);
    CFStringAppendFormat(v3, 0LL, @" %u]", v4);
  }

  else
  {
    CFStringAppend(MutableCopy, @"NA]");
  }

  return v3;
}

void __SOSGenerationCountCopyDescription_block_invoke(uint64_t a1, const __CFString *a2)
{
}

CFNumberRef SOSGetGenerationSint(const __CFNumber *result)
{
  if (result)
  {
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }

  return result;
}

CFNumberRef SOSGenerationCreate()
{
  return sosGenerationCreateOrIncrement(0LL);
}

CFNumberRef sosGenerationCreateOrIncrement(const __CFNumber *a1)
{
  if (a1)
  {
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
    unint64_t v1 = valuePtr;
    if (HIDWORD(valuePtr)) {
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v1 = 0LL;
  }

  v1 |= (unint64_t)(CFAbsoluteTimeGetCurrent() >> 1) << 32;
LABEL_6:
  unint64_t valuePtr = v1 + 1;
  return CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
}

CFNumberRef SOSGenerationCreateWithValue(uint64_t a1)
{
  uint64_t valuePtr = a1;
  return CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
}

CFNumberRef SOSGenerationCopy(const __CFNumber *result)
{
  if (result)
  {
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
  }

  return result;
}

BOOL SOSGenerationIsOlder(const __CFNumber *a1, const __CFNumber *a2)
{
  unint64_t v2 = CFNumberCompare(a1, a2, 0LL) + 1;
  return (v2 & 7) == 0 && v2 < 3;
}

CFNumberRef SOSGenerationCreateWithBaseline(const __CFNumber *a1)
{
  unint64_t v2 = sosGenerationCreateOrIncrement(0LL);
  if (v2) {
    CFRelease(v2);
  }
  return sosGenerationCreateOrIncrement(a1);
}

CFNumberRef SOSGenCountCreateFromDER( const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef v9 = 0LL;
  *a3 = der_decode_number(a1, &v9, a2, *a3, a4, a6, a7, a8);
  CFNumberRef result = v9;
  if (!v9) {
    return sosGenerationCreateOrIncrement(0LL);
  }
  return result;
}

BOOL SOSErrorCreate(CFIndex a1, CFTypeRef *a2, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  if (a1 && a2 && !*a2) {
    SecCFCreateErrorWithFormatAndArguments( a1,  @"com.apple.security.sos.error",  0LL,  a2,  formatOptions,  format,  va);
  }
  return a1 == 0;
}

uint64_t SOSCreateError(CFIndex a1, uint64_t a2, __CFString *cf, CFTypeRef *a4)
{
  return 0LL;
}

uint64_t SOSCreateErrorWithFormat( CFIndex a1, __CFString *cf, CFTypeRef *a3, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return 0LL;
}

uint64_t SOSCreateErrorWithFormatAndArguments( CFIndex a1, __CFString *cf, CFTypeRef *a3, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return 0LL;
}

uint64_t GenerateECPair(int a1, SecKeyRef *a2, SecKeyRef *a3)
{
  return GenerateECPairImp(a1, *MEMORY[0x189604DE0], a2, a3);
}

uint64_t GenerateECPairImp(int a1, uint64_t a2, SecKeyRef *a3, SecKeyRef *a4)
{
  int valuePtr = a1;
  uint64_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
  uint64_t v15 = CFDictionaryCreateForCFTypes(v6, v8, v9, v10, v11, v12, v13, v14, (uint64_t)@"type", (uint64_t)@"73");
  if (v7) {
    CFRelease(v7);
  }
  uint64_t Pair = SecKeyGeneratePair(v15, a3, a4);
  if (v15) {
    CFRelease(v15);
  }
  return Pair;
}

uint64_t GeneratePermanentECPair(int a1, SecKeyRef *a2, SecKeyRef *a3)
{
  return GenerateECPairImp(a1, *MEMORY[0x189604DE8], a2, a3);
}

__CFString *SOSItemsChangedCopyDescription(const __CFDictionary *a1, char a2)
{
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<Changes: {\n");
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  void v6[2] = __SOSItemsChangedCopyDescription_block_invoke;
  void v6[3] = &__block_descriptor_41_e15_v24__0r_v8r_v16l;
  void v6[4] = MutableCopy;
  char v7 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_6466, v6);
  CFStringAppendFormat(MutableCopy, 0LL, @"}");
  return MutableCopy;
}

void __SOSItemsChangedCopyDescription_block_invoke(uint64_t a1, const __CFString *cf, const __CFString *a3)
{
  if (!cf) {
    goto LABEL_9;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  CFTypeID TypeID = CFStringGetTypeID();
  CFStringRef v8 = 0LL;
  if (!a3 || v6 != TypeID) {
    goto LABEL_10;
  }
  CFTypeID v9 = CFGetTypeID(a3);
  if (v9 != CFDataGetTypeID())
  {
LABEL_9:
    CFStringRef v8 = 0LL;
    goto LABEL_10;
  }

  int KeyType = SOSKVSKeyGetKeyType(cf);
  if (KeyType != 1)
  {
    if (!KeyType)
    {
      CFTypeRef v16 = 0LL;
      int v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v12 = SOSCircleCreateFromData((const __CFAllocator *)*MEMORY[0x189604DB0], (CFDataRef)a3, &v16);
      if (v12)
      {
        int v13 = (const void *)v12;
        CFStringRef v8 = CFStringCreateWithFormat(v11, 0LL, @"%@", v12);
        CFRelease(v13);
        goto LABEL_10;
      }
    }

    goto LABEL_9;
  }

  CFStringRef v8 = CFCopyDescription(a3);
LABEL_10:
  if (*(_BYTE *)(a1 + 40)) {
    int v14 = "<=";
  }
  else {
    int v14 = "=>";
  }
  if (v8) {
    CFStringRef v15 = v8;
  }
  else {
    CFStringRef v15 = a3;
  }
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0LL, @"    '%@' %s %@\n", cf, v14, v15);
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t apply_block_2_6466(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFStringRef SOSCopyHashBufAsString(unsigned __int8 *a1, unint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  size_t v4 = (2 * a2) | 1;
  MEMORY[0x1895F8858]();
  CFTypeID v6 = (char *)&v12 - ((v5 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  memset(v6, 170, v4);
  unint64_t v7 = SecBase64Encode_(a1, a2, v6, v4, 0, (_DWORD *)&v12 + 1);
  unint64_t v8 = v7;
  if (v7) {
    BOOL v9 = v7 >= v4;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
  uint64_t v10 = 26LL;
  if (v8 < 0x1A) {
    uint64_t v10 = v8;
  }
  v6[v10] = 0;
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v6, 0x600u);
}

CFStringRef SOSCopyIDOfDataBuffer(const __CFData *a1)
{
  v4[1] = *MEMORY[0x1895F89C0];
  size_t v2 = *(void *)ccsha1_di();
  MEMORY[0x1895F8858]();
  if (v2) {
    memset((char *)v4 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v2);
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccdigest();
  return SOSCopyHashBufAsString((unsigned __int8 *)v4 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0LL), v2);
}

CFStringRef SOSCopyIDOfDataBufferWithLength(const __CFData *a1, CFIndex a2)
{
  CFNumberRef result = SOSCopyIDOfDataBuffer(a1);
  if (result)
  {
    size_t v4 = result;
    v6.location = 0LL;
    v6.CFIndex length = a2;
    CFStringRef v5 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], result, v6);
    CFRelease(v4);
    return v5;
  }

  return result;
}

CFStringRef SOSCopyIDOfKey(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0LL;
  if (!a1)
  {
    SOSErrorCreate(1033LL, a2, 0LL, @"NULL key passed to SOSCopyIDOfKey");
    return 0LL;
  }

  int v4 = SecKeyCopyPublicBytes(a1, (uint64_t)&cf);
  BOOL v5 = SecError(v4, (__CFString **)a2, @"Failed to export public bytes %@", a1);
  CFTypeRef v6 = cf;
  if (!v5)
  {
    CFStringRef v7 = 0LL;
    if (!cf) {
      return v7;
    }
    goto LABEL_4;
  }

  CFStringRef v7 = SOSCopyIDOfDataBuffer((const __CFData *)cf);
  CFTypeRef v6 = cf;
  if (cf)
  {
LABEL_4:
    CFTypeRef cf = 0LL;
    CFRelease(v6);
  }

  return v7;
}

CFStringRef SOSCopyIDOfKeyWithLength(uint64_t a1, CFIndex a2, CFTypeRef *a3)
{
  CFNumberRef result = SOSCopyIDOfKey(a1, a3);
  if (result)
  {
    BOOL v5 = result;
    v7.location = 0LL;
    v7.CFIndex length = a2;
    CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], result, v7);
    CFRelease(v5);
    return v6;
  }

  return result;
}

uint64_t SOSGetBackupKeyCurveParameters()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSGetBackupKeyCurveParameters_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersSingleton;
  if (SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersOnce != -1) {
    dispatch_once(&SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersOnce, block);
  }
  return SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersSingleton;
}

uint64_t __SOSGetBackupKeyCurveParameters_block_invoke(uint64_t a1)
{
  uint64_t result = MEMORY[0x186DFEF8C]();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SOSPerformWithDeviceBackupFullKey(uint64_t a1, const __CFData *a2, CFTypeRef *a3, void *a4)
{
  v14[1] = *MEMORY[0x1895F89C0];
  CFRange v7 = a4;
  MEMORY[0x1895F8858](v7);
  BOOL v9 = (char *)v14 - v8;
  uint64_t v10 = 0LL;
  do
  {
    int v11 = &v9[v10];
    *(void *)int v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10 += 16LL;
  }

  while (v8 != v10);
  uint64_t v12 = SOSGenerateDeviceBackupFullKey((uint64_t)v14 - v8, a1, a2, a3);
  if ((_DWORD)v12) {
    v7[2](v7, v9);
  }
  cc_clear();

  return v12;
}

uint64_t SOSGenerateDeviceBackupFullKey(uint64_t a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  memset(__b, 170, sizeof(__b));
  ccsha256_di();
  CFDataGetLength(a3);
  CFDataGetBytePtr(a3);
  uint64_t v6 = ccpbkdf2_hmac();
  if ((_DWORD)v6)
  {
    SOSErrorCreate(1028LL, a4, 0LL, @"ccpbkdf2_hmac failed: %d", v6);
    return 0LL;
  }

  ccrng();
  key_deterministiCC_MD4_CTX c = ccec_generate_key_deterministic();
  if ((_DWORD)key_deterministic)
  {
    SOSErrorCreate(1028LL, a4, 0LL, @"ccec_generate_key_deterministic failed: %d", key_deterministic);
    return 0LL;
  }

  return 1LL;
}

__CFData *SOSCopyDeviceBackupPublicKey(const __CFData *a1, CFTypeRef *a2)
{
  v13[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1895F8858](v4);
  uint64_t v6 = (char *)v13 - v5;
  uint64_t v7 = 0LL;
  do
  {
    uint64_t v8 = &v6[v7];
    *(void *)uint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7 += 16LL;
  }

  while (v5 != v7);
  uint64_t v9 = SOSGetBackupKeyCurveParameters();
  CFIndex v10 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataSetLength(Mutable, v10);
  if (!SecAllocationError((uint64_t)Mutable, a2, @"Mutable data allocation"))
  {
    if (!Mutable) {
      return Mutable;
    }
    CFRelease(Mutable);
    return 0LL;
  }

  CFDataGetMutableBytePtr(Mutable);
  ccec_compact_export();
  return Mutable;
}

CFDataRef SOSDateCreate()
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v1 = CFDateCreate(0LL, Current);
  uint64_t v2 = der_sizeof_date();
  uint64_t v3 = MEMORY[0x1895F8858](v2);
  CFIndex v10 = (const UInt8 *)&v12[-v9];
  if (v3) {
    memset(&v12[-v9], 170, v2);
  }
  der_encode_date((uint64_t)v1, (uint64_t)v10, (unint64_t)&v10[v2], v4, v5, v6, v7, v8, v12[0]);
  if (v1) {
    CFRelease(v1);
  }
  return CFDataCreate(0LL, v10, v2);
}

__CFData *CFDataCreateWithDER(const __CFAllocator *a1, CFIndex a2, void *a3)
{
  uint64_t v5 = a3;
  if (!a2) {
    goto LABEL_9;
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 0LL);
  CFDataSetLength(Mutable, a2);
  if (!Mutable) {
    goto LABEL_10;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  unint64_t v8 = v5[2](v5, a2, MutableBytePtr);
  if ((UInt8 *)v8 == MutableBytePtr) {
    goto LABEL_10;
  }
  if (!v8 || v8 < (unint64_t)MutableBytePtr)
  {
    CFRelease(Mutable);
LABEL_9:
    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_10;
  }

  if (v8 > (unint64_t)MutableBytePtr)
  {
    v10.location = 0LL;
    v10.CFIndex length = v8 - (void)MutableBytePtr;
    CFDataDeleteBytes(Mutable, v10);
  }

uint64_t SOSCachedNotificationOperation(uint64_t a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a2;
  int out_token = -1;
  uint64_t v4 = (void *)MEMORY[0x186DFF9D0]();
  os_unfair_lock_lock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);
  if (!SOSCachedNotificationOperation_tokenCache)
  {
    uint64_t v5 = [MEMORY[0x189603FC8] dictionary];
    uint64_t v6 = (void *)SOSCachedNotificationOperation_tokenCache;
    SOSCachedNotificationOperation_tokenCache = v5;
  }

  uint64_t v7 = +[SOSCachedNotification notificationName:](&OBJC_CLASS___SOSCachedNotification, "notificationName:", a1);
  if (v7)
  {
    unint64_t v8 = (void *)v7;
    [(id)SOSCachedNotificationOperation_tokenCache objectForKeyedSubscript:v7];
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    CFRange v10 = v9;
    if (v9)
    {
      int out_token = [v9 intValue];
    }

    else
    {
      id v12 = v8;
      uint32_t v13 = notify_register_check((const char *)[v12 UTF8String], &out_token);
      if (v13)
      {
        uint32_t v14 = v13;
        secLogObjForScope("cachedStatus");
        CFStringRef v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412546;
          id v19 = v12;
          __int16 v20 = 1024;
          uint32_t v21 = v14;
          _os_log_impl( &dword_1804F4000,  v15,  OS_LOG_TYPE_DEFAULT,  "Failed to retreive token for %@: error %d",  buf,  0x12u);
        }
      }

      else
      {
        [MEMORY[0x189607968] numberWithInt:out_token];
        CFStringRef v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        [(id)SOSCachedNotificationOperation_tokenCache setObject:v15 forKeyedSubscript:v12];
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);

    objc_autoreleasePoolPop(v4);
    uint64_t v11 = v3[2](v3);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);
    objc_autoreleasePoolPop(v4);
    uint64_t v11 = 0LL;
  }

  return v11;
}

uint64_t SOSGetCachedCircleBitmask()
{
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v6 = 0LL;
  v2[0] = MEMORY[0x1895F87A8];
  v2[1] = 3221225472LL;
  v2[2] = __SOSGetCachedCircleBitmask_block_invoke;
  v2[3] = &unk_18966C4C0;
  void v2[4] = &v3;
  SOSCachedNotificationOperation(kSOSCCCircleChangedNotification, v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18058D8EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __SOSGetCachedCircleBitmask_block_invoke(uint64_t a1, int token, int a3)
{
  if (a3) {
    notify_get_state(token, (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  }
  return 0LL;
}

uint64_t SOSGetCachedCircleStatus(CFTypeRef *a1)
{
  uint64_t v2 = SOSGetCachedCircleBitmask();
  if ((v2 & 0x8000000000000000LL) == 0) {
    return 4294967197LL;
  }
  uint64_t v3 = v2;
  if ((v2 & 0x4000000000000000LL) == 0)
  {
    if (a1)
    {
      CFTypeRef v4 = *a1;
      if (*a1)
      {
        *a1 = 0LL;
        CFRelease(v4);
      }

      if ((v3 & 0x1000000000000000LL) != 0) {
        uint64_t v5 = @"Public Key isn't available, this peer is in the circle, but invalid. The iCloud Password must be provided to keychain syncing subsystem to repair this.";
      }
      else {
        uint64_t v5 = @"Public Key isn't available. The iCloud Password must be provided to keychain syncing subsystem to repair this.";
      }
      SOSCreateErrorWithFormat(2LL, 0LL, a1, 0LL, @"%@", v5);
    }

    return 0xFFFFFFFFLL;
  }

  return v3;
}

uint64_t SOSCachedViewBitmask()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  uint64_t v8 = 0LL;
  unint64_t v0 = SOSGetCachedCircleBitmask();
  if (v0 >> 62 == 3 && v0 == 0LL)
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 3221225472LL;
    void v4[2] = __SOSCachedViewBitmask_block_invoke;
    void v4[3] = &unk_18966C4C0;
    void v4[4] = &v5;
    SOSCachedNotificationOperation(kSOSCCViewMembershipChangedNotification, v4);
  }

  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18058DA70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __SOSCachedViewBitmask_block_invoke(uint64_t a1, int token, uint64_t a3)
{
  if ((_DWORD)a3) {
    notify_get_state(token, (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  }
  return a3;
}

CFMutableSetRef SOSCreateCachedViewStatus()
{
  CFMutableSetRef result = (CFMutableSetRef)SOSCachedViewBitmask();
  if (result) {
    return SOSViewCreateSetFromBitmask((uint64_t)result);
  }
  return result;
}

id SOSCreateRandomDateBetweenNowPlus(double a1, double a2)
{
  unint64_t v3 = (unint64_t)(a2 - a1);
  else {
    unint64_t v4 = 0xAAAAAAAAAAAAAAAALL % v3;
  }
  return (id)[objc_alloc(MEMORY[0x189603F50]) initWithTimeIntervalSinceNow:(double)v4 + a1];
}

id SOSCCCredentialQueue()
{
  if (SOSCCCredentialQueue_onceToken != -1) {
    dispatch_once(&SOSCCCredentialQueue_onceToken, &__block_literal_global_6508);
  }
  return (id)SOSCCCredentialQueue_credQueue;
}

void __SOSCCCredentialQueue_block_invoke()
{
  dispatch_queue_t v0 = dispatch_queue_create("com.apple.SOSCredentialsQueue", 0LL);
  CFDateRef v1 = (void *)SOSCCCredentialQueue_credQueue;
  SOSCCCredentialQueue_credQueue = (uint64_t)v0;
}

uint64_t SOSDoWithCredentialsWhileUnlocked(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v12 = 0LL;
  uint32_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 0;
  SOSCCCredentialQueue();
  unint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSDoWithCredentialsWhileUnlocked_block_invoke;
  block[3] = &unk_18966C508;
  CFRange v10 = &v12;
  uint64_t v11 = a1;
  id v9 = v3;
  id v5 = v3;
  dispatch_sync(v4, block);

  uint64_t v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v6;
}

void __SOSDoWithCredentialsWhileUnlocked_block_invoke(uint64_t a1)
{
  uint64_t v15 = 0LL;
  CFTypeRef v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  char v18 = 0;
  uint64_t v2 = *(CFTypeRef **)(a1 + 48);
  uint64_t v3 = MEMORY[0x1895F87A8];
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  void v11[2] = __SOSDoWithCredentialsWhileUnlocked_block_invoke_2;
  unint64_t v11[3] = &unk_18966C508;
  uint32_t v13 = &v15;
  id v4 = *(id *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  id v12 = v4;
  uint64_t v14 = v5;
  uint64_t v26 = 0LL;
  CFTypeRef v27 = &v26;
  uint64_t v28 = 0x2000000000LL;
  int v29 = 0;
  KeybagAssertionQueue = (dispatch_queue_s *)GetKeybagAssertionQueue();
  uint64_t block = v3;
  uint64_t v20 = 0x40000000LL;
  uint32_t v21 = __SecAKSKeybagHoldLockAssertion_block_invoke;
  uint64_t v22 = &unk_189676A18;
  int v23 = &v26;
  uint64_t v24 = 60LL;
  int v25 = 0;
  dispatch_sync(KeybagAssertionQueue, &block);
  BOOL v7 = SecKernError( *((_DWORD *)v27 + 6),  v2,  @"Kern return error",  v11[0],  3221225472LL,  __SOSDoWithCredentialsWhileUnlocked_block_invoke_2,  &unk_18966C508);
  _Block_object_dispose(&v26, 8);
  if (v7)
  {
    __SOSDoWithCredentialsWhileUnlocked_block_invoke_2((uint64_t)v11);
    uint64_t v26 = 0LL;
    CFTypeRef v27 = &v26;
    uint64_t v28 = 0x2000000000LL;
    int v29 = 0;
    uint64_t v8 = (dispatch_queue_s *)GetKeybagAssertionQueue();
    uint64_t block = v3;
    uint64_t v20 = 0x40000000LL;
    uint32_t v21 = __SecAKSKeybagDropLockAssertion_block_invoke;
    uint64_t v22 = &unk_189676A40;
    int v23 = &v26;
    LODWORD(v24) = 0;
    dispatch_sync(v8, &block);
    SecKernError(*((_DWORD *)v27 + 6), v2, @"Kern return error");
    _Block_object_dispose(&v26, 8);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *((_BYTE *)v16 + 24);
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    id v9 = *(const void ***)(a1 + 48);
    CFRange v10 = *v9;
    if (*v9)
    {
      *id v9 = 0LL;
      CFRelease(v10);
    }
  }

  _Block_object_dispose(&v15, 8);
}

void sub_18058DE70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t __SOSDoWithCredentialsWhileUnlocked_block_invoke_2(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t SOSVisibleKeychainNotAllowed()
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2050000000LL;
  dispatch_queue_t v0 = (void *)getMCProfileConnectionClass_softClass;
  uint64_t v10 = getMCProfileConnectionClass_softClass;
  if (!getMCProfileConnectionClass_softClass)
  {
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    void v6[2] = __getMCProfileConnectionClass_block_invoke;
    void v6[3] = &unk_1896734F0;
    void v6[4] = &v7;
    __getMCProfileConnectionClass_block_invoke((uint64_t)v6);
    dispatch_queue_t v0 = (void *)v8[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v7, 8);
  [v1 sharedConnection];
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  int v3 = [v2 isCloudKeychainSyncAllowed];
  if ((v3 & 1) == 0)
  {
    secLogObjForScope("views");
    id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "V0 views disabled by Managed Preferences Profile",  (uint8_t *)v6,  2u);
    }
  }

  return v3 ^ 1u;
}

void sub_18058DFDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

Class __getMCProfileConnectionClass_block_invoke(uint64_t a1)
{
  if (!ManagedConfigurationLibraryCore_frameworkLibrary) {
    ManagedConfigurationLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!ManagedConfigurationLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    int v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *ManagedConfigurationLibrary(void)"];
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v4,  @"SOSInternal.m",  486,  @"%s",  0);

    goto LABEL_8;
  }

  Class result = objc_getClass("MCProfileConnection");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    [MEMORY[0x1896077D8] currentHandler];
    int v3 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getMCProfileConnectionClass(void)_block_invoke"];
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v3,  "handleFailureInFunction:file:lineNumber:description:",  v5,  @"SOSInternal.m",  487,  @"Unable to find class %s",  "MCProfileConnection");

LABEL_8:
    __break(1u);
  }

  getMCProfileConnectionClass_softint Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return result;
}

void _SOSControlSetupInterface(void *a1)
{
  id v2 = a1;
  +[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses");
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 setClasses:v1 forSelector:sel_userPublicKey_ argumentIndex:2 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_stashedCredentialPublicKey_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_assertStashedAccountCredential_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_validatedStashedAccountCredential_flowID_deviceSessionID_canSendMetrics_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_stashAccountCredential_altDSID_flowID_deviceSessionID_canSendMetrics_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_ghostBust_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_ghostBustPeriodic_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_ghostBustTriggerTimed_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_ghostBustInfo_ argumentIndex:0 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_iCloudIdentityStatus_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_accountStatus_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_keyStatusFor_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_myPeerInfo_flowID_deviceSessionID_canSendMetrics_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_circleHash_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_circleJoiningBlob_flowID_deviceSessionID_canSendMetrics_applicant_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_joinCircleWithBlob_altDSID_flowID_deviceSessionID_canSendMetrics_version_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_initialSyncCredentials_altDSID_flowID_deviceSessionID_canSendMetrics_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_importInitialSyncCredentials_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_rpcTriggerSync_complete_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_getWatchdogParameters_ argumentIndex:1 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_setWatchdogParmeters_complete_ argumentIndex:0 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_rpcTriggerBackup_complete_ argumentIndex:0 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_rpcTriggerRingUpdate_ argumentIndex:0 ofReply:1];
  [v2 setClasses:v1 forSelector:sel_removeV0Peers_ argumentIndex:1 ofReply:1];
}

CFStringRef SOSCircleKeyCreateWithName(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithFormat(0LL, 0LL, @"%@%@", @"o", result);
  }
  return result;
}

uint64_t SOSKVSKeyGetKeyType(const __CFString *a1)
{
  if (CFStringHasPrefix(a1, @"o")) {
    return 0LL;
  }
  if (CFStringHasPrefix(a1, @"~")) {
    return 7LL;
  }
  if (CFStringHasPrefix(a1, @"-")) {
    return 4LL;
  }
  if (CFStringHasPrefix(a1, @">KeyParameters")) {
    return 2LL;
  }
  if (CFStringHasPrefix(a1, @"^InitialSync")) {
    return 3LL;
  }
  if (CFStringHasPrefix(a1, @"^OfficialDSID")) {
    return 5LL;
  }
  if (CFStringHasPrefix(a1, @"dbg-")) {
    return 6LL;
  }
  if (CFStringHasPrefix(a1, @"k")) {
    return 9LL;
  }
  return 1LL;
}

BOOL SOSKVSKeyParse( int a1, CFStringRef theString, CFStringRef *a3, CFStringRef *a4, CFStringRef *a5, uint64_t a6, CFStringRef *a7, CFStringRef *a8)
{
  BOOL v8 = 1LL;
  switch(a1)
  {
    case 0:
      if (!a3) {
        return 1LL;
      }
      v40.CFIndex length = CFStringGetLength(theString) - 1;
      BOOL v8 = 1LL;
      v40.location = 1LL;
      *a3 = CFStringCreateWithSubstring(0LL, theString, v40);
      return v8;
    case 1:
      MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(0LL, 128LL, theString);
      CFStringRef v14 = copyStringEndingIn(MutableCopy, @"|");
      if (!v14) {
        goto LABEL_38;
      }
      uint64_t v15 = v14;
      CFTypeRef v16 = copyStringEndingIn(MutableCopy, @":");
      if (!v16)
      {
        BOOL v8 = 0LL;
        goto LABEL_45;
      }

      uint64_t v17 = v16;
      CFIndex Length = CFStringGetLength(v16);
      BOOL v8 = Length > 0;
      if (Length < 1)
      {
        CFDictionaryRef Copy = 0LL;
      }

      else
      {
        CFDictionaryRef Copy = CFStringCreateCopy(0LL, MutableCopy);
        if (a3) {
          *a3 = CFStringCreateCopy(0LL, v15);
        }
        if (a7) {
          *a7 = CFStringCreateCopy(0LL, v17);
        }
        if (a8 && Copy) {
          *a8 = CFStringCreateCopy(0LL, Copy);
        }
      }

      CFRelease(v15);
      CFRelease(v17);
      uint64_t v15 = Copy;
      if (!Copy) {
        goto LABEL_47;
      }
      goto LABEL_45;
    case 4:
      MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(0LL, 128LL, theString);
      v39.location = 0LL;
      v39.CFIndex length = 1LL;
      CFStringDelete(MutableCopy, v39);
      CFStringRef v20 = copyStringEndingIn(MutableCopy, @"|");
      if (!v20) {
        goto LABEL_38;
      }
      uint32_t v21 = v20;
      CFStringRef v22 = CFStringCreateCopy(0LL, MutableCopy);
      BOOL v8 = v22 != 0LL;
      if (v22)
      {
        uint64_t v15 = v22;
        if (a3) {
          *a3 = CFStringCreateCopy(0LL, v21);
        }
        if (a7) {
          *a7 = CFStringCreateCopy(0LL, v15);
        }
        CFRelease(v21);
      }

      else
      {
        uint64_t v15 = v21;
      }

LABEL_45:
      int v31 = v15;
      goto LABEL_46;
    case 6:
      if (a4)
      {
        CFIndex v24 = CFStringGetLength(@"dbg-");
        CFIndex v25 = CFStringGetLength(theString);
        v41.CFIndex length = v25 - CFStringGetLength(@"dbg-");
        v41.location = v24;
        *a4 = CFStringCreateWithSubstring(0LL, theString, v41);
      }

      return 1LL;
    case 7:
      if (!a5) {
        return 1LL;
      }
      v42.CFIndex length = CFStringGetLength(theString) - 1;
      BOOL v8 = 1LL;
      v42.location = 1LL;
      *a5 = CFStringCreateWithSubstring(0LL, theString, v42);
      return v8;
    case 8:
      BOOL v8 = 1LL;
      if (!a3 || !a7) {
        return v8;
      }
      MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(0LL, 128LL, theString);
      CFStringRef v27 = copyStringEndingIn(MutableCopy, @"|");
      if (v27)
      {
        uint64_t v28 = v27;
        CFStringRef v29 = CFStringCreateCopy(0LL, MutableCopy);
        BOOL v8 = v29 != 0LL;
        if (v29)
        {
          int v30 = v29;
          *a3 = CFStringCreateCopy(0LL, v28);
          *a7 = CFStringCreateCopy(0LL, v30);
          CFRelease(v28);
          uint64_t v28 = v30;
        }

        int v31 = v28;
LABEL_46:
        CFRelease(v31);
      }

      else
      {
LABEL_38:
        BOOL v8 = 0LL;
      }

    int v44 = 0LL;
LABEL_47:
    CFRange v40 = 0LL;
LABEL_48:
    if (v18) {
      CFRelease(v18);
    }
    if (v40) {
      CFRelease(v40);
    }
    goto LABEL_53;
  }

  int v44 = 0LL;
LABEL_54:
  if (values) {
    CFRelease(values);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (CertificateRequest) {
    CFRelease(CertificateRequest);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v44;
}

        uint64_t v10 = 0LL;
        goto LABEL_50;
      case 6:
        if (!v8)
        {
          secLogObjForScope("SecError");
          uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_49;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "defaultDeveloperIDLWCR";
          uint32_t v21 = "%s: signing identifier is NULL, cannot generate a LWCR";
          goto LABEL_48;
        }

        if (v4)
        {
          *(void *)&__int128 buf = &unk_18969C108;
          CFRange v40 = @"validation-category";
          CFRange v41 = @"signing-identifier";
          [NSString stringWithUTF8String:v8];
          uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          *((void *)&buf + 1) = v9;
          CFRange v42 = @"team-identifier";
          [NSString stringWithUTF8String:v4];
          char v18 = (uint64_t (*)(uint64_t, Security::CodeSigning::SecStaticCode *))objc_claimAutoreleasedReturnValue();
          CFMutableStringRef v32 = v18;
          uint64_t v10 = [MEMORY[0x189603F68] dictionaryWithObjects:&buf forKeys:&v40 count:3];

          goto LABEL_50;
        }

        secLogObjForScope("SecError");
        uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "defaultDeveloperIDLWCR";
          uint32_t v21 = "%s: team identifier is NULL, cannot generate a LWCR";
LABEL_48:
          _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&buf, 0xCu);
        }

CFStringRef copyStringEndingIn(__CFString *theString, const __CFString *a2)
{
  if (!a2) {
    return CFStringCreateCopy(0LL, theString);
  }
  CFIndex location = CFStringFind(theString, a2, 0LL).location;
  if (location == -1) {
    return 0LL;
  }
  CFIndex v4 = location;
  v8.CFIndex location = 0LL;
  v8.CFIndex length = location;
  CFStringRef v5 = CFStringCreateWithSubstring(0LL, theString, v8);
  v7.CFIndex length = v4 + 1;
  v7.CFIndex location = 0LL;
  CFStringDelete(theString, v7);
  return v5;
}

uint64_t SOSKVSKeyGetKeyTypeAndParse( const __CFString *a1, CFStringRef *a2, CFStringRef *a3, CFStringRef *a4, uint64_t a5, CFStringRef *a6, CFStringRef *a7)
{
  unsigned int KeyType = SOSKVSKeyGetKeyType(a1);
  if (SOSKVSKeyParse(KeyType, a1, a2, a3, a4, v14, a6, a7)) {
    return KeyType;
  }
  else {
    return 10LL;
  }
}

CFStringRef SOSCircleKeyCreateWithCircle(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0) {
    return CFStringCreateWithFormat(0LL, 0LL, @"%@%@", @"o", v1);
  }
  else {
    return 0LL;
  }
}

CFStringRef SOSRingKeyCreateWithName(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithFormat(0LL, 0LL, @"%@%@", @"~", result);
  }
  return result;
}

CFTypeRef SOSCircleKeyCopyCircleName(const __CFString *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0LL;
  int KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, (CFStringRef *)&cf, 0LL, 0LL, v5, 0LL, 0LL) || KeyType)
  {
    SOSCreateErrorWithFormat(1036LL, 0LL, a2, 0LL, @"Couldn't find circle name in key '%@'", a1);
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }

  return cf;
}

CFTypeRef SOSMessageKeyCopyCircleName(const __CFString *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0LL;
  int KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, (CFStringRef *)&cf, 0LL, 0LL, v5, 0LL, 0LL) || KeyType != 1)
  {
    SOSCreateErrorWithFormat(1036LL, 0LL, a2, 0LL, @"Couldn't find circle name in key '%@'", a1);
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }

  return cf;
}

CFTypeRef SOSMessageKeyCopyFromPeerName(const __CFString *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0LL;
  int KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, 0LL, 0LL, 0LL, v5, (CFStringRef *)&cf, 0LL) || KeyType != 1)
  {
    SOSCreateErrorWithFormat(1036LL, 0LL, a2, 0LL, @"Couldn't find from peer in key '%@'", a1);
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }

  return cf;
}

CFStringRef SOSMessageKeyCreateWithCircleNameAndPeerNames(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@%@", a1, @"|", a2, @":", a3);
}

CFStringRef SOSMessageKeyCreateWithCircleAndPeerNames(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v3 = 0LL;
  }
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@%@", v3, @"|", a2, @":", a3);
}

CFStringRef SOSMessageKeyCreateWithCircleAndPeerInfos(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 40);
    if (a3) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v4 = 0LL;
    if (a1) {
      goto LABEL_4;
    }
LABEL_7:
    uint64_t v5 = 0LL;
    return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@%@", v5, @"|", v3, @":", v4);
  }

  uint64_t v3 = 0LL;
  if (!a3) {
    goto LABEL_6;
  }
LABEL_3:
  uint64_t v4 = *(void *)(a3 + 40);
  if (!a1) {
    goto LABEL_7;
  }
LABEL_4:
  uint64_t v5 = *(void *)(a1 + 16);
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@%@", v5, @"|", v3, @":", v4);
}

CFStringRef SOSMessageKeyCreateFromPeerToTransport(void *a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat( 0,  0,  @"%@%@%@%@%@",  [a1 SOSTransportMessageGetCircleName],  @"|",  a3,  @":",  a2);
}

CFStringRef SOSMessageKeyCreateFromTransportToPeer(void *a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat( 0,  0,  @"%@%@%@%@%@",  [a1 SOSTransportMessageGetCircleName],  @"|",  a2,  @":",  a3);
}

CFStringRef SOSRetirementKeyCreateWithCircleNameAndPeer(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@", @"-", a1, @"|", a2);
}

CFStringRef SOSRingKeyCreateWithRingName(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@", @"~", a1);
}

CFStringRef SOSRetirementKeyCreateWithCircleAndPeer(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v2 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0LL;
  }
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@", @"-", v2, @"|", a2);
}

CFStringRef SOSLastKeyParametersPushedKeyCreateWithPeerID(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@", @"k", @">KeyParameters", @"|", a1);
}

CFStringRef SOSLastKeyParametersPushedKeyCreateWithAccountGestalt(void *a1)
{
  uint64_t v1 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  if (v1)
  {
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"{");
    v7[0] = 0LL;
    v7[1] = v7;
    unint64_t v7[2] = 0x2000000000LL;
    void v7[3] = &stru_1896794C8;
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 0x40000000LL;
    context[2] = __CFDictionaryCopySuperCompactDescription_block_invoke;
    context[3] = &unk_1896767B8;
    void context[4] = v7;
    void context[5] = MutableCopy;
    CFDictionaryApplyFunction(v1, (CFDictionaryApplierFunction)apply_block_2_13291, context);
    CFStringAppendFormat(MutableCopy, 0LL, @"}");
    _Block_object_dispose(v7, 8);
  }

  else
  {
    MutableCFDictionaryRef Copy = (__CFString *)CFCopyDescription((CFTypeRef)*MEMORY[0x189605018]);
  }

  CFStringRef v3 = CFStringCreateWithFormat(0LL, 0LL, @"%@", MutableCopy);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  CFStringRef v4 = CFStringCreateWithFormat(0LL, 0LL, @"%@%@%@%@", @"k", @">KeyParameters", @"|", v3);
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

CFStringRef SOSDebugInfoKeyCreateWithTypeName(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%@%@", @"dbg-", a1);
}

__CFString *SOSKeyedPubKeyIdentifierCreateWithData(const __CFString *a1, const __CFData *a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  CFStringRef v3 = SOSCopyIDOfDataBuffer(a2);
  CFStringRef v4 = v3;
  if (a1 && v3)
  {
    if (CFStringGetLength(a1) == 2)
    {
      MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 50LL, a1);
      CFStringAppend(MutableCopy, @"-");
      CFStringAppend(MutableCopy, v4);
LABEL_5:
      CFRelease(v4);
      return MutableCopy;
    }

CFStringRef SOSKeyedPubKeyIdentifierCopyPrefix(const __CFString *a1)
{
  v3.CFIndex location = 0LL;
  v3.CFIndex length = 2LL;
  return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x189604DB0], a1, v3);
}

CFTypeRef SecCFRetainForCollection(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void SecCFReleaseForCollection(int a1, CFTypeRef cf)
{
}

BOOL SOSPeerInfoIDEqual(void *a1, void *a2)
{
  IDOrString = GetIDOrString(a1);
  CFStringRef v4 = GetIDOrString(a2);
  if (IDOrString && v4) {
    return CFEqual(IDOrString, v4) != 0;
  }
  else {
    return IDOrString == v4;
  }
}

CFHashCode SOSPeerInfoIDHash(void *a1)
{
  IDOrString = GetIDOrString(a1);
  return CFHash(IDOrString);
}

void *GetIDOrString(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == SOSPeerInfoGetTypeID())
    {
      return (void *)v1[5];
    }

    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFStringGetTypeID()) {
        return v1;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

BOOL SOSPeerInfoSetContainsIdenticalPeers(CFTypeRef cf1, CFTypeRef cf2)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 1;
  if (!cf1 || !cf2)
  {
    if (cf1 == cf2) {
      goto LABEL_4;
    }
LABEL_6:
    BOOL v4 = 0LL;
    goto LABEL_7;
  }

  if (!CFEqual(cf1, cf2)) {
    goto LABEL_6;
  }
LABEL_4:
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  void v6[2] = __SOSPeerInfoSetContainsIdenticalPeers_block_invoke;
  void v6[3] = &unk_18966C5A8;
  void v6[4] = &v7;
  void v6[5] = cf2;
  CFSetApplyFunction((CFSetRef)cf1, (CFSetApplierFunction)apply_block_1_6637, v6);
  BOOL v4 = *((_BYTE *)v8 + 24) != 0;
LABEL_7:
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *__SOSPeerInfoSetContainsIdenticalPeers_block_invoke(uint64_t a1, const void *a2)
{
  Class result = CFSetGetValue(*(CFSetRef *)(a1 + 40), a2);
  if (a2 && result)
  {
    Class result = (const void *)CFEqual(a2, result);
    BOOL v5 = (_DWORD)result != 0;
  }

  else
  {
    BOOL v5 = result == a2;
  }

  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (!*(_BYTE *)(v6 + 24)) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(v6 + 24) = v5;
  return result;
}

uint64_t apply_block_1_6637(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableSetRef CFSetCreateMutableForSOSPeerInfosByID(const __CFAllocator *a1)
{
  return CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
}

CFMutableSetRef CFSetCreateMutableForSOSPeerInfosByIDWithArray(const __CFAllocator *a1, const __CFArray *a2)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0LL, &kSOSPeerSetCallbacks);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __CFSetCreateMutableForSOSPeerInfosByIDWithArray_block_invoke;
  context[3] = &__block_descriptor_tmp_1_6641;
  void context[4] = Mutable;
  v6.CFIndex length = CFArrayGetCount(a2);
  v6.CFIndex location = 0LL;
  CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)apply_block_1_6637, context);
  return Mutable;
}

void __CFSetCreateMutableForSOSPeerInfosByIDWithArray_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == SOSPeerInfoGetTypeID()) {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), cf);
    }
  }

void CFArrayOfSOSPeerInfosSortByID(const __CFArray *a1)
{
  if (a1)
  {
    if (CFArrayGetCount(a1) >= 1)
    {
      v2.CFIndex length = CFArrayGetCount(a1);
      v2.CFIndex location = 0LL;
      CFArraySortValues(a1, v2, (CFComparatorFunction)SOSPeerInfoCompareByID, 0LL);
    }
  }

__CFArray *SOSPeerInfoArrayCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable(a1, 0LL, MEMORY[0x189605228]);
  uint64_t v7 = ccder_decode_constructed_tl();
  *a3 = v7;
  if (!v7)
  {
    SOSCreateErrorWithFormat(1035LL, 0LL, a2, 0LL, @"%@", @"Bad Peer Info Array Sequence Header");
    if (!Mutable) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  if (v7 != 0xAAAAAAAAAAAAAAAALL)
  {
    while (1)
    {
      int v8 = (const void *)SOSPeerInfoCreateFromDER(a1, a2, a3);
      uint64_t v9 = v8;
      if (!v8) {
        break;
      }
      if (!*a3)
      {
        char v10 = v8;
        if (!a2) {
          goto LABEL_11;
        }
LABEL_9:
        SOSCreateErrorWithFormat(1035LL, (__CFString *)*a2, a2, 0LL, @"%@", @"Bad Peer Info Array DER");
        goto LABEL_12;
      }

      CFArrayAppendValue(Mutable, v8);
      CFRelease(v9);
      if (*a3 == 0xAAAAAAAAAAAAAAAALL) {
        goto LABEL_6;
      }
    }

    char v10 = 0LL;
    if (a2) {
      goto LABEL_9;
    }
LABEL_11:
    SOSCreateErrorWithFormat(1035LL, 0LL, 0LL, 0LL, @"%@", @"Bad Peer Info Array DER");
LABEL_12:
    if (v9) {
      CFRelease(v10);
    }
    if (!Mutable) {
      goto LABEL_16;
    }
LABEL_15:
    CFRelease(Mutable);
LABEL_16:
    CFMutableSetRef Mutable = 0LL;
    *a3 = 0LL;
    return Mutable;
  }

uint64_t SOSPeerInfoArrayGetDEREncodedSize(const __CFArray *a1, uint64_t a2)
{
  v10[0] = 0LL;
  v10[1] = v10;
  void v10[2] = 0x2000000000LL;
  unint64_t v10[3] = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 0;
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSPeerInfoArrayGetDEREncodedSize_block_invoke;
  context[3] = &unk_18966C620;
  void context[5] = v10;
  void context[6] = a2;
  void context[4] = &v6;
  v11.CFIndex length = CFArrayGetCount(a1);
  v11.CFIndex location = 0LL;
  CFArrayApplyFunction(a1, v11, (CFArrayApplierFunction)apply_block_1_6637, context);
  uint64_t v3 = 0LL;
  if (!*((_BYTE *)v7 + 24)) {
    uint64_t v3 = ccder_sizeof();
  }
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(v10, 8);
  return v3;
}

uint64_t __SOSPeerInfoArrayGetDEREncodedSize_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == SOSPeerInfoGetTypeID()))
  {
    uint64_t result = SOSPeerInfoGetDEREncodedSize((uint64_t)cf, *(CFTypeRef **)(a1 + 48), v5, v6, v7, v8, v9, v10);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result == 0;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += result;
  }

  else
  {
    id v12 = *(__CFString ***)(a1 + 48);
    if (v12) {
      uint64_t result = SOSCreateErrorWithFormat( 1040LL,  *v12,  (CFTypeRef *)v12,  0LL,  @"%@",  @"Non SOSPeerInfo in array");
    }
    else {
      uint64_t result = SOSCreateErrorWithFormat(1040LL, 0LL, 0LL, 0LL, @"%@", @"Non SOSPeerInfo in array");
    }
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  return result;
}

uint64_t SOSPeerInfoArrayEncodeToDER(const __CFArray *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = a4;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  CFRange v11 = __SOSPeerInfoArrayEncodeToDER_block_invoke;
  id v12 = &unk_18966C648;
  uint32_t v13 = &v16;
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    unint64_t v6 = Count + 1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v6 - 2);
      v11((uint64_t)v10, ValueAtIndex);
      --v6;
    }

    while (v6 > 1);
  }

  if (v17[3]) {
    uint64_t v8 = ccder_encode_constructed_tl();
  }
  else {
    uint64_t v8 = 0LL;
  }
  _Block_object_dispose(&v16, 8);
  return v8;
}

uint64_t __SOSPeerInfoArrayEncodeToDER_block_invoke(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  uint64_t result = SOSPeerInfoGetTypeID();
  if (v4 != result)
  {
    uint64_t result = SOSCreateErrorWithFormat( 1040LL,  0LL,  *(CFTypeRef **)(a1 + 40),  0LL,  @"%@",  @"Non SOSPeerInfo in array");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v10)
  {
    uint64_t result = SOSPeerInfoEncodeToDER((uint64_t)cf, *(CFTypeRef **)(a1 + 40), *(UInt8 **)(a1 + 48), v10, v6, v7, v8, v9);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

CFMutableSetRef SOSPeerInfoSetCreateFromArrayDER( const __CFAllocator *a1, const CFSetCallBacks *a2, CFTypeRef *a3, uint64_t *a4)
{
  uint64_t v6 = SOSPeerInfoArrayCreateFromDER(a1, a3, a4);
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0LL, a2);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __CFSetSetValues_block_invoke;
  context[3] = &__block_descriptor_tmp_14_6652;
  void context[4] = Mutable;
  v11.CFIndex length = CFArrayGetCount(v7);
  v11.CFIndex location = 0LL;
  CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)apply_block_1_6637, context);
  CFRelease(v7);
  return Mutable;
}

void __CFSetSetValues_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t SOSPeerInfoSetGetDEREncodedArraySize(const __CFSet *a1, uint64_t a2)
{
  v9[0] = 0LL;
  v9[1] = v9;
  void v9[2] = 0x2000000000LL;
  void v9[3] = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SOSPeerInfoSetGetDEREncodedArraySize_block_invoke;
  context[3] = &unk_18966C670;
  void context[5] = v9;
  void context[6] = a2;
  void context[4] = &v5;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6637, context);
  uint64_t v2 = 0LL;
  if (!*((_BYTE *)v6 + 24)) {
    uint64_t v2 = ccder_sizeof();
  }
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(v9, 8);
  return v2;
}

uint64_t __SOSPeerInfoSetGetDEREncodedArraySize_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == SOSPeerInfoGetTypeID()))
  {
    uint64_t result = SOSPeerInfoGetDEREncodedSize((uint64_t)cf, *(CFTypeRef **)(a1 + 48), v5, v6, v7, v8, v9, v10);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result == 0;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += result;
  }

  else
  {
    id v12 = *(__CFString ***)(a1 + 48);
    if (v12) {
      uint64_t result = SOSCreateErrorWithFormat( 1040LL,  *v12,  (CFTypeRef *)v12,  0LL,  @"%@",  @"Non SOSPeerInfo in array");
    }
    else {
      uint64_t result = SOSCreateErrorWithFormat(1040LL, 0LL, 0LL, 0LL, @"%@", @"Non SOSPeerInfo in array");
    }
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  return result;
}

uint64_t SOSPeerInfoSetEncodeToArrayDER(const __CFSet *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __CFSetCopyValues_block_invoke;
  context[3] = &__block_descriptor_tmp_15_6658;
  void context[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6637, context);
  CFArrayOfSOSPeerInfosSortByID(Mutable);
  uint64_t v9 = SOSPeerInfoArrayEncodeToDER(Mutable, a2, a3, a4);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v9;
}

void __CFSetCopyValues_block_invoke(uint64_t a1, const void *a2)
{
}

__CFArray *CreateArrayOfPeerInfoWithXPCObject( void *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v10 = (const __CFString *)sSecXPCErrorDomain;
    CFRange v11 = @"Unexpected Null Array to encode";
    CFIndex v12 = 2LL;
    goto LABEL_5;
  }

  if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9240])
  {
    uint64_t v10 = (const __CFString *)sSecXPCErrorDomain;
    CFRange v11 = @"Array of peer info not data";
    CFIndex v12 = 1LL;
LABEL_5:
    SecCFCreateErrorWithFormat(v12, v10, 0LL, a2, a5, v11, a7, a8, v14);
    return 0LL;
  }

  bytes_ptr = xpc_data_get_bytes_ptr(a1);
  xpc_data_get_length(a1);
  return SOSPeerInfoArrayCreateFromDER((const __CFAllocator *)*MEMORY[0x189604DB0], a2, (uint64_t *)&bytes_ptr);
}

int64_t CreateXPCObjectWithArrayOfPeerInfo(const __CFArray *a1, uint64_t a2)
{
  DEREncodedCFIndex Size = SOSPeerInfoArrayGetDEREncodedSize(a1, a2);
  int64_t v5 = DEREncodedSize;
  if (DEREncodedSize)
  {
    uint64_t v6 = malloc(DEREncodedSize);
    if (v6)
    {
      uint64_t v7 = v6;
      else {
        int64_t v5 = 0LL;
      }
      free(v7);
    }

    else
    {
      return 0LL;
    }
  }

  return v5;
}

uint64_t SOSPeerInfoGetDEREncodedSize( uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (der_sizeof_plist(*(const __CFString **)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
    {
      CFDataGetLength(*(CFDataRef *)(a1 + 24));
      if (ccder_sizeof_raw_octet_string()) {
        return ccder_sizeof();
      }
      CFRange v11 = @"Peer not signed to encode";
    }

    else
    {
      CFRange v11 = @"No Description to encode";
    }
  }

  else
  {
    CFRange v11 = @"No PeerInfo to encode";
  }

  SOSCreateErrorWithFormat(1045LL, 0LL, a2, 0LL, @"%@", v11);
  return 0LL;
}

uint64_t SOSPeerInfoEncodeToDER( uint64_t a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    CFRange v11 = *(const __CFString **)(a1 + 16);
    unint64_t v12 = der_encode_data(*(const __CFData **)(a1 + 24), a2);
    der_encode_plist_repair(v11, a2, 0LL, a3, v12, v13, v14, v15);
    return ccder_encode_constructed_tl();
  }

  else
  {
    SOSCreateErrorWithFormat(1045LL, 0LL, a2, 0LL, @"%@", @"No PeerInfo to encode");
    return 0LL;
  }

__CFData *SOSPeerInfoCopyEncodedData( uint64_t a1, int a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    DEREncodedCFIndex Size = SOSPeerInfoGetDEREncodedSize(a1, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    void v13[2] = __SOSPeerInfoCopyEncodedData_block_invoke;
    void v13[3] = &__block_descriptor_48_e11__24__0Q8_16l;
    v13[4] = a1;
    v13[5] = a3;
    return CFDataCreateWithDER(v10, DEREncodedSize, v13);
  }

  else
  {
    SOSCreateErrorWithFormat(1045LL, 0LL, a3, 0LL, @"%@", @"No PeerInfo to encode");
    return 0LL;
  }

uint64_t __SOSPeerInfoCopyEncodedData_block_invoke( uint64_t a1, uint64_t a2, UInt8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SOSPeerInfoEncodeToDER(*(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40), a3, (uint64_t)&a3[a2], a5, a6, a7, a8);
}

uint64_t SOSPeerInfoCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  SOSPeerInfoGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFTypeRef cf = 0LL;
  CFRange v40 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
  *(void *)(Instance + 32) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  uint64_t v7 = ccder_decode_constructed_tl();
  *a3 = v7;
  uint64_t v11 = der_decode_plist((uint64_t)a1, (uint64_t)&cf, a2, v7, (uint64_t)v40, v8, v9, v10);
  *a3 = v11;
  uint64_t v15 = der_decode_data(a1, (CFDataRef *)(Instance + 24), a2, v11, (uint64_t)v40, v12, v13, v14);
  *a3 = v15;
  if (v15) {
    BOOL v16 = v15 == v40;
  }
  else {
    BOOL v16 = 0;
  }
  if (!v16)
  {
    SOSCreateErrorWithFormat(1035LL, 0LL, a2, 0LL, @"%@", @"Bad Format of Peer Info DER");
    CFTypeRef v17 = cf;
    goto LABEL_20;
  }

  CFTypeRef v17 = cf;
  CFTypeID v18 = CFGetTypeID(cf);
  if (v18 == CFDictionaryGetTypeID())
  {
    *(void *)(Instance + 16) = v17;
    CFRetain(v17);
    if (v17)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v17);
    }

    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(Instance + 16), @"ConflictVersion");
    if (Value)
    {
      CFStringRef v20 = Value;
      CFTypeID v21 = CFGetTypeID(Value);
      if (v21 != CFNumberGetTypeID())
      {
        CFTypeID v33 = CFGetTypeID(v20);
        CFStringRef v34 = CFCopyTypeIDDescription(v33);
        SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"Expected (version) number got %@", v34);
        goto LABEL_25;
      }

      CFNumberGetValue((CFNumberRef)v20, kCFNumberCFIndexType, (void *)(Instance + 56));
    }

    CFStringRef v22 = CFDictionaryGetValue(*(CFDictionaryRef *)(Instance + 16), @"DeviceGestalt");
    if (!v22)
    {
      SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"gestalt key missing");
      goto LABEL_27;
    }

    int v23 = v22;
    CFTypeID v24 = CFGetTypeID(v22);
    if (v24 == CFDictionaryGetTypeID())
    {
      *(void *)(Instance + 32) = v23;
      CFRetain(v23);
      CFIndex v25 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)Instance, @"PublicSigningKey", a2);
      if (v25)
      {
        CFTypeRef v17 = v25;
        uint64_t v26 = SOSCopyIDOfKey((uint64_t)v25, a2);
        *(void *)(Instance + 40) = v26;
        if (v26)
        {
          CFStringRef v27 = v26;
          CFIndex Length = CFStringGetLength(v26);
          CFStringRef v29 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          if (Length > 8)
          {
            v44.CFIndex location = 0LL;
            v44.CFIndex length = 8LL;
            CFStringRef Copy = CFStringCreateWithSubstring(v29, v27, v44);
          }

          else
          {
            CFStringRef Copy = CFStringCreateCopy(v29, v27);
          }

          *(void *)(Instance + 4_Block_object_dispose(va, 8) = Copy;
          if ((SOSPeerInfoVerify((CFDictionaryRef *)Instance, a2) & 1) != 0) {
            goto LABEL_29;
          }
          SOSCreateErrorWithFormat(1038LL, 0LL, a2, 0LL, @"Signature doesn't validate");
          if (a2)
          {
            secLogObjForScope("SecError");
            CFMutableStringRef v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              CFTypeRef v38 = *a2;
              *(_DWORD *)__int128 buf = 138412290;
              CFTypeRef v42 = v38;
              _os_log_impl(&dword_1804F4000, v37, OS_LOG_TYPE_DEFAULT, "Can't validate PeerInfo: %@", buf, 0xCu);
            }
          }
        }

        CFRelease((CFTypeRef)Instance);
        goto LABEL_28;
      }

uint64_t SOSPeerInfoCreateFromData(int a1, CFTypeRef *a2, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  return SOSPeerInfoCreateFromDER(0LL, a2, &BytePtr);
}

BOOL SOSPeerInfoSerialNumberIsSet(uint64_t a1)
{
  CFMutableStringRef v1 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sSerialNumberKey);
  CFMutableStringRef v2 = v1;
  if (v1) {
    CFRelease(v1);
  }
  return v2 != 0LL;
}

CFMutableStringRef SOSPeerInfoV2DictionaryCopyString(uint64_t a1, const void *a2)
{
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value) {
    return 0LL;
  }
  int64_t v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID()) {
    return 0LL;
  }
  uint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Length = CFStringGetLength(v5);
  return CFStringCreateMutableCopy(v7, Length, v5);
}

uint64_t SOSPeerInfoExpandV2Data(uint64_t result, CFTypeRef *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_BYTE *)(result + 73)) {
      return 1LL;
    }
    if (*(void *)(result + 80)) {
      goto LABEL_6;
    }
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), (const void *)sV2DictionaryKey);
    if (!Value || (int64_t v5 = Value, v6 = CFGetTypeID(Value), v6 != CFDataGetTypeID()))
    {
      CFTypeID v18 = @"No V2 Data in description";
LABEL_25:
      SOSCreateErrorWithFormat(1029LL, 0LL, a2, 0LL, @"%@", v18);
      return 0LL;
    }

    CFTypeRef cf = 0LL;
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == CFDataGetTypeID())
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v5);
      CFIndex Length = CFDataGetLength((CFDataRef)v5);
      uint64_t v10 = &BytePtr[Length];
      uint64_t v14 = der_decode_plist(0LL, (uint64_t)&cf, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v11, v12, v13);
      if (v14 && (const UInt8 *)v14 == v10)
      {
        CFTypeRef v15 = cf;
        CFTypeID v16 = CFGetTypeID(cf);
        if (v16 == CFDictionaryGetTypeID())
        {
          if (v15)
          {
            CFTypeRef v17 = *(const void **)(v2 + 80);
            if (v17)
            {
              *(void *)(v2 + 80) = 0LL;
              CFRelease(v17);
            }

            *(void *)(v2 + 80) = v15;
LABEL_6:
            uint64_t result = 1LL;
            *(_BYTE *)(v2 + 73) = 1;
            return result;
          }

          goto LABEL_24;
        }

        CFTypeID v19 = CFGetTypeID(v15);
        CFStringRef v20 = CFCopyTypeIDDescription(v19);
        SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"Expected dictionary got %@", v20);
        if (v20) {
          CFRelease(v20);
        }
      }

      else
      {
        SOSCreateErrorWithFormat(1035LL, 0LL, a2, 0LL, @"%@", @"Bad Format of Dictionary DER");
        CFTypeRef v15 = cf;
      }

      if (v15) {
        CFRelease(v15);
      }
    }

    else
    {
      SOSCreateErrorWithFormat(1035LL, 0LL, a2, 0LL, @"%@", @"Corrupted v2Data Item");
    }

void SOSPeerInfoSetSerialNumber(uint64_t a1)
{
  if (!SOSGestaltSerial)
  {
    uint64_t v2 = (const void *)MGCopyAnswer();
    if (!v2)
    {
      SOSCreateErrorWithFormat(1024LL, 0LL, 0LL, 0LL, @"%@", @"No Memory");
      return;
    }

void SOSPeerInfoV2DictionarySetValue(uint64_t a1, const void *a2, const void *a3)
{
  if (SOSPeerInfoExpandV2Data(a1, 0LL))
  {
    CFTypeID v6 = *(__CFDictionary **)(a1 + 80);
    if (a3) {
      CFDictionarySetValue(v6, a2, a3);
    }
    else {
      CFDictionaryRemoveValue(v6, a2);
    }
  }

void SOSPeerInfoSetTestSerialNumber(uint64_t a1, const void *a2)
{
  if (a2) {
    SOSPeerInfoV2DictionarySetValue(a1, (const void *)sSerialNumberKey, a2);
  }
}

CFMutableStringRef SOSPeerInfoCopySerialNumber(uint64_t a1)
{
  CFMutableStringRef result = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sSerialNumberKey);
  if (!result) {
    return (CFMutableStringRef)CFRetain(@"Unknown");
  }
  return result;
}

BOOL SOSPeerInfoUpdateToV2(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  *(void *)(a1 + 56) = 3LL;
  uint64_t valuePtr = 3LL;
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"ConflictVersion", v4);
  if (v4) {
    CFRelease(v4);
  }
  *(_BYTE *)(a1 + 73) = 0;
  CFMutableSetRef Mutable = CFDictionaryCreateMutable(0LL, 2LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFMutableSetRef v6 = SOSViewCopyViewSet(1u);
  CFMutableSetRef v7 = CFSetCreateMutable(0LL, 0LL, MEMORY[0x189605258]);
  CFDictionaryAddValue(Mutable, (const void *)sViewsKey, v6);
  CFDataRef v14 = SOSCreateDERFromDictionary((const __CFString *)Mutable, a2, v8, v9, v10, v11, v12, v13);
  BOOL v15 = v14 != 0LL;
  if (!v14)
  {
    SOSCreateErrorWithFormat(1024LL, 0LL, a2, 0LL, @"%@", @"No Memory");
    if (!v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), (const void *)sV2DictionaryKey, v14);
  SOSPeerInfoSetSerialNumber(a1);
  SOSPeerInfoExpandV2Data(a1, a2);
  if (v6) {
LABEL_6:
  }
    CFRelease(v6);
LABEL_7:
  if (v14) {
    CFRelease(v14);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v15;
}

CFDataRef SOSCreateDERFromDictionary( const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10 = der_sizeof_plist(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    CFIndex v11 = v10;
    uint64_t v12 = (UInt8 *)malloc(v10);
    if (v12)
    {
      CFTypeID v16 = v12;
      if (der_encode_plist_repair(a1, a2, 0LL, v12, (unint64_t)&v12[v11], v13, v14, v15)) {
        return CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  v16,  v11,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
      }
      free(v16);
    }
  }

  return 0LL;
}

void SOSPeerInfoPackV2Data( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(uint64_t *)(a1 + 56) >= 2)
    {
      uint64_t v9 = *(const __CFString **)(a1 + 80);
      if (v9)
      {
        CFDataRef v10 = SOSCreateDERFromDictionary(v9, 0LL, a3, a4, a5, a6, a7, a8);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), (const void *)sV2DictionaryKey, v10);
        if (v10) {
          CFRelease(v10);
        }
      }
    }
  }

void SOSPeerInfoV2DictionaryRemoveValue(uint64_t a1, const void *a2)
{
}

uint64_t SOSPeerInfoV2DictionaryHasBoolean(uint64_t a1, const void *a2)
{
  uint64_t result = SOSPeerInfoExpandV2Data(a1, 0LL);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    uint64_t result = 0;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFBooleanGetTypeID()) {
        return 1;
      }
    }
  }

  return result;
}

BOOL SOSPeerInfoV2DictionaryHasStringValue(uint64_t a1, const void *a2, const void *a3)
{
  AsString = SOSPeerInfoV2DictionaryGetAsString(a1, a2);
  if (a3 && AsString) {
    return CFEqual(AsString, a3) != 0;
  }
  else {
    return AsString == a3;
  }
}

const void *SOSPeerInfoV2DictionaryGetAsString(uint64_t a1, const void *a2)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value) {
    return 0LL;
  }
  int64_t v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID()) {
    return 0LL;
  }
  return v5;
}

CFStringRef SOSPeerInfoV2DictionaryHasString(uint64_t a1, const void *a2)
{
  uint64_t result = (const __CFString *)SOSPeerInfoV2DictionaryGetAsString(a1, a2);
  if (result) {
    return (const __CFString *)(CFStringGetLength(result) > 0);
  }
  return result;
}

uint64_t SOSPeerInfoV2DictionaryHasSet(uint64_t a1, const void *a2)
{
  uint64_t result = SOSPeerInfoExpandV2Data(a1, 0LL);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    uint64_t result = 0;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFSetGetTypeID()) {
        return 1;
      }
    }
  }

  return result;
}

uint64_t SOSPeerInfoV2DictionaryHasData(uint64_t a1, const void *a2)
{
  uint64_t result = SOSPeerInfoExpandV2Data(a1, 0LL);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    uint64_t result = 0;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFDataGetTypeID()) {
        return 1;
      }
    }
  }

  return result;
}

void SOSPeerInfoV2DictionaryWithSet(uint64_t a1, const void *a2, void *a3)
{
  id v5 = a3;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  CFIndex v11 = __SOSPeerInfoV2DictionaryWithSet_block_invoke;
  uint64_t v12 = &unk_18966C708;
  id v6 = v5;
  id v13 = v6;
  CFMutableSetRef v7 = v10;
  if (SOSPeerInfoExpandV2Data(a1, 0LL))
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (Value)
    {
      uint64_t v9 = Value;
      CFRetain(Value);
      v11((CFTypeID)v7, v9);
      CFRelease(v9);
    }

    else
    {
      v11((CFTypeID)v7, 0LL);
    }
  }
}

CFTypeID __SOSPeerInfoV2DictionaryWithSet_block_invoke(CFTypeID result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(cf);
    uint64_t result = CFSetGetTypeID();
    if (v3 == result) {
      return (*(uint64_t (**)(void))(*(void *)(v2 + 32) + 16LL))();
    }
  }

  return result;
}

CFMutableSetRef SOSPeerInfoV2DictionaryCopySet(uint64_t a1, const void *a2)
{
  Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value) {
    return 0LL;
  }
  id v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFSetGetTypeID()) {
    return 0LL;
  }
  CFMutableSetRef v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Count = CFSetGetCount(v5);
  return CFSetCreateMutableCopy(v7, Count, v5);
}

void SOSPeerInfoV2DictionaryForEachSetValue(uint64_t a1, const void *a2, void *a3)
{
  id context = a3;
  if (SOSPeerInfoExpandV2Data(a1, 0LL))
  {
    Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (Value)
    {
      CFTypeID v6 = Value;
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFSetGetTypeID()) {
        CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_6748, context);
      }
    }
  }
}

uint64_t apply_block_1_6748(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFSetRef SOSPeerInfoV2DictionaryHasSetContaining(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t result = (const __CFSet *)SOSPeerInfoExpandV2Data(a1, 0LL);
  if ((_DWORD)result)
  {
    uint64_t result = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (result)
    {
      CFTypeID v7 = result;
      CFTypeID v8 = CFGetTypeID(result);
      if (v8 == CFSetGetTypeID()) {
        return (const __CFSet *)(CFSetContainsValue(v7, a3) != 0);
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

CFMutableDataRef SOSPeerInfoV2DictionaryCopyData(uint64_t a1, const void *a2)
{
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value) {
    return 0LL;
  }
  id v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID()) {
    return 0LL;
  }
  CFTypeID v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Length = CFDataGetLength(v5);
  return CFDataCreateMutableCopy(v7, Length, v5);
}

const void *SOSPeerInfoV2DictionaryCopyBoolean(uint64_t a1, const void *a2)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  id v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      CFRetain(v5);
      return v5;
    }

    return 0LL;
  }

  return v5;
}

CFMutableDictionaryRef SOSPeerInfoV2DictionaryCopyDictionary(uint64_t a1, const void *a2)
{
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value) {
    return 0LL;
  }
  id v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFDictionaryGetTypeID()) {
    return 0LL;
  }
  CFTypeID v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Count = CFDictionaryGetCount(v5);
  return CFDictionaryCreateMutableCopy(v7, Count, v5);
}

const void *SOSPeerInfoCopyWithV2DictionaryUpdate( uint64_t a1, uint64_t a2, const __CFDictionary *a3, __SecKey *a4, CFTypeRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy = SOSPeerInfoCreateCopy( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  a5,  (uint64_t)a4,  (uint64_t)a5,  a6,  a7,  a8);
  uint64_t v12 = (const void *)Copy;
  if (Copy)
  {
    if ((SOSPeerInfoExpandV2Data(Copy, a5) & 1) == 0
      || (context[0] = MEMORY[0x1895F87A8],
          context[1] = 3221225472LL,
          context[2] = __SOSPeerInfoCopyWithV2DictionaryUpdate_block_invoke,
          context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l,
          void context[4] = v12,
          CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)apply_block_2_6753, context),
          SOSPeerInfoPackV2Data((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19),
          (SOSPeerInfoSign(a4, (uint64_t)v12, a5) & 1) == 0))
    {
      CFRelease(v12);
      return 0LL;
    }
  }

  return v12;
}

void __SOSPeerInfoCopyWithV2DictionaryUpdate_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t apply_block_2_6753(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFMutableSetRef SOSViewCopyViewSet(unsigned int a1)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605258]);
  CFNumberRef v4 = Mutable;
  if ((a1 | 4) == 4)
  {
    CFSetAddValue(Mutable, @"WiFi");
    CFSetAddValue(v4, @"Passwords");
    CFSetAddValue(v4, @"CreditCards");
  }

  if (a1 > 5 || a1 == 2 || (CFSetAddValue(v4, @"iCloudIdentity"), a1 > 4))
  {
LABEL_10:
    if (a1 >= 2 && a1 != 3)
    {
      if (a1 == 6)
      {
        CFSetAddValue(v4, @"Engram");
        CFSetAddValue(v4, @"Manatee");
        CFSetAddValue(v4, @"AutoUnlock");
        CFSetAddValue(v4, @"Health");
        CFSetAddValue(v4, @"ApplePay");
        CFSetAddValue(v4, @"Home");
        CFSetAddValue(v4, @"LimitedPeersAllowed");
        CFSetAddValue(v4, @"MFi");
        CFSetAddValue(v4, @"Mail");
        CFSetAddValue(v4, @"Contacts");
        CFSetAddValue(v4, @"Photos");
        CFTypeID v6 = @"Groups";
        goto LABEL_26;
      }

      if (a1 != 5) {
        goto LABEL_16;
      }
    }

    CFSetAddValue(v4, @"PCS-Escrow");
    if (a1 != 5)
    {
      CFSetAddValue(v4, @"PCS-FDE");
      CFSetAddValue(v4, @"PCS-Feldspar");
      CFSetAddValue(v4, @"PCS-Maildrop");
      CFSetAddValue(v4, @"PCS-MasterKey");
      CFSetAddValue(v4, @"PCS-Notes");
      CFSetAddValue(v4, @"PCS-Photos");
      CFSetAddValue(v4, @"PCS-Sharing");
      CFSetAddValue(v4, @"PCS-Backup");
      CFSetAddValue(v4, @"PCS-iCloudDrive");
      CFSetAddValue(v4, @"PCS-iMessage");
      CFSetAddValue(v4, @"NanoRegistry");
      CFSetAddValue(v4, @"WatchMigration");
      goto LABEL_16;
    }

    CFTypeID v6 = @"PCS-MasterKey";
LABEL_26:
    CFSetAddValue(v4, v6);
    return v4;
  }

  CFSetAddValue(v4, @"BackupBagV0");
  switch(a1)
  {
    case 0u:
    case 4u:
      CFSetAddValue(v4, @"OtherSyncable");
      if (a1 > 3) {
        goto LABEL_16;
      }
      break;
    case 1u:
    case 3u:
      break;
    default:
      goto LABEL_10;
  }

  CFSetAddValue(v4, @"ContinuityUnlock");
  if (a1 <= 3)
  {
    CFSetAddValue(v4, @"AppleTV");
    CFSetAddValue(v4, @"HomeKit");
    CFSetAddValue(v4, @"AccessoryPairing");
    CFSetAddValue(v4, @"PCS-CloudKit");
    goto LABEL_10;
  }

void __CFSetUnion_block_invoke_6846(uint64_t a1, const void *a2)
{
}

uint64_t apply_block_1_6847(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t SOSViewInSOSSystem(uint64_t result)
{
  if (result)
  {
    CFMutableStringRef v1 = (const void *)result;
    if (CFEqual((CFTypeRef)result, @"KeychainV0")
      || CFEqual(v1, @"WiFi")
      || CFEqual(v1, @"Passwords")
      || CFEqual(v1, @"CreditCards")
      || CFEqual(v1, @"iCloudIdentity")
      || CFEqual(v1, @"BackupBagV0")
      || CFEqual(v1, @"OtherSyncable")
      || CFEqual(v1, @"ContinuityUnlock")
      || CFEqual(v1, @"AppleTV")
      || CFEqual(v1, @"HomeKit")
      || CFEqual(v1, @"AccessoryPairing")
      || CFEqual(v1, @"PCS-CloudKit")
      || CFEqual(v1, @"PCS-Escrow")
      || CFEqual(v1, @"PCS-FDE")
      || CFEqual(v1, @"PCS-Feldspar")
      || CFEqual(v1, @"PCS-Maildrop")
      || CFEqual(v1, @"PCS-MasterKey")
      || CFEqual(v1, @"PCS-Notes")
      || CFEqual(v1, @"PCS-Photos")
      || CFEqual(v1, @"PCS-Sharing")
      || CFEqual(v1, @"PCS-Backup")
      || CFEqual(v1, @"PCS-iCloudDrive")
      || CFEqual(v1, @"PCS-iMessage")
      || CFEqual(v1, @"NanoRegistry")
      || CFEqual(v1, @"WatchMigration"))
    {
      return 1LL;
    }

    else
    {
      if (!CFEqual(v1, @"Engram")
        && !CFEqual(v1, @"Manatee")
        && !CFEqual(v1, @"AutoUnlock")
        && !CFEqual(v1, @"Health")
        && !CFEqual(v1, @"ApplePay")
        && !CFEqual(v1, @"Home")
        && !CFEqual(v1, @"LimitedPeersAllowed")
        && !CFEqual(v1, @"MFi")
        && !CFEqual(v1, @"Mail")
        && !CFEqual(v1, @"Contacts")
        && !CFEqual(v1, @"Photos"))
      {
        CFEqual(v1, @"Groups");
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t SOSViewHintInSOSSystem(uint64_t result)
{
  if (result)
  {
    CFMutableStringRef v1 = (const void *)result;
    if (CFEqual((CFTypeRef)result, @"ContinuityUnlock")
      || CFEqual(v1, @"AppleTV")
      || CFEqual(v1, @"HomeKit")
      || CFEqual(v1, @"AccessoryPairing")
      || CFEqual(v1, @"PCS-CloudKit")
      || CFEqual(v1, @"PCS-Escrow")
      || CFEqual(v1, @"PCS-FDE")
      || CFEqual(v1, @"PCS-Feldspar")
      || CFEqual(v1, @"PCS-Maildrop")
      || CFEqual(v1, @"PCS-MasterKey")
      || CFEqual(v1, @"PCS-Notes")
      || CFEqual(v1, @"PCS-Photos")
      || CFEqual(v1, @"PCS-Sharing")
      || CFEqual(v1, @"PCS-Backup")
      || CFEqual(v1, @"PCS-iCloudDrive")
      || CFEqual(v1, @"PCS-iMessage")
      || CFEqual(v1, @"NanoRegistry")
      || CFEqual(v1, @"WatchMigration"))
    {
      return 1LL;
    }

    else
    {
      if (!CFEqual(v1, @"Engram")
        && !CFEqual(v1, @"Manatee")
        && !CFEqual(v1, @"AutoUnlock")
        && !CFEqual(v1, @"Health")
        && !CFEqual(v1, @"ApplePay")
        && !CFEqual(v1, @"Home")
        && !CFEqual(v1, @"LimitedPeersAllowed")
        && !CFEqual(v1, @"MFi")
        && !CFEqual(v1, @"Mail")
        && !CFEqual(v1, @"Contacts")
        && !CFEqual(v1, @"Photos"))
      {
        CFEqual(v1, @"Groups");
      }

      return 0LL;
    }
  }

  return result;
}

unint64_t SOSViewHintInCKKSSystem(unint64_t result)
{
  if (result)
  {
    CFMutableStringRef v1 = (const void *)result;
    return CFEqual((CFTypeRef)result, @"Engram")
        || CFEqual(v1, @"Manatee")
        || CFEqual(v1, @"AutoUnlock")
        || CFEqual(v1, @"Health")
        || CFEqual(v1, @"ApplePay")
        || CFEqual(v1, @"Home")
        || CFEqual(v1, @"LimitedPeersAllowed")
        || CFEqual(v1, @"MFi")
        || CFEqual(v1, @"Mail")
        || CFEqual(v1, @"Contacts")
        || CFEqual(v1, @"Photos")
        || CFEqual(v1, @"Groups") != 0;
  }

  return result;
}

uint64_t SOSViewsGetV0ViewSet()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSViewsGetV0ViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetSingleton;
  if (SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetOnce != -1) {
    dispatch_once(&SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetOnce, block);
  }
  return SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetSingleton;
}

CFSetRef __SOSViewsGetV0ViewSet_block_invoke(uint64_t a1)
{
  v3[1] = *(const void **)MEMORY[0x1895F89C0];
  v3[0] = @"KeychainV0";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v3, 1LL, MEMORY[0x189605258]);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SOSViewsGetV0SubviewSet()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSViewsGetV0SubviewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetSingleton;
  if (SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetOnce != -1) {
    dispatch_once(&SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetOnce, block);
  }
  return SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetSingleton;
}

CFMutableSetRef __SOSViewsGetV0SubviewSet_block_invoke(uint64_t a1)
{
  CFMutableSetRef result = SOSViewCopyViewSet(4u);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SOSViewsGetUserVisibleSet()
{
  if (SOSViewsGetUserVisibleSet_onceToken != -1) {
    dispatch_once(&SOSViewsGetUserVisibleSet_onceToken, &__block_literal_global_6848);
  }
  return SOSViewsGetUserVisibleSet_subViewSet;
}

void __SOSViewsGetUserVisibleSet_block_invoke()
{
  SOSViewsGetUserVisibleSet_subViewSet = (uint64_t)SOSViewCopyViewSet(4u);
  CFSetRemoveValue((CFMutableSetRef)SOSViewsGetUserVisibleSet_subViewSet, @"iCloudIdentity");
  CFSetRemoveValue((CFMutableSetRef)SOSViewsGetUserVisibleSet_subViewSet, @"BackupBagV0");
}

uint64_t SOSViewsGetV0BackupViewSet()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSViewsGetV0BackupViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetSingleton;
  if (SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetOnce != -1) {
    dispatch_once(&SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetOnce, block);
  }
  return SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetSingleton;
}

CFSetRef __SOSViewsGetV0BackupViewSet_block_invoke(uint64_t a1)
{
  v3[1] = *(const void **)MEMORY[0x1895F89C0];
  v3[0] = @"KeychainV0-tomb";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v3, 1LL, MEMORY[0x189605258]);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SOSViewsGetV0BackupBagViewSet()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SOSViewsGetV0BackupBagViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetSingleton;
  if (SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetOnce != -1) {
    dispatch_once(&SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetOnce, block);
  }
  return SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetSingleton;
}

CFSetRef __SOSViewsGetV0BackupBagViewSet_block_invoke(uint64_t a1)
{
  v3[1] = *(const void **)MEMORY[0x1895F89C0];
  v3[0] = @"BackupBagV0-tomb";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v3, 1LL, MEMORY[0x189605258]);
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL SOSViewsIsV0Subview(const void *a1)
{
  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return CFSetContainsValue(V0SubviewSet, a1) != 0;
}

void SOSViewsSetTestViewsSet(CFTypeRef cf)
{
  uint64_t v2 = (const void *)sTestViewSet;
  if (sTestViewSet)
  {
    sTestViewSet = 0LL;
    CFRelease(v2);
  }

  if (cf) {
    sTestViewSet = (uint64_t)CFRetain(cf);
  }
  CFTypeID v3 = (const void *)sosAllViews;
  if (sosAllViews)
  {
    sosAllViews = 0LL;
    CFRelease(v3);
  }

  sosAllViews = (uint64_t)SOSViewCopyViewSet(0);
  CFSetAddValue((CFMutableSetRef)sosAllViews, @"KeychainV0");
  if (sTestViewSet)
  {
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __CFSetUnion_block_invoke_6846;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    void context[4] = sosAllViews;
    CFSetApplyFunction((CFSetRef)sTestViewSet, (CFSetApplierFunction)apply_block_1_6847, context);
  }

uint64_t SOSViewsGetAllCurrent()
{
  if (SOSViewsGetAllCurrent_dot != -1) {
    dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6849);
  }
  return sosAllViews;
}

void __SOSViewsGetAllCurrent_block_invoke()
{
  sosAllViews = (uint64_t)SOSViewCopyViewSet(0);
  CFSetAddValue((CFMutableSetRef)sosAllViews, @"KeychainV0");
  if (sTestViewSet)
  {
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __CFSetUnion_block_invoke_6846;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    void context[4] = sosAllViews;
    CFSetApplyFunction((CFSetRef)sTestViewSet, (CFSetApplierFunction)apply_block_1_6847, context);
  }

CFSetRef SOSViewBitmaskFromSet(CFSetRef theSet)
{
  CFMutableStringRef v1 = theSet;
  uint64_t v4 = 0LL;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  if (theSet)
  {
    if (SOSViewsGetBitmasks_once != -1) {
      dispatch_once(&SOSViewsGetBitmasks_once, &__block_literal_global_107_6850);
    }
    if (SOSViewsGetBitmasks_masks)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 3221225472LL;
      _OWORD v3[2] = __SOSViewBitmaskFromSet_block_invoke;
      v3[3] = &unk_18966C8F8;
      v3[4] = &v4;
      void v3[5] = SOSViewsGetBitmasks_masks;
      CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_6847, v3);
    }

    CFMutableStringRef v1 = (const __CFSet *)v5[3];
  }

  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_180592698( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

unint64_t __SOSViewBitmaskFromSet_block_invoke(uint64_t a1, const void *a2)
{
  unint64_t result = (unint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) |= result;
  return result;
}

void __SOSViewsGetBitmasks_block_invoke()
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (SOSViewsGetAllCurrent_dot != -1) {
    dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6849);
  }
  dispatch_queue_t v0 = (const __CFSet *)sosAllViews;
  CFMutableStringRef v1 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = MEMORY[0x1895F87A8];
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 3221225472LL;
  context[2] = __SOSViewsGetBitmasks_block_invoke_2;
  context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
  void context[4] = Mutable;
  CFSetApplyFunction(v0, (CFSetApplierFunction)apply_block_1_6847, context);
  uint64_t Count = CFArrayGetCount(Mutable);
  if (Count < 33)
  {
    *(void *)__int128 buf = 0LL;
    CFDataRef v10 = buf;
    uint64_t v11 = 0x2020000000LL;
    int v12 = 1;
    v14.CFIndex location = 0LL;
    v14.CFIndex length = Count;
    CFArraySortValues(Mutable, v14, (CFComparatorFunction)MEMORY[0x1896033C0], 0LL);
    SOSViewsGetBitmasks_masks = (uint64_t)CFDictionaryCreateMutable(v1, 0LL, MEMORY[0x189604E40], 0LL);
    v7[0] = v3;
    v7[1] = 3221225472LL;
    unint64_t v7[2] = __SOSViewsGetBitmasks_block_invoke_108;
    void v7[3] = &unk_18966C9A8;
    void v7[4] = buf;
    uint64_t v6 = v7;
    v15.CFIndex length = CFArrayGetCount(Mutable);
    v15.CFIndex location = 0LL;
    CFArrayApplyFunction(Mutable, v15, (CFArrayApplierFunction)apply_block_1_6847, v6);

    _Block_object_dispose(buf, 8);
    if (!Mutable) {
      return;
    }
    goto LABEL_9;
  }

  secLogObjForScope("views");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = Count;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Too many views defined, can't make bitmask (%d)", buf, 8u);
  }

  if (Mutable) {
LABEL_9:
  }
    CFRelease(Mutable);
}

void sub_180592918( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void __SOSViewsGetBitmasks_block_invoke_2(uint64_t a1, const void *a2)
{
}

void __SOSViewsGetBitmasks_block_invoke_108(uint64_t a1, const void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) *= 2;
}

CFSetRef SOSPeerInfoViewBitMask(uint64_t a1)
{
  unint64_t result = SOSPeerInfoCopyEnabledViews(a1);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = SOSViewBitmaskFromSet(result);
    CFRelease(v2);
    return v3;
  }

  return result;
}

CFMutableSetRef SOSPeerInfoCopyEnabledViews(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (*(uint64_t *)(a1 + 56) > 1)
  {
    CFMutableSetRef result = SOSPeerInfoV2DictionaryCopySet(a1, (const void *)sViewsKey);
    if (!result)
    {
      secLogObjForScope("SecError");
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 40);
        int v8 = 138412290;
        uint64_t v9 = v7;
        _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "%@ v2 peer has no views", (uint8_t *)&v8, 0xCu);
      }

      return CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605258]);
    }
  }

  else
  {
    V0ViewSet = (const __CFSet *)SOSViewsGetV0ViewSet();
    CFIndex Count = CFSetGetCount(V0ViewSet);
    uint64_t v3 = (const __CFSet *)SOSViewsGetV0ViewSet();
    return CFSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], Count, v3);
  }

  return result;
}

CFMutableSetRef SOSViewCreateSetFromBitmask(uint64_t a1)
{
  if (SOSViewsGetBitmasks_once != -1) {
    dispatch_once(&SOSViewsGetBitmasks_once, &__block_literal_global_107_6850);
  }
  uint64_t v2 = (const __CFDictionary *)SOSViewsGetBitmasks_masks;
  if (!SOSViewsGetBitmasks_masks) {
    return 0LL;
  }
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605258]);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = __SOSViewCreateSetFromBitmask_block_invoke;
  v5[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
  void v5[4] = a1;
  void v5[5] = Mutable;
  CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)apply_block_2_6860, v5);
  return Mutable;
}

void __SOSViewCreateSetFromBitmask_block_invoke(uint64_t a1, const void *a2, uint64_t a3)
{
  if ((*(void *)(a1 + 32) & a3) != 0) {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
  }
}

uint64_t apply_block_2_6860(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL SOSPeerInfoSupportsCKKSForAll(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  CFMutableStringRef v1 = (const __CFBoolean *)SOSPeerInfoV2DictionaryCopyBoolean(a1, (const void *)sCKKSForAll);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  BOOL v3 = CFBooleanGetValue(v1) != 0;
  CFRelease(v2);
  return v3;
}

void SOSPeerInfoSetSupportsCKKSForAll(uint64_t a1, int a2)
{
  uint64_t v2 = (const void **)MEMORY[0x189604DE8];
  if (!a2) {
    uint64_t v2 = (const void **)MEMORY[0x189604DE0];
  }
  SOSPeerInfoV2DictionarySetValue(a1, (const void *)sCKKSForAll, *v2);
}

const char *SOSViewsXlateAction(int a1)
{
  else {
    return off_18966C9C8[a1 - 1];
  }
}

void SOSViewsForEachDefaultEnabledViewName(void *a1)
{
  id v1 = a1;
  uint64_t v2 = SOSViewCopyViewSet(1u);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 3221225472LL;
  context[2] = __SOSViewsForEachDefaultEnabledViewName_block_invoke;
  context[3] = &unk_18966F028;
  id v3 = v1;
  id v5 = v3;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_6847, context);
  if (v2) {
    CFRelease(v2);
  }
}

CFTypeID __SOSViewsForEachDefaultEnabledViewName_block_invoke(CFTypeID result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(cf);
    CFMutableSetRef result = CFStringGetTypeID();
    if (v3 == result) {
      return (*(uint64_t (**)(void))(*(void *)(v2 + 32) + 16LL))();
    }
  }

  return result;
}

CFSetRef SOSPeerInfoIsEnabledView(uint64_t a1, const void *a2)
{
  V0ViewSet = (const __CFSet *)SOSViewsGetV0ViewSet();
  return (const __CFSet *)(CFSetContainsValue(V0ViewSet, a2) != 0);
}

void SOSPeerInfoWithEnabledViewSet(uint64_t a1, void (**a2)(void, void))
{
  if (*(uint64_t *)(a1 + 56) > 1)
  {
    SOSPeerInfoV2DictionaryWithSet(a1, (const void *)sViewsKey, a2);
  }

  else
  {
    uint64_t v2 = a2;
    uint64_t V0ViewSet = SOSViewsGetV0ViewSet();
    a2[2](v2, V0ViewSet);
  }
}

uint64_t SOSPeerInfoGetPermittedViews()
{
  if (SOSViewsGetAllCurrent_dot != -1) {
    dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6849);
  }
  return sosAllViews;
}

uint64_t SOSViewsEnable(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  CFMutableSetRef v6 = SOSPeerInfoCopyEnabledViews(a1);
  if (v6)
  {
    uint64_t v7 = v6;
    if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
    {
      if (SOSPeerInfoViewIsValid(a2))
      {
        CFSetAddValue(v7, a2);
        SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v7);
        CFRelease(v7);
        return 1LL;
      }

      uint64_t v8 = 3LL;
      SOSCreateErrorWithFormat( 1026LL,  0LL,  a3,  0LL,  @"Peer is invalid for this view(%@) (ViewResultCode=%d)",  a2,  3LL);
    }

    else
    {
      uint64_t v8 = 4LL;
    }

    CFRelease(v7);
  }

  else
  {
    SOSCreateErrorWithFormat(1024LL, 0LL, a3, 0LL, @"%@", @"Failed to get memory for views in PeerInfo");
    uint64_t v8 = 0LL;
  }

  secLogObjForScope("views");
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      CFTypeRef v11 = *a3;
    }
    else {
      CFTypeRef v11 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v13 = a2;
    __int16 v14 = 2112;
    CFTypeRef v15 = v11;
    _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "Failed to enable view(%@): %@", buf, 0x16u);
  }

  return v8;
}

uint64_t SOSViewsRequireIsKnownView(uint64_t a1, CFTypeRef *a2)
{
  uint64_t IsKnownView = SOSViewsIsKnownView(a1);
  if ((IsKnownView & 1) == 0) {
    SOSCreateErrorWithFormat(1026LL, 0LL, a2, 0LL, @"Unknown view(%@) (ViewResultCode=%d)", a1, 4LL);
  }
  return IsKnownView;
}

BOOL SOSPeerInfoViewIsValid(const void *a1)
{
  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return !CFSetContainsValue(V0SubviewSet, a1) || (SOSVisibleKeychainNotAllowed() & 1) == 0;
}

uint64_t SOSViewsIsKnownView(uint64_t value)
{
  if (value)
  {
    id v1 = (const void *)value;
    if (SOSViewsGetAllCurrent_dot != -1) {
      dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6849);
    }
    if (CFSetContainsValue((CFSetRef)sosAllViews, v1))
    {
      return 1LL;
    }

    else
    {
      secLogObjForScope("views");
      uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeID v3 = 0;
        _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "Not a known view", v3, 2u);
      }

      return 0LL;
    }
  }

  return value;
}

uint64_t SOSViewSetEnable(uint64_t a1, const __CFSet *a2)
{
  uint64_t v11 = 0LL;
  int v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  char v14 = 0;
  CFMutableSetRef v4 = SOSPeerInfoCopyEnabledViews(a1);
  CFMutableSetRef v5 = v4;
  if (v4)
  {
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SOSViewSetEnable_block_invoke;
    context[3] = &unk_18966C940;
    void context[5] = a1;
    void context[6] = v4;
    void context[4] = &v11;
    CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_6847, context);
    if (*((_BYTE *)v12 + 24)) {
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v5);
    }
    CFRelease(v5);
  }

  else
  {
    secLogObjForScope("views");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "failed to copy enabled views", buf, 2u);
    }
  }

  uint64_t v6 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v6;
}

void sub_1805932C0(_Unwind_Exception *a1)
{
}

void __SOSViewSetEnable_block_invoke(uint64_t a1, void *value)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (SOSViewsIsKnownView((uint64_t)value) && SOSPeerInfoViewIsValid(value))
  {
    if (!CFSetContainsValue(*(CFSetRef *)(a1 + 48), value))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), value);
    }
  }

  else
  {
    secLogObjForScope("views");
    CFMutableSetRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = value;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "couldn't add view %@", (uint8_t *)&v5, 0xCu);
    }
  }

uint64_t SOSViewsDisable(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v6 = SOSPeerInfoCopyEnabledViews(a1);
  if (v6)
  {
    if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
    {
      CFSetRemoveValue(v6, a2);
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v6);
      CFRelease(v6);
      return 2LL;
    }

    CFRelease(v6);
    uint64_t v6 = (__CFSet *)4;
  }

  else
  {
    SOSCreateErrorWithFormat(1024LL, 0LL, a3, 0LL, @"%@", @"Failed to get memory for views in PeerInfo");
  }

  secLogObjForScope("views");
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      CFTypeRef v9 = *a3;
    }
    else {
      CFTypeRef v9 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v11 = a2;
    __int16 v12 = 2112;
    CFTypeRef v13 = v9;
    _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "Failed to disable view(%@): %@", buf, 0x16u);
  }

  return (uint64_t)v6;
}

uint64_t SOSViewSetDisable(uint64_t a1, const __CFSet *a2)
{
  uint64_t v11 = 0LL;
  __int16 v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  char v14 = 0;
  CFMutableSetRef v4 = SOSPeerInfoCopyEnabledViews(a1);
  CFMutableSetRef v5 = v4;
  if (v4)
  {
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    void v9[2] = __SOSViewSetDisable_block_invoke;
    void v9[3] = &unk_18966C8F8;
    void v9[4] = &v11;
    void v9[5] = v4;
    CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_6847, v9);
    if (*((_BYTE *)v12 + 24)) {
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v5);
    }
    CFRelease(v5);
  }

  else
  {
    secLogObjForScope("views");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "failed to copy enabled views", buf, 2u);
    }
  }

  uint64_t v6 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v6;
}

void sub_180593678( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __SOSViewSetDisable_block_invoke(uint64_t a1, void *value)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (SOSViewsIsKnownView((uint64_t)value) && CFSetContainsValue(*(CFSetRef *)(a1 + 40), value))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), value);
  }

  else
  {
    secLogObjForScope("views");
    CFMutableSetRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = value;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "couldn't delete view %@", (uint8_t *)&v5, 0xCu);
    }
  }

uint64_t SOSViewsQuery(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
  {
    uint64_t v6 = SOSPeerInfoCopyEnabledViews(a1);
    if (v6)
    {
      uint64_t v7 = v6;
      if (CFSetContainsValue(v6, @"KeychainV0")
        && (V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet(), CFSetContainsValue(V0SubviewSet, a2)))
      {
        uint64_t v9 = 1LL;
      }

      else if (CFSetContainsValue(v7, a2))
      {
        uint64_t v9 = 1LL;
      }

      else
      {
        uint64_t v9 = 2LL;
      }

      CFRelease(v7);
    }

    else
    {
      return 2LL;
    }
  }

  else
  {
    secLogObjForScope("views");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (a3) {
        CFTypeRef v12 = *a3;
      }
      else {
        CFTypeRef v12 = 0LL;
      }
      int v13 = 138412546;
      char v14 = a2;
      __int16 v15 = 2112;
      CFTypeRef v16 = v12;
      _os_log_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEFAULT, "Failed to query view(%@): %@", (uint8_t *)&v13, 0x16u);
    }

    return 4LL;
  }

  return v9;
}

BOOL SOSPeerInfoIsViewPermitted(uint64_t a1, const void *a2)
{
  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return (!CFSetContainsValue(V0SubviewSet, a2) || (SOSVisibleKeychainNotAllowed() & 1) == 0)
      && SOSViewsQuery(a1, a2, 0LL) < 3;
}

BOOL SOSViewSetIntersectsV0(const __CFSet *a1)
{
  uint64_t V0ViewSet = SOSViewsGetV0ViewSet();
  BOOL v3 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  char v9 = 1;
  if (a1 && V0ViewSet)
  {
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    void v5[2] = __CFSetIntersectionIsEmpty_block_invoke;
    v5[3] = &unk_18966C8F8;
    void v5[4] = &v6;
    void v5[5] = V0ViewSet;
    CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6847, v5);
    BOOL v3 = *((_BYTE *)v7 + 24) == 0;
  }

  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1805939FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __CFSetIntersectionIsEmpty_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if ((_DWORD)result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(_BYTE *)(v4 + 24) == 0;
  }
  char v6 = !v5;
  *(_BYTE *)(v4 + 24) = v6;
  return result;
}

BOOL SOSPeerInfoV0ViewsEnabled(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = SOSPeerInfoCopyEnabledViews(a1);
  BOOL v2 = SOSViewSetIntersectsV0(v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t SOSPeerInfoHasUserVisibleViewsEnabled(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = SOSPeerInfoCopyEnabledViews(result);
    if (SOSViewsGetUserVisibleSet_onceToken != -1) {
      dispatch_once(&SOSViewsGetUserVisibleSet_onceToken, &__block_literal_global_6848);
    }
    uint64_t v4 = 0LL;
    BOOL v5 = &v4;
    uint64_t v6 = 0x2020000000LL;
    char v7 = 1;
    if (v1 && SOSViewsGetUserVisibleSet_subViewSet)
    {
      v3[0] = MEMORY[0x1895F87A8];
      v3[1] = 3221225472LL;
      _OWORD v3[2] = __CFSetIntersectionIsEmpty_block_invoke;
      v3[3] = &unk_18966C8F8;
      v3[4] = &v4;
      void v3[5] = SOSViewsGetUserVisibleSet_subViewSet;
      CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_6847, v3);
      BOOL v2 = *((_BYTE *)v5 + 24) == 0;
      _Block_object_dispose(&v4, 8);
    }

    else
    {
      _Block_object_dispose(&v4, 8);
      BOOL v2 = 0LL;
      uint64_t result = 0LL;
      if (!v1) {
        return result;
      }
    }

    CFRelease(v1);
    return v2;
  }

  return result;
}

void sub_180593BA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id CreateXPCObjectWithCFSetRef( const __CFSet *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    SecCFCreateErrorWithFormat( 2LL,  (const __CFString *)sSecXPCErrorDomain,  0LL,  a2,  a5,  @"Unexpected Null Set to encode",  a7,  a8,  v16);
LABEL_7:
    xpc_object_t v14 = 0LL;
    return v14;
  }

  size_t v10 = der_sizeof_set(a1, (uint64_t)a2);
  if (!v10) {
    goto LABEL_7;
  }
  size_t v11 = v10;
  CFTypeRef v12 = malloc(v10);
  if (!v12) {
    goto LABEL_7;
  }
  int v13 = v12;
  der_encode_set_repair(a1, a2, 0);
  xpc_object_t v14 = xpc_data_create(v13, v11);
  free(v13);
  return v14;
}

uint64_t __CFSecRecoveryKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void CFSecRecoveryKeyDestroy(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0LL;
    CFRelease(v2);
  }

CFStringRef CFSecRecoveryKeyCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"<SecRecoveryKey: %p>", a1);
}

CFStringRef CFSecRecoveryKeyCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"<SecRecoveryKey: %p>", a1);
}

__CFString *SecRKCreateRecoveryKeyString(void *a1)
{
  id v6 = 0LL;
  BOOL v2 = SecPasswordGenerate(4, (const __CFDictionary **)&v6, 0LL);
  if (v2)
  {
    BOOL v3 = (__CFString *)v2;
    if (ValidateRecoveryKey(v2, a1)) {
      return v3;
    }
    id v5 = v3;
    goto LABEL_9;
  }

  id v5 = v6;
  if (a1)
  {
    *a1 = v6;
    return (__CFString *)0LL;
  }

  if (v6)
  {
    id v6 = 0LL;
LABEL_9:
    CFRelease(v5);
    id v5 = 0LL;
  }

  return (__CFString *)v5;
}

BOOL ValidateRecoveryKey(CFStringRef theString, void *a2)
{
  id v6 = 0LL;
  BOOL v3 = SecPasswordValidatePasswordFormat(4, theString, (__CFString **)&v6);
  if (!v3)
  {
    id v4 = v6;
    if (a2)
    {
      *a2 = v6;
    }

    else if (v6)
    {
      id v6 = 0LL;
      CFRelease(v4);
    }
  }

  return v3;
}

void *SecRKCreateRecoveryKey(void *a1)
{
  return SecRKCreateRecoveryKeyWithError(a1, 0LL);
}

void *SecRKCreateRecoveryKeyWithError(void *a1, void *a2)
{
  BOOL v3 = a1;
  if (!ValidateRecoveryKey(v3, a2)) {
    goto LABEL_9;
  }
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __CFSecRecoveryKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDSingleton;
  if (CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce != -1) {
    dispatch_once(&CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce, block);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)SecCFAllocatorZeroize_sAllocator,  v3,  0x8000100u,  0);
    Instance[2] = ExternalRepresentation;
    if (!ExternalRepresentation)
    {
      CFRelease(Instance);
LABEL_9:
      uint64_t Instance = 0LL;
    }
  }

  return Instance;
}

__CFString *SecRKCopyAccountRecoveryPassword(uint64_t a1)
{
  uint64_t v1 = SecRKCreateDerivedSecret(a1, 32LL);
  if (!v1) {
    return (__CFString *)0LL;
  }
  BOOL v2 = v1;
  CFDataGetBytePtr(v1);
  size_t v3 = (2 * (((unint64_t)(CFDataGetLength(v2) + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 >= 0x400) {
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
  id v4 = (UInt8 *)malloc(v3);
  if (v4)
  {
    id v5 = v4;
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v2);
    CFIndex Length = CFDataGetLength(v2);
    SecBase64Encode_(BytePtr, Length, v5, v3, 0, &v10);
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    uint64_t v8 = (__CFString *)CFStringCreateWithBytes((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v5, v3, 0x8000100u, 0);
    cc_clear();
    free(v5);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  CFRelease(v2);
  return v8;
}

__CFData *SecRKCreateDerivedSecret(uint64_t a1, CFIndex a2)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(Mutable, a2);
  if (Mutable)
  {
    ccsha256_di();
    CFDataGetLength(*(CFDataRef *)(a1 + 16));
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    CFDataGetLength(Mutable);
    CFDataGetMutableBytePtr(Mutable);
    if (cchkdf())
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

id SecRKCopyAccountRecoveryVerifier(void *a1, void *a2)
{
  void v18[5] = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v16 = 0LL;
  if (connectAppleIDFrameworkSymbols_onceToken != -1) {
    dispatch_once(&connectAppleIDFrameworkSymbols_onceToken, &__block_literal_global_6919);
  }
  if (connectAppleIDFrameworkSymbols_framework) {
    BOOL v4 = localProtocolSRPGROUP == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || localAppleIDauthSupportCreateVerifierPtr == 0LL)
  {
    SOSCreateErrorWithFormat( 1041LL,  0LL,  (CFTypeRef *)&v16,  0LL,  @"%@",  @"Recovery Key Creation Not Supported on this platform");
    id v6 = 0LL;
    if (a2) {
      *a2 = v16;
    }
  }

  else
  {
    char v7 = (void *)CFDataCreateWithRandomBytes(0x20uLL);
    id v8 = (id)localProtocolSRPGROUP;
    char v9 = (void *)localAppleIDauthSupportCreateVerifierPtr( localProtocolSRPGROUP,  @"foo",  v7,  &unk_18969C120,  v3,  &v16);
    SecRKCreateRecoveryKeyWithError(v3, 0LL);
    int v10 = (void *)objc_claimAutoreleasedReturnValue();
    size_t v11 = SecRKCreateDerivedSecret((uint64_t)v10, 32LL);
    CFTypeRef v12 = v11;
    if (v9 && v11)
    {
      v17[0] = @"s";
      v17[1] = @"i";
      v18[0] = v7;
      v18[1] = &unk_18969C120;
      void v17[2] = @"p";
      void v17[3] = @"v";
      void v18[2] = v8;
      _OWORD v18[3] = v9;
      v17[4] = @"mkid";
      v18[4] = v11;
      [MEMORY[0x189603F68] dictionaryWithObjects:v18 forKeys:v17 count:5];
      int v13 = (void *)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      int v13 = 0LL;
      if (a2 && v16)
      {
        id v14 = v16;
        int v13 = 0LL;
        *a2 = v14;
      }
    }

    id v6 = v13;
  }

  return v6;
}

void *__connectAppleIDFrameworkSymbols_block_invoke()
{
  localAppleIDauthSupportCreateVerifierPtr = 0LL;
  localProtocolSRPGROUP = 0LL;
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/AppleIDAuthSupport.framework/AppleIDAuthSupport", 2);
  connectAppleIDFrameworkSymbols_framework = (uint64_t)result;
  if (result)
  {
    uint64_t v1 = (uint64_t *)dlsym(result, "kAppleIDAuthSupportProtocolSRPGROUP2048SHA256PBKDF");
    if (v1) {
      uint64_t v2 = *v1;
    }
    else {
      uint64_t v2 = 0LL;
    }
    localProtocolSRPGROUP = v2;
    uint64_t result = dlsym((void *)connectAppleIDFrameworkSymbols_framework, "AppleIDAuthSupportCreateVerifier");
    localAppleIDauthSupportCreateVerifierPtr = (uint64_t (*)(void, void, void, void, void, void))result;
  }

  return result;
}

__CFData *SecRKCopyBackupFullKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 1);
}

__CFData *RKBackupCreateECKey(uint64_t a1, char a2)
{
  v13[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = MEMORY[0x186DFEF8C]();
  MEMORY[0x1895F8858](v4);
  unint64_t v6 = 0LL;
  do
  {
    char v7 = (void *)((char *)&v13[v6 / 8] - v5);
    *char v7 = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = 0xAAAAAAAAAAAAAAAALL;
    v6 += 16LL;
  }

  while (v5 != v6);
  id v8 = SecRKCreateDerivedSecret(a1, 128LL);
  if (v8)
  {
    char v9 = v8;
    CFDataGetLength(v8);
    CFDataGetBytePtr(v9);
    ccrng();
    if (ccec_generate_key_deterministic())
    {
      CFMutableSetRef Mutable = 0LL;
    }

    else
    {
      CFIndex v10 = (unint64_t)(cczp_bitlen() + 7) >> 3 << a2;
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
      CFDataSetLength(Mutable, v10);
      if (Mutable)
      {
        CFDataGetMutableBytePtr(Mutable);
        ccec_compact_export();
      }
    }

    CFRelease(v9);
  }

  else
  {
    CFMutableSetRef Mutable = 0LL;
  }

  return Mutable;
}

__CFData *SecRKCopyBackupPublicKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 0);
}

uint64_t SecRKRegisterBackupPublicKey(uint64_t a1, CFTypeRef *a2)
{
  ECKey = RKBackupCreateECKey(a1, 0);
  if (ECKey)
  {
    uint64_t v4 = ECKey;
    uint64_t v5 = SOSCCRegisterRecoveryPublicKey((uint64_t)ECKey, a2);
    CFRelease(v4);
    return v5;
  }

  else
  {
    SOSCreateErrorWithFormat(1034LL, 0LL, a2, 0LL, @"%@", @"Failed to create key from rk");
    return 0LL;
  }

const SecAsn1Template *NSS_TimeChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
  }

  else
  {
    if (!a4)
    {
      int v5 = 0;
      goto LABEL_9;
    }

    int v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
  }

  if (v5 == 24) {
    return kSecAsn1GeneralizedTimeTemplate;
  }
LABEL_9:
  char v7 = (uint64_t *)&off_18966CD00;
  uint64_t result = kSecAsn1GeneralizedTimeTemplate;
  while (1)
  {
    uint64_t v8 = *v7;
    if (!*v7) {
      break;
    }
    int v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9) {
      return (const SecAsn1Template *)v8;
    }
  }

  return result;
}

void *PR_getThreadErrInfo(int a1, int *a2)
{
  if ((PR_threadKeyInitFlag & 1) == 0)
  {
    pthread_mutex_lock(&PR_threadKeyLock);
    if (!a1 && PR_threadKeyErrorFlag)
    {
      pthread_mutex_unlock(&PR_threadKeyLock);
      uint64_t v4 = 0LL;
      int v5 = -5991;
LABEL_15:
      *a2 = v5;
      return v4;
    }

    if ((PR_threadKeyInitFlag & 1) == 0)
    {
      int v6 = pthread_key_create((pthread_key_t *)&PR_threadKey, (void (__cdecl *)(void *))MEMORY[0x1895FB398]);
      if (v6)
      {
        int v7 = v6;
        PR_threadKeyErrorFlag = 1;
        pthread_mutex_unlock(&PR_threadKeyLock);
        uint64_t v4 = 0LL;
        *a2 = v7;
        return v4;
      }

      PR_threadKeyErrorFlag = 0;
      PR_threadKeyInitFlag = 1;
    }

    pthread_mutex_unlock(&PR_threadKeyLock);
  }

  *a2 = 0;
  uint64_t v8 = pthread_getspecific(PR_threadKey);
  uint64_t v4 = v8;
  if (a1 && !v8)
  {
    int v9 = malloc(8uLL);
    uint64_t v4 = v9;
    if (!v9)
    {
      int v5 = -6000;
      goto LABEL_15;
    }

    *int v9 = 0LL;
    pthread_setspecific(PR_threadKey, v9);
  }

  return v4;
}

const SecAsn1Template *NSS_ATVChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
  }

  else
  {
    if (!a4)
    {
      int v5 = 0;
      goto LABEL_9;
    }

    int v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
  }

  if (v5 == 19) {
    return kSecAsn1PrintableStringTemplate;
  }
LABEL_9:
  int v7 = (uint64_t *)&off_18966D2B0;
  uint64_t result = kSecAsn1PrintableStringTemplate;
  while (1)
  {
    uint64_t v8 = *v7;
    if (!*v7) {
      break;
    }
    int v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9) {
      return (const SecAsn1Template *)v8;
    }
  }

  return result;
}

void *NSS_genNameChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v5 = *(unsigned __int8 *)(a5 + 16);
    if (!*(_BYTE *)(a5 + 16)) {
      return &kSecAsn1OtherNameTemplate;
    }
  }

  else
  {
    if (!a4) {
      return &kSecAsn1OtherNameTemplate;
    }
    int v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
    if (!v5) {
      return &kSecAsn1OtherNameTemplate;
    }
  }

  int v6 = (uint64_t *)&off_18966D320;
  uint64_t result = &kSecAsn1OtherNameTemplate;
  while (1)
  {
    uint64_t v8 = *v6;
    if (!*v6) {
      break;
    }
    int v9 = *((unsigned __int8 *)v6 - 8);
    v6 += 2;
    if (v5 == v9) {
      return (void *)v8;
    }
  }

  return result;
}

uint64_t SecAsn1TaggedTemplateChooser( uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  if (a2)
  {
    int v6 = *(unsigned __int8 *)(a5 + 16);
  }

  else if (a4)
  {
    int v6 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v6;
  }

  else
  {
    int v6 = 0;
  }

  uint64_t result = *((void *)a6 + 1);
  if (result && v6 != *a6)
  {
    for (uint64_t i = (uint64_t *)(a6 + 24); ; i += 2)
    {
      uint64_t v9 = *i;
      if (!*i) {
        break;
      }
      int v10 = *((unsigned __int8 *)i - 8);
      if (v6 == v10) {
        return v9;
      }
    }
  }

  return result;
}

const SecAsn1Template *NSS_P7_ContentInfoChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_Data))
  {
    int v4 = 1;
    int v5 = kSecAsn1PointerToOctetStringTemplate;
    goto LABEL_10;
  }

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EncryptedData))
  {
    int v4 = 6;
    int v5 = (const SecAsn1Template *)&NSS_P7_PtrToEncryptedDataTemplate;
    goto LABEL_10;
  }

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedData))
  {
    int v4 = 2;
LABEL_9:
    int v5 = kSecAsn1PointerToAnyTemplate;
    goto LABEL_10;
  }

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EnvelopedData))
  {
    int v4 = 3;
    goto LABEL_9;
  }

  int v5 = kSecAsn1PointerToAnyTemplate;
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedAndEnvelopedData))
  {
    int v4 = 4;
  }

  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_DigestedData))
  {
    int v4 = 5;
  }

  else
  {
    int v5 = 0LL;
    int v4 = 0;
  }

uint64_t PL_ArenaAllocate(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unsigned int v3 = (v2 + a2) & ~(_DWORD)v2;
  if (v3 < a2) {
    return 0LL;
  }
  int v6 = *(void **)(a1 + 32);
  unint64_t v7 = (v2 + a2) & ~(_DWORD)v2;
  uint64_t v8 = v6;
  do
  {
    uint64_t result = v8[3];
    if (v7 <= v8[2] - result)
    {
      *(void *)(a1 + 32) = v8;
      unint64_t v8[3] = result + v7;
      return result;
    }

    uint64_t v8 = (void *)*v8;
  }

  while (v8);
  if (*(_DWORD *)(a1 + 40) > v3) {
    unsigned int v3 = *(_DWORD *)(a1 + 40);
  }
  int v9 = v2 + 32;
  unint64_t v10 = v3 + v9;
  if (v10 <= 1) {
    size_t v11 = 1LL;
  }
  else {
    size_t v11 = v3 + v9;
  }
  CFTypeRef v12 = malloc(v11);
  uint64_t result = ((unint64_t)v12 + v2 + 32) & ~v2;
  BOOL v13 = __CFADD__(result, v7);
  if (v12) {
    BOOL v14 = !v13;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    free(v12);
    return 0LL;
  }

  if (!v12) {
    return 0LL;
  }
  void v12[2] = (char *)v12 + v10;
  v12[3] = result + v7;
  *CFTypeRef v12 = *v6;
  v12[1] = result;
  void *v6 = v12;
  *(void *)(a1 + 32) = v12;
  if (!*(void *)a1) {
    *(void *)a1 = v12;
  }
  return result;
}

char *PL_ArenaGrow(uint64_t a1, char *a2, unsigned int a3, unsigned int a4)
{
  if (a3 > 0x7FFFFFFE || a4 > 0x7FFFFFFE) {
    return 0LL;
  }
  int v6 = (void *)a1;
  uint64_t v7 = *(void *)(a1 + 48);
  unsigned int v8 = (v7 + a3) & ~(_DWORD)v7;
  if (v8 > 0x7FFFFFFE) {
    return 0LL;
  }
  int v11 = v8 + a4;
  if (v8 + a4 <= 2 * v8) {
    int v11 = 2 * v8;
  }
  unsigned int v12 = (v7 + v11) & ~(_DWORD)v7;
  if (v12 > 0x7FFFFFFE) {
    return 0LL;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  BOOL v13 = *(char **)(v15 + 24);
  if ((unint64_t)v12 <= *(void *)(v15 + 16) - (void)v13)
  {
    *(void *)(v15 + 24) = &v13[v12];
    if (!v13) {
      return v13;
    }
  }

  else
  {
    BOOL v13 = (char *)PL_ArenaAllocate(a1, v12);
    if (!v13) {
      return v13;
    }
  }

  *(void *)(v6[4] + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = &v13[~*((_DWORD *)v6 + 12) & (v6[6] + a4 + a3)];
  memcpy(v13, a2, a3);
  id v16 = (void *)*v6;
  if (*v6)
  {
    while (1)
    {
      uint64_t v17 = v16;
      id v16 = (void *)*v16;
      int v6 = v17;
      if (!*v17) {
        return v13;
      }
    }

    void *v6 = *v16;
    free(v16);
  }

  return v13;
}

uint64_t SEC_ASN1EncoderUpdate(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v94 = *MEMORY[0x1895F89C0];
  int v6 = *(_DWORD *)(a1 + 16);
  if (v6 == 3)
  {
    int v6 = 2;
    *(_DWORD *)(a1 + 16) = 2;
  }

  if (a2) {
    BOOL v7 = a3 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  uint64_t v8 = v7;
  unint64_t v9 = a3 + 1;
  while (2)
  {
    if (v6 != 2) {
      goto LABEL_145;
    }
    uint64_t v10 = *(void *)(a1 + 8);
    switch(*(_DWORD *)(v10 + 40))
    {
      case 0:
        int v91 = 0;
        uint64_t v11 = *(void *)(v10 + 48);
        if (v11 == 1024) {
          goto LABEL_14;
        }
        if ((v11 & 0x100000) != 0)
        {
          CFRange v39 = *(unsigned int **)(v10 + 8);
          if (!v39[6])
          {
LABEL_57:
            *(_DWORD *)(*(void *)v10 + 16LL) = 1;
            goto LABEL_131;
          }

          CFRange v40 = *(_DWORD **)(v10 + 16);
          CFRange v41 = (int *)(v39 + 12);
          uint64_t v42 = 1LL;
          while (*v40 != *(v41 - 2))
          {
            ++v42;
            int v43 = *v41;
            v41 += 6;
            if (!v43) {
              goto LABEL_57;
            }
          }

          *(_DWORD *)(v10 + 40) = 8;
          uint64_t v53 = *(void *)v10;
          uint64_t v54 = (uint64_t)&v39[6 * v42];
          uint64_t v55 = (uint64_t)v40 - v39[1];
        }

        else
        {
          unint64_t v90 = v9;
          if (*(_DWORD *)(*(void *)v10 + 20LL) && *(_DWORD *)(v10 + 72))
          {
            uint64_t v32 = v4;
            unint64_t v33 = v3;
            uint64_t v34 = v8;
            if (*(_DWORD *)(*(void *)v10 + 24LL)) {
              BOOL v35 = 1LL;
            }
            else {
              BOOL v35 = *(_DWORD *)(v10 + 68) == 0;
            }
          }

          else
          {
            unint64_t v33 = v3;
            uint64_t v32 = v4;
            uint64_t v34 = v8;
            BOOL v35 = 0LL;
          }

          char v44 = *(_BYTE *)(v10 + 45);
          char v45 = *(_BYTE *)(v10 + 44);
          unint64_t v46 = sec_asn1e_contents_length( *(_DWORD **)(v10 + 8),  *(unint64_t **)(v10 + 16),  *(_DWORD *)(v10 + 80),  v35,  &v91);
          if (v91 || !v46 && *(_DWORD *)(v10 + 76))
          {
            *(_DWORD *)(v10 + 40) = 4;
            uint64_t v47 = *(void *)v10;
            uint64_t v8 = v34;
            uint64_t v4 = v32;
            unint64_t v3 = v33;
            unint64_t v9 = v90;
            if (*(_DWORD *)(*(void *)v10 + 20LL) && *(_DWORD *)(v10 + 72) && *(_DWORD *)(v47 + 24)) {
              *(_DWORD *)(v47 + 16) = 3;
            }
            goto LABEL_131;
          }

          if (v35)
          {
            unint64_t v46 = 0LL;
            *(_DWORD *)(v10 + 64) = 1;
            v45 |= 0x20u;
          }

          unint64_t v89 = v46;
          LOBYTE(v92) = v45 | v44;
          (*(void (**)(void, unint64_t *, uint64_t, void, void))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  1LL,  *(unsigned int *)(v10 + 56),  0LL);
          int v51 = *(_DWORD *)(v10 + 64);
          char v93 = -86;
          unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
          if (v51)
          {
            LOBYTE(v92) = 0x80;
            uint64_t v52 = 1LL;
            uint64_t v8 = v34;
            uint64_t v4 = v32;
            unint64_t v3 = v33;
            unint64_t v9 = v90;
          }

          else
          {
            uint64_t v8 = v34;
            unint64_t v3 = v33;
            if (v89 < 0x80)
            {
              LOBYTE(v92) = v89;
              uint64_t v52 = 1LL;
              uint64_t v4 = v32;
              unint64_t v9 = v90;
            }

            else
            {
              uint64_t v73 = 0LL;
              unint64_t v74 = v89;
              uint64_t v4 = v32;
              unint64_t v9 = v90;
              do
              {
                uint64_t v75 = v73++;
                BOOL v15 = v74 >= 0x100;
                v74 >>= 8;
              }

              while (v15);
              uint64_t v52 = v75 + 2;
              LOBYTE(v92) = v73 | 0x80;
              unint64_t v76 = v89;
              do
              {
                *((_BYTE *)&v92 + v73) = v76;
                v76 >>= 8;
                --v73;
              }

              while (v73);
            }
          }

          (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  v52,  *(unsigned int *)(v10 + 56),  1LL);
          if (!v89 && !*(_DWORD *)(v10 + 64))
          {
            *(_DWORD *)(v10 + 40) = 4;
            goto LABEL_131;
          }

          if (*(_DWORD *)(v10 + 60))
          {
            *(_DWORD *)(v10 + 40) = 4;
            uint64_t v78 = *(void *)(v10 + 8);
            uint64_t v77 = *(void *)(v10 + 16);
            __int16 v79 = *(uint64_t (***)(void, uint64_t, void, void))(v78 + 8);
            if (v79 && (*(_BYTE *)(v78 + 1) & 0x40) != 0)
            {
              if (*v79)
              {
                if (v77) {
                  uint64_t v80 = v77 - *(unsigned int *)(v78 + 4);
                }
                else {
                  uint64_t v80 = 0LL;
                }
                __int16 v79 = (uint64_t (**)(void, uint64_t, void, void))(*v79)(v80, 1LL, 0LL, 0LL);
                uint64_t v77 = *(void *)(v10 + 16);
              }

              else
              {
                __int16 v79 = 0LL;
              }
            }

            uint64_t v86 = *(void *)v10;
            uint64_t v84 = v77;
LABEL_129:
            uint64_t v87 = sec_asn1e_push_state(v86, (uint64_t)v79, v84, 1);
            if (v87) {
              sec_asn1e_init_state_based_on_template(v87);
            }
            goto LABEL_131;
          }

          uint64_t v81 = *(void *)(v10 + 48);
          if ((unint64_t)(v81 - 16) >= 2)
          {
            if ((unint64_t)(v81 - 8208) > 1)
            {
LABEL_14:
              *(_DWORD *)(v10 + 40) = 1;
              goto LABEL_131;
            }

            uint64_t v82 = *(uint64_t ***)(v10 + 16);
            uint64_t v83 = *v82;
            if (!*v82 || (uint64_t v84 = *v83) == 0)
            {
              *(_DWORD *)(v10 + 40) = 4;
              goto LABEL_131;
            }

            *(_DWORD *)(v10 + 40) = 2;
            uint64_t v85 = *(void *)(v10 + 8);
            __int16 v79 = *(uint64_t (***)(void, uint64_t, void, void))(v85 + 8);
            if (v79 && (*(_BYTE *)(v85 + 1) & 0x40) != 0)
            {
              if (*v79)
              {
                __int16 v79 = (uint64_t (**)(void, uint64_t, void, void))(*v79)( (char *)v82 - *(unsigned int *)(v85 + 4),  1LL,  0LL,  0LL);
                uint64_t v84 = *v83;
              }

              else
              {
                __int16 v79 = 0LL;
              }
            }

            uint64_t v86 = *(void *)v10;
            goto LABEL_129;
          }

          *(_DWORD *)(v10 + 40) = 3;
          uint64_t v53 = *(void *)v10;
          uint64_t v54 = *(void *)(v10 + 8) + 24LL;
          uint64_t v55 = *(void *)(v10 + 16);
        }

        uint64_t v56 = sec_asn1e_push_state(v53, v54, v55, 1);
        if (v56)
        {
          uint64_t v23 = v56;
          uint64_t v57 = *(void *)v56;
          CFIndex v58 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)v56 + 32LL);
          if (v58)
          {
            uint64_t v59 = *(unsigned int *)(v56 + 56);
            uint64_t v60 = *(void *)(v56 + 16);
            *(_DWORD *)(v57 + 4_Block_object_dispose(va, 8) = 1;
            v58(*(void *)(v57 + 40), 1LL, v60, v59);
            *(_DWORD *)(v57 + 4_Block_object_dispose(va, 8) = 0;
          }

LABEL_141:
                uint64_t v71 = v67;
                uint64_t v72 = v68;
                if (v69)
                {
LABEL_136:
                  while (!v70)
                  {
                    uint64_t v67 = v71 - 1;
                    if (v71 == 1) {
                      break;
                    }
                    CFIndex v68 = v72 + 1;
                    if (v72[1] < 0)
                    {
                      if (v69) {
                        break;
                      }
                    }

                    int v70 = v72[1];
                    --v71;
                    ++v72;
                    if ((v70 & 0x80) != 0) {
                      goto LABEL_141;
                    }
                  }

                  (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  v72,  v71,  *(unsigned int *)(v10 + 56),  2LL);
                }

                else
                {
                  LOBYTE(v92) = 0;
                  (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  1LL,  *(unsigned int *)(v10 + 56),  2LL);
                  (*(void (**)(void, char *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  v68,  v67,  *(unsigned int *)(v10 + 56),  2LL);
                }
              }

              goto LABEL_12;
            }

            if (v36 == 3)
            {
              int v48 = *(void **)(v10 + 16);
              unint64_t v49 = *v48 + 7LL;
              unint64_t v50 = v49 >> 3;
              LOBYTE(v92) = (v49 & 0xF8) - *v48;
              (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  1LL,  *(unsigned int *)(v10 + 56),  2LL);
              (*(void (**)(void, void, unint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  v48[1],  v50,  *(unsigned int *)(v10 + 56),  2LL);
              goto LABEL_12;
            }
          }

          else
          {
            if (v36 == 28)
            {
              CFMutableStringRef v37 = *(uint64_t **)(v10 + 16);
              uint64_t v38 = *v37;
              if ((*v37 & 3) != 0)
              {
LABEL_83:
                *(_DWORD *)(*(void *)v10 + 16LL) = 1;
                goto LABEL_12;
              }

              goto LABEL_88;
            }

            if (v36 == 30)
            {
              CFMutableStringRef v37 = *(uint64_t **)(v10 + 16);
              uint64_t v38 = *v37;
              if ((*v37 & 1) != 0) {
                goto LABEL_83;
              }
              goto LABEL_88;
            }
          }

          CFMutableStringRef v37 = *(uint64_t **)(v10 + 16);
          uint64_t v38 = *v37;
LABEL_88:
          (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  v37[1],  v38,  *(unsigned int *)(v10 + 56),  2LL);
LABEL_12:
          *(_DWORD *)(v10 + 40) = 4;
          goto LABEL_131;
        }

        if ((v8 & 1) == 0)
        {
          if (*(void *)(v10 + 48) != 1024LL)
          {
            LOBYTE(v92) = *(void *)(v10 + 48);
            (*(void (**)(void, unint64_t *, uint64_t, void, void))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  1LL,  *(unsigned int *)(v10 + 56),  0LL);
            if (*(void *)(v10 + 48) == 3LL)
            {
              char v93 = -86;
              unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
              if (v9 < 0x80)
              {
                LOBYTE(v92) = v9;
                uint64_t v16 = 1LL;
              }

              else
              {
                uint64_t v12 = 0LL;
                unint64_t v13 = v9;
                do
                {
                  uint64_t v14 = v12++;
                  BOOL v15 = v13 >= 0x100;
                  v13 >>= 8;
                }

                while (v15);
                uint64_t v16 = v14 + 2;
                LOBYTE(v92) = v12 | 0x80;
                unint64_t v17 = v9;
                do
                {
                  *((_BYTE *)&v92 + v12) = v17;
                  v17 >>= 8;
                  --v12;
                }

                while (v12);
              }

              (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  v16,  *(unsigned int *)(v10 + 56),  1LL);
              LOBYTE(v92) = 0;
              (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  1LL,  *(unsigned int *)(v10 + 56),  2LL);
            }

            else
            {
              unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
              char v93 = -86;
              if (v3 < 0x80)
              {
                LOBYTE(v92) = v3;
                uint64_t v64 = 1LL;
              }

              else
              {
                uint64_t v61 = 0LL;
                unint64_t v62 = v3;
                do
                {
                  uint64_t v63 = v61++;
                  BOOL v15 = v62 >= 0x100;
                  v62 >>= 8;
                }

                while (v15);
                uint64_t v64 = v63 + 2;
                LOBYTE(v92) = v61 | 0x80;
                unint64_t v65 = v3;
                do
                {
                  *((_BYTE *)&v92 + v61) = v65;
                  v65 >>= 8;
                  --v61;
                }

                while (v61);
              }

              (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  v64,  *(unsigned int *)(v10 + 56),  1LL);
            }
          }

          (*(void (**)(void, uint64_t, unint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  v4,  v3,  *(unsigned int *)(v10 + 56),  2LL);
        }

        *(_DWORD *)(*(void *)v10 + 16LL) = 3;
LABEL_131:
        int v6 = *(_DWORD *)(a1 + 16);
        if (v6 == 1) {
          goto LABEL_145;
        }
        if (*(void *)(a1 + 8)) {
          continue;
        }
        int v6 = 0;
LABEL_144:
        *(_DWORD *)(a1 + 16) = v6;
LABEL_145:
        if (v6 == 1) {
          return 0xFFFFFFFFLL;
        }
        else {
          return 0LL;
        }
      case 2:
        uint64_t v18 = *(void *)(v10 + 32);
        uint64_t v19 = **(uint64_t ***)(v10 + 16);
        uint64_t v20 = *(unsigned int *)(*(void *)(v18 + 8) + 4LL);
        do
          uint64_t v21 = *v19++;
        while (v21 != *(void *)(v18 + 16) - v20);
        uint64_t v22 = *v19;
        if (!v22)
        {
          *(_DWORD *)(v18 + 40) = 9;
          goto LABEL_12;
        }

        *(void *)(v18 + 16) = v22 + v20;
        *(_DWORD *)(v18 + 40) = 0;
        *(_DWORD *)(v18 + 64) = 0;
LABEL_39:
        *(void *)(*(void *)v10 + 8LL) = v18;
        goto LABEL_131;
      case 3:
        uint64_t v23 = *(void *)(v10 + 32);
        uint64_t v24 = *(void *)v10;
        CFIndex v25 = *(void (**)(void, void, uint64_t, uint64_t))(*(void *)v10 + 32LL);
        if (v25)
        {
          uint64_t v26 = *(unsigned int *)(v23 + 56);
          uint64_t v27 = *(void *)(v23 + 16);
          *(_DWORD *)(v24 + 4_Block_object_dispose(va, 8) = 1;
          v25(*(void *)(v24 + 40), 0LL, v27, v26);
          *(_DWORD *)(v24 + 4_Block_object_dispose(va, 8) = 0;
        }

        uint64_t v28 = *(void *)(v23 + 8);
        int v29 = *(_DWORD *)(v28 + 24);
        *(void *)(v23 + _Block_object_dispose(va, 8) = v28 + 24;
        if (!v29)
        {
          *(_DWORD *)(v23 + 40) = 9;
          *(_DWORD *)(v10 + 40) = 4;
          goto LABEL_131;
        }

        *(void *)(v23 + 16) = *(void *)(v10 + 16) + *(unsigned int *)(v28 + 28);
        uint64_t v30 = *(void *)v10;
        CFTypeID v31 = *(void (**)(void, uint64_t))(*(void *)v10 + 32LL);
        if (v31)
        {
          *(_DWORD *)(v30 + 4_Block_object_dispose(va, 8) = 1;
          v31(*(void *)(v30 + 40), 1LL);
          *(_DWORD *)(v30 + 4_Block_object_dispose(va, 8) = 0;
          uint64_t v30 = *(void *)v10;
        }

        *(void *)(v30 + _Block_object_dispose(va, 8) = v23;
        goto LABEL_35;
      case 4:
        if (*(_DWORD *)(v10 + 64))
        {
          LOWORD(v92) = 0;
          (*(void (**)(void, unint64_t *, uint64_t, void, uint64_t))(*(void *)v10 + 56LL))( *(void *)(*(void *)v10 + 64LL),  &v92,  2LL,  *(unsigned int *)(v10 + 56),  3LL);
        }

        uint64_t v18 = *(void *)(v10 + 24);
        goto LABEL_39;
      case 5:
      case 6:
      case 7:
      case 8:
        goto LABEL_12;
      default:
        int v6 = 1;
        goto LABEL_144;
    }
  }

uint64_t sec_asn1e_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t result = PORT_ArenaAlloc(*(void *)a1, 0x58uLL);
  if (result)
  {
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(void *)(result + 80) = 0LL;
    *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(void *)(result + 24) = v8;
    *(void *)uint64_t result = a1;
    *(void *)(result + _Block_object_dispose(va, 8) = a2;
    *(_DWORD *)(result + 40) = 9;
    if (a3) {
      *(void *)(result + 16) = a3 + *(unsigned int *)(a2 + 4);
    }
    if (v8)
    {
      int v10 = *(_DWORD *)(v8 + 56);
      if (a4) {
        ++v10;
      }
      *(_DWORD *)(result + 56) = v10;
      *(void *)(v8 + 32) = result;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = result;
  }

  else
  {
    *(_DWORD *)(a1 + 16) = 1;
  }

  return result;
}

uint64_t sec_asn1e_init_state_based_on_template(uint64_t a1)
{
  do
  {
    uint64_t v2 = *(unsigned int **)(a1 + 8);
    unint64_t v3 = *v2;
    unint64_t v4 = v3 & 0x200;
    uint64_t v5 = (v3 >> 8) & 1;
    if ((v3 & 0x100000) != 0)
    {
      unsigned int v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      unint64_t v18 = 0x100000LL;
LABEL_39:
      LODWORD(v16) = v3;
      goto LABEL_40;
    }

    BOOL v6 = (v3 & 0xC0) != 0 && v4 == 0;
    char v7 = !v6;
    if ((v3 & 0x1800) == 0 && (v7 & 1) != 0)
    {
      unsigned int v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      unint64_t v18 = v3 & 0xFF5BBCFF;
      goto LABEL_39;
    }

    *(_DWORD *)(a1 + 64) = 0;
    uint64_t v8 = *(uint64_t **)(a1 + 16);
    if ((v3 & 0x1000) != 0)
    {
      uint64_t v9 = *v8;
      *(_DWORD *)(a1 + 40) = 7;
      if ((v3 & 0x100) != 0 && v9 == 0) {
        return a1;
      }
    }

    else
    {
      if ((v3 & 0x800) != 0)
      {
        *(_DWORD *)(a1 + 40) = 6;
      }

      else
      {
        *(_BYTE *)(a1 + 44) = v3 & 0xE0;
        *(_BYTE *)(a1 + 45) = v3 & 0x1F;
        *(_DWORD *)(a1 + 40) = 5;
        *(_DWORD *)(a1 + 76) = v5;
      }

      uint64_t v9 = (uint64_t)v8;
    }

    uint64_t v11 = (uint64_t (**)(char *, uint64_t, void, void))*((void *)v2 + 1);
    if (v11 && (v3 & 0x4000) != 0)
    {
      if (*v11)
      {
        if (v8) {
          uint64_t v12 = (char *)v8 - v2[1];
        }
        else {
          uint64_t v12 = 0LL;
        }
        uint64_t v11 = (uint64_t (**)(char *, uint64_t, void, void))(*v11)(v12, 1LL, 0LL, 0LL);
      }

      else
      {
        uint64_t v11 = 0LL;
      }
    }

    uint64_t v13 = sec_asn1e_push_state(*(void *)a1, (uint64_t)v11, v9, 0);
    a1 = v13;
    if (!v13) {
      return a1;
    }
  }

  while ((v3 & 0xC0) == 0);
  unsigned int v14 = (v3 >> 18) & 1;
  unint64_t v15 = (v3 & 0x200000) >> 21;
  uint64_t v16 = **(unsigned int **)(v13 + 8);
  if ((v3 & 0x200000) != 0) {
    unsigned int v17 = (v3 >> 18) & 1;
  }
  else {
    unsigned int v17 = 1;
  }
  if ((v16 & 0x40000) != 0)
  {
    unsigned int v14 = v17;
    unint64_t v18 = v16 & 0xFFFFFFFFFFFBFFFFLL;
  }

  else
  {
    unint64_t v18 = **(unsigned int **)(v13 + 8);
  }

unint64_t sec_asn1e_contents_length( _DWORD *a1, unint64_t *a2, unsigned int a3, uint64_t a4, int *a5)
{
  uint64_t v8 = a1;
  unsigned int v9 = *a1;
  if ((*a1 & 0x200000) != 0) {
    uint64_t v10 = 1LL;
  }
  else {
    uint64_t v10 = a3;
  }
  if ((v9 & 0x100000) != 0)
  {
    while (v8[6])
    {
      unsigned int v14 = v8 + 12;
      uint64_t v15 = 1LL;
      while (*(_DWORD *)a2 != *(v14 - 2))
      {
        ++v15;
        int v16 = *v14;
        v14 += 6;
        if (!v16) {
          return 0LL;
        }
      }

      uint64_t v17 = (uint64_t)a2 - v8[1];
      v8 += 6 * v15;
      unsigned int v9 = *v8;
      a2 = (unint64_t *)(v17 + v8[1]);
      if ((*v8 & 0x200000) != 0) {
        uint64_t v10 = 1LL;
      }
      else {
        uint64_t v10 = v10;
      }
      if ((v9 & 0x100000) == 0) {
        goto LABEL_5;
      }
    }

    return 0LL;
  }

uint64_t SEC_ASN1EncoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = PORT_NewArena(2048);
  if (!v8) {
    return 0LL;
  }
  unsigned int v9 = v8;
  uint64_t v10 = PORT_ArenaAlloc((uint64_t)v8, 0x48uLL);
  if (!v10) {
    goto LABEL_5;
  }
  uint64_t v11 = v10;
  *(_OWORD *)(v10 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(void *)uint64_t v10 = v9;
  *(void *)(v10 + 56) = a3;
  *(void *)(v10 + 64) = a4;
  *(_DWORD *)(v10 + 16) = 2;
  if (!sec_asn1e_push_state(v10, a2, a1, 0) || !sec_asn1e_init_state_based_on_template(*(void *)(v11 + 8)))
  {
LABEL_5:
    PORT_FreeArena(v9, 0);
    return 0LL;
  }

  return v11;
}

uint64_t SEC_ASN1Encode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = SEC_ASN1EncoderStart(a1, a2, a3, a4);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (void **)v4;
  uint64_t v6 = SEC_ASN1EncoderUpdate(v4, 0LL, 0LL);
  PORT_FreeArena(*v5, 0);
  return v6;
}

void *sec_asn1e_encode_item_count(void *result, uint64_t a2, uint64_t a3)
{
  *result += a3;
  return result;
}

void *sec_asn1e_encode_item_store(void *result, const void *a2, size_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    unint64_t result = memcpy((void *)(result[1] + *result), a2, a3);
    *v4 += a3;
  }

  return result;
}

uint64_t sec_asn1e_allocate_item(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v4 = (uint64_t)a2;
  if (a1)
  {
    if (a2 || (uint64_t result = PORT_ArenaAlloc(a1, 0x10uLL), (v4 = result) != 0))
    {
      uint64_t v7 = PORT_ArenaAlloc(a1, a3);
      *(void *)(v4 + _Block_object_dispose(va, 8) = v7;
      if (v7) {
        return v4;
      }
      else {
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t v8 = a2;
    if (a2 || (uint64_t result = (uint64_t)PORT_Alloc(0x10uLL), (v8 = (void *)result) != 0LL))
    {
      unint64_t v9 = (unint64_t)PORT_Alloc(a3);
      v8[1] = v9;
      uint64_t result = v9 ? (uint64_t)v8 : 0LL;
      if (!(v4 | v9))
      {
        free(v8);
        return 0LL;
      }
    }
  }

  return result;
}

void *SEC_ASN1EncodeItem(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v11 = 0LL;
  uint64_t v8 = 0LL;
  if (!SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_count, (uint64_t)&v11))
  {
    item = (void *)sec_asn1e_allocate_item(a1, a2, v11);
    uint64_t v8 = item;
    if (item)
    {
      if (item[1])
      {
        void *item = 0LL;
        SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_store, (uint64_t)item);
      }

      else
      {
        return 0LL;
      }
    }
  }

  return v8;
}

void *SEC_ASN1EncodeInteger(uint64_t a1, void *a2, unint64_t a3)
{
  char v3 = a3;
  uint64_t v4 = -1LL;
  unint64_t v5 = a3;
  do
  {
    uint64_t v6 = v4++;
    BOOL v7 = v5 > 0xFF;
    v5 >>= 8;
  }

  while (v7);
  uint64_t v8 = v6 + 2;
  uint64_t result = (void *)sec_asn1e_allocate_item(a1, a2, v6 + 2);
  if (result)
  {
    *uint64_t result = v8;
    do
    {
      *(_BYTE *)(result[1] + v4) = v3;
      char v3 = 0;
      --v4;
    }

    while (v4 != -1);
  }

  return result;
}

uint64_t SecAsn1DecodeTime(uint64_t a1, double *a2)
{
  CFErrorRef err = 0LL;
  uint64_t v4 = PORT_NewArena(1024);
  if (!v4) {
    return 4294967188LL;
  }
  unint64_t v5 = v4;
  memset(v10, 170, sizeof(v10));
  uint64_t Code = SEC_ASN1Decode((uint64_t)v4, (uint64_t)v10, (uint64_t)&kSecAsn1TimeTemplate, *(char **)(a1 + 8), *(void *)a1);
  if (!(_DWORD)Code)
  {
    double v8 = SecAbsoluteTimeFromDateContentWithError(LOBYTE(v10[2]), (unsigned __int8 *)v10[1], v10[0], &err);
    if (err)
    {
      uint64_t Code = CFErrorGetCode(err);
      CFErrorRef v9 = err;
      if (err)
      {
        CFErrorRef err = 0LL;
        CFRelease(v9);
      }
    }

    else
    {
      uint64_t Code = 0LL;
      if (a2) {
        *a2 = v8;
      }
    }
  }

  PORT_FreeArena(v5, 0);
  return Code;
}

uint64_t SecAsn1EncodeTime(uint64_t a1, uint64_t a2, CFAbsoluteTime a3)
{
  CFDateFormatterRef ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(0LL, 0LL);
  if (ISO8601Formatter)
  {
    BOOL v7 = ISO8601Formatter;
    CFTimeZoneRef v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(0LL, 0.0);
    CFDateFormatterSetProperty(v7, (CFStringRef)*MEMORY[0x189604EF0], v8);
    CFDateFormatterSetFormat(v7, @"yyyyMMddHHmmss'Z'");
    StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0LL, v7, a3);
    CFRelease(v8);
    CFRelease(v7);
  }

  else
  {
    time_t v19 = (uint64_t)(*MEMORY[0x189604DA8] + a3);
    memset(&v18, 0, sizeof(v18));
    StringWithAbsoluteTime = 0LL;
    if (gmtime_r(&v19, &v18) == &v18) {
      StringWithAbsoluteTime = CFStringCreateWithFormat( 0LL,  0LL,  @"%04d%02d%02d%02d%02d%02dZ",  (v18.tm_year + 1900),  (v18.tm_mon + 1),  v18.tm_mday,  v18.tm_hour,  v18.tm_min,  v18.tm_sec);
    }
  }

  CFIndex Length = CFStringGetLength(StringWithAbsoluteTime);
  if (!StringWithAbsoluteTime) {
    return 4294967188LL;
  }
  if (a3 < -1609459200.0 || a3 > 1546300800.0)
  {
    unint64_t v11 = (const __CFString *)CFRetain(StringWithAbsoluteTime);
    char v12 = 24;
  }

  else
  {
    v21.CFIndex length = Length - 2;
    v21.CFIndex location = 2LL;
    unint64_t v11 = CFStringCreateWithSubstring(0LL, StringWithAbsoluteTime, v21);
    char v12 = 23;
  }

  *(_BYTE *)(a2 + 16) = v12;
  CFIndex v14 = CFStringGetLength(v11);
  if (v14 < 0)
  {
    uint64_t v13 = 4294967188LL;
  }

  else
  {
    CFIndex v15 = v14;
    *(void *)a2 = v14;
    int v16 = (UInt8 *)PORT_ArenaAlloc(a1, v14);
    *(void *)(a2 + _Block_object_dispose(va, 8) = v16;
    uint64_t v13 = 4294967188LL;
    if (v16)
    {
      v20.CFIndex location = 0LL;
      v20.CFIndex length = v15;
      if (v15 == CFStringGetBytes(v11, v20, 0x8000100u, 0, 0, v16, v15, 0LL)) {
        uint64_t v13 = 0LL;
      }
      else {
        uint64_t v13 = 4294967188LL;
      }
    }
  }

  CFRelease(StringWithAbsoluteTime);
  if (v11) {
    CFRelease(v11);
  }
  return v13;
}

void *PORT_Alloc(size_t a1)
{
  if (a1 >> 31) {
    goto LABEL_5;
  }
  if (a1 <= 1) {
    a1 = 1LL;
  }
  uint64_t result = malloc(a1);
  if (!result)
  {
LABEL_5:
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v3);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE01300000000LL;
    }
    return 0LL;
  }

  return result;
}

_DWORD *PORT_SetError(int a1)
{
  uint64_t result = PR_getThreadErrInfo(1, &v3);
  if (result)
  {
    *uint64_t result = 0;
    result[1] = a1;
  }

  return result;
}

void *PORT_ZAlloc(unint64_t a1)
{
  if (a1 >> 31 || (a1 <= 1 ? (v1 = 1LL) : (v1 = a1), (uint64_t result = calloc(1uLL, v1)) == 0LL))
  {
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v4);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE01300000000LL;
    }
    return 0LL;
  }

  return result;
}

uint64_t PORT_GetError()
{
  int v2 = -1431655766;
  ThreadErrInfo = PR_getThreadErrInfo(0, &v2);
  if (ThreadErrInfo) {
    return *((unsigned int *)ThreadErrInfo + 1);
  }
  if (v2) {
    return 4294961322LL;
  }
  return 0LL;
}

_DWORD *PORT_NewArena(int a1)
{
  uint64_t result = PORT_ZAlloc(0x40uLL);
  if (result)
  {
    result[14] = -1196647457;
    *((void *)result + 6) = 7LL;
    unint64_t v3 = ((unint64_t)result + 39) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)result + 2) = v3;
    *((void *)result + 3) = v3;
    *(void *)uint64_t result = 0LL;
    *((void *)result + 1) = v3;
    *((void *)result + 4) = result;
    result[10] = a1;
  }

  return result;
}

uint64_t PORT_ArenaAlloc(uint64_t a1, unint64_t a2)
{
  if (a2 <= 1) {
    unint64_t v2 = 1LL;
  }
  else {
    unint64_t v2 = a2;
  }
  if (!(v2 >> 31))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    unsigned int v5 = (*(void *)(a1 + 48) + v2) & ~*(void *)(a1 + 48);
    uint64_t result = *(void *)(v4 + 24);
    if (v5 >= v2)
    {
      if (v5 <= (unint64_t)(*(void *)(v4 + 16) - result))
      {
        *(void *)(v4 + 24) = v5 + result;
        if (result) {
          return result;
        }
      }

      else
      {
        uint64_t result = PL_ArenaAllocate(a1, v5);
        if (result) {
          return result;
        }
      }
    }
  }

  ++port_allocFailures;
  ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
  if (ThreadErrInfo) {
    void *ThreadErrInfo = 0xFFFFE01300000000LL;
  }
  return 0LL;
}

void PORT_FreeArena(void *a1, int a2)
{
  if (a2)
  {
    unint64_t v3 = (void *)*a1;
    if (!*a1) {
      goto LABEL_7;
    }
    do
    {
      uint64_t v4 = (void *)v3[1];
      uint64_t v5 = v3[2];
      v3[3] = v4;
      bzero(v4, v5 - (void)v4);
      unint64_t v3 = (void *)*v3;
    }

    while (v3);
  }

  while (1)
  {
    uint64_t v6 = (void *)*a1;
    if (!*a1) {
      break;
    }
    *a1 = *v6;
    free(v6);
  }

char *PORT_ArenaGrow(uint64_t a1, char *a2, unint64_t a3, unint64_t a4)
{
  if (a4 >> 31)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v18);
    if (ThreadErrInfo)
    {
      unint64_t v5 = 0xFFFFE01300000000LL;
LABEL_7:
      void *ThreadErrInfo = v5;
      return 0LL;
    }

    return 0LL;
  }

  BOOL v6 = a4 >= a3;
  unsigned int v7 = a4 - a3;
  if (!v6)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v19);
    if (ThreadErrInfo)
    {
      unint64_t v5 = 0xFFFFE00100000000LL;
      goto LABEL_7;
    }

    return 0LL;
  }

  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = &a2[a3];
  unint64_t v11 = (unint64_t)&v10[v7];
  if (v10 > a2 && v11 > (unint64_t)a2 && v11 > (unint64_t)v10)
  {
    uint64_t v15 = *(void *)(a1 + 48);
    unint64_t v16 = (v15 + v11) & ~v15;
    BOOL v17 = *(char **)(v9 + 24) != &a2[~(_DWORD)v15 & (v15 + a3)] || v11 > v16;
    if (!v17 && *(void *)(v9 + 16) >= v16)
    {
      *(void *)(v9 + 24) = v16;
      return a2;
    }
  }

  return PL_ArenaGrow(a1, a2, a3, v7);
}

BOOL nssCompareSecAsn1Items(BOOL result, uint64_t a2)
{
  if (result)
  {
    unint64_t v2 = (size_t *)result;
    uint64_t result = 0LL;
    if (a2)
    {
      unint64_t v3 = (const void *)v2[1];
      if (v3) {
        return *(void *)(a2 + 8) && *v2 == *(void *)a2 && memcmp(v3, *(const void **)(a2 + 8), *v2) == 0;
      }
    }
  }

  return result;
}

const SecAsn1Template *NSS_P12_CertBagChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Certificate))
  {
    int v4 = 1;
    uint64_t result = kSecAsn1OctetStringTemplate;
    if (a2) {
      return result;
    }
    goto LABEL_3;
  }

  BOOL v6 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_SdsiCertificate);
  BOOL v7 = v6;
  if (v6) {
    uint64_t result = kSecAsn1IA5StringTemplate;
  }
  else {
    uint64_t result = 0LL;
  }
  int v4 = 2 * v7;
  if (!a2) {
LABEL_3:
  }
    *(_DWORD *)(a1 + 16) = v4;
  return result;
}

const SecAsn1Template *NSS_P12_CrlBagChooser(uint64_t a1, int a2)
{
  BOOL v4 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Crl);
  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  if (v4) {
    return kSecAsn1OctetStringTemplate;
  }
  else {
    return 0LL;
  }
}

const SecAsn1Template *NSS_P12_SafeBagChooser(uint64_t a1, int a2)
{
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_keyBag))
  {
    int v4 = 1;
    unint64_t v5 = kSecAsn1PointerToAnyTemplate;
  }

  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_shroudedKeyBag))
  {
    int v4 = 2;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToShroudedKeyBagTemplate;
  }

  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_certBag))
  {
    int v4 = 3;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToCertBagTemplate;
  }

  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_crlBag))
  {
    int v4 = 4;
    unint64_t v5 = (const SecAsn1Template *)&NSS_P12_PtrToCrlBagTemplate;
  }

  else
  {
    unint64_t v5 = kSecAsn1PointerToAnyTemplate;
    if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_secretBag))
    {
      int v4 = 5;
    }

    else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_safeContentsBag))
    {
      int v4 = 6;
    }

    else
    {
      unint64_t v5 = 0LL;
      int v4 = 0;
    }
  }

  if (!a2) {
    *(_DWORD *)(a1 + 16) = v4;
  }
  return v5;
}

uint64_t SEC_ASN1DecodeInteger(uint64_t *a1, uint64_t *a2)
{
  if (!a1)
  {
    unint64_t v3 = (int *)&v9;
    goto LABEL_13;
  }

  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 9)
  {
    unint64_t v3 = (int *)&v10;
LABEL_13:
    ThreadErrInfo = PR_getThreadErrInfo(1, v3);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00500000000LL;
    }
    return 0xFFFFFFFFLL;
  }

  int v4 = (unsigned __int8 *)a1[1];
  if (!v4)
  {
    unint64_t v3 = (int *)&v11;
    goto LABEL_13;
  }

  uint64_t v5 = (uint64_t)(char)*v4 >> 7;
  if (v2)
  {
    else {
      uint64_t v2 = v2;
    }
    do
    {
      unsigned int v6 = *v4++;
      uint64_t v5 = v6 | (unint64_t)(v5 << 8);
      --v2;
    }

    while (v2);
  }

  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t SEC_ASN1DecoderUpdate(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 == 2) {
    goto LABEL_4;
  }
  if (v8 == 3)
  {
    *(_DWORD *)(a1 + 24) = 2;
LABEL_4:
    uint64_t v198 = v7;
    while (1)
    {
      char v9 = *(void **)(a1 + 16);
      while (2)
      {
        uint64_t result = 0LL;
        switch(*((_DWORD *)v9 + 12))
        {
          case 0:
            if (!a3) {
              goto LABEL_163;
            }
            int v19 = v3;
            char v20 = *a2;
            if ((*a2 & 0x1F) == 0x1F)
            {
              *((_DWORD *)v9 + 12) = 1;
              void v9[8] = 0LL;
              v9[12] = 1LL;
LABEL_229:
              int v15 = 0;
              int v17 = 0;
              uint64_t v161 = 0LL;
              *((_BYTE *)v9 + 52) = v20 & 0xE0;
              unint64_t v14 = 1LL;
              int v16 = 1;
              goto LABEL_386;
            }

            if (*a2 || !sec_asn1d_parent_allows_EOC(v9[4]))
            {
              *((_DWORD *)v9 + 12) = 2;
              void v9[8] = v20 & 0x1F;
              goto LABEL_229;
            }

            *((_DWORD *)v9 + 12) = 21;
            v9[12] = 2LL;
            void v9[8] = 0LL;
            *((_BYTE *)v9 + 52) = 0;
            int v16 = 1;
            int v17 = *((unsigned __int8 *)v9 + 141);
            unint64_t v14 = 0LL;
            int v15 = 0;
            if (*((_BYTE *)v9 + 141))
            {
              int v17 = 0;
              uint64_t v161 = 0LL;
              *((_BYTE *)v9 + 140) = 1;
            }

            else
            {
              uint64_t v161 = 0LL;
            }

            goto LABEL_386;
          case 1:
            if (!a3)
            {
LABEL_163:
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v17 = 0;
              uint64_t v161 = 0LL;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 3;
              goto LABEL_164;
            }

            unint64_t v14 = 0LL;
            uint64_t v21 = v9[12];
            unint64_t v22 = a3;
LABEL_19:
            --v22;
            unint64_t v23 = v14;
            while (1)
            {
              if (!v21) {
                goto LABEL_27;
              }
              unint64_t v24 = v9[8];
              if (v24 >> 57) {
                break;
              }
              void v9[8] = v24 << 7;
              unint64_t v25 = v23 + 1;
              unsigned __int8 v26 = a2[v23];
              void v9[8] = v26 & 0x7F | (v24 << 7);
              if ((v26 & 0x80) == 0)
              {
                uint64_t v21 = 0LL;
                v9[12] = 0LL;
                unint64_t v14 = v25;
                if (!v22)
                {
                  unint64_t v14 = a3;
LABEL_27:
                  int v15 = 0;
                  int v17 = 0;
                  uint64_t v161 = 0LL;
                  *((_DWORD *)v9 + 12) = 2;
LABEL_164:
                  int v16 = 1;
                  goto LABEL_340;
                }

                goto LABEL_19;
              }

              --v22;
              int v16 = 1;
              unint64_t v23 = v25;
              if (v22 == -1LL)
              {
                int v15 = 0;
                int v17 = 0;
                uint64_t v161 = 0LL;
                unint64_t v14 = a3;
                goto LABEL_340;
              }
            }

            ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v199);
            if (ThreadErrInfo) {
              void *ThreadErrInfo = 0xFFFFE00900000000LL;
            }
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v17 = 0;
            uint64_t v161 = 0LL;
            int v16 = 1;
            *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
            goto LABEL_340;
          case 2:
            uint64_t v27 = v9[7];
            if ((v27 & *((_BYTE *)v9 + 52)) == (unint64_t)*((unsigned __int8 *)v9 + 53)
              && (v9[8] & v27) == v9[9])
            {
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *((_DWORD *)v9 + 12) = 3;
              goto LABEL_339;
            }

            if (!*((_BYTE *)v9 + 141)) {
              goto LABEL_172;
            }
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *((_BYTE *)v9 + 140) = 1;
            goto LABEL_272;
          case 3:
            if (!a3) {
              goto LABEL_167;
            }
            *((_DWORD *)v9 + 12) = 5;
            uint64_t v28 = *a2;
            if (*a2 < 0)
            {
              uint64_t v143 = v28 & 0x7F;
              v9[11] = 0LL;
              v9[12] = v143;
              if ((_DWORD)v143) {
                *((_DWORD *)v9 + 12) = 4;
              }
              else {
                *((_BYTE *)v9 + 139) = 1;
              }
            }

            else
            {
              v9[11] = v28;
            }

            if (*((_BYTE *)v9 + 139) || (*((_BYTE *)v9 + 81) & 0x84) == 0)
            {
              int v15 = 0;
              int v16 = 0;
            }

            else
            {
              int v15 = 0;
              int v16 = 0;
              *((_BYTE *)v9 + 52) &= ~0x20u;
            }

            unint64_t v14 = 1LL;
            goto LABEL_321;
          case 4:
            if (!a3)
            {
LABEL_167:
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 3;
              goto LABEL_321;
            }

            uint64_t v29 = 0LL;
            unint64_t v14 = v9[12];
            uint64_t v30 = a2;
            while (1)
            {
              if (!(v14 + v29)) {
                goto LABEL_233;
              }
              unint64_t v31 = v9[11];
              if (v31 >> 55) {
                break;
              }
              v9[11] = v31 << 8;
              unsigned __int8 v32 = *v30++;
              v9[11] = v32 | (v31 << 8);
              v9[12] = v14 + v29-- - 1;
              if (!(a3 + v29))
              {
                uint64_t v33 = v14 + v29;
                unint64_t v14 = a3;
                if (v33)
                {
                  int v15 = 0;
                  int v16 = 0;
                  int v17 = 1;
                  unint64_t v14 = a3;
                  goto LABEL_322;
                }

LABEL_233:
                int v15 = 0;
                int v16 = 0;
                *((_DWORD *)v9 + 12) = 5;
LABEL_321:
                int v17 = 1;
                goto LABEL_322;
              }
            }

            v159 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v159) {
              void *v159 = 0xFFFFE00900000000LL;
            }
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 1;
            *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
LABEL_322:
            uint64_t v161 = 1LL;
            goto LABEL_340;
          case 5:
            uint64_t v34 = v9[4];
            if (!v34) {
              goto LABEL_51;
            }
            while (1)
            {
              int v35 = *(_DWORD *)(v34 + 48);
              BOOL v36 = (v35 - 16) < 4 || v35 == 11;
              if (!v36 && v35 != 24) {
                break;
              }
              uint64_t v34 = *(void *)(v34 + 32);
              if (!v34) {
                goto LABEL_51;
              }
            }

LABEL_238:
              __int128 v140 = (void *)v9[2];
              if (!v140) {
                goto LABEL_359;
              }
              __int128 v141 = (uint64_t *)*v9;
              if (*(_DWORD *)(*v9 + 72LL))
              {
                uint64_t v142 = 0LL;
                *__int128 v140 = 0LL;
                v140[1] = 0LL;
LABEL_360:
                if (*((_BYTE *)v9 + 139)) {
                  goto LABEL_361;
                }
                v178 = v9 + 15;
                uint64_t v177 = v9[15];
                if (!v177) {
                  goto LABEL_361;
                }
                if (!v140) {
                  goto LABEL_172;
                }
                int v19 = v3;
                unint64_t v40 = 0LL;
                do
                {
LABEL_390:
                  uint64_t v184 = *(void *)(v177 + 8);
                  uint64_t v177 = *(void *)(v177 + 16);
                  v40 += v184;
                }

                while (v177);
LABEL_391:
                v185 = sec_asn1d_zalloc(v142, v40);
                v140[1] = v185;
                if (v185)
                {
                  uint64_t v186 = *v178;
                  if (*v178)
                  {
                    uint64_t v187 = 0LL;
                    do
                    {
                      memcpy((void *)(v140[1] + v187), *(const void **)v186, *(void *)(v186 + 8));
                      uint64_t v188 = *(void *)(v186 + 8);
                      uint64_t v186 = *(void *)(v186 + 16);
                      v187 += v188;
                    }

                    while (v186);
                  }

                  else
                  {
                    uint64_t v187 = 0LL;
                  }

                  *__int128 v140 = v187;
                  v9[15] = 0LL;
                  uint8_t v9[16] = 0LL;
                  unint64_t v40 = v9[11];
                  unint64_t v3 = v19;
LABEL_361:
                  if (!v40)
                  {
                    int v16 = *((unsigned __int8 *)v9 + 139);
                    if (!*((_BYTE *)v9 + 139))
                    {
                      unint64_t v14 = 0LL;
                      int v15 = 0;
                      goto LABEL_271;
                    }
                  }

                  if ((*((_BYTE *)v9 + 52) & 0x20) == 0)
                  {
                    if (*((_BYTE *)v9 + 139)) {
                      goto LABEL_172;
                    }
                    unint64_t v14 = 0LL;
                    int v15 = 0;
                    int v16 = 0;
                    int v17 = 0;
                    if (v9[10] == 3LL) {
                      int v18 = 6;
                    }
                    else {
                      int v18 = 10;
                    }
                    goto LABEL_273;
                  }

                  uint64_t v175 = v9[10];
                  if (v175 > 1023)
                  {
                    if (v175 == 1024)
                    {
                      v176 = kSecAsn1AnyTemplate;
                    }

                    else if (v175 == 0x8000)
                    {
                      v176 = kSecAsn1SkipTemplate;
                    }

                    else
                    {
                      v176 = kSecAsn1AnyTemplate;
                      if (v175 != 66560) {
LABEL_416:
                      }
                        v176 = 0LL;
                    }
                  }

                  else
                  {
                    switch(v175)
                    {
                      case 12LL:
                        v176 = kSecAsn1UTF8StringTemplate;
                        break;
                      case 13LL:
                      case 14LL:
                      case 15LL:
                      case 16LL:
                      case 17LL:
                      case 18LL:
                      case 21LL:
                      case 25LL:
                      case 27LL:
                      case 29LL:
                        goto LABEL_416;
                      case 19LL:
                        v176 = kSecAsn1PrintableStringTemplate;
                        break;
                      case 20LL:
                        v176 = kSecAsn1T61StringTemplate;
                        break;
                      case 22LL:
                        v176 = kSecAsn1IA5StringTemplate;
                        break;
                      case 23LL:
                        v176 = kSecAsn1UTCTimeTemplate;
                        break;
                      case 24LL:
                        v176 = kSecAsn1GeneralizedTimeTemplate;
                        break;
                      case 26LL:
                        v176 = kSecAsn1VisibleStringTemplate;
                        break;
                      case 28LL:
                        v176 = kSecAsn1UniversalStringTemplate;
                        break;
                      case 30LL:
                        v176 = kSecAsn1BMPStringTemplate;
                        break;
                      default:
                        if (v175 == 3)
                        {
                          v176 = kSecAsn1BitStringTemplate;
                        }

                        else
                        {
                          if (v175 != 4) {
                            goto LABEL_416;
                          }
                          v176 = kSecAsn1OctetStringTemplate;
                        }

                        break;
                    }
                  }

                  *((_DWORD *)v9 + 12) = 8;
                  v173 = sec_asn1d_push_state(*v9, (uint64_t)v176, (uint64_t)v140, 1);
                  if (v173)
                  {
                    *((_BYTE *)v173 + 142) = 1;
                    goto LABEL_336;
                  }

LABEL_337:
                  unint64_t v14 = 0LL;
LABEL_338:
                  int v15 = 0;
                  int v16 = 0;
                  int v17 = 0;
LABEL_339:
                  uint64_t v161 = 2LL;
                  goto LABEL_340;
                }

                goto LABEL_432;
              }

              if (*((_BYTE *)v9 + 142))
              {
                if (v140[1])
                {
LABEL_359:
                  uint64_t v142 = 0LL;
                  goto LABEL_360;
                }
              }

              else
              {
                ++v141;
                *__int128 v140 = 0LL;
                v140[1] = 0LL;
              }

              uint64_t v142 = *v141;
              if (!v40) {
                goto LABEL_360;
              }
              int v19 = v3;
              v178 = v9 + 15;
              uint64_t v177 = v9[15];
              if (v177) {
                goto LABEL_390;
              }
              goto LABEL_391;
            }

            if (!v40)
            {
              int v16 = *((unsigned __int8 *)v9 + 139);
              if (!*((_BYTE *)v9 + 139))
              {
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v17 = 0;
LABEL_247:
                int v18 = 14;
LABEL_273:
                *((_DWORD *)v9 + 12) = v18;
                goto LABEL_339;
              }
            }

            *((_DWORD *)v9 + 12) = 9;
            uint64_t v163 = v9[1];
            v164 = *(uint64_t (***)(uint64_t, void, unsigned __int8 *, unint64_t))(v163 + 8);
            if (v164 && (*(_BYTE *)(v163 + 1) & 0x40) != 0)
            {
              if (*v164)
              {
                uint64_t v171 = v9[2];
                if (v171) {
                  uint64_t v172 = v171 - *(unsigned int *)(v163 + 4);
                }
                else {
                  uint64_t v172 = 0LL;
                }
                int v19 = v3;
                v164 = (uint64_t (**)(uint64_t, void, unsigned __int8 *, unint64_t))(*v164)(v172, 0LL, (unsigned __int8 *)a2, a3);
              }

              else
              {
                int v19 = v3;
                v164 = 0LL;
              }
            }

            else
            {
              int v19 = v3;
            }

            v179 = sec_asn1d_push_state(*v9, (uint64_t)v164, 0LL, 1);
            unint64_t v14 = (unint64_t)v179;
            if (v179)
            {
              uint64_t v180 = *(void *)v179;
              if (!*(_DWORD *)(*(void *)v179 + 72LL)) {
                v179[136] = 1;
              }
LABEL_381:
              v181 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v180 + 32);
              if (v181)
              {
                uint64_t v182 = *(unsigned int *)(v14 + 112);
                uint64_t v183 = *(void *)(v14 + 16);
                *(_DWORD *)(v180 + 4_Block_object_dispose(va, 8) = 1;
                v181(*(void *)(v180 + 40), 1LL, v183, v182);
                *(_DWORD *)(v180 + 4_Block_object_dispose(va, 8) = 0;
              }

              sec_asn1d_init_state_based_on_template((void *)v14, (uint64_t)a2, a3);
              unint64_t v14 = 0LL;
            }

            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
LABEL_385:
            uint64_t v161 = 2LL;
LABEL_386:
            unint64_t v3 = v19;
LABEL_340:
            int v131 = *(_DWORD *)(a1 + 24);
LABEL_341:
            if (v131 == 1) {
              goto LABEL_450;
            }
            if (a3 < v14)
            {
              v194 = PR_getThreadErrInfo(1, (int *)&v199);
              if (v194) {
                void *v194 = 0xFFFFE00900000000LL;
              }
              *(_DWORD *)(a1 + 24) = 1;
LABEL_450:
              uint64_t v7 = v198;
LABEL_451:
              if (v9)
              {
LABEL_452:
                v195 = *(void **)(v7 + 32);
                do
                {
                  if (v195 == v9) {
                    break;
                  }
                  if (v9[5])
                  {
                    void v9[5] = 0LL;
                    void v9[3] = 0LL;
                  }

                  *((_DWORD *)v9 + 12) = 20;
                  char v9 = (void *)v9[4];
                }

                while (v9);
              }

              return 0xFFFFFFFFLL;
            }

            char v9 = *(void **)(a1 + 16);
            if (!v9 || *(_DWORD *)v9[1] == 0x80000)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 0;
              return result;
            }

            if (!v14)
            {
              if (v131 != 2) {
                return 0LL;
              }
              continue;
            }

            if (v9[10] == 1024LL && (v16 | v17) == 1 && !*(_DWORD *)(a1 + 72)) {
              sec_asn1d_record_any_header(*(uint64_t ***)(a1 + 16), a2, v14);
            }
            v192 = *(void (**)(void, char *, unint64_t, uint64_t, uint64_t))(*v9 + 56LL);
            if (v192)
            {
              uint64_t v193 = *((unsigned int *)v9 + 28);
              if (v15) {
                uint64_t v193 = v193 - (*((_BYTE *)v9 + 139) == 0);
              }
              v192(*(void *)(*v9 + 64LL), a2, v14, v193, v161);
            }

            v9[13] += v14;
            a2 += v14;
            int v8 = *(_DWORD *)(a1 + 24);
            a3 -= v14;
            if (v8 != 2)
            {
              uint64_t v7 = v198;
              goto LABEL_444;
            }

            break;
          case 6:
            uint64_t v53 = v9[12];
            if (!v53)
            {
              unsigned int v118 = (void *)v9[2];
              if (v118)
              {
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                *unsigned int v118 = 0LL;
                v118[1] = 0LL;
                uint64_t v161 = 2LL;
                int v119 = 20;
                goto LABEL_170;
              }
            }

            if (!a3)
            {
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 3;
              goto LABEL_339;
            }

            unsigned int v54 = *a2;
            if (v54 >= 8) {
              goto LABEL_172;
            }
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *((_DWORD *)v9 + 29) = v54;
            *((_DWORD *)v9 + 12) = 7;
            v9[12] = v53 - 1;
            uint64_t v161 = 2LL;
            unint64_t v14 = 1LL;
            goto LABEL_340;
          case 7:
            if (v9[12]) {
              goto LABEL_90;
            }
            int v16 = *((_DWORD *)v9 + 29);
            if (v16) {
              goto LABEL_172;
            }
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v17 = 0;
            goto LABEL_13;
          case 8:
            uint64_t v55 = v9[5];
            unint64_t v56 = *(void *)(v55 + 104);
            *(void *)(v55 + 104) = 0LL;
            unint64_t v57 = v9[12];
            v9[13] += v56;
            if (v57)
            {
              BOOL v58 = v57 >= v56;
              unint64_t v59 = v57 - v56;
              if (!v58) {
                goto LABEL_172;
              }
              v9[12] = v59;
              if (v59) {
                goto LABEL_95;
              }
            }

            else
            {
              uint64_t v121 = *(unint64_t **)(v55 + 16);
              int v122 = v9;
              while (v121 == (unint64_t *)v122[2])
              {
                if (!*((_BYTE *)v122 + 139)) {
                  break;
                }
                uint64_t v123 = v122[4];
                if (!v123) {
                  break;
                }
                while (1)
                {
                  int v124 = *(_DWORD *)(v123 + 48);
                  BOOL v125 = (v124 - 16) < 4 || v124 == 24;
                  if (!v125 && v124 != 11) {
                    break;
                  }
                  uint64_t v123 = *(void *)(v123 + 32);
                  if (!v123) {
                    goto LABEL_219;
                  }
                }

                if (*(void *)(v123 + 80) != v122[10]) {
                  break;
                }
                int v122 = (void *)v123;
                if (!*(_BYTE *)(v123 + 139))
                {
                  char v127 = 1;
                  goto LABEL_220;
                }
              }

LABEL_219:
              char v127 = 0;
LABEL_220:
              if (v121)
              {
                __int128 v138 = (void *)v121[1];
                if (!v138) {
                  char v127 = 1;
                }
                if ((v127 & 1) == 0)
                {
                  sec_asn1d_add_to_subitems((uint64_t **)v9, v138, *v121, 0);
                  *uint64_t v121 = 0LL;
                  v121[1] = 0LL;
                }
              }

              if (!*(_BYTE *)(v55 + 137))
              {
LABEL_95:
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                *(_DWORD *)(v55 + 4_Block_object_dispose(va, 8) = 0;
                *(_BYTE *)(v55 + 137) = 0;
                *(_WORD *)(v55 + 139) = 0;
                *(void *)(*v9 + 16LL) = v55;
                goto LABEL_339;
              }
            }

            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *(_DWORD *)(v55 + 4_Block_object_dispose(va, 8) = 26;
            int v18 = 13;
            goto LABEL_273;
          case 9:
            uint64_t v60 = v9[5];
            unint64_t v61 = *(void *)(v60 + 104);
            *(void *)(v60 + 104) = 0LL;
            v9[13] += v61;
            if (*(_BYTE *)(v60 + 137) && !*(_BYTE *)(v60 + 139))
            {
              v144 = *(void **)(v60 + 16);
              if (v144 && !v9[15])
              {
                sec_asn1d_add_to_subitems((uint64_t **)v9, v144, 0LL, 0);
                *(void *)(v60 + 16) = 0LL;
              }

LABEL_246:
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *(_DWORD *)(v60 + 4_Block_object_dispose(va, 8) = 26;
              goto LABEL_247;
            }

            int v19 = v3;
            uint64_t v62 = *v9;
            uint64_t v63 = *(void (**)(void, void, uint64_t, uint64_t))(*v9 + 32LL);
            if (v63)
            {
              uint64_t v64 = *(unsigned int *)(v60 + 112);
              uint64_t v65 = *(void *)(v60 + 16);
              *(_DWORD *)(v62 + 4_Block_object_dispose(va, 8) = 1;
              v63(*(void *)(v62 + 40), 0LL, v65, v64);
              *(_DWORD *)(v62 + 4_Block_object_dispose(va, 8) = 0;
            }

            uint64_t v66 = *(void *)(v60 + 16);
            if (v66)
            {
              sec_asn1d_add_to_subitems( (uint64_t **)v9,  (void *)(v66 - *(unsigned int *)(*(void *)(v60 + 8) + 4LL)),  0LL,  0);
              *(void *)(v60 + 16) = 0LL;
            }

            unint64_t v67 = v9[12];
            if (v67)
            {
              unint64_t v3 = v19;
              BOOL v58 = v67 >= v61;
              unint64_t v68 = v67 - v61;
              if (!v58) {
                goto LABEL_172;
              }
              v9[12] = v68;
              if (!v68) {
                goto LABEL_246;
              }
            }

            uint64_t v69 = *v9;
            int v70 = *(void (**)(void, uint64_t, void, uint64_t))(*v9 + 32LL);
            if (v70)
            {
              uint64_t v71 = *(unsigned int *)(v60 + 112);
              *(_DWORD *)(v69 + 4_Block_object_dispose(va, 8) = 1;
              v70(*(void *)(v69 + 40), 1LL, 0LL, v71);
              *(_DWORD *)(v69 + 4_Block_object_dispose(va, 8) = 0;
            }

            *(_DWORD *)(v60 + 4_Block_object_dispose(va, 8) = 0;
            *(_BYTE *)(v60 + 137) = 0;
            *(_WORD *)(v60 + 139) = 0;
            sec_asn1d_init_state_based_on_template((void *)v60, (uint64_t)a2, a3);
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *(void *)(*v9 + 16LL) = v60;
            goto LABEL_385;
          case 0xA:
LABEL_90:
            unint64_t v14 = sec_asn1d_parse_leaf((uint64_t)v9, a2, a3);
            goto LABEL_338;
          case 0xB:
            uint64_t v72 = v9[5];
            uint64_t v73 = *(void *)(v72 + 104);
            *(void *)(v72 + 104) = 0LL;
            unint64_t v74 = (uint64_t *)v9[2];
            if (*(void *)(v72 + 40))
            {
              *(void *)(v72 + 40) = 0LL;
              *(void *)(v72 + 24) = 0LL;
            }

            *(_DWORD *)(v72 + 4_Block_object_dispose(va, 8) = 20;
            uint64_t v75 = *v9;
            unint64_t v76 = *(void (**)(void, void))(*v9 + 32LL);
            if (v76)
            {
              uint64_t v77 = *((unsigned int *)v9 + 28);
              *(_DWORD *)(v75 + 4_Block_object_dispose(va, 8) = 1;
              ((void (*)(void, void, uint64_t *, uint64_t))v76)(*(void *)(v75 + 40), 0LL, v74, v77);
              *(_DWORD *)(v75 + 4_Block_object_dispose(va, 8) = 0;
              uint64_t v78 = (uint64_t *)v9[2];
              uint64_t v75 = *v9;
              unint64_t v76 = *(void (**)(void, void))(*v9 + 32LL);
            }

            else
            {
              uint64_t v78 = v74;
            }

            uint64_t v128 = v9[1];
            __int128 v129 = (char *)v78 - *(unsigned int *)(v128 + 4);
            v9[1] = v128 + 24;
            int v130 = &v129[*(unsigned int *)(v128 + 28)];
            *(void *)(v72 + _Block_object_dispose(va, 8) = v128 + 24;
            *(void *)(v72 + 16) = v130;
            if (v76)
            {
              *(_DWORD *)(v75 + 4_Block_object_dispose(va, 8) = 1;
              v76(*(void *)(v75 + 40), 1LL);
              *(_DWORD *)(v75 + 4_Block_object_dispose(va, 8) = 0;
              uint64_t v75 = *v9;
            }

            *((_DWORD *)v9 + 12) = 19;
            *(void *)(v75 + 16) = v72;
            sec_asn1d_init_state_based_on_template((void *)v72, v74[1], *v74);
            if (!SEC_ASN1DecoderUpdate(*v9, v74[1], *v74) && *(_DWORD *)(*v9 + 24LL) != 3)
            {
              *(void *)(v72 + 104) = 0LL;
              v9[13] += v73;
              *(_DWORD *)(v72 + 4_Block_object_dispose(va, 8) = 26;
              *((_DWORD *)v9 + 12) = 22;
            }

            int v131 = *(_DWORD *)(a1 + 24);
            if (v131 == 1) {
              return 0xFFFFFFFFLL;
            }
            if (v131 == 3) {
              goto LABEL_458;
            }
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            uint64_t v161 = 2LL;
            goto LABEL_341;
          case 0xC:
            uint64_t v197 = (uint64_t)a2;
            uint64_t v79 = v9[5];
            uint64_t v80 = *v9;
            uint64_t v81 = *(void (**)(void, void, uint64_t, uint64_t))(*v9 + 32LL);
            if (v81)
            {
              uint64_t v82 = *(unsigned int *)(v79 + 112);
              uint64_t v83 = *(void *)(v79 + 16);
              *(_DWORD *)(v80 + 4_Block_object_dispose(va, 8) = 1;
              v81(*(void *)(v80 + 40), 0LL, v83, v82);
              *(_DWORD *)(v80 + 4_Block_object_dispose(va, 8) = 0;
            }

            int v84 = *(unsigned __int8 *)(v79 + 140);
            unint64_t v85 = *(void *)(v79 + 104);
            *(void *)(v79 + 104) = 0LL;
            unint64_t v3 = &jpt_180596880;
            if (v84) {
              goto LABEL_116;
            }
            v9[13] += v85;
            if (*(void *)(v79 + 40))
            {
              *(void *)(v79 + 40) = 0LL;
              *(void *)(v79 + 24) = 0LL;
            }

            *(_DWORD *)(v79 + 4_Block_object_dispose(va, 8) = 20;
            unint64_t v132 = v9[12];
            if (!v132) {
              goto LABEL_116;
            }
            BOOL v58 = v132 >= v85;
            unint64_t v133 = v132 - v85;
            if (!v58)
            {
              uint64_t v134 = PR_getThreadErrInfo(1, (int *)&v199);
              if (v134) {
                *uint64_t v134 = 0xFFFFE00900000000LL;
              }
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
LABEL_329:
              uint64_t v161 = 2LL;
              a2 = (char *)v197;
              goto LABEL_340;
            }

            v9[12] = v133;
            if (v133)
            {
LABEL_116:
              uint64_t v86 = *(void *)(v79 + 8);
              int v87 = *(_DWORD *)(v86 + 24);
              *(void *)(v79 + _Block_object_dispose(va, 8) = v86 + 24;
              if (v87)
              {
                uint64_t v88 = v9[2];
                if (v88) {
                  *(void *)(v79 + 16) = v88 + *(unsigned int *)(v86 + 28);
                }
                uint64_t v89 = *v9;
                unint64_t v90 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*v9 + 32LL);
                if (v90)
                {
                  uint64_t v91 = *(unsigned int *)(v79 + 112);
                  uint64_t v92 = *(void *)(v79 + 16);
                  *(_DWORD *)(v89 + 4_Block_object_dispose(va, 8) = 1;
                  v90(*(void *)(v89 + 40), 1LL, v92, v91);
                  *(_DWORD *)(v89 + 4_Block_object_dispose(va, 8) = 0;
                }

                if (v84)
                {
                  char v93 = *(_BYTE *)(v79 + 52);
                  uint64_t v94 = *(void *)(v79 + 64);
                }

                else
                {
                  char v93 = 0;
                  uint64_t v94 = 0LL;
                }

                *(void *)(*v9 + 16LL) = v79;
                inited = sec_asn1d_init_state_based_on_template((void *)v79, v197, a3);
                int v15 = 0;
                unint64_t v14 = 0LL;
                uint64_t v161 = 2LL;
                if (v84 && inited)
                {
                  *((_DWORD *)inited + 12) = 2;
                  *((_BYTE *)inited + 52) = v93;
                  inited[8] = v94;
                  inited[13] = v85;
                  if (inited[10] == 1024LL)
                  {
                    a2 = (char *)v197;
                    if (!*(_DWORD *)(*inited + 72LL))
                    {
                      LOBYTE(v199) = v93 | v94;
                      sec_asn1d_record_any_header((uint64_t **)inited, &v199, 1uLL);
                    }

                    unint64_t v14 = 0LL;
                    int v15 = 0;
                    int v16 = 0;
                    int v17 = 0;
                    goto LABEL_301;
                  }

                  unint64_t v14 = 0LL;
                  int v15 = 0;
                  int v16 = 0;
                  int v17 = 0;
                }

                else
                {
                  int v16 = 0;
                  int v17 = 0;
                }

                a2 = (char *)v197;
LABEL_301:
                unint64_t v3 = &jpt_180596880;
                goto LABEL_340;
              }

              *(_DWORD *)(v79 + 4_Block_object_dispose(va, 8) = 26;
              if (v9[12])
              {
LABEL_231:
                uint64_t v120 = PR_getThreadErrInfo(1, (int *)&v199);
                a2 = (char *)v197;
                if (v120) {
                  goto LABEL_173;
                }
LABEL_174:
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
                goto LABEL_339;
              }

              if (v84)
              {
                if (!*((_BYTE *)v9 + 139) || !*(_BYTE *)(v79 + 137) || v85 != 2) {
                  goto LABEL_231;
                }
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                v9[13] += 2LL;
                int v167 = 22;
              }

              else
              {
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                int v167 = 20;
              }

              *((_DWORD *)v9 + 12) = v167;
              goto LABEL_329;
            }

            v165 = (int *)(*(void *)(v79 + 8) + 24LL);
            a2 = (char *)v197;
            while (1)
            {
              v166 = v165;
              int v17 = *v165;
              if (!*v165) {
                break;
              }
              v165 += 6;
              if ((v17 & 0x100) == 0)
              {
                *(void *)(v79 + _Block_object_dispose(va, 8) = v166;
                goto LABEL_172;
              }
            }

            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            *(void *)(v79 + _Block_object_dispose(va, 8) = v166;
            *(_DWORD *)(v79 + 4_Block_object_dispose(va, 8) = 26;
            uint64_t v161 = 2LL;
            int v119 = 22;
LABEL_170:
            *((_DWORD *)v9 + 12) = v119;
            goto LABEL_340;
          case 0xD:
            CFDataRef v96 = v9 + 15;
            uint64_t v95 = v9[15];
            if (!v95) {
              goto LABEL_270;
            }
            unint64_t v97 = 0LL;
            uint64_t v98 = v9[10];
            while (2)
            {
              while (1)
              {
                uint64_t v99 = *(void *)(v95 + 16);
                if (v98 == 3) {
                  break;
                }
                v97 += *(void *)(v95 + 8);
                uint64_t v95 = *(void *)(v95 + 16);
                if (!v99)
                {
                  uint64_t v101 = v3;
                  unint64_t v102 = v97;
                  if (v98 == 1024)
                  {
                    if (*((_BYTE *)v9 + 139)) {
                      v97 += 2LL;
                    }
                    unint64_t v102 = v97;
                  }

                  goto LABEL_263;
                }
              }

              uint64_t v100 = *(void *)(v95 + 8);
              if (v99)
              {
                if ((v100 & 7) == 0)
                {
                  v97 += v100;
                  uint64_t v95 = v99;
                  continue;
                }

LABEL_172:
                uint64_t v120 = PR_getThreadErrInfo(1, (int *)&v199);
                if (v120) {
LABEL_173:
                }
                  *uint64_t v120 = 0xFFFFE00900000000LL;
                goto LABEL_174;
              }

              break;
            }

            uint64_t v101 = v3;
            unint64_t v102 = v100 + v97;
            unint64_t v97 = (v100 + v97 + 7) >> 3;
LABEL_263:
            v155 = (unint64_t *)v9[2];
            unint64_t v14 = (unint64_t)sec_asn1d_zalloc(*(void *)(*v9 + 8LL), v97);
            v155[1] = v14;
            if (!v14)
            {
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
              uint64_t v161 = 2LL;
LABEL_325:
              unint64_t v3 = v101;
              goto LABEL_340;
            }

            unint64_t *v155 = v102;
            for (uint64_t i = *v96; i; uint64_t i = *(void *)(i + 16))
            {
              if (v98 == 3) {
                size_t v157 = (unint64_t)(*(void *)(i + 8) + 7LL) >> 3;
              }
              else {
                size_t v157 = *(void *)(i + 8);
              }
              memcpy((void *)v14, *(const void **)i, v157);
              v14 += v157;
            }

            *CFDataRef v96 = 0LL;
            uint8_t v9[16] = 0LL;
            unint64_t v3 = v101;
LABEL_270:
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
LABEL_271:
            int v17 = 0;
LABEL_272:
            int v18 = 22;
            goto LABEL_273;
          case 0xE:
            uint64_t v103 = (void *)v9[2];
            if (!v103) {
              goto LABEL_270;
            }
            CFNumberRef v105 = (void **)(v9 + 15);
            uint64_t v104 = v9[15];
            if (v104)
            {
              uint64_t v106 = 0LL;
              do
              {
                ++v106;
                uint64_t v104 = *(void *)(v104 + 16);
              }

              while (v104);
              unint64_t v107 = 8 * v106 + 8;
            }

            else
            {
              unint64_t v107 = 8LL;
            }

            v145 = sec_asn1d_zalloc(*(void *)(*v9 + 8LL), v107);
            if (!v145) {
              goto LABEL_174;
            }
            *uint64_t v103 = v145;
            for (CFIndex j = *v105; j; CFIndex j = (void *)j[2])
              *v145++ = *j;
            void *v145 = 0LL;
            *CFNumberRef v105 = 0LL;
            uint8_t v9[16] = 0LL;
            goto LABEL_270;
          case 0xF:
          case 0x10:
          case 0x11:
          case 0x12:
            uint64_t v11 = v9[5];
            int v12 = *(unsigned __int8 *)(v11 + 140);
            *((_BYTE *)v9 + 140) = v12;
            if (v12)
            {
              void v9[8] = *(void *)(v11 + 64);
              *((_BYTE *)v9 + 52) = *(_BYTE *)(v11 + 52);
              *((_BYTE *)v9 + 137) = *(_BYTE *)(v11 + 137);
            }

            uint64_t v13 = v9[12];
            v9[13] += *(void *)(v11 + 104);
            if (!v13) {
              goto LABEL_12;
            }
            if (v13 != *(void *)(v11 + 104)) {
              goto LABEL_172;
            }
            v9[12] = 0LL;
LABEL_12:
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *(void *)(v11 + 104) = 0LL;
LABEL_13:
            int v18 = 20;
            goto LABEL_273;
          case 0x13:
            return result;
          case 0x14:
            if (*((_BYTE *)v9 + 139))
            {
              v9[12] = 2LL;
              int v18 = 21;
            }

            else
            {
              int v18 = 22;
            }

            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            goto LABEL_273;
          case 0x15:
            if (!a3)
            {
              unint64_t v14 = 0LL;
              int v16 = 0;
              int v17 = 0;
              uint64_t v161 = 3LL;
              *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 3;
              int v15 = 1;
              goto LABEL_340;
            }

            unint64_t v108 = v9[12];
            if (v108 >= a3) {
              unint64_t v14 = a3;
            }
            else {
              unint64_t v14 = v9[12];
            }
            if (!v14) {
              goto LABEL_149;
            }
            uint64_t v109 = 0LL;
            unsigned int v110 = 1;
            while (!a2[v109])
            {
              uint64_t v109 = v110;
              if (v14 <= v110++)
              {
LABEL_149:
                v9[12] = v108 - v14;
                int v15 = 1;
                if (v108 <= a3)
                {
                  int v16 = 0;
                  int v17 = 0;
                  *((_DWORD *)v9 + 12) = 22;
                  *((_BYTE *)v9 + 137) = 1;
                }

                else
                {
                  int v16 = 0;
                  int v17 = 0;
                }

                goto LABEL_283;
              }
            }

            v160 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v160) {
              void *v160 = 0xFFFFE00900000000LL;
            }
            unint64_t v14 = 0LL;
            int v16 = 0;
            int v17 = 0;
            int v15 = 1;
            *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
LABEL_283:
            uint64_t v161 = 3LL;
            goto LABEL_340;
          case 0x16:
            if (v9[5])
            {
              void v9[5] = 0LL;
              void v9[3] = 0LL;
            }

            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            goto LABEL_162;
          case 0x17:
            if (*((_BYTE *)v9 + 136))
            {
              CFTypeRef v112 = (char *)sec_asn1d_zalloc(*(void *)(*v9 + 8LL), *(unsigned int *)(v9[1] + 16LL));
              if (!v112) {
                goto LABEL_260;
              }
              uint64_t v113 = v9[1];
              uint64_t v114 = *(unsigned int *)(v113 + 4);
              unint64_t v115 = &v112[v114];
              void v9[2] = &v112[v114];
            }

            else
            {
              uint64_t v113 = v9[1];
              unint64_t v115 = (char *)v9[2];
              uint64_t v114 = *(unsigned int *)(v113 + 4);
            }

            v135 = sec_asn1d_push_state(*v9, v113 + 24, (uint64_t)&v115[-v114], 0);
            if (v135)
            {
              *((_DWORD *)v135 + 12) = 0;
              *((_BYTE *)v135 + 137) = 0;
              *(_WORD *)((char *)v135 + 139) = 0;
              __int128 v136 = sec_asn1d_init_state_based_on_template(v135, (uint64_t)a2, a3);
              if (v136)
              {
                unint64_t v14 = 0LL;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                *((_BYTE *)v136 + 141) = 1;
                *((_DWORD *)v9 + 12) = 24;
                uint64_t v161 = 2LL;
                char v9 = v136;
                goto LABEL_340;
              }
            }

            char v9 = 0LL;
            goto LABEL_337;
          case 0x18:
            uint64_t v116 = v9[5];
            if (!*(_BYTE *)(v116 + 140))
            {
              __int128 v137 = (_DWORD *)v9[2];
              if (v137) {
                _DWORD *v137 = *(_DWORD *)(*(void *)(v116 + 8) + 16LL);
              }
              unint64_t v14 = 0LL;
              int v15 = 0;
              int v16 = 0;
              int v17 = 0;
              *(_DWORD *)(v116 + 4_Block_object_dispose(va, 8) = 26;
              int v18 = 25;
              goto LABEL_273;
            }

            v9[13] += *(void *)(v116 + 104);
            if (*(_BYTE *)(v116 + 137))
            {
              *(_DWORD *)(v116 + 4_Block_object_dispose(va, 8) = 26;
              *((_DWORD *)v9 + 12) = 25;
              *((_BYTE *)v9 + 137) = 1;
            }

            else
            {
              v148 = *(unsigned int **)(v116 + 8);
              uint64_t v147 = *(void *)(v116 + 16);
              uint64_t v149 = v148[1];
              unsigned int v150 = v148[6];
              *(void *)(v116 + _Block_object_dispose(va, 8) = v148 + 6;
              if (v150)
              {
                *(void *)(v116 + 16) = v147 - v149 + v148[7];
                unint64_t v151 = v9[12];
                if (!v151
                  || (v152 = *(void *)(v116 + 104), BOOL v58 = v151 >= v152, v153 = v151 - v152, v58)
                  && (v9[12] = v153) != 0LL)
                {
                  uint64_t v101 = v3;
                  *(void *)(v116 + 104) = 0LL;
                  *(_DWORD *)(v116 + 4_Block_object_dispose(va, 8) = 0;
                  *(_BYTE *)(v116 + 137) = 0;
                  *(_WORD *)(v116 + 139) = 0;
                  *(void *)(*v9 + 16LL) = v116;
                  char v168 = *(_BYTE *)(v116 + 52);
                  uint64_t v169 = *(void *)(v116 + 64);
                  v170 = sec_asn1d_init_state_based_on_template((void *)v116, (uint64_t)a2, a3);
                  char v9 = v170;
                  uint64_t v161 = 2LL;
                  unint64_t v14 = 0LL;
                  int v15 = 0;
                  int v16 = 0;
                  int v17 = 0;
                  if (v170)
                  {
                    *((_BYTE *)v170 + 52) = v168;
                    v170[8] = v169;
                    *((_BYTE *)v170 + 141) = 1;
                    *((_DWORD *)v170 + 12) = 2;
                  }

                  goto LABEL_325;
                }
              }
            }

            v154 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v154) {
              void *v154 = 0xFFFFE00900000000LL;
            }
LABEL_260:
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            *(_DWORD *)(*v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
            uint64_t v161 = 2LL;
            char v9 = 0LL;
            goto LABEL_340;
          case 0x19:
            unint64_t v14 = 0LL;
            int v15 = 0;
            int v16 = 0;
            int v17 = 0;
            uint64_t v117 = v9[5];
            v9[13] += *(void *)(v117 + 104);
            *(void *)(v117 + 104) = 0LL;
            void v9[5] = 0LL;
            void v9[3] = 0LL;
LABEL_162:
            *((_DWORD *)v9 + 12) = 20;
            *(void *)(*v9 + 16LL) = v9[4];
            goto LABEL_339;
          default:
LABEL_458:
            v196 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v196) {
              void *v196 = 0xFFFFE00900000000LL;
            }
            *(_DWORD *)(a1 + 24) = 1;
            uint64_t v7 = v198;
            goto LABEL_452;
        }

        break;
      }
    }
  }

  char v9 = 0LL;
LABEL_444:
  if (v8 == 1) {
    goto LABEL_451;
  }
  return 0LL;
}

uint64_t sec_asn1d_parent_allows_EOC(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      int v1 = *(_DWORD *)(result + 48);
      BOOL v2 = (v1 - 16) < 4 || v1 == 24;
      if (!v2 && v1 != 11) {
        break;
      }
      uint64_t result = *(void *)(result + 32);
      if (!result) {
        return result;
      }
    }

    BOOL v4 = (v1 & 0xFFFFFFFE) == 8 || *(_BYTE *)(*(void *)(result + 40) + 141LL) != 0;
    return *(_BYTE *)(result + 139) && v4;
  }

  return result;
}

uint64_t sec_asn1d_check_and_subtract_length(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  if (a1 && a3)
  {
    if (*a1 >= a2)
    {
      *a1 -= a2;
      return 1LL;
    }

    else
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
      if (ThreadErrInfo) {
        void *ThreadErrInfo = 0xFFFFE00900000000LL;
      }
      uint64_t result = 0LL;
      *(_DWORD *)(a3 + 24) = 1;
    }
  }

  else
  {
    unsigned int v6 = PR_getThreadErrInfo(1, &v7);
    if (v6) {
      void *v6 = 0xFFFFE00500000000LL;
    }
    uint64_t result = 0LL;
    if (a3) {
      *(_DWORD *)(a3 + 24) = 1;
    }
  }

  return result;
}

void *sec_asn1d_zalloc(uint64_t a1, unint64_t a2)
{
  if (a1) {
    unint64_t v3 = (void *)PORT_ArenaAlloc(a1, a2);
  }
  else {
    unint64_t v3 = PORT_Alloc(a2);
  }
  BOOL v4 = v3;
  if (v3) {
    bzero(v3, a2);
  }
  return v4;
}

void *sec_asn1d_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (a2)
  {
    if (v5) {
      *(void *)(v5 + 24) = -1LL;
    }
    uint64_t result = sec_asn1d_zalloc(*(void *)a1, 0x90uLL);
    if (result)
    {
      result[4] = v5;
      *uint64_t result = a1;
      result[1] = a2;
      *((_DWORD *)result + 12) = 26;
      if (a3) {
        result[2] = a3 + *(unsigned int *)(a2 + 4);
      }
      if (v5)
      {
        int v10 = *(_DWORD *)(v5 + 112);
        *((_DWORD *)result + 2_Block_object_dispose(va, 8) = v10;
        if (a4)
        {
          *((_DWORD *)result + 2_Block_object_dispose(va, 8) = v10 + 1;
          if (v10 >= 32)
          {
            ThreadErrInfo = PR_getThreadErrInfo(1, &v14);
            if (ThreadErrInfo) {
              void *ThreadErrInfo = 0xFFFFE00900000000LL;
            }
            *(_DWORD *)(a1 + 24) = 1;
            goto LABEL_16;
          }
        }

        *(void *)(v5 + 40) = result;
      }

      *(void *)(a1 + 16) = result;
      return result;
    }
  }

  else
  {
    int v12 = PR_getThreadErrInfo(1, &v13);
    if (v12) {
      *int v12 = 0xFFFFE08800000000LL;
    }
  }

  *(_DWORD *)(a1 + 24) = 1;
  if (v5)
  {
LABEL_16:
    uint64_t result = 0LL;
    *(void *)(v5 + 24) = 0LL;
    return result;
  }

  return 0LL;
}

void *sec_asn1d_init_state_based_on_template(void *a1, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (!a1) {
      return a1;
    }
    uint64_t v6 = *a1;
    if (*(_DWORD *)(*a1 + 24LL) == 1) {
      return a1;
    }
    int v7 = (unsigned int *)a1[1];
    if (!v7) {
      return a1;
    }
    unsigned int v8 = *v7;
    if ((*v7 & 0x20000) == 0) {
      goto LABEL_19;
    }
    if (*(_DWORD *)(v6 + 72)) {
      break;
    }
    *((_BYTE *)a1 + 137) = 0;
    *(_WORD *)((char *)a1 + 139) = 0;
    *((_DWORD *)a1 + 12) = 11;
    a1 = sec_asn1d_push_state(v6, (uint64_t)kSecAsn1AnyTemplate, a1[2], 0);
    if (!a1) {
      return a1;
    }
  }

  char v9 = *(void (**)(void, void, uint64_t, uint64_t))(v6 + 32);
  if (v9)
  {
    uint64_t v10 = *((unsigned int *)a1 + 28);
    uint64_t v11 = a1[2];
    *(_DWORD *)(v6 + 4_Block_object_dispose(va, 8) = 1;
    v9(*(void *)(v6 + 40), 0LL, v11, v10);
    *(_DWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0;
  }

  uint64_t v12 = a1[2];
  if (v12)
  {
    int v13 = (unsigned int *)a1[1];
    uint64_t v14 = v12 - v13[1];
  }

  else
  {
    uint64_t v14 = *(void *)(a1[4] + 16LL);
    int v13 = (unsigned int *)a1[1];
  }

  int v7 = v13 + 6;
  a1[1] = v13 + 6;
  a1[2] = v14;
  if (v14)
  {
    uint64_t v15 = v14 + v13[7];
    a1[2] = v15;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v16 = *a1;
  int v17 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(*a1 + 32LL);
  if (v17)
  {
    uint64_t v18 = *((unsigned int *)a1 + 28);
    *(_DWORD *)(v16 + 4_Block_object_dispose(va, 8) = 1;
    v17(*(void *)(v16 + 40), 1LL, v15, v18);
    *(_DWORD *)(v16 + 4_Block_object_dispose(va, 8) = 0;
    int v7 = (unsigned int *)a1[1];
  }

  unsigned int v8 = *v7;
LABEL_19:
  if ((v8 & 0x100000) != 0)
  {
    *((_DWORD *)a1 + 12) = 23;
    return a1;
  }

  unint64_t v19 = v8 & 0x200;
  int v20 = (v8 >> 8) & 1;
  BOOL v22 = (v8 & 0xC0) == 0 || v19 != 0;
  if ((v8 & 0x1800) == 0 && v22)
  {
    uint64_t v23 = v8 & 0xFFFBBCFF;
    if ((v8 & 0x200) != 0) {
      uint64_t v23 = 0LL;
    }
    goto LABEL_54;
  }

  *((_DWORD *)a1 + 12) = 0;
  *((_BYTE *)a1 + 137) = 0;
  *(_WORD *)((char *)a1 + 139) = 0;
  if ((v8 & 0x1000) != 0)
  {
    uint64_t v25 = 0LL;
    BOOL v24 = *(_DWORD *)(*a1 + 72LL) == 0;
    int v26 = 18;
  }

  else
  {
    BOOL v24 = 0;
    uint64_t v25 = a1[2];
    if ((v8 & 0x800) != 0) {
      int v26 = 17;
    }
    else {
      int v26 = 16;
    }
  }

  *((_DWORD *)a1 + 12) = v26;
  *((_BYTE *)a1 + 141) = v20;
  uint64_t v27 = a1;
  while (1)
  {
    uint64_t v28 = v27[2];
    if (v28) {
      break;
    }
    uint64_t v27 = (void *)v27[4];
    if (!v27)
    {
      uint64_t v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))*((void *)v7 + 1);
      if (v29 && (v8 & 0x4000) != 0)
      {
        if (*v29)
        {
          uint64_t v30 = ((uint64_t (*)(void, void, uint64_t, uint64_t, void))*v29)(0LL, 0LL, a2, a3, 0LL);
LABEL_48:
          uint64_t v29 = (uint64_t (**)(uint64_t, void, uint64_t, uint64_t))v30;
          goto LABEL_50;
        }

unint64_t sec_asn1d_parse_leaf(uint64_t a1, char *__src, unint64_t a3)
{
  if (!a3)
  {
    unint64_t v5 = 0LL;
    *(_DWORD *)(*(void *)a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 3;
    return v5;
  }

  unint64_t v4 = *(void *)(a1 + 96);
  if (v4 >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(void *)(a1 + 96);
  }
  uint64_t v6 = *(unint64_t **)(a1 + 16);
  if (!v6) {
    goto LABEL_30;
  }
  unint64_t v7 = v6[1];
  if (!v7) {
    goto LABEL_30;
  }
  unsigned int v8 = __src;
  uint64_t v9 = *(void *)(a1 + 80);
  unint64_t v10 = *v6;
  if (v9 == 2)
  {
    if (v10) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v5 >= 2;
    }
    if (!v11)
    {
      size_t v12 = v5;
      goto LABEL_25;
    }

    __srCC_MD4_CTX c = &__src[v5 - 1];
    size_t v12 = v5;
    while (!*v8)
    {
      ++v8;
      if (--v12 <= 1)
      {
        size_t v12 = 1LL;
        goto LABEL_20;
      }
    }

    __srCC_MD4_CTX c = v8;
  }

  else
  {
    size_t v12 = v5;
  }

void sec_asn1d_add_to_subitems(uint64_t **a1, void *a2, unint64_t a3, int a4)
{
  unsigned int v8 = (uint64_t *)sec_asn1d_zalloc(**a1, 0x18uLL);
  if (!v8)
  {
    *((_DWORD *)*a1 + 6) = 1;
    return;
  }

  uint64_t v9 = v8;
  if (!a4)
  {
    uint64_t v12 = (uint64_t)a2;
LABEL_10:
    *uint64_t v9 = v12;
    v9[1] = a3;
    void v9[2] = 0LL;
    if (a1[15]) {
      a1[16][2] = (uint64_t)v9;
    }
    else {
      a1[15] = v9;
    }
    a1[16] = v9;
    return;
  }

  uint64_t v10 = **a1;
  if (v10) {
    BOOL v11 = (void *)PORT_ArenaAlloc(v10, a3);
  }
  else {
    BOOL v11 = PORT_Alloc(a3);
  }
  uint64_t v12 = (uint64_t)v11;
  if (v11)
  {
    memcpy(v11, a2, a3);
    goto LABEL_10;
  }

  unint64_t v13 = *a1;
  *((_DWORD *)v13 + 6) = 1;
  if (!*v13) {
    free(v9);
  }
}

void sec_asn1d_record_any_header(uint64_t **a1, void *a2, unint64_t a3)
{
  unint64_t v4 = a1[2];
  if (v4 && v4[1])
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v6);
    if (ThreadErrInfo) {
      void *ThreadErrInfo = 0xFFFFE00100000000LL;
    }
    *((_DWORD *)*a1 + 6) = 1;
  }

  else
  {
    sec_asn1d_add_to_subitems(a1, a2, a3, 1);
  }

uint64_t SEC_ASN1DecoderFinish(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) != 3) {
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (!*(_DWORD *)(v2 + 48))
  {
    unint64_t v5 = *(int **)(v2 + 8);
    int v6 = *v5;
    if (*v5)
    {
      unint64_t v7 = v5 + 6;
      while ((v6 & 0x100) != 0)
      {
        int v8 = *v7;
        v7 += 6;
        LOWORD(v6) = v8;
        if (!v8) {
          goto LABEL_10;
        }
      }

      goto LABEL_3;
    }

uint64_t SEC_ASN1DecoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = PORT_NewArena(2048);
  if (!v10) {
    return 0LL;
  }
  BOOL v11 = v10;
  uint64_t v12 = PORT_ArenaAlloc((uint64_t)v10, 0x50uLL);
  if (!v12) {
    goto LABEL_7;
  }
  uint64_t v13 = v12;
  *(void *)(v12 + 72) = 0LL;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + _Block_object_dispose(va, 8) = 0u;
  *(void *)uint64_t v12 = v11;
  if (a1) {
    *(void *)(v12 + _Block_object_dispose(va, 8) = a1;
  }
  *(_DWORD *)(v12 + 24) = 3;
  if (!sec_asn1d_push_state(v12, a3, a2, 0) || !sec_asn1d_init_state_based_on_template(*(void **)(v13 + 16), a4, a5))
  {
LABEL_7:
    PORT_FreeArena(v11, 0);
    return 0LL;
  }

  return v13;
}

uint64_t SEC_ASN1Decode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v7 = SEC_ASN1DecoderStart(a1, a2, a3, (uint64_t)a4, a5);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  int v9 = SEC_ASN1DecoderUpdate(v7, a4, a5);
  LODWORD(result) = SEC_ASN1DecoderFinish(v8);
  if (v9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

OSStatus SecAsn1CoderCreate(SecAsn1CoderRef *coder)
{
  if (!coder) {
    return -50;
  }
  uint64_t v2 = (SecAsn1Coder *)malloc(8uLL);
  unint64_t v3 = PORT_NewArena(1024);
  *(void *)uint64_t v2 = v3;
  if (v3)
  {
    OSStatus result = 0;
    *SecAsn1CoderRef coder = v2;
  }

  else
  {
    free(v2);
    return -108;
  }

  return result;
}

OSStatus SecAsn1CoderRelease(SecAsn1CoderRef coder)
{
  if (!coder) {
    return -50;
  }
  uint64_t v2 = *(void **)coder;
  if (v2) {
    PORT_FreeArena(v2, 1);
  }
  free(coder);
  return 0;
}

OSStatus SecAsn1Decode( SecAsn1CoderRef coder, const void *src, size_t len, const SecAsn1Template *templates, void *dest)
{
  OSStatus result = -50;
  if (coder && src && templates && dest)
  {
    else {
      return 0;
    }
  }

  return result;
}

OSStatus SecAsn1DecodeData( SecAsn1CoderRef coder, const SecAsn1Item *src, const SecAsn1Template *templ, void *dest)
{
  return SecAsn1Decode(coder, src->Data, src->Length, templ, dest);
}

OSStatus SecAsn1EncodeItem( SecAsn1CoderRef coder, const void *src, const SecAsn1Template *templates, SecAsn1Item *dest)
{
  OSStatus result = -50;
  if (coder && src && templates && dest)
  {
    dest->CFIndex Length = 0LL;
    dest->Data = 0LL;
    else {
      return -50;
    }
  }

  return result;
}

void *__cdecl SecAsn1Malloc(void *coder, size_t len)
{
  if (coder) {
    return (void *)PORT_ArenaAlloc(*(void *)coder, len);
  }
  return coder;
}

OSStatus SecAsn1AllocItem(SecAsn1CoderRef coder, SecAsn1Item *item, size_t len)
{
  OSStatus result = -50;
  if (coder && item)
  {
    uint64_t v7 = (uint8_t *)PORT_ArenaAlloc(*(void *)coder, len);
    item->Data = v7;
    if (v7)
    {
      OSStatus result = 0;
      item->CFIndex Length = len;
    }

    else
    {
      return -108;
    }
  }

  return result;
}

OSStatus SecAsn1AllocCopy(SecAsn1CoderRef coder, const void *src, size_t len, SecAsn1Item *dest)
{
  if (!src) {
    return -50;
  }
  OSStatus result = -50;
  if (coder && dest)
  {
    int v9 = (uint8_t *)PORT_ArenaAlloc(*(void *)coder, len);
    dest->Data = v9;
    if (v9)
    {
      dest->CFIndex Length = len;
      memmove(v9, src, len);
      return 0;
    }

    else
    {
      return -108;
    }
  }

  return result;
}

OSStatus SecAsn1AllocCopyItem(SecAsn1CoderRef coder, const SecAsn1Item *src, SecAsn1Item *dest)
{
  return SecAsn1AllocCopy(coder, src->Data, src->Length, dest);
}

BOOL SecAsn1OidCompare(const SecAsn1Oid *oid1, const SecAsn1Oid *oid2)
{
  if (!oid1 || !oid2) {
    return oid1 == oid2;
  }
  if (oid1->Length == oid2->Length) {
    return memcmp(oid1->Data, oid2->Data, oid1->Length) == 0;
  }
  return 0;
}

CFTypeID SSLContextGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SSLContextGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_7113;
  void block[4] = &SSLContextGetTypeID_sSSLContextGetTypeIDSingleton;
  if (SSLContextGetTypeID_sSSLContextGetTypeIDOnce != -1) {
    dispatch_once(&SSLContextGetTypeID_sSSLContextGetTypeIDOnce, block);
  }
  return SSLContextGetTypeID_sSSLContextGetTypeIDSingleton;
}

uint64_t __SSLContextGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SSLContextDestroy(uint64_t a1)
{
  if (*(uint64_t (***)())(a1 + 40) == SSLRecordLayerInternal)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    unint64_t v3 = (void *)v2[3];
    if (v3) {
      free(v3);
    }
    v2[2] = 0LL;
    v2[3] = 0LL;
    uint64_t v4 = (void *)v2[5];
    if (v4)
    {
      do
      {
        unint64_t v5 = (void *)*v4;
        free(v4);
        uint64_t v4 = v5;
      }

      while (v5);
    }

    if (*v2) {
      tls_record_destroy();
    }
    free(v2);
  }

  int v6 = *(void **)(a1 + 328);
  if (v6) {
    free(v6);
  }
  *(void *)(a1 + 320) = 0LL;
  *(void *)(a1 + 32_Block_object_dispose(va, 8) = 0LL;
  uint64_t v7 = *(void **)(a1 + 200);
  if (v7) {
    free(v7);
  }
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 200) = 0LL;
  uint64_t v8 = *(void **)(a1 + 216);
  if (v8) {
    free(v8);
  }
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 216) = 0LL;
  int v9 = *(void **)(a1 + 232);
  if (v9) {
    free(v9);
  }
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  int v10 = *(void **)(a1 + 296);
  if (v10) {
    free(v10);
  }
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  BOOL v11 = *(void **)(a1 + 376);
  if (v11) {
    free(v11);
  }
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 376) = 0LL;
  uint64_t v12 = *(const void **)(a1 + 272);
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = *(const void **)(a1 + 152);
  if (v13) {
    CFRelease(v13);
  }
  unint64_t v14 = *(const void **)(a1 + 160);
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = *(const void **)(a1 + 176);
  if (v15) {
    CFRelease(v15);
  }
  uint64_t v16 = *(const void **)(a1 + 168);
  if (v16) {
    CFRelease(v16);
  }
  sslFreeDnList(a1);
  int v17 = *(void **)(a1 + 456);
  if (v17) {
    free(v17);
  }
  *(void *)(a1 + 44_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 456) = 0LL;
  uint64_t v18 = *(void **)(a1 + 472);
  if (v18) {
    free(v18);
  }
  *(void *)(a1 + 464) = 0LL;
  *(void *)(a1 + 472) = 0LL;
  unint64_t v19 = *(void **)(a1 + 504);
  if (v19) {
    free(v19);
  }
  *(void *)(a1 + 496) = 0LL;
  *(void *)(a1 + 504) = 0LL;
  int v20 = *(void **)(a1 + 488);
  if (v20) {
    free(v20);
  }
  *(void *)(a1 + 480) = 0LL;
  *(void *)(a1 + 48_Block_object_dispose(va, 8) = 0LL;
  uint64_t v21 = *(void **)(a1 + 144);
  if (v21) {
    free(v21);
  }
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 144) = 0LL;
  if (*(void *)(a1 + 64)) {
    tls_cache_cleanup();
  }
  bzero((void *)(a1 + 16), 0x220uLL);
}

BOOL SSLContextCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

CFStringRef SSLContextCopyFormatDescription(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<SSLContext(%p) { ... }>",  result);
  }
  return result;
}

CFStringRef SSLContextCopyDescription(uint64_t a1)
{
  if (a1) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SSLContext(%p) { ... }>", a1);
  }
  else {
    return 0LL;
  }
}

void sslFreeDnList(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 264);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)v2[2];
      if (v3) {
        free(v3);
      }
      uint64_t v4 = (void *)*v2;
      free(v2);
      uint64_t v2 = v4;
    }

    while (v4);
  }

  *(void *)(a1 + 264) = 0LL;
}

uint64_t _SSLNewContext(int a1, SSLContextRef *a2)
{
  if (!a2) {
    return 4294967246LL;
  }
  SSLContextRef v3 = SSLCreateContext((CFAllocatorRef)*MEMORY[0x189604DB0], (SSLProtocolSide)(a1 == 0), kSSLStreamType);
  *a2 = v3;
  if (v3) {
    return 0LL;
  }
  else {
    return 4294967188LL;
  }
}

SSLContextRef SSLCreateContext( CFAllocatorRef alloc, SSLProtocolSide protocolSide, SSLConnectionType connectionType)
{
  uint64_t v3 = SSLCreateContextWithRecordFuncs((uint64_t)alloc, protocolSide, connectionType, (uint64_t)SSLRecordLayerInternal);
  if (!v3) {
    return (SSLContextRef)v3;
  }
  uint64_t v4 = (char *)malloc(0x30uLL);
  if (!v4)
  {
LABEL_15:
    CFRelease((CFTypeRef)v3);
    return 0LL;
  }

  unint64_t v5 = (uint64_t *)v4;
  *((void *)v4 + 5) = 0LL;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + _Block_object_dispose(va, 8) = 0u;
  ccrng();
  uint64_t v6 = tls_record_create();
  uint64_t *v5 = v6;
  if (!v6)
  {
LABEL_14:
    free(v5);
    goto LABEL_15;
  }

  uint64_t v7 = malloc(0x4800uLL);
  if (v7) {
    uint64_t v8 = 18432LL;
  }
  else {
    uint64_t v8 = 0LL;
  }
  void v5[2] = v8;
  v5[3] = (uint64_t)v7;
  if (!v7)
  {
    tls_record_destroy();
    goto LABEL_14;
  }

  v5[1] = v3;
  unsigned int v9 = *(_DWORD *)(v3 + 80);
  BOOL v10 = v9 > 6;
  int v11 = (1 << v9) & 0x59;
  if (!v10 && v11 != 0) {
    *(void *)(v3 + 4_Block_object_dispose(va, 8) = v5;
  }
  return (SSLContextRef)v3;
}

uint64_t SSLCreateContextWithRecordFuncs(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), 0x220uLL);
    uint64_t v9 = tls_handshake_create();
    *(void *)(v8 + 56) = v9;
    if (v9)
    {
      if (SSLCreateContextWithRecordFuncs_onceToken != -1) {
        dispatch_once(&SSLCreateContextWithRecordFuncs_onceToken, &__block_literal_global_7118);
      }
      *(void *)(v8 + 64) = g_session_cache;
      tls_handshake_set_callbacks();
      *(_BYTE *)(v8 + 104) = a3 == 1;
      *(_DWORD *)(v8 + 80) = 0;
      *(void *)(v8 + 424) = 0x3FF0000000000000LL;
      *(void *)(v8 + 432) = 1400LL;
      tls_handshake_get_min_protocol_version();
      tls_handshake_get_max_protocol_version();
      if (a2 == 1)
      {
        tls_handshake_set_sct_enable();
        tls_handshake_set_ocsp_enable();
      }

      *(_DWORD *)(v8 + 8_Block_object_dispose(va, 8) = 0;
      *(_DWORD *)(v8 + 10_Block_object_dispose(va, 8) = a2;
      *(void *)(v8 + 40) = a4;
      *(_BYTE *)(v8 + 187) = 1;
      *(_BYTE *)(v8 + 314) = 1;
      *(_BYTE *)(v8 + 315) = kSSLDisableRecordSplittingDefaultValue == 0;
      *(_BYTE *)(v8 + 513) = 0;
      if (kSSLSessionConfigDefaultValue) {
        SSLSetSessionConfig((SSLContextRef)v8, (CFStringRef)kSSLSessionConfigDefaultValue);
      }
      if (kMinDhGroupSizeDefaultValue) {
        tls_handshake_set_min_dh_group_size();
      }
      if (kMinProtocolVersionDefaultValue) {
        SSLSetProtocolVersionMin((SSLContextRef)v8, (SSLProtocol)kMinProtocolVersionDefaultValue);
      }
      *(_DWORD *)(v8 + 352) = 0;
      *(_DWORD *)(v8 + 355) = 0;
    }

    else
    {
      CFRelease((CFTypeRef)v8);
      return 0LL;
    }
  }

  return v8;
}

OSStatus SSLSetSessionConfig(SSLContextRef context, CFStringRef config)
{
  if (CFEqual(config, @"ATSv1")
    || CFEqual(config, @"ATSv1_noPFS")
    || CFEqual(config, @"standard")
    || CFEqual(config, @"TLSv1_fallback")
    || CFEqual(config, @"TLSv1_RC4_fallback")
    || CFEqual(config, @"RC4_fallback")
    || CFEqual(config, @"3DES_fallback")
    || CFEqual(config, @"TLSv1_3DES_fallback")
    || CFEqual(config, @"legacy")
    || CFEqual(config, @"legacy_DHE")
    || CFEqual(config, @"anonymous")
    || CFEqual(config, @"default"))
  {
    return tls_handshake_set_config();
  }

  else
  {
    return -50;
  }

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  if (!context) {
    return -50;
  }
  OSStatus result = -9830;
  __int32 v4 = minVersion - 2;
  unsigned int v5 = 768;
  switch(v4)
  {
    case 0:
      goto LABEL_7;
    case 2:
      unsigned int v5 = 769;
      goto LABEL_7;
    case 5:
      unsigned int v5 = 770;
      goto LABEL_7;
    case 6:
      unsigned int v5 = 771;
LABEL_7:
      if (*((_BYTE *)context + 104)) {
        return result;
      }
      if (v5 > *((_DWORD *)context + 25)) {
        goto LABEL_9;
      }
      goto LABEL_10;
    case 7:
      if (!*((_BYTE *)context + 104)) {
        return result;
      }
      unsigned int v5 = 65279;
      if (*((_DWORD *)context + 25) >> 8 < 0xFFu) {
        goto LABEL_10;
      }
LABEL_9:
      *((_DWORD *)context + 25) = v5;
LABEL_10:
      *((_DWORD *)context + 24) = v5;
      tls_handshake_set_min_protocol_version();
      tls_handshake_set_max_protocol_version();
      OSStatus result = 0;
      break;
    default:
      return result;
  }

  return result;
}

uint64_t __SSLCreateContextWithRecordFuncs_block_invoke()
{
  dispatch_queue_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  int v1 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"/Library/Managed Preferences/mobile/.GlobalPreferences.plist",  kCFURLPOSIXPathStyle,  0);
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = CFReadStreamCreateWithFile(v0, v1);
    if (v3)
    {
      __int32 v4 = v3;
      if (CFReadStreamOpen(v3)) {
        unsigned int v5 = (const __CFDictionary *)CFPropertyListCreateWithStream(v0, v4, 0LL, 0LL, 0LL, 0LL);
      }
      else {
        unsigned int v5 = 0LL;
      }
      CFRelease(v4);
    }

    else
    {
      unsigned int v5 = 0LL;
    }

    CFRelease(v2);
  }

  else
  {
    unsigned int v5 = 0LL;
  }

  uint64_t v6 = (const __CFBoolean *)SSLPreferencesCopyValue(@"SSLDisableRecordSplitting", v5);
  if (v6)
  {
    uint64_t v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFBooleanGetTypeID()) {
      Boolean Value = CFBooleanGetValue(v7);
    }
    else {
      Boolean Value = 0;
    }
    CFRelease(v7);
  }

  else
  {
    Boolean Value = 0;
  }

  kSSLDisableRecordSplittingDefaultBoolean Value = Value;
  kMinDhGroupSizeDefaultBoolean Value = (uint64_t)SSLPreferencesGetInteger(@"SSLMinDhGroupSize", v5);
  kMinProtocolVersionDefaultBoolean Value = (uint64_t)SSLPreferencesGetInteger(@"SSLMinProtocolVersion", v5);
  CFPropertyListRef v10 = SSLPreferencesCopyValue(@"SSLSessionConfig", v5);
  int v11 = v10;
  if (v10)
  {
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 != CFStringGetTypeID())
    {
      CFRelease(v11);
      int v11 = 0LL;
    }
  }

  kSSLSessionConfigDefaultBoolean Value = (uint64_t)v11;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t result = tls_cache_create();
  g_session_cache = result;
  return result;
}

CFPropertyListRef SSLPreferencesCopyValue(const void *a1, const __CFDictionary *a2)
{
  CFPropertyListRef v4 = CFPreferencesCopyAppValue(@"SSLSessionConfig", (CFStringRef)*MEMORY[0x189605188]);
  CFPropertyListRef v5 = v4;
  if (a2)
  {
    if (!v4)
    {
      Boolean Value = CFDictionaryGetValue(a2, a1);
      CFPropertyListRef v5 = Value;
      if (Value) {
        CFRetain(Value);
      }
    }
  }

  return v5;
}

CFNumberRef SSLPreferencesGetInteger(const void *a1, const __CFDictionary *a2)
{
  uint64_t result = (const __CFNumber *)SSLPreferencesCopyValue(a1, a2);
  uint64_t valuePtr = 0LL;
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID()) {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    }
    CFRelease(v3);
    return (const __CFNumber *)valuePtr;
  }

  return result;
}

uint64_t SSLSetRecordContext(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return 4294966387LL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a2;
  return result;
}

uint64_t _SSLNewDatagramContext(int a1, SSLContextRef *a2)
{
  if (!a2) {
    return 4294967246LL;
  }
  SSLContextRef v3 = SSLCreateContext((CFAllocatorRef)*MEMORY[0x189604DB0], (SSLProtocolSide)(a1 == 0), kSSLDatagramType);
  *a2 = v3;
  if (v3) {
    return 0LL;
  }
  else {
    return 4294967188LL;
  }
}

uint64_t _SSLDisposeContext(const void *a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  CFRelease(a1);
  return 0LL;
}

OSStatus SSLGetSessionState(SSLContextRef context, SSLSessionState *state)
{
  if (!context) {
    return -50;
  }
  unsigned int v2 = *((_DWORD *)context + 20) - 1;
  if (v2 > 5) {
    SSLSessionState v3 = kSSLIdle;
  }
  else {
    SSLSessionState v3 = dword_1806546E0[v2];
  }
  OSStatus result = 0;
  *os_activity_scope_state_s state = v3;
  return result;
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  if (!context) {
    return -50;
  }
  unsigned int v4 = *((_DWORD *)context + 20);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return -909;
  }
  switch(option)
  {
    case kSSLSessionOptionBreakOnServerAuth:
      OSStatus result = 0;
      *((_BYTE *)context + 353) = value;
      goto LABEL_13;
    case kSSLSessionOptionBreakOnCertRequested:
      OSStatus result = 0;
      *((_BYTE *)context + 354) = value;
      break;
    case kSSLSessionOptionBreakOnClientAuth:
      OSStatus result = 0;
      *((_BYTE *)context + 355) = value;
LABEL_13:
      *((_BYTE *)context + 187) = value == 0;
      break;
    case kSSLSessionOptionFalseStart:
      tls_handshake_set_false_start();
      OSStatus result = 0;
      *((_BYTE *)context + 512) = value;
      break;
    case kSSLSessionOptionSendOneByteRecord:
      if (*((unsigned __int8 *)context + 315) != value) {
        (*(void (**)(void, void, BOOL))(*((void *)context + 5) + 72LL))( *((void *)context + 6),  0LL,  value != 0);
      }
      OSStatus result = 0;
      *((_BYTE *)context + 315) = value;
      break;
    case kSSLSessionOptionAllowServerIdentityChange:
      tls_handshake_set_server_identity_change();
      OSStatus result = 0;
      *((_BYTE *)context + 360) = 1;
      break;
    case kSSLSessionOptionFallback:
      tls_handshake_set_fallback();
      OSStatus result = 0;
      *((_BYTE *)context + 513) = value;
      break;
    case kSSLSessionOptionBreakOnClientHello:
      OSStatus result = 0;
      *((_BYTE *)context + 359) = value;
      break;
    case kSSLSessionOptionAllowRenegotiation:
      tls_handshake_set_renegotiation();
      OSStatus result = 0;
      *((_BYTE *)context + 361) = 1;
      break;
    case kSSLSessionOptionEnableSessionTickets:
      tls_handshake_set_session_ticket_enabled();
      OSStatus result = 0;
      *((_BYTE *)context + 362) = 1;
      break;
    default:
      OSStatus result = -50;
      break;
  }

  return result;
}

OSStatus SSLGetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean *value)
{
  OSStatus result = -50;
  if (context && value)
  {
    switch(option)
    {
      case kSSLSessionOptionBreakOnServerAuth:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 353);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnCertRequested:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 354);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnClientAuth:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 355);
        goto LABEL_11;
      case kSSLSessionOptionFalseStart:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 512);
        goto LABEL_11;
      case kSSLSessionOptionSendOneByteRecord:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 315);
        goto LABEL_11;
      case kSSLSessionOptionAllowServerIdentityChange:
        tls_handshake_get_server_identity_change();
        return 0;
      case kSSLSessionOptionBreakOnClientHello:
        OSStatus result = 0;
        Boolean v5 = *((_BYTE *)context + 359);
LABEL_11:
        *xpc_object_t value = v5;
        break;
      default:
        return result;
    }
  }

  return result;
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  if (!context) {
    return -50;
  }
  unsigned int v5 = *((_DWORD *)context + 20);
  BOOL v6 = v5 > 6;
  int v7 = (1 << v5) & 0x59;
  if (v6 || v7 == 0) {
    return -909;
  }
  OSStatus result = 0;
  *((void *)context + 2) = readFunc;
  *((void *)context + 3) = writeFunc;
  return result;
}

uint64_t SSLSetNPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 80);
    BOOL v4 = v3 > 6;
    int v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(void *)(result + 520) = a2;
      *(void *)(result + 52_Block_object_dispose(va, 8) = a3;
      if (*(_DWORD *)(result + 108) == 1) {
        return tls_handshake_set_npn_enable();
      }
    }
  }

  return result;
}

uint64_t SSLSetNPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  else {
    return 4294967246LL;
  }
}

uint64_t *SSLGetNPNData(uint64_t a1, void *a2)
{
  OSStatus result = 0LL;
  if (a1 && a2)
  {
    OSStatus result = (uint64_t *)tls_handshake_get_peer_npn_data();
    if (result)
    {
      uint64_t v5 = *result;
      OSStatus result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }

  return result;
}

uint64_t SSLSetALPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 80);
    BOOL v4 = v3 > 6;
    int v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(void *)(result + 536) = a2;
      *(void *)(result + 544) = a3;
    }
  }

  return result;
}

uint64_t SSLSetALPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  else {
    return 4294967246LL;
  }
}

uint64_t *SSLGetALPNData(uint64_t a1, void *a2)
{
  OSStatus result = 0LL;
  if (a1 && a2)
  {
    OSStatus result = (uint64_t *)tls_handshake_get_peer_alpn_data();
    if (result)
    {
      uint64_t v5 = *result;
      OSStatus result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }

  return result;
}

OSStatus SSLSetALPNProtocols(SSLContextRef context, CFArrayRef protocols)
{
  OSStatus v2 = -50;
  if (context && protocols && CFArrayGetCount(protocols))
  {
    CFMutableSetRef Mutable = CFDataCreateMutable(0LL, 0LL);
    contexta[0] = MEMORY[0x1895F87A8];
    contexta[1] = 0x40000000LL;
    contexta[2] = __SSLSetALPNProtocols_block_invoke;
    contexta[3] = &__block_descriptor_tmp_4_7130;
    contexta[4] = Mutable;
    v7.CFIndex length = CFArrayGetCount(protocols);
    v7.CFIndex location = 0LL;
    CFArrayApplyFunction(protocols, v7, (CFArrayApplierFunction)apply_block_1_7131, contexta);
    if (CFDataGetLength(Mutable) <= 255)
    {
      CFDataGetBytePtr(Mutable);
      CFDataGetLength(Mutable);
      OSStatus v2 = tls_handshake_set_alpn_data();
    }

    CFRelease(Mutable);
  }

  return v2;
}

void __SSLSetALPNProtocols_block_invoke(uint64_t a1, CFStringRef theString)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  UInt8 bytes = CFStringGetLength(theString);
  if (bytes <= 0x20uLL)
  {
    *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)buffer = v4;
    __int128 v7 = v4;
    if (CFStringGetCString(theString, buffer, 32LL, 0x600u))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 32), &bytes, 1LL);
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 32), (const UInt8 *)buffer, bytes);
    }
  }

uint64_t apply_block_1_7131(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLCopyALPNProtocols(SSLContextRef context, CFArrayRef *protocols)
{
  OSStatus result = -50;
  if (context && protocols)
  {
    CFMutableSetRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    peer_alpn_data = (unint64_t *)tls_handshake_get_peer_alpn_data();
    if (peer_alpn_data)
    {
      __int128 v7 = peer_alpn_data;
      unint64_t v8 = 0LL;
      unint64_t v9 = *peer_alpn_data;
      while (v8 < v9)
      {
        unint64_t v10 = v7[1];
        CFIndex v11 = *(char *)(v10 + v8);
        unint64_t v12 = v8 + 1;
        v8 += 1 + v11;
        if (v8 <= v9)
        {
          CFStringRef v13 = CFStringCreateWithBytes(0LL, (const UInt8 *)(v10 + v12), v11, 0x600u, 0);
          CFArrayAppendValue(Mutable, v13);
          if (v13) {
            CFRelease(v13);
          }
          unint64_t v9 = *v7;
          if (v8 <= *v7) {
            continue;
          }
        }

        goto LABEL_10;
      }

      OSStatus result = 0;
    }

    else
    {
LABEL_10:
      if (Mutable)
      {
        CFRelease(Mutable);
        CFMutableSetRef Mutable = 0LL;
      }

      OSStatus result = -50;
    }

    *protocols = Mutable;
  }

  return result;
}

OSStatus SSLSetOCSPResponse(SSLContextRef context, CFDataRef response)
{
  OSStatus result = -50;
  if (context)
  {
    if (response)
    {
      CFDataGetBytePtr(response);
      CFDataGetLength(response);
      return tls_handshake_set_ocsp_response();
    }
  }

  return result;
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  if (!context) {
    return -50;
  }
  unsigned int v4 = *((_DWORD *)context + 20);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return -909;
  }
  OSStatus result = 0;
  *((void *)context + 4) = connection;
  return result;
}

OSStatus SSLGetConnection(SSLContextRef context, SSLConnectionRef *connection)
{
  OSStatus result = -50;
  if (context)
  {
    if (connection)
    {
      OSStatus result = 0;
      _xpc_connection_s *connection = (SSLConnectionRef)*((void *)context + 4);
    }
  }

  return result;
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  BOOL v4 = v3 >= 6;
  BOOL v6 = v3 == 6;
  int v5 = (1 << v3) & 0x59;
  BOOL v6 = !v6 && v4 || v5 == 0;
  if (v6) {
    return -909;
  }
  if (*((_DWORD *)context + 27) == 1) {
    return tls_handshake_set_peer_hostname();
  }
  return 0;
}

OSStatus SSLGetPeerDomainNameLength(SSLContextRef context, size_t *peerNameLen)
{
  if (context) {
    return tls_handshake_get_peer_hostname();
  }
  else {
    return -50;
  }
}

OSStatus SSLGetPeerDomainName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  if (!context) {
    return -50;
  }
  OSStatus result = tls_handshake_get_peer_hostname();
  if (!result)
  {
    if (*peerNameLen >= 0xAAAAAAAAAAAAAAAALL)
    {
      memcpy(peerName, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
      OSStatus result = 0;
      *peerNameLen = 0xAAAAAAAAAAAAAAAALL;
    }

    else
    {
      return -9817;
    }
  }

  return result;
}

OSStatus SSLCopyRequestedPeerNameLength(SSLContextRef ctx, size_t *peerNameLen)
{
  if (!ctx) {
    return -50;
  }
  uint64_t sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname) {
    return -50;
  }
  BOOL v4 = (size_t *)sni_hostname;
  OSStatus result = 0;
  *peerNameLen = *v4;
  return result;
}

OSStatus SSLCopyRequestedPeerName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  if (!context) {
    return -50;
  }
  uint64_t sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname) {
    return -50;
  }
  BOOL v6 = (size_t *)sni_hostname;
  if (*peerNameLen < *(void *)sni_hostname) {
    return -9817;
  }
  memcpy(peerName, *(const void **)(sni_hostname + 8), *(void *)sni_hostname);
  OSStatus result = 0;
  *peerNameLen = *v6;
  return result;
}

OSStatus SSLSetDatagramHelloCookie(SSLContextRef dtlsContext, const void *cookie, size_t cookieLen)
{
  if (!dtlsContext) {
    return -50;
  }
  OSStatus result = -50;
  if (cookieLen <= 0x20 && *((_BYTE *)dtlsContext + 104))
  {
    unsigned int v6 = *((_DWORD *)dtlsContext + 20);
    BOOL v7 = v6 > 6;
    int v8 = (1 << v6) & 0x59;
    if (v7 || v8 == 0)
    {
      return -909;
    }

    else
    {
      CFIndex v11 = (void *)*((void *)dtlsContext + 15);
      if (v11) {
        free(v11);
      }
      unint64_t v12 = malloc(cookieLen);
      CFStringRef v13 = v12;
      if (v12) {
        size_t v14 = cookieLen;
      }
      else {
        size_t v14 = 0LL;
      }
      if (v12) {
        OSStatus result = 0;
      }
      else {
        OSStatus result = -1;
      }
      *((void *)dtlsContext + 14) = v14;
      *((void *)dtlsContext + 15) = v13;
      if (v13)
      {
        memcpy(v13, cookie, cookieLen);
        return 0;
      }
    }
  }

  return result;
}

OSStatus SSLSetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t maxSize)
{
  if (!dtlsContext) {
    return -50;
  }
  if (!*((_BYTE *)dtlsContext + 104)) {
    return -50;
  }
  tls_handshake_set_mtu();
  return 0;
}

OSStatus SSLGetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t *maxSize)
{
  if (!dtlsContext || !*((_BYTE *)dtlsContext + 104)) {
    return -50;
  }
  OSStatus result = 0;
  *maxCFIndex Size = *((void *)dtlsContext + 54);
  return result;
}

OSStatus SSLGetDatagramWriteSize(SSLContextRef dtlsContext, size_t *bufSize)
{
  if (!dtlsContext) {
    return -50;
  }
  OSStatus result = -50;
  if (bufSize)
  {
    if (*((_BYTE *)dtlsContext + 104))
    {
      OSStatus result = 0;
      *bufCFIndex Size = ((*((void *)dtlsContext + 54) - 13LL) & 0xFFFFFFFFFFFFFFF0LL) - 49;
    }
  }

  return result;
}

OSStatus SSLGetProtocolVersionMin(SSLContextRef context, SSLProtocol *minVersion)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 24))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }

  OSStatus result = 0;
  *minVersion = v2;
  return result;
}

OSStatus SSLSetProtocolVersionMax(SSLContextRef context, SSLProtocol maxVersion)
{
  if (!context) {
    return -50;
  }
  OSStatus result = -9830;
  unsigned int v4 = 768;
  switch(maxVersion)
  {
    case kSSLProtocol3:
      goto LABEL_7;
    case kTLSProtocol1:
      unsigned int v4 = 769;
      goto LABEL_7;
    case kTLSProtocol11:
      unsigned int v4 = 770;
      goto LABEL_7;
    case kTLSProtocol12:
      unsigned int v4 = 771;
LABEL_7:
      if (*((_BYTE *)context + 104)) {
        return result;
      }
      if (v4 < *((_DWORD *)context + 24)) {
        *((_DWORD *)context + 24) = v4;
      }
      break;
    case kDTLSProtocol1:
      if (!*((_BYTE *)context + 104)) {
        return result;
      }
      unsigned int v4 = 65279;
      if (*((_DWORD *)context + 24) <= 0xFEFEu) {
        *((_DWORD *)context + 24) = 65279;
      }
      break;
    default:
      return result;
  }

  *((_DWORD *)context + 25) = v4;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0;
}

OSStatus SSLGetProtocolVersionMax(SSLContextRef context, SSLProtocol *maxVersion)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 25))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }

  OSStatus result = 0;
  *maxVersion = v2;
  return result;
}

uint64_t _SSLProtocolVersionToWireFormatValue(int a1)
{
  uint64_t result = 768LL;
  switch(a1)
  {
    case 0:
    case 1:
    case 3:
    case 5:
    case 6:
      uint64_t result = 0LL;
      break;
    case 2:
      return result;
    case 4:
      uint64_t result = 769LL;
      break;
    case 7:
      uint64_t result = 770LL;
      break;
    case 8:
      uint64_t result = 771LL;
      break;
    case 9:
      uint64_t result = 65279LL;
      break;
    case 10:
      uint64_t result = 772LL;
      break;
    case 11:
      uint64_t result = 65277LL;
      break;
    default:
      if (a1 == 999) {
        uint64_t result = 772LL;
      }
      else {
        uint64_t result = 0LL;
      }
      break;
  }

  return result;
}

uint64_t _SSLSetProtocolVersionEnabled(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  BOOL v6 = v4 || v5 == 0;
  if (v6 || *(_BYTE *)(a1 + 104)) {
    return 4294966387LL;
  }
  int v8 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_18;
    case 2:
      int v8 = 768;
      goto LABEL_18;
    case 4:
      int v8 = 769;
      goto LABEL_18;
    case 6:
      if (!a3) {
        goto LABEL_42;
      }
      *(void *)(a1 + 96) = 0x30300000300LL;
      goto LABEL_43;
    case 7:
      int v8 = 770;
      goto LABEL_18;
    case 8:
      int v8 = 771;
      goto LABEL_18;
    case 9:
      int v8 = 65279;
      goto LABEL_18;
    default:
      int v8 = 0;
LABEL_18:
      unsigned int v9 = v8 - 772;
      if (!a3)
      {
        if (v9 < 0xFFFFFCFE) {
          return 4294967246LL;
        }
        if (v8 > 768)
        {
          if (v8 == 769)
          {
            unsigned int v11 = 770;
            goto LABEL_38;
          }

          if (v8 == 770)
          {
            unsigned int v11 = 771;
            goto LABEL_38;
          }
        }

        else
        {
          if (v8 == 2)
          {
            unsigned int v11 = 768;
            goto LABEL_38;
          }

          if (v8 == 768)
          {
            unsigned int v11 = 769;
            goto LABEL_38;
          }
        }

        unsigned int v11 = 0;
LABEL_38:
        unsigned int v12 = *(_DWORD *)(a1 + 100);
        if (*(_DWORD *)(a1 + 96) <= v11) {
          unsigned int v13 = v11;
        }
        else {
          unsigned int v13 = *(_DWORD *)(a1 + 96);
        }
        *(_DWORD *)(a1 + 96) = v13;
        if (v13 > v12) {
LABEL_42:
        }
          *(void *)(a1 + 96) = 0LL;
        goto LABEL_43;
      }

      if (v9 < 0xFFFFFFFC) {
        return 4294967246LL;
      }
      if (v8 <= *(_DWORD *)(a1 + 100))
      {
        unsigned int v10 = *(_DWORD *)(a1 + 96);
      }

      else
      {
        *(_DWORD *)(a1 + 100) = v8;
        unsigned int v10 = *(_DWORD *)(a1 + 96);
        if (!v10)
        {
          *(_DWORD *)(a1 + 96) = v8;
          unsigned int v10 = v8;
        }
      }

      if (v8 < v10) {
        *(_DWORD *)(a1 + 96) = v8;
      }
LABEL_43:
      tls_handshake_set_min_protocol_version();
      tls_handshake_set_max_protocol_version();
      return 0LL;
  }