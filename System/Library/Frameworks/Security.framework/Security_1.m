uint64_t _SSLGetProtocolVersionEnabled(uint64_t a1, int a2, BOOL *a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  if (!a1) {
    return 4294967246LL;
  }
  if (*(_BYTE *)(a1 + 104)) {
    return 4294966387LL;
  }
  v3 = 4294967246LL;
  v4 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_12;
    case 2:
      v4 = 768;
      goto LABEL_12;
    case 4:
      v4 = 769;
      goto LABEL_12;
    case 6:
      if (*(_DWORD *)(a1 + 96) > 0x300u) {
        goto LABEL_13;
      }
      v5 = *(_DWORD *)(a1 + 100) > 0x302u;
      goto LABEL_15;
    case 7:
      v4 = 770;
      goto LABEL_12;
    case 8:
      v4 = 771;
LABEL_12:
      if (*(_DWORD *)(a1 + 96) <= v4) {
        v5 = *(_DWORD *)(a1 + 100) >= v4;
      }
      else {
LABEL_13:
      }
        v5 = 0;
LABEL_15:
      v3 = 0LL;
      *a3 = v5;
      break;
    default:
      return v3;
  }

  return v3;
}

uint64_t _SSLSetProtocolVersion(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  BOOL v3 = v2 > 6;
  int v4 = (1 << v2) & 0x59;
  BOOL v5 = v3 || v4 == 0;
  if (v5 || *(_BYTE *)(a1 + 104)) {
    return 4294966387LL;
  }
  if (a2 > 8 || ((0x1FDu >> a2) & 1) == 0) {
    return 4294967246LL;
  }
  int v7 = dword_18065471C[a2];
  *(_DWORD *)(a1 + 96) = dword_1806546F8[a2];
  *(_DWORD *)(a1 + 100) = v7;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0LL;
}

uint64_t _SSLGetProtocolVersion(uint64_t a1, int *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  switch(*(_DWORD *)(a1 + 100))
  {
    case 0x300:
      if (*(_DWORD *)(a1 + 96) != 768) {
        return 4294967246LL;
      }
      uint64_t result = 0LL;
      int v3 = 2;
      goto LABEL_14;
    case 0x301:
      int v4 = *(_DWORD *)(a1 + 96);
      if (v4 == 768)
      {
        uint64_t result = 0LL;
        int v3 = 4;
      }

      else
      {
        if (v4 != 769) {
          return 4294967246LL;
        }
        uint64_t result = 4294967246LL;
        int v3 = 5;
      }

OSStatus SSLGetNegotiatedProtocolVersion(SSLContextRef context, SSLProtocol *protocol)
{
  if (!context) {
    return -50;
  }
  SSLProtocol v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 22))
  {
    case 0x300:
      break;
    case 0x301:
      SSLProtocol v2 = kTLSProtocol1;
      break;
    case 0x302:
      SSLProtocol v2 = kTLSProtocol11;
      break;
    case 0x303:
      SSLProtocol v2 = kTLSProtocol12;
      break;
    default:
      SSLProtocol v2 = kSSLProtocolUnknown;
      break;
  }

  OSStatus result = 0;
  *protocol = v2;
  return result;
}

uint64_t _SSLSetEnableCertVerify(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return 4294966387LL;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 187) = a2;
  return result;
}

uint64_t _SSLGetEnableCertVerify(uint64_t a1, _BYTE *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(_BYTE *)(a1 + 187);
  return result;
}

uint64_t _SSLSetAllowsExpiredCerts()
{
  return 0LL;
}

uint64_t _SSLGetAllowsExpiredCerts()
{
  return 4294967292LL;
}

uint64_t _SSLSetAllowsExpiredRoots()
{
  return 0LL;
}

uint64_t _SSLGetAllowsExpiredRoots()
{
  return 4294967292LL;
}

uint64_t _SSLSetAllowsAnyRoot(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 312) = a2;
  return result;
}

uint64_t _SSLGetAllowsAnyRoot(uint64_t a1, _BYTE *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(_BYTE *)(a1 + 312);
  return result;
}

uint64_t _SSLSetTrustedRoots(uint64_t a1, CFArrayRef theArray, int a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return 4294966387LL;
  }
  if (a3)
  {
    *(_BYTE *)(a1 + 184) = 1;
    v9 = *(const void **)(a1 + 176);
    if (v9)
    {
      *(void *)(a1 + 176) = 0LL;
      CFRelease(v9);
    }
  }

  if (*(void *)(a1 + 176))
  {
    v12.length = CFArrayGetCount(theArray);
    v12.location = 0LL;
    CFArrayAppendArray(*(CFMutableArrayRef *)(a1 + 176), theArray, v12);
    return 0LL;
  }

  CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, theArray);
  *(void *)(a1 + 176) = MutableCopy;
  if (MutableCopy) {
    return 0LL;
  }
  return 4294967188LL;
}

uint64_t _SSLCopyTrustedRoots(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 176);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 176));
      return 0LL;
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = 0LL;
    }
  }

  return result;
}

OSStatus SSLSetClientSideAuthenticate(SSLContextRef context, SSLAuthenticate auth)
{
  if (!context) {
    return -50;
  }
  unsigned int v2 = *((_DWORD *)context + 20);
  BOOL v3 = v2 > 6;
  int v4 = (1 << v2) & 0x59;
  if (v3 || v4 == 0) {
    return -909;
  }
  *((_DWORD *)context + 63) = auth;
  return 0;
}

uint64_t SSLGetClientSideAuthenticate(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(_DWORD *)(a1 + 252);
    }
  }

  return result;
}

OSStatus SSLGetClientCertificateState(SSLContextRef context, SSLClientCertificateState *clientState)
{
  if (!context) {
    return -50;
  }
  SSLClientCertificateState v2 = *((_DWORD *)context + 64);
  if (*((_DWORD *)context + 27) == 1)
  {
    if (v2 == kSSLClientCertNone)
    {
LABEL_16:
      OSStatus result = 0;
      *clientState = v2;
      return result;
    }

    if (v2 == kSSLClientCertRequested)
    {
      BOOL v3 = (char *)context + 152;
      goto LABEL_13;
    }
  }

  else
  {
    if (v2) {
      BOOL v5 = v2 == kSSLClientCertRejected;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5) {
      goto LABEL_16;
    }
    if (v2 == kSSLClientCertRequested)
    {
      BOOL v3 = (char *)context + 168;
LABEL_13:
      if (*(void *)v3) {
        SSLClientCertificateState v2 = kSSLClientCertSent;
      }
      else {
        SSLClientCertificateState v2 = kSSLClientCertRequested;
      }
      goto LABEL_16;
    }
  }

  return -9810;
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  if (!context) {
    return -50;
  }
  int v4 = (const void *)*((void *)context + 19);
  if (v4)
  {
    *((void *)context + 19) = 0LL;
    CFRelease(v4);
  }

  if (certRefs)
  {
    OSStatus result = tls_helper_set_identity_from_array();
    if (result) {
      return result;
    }
    *((void *)context + 19) = certRefs;
    CFRetain(certRefs);
  }

  return 0;
}

OSStatus SSLSetEncryptionCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  BOOL v4 = v3 > 6;
  int v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0) {
    return -909;
  }
  v8 = (const void *)*((void *)context + 20);
  if (v8)
  {
    *((void *)context + 20) = 0LL;
    CFRelease(v8);
  }

  *((void *)context + 20) = certRefs;
  CFRetain(certRefs);
  return 0;
}

uint64_t SSLGetCertificate(uint64_t a1, void *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(void *)(a1 + 152);
  return result;
}

uint64_t SSLGetEncryptionCertificate(uint64_t a1, void *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(void *)(a1 + 160);
  return result;
}

OSStatus SSLSetPeerID(SSLContextRef context, const void *peerID, size_t peerIDLen)
{
  OSStatus result = -50;
  if (context && peerID && peerIDLen)
  {
    unsigned int v7 = *((_DWORD *)context + 20);
    BOOL v8 = v7 > 6;
    int v9 = (1 << v7) & 0x59;
    BOOL v10 = v8 || v9 == 0;
    if (!v10 || *((_DWORD *)context + 64) == 1)
    {
      v11 = (void *)*((void *)context + 27);
      if (v11) {
        free(v11);
      }
      CFRange v12 = malloc(peerIDLen);
      if (v12) {
        size_t v13 = peerIDLen;
      }
      else {
        size_t v13 = 0LL;
      }
      *((void *)context + 26) = v13;
      *((void *)context + 27) = v12;
      if (v12)
      {
        tls_handshake_set_resumption();
        memmove(*((void **)context + 27), peerID, peerIDLen);
        return 0;
      }

      else
      {
        return -1;
      }
    }

    else
    {
      return -909;
    }
  }

  return result;
}

OSStatus SSLGetPeerID(SSLContextRef context, const void **peerID, size_t *peerIDLen)
{
  size_t v3 = *((void *)context + 26);
  *peerID = (const void *)*((void *)context + 27);
  *peerIDLen = v3;
  return 0;
}

OSStatus SSLGetNegotiatedCipher(SSLContextRef context, SSLCipherSuite *cipherSuite)
{
  if (!context) {
    return -50;
  }
  unsigned int v3 = *((_DWORD *)context + 20);
  if (v3 < 7 && ((0x59u >> v3) & 1) != 0) {
    return -909;
  }
  SSLCipherSuite negotiated_cipherspec = tls_handshake_get_negotiated_cipherspec();
  OSStatus result = 0;
  *cipherSuite = negotiated_cipherspec;
  return result;
}

OSStatus SSLAddDistinguishedName(SSLContextRef context, const void *derDN, size_t derDNLen)
{
  if (!context) {
    return -50;
  }
  unsigned int v4 = *((_DWORD *)context + 20);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return -909;
  }
  BOOL v10 = malloc(0x18uLL);
  if (!v10) {
    return -108;
  }
  v11 = v10;
  CFRange v12 = malloc(derDNLen);
  if (v12) {
    size_t v13 = derDNLen;
  }
  else {
    size_t v13 = 0LL;
  }
  v11[1] = v13;
  v11[2] = v12;
  if (v12)
  {
    memcpy(v12, derDN, derDNLen);
    void *v11 = *((void *)context + 33);
    *((void *)context + 33) = v11;
    tls_handshake_set_acceptable_dn_list();
    return 0;
  }

  else
  {
    free(v11);
    return -1;
  }

uint64_t _SSLSetCertificateAuthorities(uint64_t a1, CFTypeRef cf, int a3)
{
  if (a1)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 80);
    BOOL v5 = v4 > 6;
    int v6 = (1 << v4) & 0x59;
    BOOL v7 = v5 || v6 == 0;
    if (!v7 && !*(_DWORD *)(a1 + 108))
    {
      if (a3)
      {
        sslFreeDnList(a1);
        BOOL v10 = *(const void **)(a1 + 272);
        if (v10)
        {
          CFRelease(v10);
          *(void *)(a1 + 272) = 0LL;
        }
      }

      CFTypeID v11 = CFGetTypeID(cf);
      if (v11 == SecCertificateGetTypeID()) {
        return sslAddCA((SSLContext *)a1, cf);
      }
      if (v11 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        if (Count < 1) {
          return 0LL;
        }
        CFIndex v13 = Count;
        CFIndex v14 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v14);
          CFTypeID v16 = CFGetTypeID(ValueAtIndex);
          if (v16 != SecCertificateGetTypeID()) {
            break;
          }
          uint64_t result = sslAddCA((SSLContext *)a1, ValueAtIndex);
          if (!(_DWORD)result && v13 != ++v14) {
            continue;
          }
          return result;
        }
      }
    }
  }

  return 4294967246LL;
}

uint64_t sslAddCA(SSLContext *a1, const void *a2)
{
  unsigned int v4 = SecDERItemCopySequence((uint64_t)a2 + 184);
  if (!v4) {
    return 4294967246LL;
  }
  BOOL v5 = v4;
  Mutable = (__CFArray *)*((void *)a1 + 34);
  if (Mutable
    || (Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]), (*((void *)a1 + 34) = Mutable) != 0LL))
  {
    CFArrayAppendValue(Mutable, a2);
    BytePtr = CFDataGetBytePtr(v5);
    CFIndex Length = CFDataGetLength(v5);
    uint64_t v9 = SSLAddDistinguishedName(a1, BytePtr, Length);
  }

  else
  {
    uint64_t v9 = 4294967246LL;
  }

  CFRelease(v5);
  return v9;
}

uint64_t _SSLCopyCertificateAuthorities(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 272);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 272));
      return 0LL;
    }

    else
    {
      uint64_t result = 0LL;
      *a2 = 0LL;
    }
  }

  return result;
}

OSStatus SSLCopyDistinguishedNames(SSLContextRef context, CFArrayRef *names)
{
  OSStatus result = -50;
  if (context && names)
  {
    if (*((_DWORD *)context + 27))
    {
      uint64_t peer_acceptable_dn_list = tls_handshake_get_peer_acceptable_dn_list();
      if (peer_acceptable_dn_list) {
        goto LABEL_5;
      }
    }

    else
    {
      uint64_t peer_acceptable_dn_list = *((void *)context + 33);
      if (peer_acceptable_dn_list)
      {
LABEL_5:
        Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
        do
        {
          CFDataRef v7 = CFDataCreate( 0LL,  *(const UInt8 **)(peer_acceptable_dn_list + 16),  *(void *)(peer_acceptable_dn_list + 8));
          CFArrayAppendValue(Mutable, v7);
          CFRelease(v7);
          uint64_t peer_acceptable_dn_list = *(void *)peer_acceptable_dn_list;
        }

        while (peer_acceptable_dn_list);
        goto LABEL_10;
      }
    }

    Mutable = 0LL;
LABEL_10:
    OSStatus result = 0;
    *names = Mutable;
  }

  return result;
}

uint64_t _SSLCopyPeerCertificates(uint64_t a1, CFArrayRef *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v3 = *(__SecTrust **)(a1 + 168);
  if (!v3)
  {
    CFArrayRef v5 = 0LL;
    uint64_t result = 4294966387LL;
    goto LABEL_7;
  }

  CFArrayRef v4 = SecTrustCopyCertificateChain(v3);
  if (v4)
  {
    CFArrayRef v5 = v4;
    uint64_t result = 0LL;
LABEL_7:
    *a2 = v5;
    return result;
  }

  return 4294967188LL;
}

uint64_t _SSLSetDiffieHellmanParams(uint64_t a1, const void *a2, size_t __size)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 80);
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0) {
    return 4294966387LL;
  }
  BOOL v10 = (void *)(a1 + 136);
  CFTypeID v11 = *(void **)(a1 + 144);
  if (v11) {
    free(v11);
  }
  *BOOL v10 = 0LL;
  *(void *)(a1 + 144) = 0LL;
  CFRange v12 = malloc(__size);
  if (v12)
  {
    CFIndex v13 = v12;
    memcpy(v12, a2, __size);
    *(void *)(a1 + 136) = __size;
    *(void *)(a1 + 144) = v13;
    return tls_handshake_set_dh_parameters();
  }

  else
  {
    *(void *)(a1 + 144) = 0LL;
    return 0xFFFFFFFFLL;
  }

uint64_t _SSLGetDiffieHellmanParams(uint64_t a1, void *a2, void *a3)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  uint64_t v6 = a1 + 136;
  uint64_t v5 = *(void *)(a1 + 136);
  *a2 = *(void *)(v6 + 8);
  *a3 = v5;
  return result;
}

uint64_t SSLSetDHEEnabled(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 552) = a2;
  tls_handshake_get_min_protocol_version();
  tls_handshake_get_max_protocol_version();
  tls_handshake_get_min_dh_group_size();
  tls_handshake_set_config();
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  tls_handshake_set_min_dh_group_size();
  return 0LL;
}

uint64_t SSLGetDHEEnabled(uint64_t a1, _BYTE *a2)
{
  *a2 = *(_BYTE *)(a1 + 552);
  return 0LL;
}

uint64_t SSLSetMinimumDHGroupSize()
{
  return tls_handshake_set_min_dh_group_size();
}

uint64_t SSLGetMinimumDHGroupSize()
{
  return tls_handshake_get_min_dh_group_size();
}

uint64_t _SSLSetRsaBlinding(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 314) = a2;
  return result;
}

uint64_t _SSLGetRsaBlinding(uint64_t a1, _BYTE *a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(_BYTE *)(a1 + 314);
  return result;
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  OSStatus SecTrust = -50;
  if (context && trust)
  {
    uint64_t v6 = (CFTypeRef *)((char *)context + 168);
    uint64_t v5 = (__SecTrust *)*((void *)context + 21);
    if (v5)
    {
      OSStatus SecTrust = 0;
    }

    else
    {
      OSStatus SecTrust = sslCreateSecTrust((uint64_t)context, (void *)context + 21);
      uint64_t v5 = (__SecTrust *)*((void *)context + 21);
    }

    *trust = v5;
    if (*v6) {
      CFRetain(*v6);
    }
  }

  return SecTrust;
}

uint64_t SSLGetPeerSecTrust(uint64_t a1, void *a2)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v5 = *(void *)(a1 + 168);
    if (v5)
    {
      uint64_t result = 0LL;
    }

    else
    {
      uint64_t result = sslCreateSecTrust(a1, (void *)(a1 + 168));
      uint64_t v5 = *(void *)(a1 + 168);
    }

    *a2 = v5;
  }

  return result;
}

uint64_t SSLInternalMasterSecret(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return tls_handshake_internal_master_secret();
  }
  else {
    return 4294967246LL;
  }
}

uint64_t SSLInternalServerRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return tls_handshake_internal_server_random();
  }
  else {
    return 4294967246LL;
  }
}

uint64_t SSLInternalClientRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3) {
    return tls_handshake_internal_client_random();
  }
  else {
    return 4294967246LL;
  }
}

uint64_t SSLGetCipherSizes(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      tls_handshake_get_negotiated_cipherspec();
      *a2 = sslCipherSuiteGetMacSize();
      *a3 = sslCipherSuiteGetSymmetricCipherKeySize();
      unsigned int SymmetricCipherBlockIvSize = sslCipherSuiteGetSymmetricCipherBlockIvSize();
      uint64_t result = 0LL;
      *a4 = SymmetricCipherBlockIvSize;
    }
  }

  return result;
}

uint64_t SSLGetResumableSessionInfo(uint64_t a1, _BYTE *a2, void *a3, unint64_t *a4)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2 && a3 && a4)
  {
    if (*a4 < 0x20) {
      return 4294967246LL;
    }
    if (tls_handshake_get_session_match())
    {
      *a2 = 1;
      unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
      if (*a4 < 0xAAAAAAAAAAAAAAAALL) {
        return 4294967246LL;
      }
      memmove(a3, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
    }

    else
    {
      unint64_t v9 = 0LL;
      *a2 = 0;
    }

    uint64_t result = 0LL;
    *a4 = v9;
  }

  return result;
}

uint64_t SSLSetAllowAnonymousCiphers()
{
  return 0LL;
}

uint64_t SSLGetAllowAnonymousCiphers()
{
  return 0LL;
}

uint64_t SSLSetSessionCacheTimeout(uint64_t a1, int a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 316) = a2;
  return result;
}

uint64_t SSLInternalSetMasterSecretFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 4294967246LL;
  }
  *(void *)(a1 + 336) = a2;
  *(void *)(a1 + 344) = a3;
  return tls_handshake_internal_set_master_secret_function();
}

uint64_t tls_handshake_master_secret_function(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(a1 + 336))(a1, *(void *)(a1 + 344), a2, a3);
}

uint64_t SSLInternalSetSessionTicket(uint64_t a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  unsigned int v1 = *(_DWORD *)(a1 + 80);
  BOOL v2 = v1 >= 6;
  BOOL v4 = v1 == 6;
  int v3 = (1 << v1) & 0x59;
  BOOL v4 = !v4 && v2 || v3 == 0;
  if (v4) {
    return 4294966387LL;
  }
  else {
    return tls_handshake_internal_set_session_ticket();
  }
}

uint64_t SSLGetNegotiatedCurve(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      int negotiated_curve = tls_handshake_get_negotiated_curve();
      uint64_t result = 0LL;
      *a2 = negotiated_curve;
    }
  }

  return result;
}

uint64_t SSLGetNumberOfECDSACurves(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(_DWORD *)(a1 + 248);
    }
  }

  return result;
}

uint64_t SSLGetECDSACurves(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = 4294967246LL;
  if (a1 && a2 && a3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 248);
    if (*a3 >= v4)
    {
      if (v4)
      {
        unint64_t v5 = 0LL;
        do
        {
          *(_DWORD *)(a2 + 4 * v5) = *(unsigned __int16 *)(*(void *)(a1 + 240) + 2 * v5);
          ++v5;
          unint64_t v6 = *(unsigned int *)(a1 + 248);
        }

        while (v5 < v6);
      }

      else
      {
        LODWORD(v6) = 0;
      }

      uint64_t v3 = 0LL;
      *a3 = v6;
    }

    else
    {
      return 4294967246LL;
    }
  }

  return v3;
}

uint64_t SSLSetECDSACurves(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2 && a3)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 80);
    BOOL v8 = v7 > 6;
    int v9 = (1 << v7) & 0x59;
    if (v8 || v9 == 0)
    {
      return 4294966387LL;
    }

    else
    {
      CFTypeID v11 = malloc(2LL * a3);
      *(void *)(a1 + 240) = v11;
      if (v11)
      {
        uint64_t v12 = 0LL;
        do
        {
          int v13 = *(_DWORD *)(a2 + 4 * v12);
          if (v13 > 65534) {
            LOWORD(v13) = -1;
          }
          v11[v12++] = v13;
        }

        while (a3 != v12);
        *(_DWORD *)(a1 + 248) = a3;
        tls_handshake_set_curves();
        return 0LL;
      }

      else
      {
        *(_DWORD *)(a1 + 248) = 0;
        return 4294967188LL;
      }
    }
  }

  return result;
}

uint64_t SSLGetNumberOfClientAuthTypes(uint64_t a1, _DWORD *a2)
{
  if (!a1 || !*(_DWORD *)(a1 + 256)) {
    return 4294967246LL;
  }
  uint64_t result = 0LL;
  *a2 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetClientAuthTypes(uint64_t a1, void *__dst, _DWORD *a3)
{
  if (!a1) {
    return 4294967246LL;
  }
  if (!*(_DWORD *)(a1 + 256)) {
    return 4294967246LL;
  }
  memmove(__dst, *(const void **)(a1 + 408), 4LL * *(unsigned int *)(a1 + 400));
  uint64_t result = 0LL;
  *a3 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetNegotiatedClientAuthType()
{
  return 4294967292LL;
}

uint64_t SSLGetNumberOfSignatureAlgorithms(uint64_t a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  tls_handshake_get_peer_signature_algorithms();
  return 0LL;
}

uint64_t SSLGetSignatureAlgorithms(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1) {
    return 4294967246LL;
  }
  peer_signature_algorithms = (const void *)tls_handshake_get_peer_signature_algorithms();
  memmove(a2, peer_signature_algorithms, 0x555555550uLL);
  uint64_t result = 0LL;
  *a3 = -1431655766;
  return result;
}

uint64_t SSLSetPSKSharedSecret(uint64_t a1, const void *a2, size_t __size)
{
  if (!a1) {
    return 4294967246LL;
  }
  unint64_t v6 = (void *)(a1 + 480);
  unsigned int v7 = *(void **)(a1 + 488);
  if (v7)
  {
    free(v7);
    *unint64_t v6 = 0LL;
    v6[1] = 0LL;
  }

  BOOL v8 = malloc(__size);
  if (v8)
  {
    int v9 = v8;
    memcpy(v8, a2, __size);
    *(void *)(a1 + 480) = __size;
    *(void *)(a1 + 488) = v9;
    tls_handshake_set_psk_secret();
    return 0LL;
  }

  else
  {
    *(void *)(a1 + 488) = 0LL;
    return 4294967188LL;
  }

uint64_t SSLSetPSKIdentity(uint64_t a1, const void *a2, size_t __size)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2 && __size)
  {
    unsigned int v7 = *(void **)(a1 + 504);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 496) = 0LL;
      *(void *)(a1 + 504) = 0LL;
    }

    BOOL v8 = malloc(__size);
    if (v8)
    {
      int v9 = v8;
      memcpy(v8, a2, __size);
      *(void *)(a1 + 496) = __size;
      *(void *)(a1 + 504) = v9;
      tls_handshake_set_psk_identity();
      return 0LL;
    }

    else
    {
      *(void *)(a1 + 504) = 0LL;
      return 4294967188LL;
    }
  }

  return result;
}

uint64_t SSLGetPSKIdentity(uint64_t a1, void *a2, void *a3)
{
  uint64_t result = 4294967246LL;
  if (a1 && a2)
  {
    if (a3)
    {
      uint64_t result = 0LL;
      uint64_t v6 = a1 + 496;
      uint64_t v5 = *(void *)(a1 + 496);
      *a2 = *(void *)(v6 + 8);
      *a3 = v5;
    }
  }

  return result;
}

uint64_t SSLInternal_PRF()
{
  return tls_handshake_internal_prf();
}

uint64_t tls_handshake_write_callback(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v6 = *(uint64_t (**)(uint64_t, _BYTE *))(v5 + 8);
  v8[0] = a4;
  memset(&v8[1], 170, 7);
  uint64_t v9 = a2;
  uint64_t v10 = a3;
  return v6(v4, v8);
}

uint64_t tls_handshake_message_callback(uint64_t a1, int a2)
{
  uint64_t result = 0LL;
  if (a2 > 12)
  {
    switch(a2)
    {
      case 67:
        uint64_t result = tls_handshake_get_peer_npn_data();
        if (!result) {
          return result;
        }
        (*(void (**)(uint64_t, void, void, void))(a1 + 520))( a1,  *(void *)(a1 + 528),  *(void *)(result + 8),  *(void *)result);
        break;
      case 14:
        return tls_verify_peer_cert(a1);
      case 13:
        *(_DWORD *)(a1 + 256) = 1;
        *(void *)(a1 + 408) = tls_handshake_get_peer_acceptable_client_auth_type();
        if (*(_BYTE *)(a1 + 354) && !*(void *)(a1 + 152))
        {
          *(_BYTE *)(a1 + 357) = 1;
          return 4294957454LL;
        }

        break;
      default:
        return result;
    }

    return 0LL;
  }

  switch(a2)
  {
    case 1:
      *(void *)(a1 + 392) = tls_handshake_get_peer_signature_algorithms();
      if (*(_BYTE *)(a1 + 359)) {
        return 4294957445LL;
      }
      else {
        return 0LL;
      }
    case 2:
      *(_BYTE *)(a1 + 553) = 1;
      peer_alpn_data = (void *)tls_handshake_get_peer_alpn_data();
      if (peer_alpn_data && (uint64_t v5 = *(void (**)(uint64_t, void, void, void))(a1 + 536)) != 0LL)
      {
        uint64_t v6 = (void *)(a1 + 544);
      }

      else
      {
        peer_alpn_data = (void *)tls_handshake_get_peer_npn_data();
        if (!peer_alpn_data)
        {
LABEL_27:
          uint64_t peer_signature_algorithms = tls_handshake_get_peer_signature_algorithms();
          uint64_t result = 0LL;
          *(void *)(a1 + 392) = peer_signature_algorithms;
          return result;
        }

        uint64_t v5 = *(void (**)(uint64_t, void, void, void))(a1 + 520);
        uint64_t v6 = (void *)(a1 + 528);
      }

      v5(a1, *v6, peer_alpn_data[1], *peer_alpn_data);
      goto LABEL_27;
    case 11:
      uint64_t result = tls_helper_set_peer_pubkey();
      if (!(_DWORD)result)
      {
        if (!*(_DWORD *)(a1 + 108)) {
          return tls_verify_peer_cert(a1);
        }
        return 0LL;
      }

      break;
  }

  return result;
}

_DWORD *tls_handshake_ready_callback(_DWORD *result, int a2, int a3)
{
  if (a2)
  {
    result[19] = a3;
  }

  else
  {
    result[18] = a3;
    if (a3) {
      int v3 = 2;
    }
    else {
      int v3 = 1;
    }
    result[20] = v3;
  }

  return result;
}

uint64_t tls_handshake_set_retransmit_timer_callback(uint64_t a1, int a2)
{
  if (a2) {
    double v3 = CFAbsoluteTimeGetCurrent() + (double)(1 << (a2 - 1)) * *(double *)(a1 + 424);
  }
  else {
    double v3 = 0.0;
  }
  *(double *)(a1 + 416) = v3;
  return 0LL;
}

uint64_t tls_handshake_save_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a2;
  v11[1] = a3;
  uint64_t v9 = a4;
  uint64_t v10 = a5;
  if (!*(void *)(a1 + 64)) {
    return 4294957492LL;
  }
  size_t v7 = 0LL;
  BOOL v8 = 0LL;
  uint64_t v5 = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v11, &v7);
  if (!(_DWORD)v5)
  {
    uint64_t v5 = tls_cache_save_session_data();
    free(v8);
  }

  return v5;
}

uint64_t tls_handshake_load_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  v12[0] = a2;
  v12[1] = a3;
  uint64_t v6 = (void *)(a1 + 224);
  size_t v7 = *(void **)(a1 + 232);
  if (v7) {
    free(v7);
  }
  *uint64_t v6 = 0LL;
  v6[1] = 0LL;
  if (!*(void *)(a1 + 64)) {
    return 4294957492LL;
  }
  size_t v10 = 0LL;
  CFTypeID v11 = 0LL;
  uint64_t session_data = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v12, &v10);
  if (!(_DWORD)session_data)
  {
    uint64_t session_data = tls_cache_load_session_data();
    *a4 = *(_OWORD *)v6;
    free(v11);
  }

  return session_data;
}

uint64_t tls_handshake_delete_session_data_callback(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    return tls_cache_delete_session_data();
  }
  else {
    return 4294957492LL;
  }
}

uint64_t tls_handshake_delete_all_sessions_callback(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    tls_cache_empty();
  }
  return 0LL;
}

uint64_t tls_handshake_init_pending_cipher_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 48));
}

uint64_t tls_handshake_advance_write_callback(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 315)) {
    BOOL v2 = *(_DWORD *)(a1 + 88) < 0x302u;
  }
  else {
    BOOL v2 = 0LL;
  }
  (*(void (**)(void, void, BOOL))(*(void *)(a1 + 40) + 72LL))(*(void *)(a1 + 48), 0LL, v2);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 24LL))(*(void *)(a1 + 48));
}

uint64_t tls_handshake_rollback_write_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 32LL))(*(void *)(a1 + 48));
}

uint64_t tls_handshake_advance_read_cipher_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 40LL))(*(void *)(a1 + 48));
}

uint64_t tls_handshake_set_protocol_version_callback(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 88) = a2;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 48LL))(*(void *)(a1 + 48));
}

uint64_t _buildConfigurationSpecificSessionCacheKey(uint64_t a1, uint64_t a2, size_t *a3)
{
  uint64_t v6 = *(const void **)(a1 + 376);
  if (!v6)
  {
    size_t v10 = malloc(0xAuLL);
    if (v10)
    {
      uint64_t v9 = v10;
      *size_t v10 = *(void *)(a1 + 353);
      *((_WORD *)v10 + 4) = *(_WORD *)(a1 + 361);
      size_t v7 = 10LL;
      *(void *)(a1 + 368) = 10LL;
      CFTypeID v11 = malloc(0xAuLL);
      *(void *)(a1 + 376) = v11;
      *(void *)CFTypeID v11 = *(void *)v9;
      v11[4] = v9[4];
      goto LABEL_6;
    }

    return 4294967188LL;
  }

  size_t v7 = *(void *)(a1 + 368);
  BOOL v8 = malloc(v7);
  if (!v8) {
    return 4294967188LL;
  }
  uint64_t v9 = v8;
  memcpy(v8, v6, v7);
LABEL_6:
  size_t v12 = *(void *)a2 + v7;
  *a3 = v12;
  int v13 = (char *)malloc(v12);
  a3[1] = (size_t)v13;
  if (v13)
  {
    CFIndex v14 = v13;
    memcpy(v13, v9, v7);
    memcpy(&v14[v7], *(const void **)(a2 + 8), *(void *)a2);
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = 4294967188LL;
  }

  free(v9);
  return v15;
}

uint64_t SSLRecordReadInternal(void *a1, uint64_t a2)
{
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t header_size = (int)tls_record_get_header_size();
  unint64_t v5 = a1[4];
  unint64_t v6 = header_size - v5;
  if (header_size <= v5)
  {
LABEL_9:
    tls_record_parse_header();
    if (a1[2] < 0xAAAAAAAAAAAAAAACLL) {
      return 4294957288LL;
    }
    unint64_t v12 = a1[4];
    if (v12 < 0xAAAAAAAAAAAAAAACLL
      && ((unint64_t v13 = a1[3] + v12,
           uint64_t v14 = a1[1],
           unint64_t v20 = 0xAAAAAAAAAAAAAAACLL - v12,
           uint64_t result = (*(uint64_t (**)(void, unint64_t, unint64_t *))(v14 + 16))( *(void *)(v14 + 32),  v13,  &v20),  (_DWORD)result != -9803)
        ? (int v15 = result)
        : (int v15 = -10001),
          v15))
    {
      if (v15 == -10001) {
        goto LABEL_7;
      }
    }

    else
    {
      *(_BYTE *)a2 = -86;
      a1[4] = 0LL;
      size_t v16 = tls_record_decrypted_size();
      if (v16)
      {
        size_t v17 = v16;
        v18 = malloc(v16);
        if (v18) {
          size_t v19 = v17;
        }
        else {
          size_t v19 = 0LL;
        }
        *(void *)(a2 + 8) = v19;
        *(void *)(a2 + 16) = v18;
        if (v18) {
          return tls_record_decrypt();
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }

      else if (*(_BYTE *)(a1[1] + 104LL))
      {
        return 4294957287LL;
      }

      else
      {
        return 4294957292LL;
      }
    }

    return result;
  }

  unint64_t v7 = a1[3] + v5;
  uint64_t v8 = a1[1];
  unint64_t v20 = v6;
  int v9 = (*(uint64_t (**)(void, unint64_t, unint64_t *))(v8 + 16))( *(void *)(v8 + 32),  v7,  &v20);
  if (v9 == -9803) {
    int v10 = -10001;
  }
  else {
    int v10 = v9;
  }
  if (!v10)
  {
    a1[4] += v20;
    goto LABEL_9;
  }

  if (v10 == -10001)
  {
LABEL_7:
    a1[4] += v20;
    return 4294957295LL;
  }

  return 4294957292LL;
}

uint64_t SSLRecordWriteInternal(uint64_t a1)
{
  uint64_t v2 = tls_record_encrypted_size();
  double v3 = malloc(v2 + 24);
  if (!v3) {
    return 4294957296LL;
  }
  uint64_t v4 = v3;
  *double v3 = 0LL;
  v3[1] = 0LL;
  v3[2] = v2;
  uint64_t v5 = tls_record_encrypt();
  if ((_DWORD)v5)
  {
    uint64_t v8 = v5;
    free(v4);
  }

  else
  {
    v4[2] = v2;
    unint64_t v6 = *(void **)(a1 + 40);
    if (v6)
    {
      do
      {
        unint64_t v7 = v6;
        unint64_t v6 = (void *)*v6;
      }

      while (v6);
      uint64_t v8 = 0LL;
      *unint64_t v7 = v4;
    }

    else
    {
      uint64_t v8 = 0LL;
      *(void *)(a1 + 40) = v4;
    }
  }

  return v8;
}

uint64_t SSLInitInternalRecordLayerPendingCiphers()
{
  return tls_record_init_pending_ciphers();
}

uint64_t SSLAdvanceInternalRecordLayerWriteCipher()
{
  return tls_record_advance_write_cipher();
}

uint64_t SSLRollbackInternalRecordLayerWriteCipher()
{
  return tls_record_rollback_write_cipher();
}

uint64_t SSLAdvanceInternalRecordLayerReadCipher()
{
  return tls_record_advance_read_cipher();
}

uint64_t SSLSetInternalRecordLayerProtocolVersion()
{
  return tls_record_set_protocol_version();
}

uint64_t SSLRecordFreeInternal(uint64_t a1, uint64_t a2)
{
  double v3 = *(void **)(a2 + 16);
  if (v3) {
    free(v3);
  }
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  return 0LL;
}

uint64_t SSLRecordServiceWriteQueueInternal(uint64_t a1)
{
  while (1)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    if (!v2) {
      break;
    }
    uint64_t v3 = v2[1];
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v10 = v2[2] - v3;
    unsigned int v5 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(v4 + 24))( *(void *)(v4 + 32),  (uint64_t)v2 + v3 + 24,  &v10);
    if (v5 == -9803) {
      uint64_t v6 = 4294957295LL;
    }
    else {
      uint64_t v6 = v5;
    }
    unint64_t v7 = v2[2];
    unint64_t v8 = v2[1] + v10;
    v2[1] = v8;
    if (v8 >= v7)
    {
      *(void *)(a1 + 40) = *v2;
      free(v2);
    }

    if ((_DWORD)v6) {
      return v6;
    }
  }

  return 0LL;
}

uint64_t SSLRecordSetOption(uint64_t a1, int a2)
{
  if (a2) {
    return 0LL;
  }
  else {
    return tls_record_set_record_splitting();
  }
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  OSStatus v4 = -50;
  if (context && processed)
  {
    *processed = 0LL;
    int v9 = *((_DWORD *)context + 20);
    OSStatus v4 = -909;
    OSStatus v10 = -9805;
    switch(v9)
    {
      case 0:
        return v4;
      case 3:
        return v10;
      case 4:
      case 6:
        return -9806;
      default:
        break;
    }

    while (!*((_DWORD *)context + 19))
    {
      OSStatus v10 = SSLHandshakeProceed((uint64_t)context);
      if (v10) {
        goto LABEL_16;
      }
    }

    OSStatus v10 = (*(uint64_t (**)(void))(*((void *)context + 5) + 64LL))(*((void *)context + 6));
    if (!v10)
    {
      if (!dataLength) {
        goto LABEL_14;
      }
      memset(&v14[1], 170, 7);
      uint64_t v11 = *((void *)context + 6);
      unint64_t v12 = *(uint64_t (**)(uint64_t, _BYTE *))(*((void *)context + 5) + 8LL);
      v14[0] = 23;
      size_t v15 = dataLength;
      size_t v16 = data;
      OSStatus v10 = v12(v11, v14);
      if (!v10)
      {
LABEL_14:
        *processed = dataLength;
        OSStatus v10 = (*(uint64_t (**)(void))(*((void *)context + 5) + 64LL))(*((void *)context + 6));
      }

uint64_t SSLHandshakeProceed(uint64_t a1)
{
  uint64_t v2 = tls_handshake_continue();
  if (!(_DWORD)v2)
  {
    uint64_t v2 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 64LL))(*(void *)(a1 + 48));
    if (!(_DWORD)v2)
    {
      memset(v4, 170, sizeof(v4));
      uint64_t v2 = (**(uint64_t (***)(void, _BYTE *))(a1 + 40))(*(void *)(a1 + 48), v4);
      if (!(_DWORD)v2)
      {
        uint64_t v2 = tls_handshake_process();
        __int128 v5 = *(_OWORD *)v4;
        uint64_t v6 = *(void *)&v4[16];
        (*(void (**)(void, __int128 *))(*(void *)(a1 + 40) + 56LL))(*(void *)(a1 + 48), &v5);
      }

      if (*(_DWORD *)(a1 + 108) == 1
        && !*(_BYTE *)(a1 + 552)
        && !*(_BYTE *)(a1 + 553)
        && (_DWORD)v2 != -9803
        && (_DWORD)v2)
      {
        log_SecureTransport_early_fail((int)v2);
      }
    }
  }

  return v2;
}

void log_SecureTransport_early_fail(uint64_t a1)
{
  CFStringRef v1 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"com.apple.SecureTransport.early_fail.%ld",  a1);
  if (v1)
  {
    CFStringRef v2 = v1;
    SecCoreAnalyticsSendValue((uint64_t)v1, 1LL);
    CFRelease(v2);
  }

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  OSStatus result = -50;
  if (context && data && processed)
  {
    int v9 = (size_t *)((char *)context + 288);
    *processed = 0LL;
    while (2)
    {
      int v10 = *((_DWORD *)context + 20) - 3;
      if (v10 < 4)
      {
        return dword_18065A2D0[v10];
      }

      else
      {
        while (!*((_DWORD *)context + 18))
        {
          OSStatus result = SSLHandshakeProceed((uint64_t)context);
          if (result) {
            goto LABEL_29;
          }
        }

        OSStatus result = tls_handshake_continue();
        if (result) {
          return result;
        }
        OSStatus result = (*(uint64_t (**)(void))(*((void *)context + 5) + 64LL))(*((void *)context + 6));
        if (result) {
          BOOL v11 = result == -9803;
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11) {
          goto LABEL_29;
        }
        uint64_t v12 = *((void *)context + 37);
        size_t v13 = dataLength;
        uint64_t v14 = (char *)data;
        if (v12)
        {
          uint64_t v15 = *((void *)context + 38);
          size_t v16 = *((void *)context + 36) - v15 >= dataLength ? dataLength : *((void *)context + 36) - v15;
          memcpy(data, (const void *)(v12 + v15), v16);
          size_t v13 = dataLength - v16;
          uint64_t v14 = (char *)data + v16;
          *processed += v16;
          size_t v17 = (void *)*((void *)context + 37);
          size_t v18 = *((void *)context + 38) + v16;
          *((void *)context + 38) = v18;
          if (v17)
          {
            if (v18 >= *v9)
            {
              free(v17);
              size_t *v9 = 0LL;
              *((void *)context + 37) = 0LL;
              *((void *)context + 38) = 0LL;
            }
          }
        }

        if (!v13 || *((_DWORD *)context + 20) == 3) {
          goto LABEL_33;
        }
        OSStatus result = (**((uint64_t (***)(void, _BYTE *))context + 5))(*((void *)context + 6), v21);
        if (result)
        {
LABEL_29:
          uint64_t v19 = (result + 9851);
          if (v19 <= 0x30)
          {
            if (v19 == 2) {
              continue;
            }
          }

          if (result)
          {
            *((_DWORD *)context + 20) = 4;
            return result;
          }

          goto LABEL_33;
        }

        if (v21[0] != 23 && v21[0])
        {
          OSStatus result = tls_handshake_process();
          if (result)
          {
            if (result != -9805) {
              goto LABEL_29;
            }
            SSLClose(context);
          }

          __int128 v22 = *(_OWORD *)v21;
          uint64_t v23 = *(void *)&v21[16];
          OSStatus result = (*(uint64_t (**)(void, __int128 *))(*((void *)context + 5) + 56LL))( *((void *)context + 6),  &v22);
          if (!result) {
            goto LABEL_33;
          }
          goto LABEL_29;
        }

        uint64_t v20 = *(void *)&v21[8];
        if (*(void *)&v21[8] > v13)
        {
          memcpy(v14, *(const void **)&v21[16], v13);
          *processed += v13;
          *(_OWORD *)int v9 = *(_OWORD *)&v21[8];
          *((void *)context + 38) = v13;
          goto LABEL_33;
        }

        memcpy(v14, *(const void **)&v21[16], *(size_t *)&v21[8]);
        *processed += v20;
        __int128 v22 = *(_OWORD *)v21;
        uint64_t v23 = *(void *)&v21[16];
        OSStatus result = (*(uint64_t (**)(void, __int128 *))(*((void *)context + 5) + 56LL))( *((void *)context + 6),  &v22);
        if (result) {
          goto LABEL_29;
        }
LABEL_33:
        OSStatus result = 0;
        if (dataLength && !*processed) {
          continue;
        }
      }

      break;
    }
  }

  return result;
}

OSStatus SSLClose(SSLContextRef context)
{
  if (!context) {
    return -50;
  }
  OSStatus result = tls_handshake_close();
  if (!result)
  {
    OSStatus result = (*(uint64_t (**)(void))(*((void *)context + 5) + 64LL))(*((void *)context + 6));
  }

  *((_DWORD *)context + 20) = 3;
  if (result == -36) {
    return 0;
  }
  return result;
}

OSStatus SSLReHandshake(SSLContextRef context)
{
  if (!context) {
    return -50;
  }
  unsigned int v1 = *((_DWORD *)context + 20) - 1;
  if (v1 < 6 && ((0x2Du >> v1) & 1) != 0) {
    return dword_180654740[v1];
  }
  if (*((_DWORD *)context + 27) == 1) {
    return SSLHandshakeStart((uint64_t)context);
  }
  return tls_handshake_request_renegotiation();
}

uint64_t SSLHandshakeStart(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 md = v2;
  __int128 v16 = v2;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x8000000000LL;
  *(_OWORD *)v14.count = v2;
  *(_OWORD *)&v14.hash[2] = v2;
  *(_OWORD *)&v14.hash[6] = v2;
  *(_OWORD *)&v14.wbuf[2] = v2;
  *(_OWORD *)&v14.wbuf[6] = v2;
  *(_OWORD *)&v14.wbuf[10] = v2;
  *(void *)&v14.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  CC_SHA256_Init(&v14);
  CC_SHA256_Update((CC_SHA256_CTX *)(v12 + 3), (const void *)(a1 + 312), 1u);
  CC_SHA256_Update((CC_SHA256_CTX *)(v12 + 3), (const void *)(a1 + 184), 1u);
  uint64_t v3 = *(const __CFArray **)(a1 + 176);
  if (v3)
  {
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 0x40000000LL;
    context[2] = __get_extended_peer_id_block_invoke;
    context[3] = &unk_18966EF80;
    context[4] = &v11;
    v18.length = CFArrayGetCount(v3);
    v18.location = 0LL;
    CFArrayApplyFunction(v3, v18, (CFArrayApplierFunction)apply_block_1_7156, context);
  }

  CC_SHA256_Final((unsigned __int8 *)&md, (CC_SHA256_CTX *)(v12 + 3));
  size_t v4 = *(void *)(a1 + 208);
  int v9 = (char *)malloc(v4 + 32);
  memcpy(v9, *(const void **)(a1 + 216), v4);
  __int128 v5 = &v9[v4];
  __int128 v6 = v16;
  *(_OWORD *)__int128 v5 = md;
  *((_OWORD *)v5 + 1) = v6;
  _Block_object_dispose(&v11, 8);
  uint64_t v7 = tls_handshake_negotiate();
  free(v9);
  if (!(_DWORD)v7)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_DWORD *)(a1 + 80) = 1;
  }

  return v7;
}

uint64_t __get_extended_peer_id_block_invoke(uint64_t a1, uint64_t a2)
{
  return CC_SHA256_Update( (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(const void **)(a2 + 16),  *(_DWORD *)(a2 + 24));
}

uint64_t apply_block_1_7156(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLHandshake(SSLContextRef context)
{
  if (!context) {
    return -50;
  }
  int v2 = *((_DWORD *)context + 20);
  if (v2 == 3) {
    return -9805;
  }
  if (v2 == 4) {
    return -9806;
  }
  if (*((_BYTE *)context + 104))
  {
    if (*((double *)context + 52) != 0.0 && *((double *)context + 52) < CFAbsoluteTimeGetCurrent())
    {
      OSStatus result = MEMORY[0x186E0033C](*((void *)context + 7));
      if (result) {
        return result;
      }
    }

    int v2 = *((_DWORD *)context + 20);
  }

  if (v2 == 6)
  {
    int v4 = *((_DWORD *)context + 21);
    if (v4 == -67818 || v4 == -67820)
    {
      tls_handshake_send_alert();
      return SSLClose(context);
    }

    else
    {
LABEL_20:
      while (1)
      {
        OSStatus result = SSLHandshakeProceed((uint64_t)context);
        if (result)
        {
          if (result != -9849) {
            break;
          }
        }

        if (*((_DWORD *)context + 18) && *((_DWORD *)context + 19))
        {
          OSStatus result = (*(uint64_t (**)(void))(*((void *)context + 5) + 64LL))(*((void *)context + 6));
          return result;
        }
      }
    }
  }

  else
  {
    if (v2) {
      goto LABEL_20;
    }
    if (*((_DWORD *)context + 27) != 1 || (OSStatus result = SSLHandshakeStart((uint64_t)context)) == 0)
    {
      *((_DWORD *)context + 20) = 1;
      goto LABEL_20;
    }
  }

  return result;
}

OSStatus SSLSetError(SSLContextRef context, OSStatus status)
{
  *((_DWORD *)context + 20) = 6;
  *((_DWORD *)context + 21) = status;
  return 0;
}

OSStatus SSLGetBufferedReadSize(SSLContextRef context, size_t *bufSize)
{
  if (!context) {
    return -50;
  }
  size_t v2 = *((void *)context + 37);
  if (v2) {
    size_t v2 = *((void *)context + 36) - *((void *)context + 38);
  }
  OSStatus result = 0;
  *bufSize = v2;
  return result;
}

BOOL SSLIsSessionNegotiatedWithUnsafeDH(BOOL result)
{
  if (result) {
    return tls_handshake_get_session_warning() == -49;
  }
  return result;
}

uint64_t SSLCiphersuiteGroupToCiphersuiteList(int a1, void *a2)
{
  else {
    unsigned __int16 v2 = a1;
  }
  if (!a2) {
    return 0LL;
  }
  if (v2 > 4u)
  {
    uint64_t v4 = 0LL;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v3 = v2;
    uint64_t v4 = qword_180652E88[v2];
    uint64_t result = (uint64_t)*(&off_189667138 + v3);
  }

  *a2 = v4;
  return result;
}

BOOL SSLCiphersuiteGroupContainsCiphersuite(int a1, int a2)
{
  BOOL result = 0LL;
  if ((unsigned __int16)a1 <= 4u)
  {
    uint64_t v4 = qword_180652E88[(unsigned __int16)a1];
    __int128 v5 = (unsigned __int16 *)*(&off_189667138 + (unsigned __int16)a1);
    uint64_t v6 = v4 - 1;
    do
    {
      int v7 = *v5++;
      BOOL result = v7 == a2;
    }

    while (v7 != a2 && v6-- != 0);
  }

  return result;
}

uint64_t SSLProtocolGetVersionCodepoint(int a1)
{
  uint64_t v1 = 0LL;
  unsigned __int16 v2 = ssl_protocol_version_map;
  while (1)
  {
    int v3 = *v2;
    v2 += 2;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 8) {
      return 0LL;
    }
  }

  return LOWORD(ssl_protocol_version_map[2 * v1 + 1]);
}

uint64_t SSLProtocolFromVersionCodepoint(int a1)
{
  uint64_t v1 = 0LL;
  unsigned __int16 v2 = &word_18065475C;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 4;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 8) {
      return 0LL;
    }
  }

  return ssl_protocol_version_map[2 * v1];
}

uint64_t SSLCiphersuiteMinimumTLSVersion(int a1)
{
  uint64_t v1 = 0LL;
  unsigned __int16 v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37)
    {
      int v4 = 0;
      goto LABEL_6;
    }
  }

  int v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 1];
LABEL_6:
  uint64_t v5 = 0LL;
  uint64_t v6 = &word_18065475C;
  while (1)
  {
    int v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4) {
      break;
    }
    if (++v5 == 8) {
      return 0LL;
    }
  }

  return ssl_protocol_version_map[2 * v5];
}

uint64_t SSLCiphersuiteMaximumTLSVersion(int a1)
{
  uint64_t v1 = 0LL;
  unsigned __int16 v2 = tls_ciphersuite_definitions;
  while (1)
  {
    int v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1) {
      break;
    }
    if (++v1 == 37)
    {
      int v4 = 0;
      goto LABEL_6;
    }
  }

  int v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 2];
LABEL_6:
  uint64_t v5 = 0LL;
  uint64_t v6 = &word_18065475C;
  while (1)
  {
    int v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4) {
      break;
    }
    if (++v5 == 8) {
      return 0LL;
    }
  }

  return ssl_protocol_version_map[2 * v5];
}

OSStatus SSLGetNumberSupportedCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context)
  {
    if (numCiphers)
    {
      OSStatus result = 0;
      *numCiphers = 67LL;
    }
  }

  return result;
}

OSStatus SSLGetSupportedCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context && ciphers && numCiphers)
  {
    if (*numCiphers >= 0x43)
    {
      for (uint64_t i = 0LL; i != 67; ++i)
        ciphers[i] = STKnownCipherSuites[i];
      OSStatus result = 0;
      *numCiphers = 67LL;
    }

    else
    {
      return -9817;
    }
  }

  return result;
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  OSStatus result = -50;
  if (context && ciphers && numCiphers)
  {
    unsigned int v7 = *((_DWORD *)context + 20);
    BOOL v8 = v7 > 6;
    int v9 = (0x10000010100uLL >> (8 * v7));
    if (!v8 && v9 == 0)
    {
      uint64_t v11 = 0LL;
      int v12 = 0;
      do
      {
        uint64_t v13 = 0LL;
        while (STKnownCipherSuites[v13] != ciphers[v11])
        {
          if (++v13 == 67) {
            goto LABEL_15;
          }
        }

        ++v12;
LABEL_15:
        ++v11;
      }

      while (v11 != numCiphers);
      if (v12)
      {
        CC_SHA256_CTX v14 = malloc(2LL * v12);
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = 0LL;
          int v17 = 0;
          do
          {
            uint64_t v18 = 0LL;
            int v19 = ciphers[v16];
            while ((unsigned __int16)STKnownCipherSuites[v18] != v19)
            {
              if (++v18 == 67) {
                goto LABEL_24;
              }
            }

            *((_WORD *)v14 + v17++) = v19;
LABEL_24:
            ++v16;
          }

          while (v16 != numCiphers);
          OSStatus v20 = tls_handshake_set_ciphersuites();
          free(v15);
          return v20;
        }

        else
        {
          return -108;
        }
      }

      else
      {
        return -50;
      }
    }

    else
    {
      return -909;
    }
  }

  return result;
}

OSStatus SSLGetNumberEnabledCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context && numCiphers)
  {
    OSStatus result = tls_handshake_get_ciphersuites();
    if (!result) {
      *numCiphers = 2863311530LL;
    }
  }

  return result;
}

OSStatus SSLGetEnabledCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result = -50;
  if (context)
  {
    uint64_t v5 = ciphers;
    if (ciphers)
    {
      if (numCiphers)
      {
        OSStatus result = tls_handshake_get_ciphersuites();
        if (!result)
        {
          if (*numCiphers >= 0xAAAAAAAA)
          {
            unsigned int v7 = (SSLCipherSuite *)0xAAAAAAAAAAAAAAAALL;
            uint64_t v8 = 2863311530LL;
            do
            {
              SSLCipherSuite v9 = *v7++;
              *v5++ = v9;
              --v8;
            }

            while (v8);
            OSStatus result = 0;
            *numCiphers = 2863311530LL;
          }

          else
          {
            return -9817;
          }
        }
      }
    }
  }

  return result;
}

OSStatus SSLSetSessionTicketsEnabled(SSLContextRef context, Boolean enabled)
{
  if (context) {
    return tls_handshake_set_session_ticket_enabled();
  }
  else {
    return -50;
  }
}

uint64_t sslCreateSecTrust(uint64_t a1, void *a2)
{
  uint64_t peer_trust = tls_helper_create_peer_trust();
  if ((_DWORD)peer_trust) {
    uint64_t v4 = peer_trust;
  }
  else {
    uint64_t v4 = 0LL;
  }
  *a2 = 0LL;
  return v4;
}

uint64_t tls_verify_peer_cert(uint64_t a1)
{
  unsigned int v7 = 0LL;
  unsigned __int16 v2 = *(const void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 168) = 0LL;
    CFRelease(v2);
  }

  sslCreateSecTrust(a1, &v7);
  int v3 = v7;
  if (!v7)
  {
    if (*(_DWORD *)(a1 + 108) == 1 || *(_DWORD *)(a1 + 252) == 1) {
      goto LABEL_12;
    }
    goto LABEL_13;
  }

  if (!*(_BYTE *)(a1 + 187))
  {
LABEL_13:
    *(void *)(a1 + 168) = v3;
    goto LABEL_14;
  }

  int v6 = -1431655766;
  if (!SecTrustEvaluateInternal(v7, &v6))
  {
    if (v6 != 1 && v6 != 4 && !*(_BYTE *)(a1 + 312))
    {
LABEL_12:
      *(void *)(a1 + 168) = v3;
      goto LABEL_14;
    }

    goto LABEL_13;
  }

  *(void *)(a1 + 168) = v3;
LABEL_14:
  tls_handshake_set_peer_trust();
  if (*(_DWORD *)(a1 + 108))
  {
    if (!*(void *)(a1 + 168)) {
      return 0LL;
    }
    uint64_t v4 = (_BYTE *)(a1 + 353);
  }

  else
  {
    uint64_t v4 = (_BYTE *)(a1 + 355);
  }

  if (*v4) {
    return 4294957455LL;
  }
  else {
    return 0LL;
  }
}

uint64_t SOSCCSetSOSDisabledError(CFTypeRef *a1)
{
  if (a1)
  {
    if (staticSOSDisabledError_onceToken != -1) {
      dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_241);
    }
    *a1 = CFRetain((CFTypeRef)staticSOSDisabledError_sosIsDisabledError);
  }

  return 1LL;
}

void __staticSOSDisabledError_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t SOSCCThisDeviceIsInCircle(CFTypeRef *a1)
{
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t result = SOSGetCachedCircleStatus(a1);
    if ((_DWORD)result == -99) {
      return SOSCCThisDeviceIsInCircleNonCached(a1);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabled()
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  secLogObjForScope("sos-compatibility-mode");
  v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1804F4000, v0, OS_LOG_TYPE_DEBUG, "enter SOSCCIsSOSTrustAndSyncingEnabled", buf, 2u);
  }

  secLogObjForScope("sos-compatibility-mode");
  uint64_t v1 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( &dword_1804F4000,  v1,  OS_LOG_TYPE_DEFAULT,  "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode",  buf,  2u);
  }

  CFTypeRef cf = 0LL;
  uint64_t v2 = SOSCCFetchCompatibilityMode(&cf);
  secLogObjForScope("sos-compatibility-mode");
  int v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = @"disabled";
    if ((_DWORD)v2) {
      uint64_t v4 = @"enabled";
    }
    *(_DWORD *)buf = 138412290;
    CFTypeRef v10 = v4;
    _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    secLogObjForScope("SecError");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "sos-compatibility-mode: fetching compatibility mode error: %@",  buf,  0xCu);
    }

    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }

  return v2;
}

uint64_t SOSCCThisDeviceIsInCircleNonCached(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    unsigned int v7 = SecLogAPICreate(0LL, "SOSCCThisDeviceIsInCircleNonCached", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __SOSCCThisDeviceIsInCircleNonCached_block_invoke;
    v18[3] = &__block_descriptor_40_e5_i8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCThisDeviceIsInCircleNonCached_block_invoke((uint64_t)v18);
    uint64_t v15 = SecLogAPICreate( 0LL,  "SOSCCThisDeviceIsInCircleNonCached",  @"SOSCCStatus=%d",  v10,  v11,  v12,  v13,  v14,  v9);
    secLogObjForScope("api_trace");
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }

  return v9;
}

uint64_t __SOSCCThisDeviceIsInCircleNonCached_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (gSecurityd)
  {
    uint64_t v2 = *(uint64_t (**)(void))(gSecurityd + 232);
    if (v2) {
      return v2(*(void *)(a1 + 32));
    }
  }

  xpc_object_t message = securityd_create_message(0x31u, *(CFTypeRef **)(a1 + 32));
  uint64_t v5 = message;
  if (message)
  {
    uint64_t v6 = (void *)securityd_message_with_reply_sync(message, *(void *)(a1 + 32));
    unsigned int v7 = v6;
    if (v6)
    {
      if (!xpc_dictionary_entry_is_type(v6))
      {
        int64_t int64 = 0xFFFFFFFFLL;
        goto LABEL_12;
      }

      int64_t int64 = xpc_dictionary_get_int64(v7, "status");
      if ((int64 & 0x80000000) != 0)
      {
LABEL_12:
        if (securityd_message_no_error((uint64_t)v7, *(CFErrorRef **)(a1 + 32)))
        {
          uint64_t v9 = (void *)MEMORY[0x186E00738](v7);
          SecCFCreateErrorWithFormat( 0LL,  (const __CFString *)sSecXPCErrorDomain,  0LL,  *(CFTypeRef **)(a1 + 32),  v10,  @"Remote error occurred/no info: %s",  v11,  v12,  (char)v9);
          free(v9);
        }
      }
    }

    else
    {
      int64_t int64 = 0xFFFFFFFFLL;
    }

    goto LABEL_15;
  }

  int64_t int64 = 0xFFFFFFFFLL;
LABEL_15:
  secLogObjForScope("circleOps");
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v15 = int64;
    _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEFAULT, "Retrieved non-cached circle value %d", buf, 8u);
  }

  return int64;
}

BOOL xpc_dictionary_entry_is_type(void *a1)
{
  uint64_t v1 = xpc_dictionary_get_value(a1, "status");
  uint64_t v2 = (void *)v1;
  if (v1) {
    BOOL v3 = MEMORY[0x186E0087C](v1) == MEMORY[0x1895F9280];
  }
  else {
    BOOL v3 = 0LL;
  }

  return v3;
}

uint64_t SOSCCFetchCompatibilityMode(CFTypeRef *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  secLogObjForScope("sos-compatibility-mode");
  uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityMode", buf, 2u);
  }

  else {
    uint64_t v4 = simple_BOOL_error_request(0x5Bu, a1);
  }
  uint64_t v10 = v4;
  uint64_t v11 = SecLogAPICreate(0LL, "SOSCCFetchCompatibilityMode", @"return=%d", v5, v6, v7, v8, v9, v4);
  secLogObjForScope("api_trace");
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    int v15 = v11;
    _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11) {
    CFRelease(v11);
  }
  return v10;
}

uint64_t simple_BOOL_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  char v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __simple_BOOL_error_request_block_invoke;
  v4[3] = &unk_1896702C8;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0LL, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SOSCCRequestToJoinCircle(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCRequestToJoinCircle", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x32u, a1);
    }
    uint64_t v16 = v10;
    int v17 = SecLogAPICreate(0LL, "SOSCCRequestToJoinCircle", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCRequestToJoinCircleAfterRestore(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCRequestToJoinCircleAfterRestore", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x33u, a1);
    }
    uint64_t v16 = v10;
    int v17 = SecLogAPICreate(0LL, "SOSCCRequestToJoinCircleAfterRestore", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCAccountHasPublicKey(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCAccountHasPublicKey", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x55u, a1);
    }
    uint64_t v16 = v10;
    int v17 = SecLogAPICreate(0LL, "SOSCCAccountHasPublicKey", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCWaitForInitialSync(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCWaitForInitialSync", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x4Fu, a1);
    }
    uint64_t v16 = v10;
    int v17 = SecLogAPICreate(0LL, "SOSCCWaitForInitialSync", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCAccountSetToNew(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCAccountSetToNew called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0LL, "SOSCCAccountSetToNew", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x4Cu, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCAccountSetToNew", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCResetToOffering(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToOffering called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0LL, "SOSCCResetToOffering", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x34u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCResetToOffering", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCResetToEmpty(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToEmpty called", buf, 2u);
    }

    char v8 = SecLogAPICreate(0LL, "SOSCCResetToEmpty", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x35u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCResetToEmpty", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCRemovePeersFromCircle(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCRemovePeersFromCircle", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCRemovePeersFromCircle_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    uint64_t v11 = __SOSCCRemovePeersFromCircle_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCRemovePeersFromCircle", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t __SOSCCRemovePeersFromCircle_block_invoke(uint64_t a1)
{
  else {
    return info_array_to_BOOL_error_request(0x39u, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t info_array_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  char v10 = 0;
  v5[4] = &v7;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __info_array_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v6[4] = a2;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __info_array_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1896702C8;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCRemoveThisDeviceFromCircle(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCRemoveThisDeviceFromCircle", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x38u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCRemoveThisDeviceFromCircle", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCLoggedIntoAccount(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCLoggedIntoAccount", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x3Au, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCLoggedIntoAccount", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCLoggedOutOfAccount(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCLoggedOutOfAccount", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x3Bu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCLoggedOutOfAccount", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCBailFromCircle_BestEffort(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCBailFromCircle_BestEffort", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCBailFromCircle_BestEffort_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    uint64_t v11 = __SOSCCBailFromCircle_BestEffort_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCBailFromCircle_BestEffort", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t SOSCCCopyPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCCopyPeerPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x43u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t array_of_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  uint64_t v15 = 0LL;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  void v11[2] = __array_of_info_error_request_block_invoke;
  v11[3] = &unk_1896702C8;
  v11[4] = &v12;
  securityd_send_sync_and_do(a1, a2, 0LL, (uint64_t)v11);
  uint64_t v3 = (const void *)v13[3];
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    CFTypeID TypeID = CFArrayGetTypeID();
    uint64_t v6 = v13;
    if (v4 == TypeID) {
      goto LABEL_7;
    }
    uint64_t v7 = v13[3];
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  SOSErrorCreate(1040LL, a2, 0LL, @"Expected array, got: %@", v7);
  uint64_t v6 = v13;
  uint64_t v8 = (const void *)v13[3];
  if (v8)
  {
    v13[3] = 0LL;
    CFRelease(v8);
    uint64_t v6 = v13;
  }

void sub_18059F9B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __array_of_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v13 = v6;
  if (xdict && v6) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CreateArrayOfPeerInfoWithXPCObject( v6,  a3,  v7,  v8,  v9,  v10,  v11,  v12);
  }
  BOOL v14 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v14;
}

uint64_t SOSCCCopyConcurringPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCCopyConcurringPeerPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x44u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyConcurringPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyGenerationPeerInfo(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCCopyGenerationPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __SOSCCCopyGenerationPeerInfo_block_invoke;
    v18[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCCopyGenerationPeerInfo_block_invoke((uint64_t)v18);
    uint64_t v15 = SecLogAPICreate(0LL, "SOSCCCopyGenerationPeerInfo", @"return=%@", v10, v11, v12, v13, v14, v9);
    secLogObjForScope("api_trace");
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v9;
}

uint64_t __SOSCCCopyGenerationPeerInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 392);
    if (v1) {
      return v1(*(void *)(a1 + 32));
    }
  }

  uint64_t v3 = *(CFTypeRef **)(a1 + 32);
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  uint64_t v16 = 0LL;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  void v12[2] = __simple_array_error_request_block_invoke;
  v12[3] = &unk_1896702C8;
  v12[4] = &v13;
  int v4 = securityd_send_sync_and_do(0x45u, v3, 0LL, (uint64_t)v12);
  uint64_t v5 = v14;
  if (v4)
  {
    uint64_t v6 = (const void *)v14[3];
    if (!v6)
    {
      uint64_t v9 = 0LL;
LABEL_9:
      SOSErrorCreate(1040LL, v3, 0LL, @"Expected array, got: %@", v9);
      uint64_t v5 = v14;
      uint64_t v10 = (const void *)v14[3];
      if (v10)
      {
        v14[3] = 0LL;
        CFRelease(v10);
        uint64_t v5 = v14;
      }

      goto LABEL_11;
    }

    CFTypeID v7 = CFGetTypeID(v6);
    CFTypeID TypeID = CFArrayGetTypeID();
    uint64_t v5 = v14;
    if (v7 != TypeID)
    {
      uint64_t v9 = v14[3];
      goto LABEL_9;
    }
  }

void sub_18059FEE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __simple_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  BOOL v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v4;
}

uint64_t SOSCCCopyApplicantPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyApplicantPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x3Fu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyApplicantPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCValidateUserPublic(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCValidateUserPublic", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x41u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCValidateUserPublic", 0LL, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyValidPeerPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x40u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyValidPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyNotValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyNotValidPeerPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x42u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyNotValidPeerPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyRetirementPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyRetirementPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x48u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyRetirementPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyViewUnawarePeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyViewUnawarePeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = array_of_info_error_request(0x49u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyViewUnawarePeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCCopyMyPeerInfo(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCCopyMyPeerInfo", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = peer_info_error_request(0x4Bu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyMyPeerInfo", @"return=%@", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t peer_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  uint64_t v14 = 0LL;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __peer_info_error_request_block_invoke;
  v10[3] = &unk_1896702C8;
  v10[4] = &v11;
  securityd_send_sync_and_do(a1, a2, 0LL, (uint64_t)v10);
  uint64_t v3 = (const void *)v12[3];
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    CFTypeID TypeID = CFDataGetTypeID();
    uint64_t v6 = (const __CFData *)v12[3];
    if (v4 == TypeID)
    {
      uint64_t v7 = SOSPeerInfoCreateFromData(TypeID, a2, v6);
      goto LABEL_6;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  SOSErrorCreate(1040LL, a2, 0LL, @"Expected CFData, got: %@", v6);
  uint64_t v7 = 0LL;
LABEL_6:
  uint64_t v8 = (const void *)v12[3];
  if (v8)
  {
    v12[3] = 0LL;
    CFRelease(v8);
  }

  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_1805A0C28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __peer_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v6;
}

void SOSCCForEachEngineStateAsStringFromArray(const __CFArray *a1, void *a2)
{
  id v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SOSCCForEachEngineStateAsStringFromArray_block_invoke;
    context[3] = &unk_18966F028;
    id v5 = v3;
    v6.length = CFArrayGetCount(a1);
    v6.location = 0LL;
    CFArrayApplyFunction(a1, v6, (CFArrayApplierFunction)apply_block_1_7403, context);
  }
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      id v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStatePeerIDKey);
      if (Value && (uint64_t v8 = Value, v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID())) {
        CFStringAppendFormat(Mutable, 0LL, @"remote %@ ", v8);
      }
      else {
        CFStringAppendFormat(Mutable, 0LL, @"local ");
      }
      uint64_t v10 = (const __CFSet *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateSyncSetKey);
      if (v10 && (v11 = v10, CFTypeID v12 = CFGetTypeID(v10), v12 == CFSetGetTypeID()))
      {
        v31[0] = MEMORY[0x1895F87A8];
        v31[1] = 3221225472LL;
        v31[2] = __SOSCCForEachEngineStateAsStringFromArray_block_invoke_2;
        v31[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
        v31[4] = Mutable;
        CFStringSetPerformWithDescription(v11, (uint64_t)v31);
      }

      else
      {
        CFStringAppendFormat(Mutable, 0LL, @"<Missing view set!>");
      }

      uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateManifestCountKey);
      CFStringAppendFormat(Mutable, 0LL, @" [%@]", v13);
      uint64_t v14 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateManifestHashKey);
      if (v14)
      {
        uint64_t v15 = v14;
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFDataGetTypeID())
        {
          v27[0] = MEMORY[0x1895F87A8];
          v27[1] = 3221225472LL;
          v28 = __SOSCCForEachEngineStateAsStringFromArray_block_invoke_3;
          v29 = &__block_descriptor_40_e21_v16__0____CFString__8l;
          v30 = Mutable;
          uint64_t v17 = v27;
          CFIndex Length = CFDataGetLength(v15);
          int v19 = CFStringCreateMutable(v5, 2 * Length);
          BytePtr = CFDataGetBytePtr(v15);
          CFIndex v21 = CFDataGetLength(v15);
          if (v21 >= 1)
          {
            CFIndex v22 = v21;
            do
            {
              unsigned int v23 = *BytePtr++;
              CFStringAppendFormat(v19, 0LL, @"%02X", v23);
              --v22;
            }

            while (v22);
          }

          v28((uint64_t)v17, (uint64_t)v19);
          CFRelease(v19);
        }
      }

      v24 = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSOSCCEngineStateCoderKey);
      if (v24)
      {
        v25 = v24;
        CFTypeID v26 = CFGetTypeID(v24);
        if (v26 == CFStringGetTypeID()) {
          CFStringAppendFormat(Mutable, 0LL, @" %@", v25);
        }
      }

      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
  }

uint64_t apply_block_1_7403(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke_2(uint64_t a1, const __CFString *a2)
{
}

void __SOSCCForEachEngineStateAsStringFromArray_block_invoke_3(uint64_t a1, uint64_t a2)
{
}

uint64_t SOSCCForEachEngineStateAsString(CFTypeRef *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0 && (SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v9 = SecLogAPICreate(0LL, "SOSCCCopyEngineState", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCCopyEngineState_block_invoke;
    v20[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v20[4] = a1;
    uint64_t v11 = __SOSCCCopyEngineState_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCopyEngineState", @"return=%@", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
    if (v11)
    {
      SOSCCForEachEngineStateAsStringFromArray((const __CFArray *)v11, v3);
      CFRelease((CFTypeRef)v11);
      uint64_t v11 = 1LL;
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    uint64_t v11 = 0LL;
  }

  return v11;
}

uint64_t __SOSCCCopyEngineState_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 440);
    if (v1) {
      return v1(*(void *)(a1 + 32));
    }
  }

  id v3 = *(CFTypeRef **)(a1 + 32);
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  uint64_t v16 = 0LL;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  void v12[2] = __der_array_error_request_block_invoke;
  v12[3] = &unk_1896702C8;
  v12[4] = &v13;
  int v4 = securityd_send_sync_and_do(0x4Au, v3, 0LL, (uint64_t)v12);
  uint64_t v5 = v14;
  if (v4)
  {
    uint64_t v6 = (const void *)v14[3];
    if (!v6)
    {
      uint64_t v9 = 0LL;
LABEL_9:
      SOSErrorCreate(1040LL, v3, 0LL, @"Expected array, got: %@", v9);
      uint64_t v5 = v14;
      uint64_t v10 = (const void *)v14[3];
      if (v10)
      {
        v14[3] = 0LL;
        CFRelease(v10);
        uint64_t v5 = v14;
      }

      goto LABEL_11;
    }

    CFTypeID v7 = CFGetTypeID(v6);
    CFTypeID TypeID = CFArrayGetTypeID();
    uint64_t v5 = v14;
    if (v7 != TypeID)
    {
      uint64_t v9 = v14[3];
      goto LABEL_9;
    }
  }

void sub_1805A1364( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __der_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  size_t length = 0LL;
  data = xpc_dictionary_get_data(xdict, "status", &length);
  der_decode_plist( *MEMORY[0x189604DB0],  *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL,  a3,  (uint64_t)data,  (uint64_t)data + length,  v6,  v7,  v8);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t SOSCCAcceptApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCAcceptApplicants", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCAcceptApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCAcceptApplicants_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCAcceptApplicants", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t __SOSCCAcceptApplicants_block_invoke(uint64_t a1)
{
  else {
    return info_array_to_BOOL_error_request(0x3Du, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCRejectApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCRejectApplicants", @"applicants=%@", v4, v5, v6, v7, v8, a1);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCRejectApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCRejectApplicants_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCRejectApplicants", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t __SOSCCRejectApplicants_block_invoke(uint64_t a1)
{
  else {
    return info_array_to_BOOL_error_request(0x3Eu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCCopyMyPeerWithNewDeviceRecoverySecret(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  secLogObjForScope("devRecovery");
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "Enter SOSCCCopyMyPeerWithNewDeviceRecoverySecret()",  (uint8_t *)&buf,  2u);
  }

  uint64_t v5 = SOSCopyDeviceBackupPublicKey(a1, a2);
  secLogObjForScope("devRecovery");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "SOSCopyDeviceBackupPublicKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5)
  {
    if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
    {
      uint64_t v12 = SecLogAPICreate(0LL, "SOSSetNewPublicBackupKey", 0LL, v7, v8, v9, v10, v11, 0);
      secLogObjForScope("api_trace");
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
      }

      if (v12) {
        CFRelease(v12);
      }
      *(void *)&__int128 buf = MEMORY[0x1895F87A8];
      *((void *)&buf + 1) = 3221225472LL;
      v27 = __SOSSetNewPublicBackupKey_block_invoke;
      v28 = &__block_descriptor_48_e27_____OpaqueSOSPeerInfo__8__0l;
      v29 = v5;
      v30 = a2;
      uint64_t v14 = __SOSSetNewPublicBackupKey_block_invoke((uint64_t)&buf);
      OSStatus v20 = SecLogAPICreate(0LL, "SOSSetNewPublicBackupKey", @"return=%@", v15, v16, v17, v18, v19, v14);
      secLogObjForScope("api_trace");
      CFIndex v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v24 = 138412290;
        v25 = v20;
        _os_log_debug_impl(&dword_1804F4000, v21, OS_LOG_TYPE_DEBUG, "%@", v24, 0xCu);
      }

      if (v20) {
        CFRelease(v20);
      }
      goto LABEL_19;
    }

    SOSCCSetSOSDisabledError(a2);
  }

  uint64_t v14 = 0LL;
LABEL_19:
  secLogObjForScope("devRecovery");
  CFIndex v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v14;
    _os_log_impl(&dword_1804F4000, v22, OS_LOG_TYPE_DEFAULT, "SOSSetNewPublicBackupKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5) {
    CFRelease(v5);
  }
  return v14;
}

uint64_t __SOSSetNewPublicBackupKey_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 376);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
    }
  }

  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  uint64_t v16 = 0LL;
  v11[4] = &v13;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  void v12[2] = __data_to_peer_info_error_request_block_invoke;
  v12[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v12[4] = v3;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  void v11[2] = __data_to_peer_info_error_request_block_invoke_2;
  v11[3] = &unk_1896702C8;
  securityd_send_sync_and_do(0x4Du, v4, (uint64_t)v12, (uint64_t)v11);
  uint64_t v5 = (const void *)v14[3];
  if (!v5)
  {
    uint64_t v8 = 0LL;
    goto LABEL_8;
  }

  CFTypeID v6 = CFGetTypeID(v5);
  CFTypeID TypeID = CFDataGetTypeID();
  uint64_t v8 = (const __CFData *)v14[3];
  if (v6 != TypeID)
  {
LABEL_8:
    SOSErrorCreate(1040LL, v4, 0LL, @"Expected CFData, got: %@", v8);
    uint64_t v9 = 0LL;
    goto LABEL_9;
  }

  uint64_t v9 = SOSPeerInfoCreateFromData(TypeID, v4, v8);
LABEL_9:
  uint64_t v10 = (const void *)v14[3];
  if (v10)
  {
    v14[3] = 0LL;
    CFRelease(v10);
  }

  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_1805A1C24(_Unwind_Exception *a1)
{
}

BOOL __data_to_peer_info_error_request_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "newPublicBackupKey", v3);
  }

  return v3 != 0LL;
}

BOOL __data_to_peer_info_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v6;
}

uint64_t SOSCCRegisterSingleRecoverySecret(uint64_t a1, char a2, CFTypeRef *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v11 = SecLogAPICreate(0LL, "SOSCCRegisterSingleRecoverySecret", 0LL, v6, v7, v8, v9, v10, 0);
    secLogObjForScope("api_trace");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v25 = v11;
      _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __SOSCCRegisterSingleRecoverySecret_block_invoke;
    v22[3] = &__block_descriptor_49_e5_B8__0l;
    char v23 = a2;
    v22[4] = a1;
    v22[5] = a3;
    uint64_t v13 = __SOSCCRegisterSingleRecoverySecret_block_invoke((uint64_t)v22);
    uint64_t v19 = SecLogAPICreate(0LL, "SOSCCRegisterSingleRecoverySecret", @"return=%d", v14, v15, v16, v17, v18, v13);
    secLogObjForScope("api_trace");
    OSStatus v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v25 = v19;
      _os_log_debug_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19) {
      CFRelease(v19);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

  return v13;
}

uint64_t __SOSCCRegisterSingleRecoverySecret_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void))(gSecurityd + 296);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 40));
    }
  }

  char v3 = *(_BYTE *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __keybag_and_BOOL_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_41_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v6[4] = v5;
  char v7 = v3;
  return securityd_send_sync_and_do(0x4Eu, v4, (uint64_t)v6, (uint64_t)&__block_literal_global_263);
}

uint64_t SOSCCRegisterRecoveryPublicKey(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCRegisterRecoveryPublicKey", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFIndex v22 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCRegisterRecoveryPublicKey_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    void v20[5] = a2;
    uint64_t v11 = __SOSCCRegisterRecoveryPublicKey_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCRegisterRecoveryPublicKey", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFIndex v22 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t __SOSCCRegisterRecoveryPublicKey_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 304);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
    }
  }

  uint64_t v4 = *(void *)(a1 + 32);
  char v3 = *(CFTypeRef **)(a1 + 40);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __recovery_and_BOOL_to_BOOL_error_request_block_invoke;
  v5[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v5[4] = v4;
  return securityd_send_sync_and_do(0x57u, v3, (uint64_t)v5, (uint64_t)&__block_literal_global_264);
}

uint64_t SOSCCCopyRecoveryPublicKey(CFTypeRef *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v7 = SecLogAPICreate(0LL, "SOSCCCopyRecoveryPublicKey", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      OSStatus v20 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __SOSCCCopyRecoveryPublicKey_block_invoke;
    v18[3] = &__block_descriptor_40_e16_____CFData__8__0l;
    v18[4] = a1;
    uint64_t v9 = __SOSCCCopyRecoveryPublicKey_block_invoke((uint64_t)v18);
    uint64_t v15 = SecLogAPICreate(0LL, "SOSCCCopyRecoveryPublicKey", @"return=%@", v10, v11, v12, v13, v14, v9);
    secLogObjForScope("api_trace");
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      OSStatus v20 = v15;
      _os_log_debug_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15) {
      CFRelease(v15);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v9;
}

uint64_t __SOSCCCopyRecoveryPublicKey_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void))(gSecurityd + 312);
    if (v1) {
      return v1(*(void *)(a1 + 32));
    }
  }

  uint64_t v3 = *(CFTypeRef **)(a1 + 32);
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  uint64_t v12 = 0LL;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __data_to_error_request_block_invoke;
  v8[3] = &unk_1896702C8;
  v8[4] = &v9;
  securityd_send_sync_and_do(0x58u, v3, 0LL, (uint64_t)v8);
  uint64_t v4 = (const void *)v10[3];
  if (v4)
  {
    CFTypeID v5 = CFGetTypeID(v4);
    CFTypeID TypeID = CFDataGetTypeID();
    uint64_t v7 = v10[3];
    if (v5 == TypeID) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  SOSErrorCreate(1040LL, v3, 0LL, @"Expected CFData, got: %@", v7);
  uint64_t v7 = 0LL;
LABEL_9:
  _Block_object_dispose(&v9, 8);
  return v7;
}

void sub_1805A25D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __data_to_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  CFTypeID v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v6;
}

uint64_t SOSCCRegisterUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a1;
      _os_log_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_DEFAULT,  "SOSCCRegisterUserCredentials - calling SOSCCSetUserCredentials for %@\n",  (uint8_t *)&v8,  0xCu);
    }

    return SOSCCSetUserCredentials(a1, a2, a3);
  }

  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

uint64_t SOSCCSetUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v25 = a1;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentials for %@\n", buf, 0xCu);
    }

    uint64_t v12 = SecLogAPICreate(0LL, "SOSCCSetUserCredentials", @"user_label=%@", v7, v8, v9, v10, v11, (char)a1);
    secLogObjForScope("api_trace");
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v25 = v12;
      _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12) {
      CFRelease(v12);
    }
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    v23[2] = __SOSCCSetUserCredentials_block_invoke;
    v23[3] = &__block_descriptor_56_e5_B8__0l;
    v23[4] = a1;
    v23[5] = a2;
    v23[6] = a3;
    uint64_t v14 = __SOSCCSetUserCredentials_block_invoke(v23);
    OSStatus v20 = SecLogAPICreate(0LL, "SOSCCSetUserCredentials", @"return=%d", v15, v16, v17, v18, v19, v14);
    secLogObjForScope("api_trace");
    uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v25 = v20;
      _os_log_debug_impl(&dword_1804F4000, v21, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v20) {
      CFRelease(v20);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

  return v14;
}

uint64_t __SOSCCSetUserCredentials_block_invoke(void *a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void))(gSecurityd + 200);
    if (v1) {
      return v1(a1[4], a1[5], a1[6]);
    }
  }

  uint64_t v3 = (CFTypeRef *)a1[6];
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  char v11 = 0;
  v5[4] = &v8;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __label_and_password_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  __int128 v7 = *((_OWORD *)a1 + 2);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __label_and_password_to_BOOL_error_request_block_invoke_3;
  v5[3] = &unk_1896702C8;
  securityd_send_sync_and_do(0x2Du, v3, (uint64_t)v6, (uint64_t)v5);
  uint64_t v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t SOSCCSetUserCredentialsAndDSID(__CFString *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v27 = a1;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentialsAndDSID for %@\n", buf, 0xCu);
    }

    uint64_t v14 = SecLogAPICreate( 0LL,  "SOSCCSetUserCredentialsAndDSID",  @"user_label=%@",  v9,  v10,  v11,  v12,  v13,  (char)a1);
    secLogObjForScope("api_trace");
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v27 = v14;
      _os_log_debug_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14) {
      CFRelease(v14);
    }
    v25[0] = MEMORY[0x1895F87A8];
    v25[1] = 3221225472LL;
    v25[2] = __SOSCCSetUserCredentialsAndDSID_block_invoke;
    v25[3] = &__block_descriptor_64_e5_B8__0l;
    v25[4] = a1;
    v25[5] = a2;
    v25[6] = a3;
    v25[7] = a4;
    uint64_t v16 = __SOSCCSetUserCredentialsAndDSID_block_invoke((uint64_t)v25);
    CFIndex v22 = SecLogAPICreate(0LL, "SOSCCSetUserCredentialsAndDSID", @"return=%d", v17, v18, v19, v20, v21, v16);
    secLogObjForScope("api_trace");
    uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v27 = v22;
      _os_log_debug_impl(&dword_1804F4000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v22) {
      CFRelease(v22);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0LL;
  }

  return v16;
}

uint64_t __SOSCCSetUserCredentialsAndDSID_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void, void))(gSecurityd + 208);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
    }
  }

  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    SOSErrorCreate(1045LL, *(CFTypeRef **)(a1 + 56), 0LL, @"user_label is nil");
    return 0LL;
  }

  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4)
  {
    SOSErrorCreate(1045LL, *(CFTypeRef **)(a1 + 56), 0LL, @"user_password is nil");
    return 0LL;
  }

  if (*(void *)(a1 + 48)) {
    CFTypeID v5 = *(const __CFString **)(a1 + 48);
  }
  else {
    CFTypeID v5 = &stru_1896794C8;
  }
  return label_and_password_and_dsid_to_BOOL_error_request(0x2Eu, v3, v4, (uint64_t)v5, *(CFTypeRef **)(a1 + 56));
}

uint64_t label_and_password_and_dsid_to_BOOL_error_request( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 0;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke;
  v8[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v8[4] = a2;
  void v8[5] = a4;
  v8[6] = a3;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke_4;
  v7[3] = &unk_1896702C8;
  v7[4] = &v9;
  securityd_send_sync_and_do(a1, a5, (uint64_t)v8, (uint64_t)v7);
  uint64_t v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t SOSCCTryUserCredentialsAndDSID(uint64_t a1, uint64_t a2, const __CFString *a3, CFTypeRef *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a4);
    return 0LL;
  }

  secLogObjForScope("sosops");
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 138412290;
    uint64_t v12 = a1;
    _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "SOSCCTryUserCredentialsAndDSID!! %@\n",  (uint8_t *)&v11,  0xCu);
  }

  if (!a1)
  {
    SOSErrorCreate(1045LL, a4, 0LL, @"user_label is nil");
    return 0LL;
  }

  if (!a2)
  {
    SOSErrorCreate(1045LL, a4, 0LL, @"user_password is nil");
    return 0LL;
  }

  if (a3) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = &stru_1896794C8;
  }
  return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, (uint64_t)v9, a4);
}

uint64_t SOSCCTryUserCredentialsAndDSID_internal(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke;
    v17[3] = &__block_descriptor_64_e5_B8__0l;
    v17[4] = a1;
    v17[5] = a2;
    v17[6] = a3;
    v17[7] = a4;
    uint64_t v8 = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke((uint64_t)v17);
    uint64_t v14 = SecLogAPICreate( 0LL,  "SOSCCTryUserCredentialsAndDSID_internal",  @"return=%d",  v9,  v10,  v11,  v12,  v13,  v8);
    secLogObjForScope("api_trace");
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v19 = v14;
      _os_log_debug_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14) {
      CFRelease(v14);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0LL;
  }

  return v8;
}

uint64_t SOSCCTryUserCredentials(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0) {
    return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, 0LL, a3);
  }
  SOSCCSetSOSDisabledError(a3);
  return 0LL;
}

uint64_t SOSCCCanAuthenticate(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    __int128 v7 = SecLogAPICreate(0LL, "SOSCCCanAuthenticate", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x2Fu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCCanAuthenticate", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCPurgeUserCredentials(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    __int128 v7 = SecLogAPICreate(0LL, "SOSCCPurgeUserCredentials", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_BOOL_error_request(0x30u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCPurgeUserCredentials", @"return=%d", v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t SOSCCGetLastDepartureReason(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    __int128 v7 = SecLogAPICreate(0LL, "SOSCCGetLastDepartureReason", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_int_error_request(0x46u, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCGetLastDepartureReason", 0LL, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

uint64_t simple_int_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  int v8 = 0;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __simple_int_error_request_block_invoke;
  v4[3] = &unk_1896702C8;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0LL, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __simple_int_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "status");
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0;
}

uint64_t SOSCCSetLastDepartureReason(int a1, CFTypeRef *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v9 = SecLogAPICreate(0LL, "SOSCCSetLastDepartureReason", 0LL, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v23 = v9;
      _os_log_debug_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9) {
      CFRelease(v9);
    }
    v20[0] = MEMORY[0x1895F87A8];
    v20[1] = 3221225472LL;
    v20[2] = __SOSCCSetLastDepartureReason_block_invoke;
    v20[3] = &__block_descriptor_44_e5_B8__0l;
    int v21 = a1;
    v20[4] = a2;
    uint64_t v11 = __SOSCCSetLastDepartureReason_block_invoke((uint64_t)v20);
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCSetLastDepartureReason", 0LL, v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v23 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v11;
}

uint64_t __SOSCCSetLastDepartureReason_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 472);
    if (v1) {
      return v1(*(unsigned int *)(a1 + 40), *(void *)(a1 + 32));
    }
  }

  uint64_t v3 = *(CFTypeRef **)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __SOSCCSetLastDepartureReason_block_invoke_2;
  v4[3] = &__block_descriptor_36_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  int v5 = *(_DWORD *)(a1 + 40);
  return securityd_send_sync_and_do(0x47u, v3, (uint64_t)v4, (uint64_t)&__block_literal_global_7471);
}

uint64_t __SOSCCSetLastDepartureReason_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  return 1LL;
}

BOOL __SOSCCSetLastDepartureReason_block_invoke_3(int a1, xpc_object_t xdict)
{
  return xpc_dictionary_get_BOOL(xdict, "status");
}

uint64_t SOSCCProcessEnsurePeerRegistration(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("updates");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCProcessEnsurePeerRegistration", buf, 2u);
    }

    uint64_t v8 = SecLogAPICreate(0LL, "SOSCCProcessEnsurePeerRegistration", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x22u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCProcessEnsurePeerRegistration", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCProcessSyncWithPeers(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v11 = SecLogAPICreate(0LL, "SOSCCProcessSyncWithPeers", 0LL, v6, v7, v8, v9, v10, 0);
    secLogObjForScope("api_trace");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v11;
      _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
    v22[0] = MEMORY[0x1895F87A8];
    v22[1] = 3221225472LL;
    v22[2] = __SOSCCProcessSyncWithPeers_block_invoke;
    v22[3] = &__block_descriptor_56_e15_____CFSet__8__0l;
    v22[4] = a1;
    v22[5] = a2;
    void v22[6] = a3;
    uint64_t v13 = __SOSCCProcessSyncWithPeers_block_invoke(v22);
    uint64_t v19 = SecLogAPICreate(0LL, "SOSCCProcessSyncWithPeers", 0LL, v14, v15, v16, v17, v18, v13);
    secLogObjForScope("api_trace");
    uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v19;
      _os_log_debug_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19) {
      CFRelease(v19);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

  return v13;
}

uint64_t __SOSCCProcessSyncWithPeers_block_invoke(void *a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void))(gSecurityd + 480);
    if (v1) {
      return v1(a1[4], a1[5], a1[6]);
    }
  }

  uint64_t v3 = (CFTypeRef *)a1[6];
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000LL;
  uint64_t v14 = 0LL;
  v8[4] = &v11;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = __cfset_cfset_to_cfset_error_request_block_invoke;
  v9[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  __int128 v10 = *((_OWORD *)a1 + 2);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __cfset_cfset_to_cfset_error_request_block_invoke_2;
  v8[3] = &unk_1896702C8;
  char v4 = securityd_send_sync_and_do(0x6Au, v3, (uint64_t)v9, (uint64_t)v8);
  uint64_t v5 = v12;
  if ((v4 & 1) == 0)
  {
    uint64_t v6 = (const void *)v12[3];
    if (v6)
    {
      v12[3] = 0LL;
      CFRelease(v6);
      uint64_t v5 = v12;
    }
  }

  uint64_t v7 = v5[3];
  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_1805A4188(_Unwind_Exception *a1)
{
}

size_t __cfset_cfset_to_cfset_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  if (SecXPCDictionarySetPListWithRepair( v5,  "cfset",  *(const __CFString **)(a1 + 32),  a3,  v6,  v7,  v8,  v9)) {
    size_t v14 = SecXPCDictionarySetPListWithRepair(v5, "cfset2", *(const __CFString **)(a1 + 40), a3, v10, v11, v12, v13);
  }
  else {
    size_t v14 = 0LL;
  }

  return v14;
}

BOOL __cfset_cfset_to_cfset_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a2, "status", a3);
  uint64_t v6 = v5;
  if (v5 && (CFTypeID v7 = CFGetTypeID(v5), v7 == CFSetGetTypeID()))
  {
    CFRetain(v6);
    uint64_t v8 = v6;
  }

  else
  {
    if (a3) {
      SecError(-50, a3, @"object %@ is not a set", v6);
    }
    if (!v6)
    {
      uint64_t v8 = 0LL;
      goto LABEL_12;
    }

    CFTypeID v9 = CFGetTypeID(v6);
    CFStringRef v10 = CFCopyTypeIDDescription(v9);
    SecError(-50, a3, @"object for key %s not set but %@", "status", v10);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v8 = 0LL;
  }

  CFRelease(v6);
LABEL_12:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v8;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t SOSCCProcessSyncWithAllPeers(CFTypeRef *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeID v7 = SecLogAPICreate(0LL, "SOSCCProcessSyncWithAllPeers", 0LL, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      int v21 = v7;
      _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7) {
      CFRelease(v7);
    }
    else {
      uint64_t v10 = simple_int_error_request(0x1Cu, a1);
    }
    uint64_t v16 = v10;
    uint64_t v17 = SecLogAPICreate(0LL, "SOSCCProcessSyncWithAllPeers", 0LL, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      int v21 = v17;
      _os_log_debug_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v16;
}

CFStringRef SOSCCGetStatusDescription(int a1)
{
  else {
    return off_18966F450[a1 + 1];
  }
}

CFStringRef SOSCCGetViewResultDescription(unsigned int a1)
{
  if (a1 > 4) {
    return @"Unknown View Status";
  }
  else {
    return off_18966F478[a1];
  }
}

uint64_t SOSCCView(const void *a1, int a2, CFTypeRef *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

  int v6 = SOSVisibleKeychainNotAllowed();
  if (a1 && a2 == 1 && v6)
  {
    V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
    if (CFSetContainsValue(V0SubviewSet, a1))
    {
      secLogObjForScope("views");
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "Cannot enable visible keychain views due to profile restrictions",  buf,  2u);
      }

      return 0LL;
    }
  }

  else if (a2 == 3 && SOSGetCachedCircleBitmask() < 0)
  {
    uint64_t v25 = SOSCachedViewBitmask();
    if (!v25) {
      return 2LL;
    }
    SetFromBitmask = SOSViewCreateSetFromBitmask(v25);
    if (!SetFromBitmask) {
      return 2LL;
    }
    uint64_t v22 = (__CFString *)SetFromBitmask;
    if (CFSetContainsValue(SetFromBitmask, a1)) {
      uint64_t v14 = 1LL;
    }
    else {
      uint64_t v14 = 2LL;
    }
    goto LABEL_20;
  }

  uint64_t v15 = SecLogAPICreate(0LL, "SOSCCView", 0LL, v7, v8, v9, v10, v11, 0);
  secLogObjForScope("api_trace");
  uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    v30 = v15;
    _os_log_debug_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v15) {
    CFRelease(v15);
  }
  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 3221225472LL;
  void v27[2] = __SOSCCView_block_invoke;
  v27[3] = &__block_descriptor_52_e5_i8__0l;
  int v28 = a2;
  v27[4] = a1;
  v27[5] = a3;
  uint64_t v14 = __SOSCCView_block_invoke((uint64_t)v27);
  uint64_t v22 = SecLogAPICreate(0LL, "SOSCCView", @"SOSViewResultCode=%d", v17, v18, v19, v20, v21, v14);
  secLogObjForScope("api_trace");
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    v30 = v22;
    _os_log_debug_impl(&dword_1804F4000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v22) {
LABEL_20:
  }
    CFRelease(v22);
  return v14;
}

uint64_t __SOSCCView_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void))(gSecurityd + 280);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(unsigned int *)(a1 + 48), *(void *)(a1 + 40));
    }
  }

  uint64_t v3 = *(int *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  uint64_t v13 = 0LL;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = __name_action_to_code_request_block_invoke;
  v9[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  void v9[4] = v5;
  v9[5] = v3;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = __name_action_to_code_request_block_invoke_3;
  v7[3] = &unk_18966F3D0;
  v7[4] = &v10;
  __int16 v8 = 0;
  securityd_send_sync_and_do(0x36u, v4, (uint64_t)v9, (uint64_t)v7);
  uint64_t v6 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __name_action_to_code_request_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = MEMORY[0x1895F87A8];
  uint64_t v5 = *(const __CFString **)(a1 + 32);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __name_action_to_code_request_block_invoke_2;
  v8[3] = &unk_18966F3A8;
  id v9 = v3;
  id v6 = v3;
  v10[0] = v4;
  v10[1] = 0x40000000LL;
  v10[2] = __CFStringPerformWithCString_block_invoke;
  v10[3] = &unk_189676790;
  v10[4] = v8;
  CFStringPerformWithCStringAndLength(v5, (uint64_t)v10);
  xpc_dictionary_set_int64(v6, "viewactioncode", *(void *)(a1 + 40));

  return 1LL;
}

BOOL __name_action_to_code_request_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3 && xpc_dictionary_entry_is_type(v3)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_int64(v4, "status");
  }
  BOOL v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != *(unsigned __int16 *)(a1 + 40);

  return v5;
}

void __name_action_to_code_request_block_invoke_2(uint64_t a1, char *string)
{
}

uint64_t SOSCCViewSet(const __CFSet *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  int v4 = SOSVisibleKeychainNotAllowed();
  if (a1 && v4 && CFSetGetCount(a1) && SOSViewSetIntersectsV0(a1))
  {
    secLogObjForScope("views");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "Cannot enable visible keychain views due to profile restrictions",  buf,  2u);
    }

    return 0LL;
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v24 = buf;
  uint64_t v25 = 0x2020000000LL;
  char v26 = 0;
  uint64_t v12 = SecLogAPICreate(0LL, "SOSCCViewSet", 0LL, v5, v6, v7, v8, v9, 0);
  secLogObjForScope("api_trace");
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v27 = 138412290;
    int v28 = v12;
    _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v12) {
    CFRelease(v12);
  }
  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 3221225472LL;
  v22[2] = __SOSCCViewSet_block_invoke;
  v22[3] = &unk_18966F190;
  void v22[6] = a2;
  void v22[7] = 0LL;
  v22[4] = buf;
  v22[5] = a1;
  uint64_t v11 = __SOSCCViewSet_block_invoke(v22);
  uint64_t v19 = SecLogAPICreate(0LL, "SOSCCViewSet", @"return=%d", v14, v15, v16, v17, v18, v11);
  secLogObjForScope("api_trace");
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v27 = 138412290;
    int v28 = v19;
    _os_log_debug_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v19) {
    CFRelease(v19);
  }
  _Block_object_dispose(buf, 8);
  return v11;
}

void sub_1805A4C28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __SOSCCViewSet_block_invoke(void *a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 288);
    if (v1) {
      return v1(a1[5], a1[6]);
    }
  }

  id v3 = (CFTypeRef *)a1[7];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __SOSCCViewSet_block_invoke_2;
  v5[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  __int128 v6 = *(_OWORD *)(a1 + 5);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __SOSCCViewSet_block_invoke_3;
  v4[3] = &unk_1896702C8;
  void v4[4] = a1[4];
  return securityd_send_sync_and_do(0x37u, v3, (uint64_t)v5, (uint64_t)v4);
}

BOOL __SOSCCViewSet_block_invoke_2(uint64_t a1, void *a2, CFTypeRef *a3)
{
  id v5 = a2;
  uint64_t v12 = CreateXPCObjectWithCFSetRef(*(const __CFSet **)(a1 + 32), a3, v6, v7, v8, v9, v10, v11);
  uint64_t v19 = CreateXPCObjectWithCFSetRef(*(const __CFSet **)(a1 + 40), a3, v13, v14, v15, v16, v17, v18);
  if (v12) {
    xpc_dictionary_set_value(v5, "enabledViews", (xpc_object_t)v12);
  }
  if (v19) {
    xpc_dictionary_set_value(v5, "disabledViews", (xpc_object_t)v19);
  }

  return (v12 | v19) != 0;
}

uint64_t __SOSCCViewSet_block_invoke_3(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t SOSCCIsIcloudKeychainSyncing()
{
  v1[4] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"WiFi";
    v1[1] = @"Passwords";
    v1[2] = @"CreditCards";
    v1[3] = @"OtherSyncable";
    return sosIsViewSetSyncing(4LL, v1);
  }

  return result;
}

BOOL sosIsViewSetSyncing(uint64_t a1, const void **a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = a2;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFStringAppend(Mutable, @"|");
  uint64_t v5 = 0LL;
  do
  {
    CFStringAppend(Mutable, (CFStringRef)v2[v5]);
    CFStringAppend(Mutable, @"|");
    ++v5;
  }

  while (a1 != v5);
  int v6 = SOSCCThisDeviceIsInCircle(&cf);
  BOOL v7 = v6 == 0;
  if (v6)
  {
    int v8 = v6;
    secLogObjForScope("viewCheck");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v10 = off_18966F4A0[v8 + 1];
      }
      *(_DWORD *)__int128 buf = 138412802;
      v30 = Mutable;
      __int16 v31 = 2112;
      v32 = v10;
      __int16 v33 = 2112;
      CFTypeRef v34 = cf;
      uint64_t v19 = "Checking view / circle status for %@:  SOSCCStatus: (%@)  Error: (%@)";
      uint64_t v20 = v9;
      uint32_t v21 = 32;
      goto LABEL_25;
    }
  }

  else
  {
    if (SOSGetCachedCircleBitmask() < 0)
    {
      uint64_t v24 = SOSCachedViewBitmask();
      if (v24)
      {
        CFMutableSetRef SetFromBitmask = SOSViewCreateSetFromBitmask(v24);
        if (SetFromBitmask)
        {
          char v26 = SetFromBitmask;
          LOBYTE(v11) = 1;
          do
          {
            v27 = *v2++;
            BOOL v11 = (CFSetContainsValue(v26, v27) != 0) & v11;
            --a1;
          }

          while (a1);
          CFTypeRef v22 = v26;
          goto LABEL_29;
        }
      }
    }

    uint64_t v12 = 0LL;
    char v13 = 1;
    do
    {
      while (1)
      {
        unsigned int v14 = SOSCCView(v2[v12], 3, &cf);
        if (v14 == 1) {
          break;
        }
        unsigned int v15 = v14;
        secLogObjForScope("viewCheck");
        uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = @"Unknown View Status";
          if (v15 <= 4) {
            uint64_t v17 = off_18966F4C8[v15];
          }
          uint64_t v18 = (__CFString *)v2[v12];
          *(_DWORD *)__int128 buf = 138413058;
          v30 = v18;
          __int16 v31 = 2112;
          v32 = @"InCircle";
          __int16 v33 = 2112;
          CFTypeRef v34 = v17;
          __int16 v35 = 2112;
          CFTypeRef v36 = cf;
          _os_log_impl( &dword_1804F4000,  v16,  OS_LOG_TYPE_DEFAULT,  "Checking view / circle status for %@:  SOSCCStatus: (%@) SOSViewResultCode(%@) Error: (%@)",  buf,  0x2Au);
        }

        char v13 = 0;
        BOOL v11 = 0LL;
        if (++v12 == a1) {
          goto LABEL_27;
        }
      }

      ++v12;
    }

    while (a1 != v12);
    if ((v13 & 1) == 0)
    {
      BOOL v11 = 0LL;
      goto LABEL_27;
    }

    secLogObjForScope("viewCheck");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v30 = Mutable;
      uint64_t v19 = "Checking view / circle status for %@:  ENABLED";
      uint64_t v20 = v9;
      uint32_t v21 = 12;
LABEL_25:
      _os_log_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    }
  }

  BOOL v11 = v7;
LABEL_27:
  CFTypeRef v22 = cf;
  if (!cf) {
    goto LABEL_30;
  }
  CFTypeRef cf = 0LL;
LABEL_29:
  CFRelease(v22);
LABEL_30:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v11;
}

uint64_t SOSCCIsSafariSyncing()
{
  v1[2] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"Passwords";
    v1[1] = @"CreditCards";
    return sosIsViewSetSyncing(2LL, v1);
  }

  return result;
}

uint64_t SOSCCIsAppleTVSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"AppleTV";
    return sosIsViewSetSyncing(1LL, v1);
  }

  return result;
}

uint64_t SOSCCIsHomeKitSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"HomeKit";
    return sosIsViewSetSyncing(1LL, v1);
  }

  return result;
}

uint64_t SOSCCIsWiFiSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"WiFi";
    return sosIsViewSetSyncing(1LL, v1);
  }

  return result;
}

uint64_t SOSCCIsContinuityUnlockSyncing()
{
  v1[1] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = @"ContinuityUnlock";
    return sosIsViewSetSyncing(1LL, v1);
  }

  return result;
}

uint64_t SOSCCCopyApplication(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyApplication applicant", buf, 2u);
    }

    int v8 = SecLogAPICreate(0LL, "SOSCCCopyApplication", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = peer_info_error_request(0x51u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCCopyApplication", @"return=%@", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCCleanupKVSKeys(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("cleanup-keys");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCleanupKVSKeys", buf, 2u);
    }

    int v8 = SecLogAPICreate(0LL, "SOSCCCleanupKVSKeys", 0LL, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v22 = v8;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8) {
      CFRelease(v8);
    }
    else {
      uint64_t v11 = simple_BOOL_error_request(0x54u, a1);
    }
    uint64_t v17 = v11;
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCCleanupKVSKeys", @"return=%d", v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v22 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

  return v17;
}

uint64_t SOSCCCopyCircleJoiningBlob(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyCircleJoiningBlob approver", buf, 2u);
    }

    uint64_t v10 = SecLogAPICreate(0LL, "SOSCCCopyCircleJoiningBlob", 0LL, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v30 = v10;
      _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v28[0] = MEMORY[0x1895F87A8];
    v28[1] = 3221225472LL;
    v28[2] = __SOSCCCopyCircleJoiningBlob_block_invoke;
    v28[3] = &__block_descriptor_48_e16_____CFData__8__0l;
    v28[4] = a1;
    v28[5] = a2;
    uint64_t v19 = __SOSCCCopyCircleJoiningBlob_block_invoke((uint64_t)v28, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v25 = SecLogAPICreate(0LL, "SOSCCCopyCircleJoiningBlob", @"return=%@", v20, v21, v22, v23, v24, v19);
    secLogObjForScope("api_trace");
    char v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v30 = v25;
      _os_log_debug_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v25) {
      CFRelease(v25);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v19;
}

uint64_t __SOSCCCopyCircleJoiningBlob_block_invoke( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (gSecurityd)
  {
    uint64_t v9 = *(uint64_t (**)(void, void))(gSecurityd + 568);
    if (v9) {
      return v9(*(void *)(a1 + 32), *(void *)(a1 + 40));
    }
  }

  uint64_t v11 = SOSPeerInfoCopyEncodedData(*(void *)(a1 + 32), a2, *(CFTypeRef **)(a1 + 40), a4, a5, a6, a7, a8);
  int v12 = *(CFTypeRef **)(a1 + 40);
  uint64_t v22 = 0LL;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000LL;
  uint64_t v25 = 0LL;
  uint64_t v18 = SecLogAPICreate(0LL, "cfdata_error_request_returns_cfdata", 0LL, v13, v14, v15, v16, v17, 0);
  secLogObjForScope("api_trace");
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v18;
    _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
  }

  if (v18) {
    CFRelease(v18);
  }
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + 1) = 3221225472LL;
  v27 = __cfdata_error_request_returns_cfdata_block_invoke;
  int v28 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  uint64_t v29 = v11;
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  v21[2] = __cfdata_error_request_returns_cfdata_block_invoke_2;
  v21[3] = &unk_1896702C8;
  v21[4] = &v22;
  securityd_send_sync_and_do(0x52u, v12, (uint64_t)&buf, (uint64_t)v21);
  uint64_t v20 = v23[3];
  _Block_object_dispose(&v22, 8);
  if (v11) {
    CFRelease(v11);
  }
  return v20;
}

void sub_1805A5B84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "data", v3);
  }

  return v3 != 0LL;
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  uint64_t v6 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v7 = (void *)v6;
  if (xdict && v6)
  {
    uint64_t v8 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    uint64_t v9 = v8;
    if (v8)
    {
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFDataGetTypeID())
      {
        CFRetain(v9);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v9;
LABEL_9:
        CFRelease(v9);
        goto LABEL_10;
      }
    }

    if (a3) {
      SecError(-50, a3, @"object %@ is not a data", v9);
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    if (v9) {
      goto LABEL_9;
    }
  }

uint64_t SOSCCCopyInitialSyncData(int a1, CFTypeRef *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleJoin");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyInitialSyncData approver", buf, 2u);
    }

    CFTypeID v10 = SecLogAPICreate(0LL, "SOSCCCopyInitialSyncData", 0LL, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v10;
      _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v21[0] = MEMORY[0x1895F87A8];
    v21[1] = 3221225472LL;
    v21[2] = __SOSCCCopyInitialSyncData_block_invoke;
    v21[3] = &__block_descriptor_44_e16_____CFData__8__0l;
    int v22 = a1;
    v21[4] = a2;
    uint64_t v12 = __SOSCCCopyInitialSyncData_block_invoke((uint64_t)v21);
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCCopyInitialSyncData", @"return=%@", v13, v14, v15, v16, v17, v12);
    secLogObjForScope("api_trace");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v24 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v12;
}

uint64_t __SOSCCCopyInitialSyncData_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 576);
    if (v1) {
      return v1(*(unsigned int *)(a1 + 40), *(void *)(a1 + 32));
    }
  }

  int v3 = *(_DWORD *)(a1 + 40);
  uint64_t v4 = *(CFTypeRef **)(a1 + 32);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  uint64_t v15 = 0LL;
  void v9[4] = &v12;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __flags_to_data_error_request_block_invoke;
  v10[3] = &__block_descriptor_36_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  int v11 = v3;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  v9[2] = __flags_to_data_error_request_block_invoke_2;
  v9[3] = &unk_1896702C8;
  securityd_send_sync_and_do(0x59u, v4, (uint64_t)v10, (uint64_t)v9);
  uint64_t v5 = (const void *)v13[3];
  if (v5)
  {
    CFTypeID v6 = CFGetTypeID(v5);
    CFTypeID TypeID = CFDataGetTypeID();
    uint64_t v8 = v13[3];
    if (v6 == TypeID) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  SOSErrorCreate(1040LL, v4, 0LL, @"Expected CFData, got: %@", v8);
  uint64_t v8 = 0LL;
LABEL_9:
  _Block_object_dispose(&v12, 8);
  return v8;
}

void sub_1805A6038(_Unwind_Exception *a1)
{
}

uint64_t __flags_to_data_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  return 1LL;
}

BOOL __flags_to_data_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4 = xpc_dictionary_get_value(xdict, "status");
  uint64_t v5 = (void *)v4;
  if (xdict && v4) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  }
  BOOL v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v6;
}

uint64_t SOSCCJoinWithCircleJoiningBlob(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "enter SOSCCJoinWithCircleJoiningBlob applicant", buf, 2u);
    }

    uint64_t v12 = SecLogAPICreate(0LL, "SOSCCJoinWithCircleJoiningBlob", 0LL, v7, v8, v9, v10, v11, 0);
    secLogObjForScope("api_trace");
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int16 v33 = v12;
      _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12) {
      CFRelease(v12);
    }
    v30[0] = MEMORY[0x1895F87A8];
    v30[1] = 3221225472LL;
    v30[2] = __SOSCCJoinWithCircleJoiningBlob_block_invoke;
    v30[3] = &__block_descriptor_52_e5_B8__0l;
    int v31 = a2;
    v30[4] = a1;
    v30[5] = a3;
    uint64_t v21 = __SOSCCJoinWithCircleJoiningBlob_block_invoke((uint64_t)v30, v14, v15, v16, v17, v18, v19, v20);
    v27 = SecLogAPICreate(0LL, "SOSCCJoinWithCircleJoiningBlob", @"return=%d", v22, v23, v24, v25, v26, v21);
    secLogObjForScope("api_trace");
    int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int16 v33 = v27;
      _os_log_debug_impl(&dword_1804F4000, v28, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v27) {
      CFRelease(v27);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0LL;
  }

  return v21;
}

uint64_t __SOSCCJoinWithCircleJoiningBlob_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void, void), uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (gSecurityd)
  {
    a4 = *(uint64_t (**)(void, void, void))(gSecurityd + 584);
    if (a4) {
      return a4(*(void *)(a1 + 32), *(unsigned int *)(a1 + 48), *(void *)(a1 + 40));
    }
  }

  int v9 = *(_DWORD *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v10 = *(CFTypeRef **)(a1 + 40);
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  char v19 = 0;
  uint64_t v12 = SecLogAPICreate(0LL, "cfdata_and_int_error_request_returns_BOOL", 0LL, (uint64_t)a4, a5, a6, a7, a8, 0);
  secLogObjForScope("api_trace");
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v12;
    _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
  }

  if (v12) {
    CFRelease(v12);
  }
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + 1) = 3221225472LL;
  uint64_t v21 = __cfdata_and_int_error_request_returns_BOOL_block_invoke;
  uint64_t v22 = &__block_descriptor_44_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  uint64_t v23 = v11;
  int v24 = v9;
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = __cfdata_and_int_error_request_returns_BOOL_block_invoke_2;
  v15[3] = &unk_1896702C8;
  v15[4] = &v16;
  securityd_send_sync_and_do(0x53u, v10, (uint64_t)&buf, (uint64_t)v15);
  uint64_t v14 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  return v14;
}

void sub_1805A64E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t SOSCCPeersHaveViewsEnabled(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("view-enabled");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCPeersHaveViewsEnabled", buf, 2u);
    }

    uint64_t v10 = SecLogAPICreate(0LL, "SOSCCPeersHaveViewsEnabled", 0LL, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v23 = v10;
      _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
    v21[0] = MEMORY[0x1895F87A8];
    v21[1] = 3221225472LL;
    v21[2] = __SOSCCPeersHaveViewsEnabled_block_invoke;
    v21[3] = &__block_descriptor_48_e19_____CFBoolean__8__0l;
    v21[4] = a1;
    void v21[5] = a2;
    uint64_t v12 = __SOSCCPeersHaveViewsEnabled_block_invoke((uint64_t)v21);
    uint64_t v18 = SecLogAPICreate(0LL, "SOSCCPeersHaveViewsEnabled", @"return=%@", v13, v14, v15, v16, v17, v12);
    secLogObjForScope("api_trace");
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v23 = v18;
      _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18) {
      CFRelease(v18);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v12;
}

uint64_t __SOSCCPeersHaveViewsEnabled_block_invoke(uint64_t a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void))(gSecurityd + 616);
    if (v1) {
      return v1(*(void *)(a1 + 32), *(void *)(a1 + 40));
    }
  }

  uint64_t v4 = *(void *)(a1 + 32);
  int v3 = *(CFTypeRef **)(a1 + 40);
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 0;
  v7[4] = &v9;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = __cfarray_to_cfBOOLean_error_request_block_invoke;
  v8[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  void v8[4] = v4;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = __cfarray_to_cfBOOLean_error_request_block_invoke_2;
  v7[3] = &unk_1896702C8;
  uint64_t v5 = 0LL;
  if (securityd_send_sync_and_do(0x69u, v3, (uint64_t)v8, (uint64_t)v7))
  {
    if (*((_BYTE *)v10 + 24)) {
      uint64_t v6 = (uint64_t *)MEMORY[0x189604DE8];
    }
    else {
      uint64_t v6 = (uint64_t *)MEMORY[0x189604DE0];
    }
    uint64_t v5 = *v6;
  }

  _Block_object_dispose(&v9, 8);
  return v5;
}

size_t __cfarray_to_cfBOOLean_error_request_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "cfarray", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __cfarray_to_cfBOOLean_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

uint64_t SOSCCMessageFromPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("pending-check");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCMessageFromPeerIsPending", buf, 2u);
    }

    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __SOSCCMessageFromPeerIsPending_block_invoke;
    v14[3] = &__block_descriptor_48_e5_B8__0l;
    v14[4] = a1;
    v14[5] = a2;
    uint64_t v5 = __SOSCCMessageFromPeerIsPending_block_invoke((uint64_t)v14);
    uint64_t v11 = SecLogAPICreate(0LL, "SOSCCMessageFromPeerIsPending", @"return=%d", v6, v7, v8, v9, v10, v5);
    secLogObjForScope("api_trace");
    char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v16 = v11;
      _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v5;
}

uint64_t __SOSCCMessageFromPeerIsPending_block_invoke(uint64_t a1)
{
  else {
    return peer_info_to_BOOL_error_request(0x6Bu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t peer_info_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  char v10 = 0;
  void v5[4] = &v7;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __peer_info_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  void v6[4] = a2;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __peer_info_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1896702C8;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCSendToPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __SOSCCSendToPeerIsPending_block_invoke;
    v13[3] = &__block_descriptor_48_e5_B8__0l;
    v13[4] = a1;
    v13[5] = a2;
    uint64_t v4 = __SOSCCSendToPeerIsPending_block_invoke((uint64_t)v13);
    char v10 = SecLogAPICreate(0LL, "SOSCCSendToPeerIsPending", @"return=%d", v5, v6, v7, v8, v9, v4);
    secLogObjForScope("api_trace");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v15 = v10;
      _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10) {
      CFRelease(v10);
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0LL;
  }

  return v4;
}

uint64_t __SOSCCSendToPeerIsPending_block_invoke(uint64_t a1)
{
  else {
    return peer_info_to_BOOL_error_request(0x6Cu, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40));
  }
}

uint64_t SOSCCSetCompatibilityMode(char a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  secLogObjForScope("sos-compatibility-mode");
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCSetCompatibilityMode", buf, 2u);
  }

  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  v21[2] = __SOSCCSetCompatibilityMode_block_invoke;
  v21[3] = &__block_descriptor_41_e5_B8__0l;
  char v22 = a1;
  v21[4] = a2;
  uint64_t v12 = __SOSCCSetCompatibilityMode_block_invoke((uint64_t)v21, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v18 = SecLogAPICreate(0LL, "SOSCCSetCompatibilityMode", @"return=%d", v13, v14, v15, v16, v17, v12);
  secLogObjForScope("api_trace");
  char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v24 = v18;
    _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18) {
    CFRelease(v18);
  }
  return v12;
}

uint64_t __SOSCCSetCompatibilityMode_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (gSecurityd)
  {
    uint64_t v8 = *(uint64_t (**)(void, void))(gSecurityd + 648);
    if (v8) {
      return v8(*(unsigned __int8 *)(a1 + 40), *(void *)(a1 + 32));
    }
  }

  char v10 = *(_BYTE *)(a1 + 40);
  uint64_t v11 = *(CFTypeRef **)(a1 + 32);
  uint64_t v17 = 0LL;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  char v20 = 0;
  uint64_t v12 = SecLogAPICreate(0LL, "BOOL_and_error_request_returns_BOOL", 0LL, a4, a5, a6, a7, a8, 0);
  secLogObjForScope("api_trace");
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v12;
    _os_log_debug_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
  }

  if (v12) {
    CFRelease(v12);
  }
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = __BOOL_and_error_request_returns_BOOL_block_invoke;
  v15[3] = &__block_descriptor_33_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  char v16 = v10;
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + 1) = 3221225472LL;
  char v22 = __BOOL_and_error_request_returns_BOOL_block_invoke_2;
  uint64_t v23 = &unk_1896702C8;
  uint64_t v24 = &v17;
  securityd_send_sync_and_do(0x5Au, v11, (uint64_t)v15, (uint64_t)&buf);
  uint64_t v14 = *((unsigned __int8 *)v18 + 24);
  _Block_object_dispose(&v17, 8);
  return v14;
}

void sub_1805A70F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t SOSCCFetchCompatibilityModeCachedValue(CFTypeRef *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  secLogObjForScope("sos-compatibility-mode-cached");
  id v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityModeCachedValue", buf, 2u);
  }

  else {
    uint64_t v4 = simple_BOOL_error_request(0x5Cu, a1);
  }
  uint64_t v10 = v4;
  uint64_t v11 = SecLogAPICreate(0LL, "SOSCCFetchCompatibilityModeCachedValue", @"return=%d", v5, v6, v7, v8, v9, v4);
  secLogObjForScope("api_trace");
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v15 = v11;
    _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11) {
    CFRelease(v11);
  }
  return v10;
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabledCachedValue()
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  secLogObjForScope("sos-compatibility-mode-cached");
  v0 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl( &dword_1804F4000,  v0,  OS_LOG_TYPE_DEBUG,  "enter SOSCCIsSOSTrustAndSyncingEnabledCachedValue",  buf,  2u);
  }

  secLogObjForScope("sos-compatibility-mode-cached");
  uint64_t v1 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( &dword_1804F4000,  v1,  OS_LOG_TYPE_DEFAULT,  "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode",  buf,  2u);
  }

  CFTypeRef cf = 0LL;
  uint64_t v2 = SOSCCFetchCompatibilityModeCachedValue(&cf);
  secLogObjForScope("sos-compatibility-mode-cached");
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = @"disabled";
    if ((_DWORD)v2) {
      uint64_t v4 = @"enabled";
    }
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v10 = v4;
    _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    secLogObjForScope("SecError");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "sos-compatibility-mode-cached: fetching compatibility mode error: %@",  buf,  0xCu);
    }

    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }

  return v2;
}

uint64_t SOSCCPushResetCircle(CFTypeRef *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  secLogObjForScope("push-reset-circle-to-kvs");
  uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCPushResetCircle", buf, 2u);
  }

  uint64_t v8 = SecLogAPICreate(0LL, "SOSCCPushResetCircle", 0LL, v3, v4, v5, v6, v7, 0);
  secLogObjForScope("api_trace");
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    char v22 = v8;
    _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v8) {
    CFRelease(v8);
  }
  else {
    uint64_t v11 = simple_BOOL_error_request(0x5Du, a1);
  }
  uint64_t v17 = v11;
  uint64_t v18 = SecLogAPICreate(0LL, "SOSCCPushResetCircle", @"return=%d", v12, v13, v14, v15, v16, v11);
  secLogObjForScope("api_trace");
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 138412290;
    char v22 = v18;
    _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18) {
    CFRelease(v18);
  }
  return v17;
}

void SOSCCAccountGetPublicKey(void *a1)
{
  id v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    sosDisabledNSError();
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, void, void, void *))v1 + 2))(v1, 0LL, 0LL, v3);
    goto LABEL_15;
  }

  CFTypeRef cf = 0LL;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    if (gSecurityd && (uint64_t v2 = *(void (**)(void))(gSecurityd + 680)) != 0LL)
    {
      v2();
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v3)
      {
LABEL_6:
        CFTypeRef v4 = 0LL;
        goto LABEL_9;
      }
    }

    else
    {
      if (SOSCCGetStatusObject_onceToken != -1) {
        dispatch_once(&SOSCCGetStatusObject_onceToken, &__block_literal_global_272);
      }
      [(id)SOSCCGetStatusObject_control connection];
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
      [v6 remoteObjectProxy];
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v3) {
        goto LABEL_6;
      }
    }

    [v3 userPublicKey:v1];
LABEL_15:

    goto LABEL_16;
  }

  SOSCCSetSOSDisabledError(&cf);
  CFTypeRef v4 = cf;
LABEL_9:
  (*((void (**)(id, void, void, CFTypeRef))v1 + 2))(v1, 0LL, 0LL, v4);
  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v5);
  }

id sosDisabledNSError()
{
  if (staticSOSDisabledError_onceToken != -1) {
    dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_241);
  }
  return (id)staticSOSDisabledError_sosIsDisabledError;
}

void __SOSCCGetStatusObject_block_invoke()
{
  v0 = objc_alloc_init(&OBJC_CLASS___SecSOSStatus);
  id v1 = (void *)SOSCCGetStatusObject_control;
  SOSCCGetStatusObject_control = (uint64_t)v0;
}

void SOSCCAccountGetKeyCircleGeneration(void *a1)
{
  id v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    v3[2] = __SOSCCAccountGetKeyCircleGeneration_block_invoke;
    v3[3] = &unk_18966F290;
    id v4 = v1;
    SOSCCAccountGetPublicKey(v3);
  }

  else
  {
    sosDisabledNSError();
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, void, void *))v1 + 2))(v1, 0LL, v2);
  }
}

void __SOSCCAccountGetKeyCircleGeneration_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v12 = a3;
  if (v12)
  {
    uint64_t v6 = (void *)MEMORY[0x189603FB8];
    id v7 = a4;
    [v6 dataWithLength:32];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    ccsha256_di();
    [v12 length];
    [v12 bytes];
    id v9 = v8;
    [v9 mutableBytes];
    ccdigest();
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void (**)(uint64_t, void, id))(v10 + 16);
    id v9 = a4;
    v11(v10, 0LL, v9);
  }
}

id SOSCCCircleHash(void *a1)
{
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    uint64_t v14 = 0LL;
    SOSCCGetSynchronousStatusObject((CFTypeRef *)&v14);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v3 = v2;
    if (v2)
    {
      uint64_t v8 = 0LL;
      id v9 = &v8;
      uint64_t v10 = 0x3032000000LL;
      uint64_t v11 = __Block_byref_object_copy__7567;
      id v12 = __Block_byref_object_dispose__7568;
      id v13 = 0LL;
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = __SOSCCCircleHash_block_invoke;
      v7[3] = &unk_18966F2B8;
      v7[4] = &v8;
      [v2 circleHash:v7];
      id v4 = (id)v9[5];
      _Block_object_dispose(&v8, 8);
    }

    else
    {
      if (a1) {
        *a1 = v14;
      }
      uint64_t v6 = v14;
      if (v14)
      {
        uint64_t v14 = 0LL;
        CFRelease(v6);
      }

      id v4 = 0LL;
    }
  }

  else
  {
    if (a1)
    {
      sosDisabledNSError();
      *a1 = (id)objc_claimAutoreleasedReturnValue();
      return 0LL;
    }

    id v4 = 0LL;
  }

  return v4;
}

void sub_1805A7B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

id SOSCCGetSynchronousStatusObject(CFTypeRef *a1)
{
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    if (gSecurityd && (uint64_t v2 = *(void (**)(void))(gSecurityd + 680)) != 0LL)
    {
      v2();
      return (id)objc_claimAutoreleasedReturnValue();
    }

    else
    {
      if (SOSCCGetSynchronousStatusObject_onceToken != -1) {
        dispatch_once(&SOSCCGetSynchronousStatusObject_onceToken, &__block_literal_global_274);
      }
      uint64_t v8 = 0LL;
      id v9 = &v8;
      uint64_t v10 = 0x3032000000LL;
      uint64_t v11 = __Block_byref_object_copy__7567;
      id v12 = __Block_byref_object_dispose__7568;
      id v13 = 0LL;
      [(id)SOSCCGetSynchronousStatusObject_control connection];
      id v4 = (void *)objc_claimAutoreleasedReturnValue();
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = __SOSCCGetSynchronousStatusObject_block_invoke_2;
      v7[3] = &unk_189672C48;
      v7[4] = &v8;
      [v4 synchronousRemoteObjectProxyWithErrorHandler:v7];
      CFTypeRef v5 = (void *)objc_claimAutoreleasedReturnValue();

      if (a1)
      {
        uint64_t v6 = (const void *)v9[5];
        if (v6) {
          *a1 = v6;
        }
      }

      _Block_object_dispose(&v8, 8);

      return v5;
    }
  }

  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0LL;
  }

void sub_1805A7C84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t __Block_byref_object_copy__7567(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__7568(uint64_t a1)
{
}

void __SOSCCCircleHash_block_invoke(uint64_t a1, void *a2)
{
}

void __SOSCCGetSynchronousStatusObject_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  id v4 = a2;
  secLogObjForScope("ghostbust");
  CFTypeRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v4;
    _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "An error occurred on the xpc connection to setup the background session: %@",  (uint8_t *)&v6,  0xCu);
  }

  if (v4) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }
}

void __SOSCCGetSynchronousStatusObject_block_invoke()
{
  v0 = objc_alloc_init(&OBJC_CLASS___SecSOSStatus);
  id v1 = (void *)SOSCCGetSynchronousStatusObject_control;
  SOSCCGetSynchronousStatusObject_control = (uint64_t)v0;
}

void SOSCCGhostBust(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeRef v10 = 0LL;
    SOSCCGetSynchronousStatusObject(&v10);
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      secLogObjForScope("ghostbust");
      CFTypeRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "API Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = __SOSCCGhostBust_block_invoke;
      v7[3] = &unk_189670568;
      id v8 = v3;
      [v4 ghostBust:a1 complete:v7];
    }

    else
    {
      (*((void (**)(id, void, CFTypeRef))v3 + 2))(v3, 0LL, v10);
      CFTypeRef v6 = v10;
      if (v10)
      {
        CFTypeRef v10 = 0LL;
        CFRelease(v6);
      }
    }
  }

  else
  {
    sosDisabledNSError();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, void, void *))v3 + 2))(v3, 0LL, v4);
  }
}

void __SOSCCGhostBust_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  secLogObjForScope("ghostbust");
  CFTypeRef v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = a2;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "API returned: %d", (uint8_t *)v7, 8u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void SOSCCGhostBustTriggerTimed(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeRef v10 = 0LL;
    SOSCCGetSynchronousStatusObject(&v10);
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      secLogObjForScope("ghostbust");
      id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "API Trigger Timed Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      _DWORD v7[2] = __SOSCCGhostBustTriggerTimed_block_invoke;
      v7[3] = &unk_189670568;
      id v8 = v3;
      [v4 ghostBustTriggerTimed:a1 complete:v7];
    }

    else
    {
      (*((void (**)(id, void, CFTypeRef))v3 + 2))(v3, 0LL, v10);
      CFTypeRef v6 = v10;
      if (v10)
      {
        CFTypeRef v10 = 0LL;
        CFRelease(v6);
      }
    }
  }

  else
  {
    sosDisabledNSError();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, void, void *))v3 + 2))(v3, 0LL, v4);
  }
}

void __SOSCCGhostBustTriggerTimed_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  secLogObjForScope("ghostbust");
  CFTypeRef v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = a2;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "API Trigger Timed returned: %d", (uint8_t *)v7, 8u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void SOSCCGhostBustInfo(void *a1)
{
  id v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    CFTypeRef v8 = 0LL;
    SOSCCGetSynchronousStatusObject(&v8);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    if (v2)
    {
      secLogObjForScope("ghostbust");
      id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "API Info Called", buf, 2u);
      }

      v5[0] = MEMORY[0x1895F87A8];
      v5[1] = 3221225472LL;
      v5[2] = __SOSCCGhostBustInfo_block_invoke;
      v5[3] = &unk_18966F2E0;
      id v6 = v1;
      [v2 ghostBustInfo:v5];
    }

    else
    {
      (*((void (**)(id, void, CFTypeRef))v1 + 2))(v1, 0LL, v8);
      CFTypeRef v4 = v8;
      if (v8)
      {
        CFTypeRef v8 = 0LL;
        CFRelease(v4);
      }
    }
  }

  else
  {
    sosDisabledNSError();
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, void, void *))v1 + 2))(v1, 0LL, v2);
  }
}

void __SOSCCGhostBustInfo_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  secLogObjForScope("ghostbust");
  id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef v8 = 0;
    _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "API Info returned", v8, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

CFStringRef SecCopyErrorMessageString(OSStatus status, void *reserved)
{
  uint64_t v2 = *(void *)&status;
  CFStringRef result = copyErrorMessageFromBundle(*(uint64_t *)&status, @"SecErrorMessages");
  if (!result)
  {
    CFStringRef result = copyErrorMessageFromBundle(v2, @"SecDebugErrorMessages");
    if (!result) {
      return CFStringCreateWithFormat(0LL, 0LL, @"OSStatus %d", v2);
    }
  }

  return result;
}

CFStringRef copyErrorMessageFromBundle(uint64_t a1, const __CFString *a2)
{
  uint64_t Bundle = SecFrameworkGetBundle();
  if (!Bundle) {
    return 0LL;
  }
  id v5 = (__CFBundle *)Bundle;
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%d", a1);
  if (!v6) {
    return 0LL;
  }
  id v7 = v6;
  CFStringRef v8 = CFBundleCopyLocalizedString(v5, v7, v7, a2);
  if (CFStringCompare(v8, v7, 0LL) == kCFCompareEqualTo && v8)
  {
    CFRelease(v8);
    CFStringRef v8 = 0LL;
  }

  CFRelease(v7);
  return v8;
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return CCRandomCopyBytes();
}

CFTypeID SecAccessControlGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __SecAccessControlGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SecAccessControlGetTypeID_sSecAccessControlGetTypeIDSingleton;
  if (SecAccessControlGetTypeID_sSecAccessControlGetTypeIDOnce != -1) {
    dispatch_once(&SecAccessControlGetTypeID_sSecAccessControlGetTypeIDOnce, block);
  }
  return SecAccessControlGetTypeID_sSecAccessControlGetTypeIDSingleton;
}

uint64_t __SecAccessControlGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SecAccessControlDestroy(uint64_t a1)
{
  id v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

BOOL SecAccessControlCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2 || CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
}

id SecAccessControlCopyFormatDescription(uint64_t a1)
{
  id v1 = (void *)MEMORY[0x189607940];
  id v2 = *(id *)(a1 + 16);
  [v1 string];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 objectForKeyedSubscript:@"prot"];
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue();
  dumpValue(v4, v3, &stru_1896794C8);

  [v2 objectForKeyedSubscript:@"acl"];
  id v5 = (void *)objc_claimAutoreleasedReturnValue();

  dumpValue(v5, v3, @";");
  [NSString stringWithFormat:@"<SecAccessControlRef: %@>", v3];
  id v6 = (id)objc_claimAutoreleasedReturnValue();

  return v6;
}

id SecAccessControlCopyDescription(uint64_t a1)
{
  return SecAccessControlCopyFormatDescription(a1);
}

void dumpValue(void *a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (v5)
  {
    CFTypeID v8 = CFGetTypeID(v5);
    if (v8 == CFBooleanGetTypeID())
    {
      else {
        id v9 = @"false";
      }
LABEL_6:
      CFTypeRef v10 = v6;
LABEL_7:
      [v10 appendString:v9];
      goto LABEL_11;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[__CFString stringValue](v5, "stringValue");
      uint64_t v11 = (__CFString *)objc_claimAutoreleasedReturnValue();
      [v6 appendString:v11];
LABEL_10:

      goto LABEL_11;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      CFTypeRef v10 = v6;
      id v9 = v5;
      goto LABEL_7;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v26[0] = MEMORY[0x1895F87A8];
        v26[1] = 3221225472LL;
        v26[2] = __dumpValue_block_invoke;
        v26[3] = &unk_18966F558;
        id v27 = v6;
        id v28 = v7;
        -[__CFString enumerateKeysAndObjectsUsingBlock:](v5, "enumerateKeysAndObjectsUsingBlock:", v26);

        goto LABEL_11;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_11;
      }
      [v6 appendString:@"["];
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      uint64_t v15 = v5;
      uint64_t v16 = -[__CFString countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v22,  v29,  16LL);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)v23;
        uint64_t v19 = &stru_1896794C8;
        do
        {
          uint64_t v20 = 0LL;
          do
          {
            if (*(void *)v23 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v21 = *(void *)(*((void *)&v22 + 1) + 8 * v20);
            [v6 appendString:v19];
            dumpValue(v21, v6, v7);
            ++v20;
            uint64_t v19 = @",";
          }

          while (v17 != v20);
          uint64_t v17 = -[__CFString countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v22,  v29,  16LL);
          uint64_t v19 = @",";
        }

        while (v17);
      }

      id v9 = @"]";
      goto LABEL_6;
    }

    uint64_t v11 = v5;
    uint64_t v12 = -[__CFString bytes](v11, "bytes");
    if ((unint64_t)-[__CFString length](v11, "length") <= 0x40)
    {
      unint64_t v13 = -[__CFString length](v11, "length");
      if (!v13) {
        goto LABEL_22;
      }
    }

    else
    {
      unint64_t v13 = 64LL;
    }

    uint64_t v14 = 0LL;
    do
      objc_msgSend(v6, "appendFormat:", @"%02X", *(unsigned __int8 *)(v12 + v14++));
    while (v13 != v14);
LABEL_22:
    if (v13 < -[__CFString length](v11, "length")) {
      objc_msgSend(v6, "appendFormat:", @"...(%db)", -[__CFString length](v11, "length"));
    }
    goto LABEL_10;
  }

uint64_t __dumpValue_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = a3;
  id v8 = a2;
  [v5 appendString:v6];
  dumpValue(v8, *(void *)(a1 + 32), &stru_1896794C8);

  objc_msgSend(*(id *)(a1 + 32), "appendString:", @"(");
  dumpValue(v7, *(void *)(a1 + 32), &stru_1896794C8);

  return [*(id *)(a1 + 32) appendString:@""]);
}

uint64_t SecAccessControlCreate(const __CFAllocator *a1, __CFString **a2)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance) {
    *(void *)(Instance + 16) = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }
  else {
    SecError(-108, a2, @"allocate memory for SecAccessControl");
  }
  return Instance;
}

SecAccessControlRef SecAccessControlCreateWithFlags( CFAllocatorRef allocator, CFTypeRef protection, SecAccessControlCreateFlags flags, CFErrorRef *error)
{
  uint64_t v8 = SecAccessControlCreate(allocator, (__CFString **)error);
  id v9 = (__SecAccessControl *)v8;
  if (!v8) {
    return v9;
  }
  if (!SecAccessControlSetProtection(v8, protection, (__CFString **)error))
  {
LABEL_14:
    CFMutableArrayRef Mutable = v9;
    id v9 = 0LL;
LABEL_15:
    CFRelease(Mutable);
    return v9;
  }

  if (flags)
  {
    if ((~(_DWORD)flags & 0xC000LL) == 0)
    {
      SecError(-50, (__CFString **)error, @"only one logical operation can be set");
      goto LABEL_14;
    }

    if ((flags & 8) != 0 && (flags & 0xA) != 8)
    {
      SecError(-50, (__CFString **)error, @"only one bio constraint can be set");
      goto LABEL_14;
    }

    if ((flags & 1) != 0 && (flags & 0xFFFFFFFF3FFFFFFELL) != 0)
    {
      SecError( -50,  (__CFString **)error,  @"kSecAccessControlUserPresence can be combined only with kSecAccessControlApplicationPassword and kSecAccessControlPrivateKeyUsage");
      goto LABEL_14;
    }

    CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0LL, MEMORY[0x189605228]);
    if ((flags & 1) != 0)
    {
      MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith( allocator,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  @"cpo",  (uint64_t)@"DeviceOwnerAuthentication");
      if (!MutableForCFTypesWith) {
        goto LABEL_74;
      }
      uint64_t v20 = MutableForCFTypesWith;
      CFArrayAppendValue(Mutable, MutableForCFTypesWith);
      CFRelease(v20);
    }

    if ((flags & 0x10) != 0)
    {
      uint64_t v21 = CFDictionaryCreateMutableForCFTypesWith( allocator,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  @"cup",  *MEMORY[0x189604DE8]);
      if (!v21) {
        goto LABEL_74;
      }
      __int128 v22 = v21;
      CFArrayAppendValue(Mutable, v21);
      CFRelease(v22);
    }

    if ((flags & 2) != 0)
    {
      if (_getEmptyData_onceToken != -1) {
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_7632);
      }
      BiometryAny = SecAccessConstraintCreateBiometryAny( allocator,  _getEmptyData_emptyData,  v13,  v14,  v15,  v16,  v17,  v18);
      if (!BiometryAny) {
        goto LABEL_74;
      }
      __int128 v24 = BiometryAny;
      CFArrayAppendValue(Mutable, BiometryAny);
      CFRelease(v24);
    }

    if ((flags & 8) != 0)
    {
      if (_getEmptyData_onceToken != -1) {
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_7632);
      }
      BiometryCurrentSet = SecAccessConstraintCreateBiometryCurrentSet( allocator,  _getEmptyData_emptyData,  (const void *)_getEmptyData_emptyData,  v14,  v15,  v16,  v17,  v18);
      if (!BiometryCurrentSet) {
        goto LABEL_74;
      }
      uint64_t v26 = BiometryCurrentSet;
      CFArrayAppendValue(Mutable, BiometryCurrentSet);
      CFRelease(v26);
    }

    if ((flags & 0x20) != 0)
    {
      id v27 = CFDictionaryCreateMutableForCFTypesWith( allocator,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  @"cwtch",  *MEMORY[0x189604DE8]);
      if (!v27) {
        goto LABEL_74;
      }
      id v28 = v27;
      CFArrayAppendValue(Mutable, v27);
      CFRelease(v28);
    }

    if ((flags & 0x80000000) != 0)
    {
      MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints((CFDictionaryRef *)v9);
      CFDictionarySetValue(MutableConstraints, @"prp", (const void *)*MEMORY[0x189604DE8]);
    }

    CFIndex Count = CFArrayGetCount(Mutable);
    if (Count >= 2)
    {
      if ((flags & 0x4000) != 0) {
        uint64_t v31 = 1LL;
      }
      else {
        uint64_t v31 = Count;
      }
      ValueOfKofN = SecAccessConstraintCreateValueOfKofN(allocator, v31, Mutable, (__CFString **)error);
      if (!ValueOfKofN) {
        goto LABEL_75;
      }
      if ((flags & 0x40000000) != 0)
      {
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"osgn",  ValueOfKofN,  (__CFString **)error)
          || !SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"ock",  ValueOfKofN,  (__CFString **)error)
          || !SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"okd",  ValueOfKofN,  (__CFString **)error)
          || (__int16 v33 = (const void *)*MEMORY[0x189604DE8],
              !SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"oa",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)))
        {
LABEL_75:
          CFRelease(v9);
          if (Mutable) {
            CFRelease(Mutable);
          }
          id v9 = 0LL;
          CFMutableArrayRef Mutable = ValueOfKofN;
          if (ValueOfKofN) {
            goto LABEL_15;
          }
          return v9;
        }
      }

      else
      {
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"od",  ValueOfKofN,  (__CFString **)error)) {
          goto LABEL_75;
        }
        __int16 v33 = (const void *)*MEMORY[0x189604DE8];
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"oe",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)) {
          goto LABEL_75;
        }
      }

      CFRelease(ValueOfKofN);
LABEL_72:
      if (!Mutable) {
        return v9;
      }
      goto LABEL_15;
    }

    if (Count == 1)
    {
      if ((flags & 0x40000000) != 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0LL);
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"osgn",  ValueAtIndex,  (__CFString **)error)) {
          goto LABEL_74;
        }
        v38 = CFArrayGetValueAtIndex(Mutable, 0LL);
        v39 = CFArrayGetValueAtIndex(Mutable, 0LL);
        __int16 v35 = (const void *)*MEMORY[0x189604DE8];
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"oa",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)) {
          goto LABEL_74;
        }
      }

      else
      {
        uint64_t v34 = CFArrayGetValueAtIndex(Mutable, 0LL);
        __int16 v35 = (const void *)*MEMORY[0x189604DE8];
        if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"oe",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)) {
          goto LABEL_74;
        }
      }

      v40 = (CFDictionaryRef *)v9;
      v41 = v35;
    }

    else
    {
      CFTypeRef v36 = (const void *)*MEMORY[0x189604DE8];
      if ((flags & 0x40000000) == 0)
      {
        if (SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"dacl",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error))
        {
          goto LABEL_72;
        }

        goto LABEL_74;
      }

      if (!SecAccessControlAddConstraintForOperation( (CFDictionaryRef *)v9,  @"osgn",  (CFTypeRef)*MEMORY[0x189604DE8],  (__CFString **)error)
        || !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"ock", v36, (__CFString **)error)
        || !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"okd", v36, (__CFString **)error)
        || !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, @"oa", v36, (__CFString **)error))
      {
        goto LABEL_74;
      }

      v40 = (CFDictionaryRef *)v9;
      v41 = v36;
    }

BOOL SecAccessControlSetProtection(uint64_t a1, CFTypeRef cf, __CFString **a3)
{
  v10[8] = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID()) {
      goto LABEL_11;
    }
  }

  uint64_t v7 = 0LL;
  v10[0] = @"dk";
  v10[1] = @"ck";
  v10[2] = @"ak";
  v10[3] = @"dku";
  void v10[4] = @"cku";
  void v10[5] = @"aku";
  v10[6] = @"akpu";
  v10[7] = @"f";
  do
  {
    CFTypeRef v8 = (CFTypeRef)v10[v7];
    if (cf && v8)
    {
      if (CFEqual(cf, v8)) {
        goto LABEL_11;
      }
    }

    else if (v8 == cf)
    {
      goto LABEL_11;
    }

    ++v7;
  }

  while (v7 != 8);
  BOOL result = SecError(-50, a3, @"%@: %@", @"SecAccessControl: invalid protection", cf);
  if (result)
  {
LABEL_11:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"prot", cf);
    return 1LL;
  }

  return result;
}

__CFDictionary *SecAccessConstraintCreateBiometryAny( const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"pbioc", a2);
  int v17 = CFDictionaryCreateMutableForCFTypesWith( a1,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  @"cbio",  (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return v17;
}

__CFDictionary *SecAccessConstraintCreateBiometryCurrentSet( const __CFAllocator *a1, uint64_t a2, const void *a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith( a1,  a2,  (int)a3,  a4,  a5,  a6,  a7,  a8,  @"pbioc",  a2);
  CFDictionarySetValue(MutableForCFTypesWith, @"pbioh", a3);
  int v18 = CFDictionaryCreateMutableForCFTypesWith( a1,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  @"cbio",  (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return v18;
}

const void *SecAccessControlGetMutableConstraints(CFDictionaryRef *a1)
{
  BOOL result = CFDictionaryGetValue(a1[2], @"acl");
  if (!result)
  {
    id v3 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    CFDictionarySetValue(a1[2], @"acl", Mutable);
    CFRelease(Mutable);
    return CFDictionaryGetValue(a1[2], @"acl");
  }

  return result;
}

__CFDictionary *SecAccessConstraintCreateValueOfKofN( const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  uint64_t valuePtr = a2;
  CFNumberRef v7 = CFNumberCreate(a1, kCFNumberCFIndexType, &valuePtr);
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith( a1,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  @"pkofn",  (uint64_t)v7);
  CFRelease(v7);
  CFIndex Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    CFIndex v17 = Count;
    CFIndex v18 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v18);
      if (!ValueAtIndex) {
        break;
      }
      uint64_t v20 = ValueAtIndex;
      CFTypeID v21 = CFGetTypeID(ValueAtIndex);
      if (v21 != CFDictionaryGetTypeID()) {
        break;
      }
      uint64_t v22 = 0LL;
      while (1)
      {
        __int128 v23 = off_18966F598[v22];
        Value = CFDictionaryGetValue(v20, v23);
        if (Value) {
          break;
        }
        if (++v22 == 4) {
          goto LABEL_11;
        }
      }

      CFDictionarySetValue(MutableForCFTypesWith, v23, Value);
      if (++v18 == v17) {
        return MutableForCFTypesWith;
      }
    }

BOOL SecAccessControlAddConstraintForOperation( CFDictionaryRef *a1, const void *a2, CFTypeRef cf, __CFString **a4)
{
  if (!cf || (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    if (!CFEqual(cf, (CFTypeRef)*MEMORY[0x189604DE8]) && !CFEqual(cf, (CFTypeRef)*MEMORY[0x189604DE0])) {
      return SecError(-50, a4, @"invalid constraint");
    }
  }

  MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
  CFDictionarySetValue(MutableConstraints, a2, cf);
  return 1LL;
}

CFMutableDataRef ___getEmptyData_block_invoke()
{
  CFMutableDataRef result = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  _getEmptyData_emptyData = (uint64_t)result;
  return result;
}

__CFDictionary *SecAccessConstraintCreatePolicy( const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cpo", a2);
}

__CFDictionary *SecAccessConstraintCreatePasscode( const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cup", *MEMORY[0x189604DE8]);
}

__CFDictionary *SecAccessConstraintCreateCompanion( const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cwtch", *MEMORY[0x189604DE8]);
}

void SecAccessControlSetRequirePassword(CFDictionaryRef *a1, int a2)
{
  MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
  CFTypeRef v4 = (const void **)MEMORY[0x189604DE8];
  if (!a2) {
    CFTypeRef v4 = (const void **)MEMORY[0x189604DE0];
  }
  CFDictionarySetValue(MutableConstraints, @"prp", *v4);
}

const void *SecAccessControlGetProtection(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"prot");
}

__CFDictionary *SecAccessConstraintCreateWatch( const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, @"cwtch", *MEMORY[0x189604DE8]);
}

__CFDictionary *SecAccessConstraintCreateKofN( const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  CFMutableDataRef result = SecAccessConstraintCreateValueOfKofN(a1, a2, a3, a4);
  if (result)
  {
    int v13 = result;
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith( a1,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  @"ckon",  (uint64_t)result);
    CFRelease(v13);
    return MutableForCFTypesWith;
  }

  return result;
}

const void *SecAccessControlGetConstraint(uint64_t a1, const void *a2)
{
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
  if (!Value) {
    return (const void *)*MEMORY[0x189604DE8];
  }
  CFTypeRef v4 = Value;
  if (!CFDictionaryGetCount(Value)) {
    return (const void *)*MEMORY[0x189604DE8];
  }
  CFMutableDataRef result = CFDictionaryGetValue(v4, a2);
  if (!result) {
    return CFDictionaryGetValue(v4, @"dacl");
  }
  return result;
}

__CFData *SecAccessControlCopyConstraintData(uint64_t a1, const void *a2)
{
  Constraint = (const __CFString *)SecAccessControlGetConstraint(a1, a2);
  CFIndex v9 = der_sizeof_plist(Constraint, 0LL, v3, v4, v5, v6, v7, v8);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, v9);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair( Constraint,  0LL,  0LL,  MutableBytePtr,  (unint64_t)&MutableBytePtr[v9],  v12,  v13,  v14)
    && Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

const void *SecAccessControlGetConstraints(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
}

void SecAccessControlSetConstraints(CFMutableDictionaryRef *a1, const __CFDictionary *a2)
{
  uint64_t v4 = CFGetAllocator(a1);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v4, 0LL, a2);
  CFDictionarySetValue(a1[2], @"acl", MutableCopy);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

CFDictionaryRef SecAccessControlGetRequirePassword(uint64_t a1)
{
  CFMutableDataRef result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
  if (result)
  {
    Value = CFDictionaryGetValue(result, @"prp");
    uint64_t v3 = (const void *)*MEMORY[0x189604DE8];
    if (Value) {
      BOOL v4 = v3 == 0LL;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4) {
      return Value == v3;
    }
    else {
      return CFEqual(Value, v3 != 0);
    }
  }

  return result;
}

void SecAccessControlSetBound(uint64_t a1, int a2)
{
  id v2 = *(__CFDictionary **)(a1 + 16);
  uint64_t v3 = (const void **)MEMORY[0x189604DE8];
  if (!a2) {
    uint64_t v3 = (const void **)MEMORY[0x189604DE0];
  }
  CFDictionarySetValue(v2, @"bound", *v3);
}

uint64_t SecAccessControlIsBound(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"bound");
  if (Value && *MEMORY[0x189604DE8] && CFEqual(Value, (CFTypeRef)*MEMORY[0x189604DE8])) {
    return 1LL;
  }
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"acl");
  BOOL v4 = (void *)objc_claimAutoreleasedReturnValue();
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  objc_msgSend(v4, "allValues", 0);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v13;
    CFIndex v9 = (const void *)*MEMORY[0x189604DE8];
    while (2)
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        if (*(void *)v13 != v8) {
          objc_enumerationMutation(v5);
        }
        if (!CFEqual(*(CFTypeRef *)(*((void *)&v12 + 1) + 8 * i), v9))
        {
          uint64_t v3 = 0LL;
          goto LABEL_17;
        }
      }

      uint64_t v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }

  uint64_t v3 = 1LL;
LABEL_17:

  return v3;
}

__CFData *SecAccessControlCopyData( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v9 = der_sizeof_plist(*(const __CFString **)(a1 + 16), 0LL, a3, a4, a5, a6, a7, a8);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, v9);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair( *(const __CFString **)(a1 + 16),  0LL,  0LL,  MutableBytePtr,  (unint64_t)&MutableBytePtr[v9],  v12,  v13,  v14)
    && Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

void *SecAccessControlCreateFromData(const __CFAllocator *a1, const __CFData *a2, __CFString **a3)
{
  uint64_t v5 = (void *)SecAccessControlCreate(a1, a3);
  if (v5)
  {
    uint64_t v15 = 0LL;
    BytePtr = CFDataGetBytePtr(a2);
    CFIndex Length = CFDataGetLength(a2);
    uint64_t v8 = &BytePtr[Length];
    uint64_t v12 = der_decode_plist( 0LL,  (uint64_t)&v15,  (CFTypeRef *)a3,  (uint64_t)BytePtr,  (uint64_t)&BytePtr[Length],  v9,  v10,  v11);
    if (!v12)
    {
LABEL_5:
      CFRelease(v5);
      return 0LL;
    }

    if ((const UInt8 *)v12 != v8)
    {
      SecError(-26275, a3, @"trailing garbage at end of SecAccessControl data");
      goto LABEL_5;
    }

    uint64_t v13 = (const void *)v5[2];
    if (v13) {
      CFRelease(v13);
    }
    v5[2] = v15;
  }

  return v5;
}

void SecItemFetchCurrentItemOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = _os_activity_create(&dword_1804F4000, "fetchCurrentItemOutOfBand", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  uint64_t v8 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v9 = MEMORY[0x1895F87A8];
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke;
  v15[3] = &unk_189670540;
  id v10 = v6;
  id v16 = v10;
  SecuritydXPCProxyObject(0LL, v15);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  v13[0] = v9;
  v13[1] = 3221225472LL;
  v13[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke_2;
  v13[3] = &unk_18966F5C0;
  id v12 = v10;
  id v14 = v12;
  [v11 secItemFetchCurrentItemOutOfBand:v5 forceFetch:a2 complete:v13];

  objc_autoreleasePoolPop(v8);
  os_activity_scope_leave(&state);
}

void sub_1805AAEA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchCurrentItemOutOfBand_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __SecItemFetchCurrentItemOutOfBand_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void SecItemFetchPCSIdentityOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = _os_activity_create(&dword_1804F4000, "fetchPCSIdentityOutOfBand", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  uint64_t v8 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v9 = MEMORY[0x1895F87A8];
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke;
  v15[3] = &unk_189670540;
  id v10 = v6;
  id v16 = v10;
  SecuritydXPCProxyObject(0LL, v15);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  v13[0] = v9;
  v13[1] = 3221225472LL;
  v13[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke_2;
  v13[3] = &unk_18966F5C0;
  id v12 = v10;
  id v14 = v12;
  [v11 secItemFetchPCSIdentityByKeyOutOfBand:v5 forceFetch:a2 complete:v13];

  objc_autoreleasePoolPop(v8);
  os_activity_scope_leave(&state);
}

void sub_1805AB02C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchPCSIdentityOutOfBand_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __SecItemFetchPCSIdentityOutOfBand_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

unint64_t SecBase64Encode(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4)
{
  return SecBase64Encode_(a1, a2, a3, a4, 0, &v5);
}

unint64_t SecBase64Encode_( unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v7 = a3;
  unint64_t v8 = a2;
  unint64_t v9 = (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  *a6 = 0;
  if (a5) {
    unint64_t v9 = v9 + 2 * ((v9 + a5 - 1) / a5) - 2;
  }
  if (a3)
  {
    if (v9 <= a4)
    {
      if (a2 >= 3)
      {
        uint64_t v10 = 0LL;
        do
        {
          uint64_t v11 = v7;
          unint64_t v12 = *a1;
          unint64_t v13 = v12 >> 2;
          unint64_t v14 = a1[1];
          unint64_t v15 = (v14 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v12 & 3));
          unint64_t v16 = a1[2];
          *uint64_t v7 = b64_chars[v13];
          v7[1] = b64_chars[v15];
          _DWORD v7[2] = b64_chars[(v16 >> 6) & 0xFFFFFFFFFFFFFFC3LL | (4 * (v14 & 0xF))];
          v7 += 4;
          v11[3] = b64_chars[v16 & 0x3F];
          v10 += 4LL;
          if (v10 == a5 && v7 != &a3[a4])
          {
            uint64_t v10 = 0LL;
            *((_WORD *)v11 + 2) = 2573;
            uint64_t v7 = v11 + 6;
          }

          a1 += 3;
          v8 -= 3LL;
        }

        while (v8 > 2);
      }

      if (v8)
      {
        unint64_t v17 = 0LL;
        __int16 v20 = -21846;
        char v21 = -86;
        do
        {
          unint64_t v18 = v17;
          *((_BYTE *)&v20 + v17) = a1[v17];
          ++v17;
        }

        while (v8 != v17);
        if (v18 < 2) {
          bzero((char *)&v20 + v8, v8 ^ 3);
        }
        SecBase64Encode_(&v20, 3LL, v7, 12LL, 0LL, a6);
        memset(&v7[v8 + 1], 61, v8 ^ 3);
      }
    }

    else
    {
      unint64_t v9 = 0LL;
      *a6 = 1;
    }
  }

  return v9;
}

unint64_t SecBase64Encode2( unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, char a5, unsigned int a6, char *a7)
{
  if (a7) {
    unint64_t v8 = a7;
  }
  else {
    unint64_t v8 = &v12;
  }
  int v9 = a5 & 0xF;
  unsigned int v10 = 76;
  switch(v9)
  {
    case 0:
      unsigned int v10 = a6;
      if ((a6 & 0x80000000) == 0) {
        goto LABEL_9;
      }
      goto LABEL_6;
    case 1:
      unsigned int v10 = 0;
      goto LABEL_9;
    case 2:
LABEL_6:
      unsigned int v10 = 64;
      goto LABEL_9;
    case 3:
LABEL_9:
      unint64_t result = SecBase64Encode_(a1, a2, a3, a4, v10, v8);
      break;
    default:
      unint64_t result = 0LL;
      *(_DWORD *)unint64_t v8 = 3;
      break;
  }

  return result;
}

_BYTE *SecBase64Decode(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4)
{
  return SecBase64Decode_(a1, a2, a3, a4, 0, &v6, &v5);
}

_BYTE *SecBase64Decode_( unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, _DWORD *a7)
{
  unint64_t v7 = a2 >> 2;
  if ((a2 & 3) != 0) {
    ++v7;
  }
  unint64_t v8 = 3 * v7;
  *a6 = 0LL;
  *a7 = 0;
  if (a3)
  {
    if (v8 > a4)
    {
      unint64_t v8 = 0LL;
      *a7 = 1;
      return (_BYTE *)v8;
    }

    int v15 = -1431655766;
    int v9 = a3;
    if (!a2) {
      return (_BYTE *)(v9 - a3);
    }
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    int v9 = a3;
    while (1)
    {
      unsigned int v12 = (char)*a1;
      if (v12 == 61)
      {
        *((_BYTE *)&v15 + v11) = 0;
        ++v10;
        goto LABEL_12;
      }

      int v13 = b64_indexes[*a1];
      if (v13 != 255)
      {
        uint64_t v10 = 0LL;
        *((_BYTE *)&v15 + v11) = v13;
LABEL_12:
        if (++v11 == 4)
        {
          _BYTE *v9 = (4 * v15) | (BYTE1(v15) >> 4) & 3;
          if (v10 == 2) {
            return (_BYTE *)(++v9 - a3);
          }
          v9[1] = (16 * BYTE1(v15)) | (BYTE2(v15) >> 2) & 0xF;
          if (v10 == 1)
          {
            v9 += 2;
            return (_BYTE *)(v9 - a3);
          }

          v9[2] = HIBYTE(v15) + (BYTE2(v15) << 6);
          if (v10)
          {
            v9 += 3;
            return (_BYTE *)(v9 - a3);
          }

          uint64_t v11 = 0LL;
          v9 += 3;
        }

        goto LABEL_23;
      }

      if (v12 <= 0x20)
      {
        if (((1LL << v12) & 0x100000B00LL) != 0)
        {
          if ((a5 & 0x200) != 0) {
            goto LABEL_30;
          }
          goto LABEL_23;
        }

        if (((1LL << v12) & 0x2400) != 0) {
          goto LABEL_23;
        }
      }

      if ((a5 & 0x100) != 0)
      {
LABEL_30:
        unint64_t v8 = 0LL;
        *a7 = 3;
        *a6 = a1;
        return (_BYTE *)v8;
      }

_BYTE *SecBase64Decode2( unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, char *a7)
{
  if (!a6) {
    a6 = (unsigned __int8 **)&v9;
  }
  if (!a7) {
    a7 = &v8;
  }
  return SecBase64Decode_(a1, a2, a3, a4, a5, a6, a7);
}

uint64_t SecCFAllocatorZeroize()
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  return SecCFAllocatorZeroize_sAllocator;
}

CFAllocatorRef __SecCFAllocatorZeroize_block_invoke()
{
  context.version = 0LL;
  *(_OWORD *)&context.info = unk_18C4873F8;
  context.release = (CFAllocatorReleaseCallBack)qword_18C487408;
  context.copyDescription = (CFAllocatorCopyDescriptionCallBack)SecCFAllocatorCopyDescription;
  *(_OWORD *)&context.allocate = unk_18C487418;
  context.deallocate = (CFAllocatorDeallocateCallBack)SecCFAllocatorDeallocate;
  context.preferredSize = (CFAllocatorPreferredSizeCallBack)qword_18C487430;
  CFAllocatorRef result = CFAllocatorCreate(0LL, &context);
  SecCFAllocatorZeroize_sAllocator = (uint64_t)result;
  return result;
}

CFStringRef SecCFAllocatorCopyDescription()
{
  return @"Custom CFAllocator for sensitive data that zeroizes on deallocate";
}

uint64_t SecCMSCreateEnvelopedData(void *a1, CFDictionaryRef theDict, const __CFData *a3, uint64_t a4)
{
  if (theDict && (Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSBulkEncryptionAlgorithm)) != 0LL)
  {
    char v8 = Value;
    if (CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmDESCBC, Value))
    {
      int v9 = 64;
      unsigned int v10 = 10;
    }

    else
    {
      int v26 = CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmAESCBC, v8);
      if (v26) {
        unsigned int v10 = 184;
      }
      else {
        unsigned int v10 = 7;
      }
      if (v26) {
        int v9 = 128;
      }
      else {
        int v9 = 192;
      }
    }
  }

  else
  {
    int v9 = 192;
    unsigned int v10 = 7;
  }

  uint64_t v11 = SecCmsMessageCreate();
  if (!v11) {
    return 4294967246LL;
  }
  unsigned int v12 = (unint64_t *)v11;
  unint64_t v13 = SecCmsEnvelopedDataCreate(v11, v10, v9);
  if (!v13) {
    goto LABEL_22;
  }
  unint64_t v14 = (unint64_t *)v13;
  if (SecCmsContentInfoSetContent(v12, 0x1Bu, v13)
    || SecCmsContentInfoSetContentData(v14, 0LL, 0))
  {
    goto LABEL_22;
  }

  CFTypeID v15 = CFGetTypeID(a1);
  if (v15 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      CFIndex v19 = Count;
      CFIndex v20 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v20);
      }

      while (v19 != ++v20);
    }

uint64_t SecCMSDecryptEnvelopedData(const __CFData *a1, __CFData *a2, void *a3)
{
  uint64_t v6 = MS_SecCMSDecryptEnvelopedData((uint64_t)a1, a2, a3);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3302);
  }
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound || !(_DWORD)v6) {
    return v6;
  }
  uint64_t v24 = 0LL;
  v23[0] = CFDataGetLength(a1);
  v23[1] = CFDataGetBytePtr(a1);
  int v8 = SecCmsMessageDecode((uint64_t)v23, 0LL, 0LL, v7, 0LL, 0LL, 0LL, &v24);
  uint64_t v9 = v24;
  if (v8)
  {
    uint64_t v6 = 4294941021LL;
    goto LABEL_35;
  }

  if (!v24) {
    return 4294967246LL;
  }
  uint64_t OID = *(void *)(v24 + 32);
  if (!OID)
  {
    uint64_t OID = SECOID_FindOID(v24);
    *(void *)(v9 + 32) = OID;
    if (!OID) {
      goto LABEL_14;
    }
  }

  if (*(_DWORD *)(OID + 16) != 27 || OID == 0) {
    goto LABEL_14;
  }
  uint64_t v12 = *(void *)(v9 + 16);
  if (!v12) {
    goto LABEL_14;
  }
  unint64_t v13 = *(uint64_t **)(v12 + 144);
  while (1)
  {
    uint64_t v14 = *v13;
    if (!*v13) {
      break;
    }
    CFTypeID v15 = *(const void **)(v14 + 144);
    ++v13;
    if (v15) {
      goto LABEL_21;
    }
  }

  CFTypeID v15 = 0LL;
LABEL_21:
  int v16 = 0;
  uint64_t ChildContentInfo = v9;
  do
  {
    ++v16;
    uint64_t ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
  }

  while (ChildContentInfo);
  if (v16 != 2) {
    goto LABEL_40;
  }
  uint64_t v18 = SecCmsContentInfoGetChildContentInfo(v9);
  if (!v18)
  {
LABEL_14:
    uint64_t v6 = 4294967246LL;
LABEL_36:
    SecCmsMessageDestroy(v9);
    return v6;
  }

  uint64_t v19 = v18;
  uint64_t v20 = *(void *)(v18 + 32);
  if (!v20 && (uint64_t v20 = SECOID_FindOID(v19), (*(void *)(v19 + 32) = v20) == 0LL) || *(_DWORD *)(v20 + 16) != 25)
  {
LABEL_40:
    uint64_t v6 = 4294967246LL;
    goto LABEL_35;
  }

  uint64_t InnerContent = SecCmsContentInfoGetInnerContent(v9);
  if (InnerContent) {
    CFDataAppendBytes(a2, *(const UInt8 **)(InnerContent + 8), *(void *)InnerContent);
  }
  if (a3)
  {
    if (v14) {
      CFRetain(v15);
    }
    uint64_t v6 = 0LL;
    *a3 = v15;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

uint64_t SecCMSSignDataAndAttributes( uint64_t a1, const __CFData *a2, int a3, uint64_t a4, const __CFDictionary *a5)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, a3, 0, 4u, a4, a5, 2, 0LL);
}

uint64_t SecCMSSignDataOrDigestAndAttributes( uint64_t a1, const __CFData *a2, int a3, int a4, unsigned int a5, uint64_t a6, const __CFDictionary *a7, int a8, CFArrayRef theArray)
{
  if (!a3 && (a4 & 1) != 0) {
    return 4294967246LL;
  }
  uint64_t v17 = SecCmsMessageCreate();
  if (!v17) {
    return 4294967246LL;
  }
  uint64_t v18 = (unint64_t *)v17;
  unint64_t v19 = PORT_ArenaAlloc(*(void *)(v17 + 120), 0xB8uLL);
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = (unint64_t *)v19;
  *(void *)(v19 + 176) = 0LL;
  *(_OWORD *)(v19 + 144) = 0u;
  *(_OWORD *)(v19 + 160) = 0u;
  *(_OWORD *)(v19 + 112) = 0u;
  *(_OWORD *)(v19 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v19 + 80) = 0u;
  *(_OWORD *)(v19 + 96) = 0u;
  *(_OWORD *)(v19 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v19 + 64) = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  *(_OWORD *)(v19 + 32) = 0u;
  *(_OWORD *)unint64_t v19 = 0u;
  *(void *)(v19 + 24) = v18;
  uint64_t v21 = SecCmsSignerInfoCreate((uint64_t)v20, a1, a5);
  if (!v21) {
    goto LABEL_28;
  }
  CFTypeID v22 = (void *)v21;
  if (theArray)
  {
  }

  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  if (a7) {
    CFDictionaryApplyFunction(a7, (CFDictionaryApplierFunction)sign_all_attributes, v22);
  }
  CFIndex v32 = 0LL;
  BytePtr = 0LL;
  if (!a2)
  {
    CFIndex Length = 0LL;
    if (a4) {
      goto LABEL_16;
    }
LABEL_19:
    if (Length) {
      BOOL v29 = a2 == 0LL;
    }
    else {
      BOOL v29 = 1;
    }
    if (v29) {
      id v28 = 0LL;
    }
    else {
      id v28 = &v32;
    }
    id v27 = (uint64_t *)v18;
    goto LABEL_26;
  }

  CFIndex Length = CFDataGetLength(a2);
  CFIndex v32 = Length;
  BytePtr = CFDataGetBytePtr(a2);
  if (!a4) {
    goto LABEL_19;
  }
LABEL_16:
  if (SecCmsSignedDataSetDigestValue(v20, a5, (uint64_t)&v32))
  {
LABEL_28:
    uint64_t v30 = 4294967246LL;
    goto LABEL_29;
  }

  id v27 = (uint64_t *)v18;
  id v28 = 0LL;
LABEL_26:
  uint64_t v30 = 0LL;
LABEL_29:
  SecCmsMessageDestroy((uint64_t)v18);
  return v30;
}

uint64_t sign_all_attributes(const __CFData *a1, const __CFData *a2, uint64_t a3)
{
  v13[0] = CFDataGetLength(a1);
  v13[1] = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a2);
  v12[0] = Length;
  v12[1] = CFDataGetBytePtr(a2);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a3 + 128) + 24LL) + 120LL);
  uint64_t result = PORT_ArenaAlloc(v7, 0x28uLL);
  if (result)
  {
    uint64_t v9 = result;
    *(void *)(result + 32) = 0LL;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    if (!SECITEM_CopyItem(v7, (unint64_t *)result, (uint64_t)v13))
    {
      unsigned int v10 = SECITEM_AllocItem(v7, 0LL, Length);
      if (v10)
      {
        uint64_t v11 = (uint64_t)v10;
        if (!SECITEM_CopyItem(v7, v10, (uint64_t)v12)
          && !SecCmsArrayAdd(v7, (char **)(v9 + 16), v11))
        {
          *(_BYTE *)(v9 + 32) = 1;
        }
      }
    }

    return SecCmsAttributeArrayAddAttr(v7, (uint64_t **)(a3 + 64), v9);
  }

  return result;
}

uint64_t SecCMSSignDigestAndAttributes(uint64_t a1, const __CFData *a2, uint64_t a3, const __CFDictionary *a4)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, 1, 1, 4u, a3, a4, 2, 0LL);
}

uint64_t SecCMSCreateSignedData( uint64_t a1, const __CFData *a2, CFDictionaryRef theDict, const __CFDictionary *a4, uint64_t a5)
{
  theArray = theDict;
  if (!theDict)
  {
    BOOL v11 = 0;
    BOOL v10 = 0;
    unsigned int v19 = 4;
    SInt32 IntValue = 2;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }

  BOOL v10 = CFDictionaryGetValueIfPresent(theDict, (const void *)kSecCMSSignDigest, 0LL) != 0;
  BOOL v11 = CFDictionaryGetValueIfPresent(theArray, (const void *)kSecCMSSignDetached, 0LL) != 0;
  Value = CFDictionaryGetValue(theArray, (const void *)kSecCMSSignHashAlgorithm);
  unint64_t v13 = (const __CFString *)CFDictionaryGetValue(theArray, (const void *)kSecCMSCertChainMode);
  if (v13 && (uint64_t v14 = v13, v15 = CFGetTypeID(v13), v15 == CFStringGetTypeID())) {
    SInt32 IntValue = CFStringGetIntValue(v14);
  }
  else {
    SInt32 IntValue = 2;
  }
  uint64_t v17 = (const __CFArray *)CFDictionaryGetValue(theArray, (const void *)kSecCMSAdditionalCerts);
  theArray = v17;
  if (v17)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 != CFArrayGetTypeID()) {
      theArray = 0LL;
    }
  }

  if (!Value || CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA1, Value))
  {
    unsigned int v19 = 4;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }

  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA256, Value))
  {
    unsigned int v19 = 192;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }

  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA384, Value))
  {
    unsigned int v19 = 193;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }

  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA512, Value))
  {
    unsigned int v19 = 194;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }

  return 4294967246LL;
}

uint64_t SecCMSVerifyCopyDataAndAttributes( const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, uint64_t *a5, const __CFDictionary **a6)
{
  return SecCMSVerifySignedData_internal(a1, a2, a3, a4, 0LL, a5, a6);
}

uint64_t SecCMSVerifySignedData_internal( const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, const __CFArray *a5, uint64_t *a6, const __CFDictionary **a7)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  CFTypeRef cf2 = 0LL;
  if (a6) {
    p_CFTypeRef cf2 = (uint64_t *)&cf2;
  }
  else {
    p_CFTypeRef cf2 = 0LL;
  }
  if (a7) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0LL;
  }
  CFTypeRef v106 = 0LL;
  if (a4) {
    int v16 = (__SecTrust **)&v106;
  }
  else {
    int v16 = 0LL;
  }
  uint64_t BytePtr = MS_SecCMSVerifySignedData_internal((uint64_t)a1, (uint64_t)a2, a3, v16, (uint64_t)a5, p_cf2, p_cf);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3302);
  }
  if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound && (_DWORD)BytePtr)
  {
    v103 = a4;
    uint64_t v105 = 0LL;
    if (!a1) {
      goto LABEL_167;
    }
    v104[0] = CFDataGetLength(a1);
    v104[1] = CFDataGetBytePtr(a1);
    int v19 = SecCmsMessageDecode((uint64_t)v104, 0LL, 0LL, v18, 0LL, 0LL, 0LL, &v105);
    uint64_t v20 = v105;
    if (v19)
    {
      uint64_t v23 = 4294941021LL;
      goto LABEL_111;
    }

    if (!v105)
    {
LABEL_167:
      uint64_t v23 = 4294967246LL;
      goto LABEL_26;
    }

    uint64_t OID = *(void *)(v105 + 32);
    if (OID || (uint64_t OID = SECOID_FindOID(v105), (*(void *)(v20 + 32) = OID) != 0LL))
    {
      if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
      {
        uint64_t v31 = *(void *)(v20 + 16);
        if (v31)
        {
          if (a2)
          {
            if (*(void *)(v31 + 168)) {
              goto LABEL_24;
            }
            uint64_t started = SecCmsDigestContextStartMultiple(*(uint64_t **)(v31 + 136));
            int v33 = BytePtr;
            uint64_t BytePtr = (uint64_t)CFDataGetBytePtr(a2);
            CFIndex Length = CFDataGetLength(a2);
            __int16 v35 = (const void *)BytePtr;
            LODWORD(BytePtr) = v33;
            SecCmsDigestContextUpdate(started, v35, Length);
            SecCmsSignedDataSetDigestContext((void *)v31, started);
            SecCmsDigestContextCancel(started);
          }

          if (!a5 || !SecCmsSignedDataAddCertList(v31, a5))
          {
            if (!a3) {
              goto LABEL_63;
            }
            CFTypeRef v36 = *(void **)(v31 + 160);
            if (v36 && *v36)
            {
              uint64_t v37 = v36 + 1;
              int v38 = -1;
              do
              {
                uint64_t v39 = *v37++;
                ++v38;
              }

              while (v39);
              if (v38)
              {
                uint64_t v23 = 4294967246LL;
                goto LABEL_111;
              }

              if (SecCmsSignedDataVerifySignerInfo_internal(v31, 0, a3, v103))
              {
                uint64_t v23 = 4294942003LL;
                goto LABEL_111;
              }

LABEL_63:
              v40 = (CFAllocatorRef *)MEMORY[0x189604DB0];
              if (a6)
              {
                uint64_t InnerContent = SecCmsContentInfoGetInnerContent(v20);
                if (InnerContent) {
                  uint64_t InnerContent = (uint64_t)CFDataCreate( *v40,  *(const UInt8 **)(InnerContent + 8),  *(void *)InnerContent);
                }
                *a6 = InnerContent;
              }

              if (!a7) {
                goto LABEL_110;
              }
              int v101 = BytePtr;
              v42 = *v40;
              theDict = CFDictionaryCreateMutable(*v40, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
              if (theDict)
              {
                v43 = *(uint64_t **)(**(void **)(v31 + 160) + 64LL);
                if (v43)
                {
                  uint64_t v44 = *v43;
                  if (*v43)
                  {
                    do
                    {
                      CFDataRef v45 = CFDataCreate(v42, *(const UInt8 **)(v44 + 8), *(void *)v44);
                      if (v45)
                      {
                        CFDataRef v46 = v45;
                        uint64_t v47 = *v43;
                        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v42, 0LL, MEMORY[0x189605228]);
                        v49 = *(uint64_t **)(v47 + 16);
                        if (v49)
                        {
                          uint64_t v50 = *v49;
                          if (*v49)
                          {
                            v51 = v49 + 1;
                            do
                            {
                              CFDataRef v52 = CFDataCreate(v42, *(const UInt8 **)(v50 + 8), *(void *)v50);
                              if (v52)
                              {
                                CFDataRef v53 = v52;
                                CFArrayAppendValue(Mutable, v52);
                                CFRelease(v53);
                              }

                              uint64_t v54 = *v51++;
                              uint64_t v50 = v54;
                            }

                            while (v54);
                          }
                        }

                        if (Mutable)
                        {
                          v55 = (__CFArray *)CFDictionaryGetValue(theDict, v46);
                          if (v55)
                          {
                            v56 = v55;
                            CFIndex Count = CFArrayGetCount(Mutable);
                            if (Count)
                            {
                              v115.size_t length = Count;
                              v115.location = 0LL;
                              CFArrayAppendArray(v56, Mutable, v115);
                            }
                          }

                          else
                          {
                            CFDictionarySetValue(theDict, v46, Mutable);
                          }

                          CFRelease(Mutable);
                        }

                        CFRelease(v46);
                      }

                      uint64_t v58 = v43[1];
                      ++v43;
                      uint64_t v44 = v58;
                    }

                    while (v58);
                  }
                }

                v59 = *(uint64_t **)(v31 + 144);
                v60 = CFArrayCreateMutable(v42, 0LL, MEMORY[0x189605228]);
                if (v59)
                {
                  uint64_t v61 = *v59;
                  if (*v59)
                  {
                    v62 = v59 + 1;
                    do
                    {
                      v63 = SecCertificateCreateWithBytes(0LL, *(const void **)(v61 + 8), *(void *)v61);
                      if (v63)
                      {
                        v64 = v63;
                        CFArrayAppendValue(v60, v63);
                        CFRelease(v64);
                      }

                      uint64_t v65 = *v62++;
                      uint64_t v61 = v65;
                    }

                    while (v65);
                  }
                }

                CFDictionaryAddValue(theDict, (const void *)kSecCMSAllCerts, v60);
                *(void *)at = -1LL;
                SecCmsSignerInfoGetSigningTime(**(void **)(v31 + 160), (double *)at, v66);
                if (!v67)
                {
                  CFDateRef v68 = CFDateCreate(v42, *(CFAbsoluteTime *)at);
                  if (v68)
                  {
                    CFDateRef v69 = v68;
                    CFDictionarySetValue(theDict, (const void *)kSecCMSSignDate, v68);
                    CFRelease(v69);
                  }
                }

                value = 0LL;
                if (SecCmsSignerInfoGetAppleCodesigningHashAgility( **(void **)(v31 + 160),  (CFDataRef *)&value)) {
                  BOOL v70 = 1;
                }
                else {
                  BOOL v70 = value == 0LL;
                }
                LODWORD(BytePtr) = v101;
                if (!v70) {
                  CFDictionarySetValue(theDict, (const void *)kSecCMSHashAgility, value);
                }
                CFArrayRef policies = 0LL;
                else {
                  BOOL v72 = policies == 0LL;
                }
                if (!v72) {
                  CFDictionarySetValue(theDict, (const void *)kSecCMSHashAgilityV2, policies);
                }
                CFAbsoluteTime v109 = NAN;
                SecCmsSignerInfoGetAppleExpirationTime(**(void **)(v31 + 160), &v109, v71);
                if (!v73)
                {
                  CFDateRef v74 = CFDateCreate(0LL, v109);
                  if (v74)
                  {
                    CFDateRef v75 = v74;
                    CFDictionarySetValue(theDict, (const void *)kSecCMSExpirationDate, v74);
                    CFRelease(v75);
                  }
                }

                *a7 = theDict;
                if (v60) {
                  CFRelease(v60);
                }
LABEL_110:
                uint64_t v23 = 0LL;
                goto LABEL_111;
              }

              uint64_t v23 = 0LL;
LABEL_111:
              if (!v20)
              {
LABEL_26:
                if (!a6) {
                  goto LABEL_116;
                }
                CFTypeRef v24 = (CFTypeRef)*a6;
                if (*a6 && cf2)
                {
                  if (CFEqual(v24, cf2)) {
                    goto LABEL_116;
                  }
                }

                else if (v24 == cf2)
                {
                  goto LABEL_116;
                }

                v76 = (os_log_s *)secLogObjForScope("SecWarning");
                if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v77 = *a6;
                  *(_DWORD *)at = 138412546;
                  *(void *)&at[4] = v77;
                  *(_WORD *)&at[12] = 2112;
                  CFTypeRef v113 = cf2;
                  _os_log_impl( &dword_1804F4000,  v76,  OS_LOG_TYPE_DEFAULT,  "MessageSecurity and Security frameworks have different attached contents results, returning Security result. sec: %@, ms: %@",  at,  0x16u);
                }

LABEL_116:
                v78 = v103;
                if (a7)
                {
                  v79 = *a7;
                  if (*a7 && cf)
                  {
                    if (CFEqual(v79, cf)) {
                      goto LABEL_124;
                    }
                  }

                  else if (v79 == cf)
                  {
                    goto LABEL_124;
                  }

                  v80 = (os_log_s *)secLogObjForScope("SecWarning");
                  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
                  {
                    v81 = *a7;
                    *(_DWORD *)at = 138412546;
                    *(void *)&at[4] = v81;
                    *(_WORD *)&at[12] = 2112;
                    CFTypeRef v113 = cf;
                    _os_log_impl( &dword_1804F4000,  v80,  OS_LOG_TYPE_DEFAULT,  "MessageSecurity and Security frameworks have different signed attributes results, returning Securi ty result. sec: %@, ms: %@",  at,  0x16u);
                  }
                }

      munmap(v10, v11);
      goto LABEL_117;
    }

    if (v14 != -822415874)
    {
      CFTypeID v15 = 0LL;
      if (v14 != -805638658) {
        goto LABEL_57;
      }
    }
  }

  v88 = size;
  if (!vm_alloc((vm_address_t *)&__dst, size, &v86)) {
    goto LABEL_116;
  }
  uint64_t v12 = (char *)__dst;
  memcpy(__dst, v10, v11);
  if (remove_signature_space(v12, v11, &v88, &v86))
  {
    unint64_t v13 = v88;
    CFTypeID v15 = v11;
    goto LABEL_57;
  }

  uint64_t v39 = 0;
  CFTypeID v15 = v11;
LABEL_66:
  v48 = vm_dealloc(&__dst, v15, &v86);
  munmap(v10, v11);
  if ((v48 & v39 & 1) == 0) {
    goto LABEL_117;
  }
LABEL_90:
  *(_DWORD *)__int128 buf = -1;
  Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)buf, 0);
  else {
    double v71 = (const char *)*((void *)this + 18);
  }
  Security::UnixPlusPlus::FileDesc::open((Security::CodeSigning::MachOEditor *)((char *)this + 200), v71, 2, 438);
  Security::CodeSigning::UidGuard::~UidGuard((uid_t *)buf);
  BOOL v72 = operator new(0x50uLL);
  v80 = *((_DWORD *)this + 50);
  v81 = *((_BYTE *)this + 204);
  uint64_t result = Security::Universal::Universal((uint64_t)v72, &v80, 0LL, 0LL);
  *((void *)this + 24) = v72;
  return result;
}

          int v5 = 0;
        }

        goto LABEL_125;
      default:
        uint64_t v31 = (os_log_s *)secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          fts_info = v7->fts_info;
          fts_errno = v7->fts_errno;
          CFDataRef v53 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 67109634;
          HIDWORD(v84.__r_.__value_.__r.__words[0]) = fts_info;
          LOWORD(v84.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&v84.__r_.__value_.__r.__words[1] + 2) = fts_errno;
          HIWORD(v84.__r_.__value_.__r.__words[1]) = 2080;
          v84.__r_.__value_.__l.__cap_ = v53;
          _os_log_debug_impl(&dword_1804F4000, v31, OS_LOG_TYPE_DEBUG, "type %d (errno %d): %s", (uint8_t *)&v84, 0x18u);
        }

        if (!*(_BYTE *)(a1 + 89)) {
          goto LABEL_125;
        }
        uint64_t v61 = -67016;
        goto LABEL_144;
    }
  }

LABEL_124:
                if (!v103 || (v82 = *v103, v83 = (__SecTrust *)v106, *v103 == v106))
                {
LABEL_137:
                  if ((_DWORD)v23 != (_DWORD)BytePtr)
                  {
                    v88 = (os_log_s *)secLogObjForScope("SecWarning");
                    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)at = 67109376;
                      *(_DWORD *)&at[4] = v23;
                      *(_WORD *)&at[8] = 1024;
                      *(_DWORD *)&at[10] = BytePtr;
                      _os_log_impl( &dword_1804F4000,  v88,  OS_LOG_TYPE_DEFAULT,  "MessageSecurity and Security frameworks have different status results, returning Security result . sec: %d, ms: %d",  at,  0xEu);
                    }
                  }

                  CFTypeRef v89 = cf2;
                  if (cf2)
                  {
                    CFTypeRef cf2 = 0LL;
                    CFRelease(v89);
                  }

                  CFTypeRef v90 = cf;
                  if (cf)
                  {
                    CFTypeRef cf = 0LL;
                    CFRelease(v90);
                  }

                  CFTypeRef v91 = v106;
                  if (v106)
                  {
                    CFTypeRef v106 = 0LL;
                    CFRelease(v91);
                  }

                  return v23;
                }

                if (!v82 || !v106)
                {
LABEL_135:
                  v86 = (os_log_s *)secLogObjForScope("SecWarning");
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
                  {
                    SecTrustRef v87 = *v78;
                    *(_DWORD *)at = 138412546;
                    *(void *)&at[4] = v87;
                    *(_WORD *)&at[12] = 2112;
                    CFTypeRef v113 = v106;
                    _os_log_impl( &dword_1804F4000,  v86,  OS_LOG_TYPE_DEFAULT,  "MessageSecurity and Security frameworks have different trustref results, returning Security result . sec: %@, ms: %@",  at,  0x16u);
                  }

                  goto LABEL_137;
                }

                value = 0LL;
                *(void *)at = 0LL;
                if (SecTrustCopyInputCertificates((uint64_t)v82, at)
                  || SecTrustCopyInputCertificates((uint64_t)v83, &value))
                {
                  v84 = *(const void **)at;
                  if (!*(void *)at)
                  {
LABEL_132:
                    CFAbsoluteTime v85 = *(double *)&value;
                    if (!value) {
                      goto LABEL_135;
                    }
                    value = 0LL;
                    goto LABEL_134;
                  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v10;
  v76 = *(void *)(a1 + 32);
  uint64_t v77 = *(void *)(a1 + 48);
  if (*(_DWORD *)(*(void *)(v76 + 8) + 24LL))
  {
    CFAbsoluteTime v85 = MEMORY[0x1895F87A8];
    v86 = 0x40000000LL;
    SecTrustRef v87 = __SecOTRSProcessPacket_block_invoke_3;
    v88 = &unk_1896732B0;
    CFTypeRef v89 = v76;
    CFTypeRef v90 = v77;
    LODWORD(v91) = v7;
    if (v2)
    {
      v78 = *v8;
      v79 = CFDataGetLength(v2);
      v80 = CFStringCreateMutable(v78, 2 * v79);
      v81 = CFDataGetBytePtr(v2);
      v82 = CFDataGetLength(v2);
      if (v82 >= 1)
      {
        v83 = v82;
        do
        {
          v84 = *v81++;
          CFStringAppendFormat( v80,  0LL,  @"%02X",  v84,  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v92,  v93,  v94,  v95,  *(void *)buf,  *(void *)&buf[8],  *(_OWORD *)&buf[16],  v97);
          --v83;
        }

        while (v83);
      }
    }

    else
    {
      v80 = @"(null)";
    }

    __SecOTRSProcessPacket_block_invoke_3((uint64_t)&v85, (uint64_t)v80);
    CFRelease(v80);
    uint64_t v77 = *(void *)(a1 + 48);
  }

  if (*(_BYTE *)(v77 + 648)) {
    SecOTRPrepareOutgoingBytes(Mutable, *(__CFData **)(a1 + 56));
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t certArrayIsSubset(const __CFArray *a1, CFArrayRef theArray)
{
  if (a1 == theArray) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if (a1 && theArray)
  {
    CFIndex v5 = 0LL;
    do
    {
      CFIndex Count = CFArrayGetCount(theArray);
      BOOL v7 = v5 < Count;
      uint64_t result = v5 >= Count;
      if (!v7) {
        break;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      v9.size_t length = CFArrayGetCount(a1);
      v9.location = 0LL;
      uint64_t result = CFArrayContainsValue(a1, v9, ValueAtIndex);
      ++v5;
    }

    while ((_DWORD)result);
  }

  return result;
}

uint64_t SecCMSVerifySignedData( const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, const __CFArray *a5, uint64_t *a6, CFDictionaryRef *a7)
{
  values = 0LL;
  uint64_t v8 = SecCMSVerifySignedData_internal(a1, a2, a3, a4, a5, a6, (const __CFDictionary **)&values);
  CFRange v9 = values;
  if (a7 && !(_DWORD)v8 && values)
  {
    *a7 = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)&kSecCMSSignedAttributes,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFRange v9 = values;
  }

  if (v9) {
    CFRelease(v9);
  }
  return v8;
}

uint64_t SecCMSVerify(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, uint64_t *a5)
{
  return SecCMSVerifySignedData_internal(a1, a2, a3, a4, 0LL, a5, 0LL);
}

uint64_t SecCMSDecodeSignedData(const __CFData *a1, uint64_t *a2, const __CFDictionary **a3)
{
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3302);
  }
  if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound) {
    return SecCMSVerifySignedData_internal(a1, 0LL, 0LL, 0LL, 0LL, a2, a3);
  }
  else {
    return MS_SecCMSDecodeSignedData((uint64_t)a1, a2, (uint64_t)a3);
  }
}

CFArrayRef SecCMSCertificatesOnlyMessageCopyCertificates(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = (const __CFData *)a1;
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return Mutable;
  }
  id v2 = (const __CFArray *)MS_SecCMSCertificatesOnlyMessageCopyCertificates(a1);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1) {
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_3302);
  }
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound) {
    return v2;
  }
  uint64_t v22 = 0LL;
  v21[0] = CFDataGetLength(Mutable);
  v21[1] = CFDataGetBytePtr(Mutable);
  int v4 = SecCmsMessageDecode((uint64_t)v21, 0LL, 0LL, v3, 0LL, 0LL, 0LL, &v22);
  uint64_t v5 = v22;
  if (!v4)
  {
    if (!v22) {
      goto LABEL_21;
    }
    uint64_t OID = *(void *)(v22 + 32);
    if ((OID || (uint64_t OID = SECOID_FindOID(v22), (*(void *)(v5 + 32) = OID) != 0LL))
      && (*(_DWORD *)(OID + 16) == 26 ? (BOOL v7 = OID == 0) : (BOOL v7 = 1),
          !v7 && (uint64_t v8 = *(void *)(v5 + 16)) != 0 && ((v9 = *(void **)(v8 + 160)) == 0LL || !*v9)))
    {
      CFTypeID v15 = *(uint64_t **)(v8 + 144);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
      if (v15)
      {
        uint64_t v16 = *v15;
        if (*v15)
        {
          uint64_t v17 = v15 + 1;
          do
          {
            uint64_t v18 = SecCertificateCreateWithBytes(0LL, *(const void **)(v16 + 8), *(void *)v16);
            if (v18)
            {
              int v19 = v18;
              CFArrayAppendValue(Mutable, v18);
              CFRelease(v19);
            }

            uint64_t v20 = *v17++;
            uint64_t v16 = v20;
          }

          while (v20);
          if (!v5) {
            goto LABEL_18;
          }
        }
      }
    }

    else
    {
      CFMutableDictionaryRef Mutable = 0LL;
    }

    goto LABEL_17;
  }

  CFMutableDictionaryRef Mutable = 0LL;
  if (v22) {
LABEL_17:
  }
    SecCmsMessageDestroy(v5);
LABEL_18:
  if (!Mutable || CFArrayGetCount(Mutable) > 0) {
    goto LABEL_22;
  }
  CFRelease(Mutable);
LABEL_21:
  CFMutableDictionaryRef Mutable = 0LL;
LABEL_22:
  if (Mutable != v2)
  {
    if (v2 && Mutable && (CFIndex Count = CFArrayGetCount(Mutable), Count == CFArrayGetCount(v2)))
    {
      CFIndex v11 = 0LL;
      while (v11 < CFArrayGetCount(Mutable))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v11);
        v28.size_t length = CFArrayGetCount(v2);
        v28.location = 0LL;
        ++v11;
        if (!CFArrayContainsValue(v2, v28, ValueAtIndex)) {
          goto LABEL_29;
        }
      }
    }

    else
    {
LABEL_29:
      unint64_t v13 = (os_log_s *)secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        CFTypeRef v24 = Mutable;
        __int16 v25 = 2112;
        int v26 = v2;
        _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "MessageSecurity and Security frameworks have different results, returning Security result. sec: %@, ms: %@",  buf,  0x16u);
      }
    }
  }

  if (v2) {
    CFRelease(v2);
  }
  return Mutable;
}

CFMutableDataRef SecCMSCreateCertificatesOnlyMessage(void *a1)
{
  values = a1;
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = SecCmsMessageCreate();
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  uint64_t v4 = PORT_ArenaAlloc(*(void *)(v2 + 120), 0xB8uLL);
  CFMutableDataRef Mutable = (CFMutableDataRef)v4;
  if (v4)
  {
    *(void *)(v4 + 176) = 0LL;
    *(_OWORD *)(v4 + 144) = 0u;
    *(_OWORD *)(v4 + 160) = 0u;
    *(_OWORD *)(v4 + 112) = 0u;
    *(_OWORD *)(v4 + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v4 + 80) = 0u;
    *(_OWORD *)(v4 + 96) = 0u;
    *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v4 + 64) = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)uint64_t v4 = 0u;
    *(void *)(v4 + 24) = v3;
    if (!SecCmsContentInfoSetContentData((unint64_t *)v4, 0LL, 1)
      && !SecCmsContentInfoSetContent((unint64_t *)v3, 0x1Au, (unint64_t)Mutable)
      && SEC_ASN1EncodeInteger(*(void *)(v3 + 120), (void *)Mutable + 15, 1uLL))
    {
      CFTypeID v6 = CFGetTypeID(a1);
      if (v6 == SecCertificateGetTypeID())
      {
        BOOL v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605228]);
        goto LABEL_11;
      }

      CFTypeID v9 = CFGetTypeID(a1);
      if (v9 == CFArrayGetTypeID())
      {
        BOOL v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], (CFArrayRef)a1);
LABEL_11:
        BOOL v10 = Copy;
        if (Copy)
        {
          CFIndex Count = CFArrayGetCount(Copy);
          if (Count >= 1)
          {
            uint64_t v12 = Count;
            uint64_t v13 = PORT_ArenaAlloc(*(void *)(v3 + 120), 8 * Count + 8);
            *((void *)Mutable + 1_Block_object_dispose(va, 8) = v13;
            if (v13)
            {
              CFIndex v14 = 0LL;
              while (1)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v10, v14);
                if (!ValueAtIndex) {
                  break;
                }
                uint64_t v16 = ValueAtIndex;
                uint64_t v17 = (void *)PORT_ArenaAlloc(*(void *)(v3 + 120), 0x10uLL);
                if (v17)
                {
                  *uint64_t v17 = 0LL;
                  v17[1] = 0LL;
                }

                *(void *)(*((void *)Mutable + 18) + 8 * v14) = v17;
                uint64_t v18 = v16[2];
                int v19 = *(void **)(*((void *)Mutable + 18) + 8 * v14);
                *int v19 = v16[3];
                v19[1] = v18;
                if (v12 == ++v14)
                {
                  *(void *)(*((void *)Mutable + 18) + 8 * v12) = 0LL;
                  if (v12 >= 2) {
                    SecCmsArraySort(*((void **)Mutable + 18), 0LL, 0LL);
                  }
                  CFMutableDataRef Mutable = CFDataCreateMutable(v7, 0LL);
                  CFIndex v21 = 0LL;
                  uint64_t v22 = 0LL;
                  if (SEC_ASN1EncodeItem(*(void *)(v3 + 120), &v21, v3, (uint64_t)&SecCmsMessageTemplate))
                  {
                    CFDataAppendBytes(Mutable, v22, v21);
                    goto LABEL_23;
                  }

                  CFRelease(v10);
                  BOOL v10 = Mutable;
                  if (Mutable) {
                    goto LABEL_23;
                  }
                  goto LABEL_25;
                }
              }
            }
          }

          CFMutableDataRef Mutable = 0LL;
LABEL_23:
          CFRelease(v10);
          goto LABEL_25;
        }
      }
    }

    CFMutableDataRef Mutable = 0LL;
  }

__CFData *SecCMSCreateCertificatesOnlyMessageIAP(__SecCertificate *a1)
{
  id v1 = SecCertificateCopyData(a1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  uint64_t BytePtr = CFDataGetBytePtr(v1);
  CFIndex Length = CFDataGetLength(v2);
  if ((unint64_t)(Length - 0xFFFF) < 0xFFFFFFFFFFFF0101LL)
  {
    BOOL v7 = 0LL;
  }

  else
  {
    CFIndex v5 = Length;
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    BOOL v7 = Mutable;
    if (Mutable)
    {
      CFDataAppendBytes(Mutable, SecCMSCreateCertificatesOnlyMessageIAP_header, 45LL);
      CFDataAppendBytes(v7, BytePtr, v5);
      CFDataAppendBytes(v7, SecCMSCreateCertificatesOnlyMessageIAP_trailer, 4LL);
      Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(v7);
      __int16 v9 = CFDataGetLength(v7);
      MutableBytePtr[2] = (unsigned __int16)(v9 - 4) >> 8;
      MutableBytePtr[3] = v9 - 4;
      MutableBytePtr[17] = (unsigned __int16)(v9 - 19) >> 8;
      MutableBytePtr[18] = v9 - 19;
      MutableBytePtr[21] = (unsigned __int16)(v9 - 23) >> 8;
      MutableBytePtr[22] = v9 - 23;
      MutableBytePtr[43] = (unsigned __int16)(v9 - 49) >> 8;
      MutableBytePtr[44] = v9 - 49;
    }
  }

  CFRelease(v2);
  return v7;
}

uint64_t isModifyingAPIRateWithinLimits()
{
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v1 = [v0 isModifyingAPICallWithinLimits];

  return v1;
}

void *SecKeyCreateCTKKey(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex v5 = SecKeyCreate(a1, (uint64_t)&kSecCTKKeyDescriptor, 0LL, 0LL, 0LL);
  id v10 = 0LL;
  CFTypeID v6 = -[SecCTKKey initWithAttributes:error:]( objc_alloc(&OBJC_CLASS___SecCTKKey),  "initWithAttributes:error:",  a2,  &v10);
  id v7 = v10;
  uint64_t v8 = v7;
  if (v6)
  {
    v5[3] = v6;
  }

  else
  {
    CFIndex v5 = 0LL;
    if (a3) {
      *a3 = v7;
    }
  }

  return v5;
}

void SecCTKKeyDestroy(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x186DFF9D0]();

  objc_autoreleasePoolPop(v2);
}

uint64_t SecCTKKeyBlockSize(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  [v1 keychainAttributes];
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 objectForKeyedSubscript:@"bsiz"];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    uint64_t v4 = [v3 integerValue];
    uint64_t v5 = v4 + 7;
    if (v4 < -7) {
      uint64_t v5 = v4 + 14;
    }
    uint64_t v6 = v5 >> 3;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

uint64_t SecCTKKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (SecCTKKeyCopyAttributeDictionary_onceToken != -1) {
    dispatch_once(&SecCTKKeyCopyAttributeDictionary_onceToken, &__block_literal_global_8007);
  }
  +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a1);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  id v3 = objc_alloc_init(MEMORY[0x189603FC8]);
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  id v4 = (id)SecCTKKeyCopyAttributeDictionary_exportableAttributes;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v26;
    do
    {
      for (uint64_t i = 0LL; i != v6; ++i)
      {
        if (*(void *)v26 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v25 + 1) + 8 * i);
        objc_msgSend(v2, "keychainAttributes", (void)v25);
        id v10 = (void *)objc_claimAutoreleasedReturnValue();
        [v10 objectForKeyedSubscript:v9];
        CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue();

        if (v11) {
          [v3 setObject:v11 forKeyedSubscript:v9];
        }
      }

      uint64_t v6 = [v4 countByEnumeratingWithState:&v25 objects:v29 count:16];
    }

    while (v6);
  }

  [v2 tokenObject];
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  [v12 publicKey];
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();

  CFIndex v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  id v15 = v13;
  uint64_t v16 = SecSHA1DigestCreate(v14, [v15 bytes], objc_msgSend(v15, "length"));
  [v3 setObject:v16 forKeyedSubscript:@"klbl"];

  [v3 setObject:MEMORY[0x189604A88] forKeyedSubscript:@"perm"];
  [v2 tokenObject];
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  [v17 session];
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
  [v18 token];
  int v19 = (void *)objc_claimAutoreleasedReturnValue();
  [v19 tokenID];
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v20 forKeyedSubscript:@"tkid"];

  [v2 tokenObject];
  CFIndex v21 = (void *)objc_claimAutoreleasedReturnValue();
  [v21 objectID];
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 setObject:v22 forKeyedSubscript:@"toid"];

  uint64_t v23 = [v3 copy];
  return v23;
}

id SecCTKKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  [v2 keychainAttributes];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = [v3 objectForKeyedSubscript:@"tkid"];
  uint64_t v5 = (void *)v4;
  uint64_t v6 = @"uninited";
  if (v4) {
    uint64_t v6 = (__CFString *)v4;
  }
  uint64_t v7 = v6;

  [NSString stringWithFormat:@"<SecKeyRef:('%@') %p>", v7, a1];
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();

  id v9 = v8;
  return v9;
}

uint64_t SecCTKGetAlgorithmID(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v2 = [v1 algorithmID];

  return v2;
}

uint64_t SecCTKKeyCopyPublicOctets(uint64_t a1, uint64_t *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  [v3 tokenObject];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *a2 = [v4 publicKey];

  return 0LL;
}

uint64_t SecCTKKeyCopyOperationResult( uint64_t a1, unint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  if (a2 < 7 && ((0x59u >> a2) & 1) != 0)
  {
    uint64_t v13 = qword_180654AB0[a2];
    +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a1);
    CFIndex v14 = (void *)objc_claimAutoreleasedReturnValue();
    [v14 tokenObject];
    id v15 = (void *)objc_claimAutoreleasedReturnValue();
    [v15 session];
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    [v16 setAuthenticateWhenNeeded:1];

    [v14 tokenObject];
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    id v20 = 0LL;
    uint64_t v9 = [v17 operation:v13 data:a6 algorithms:a4 parameters:a7 error:&v20];
    id v18 = v20;

    if (a8 && !v9) {
      *a8 = (__CFString *)v18;
    }
  }

  else
  {
    SecError(-50, a8, @"Invalid key operation %d", a2);
    return 0LL;
  }

  return v9;
}

uint64_t SecCTKKeyIsEqual(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v5 = [v3 isEqual:v4];

  return v5;
}

void *SecCTKKeyCreateDuplicate(const void *a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  CFAllocatorRef v3 = CFGetAllocator(a1);
  uint64_t v4 = SecKeyCreate((uint64_t)v3, (uint64_t)&kSecCTKKeyDescriptor, 0LL, 0LL, 0LL);
  v4[3] = [v2 copy];

  return v4;
}

uint64_t SecCTKKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a1);
  CFTypeRef v36 = (void *)objc_claimAutoreleasedReturnValue();
  [v36 sessionParameters];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = (void *)[v6 mutableCopy];

  [v7 setObject:a3 forKeyedSubscript:a2];
  id v8 = v7;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  id obj = (id)[v8 copy];
  uint64_t v9 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    id v11 = 0LL;
    uint64_t v12 = *(void *)v41;
    do
    {
      for (uint64_t i = 0LL; i != v10; ++i)
      {
        if (*(void *)v41 != v12) {
          objc_enumerationMutation(obj);
        }
        CFIndex v14 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        [v8 objectForKeyedSubscript:v14];
        id v15 = (void *)objc_claimAutoreleasedReturnValue();
        if ([v14 isEqual:@"u_AuthCtx"])
        {
          id v16 = v15;

          [v8 removeObjectForKey:v14];
          id v11 = v16;
        }

        if ([v14 isEqual:@"u_CredRef"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            uint64_t v17 = [objc_alloc((Class)getLAContextClass()) initWithExternalizedContext:v15];

            id v11 = (id)v17;
          }

          [v8 removeObjectForKey:v14];
        }

        if (LocalAuthenticationLibraryCore() && [v14 isEqual:@"u_CallerName"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v11) {
              id v11 = objc_alloc_init((Class)getLAContextClass());
            }
            [v11 setOptionCallerName:v15];
          }

          [v8 removeObjectForKey:v14];
        }

        if ([v14 isEqual:@"u_AuthUI"])
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v11) {
              id v11 = objc_alloc_init((Class)getLAContextClass());
            }
            objc_msgSend(MEMORY[0x189607968], "numberWithBool:", objc_msgSend(v15, "isEqual:", @"u_AuthUIF"));
            id v18 = (void *)objc_claimAutoreleasedReturnValue();
            [v11 setOptionNotInteractive:v18];
          }

          [v8 removeObjectForKey:v14];
        }
      }

      uint64_t v10 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
    }

    while (v10);
  }

  else
  {
    id v11 = 0LL;
  }

  if (CryptoTokenKitLibraryCore())
  {
    id v19 = objc_alloc((Class)getTKClientTokenSessionClass());
    id v20 = v36;
    [v36 tokenObject];
    CFIndex v21 = (void *)objc_claimAutoreleasedReturnValue();
    [v21 session];
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    [v22 token];
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    id v39 = 0LL;
    CFTypeRef v24 = (void *)[v19 initWithToken:v23 LAContext:v11 parameters:v8 error:&v39];
    id v25 = v39;

    [v36 tokenObject];
    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue();
    [v26 objectID];
    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue();
    id v38 = v25;
    [v24 objectForObjectID:v27 error:&v38];
    __int128 v28 = (void *)objc_claimAutoreleasedReturnValue();
    id v29 = v38;

    if (v28)
    {
      [v36 setSessionParameters:v8];
      [v36 setTokenObject:v28];

      uint64_t v30 = 1LL;
      goto LABEL_36;
    }
  }

  else
  {
    uint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607670];
    uint64_t v44 = *MEMORY[0x189607490];
    CFDataRef v45 = @"CryptoTokenKit is not available";
    [MEMORY[0x189603F68] dictionaryWithObjects:&v45 forKeys:&v44 count:1];
    int v33 = (void *)objc_claimAutoreleasedReturnValue();
    [v31 errorWithDomain:v32 code:-4 userInfo:v33];
    id v29 = (id)objc_claimAutoreleasedReturnValue();

    id v20 = v36;
  }

  if (a4)
  {
    id v29 = v29;
    uint64_t v30 = 0LL;
    *a4 = v29;
  }

  else
  {
    uint64_t v30 = 0LL;
  }

void __SecCTKKeyCopyAttributeDictionary_block_invoke()
{
  v2[22] = *MEMORY[0x1895F89C0];
  v2[0] = @"class";
  v2[1] = @"tkid";
  v2[2] = @"kcls";
  v2[3] = @"accc";
  v2[4] = @"priv";
  v2[5] = @"modi";
  v2[6] = @"type";
  v2[7] = @"bsiz";
  v2[8] = @"esiz";
  v2[9] = @"sens";
  v2[10] = @"asen";
  v2[11] = @"extr";
  v2[12] = @"next";
  v2[13] = @"encr";
  v2[14] = @"decr";
  v2[15] = @"drve";
  v2[16] = @"sign";
  v2[17] = @"vrfy";
  v2[18] = @"snrc";
  v2[19] = @"vyrc";
  v2[20] = @"wrap";
  v2[21] = @"unwp";
  uint64_t v0 = [MEMORY[0x189603F18] arrayWithObjects:v2 count:22];
  uint64_t v1 = (void *)SecCTKKeyCopyAttributeDictionary_exportableAttributes;
  SecCTKKeyCopyAttributeDictionary_exportableAttributes = v0;
}

void *SecKeyCopySystemKey(uint64_t a1, __CFString **a2)
{
  switch((int)a1)
  {
    case 0:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sikObjectIDBytes;
      goto LABEL_5;
    case 1:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_gidObjectIDBytes;
LABEL_5:
      uint64_t v6 = v3;
      CFIndex v7 = 23LL;
      goto LABEL_21;
    case 2:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_uikCommittedObjectIDBytes;
      goto LABEL_20;
    case 3:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_uikProposedObjectIDBytes;
      goto LABEL_20;
    case 4:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], SecKeyCopySystemKey_casdObjectIDBytes, 29LL);
      goto LABEL_22;
    case 5:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_oikCommittedObjectIDBytes;
      goto LABEL_20;
    case 6:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_oikProposedObjectIDBytes;
      goto LABEL_20;
    case 7:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dakCommittedObjectIDBytes;
      goto LABEL_20;
    case 8:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dakProposedObjectIDBytes;
      goto LABEL_20;
    case 9:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_havenCommittedObjectIDBytes;
      goto LABEL_15;
    case 10:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_havenProposedObjectIDBytes;
LABEL_15:
      uint64_t v6 = v3;
      CFIndex v7 = 26LL;
      goto LABEL_21;
    case 11:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakCommittedObjectIDBytes;
      goto LABEL_18;
    case 12:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakProposedObjectIDBytes;
LABEL_18:
      uint64_t v6 = v3;
      CFIndex v7 = 25LL;
      goto LABEL_21;
    case 13:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v4 = (const UInt8 *)&SecKeyCopySystemKey_dcikObjectIDBytes;
LABEL_20:
      uint64_t v6 = v3;
      CFIndex v7 = 24LL;
LABEL_21:
      CFDataRef v15 = CFDataCreate(v6, v4, v7);
LABEL_22:
      CFDictionaryRef v16 = CFDictionaryCreateForCFTypes(v3, v8, v9, v10, v11, v12, v13, v14, (uint64_t)@"toid", (uint64_t)v15);
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      CTKKey = SecKeyCreateCTKKey(SecCFAllocatorZeroize_sAllocator, (uint64_t)v16, a2);
      if (v16) {
        CFRelease(v16);
      }
      if (v15) {
        CFRelease(v15);
      }
      break;
    default:
      SecError(-50, a2, @"unexpected system key type %d", a1);
      CTKKey = 0LL;
      break;
  }

  return CTKKey;
}

uint64_t SecKeyCreateAttestation(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v7 = _os_activity_create(&dword_1804F4000, "SecKeyCreateAttestation", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateAttestation");
  +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a1);
  int v8 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a2);
  int v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    if (*(_UNKNOWN **)(a2 + 16) == &kSecCTKKeyDescriptor)
    {
      [v8 tokenObject];
      int v12 = (void *)objc_claimAutoreleasedReturnValue();
      [v9 tokenObject];
      int v13 = (void *)objc_claimAutoreleasedReturnValue();
      [v8 sessionParameters];
      int v14 = (void *)objc_claimAutoreleasedReturnValue();
      [v14 objectForKeyedSubscript:@"com.apple.security.seckey.setoken.attestation-nonce"];
      CFDataRef v15 = (void *)objc_claimAutoreleasedReturnValue();
      id v18 = 0LL;
      uint64_t v10 = [v12 attestKeyObject:v13 nonce:v15 error:&v18];
      id v17 = v18;

      id v16 = v17;
      _SecKeyErrorPropagate(v10 != 0, (uint64_t)"SecKeyCreateAttestation", v16, a3);

      goto LABEL_6;
    }

    SecError(-4, a3, @"attestation not supported for key %@", a2);
  }

  else
  {
    SecError(-4, a3, @"attestation not supported by key %@", a1);
  }

  uint64_t v10 = 0LL;
LABEL_6:

  os_activity_scope_leave(&state);
  objc_autoreleasePoolPop(v6);
  return v10;
}

void sub_1805AF3E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

BOOL SecKeyControlLifetime(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v7 = _os_activity_create(&dword_1804F4000, "SecKeyControlLifetime", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyControlLifetime");
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    +[SecCTKKey fromKeyRef:](&OBJC_CLASS___SecCTKKey, "fromKeyRef:", a1);
    int v9 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v10 = v9;
    if ((_DWORD)a2)
    {
      if ((_DWORD)a2 != 1)
      {
        BOOL v8 = SecError(-50, a3, @"Unsupported lifetime operation %d requested", a2);
        id v15 = 0LL;
        goto LABEL_9;
      }

      [v9 tokenObject];
      int v11 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = 0LL;
      int v12 = (id *)&v17;
      uint64_t v13 = [v11 commitKeyWithError:&v17];
    }

    else
    {
      [v9 tokenObject];
      int v11 = (void *)objc_claimAutoreleasedReturnValue();
      uint64_t v18 = 0LL;
      int v12 = (id *)&v18;
      uint64_t v13 = [v11 bumpKeyWithError:&v18];
    }

    BOOL v8 = v13;
    id v14 = *v12;

    id v15 = v14;
    _SecKeyErrorPropagate(v8, (uint64_t)"SecKeyControlLifetime", v15, a3);
LABEL_9:

    goto LABEL_10;
  }

  BOOL v8 = SecError(-4, a3, @"lifetimecontrol not supported for key %@", a1);
LABEL_10:
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_1805AF5A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

CFDictionaryRef __SecCertificateGetTypeID_block_invoke(uint64_t a1)
{
  **(void **)(a1 + 32) = _CFRuntimeRegisterClass();
  CFDictionaryRef result = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)SecCertificateInitializeExtensionParsers_extnOIDs,  (const void **)SecCertificateInitializeExtensionParsers_extnParsers,  20LL,  &SecDERItemKeyCallBacks,  0LL);
  sExtensionParsers = (uint64_t)result;
  return result;
}

uint64_t SecCEPPrivateKeyUsagePeriod()
{
  return 1LL;
}

uint64_t SecCEPIssuerAltName()
{
  return 1LL;
}

uint64_t SecCEPNameConstraints(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v8 = v3;
  __int128 v9 = v3;
  if (!DERParseSequence( a2 + 24,  (unsigned __int16)DERNumNameConstraintsItemSpecs,  (uint64_t)&DERNameConstraintsItemSpecs,  (unint64_t)&v8,  0x20uLL)
    && (!*((void *)&v8 + 1) || !parseGeneralSubtrees((unint64_t *)&v8, (CFTypeRef *)(a1 + 488)))
    && (!*((void *)&v9 + 1) || !parseGeneralSubtrees((unint64_t *)&v9, (CFTypeRef *)(a1 + 496))))
  {
    return 1LL;
  }

  uint64_t v5 = (os_log_s *)secLogObjForScope("SecWarning");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v6)
  {
    *(_WORD *)CFIndex v7 = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Invalid Name Constraints extension", v7, 2u);
    return 0LL;
  }

  return result;
}

uint64_t SecCEPPolicyMappings(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 24;
  memset(v19, 170, sizeof(v19));
  unint64_t v5 = 0LL;
  memset(v18, 170, sizeof(v18));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v19, v18);
    if (v6) {
      break;
    }
    if (v18[0] != 0x2000000000000010LL || v5++ >= 0x1FFF) {
      goto LABEL_10;
    }
  }

  if (!v5) {
    goto LABEL_10;
  }
  if (v6 != 1) {
    goto LABEL_10;
  }
  id v15 = malloc(32 * v5);
  if (!v15) {
    goto LABEL_10;
  }
  if (DERDecodeSeqInit(v4, &v19[2], v19))
  {
LABEL_23:
    free(v15);
LABEL_10:
    *(_BYTE *)(a1 + 32_Block_object_dispose(va, 8) = 0;
    __int128 v8 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v9)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "Invalid PolicyMappings Extension", buf, 2u);
      return 0LL;
    }

    return result;
  }

  int v11 = v15 + 1;
  unint64_t v12 = v5;
  do
  {
    if (v18[0] != 0x2000000000000010LL) {
      goto LABEL_23;
    }
    *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)__int128 buf = v13;
    __int128 v17 = v13;
    if (DERParseSequenceContent( &v18[1],  (unsigned __int16)DERNumPolicyMappingItemSpecs,  (uint64_t)&DERPolicyMappingItemSpecs,  (unint64_t)buf,  0x20uLL)) {
      goto LABEL_23;
    }
    __int128 v14 = v17;
    *(v11 - 1) = *(_OWORD *)buf;
    _OWORD *v11 = v14;
    v11 += 2;
    --v12;
  }

  while (v12);
  uint64_t result = 1LL;
  *(_BYTE *)(a1 + 32_Block_object_dispose(va, 8) = 1;
  *(_BYTE *)(a1 + 329) = *(_BYTE *)(a2 + 16);
  *(void *)(a1 + 336) = v5;
  *(void *)(a1 + 344) = v15;
  return result;
}

uint64_t SecCEPPolicyConstraints(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v9 = v4;
  __int128 v10 = v4;
  if (DERParseSequence( a2 + 24,  (unsigned __int16)DERNumPolicyConstraintsItemSpecs,  (uint64_t)&DERPolicyConstraintsItemSpecs,  (unint64_t)&v9,  0x20uLL)) {
    goto LABEL_10;
  }
  if (*((void *)&v9 + 1))
  {
    *(_BYTE *)(a1 + 310) = 1;
  }

  if (!*((void *)&v10 + 1))
  {
LABEL_8:
    uint64_t result = 1LL;
    *(_BYTE *)(a1 + 30_Block_object_dispose(va, 8) = 1;
    *(_BYTE *)(a1 + 309) = *(_BYTE *)(a2 + 16);
    return result;
  }

  if (!DERParseInteger((char **)&v10, (_DWORD *)(a1 + 320)))
  {
    *(_BYTE *)(a1 + 316) = 1;
    goto LABEL_8;
  }

uint64_t SecCEPInhibitAnyPolicy(uint64_t a1, uint64_t a2)
{
  if (DERDecodeItem(a2 + 24, v8)
    || v8[0] != 2
    || DERParseInteger((char **)&v8[1], (_DWORD *)(a1 + 380)))
  {
    *(_BYTE *)(a1 + 376) = 0;
    unint64_t v5 = (os_log_s *)secLogObjForScope("SecWarning");
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v6)
    {
      *(_WORD *)BOOL v7 = 0;
      _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Invalid InhibitAnyPolicy Extension", v7, 2u);
      return 0LL;
    }
  }

  else
  {
    uint64_t result = 1LL;
    *(_BYTE *)(a1 + 376) = 1;
    *(_BYTE *)(a1 + 377) = *(_BYTE *)(a2 + 16);
  }

  return result;
}

uint64_t SecCEPSubjectInfoAccess()
{
  return 1LL;
}

uint64_t SecCEPNetscapeCertType()
{
  return 1LL;
}

uint64_t SecCEPEntrustVersInfo()
{
  return 1LL;
}

uint64_t SecCEPEscrowMarker()
{
  return 1LL;
}

uint64_t SecCEPOCSPNoCheck()
{
  return 1LL;
}

CFDataRef parseGeneralSubtrees(unint64_t *a1, CFTypeRef *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  v18[0] = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = 0xAAAAAAAAAAAAAAAALL;
  __int128 v3 = DERDecodeSeqContentInit(a1, v18);
  if ((_DWORD)v3) {
    return (CFDataRef)v3;
  }
  memset(v17, 170, sizeof(v17));
  __int128 v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (!Mutable) {
    return 0LL;
  }
  CFMutableArrayRef v6 = Mutable;
  for (int i = 0x2000; ; --i)
  {
    uint64_t v8 = DERDecodeSeqNext(v18, v17);
    if ((_DWORD)v8 == 1) {
      goto LABEL_18;
    }
    CFDataRef v9 = (CFDataRef)v8;
    if ((_DWORD)v8) {
      goto LABEL_23;
    }
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v15 = v10;
    __int128 v16 = v10;
    *(_OWORD *)bytes = v10;
    if (v17[0] != 0x2000000000000010LL)
    {
LABEL_22:
      CFDataRef v9 = 0LL;
LABEL_23:
      CFRelease(v6);
      return v9;
    }

    int v11 = DERParseSequenceContent( &v17[1],  (unsigned __int16)DERNumGeneralSubtreeItemSpecs,  (uint64_t)&DERGeneralSubtreeItemSpecs,  (unint64_t)bytes,  0x30uLL);
    if ((_DWORD)v11)
    {
      CFDataRef v9 = (CFDataRef)v11;
      goto LABEL_23;
    }

    if (*((void *)&v15 + 1))
    {
      *(_DWORD *)__int128 buf = -1431655766;
    }

    CFDataRef v9 = CFDataCreate(v4, bytes[0], (CFIndex)bytes[1]);
    if (!v9) {
      goto LABEL_23;
    }
    CFArrayAppendValue(v6, v9);
    CFRelease(v9);
    if (!i) {
      break;
    }
  }

  unint64_t v12 = (os_log_s *)secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v20 = 0x2000;
    _os_log_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEFAULT, "Skipping subtrees after the first %d", buf, 8u);
  }

BOOL SecCertificateEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  size_t v2 = *(void *)(a1 + 24);
  return v2 == *(void *)(a2 + 24) && memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) == 0;
}

unint64_t SecCertificateHash(void *a1)
{
  unint64_t v1 = 0LL;
  unint64_t v2 = a1[11];
  unint64_t v3 = v2 - 4;
  if (v2 < 4) {
    unint64_t v3 = 0LL;
  }
  if (v3 < v2)
  {
    unint64_t v1 = 0LL;
    uint64_t v4 = 4LL;
    if (v2 < 4) {
      uint64_t v4 = a1[11];
    }
    uint64_t v5 = -v4;
    do
      unint64_t v1 = *(unsigned __int8 *)(a1[10] + v2 + v5) | (v1 << 8);
    while (!__CFADD__(v5++, 1LL));
  }

  return v2 + a1[3] + v1;
}

CFStringRef SecCertificateCopyDescription(__SecCertificate *a1)
{
  CFStringRef v2 = SecCertificateCopySubjectSummary(a1);
  CFTypeRef v3 = SecCertificateCopyIssuerSummary((uint64_t)a1);
  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<cert(%p) s: %@ i: %@>", a1, v2, v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

CFStringRef SecCertificateCopySubjectSummary(CFStringRef certificate)
{
  if (certificate)
  {
    CFStringRef v1 = certificate;
    uint64_t v8 = 0LL;
    CFTypeRef cf = 0LL;
    CFTypeRef v10 = 0LL;
    int v2 = parseX501NameContent( (unint64_t *)&certificate[5].length,  (uint64_t)&v8,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))obtainSummaryFromX501Name,  1LL);
    certificate = 0LL;
    if (!v2)
    {
      CFTypeRef v3 = v10;
      if (v10)
      {
        if ((_DWORD)v8 == 4)
        {
          CFStringRef v4 = SecFrameworkCopyLocalizedString(@"%@ (%@)", @"Certificate");
          CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v4, cf, v10);
          CFRelease(v4);
          CFRelease(cf);
          CFTypeRef cf = v5;
          CFTypeRef v3 = v10;
        }

        CFRelease(v3);
      }

      if ((_DWORD)v8 != 4)
      {
        CFMutableArrayRef v6 = SecCertificateCopyRFC822Names((uint64_t)v1);
        if (v6 || (CFMutableArrayRef v6 = SecCertificateCopyDNSNames((uint64_t)v1)) != 0LL)
        {
          CFTypeRef v7 = cf;
          if (cf)
          {
            CFTypeRef cf = 0LL;
            CFRelease(v7);
          }

          CFTypeRef cf = CFArrayGetValueAtIndex(v6, 0LL);
          CFRetain(cf);
          CFRelease(v6);
        }
      }

      return (CFStringRef)cf;
    }
  }

  return certificate;
}

CFTypeRef SecCertificateCopyIssuerSummary(uint64_t a1)
{
  uint64_t v6 = 0LL;
  CFTypeRef cf = 0LL;
  CFTypeRef v8 = 0LL;
  int v1 = parseX501NameContent( (unint64_t *)(a1 + 152),  (uint64_t)&v6,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))obtainSummaryFromX501Name,  1LL);
  CFTypeRef result = 0LL;
  if (!v1)
  {
    CFTypeRef v3 = v8;
    if (v8)
    {
      if ((_DWORD)v6 == 4)
      {
        CFStringRef v4 = SecFrameworkCopyLocalizedString(@"%@ (%@)", @"Certificate");
        CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v4, cf, v8);
        CFRelease(v4);
        CFRelease(cf);
        CFTypeRef cf = v5;
        CFTypeRef v3 = v8;
      }

      CFRelease(v3);
    }

    return cf;
  }

  return result;
}

uint64_t obtainSummaryFromX501Name(unsigned int *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  if (DEROidCompare(a2, (uint64_t)&oidCommonName))
  {
    CFDataRef v9 = 0LL;
    unsigned int v10 = 4;
    goto LABEL_18;
  }

  if (DEROidCompare(a2, (uint64_t)&oidOrganizationalUnitName))
  {
    CFDataRef v9 = 0LL;
    unsigned int v10 = 3;
    goto LABEL_18;
  }

  if (DEROidCompare(a2, (uint64_t)&oidOrganizationName))
  {
    CFDataRef v9 = 0LL;
    unsigned int v10 = 2;
    goto LABEL_18;
  }

  if (DEROidCompare(a2, (uint64_t)&oidDescription))
  {
    int v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    unint64_t v12 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    CFDataRef v9 = v12;
    if (!v12)
    {
      unsigned int v10 = 0;
      goto LABEL_18;
    }

    uint64_t v13 = *((void *)a1 + 2);
    if (v13)
    {
      if (a5)
      {
        __int128 v14 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate");
        CFStringRef v15 = CFStringCreateWithFormat(v11, 0LL, v14, v9, *((void *)a1 + 2));
      }

      else
      {
        __int128 v14 = @"%@, %@";
        CFStringRef v15 = CFStringCreateWithFormat(v11, 0LL, @"%@, %@", v12, v13);
      }

      CFStringRef v16 = v15;
      CFRelease(v14);
      CFRelease(*((CFTypeRef *)a1 + 2));
      *((void *)a1 + 2) = v16;
    }

    else
    {
      *((void *)a1 + 2) = v12;
      CFRetain(v12);
    }
  }

  else
  {
    CFDataRef v9 = 0LL;
  }

  unsigned int v10 = 1;
LABEL_18:
  unsigned int v17 = *a1;
  if (*a1 <= v10)
  {
    if (!v9)
    {
      uint64_t v18 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
      if (!v18) {
        return 0LL;
      }
      CFDataRef v9 = v18;
      unsigned int v17 = *a1;
    }

    if (v17 == v10)
    {
      if (a5)
      {
        id v19 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate");
        CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v19, v9, *((void *)a1 + 1));
      }

      else
      {
        id v19 = @"%@, %@";
        CFStringRef v20 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"%@, %@",  v9,  *((void *)a1 + 1));
      }

      CFStringRef v21 = v20;
      CFRelease(v19);
      CFRelease(v9);
      CFDataRef v9 = (__CFString *)v21;
    }

    else
    {
      *a1 = v10;
    }

    uint64_t v22 = (const void *)*((void *)a1 + 1);
    if (v22) {
      CFRelease(v22);
    }
    *((void *)a1 + 1) = v9;
  }

  else if (v9)
  {
    CFRelease(v9);
  }

  return 0LL;
}

uint64_t parseX501NameContent( unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t), uint64_t a4)
{
  LODWORD(v7) = -1431655766;
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v8 = 0;
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    int v9 = DERDecodeSeqNext(v15, v14);
    if (v9) {
      break;
    }
    if (v14[0] != 0x2000000000000011LL || v14[2] == 0) {
      return 4294941021LL;
    }
    unsigned int v11 = parseRDNContent(&v14[1], a2, a3, a4);
    int v12 = 4 * (v8 > 0x3FE);
    if (v11) {
      uint64_t v7 = v11;
    }
    else {
      uint64_t v7 = v7;
    }
    if (v11) {
      int v12 = 1;
    }
    else {
      ++v8;
    }
    if (v12)
    {
      if (v12 != 4) {
        return v7;
      }
      return 4294941021LL;
    }
  }

  if (v9 != 1) {
    return 4294941021LL;
  }
  return 0LL;
}

uint64_t parseRDNContent( unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t), uint64_t a4)
{
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = 0LL;
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    int v8 = DERDecodeSeqNext(v15, v14);
    if (v8) {
      break;
    }
    if (v14[0] != 0x2000000000000010LL) {
      return 4294941021LL;
    }
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v12 = v9;
    __int128 v13 = v9;
    if (DERParseSequenceContent( &v14[1],  (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs,  (uint64_t)&DERAttributeTypeAndValueItemSpecs,  (unint64_t)&v12,  0x20uLL)
      || *((void *)&v12 + 1) == 0LL)
    {
      return 4294941021LL;
    }

    uint64_t result = a3(a2, &v12, &v13, v7++, a4);
    if ((_DWORD)result) {
      return result;
    }
  }

  if (v8 == 1) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFString *copyDERThingDescription(const __CFAllocator *a1, unsigned __int8 **a2, char a3, int a4)
{
  if ((a3 & 1) != 0) {
    return 0LL;
  }
  return copyHexDescription(a1, a2);
}

__CFString *copyHexDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2 = (unint64_t)a2[1];
  if (v2 > 0x2AAAAAAAAAAAAAA9LL) {
    return 0LL;
  }
  CFMutableArrayRef Mutable = CFStringCreateMutable(a1, 3 * v2 - 1);
  if (v2)
  {
    for (uint64_t i = 0LL; i != v2; ++i)
    {
      if (i) {
        CFStringAppendFormat(Mutable, 0LL, @" %02X", (*a2)[i]);
      }
      else {
        CFStringAppendFormat(Mutable, 0LL, @"%02X", **a2);
      }
    }
  }

  return Mutable;
}

CFStringRef copyDERThingContentDescription(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!a3) {
    return 0LL;
  }
  switch(a2)
  {
    case 1LL:
    case 2LL:
      return copyIntegerContentDescription(a1, a3);
    case 3LL:
      __int128 v9 = @"Bit string";
      __int128 v12 = @"bits";
      return copyBlobString(a1, v9, v12, a3, a4);
    case 4LL:
      __int128 v9 = @"Byte string";
      goto LABEL_19;
    case 5LL:
    case 7LL:
    case 8LL:
    case 9LL:
    case 10LL:
    case 11LL:
    case 13LL:
    case 14LL:
    case 15LL:
    case 16LL:
    case 17LL:
    case 18LL:
    case 23LL:
    case 24LL:
    case 25LL:
    case 29LL:
      goto LABEL_10;
    case 6LL:
      return copyOidDescription(a1, a3, a4);
    case 12LL:
    case 27LL:
    case 28LL:
      uint64_t v7 = a3;
      CFStringEncoding v8 = 134217984;
      return copyContentString(a1, v7, v8);
    case 19LL:
    case 22LL:
      uint64_t v7 = a3;
      CFStringEncoding v8 = 1536;
      return copyContentString(a1, v7, v8);
    case 20LL:
    case 21LL:
    case 26LL:
      uint64_t v7 = a3;
      CFStringEncoding v8 = 513;
      return copyContentString(a1, v7, v8);
    case 30LL:
      uint64_t v7 = a3;
      CFStringEncoding v8 = 256;
      return copyContentString(a1, v7, v8);
    default:
      if (a2 == 0x2000000000000010LL)
      {
        __int128 v9 = @"Sequence";
LABEL_19:
        __int128 v12 = @"bytes";
        return copyBlobString(a1, v9, v12, a3, a4);
      }

      if (a2 == 0x2000000000000011LL)
      {
        __int128 v9 = @"Set";
        goto LABEL_19;
      }

__CFString *copyIntegerContentDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  unint64_t v4 = 0LL;
  CFStringRef v5 = *(unsigned __int8 **)a2;
  do
  {
    unsigned int v6 = *v5++;
    unint64_t v4 = v6 | (v4 << 8);
    --v2;
  }

  while (v2);
  return (__CFString *)CFStringCreateWithFormat(a1, 0LL, @"%llu", v4);
}

__CFString *copyContentString(CFAllocatorRef alloc, uint64_t a2, CFStringEncoding encoding)
{
  unsigned int v6 = *(const UInt8 **)a2;
  CFIndex v7 = *(void *)(a2 + 8);
  if (v7)
  {
    if (v6[v7 - 1]) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = encoding == 256;
    }
    if (v9) {
      CFIndex v10 = v7;
    }
    else {
      CFIndex v10 = v7 - 1;
    }
    if (v10 < 0) {
      return 0LL;
    }
  }

  else
  {
    CFIndex v10 = 0LL;
  }

  CFStringRef result = (__CFString *)CFStringCreateWithBytes(alloc, v6, v10, encoding, encoding == 256);
  if (!result) {
    return copyHexDescription(alloc, (unsigned __int8 **)a2);
  }
  return result;
}

CFStringRef copyBlobString( const __CFAllocator *a1, const __CFString *cf, const __CFString *a3, uint64_t a4, char a5)
{
  CFStringRef v7 = cf;
  if ((a5 & 1) != 0)
  {
    CFStringRef v7 = SecFrameworkCopyLocalizedString(cf, @"Certificate");
    a3 = SecFrameworkCopyLocalizedString(a3, @"Certificate");
    BOOL v9 = SecFrameworkCopyLocalizedString(@"%@; %d %@; data = %@", @"Certificate");
  }

  else
  {
    if (cf) {
      CFRetain(cf);
    }
    if (a3) {
      CFRetain(a3);
    }
    BOOL v9 = @"%@; %d %@; data = %@";
  }

  CFIndex v10 = copyHexDescription(a1, (unsigned __int8 **)a4);
  CFStringRef v11 = CFStringCreateWithFormat(a1, 0LL, v9, v7, *(void *)(a4 + 8), a3, v10);
  CFRelease(v10);
  CFRelease(v9);
  if (a3) {
    CFRelease(a3);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v11;
}

CFStringRef copyOidDescription(const __CFAllocator *a1, uint64_t a2, int a3)
{
  if (a2 && *(void *)(a2 + 8))
  {
    CFStringRef v6 = SecDERItemCopyOIDDecimalRepresentation(a1, (unsigned __int8 **)a2);
    if (!a3) {
      return v6;
    }
    unint64_t v7 = *(void *)(a2 + 8);
    if (v7 > 0x2AAAAAAAAAAAAAA5LL) {
      return v6;
    }
    CFMutableStringRef Mutable = CFStringCreateMutable(a1, 3 * v7 + 5);
    CFStringAppendFormat(Mutable, 0LL, @"06 %02lX", *(void *)(a2 + 8));
    if (*(void *)(a2 + 8))
    {
      unint64_t v9 = 0LL;
      do
        CFStringAppendFormat(Mutable, 0LL, @" %02X", *(unsigned __int8 *)(*(void *)a2 + v9++));
      while (v9 < *(void *)(a2 + 8));
    }

    CFStringRef v10 = SecFrameworkCopyLocalizedString(Mutable, @"OID");
    if (v10)
    {
      CFStringRef v11 = v10;
      if (CFEqual(Mutable, v10))
      {
        CFStringRef v12 = v11;
        CFStringRef v11 = v6;
LABEL_16:
        CFRelease(v12);
        goto LABEL_17;
      }

      CFStringRef v12 = v6;
      if (v6) {
        goto LABEL_16;
      }
    }

    else
    {
      CFStringRef v11 = v6;
    }

CFStringRef SecDERItemCopyOIDDecimalRepresentation(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2 = (unint64_t)a2[1];
  if (!v2)
  {
    CFTypeRef v3 = @"<NULL>";
    return SecFrameworkCopyLocalizedString(v3, @"Certificate");
  }

  if (v2 > 0x20)
  {
    CFTypeRef v3 = @"OID too long";
    return SecFrameworkCopyLocalizedString(v3, @"Certificate");
  }

  CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0LL);
  unint64_t v7 = Mutable;
  unsigned int v8 = **a2;
  unsigned int v9 = v8 / 0x28;
  BOOL v10 = v8 > 0x77;
  if (v8 <= 0x77) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = 2LL;
  }
  if (v10) {
    int v12 = 40 * v9 - 80;
  }
  else {
    int v12 = 0;
  }
  CFStringAppendFormat(Mutable, 0LL, @"%u.%u", v11, v12 + **a2 % 0x28u);
  unint64_t v13 = (unint64_t)a2[1];
  if (v13 >= 2)
  {
    int v14 = 0;
    unsigned int v15 = 2;
    uint64_t v16 = 1LL;
    do
    {
      unsigned __int8 v17 = (*a2)[v16];
      if ((v17 & 0x80) != 0)
      {
        int v14 = v17 & 0x7F | (v14 << 7);
      }

      else
      {
        CFStringAppendFormat(v7, 0LL, @".%u", v17 & 0x7F | (v14 << 7));
        int v14 = 0;
        unint64_t v13 = (unint64_t)a2[1];
      }

      uint64_t v16 = v15;
      BOOL v10 = v13 > v15++;
    }

    while (v10);
  }

  return v7;
}

CFMutableArrayRef SecCertificateCopyRFC822Names(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames( v3 + 24,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendRFC822NamesFromGeneralNames)
    || parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRFC822NamesFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

CFArrayRef SecCertificateCopyDNSNames(uint64_t a1)
{
  unint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (*(void *)(a1 + 456))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
    int v4 = SecCertificateParseGeneralNames( *(void *)(a1 + 456) + 24LL,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendDNSNamesFromGeneralNames);
    if (Mutable) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      if (CFArrayGetCount(Mutable) > 0) {
        return Mutable;
      }
    }

    else if (!Mutable)
    {
      goto LABEL_10;
    }

    CFRelease(Mutable);
  }

uint64_t appendDNSNamesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 2) {
    return 0LL;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0) {
    return 4294941021LL;
  }
  int v4 = CFStringCreateWithBytes( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const UInt8 **)a3,  *(void *)(a3 + 8),  0x8000100u,  0);
  if (!v4) {
    return 4294941021LL;
  }
  BOOL v5 = v4;
  if (SecFrameworkIsDNSName(v4)) {
    CFArrayAppendValue(a1, v5);
  }
  CFRelease(v5);
  return 0LL;
}

uint64_t appendDNSNamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidCommonName);
  if ((_DWORD)result)
  {
    unsigned int v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      BOOL v10 = v9;
      if (SecFrameworkIsDNSName(v9)) {
        CFArrayAppendValue(a1, v10);
      }
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

uint64_t appendRFC822NamesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 1) {
    return 0LL;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0) {
    return 4294941021LL;
  }
  CFStringRef v4 = CFStringCreateWithBytes( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const UInt8 **)a3,  *(void *)(a3 + 8),  0x600u,  0);
  if (!v4) {
    return 4294941021LL;
  }
  CFStringRef v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0LL;
}

uint64_t appendRFC822NamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidEmailAddress);
  if ((_DWORD)result)
  {
    unsigned int v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      BOOL v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

__CFData *SecDistinguishedNameCopyNormalizedContent(const __CFData *a1)
{
  if (CFDataGetLength(a1) < 0) {
    return 0LL;
  }
  v5[0] = CFDataGetBytePtr(a1);
  v5[1] = CFDataGetLength(a1);
  memset(v4, 170, sizeof(v4));
  int v2 = DERDecodeItem((uint64_t)v5, v4);
  uint64_t result = 0LL;
  if (!v2 && v4[0] == 0x2000000000000010LL) {
    return createNormalizedX501Name((const __CFAllocator *)*MEMORY[0x189604DB0], (uint64_t)&v4[1]);
  }
  return result;
}

__CFData *SecDistinguishedNameCopyNormalizedSequence(const __CFData *a1)
{
  if (!a1) {
    return 0LL;
  }
  int v1 = SecDistinguishedNameCopyNormalizedContent(a1);
  if (!v1) {
    return 0LL;
  }
  int v2 = v1;
  uint64_t v3 = SecCopySequenceFromContent(v1);
  CFRelease(v2);
  return v3;
}

__CFData *SecCopySequenceFromContent(const __CFData *a1)
{
  if (CFDataGetLength(a1) < 0) {
    return 0LL;
  }
  v3[0] = CFDataGetBytePtr(a1);
  v3[1] = CFDataGetLength(a1);
  return SecDERItemCopySequence((uint64_t)v3);
}

__CFData *SecDERItemCopySequence(uint64_t a1)
{
  uint64_t v7 = DERLengthOfLength(*(void *)(a1 + 8));
  CFIndex v2 = v7 + *(void *)(a1 + 8) + 1;
  if (v2 < 0) {
    return 0LL;
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], v2);
  CFDataSetLength(Mutable, v2);
  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
  UInt8 *MutableBytePtr = 48;
  CFStringRef v5 = MutableBytePtr + 1;
  if (DEREncodeLength( *(void *)(a1 + 8),  (unint64_t)(MutableBytePtr + 1),  (unint64_t *)&v7))
  {
    if (!Mutable) {
      return Mutable;
    }
    CFRelease(Mutable);
    return 0LL;
  }

  memcpy(&v5[v7], *(const void **)a1, *(void *)(a1 + 8));
  return Mutable;
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  if (!data || CFDataGetLength(data) < 0) {
    return 0LL;
  }
  SecCertificateGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), 0x268uLL);
    Copy = CFDataCreateCopy(allocator, data);
    *(void *)(v5 + 552) = Copy;
    *(void *)(v5 + 16) = CFDataGetBytePtr(Copy);
    *(void *)(v5 + 24) = CFDataGetLength(*(CFDataRef *)(v5 + 552));
    if ((SecCertificateParse(v5) & 1) == 0)
    {
      CFRelease((CFTypeRef)v5);
      return 0LL;
    }
  }

  return (SecCertificateRef)v5;
}

SecCertificateRef SecCertificateCreateWithKeychainItem( const __CFAllocator *a1, const __CFData *a2, const void *a3)
{
  SecCertificateRef v4 = SecCertificateCreateWithData(a1, a2);
  if (v4)
  {
    if (a3) {
      CFRetain(a3);
    }
    *((void *)v4 + 77) = a3;
  }

  return v4;
}

uint64_t SecCertificateSetKeychainItem(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 4294967246LL;
  }
  if (cf) {
    CFRetain(cf);
  }
  SecCertificateRef v4 = *(const void **)(a1 + 616);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 616) = cf;
  return result;
}

uint64_t SecCertificateGetLength(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t SecCertificateGetBytePtr(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

CFDataRef SecCertificateCopyPrecertTBS(uint64_t a1)
{
  CFDataRef v1 = 0LL;
  __int128 v24 = *(_OWORD *)(a1 + 32);
  uint64_t v22 = 0LL;
  CFIndex v23 = 0LL;
  __int128 v21 = 0uLL;
  unint64_t v2 = *(void *)(a1 + 512);
  if (v2 > 0x555555555555554LL) {
    return v1;
  }
  SecCertificateRef v4 = malloc(16 * v2);
  uint64_t v5 = (char *)malloc(24 * v2);
  CFStringRef v6 = v5;
  CFDataRef v1 = 0LL;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[8] = v7;
  __int128 v20 = v7;
  v19[6] = v7;
  v19[7] = v7;
  v19[4] = v7;
  v19[5] = v7;
  v19[2] = v7;
  unint64_t v19[3] = v7;
  v19[0] = v7;
  v19[1] = v7;
  if (!v4 || !v5) {
    goto LABEL_25;
  }
  if (DERParseSequence( (uint64_t)&v24,  (unsigned __int16)DERNumTBSCertItemSpecs,  (uint64_t)&DERTBSCertItemSpecs,  (unint64_t)v19,  0xA0uLL)) {
    goto LABEL_34;
  }
  if (*((void *)&v20 + 1))
  {
    memset(v18, 170, sizeof(v18));
    unint64_t v8 = 0LL;
    memset(v17, 170, sizeof(v17));
    while (1)
    {
      int v9 = DERDecodeSeqNext(&v18[1], v17);
      if (v9) {
        break;
      }
      if (v17[0] != 0x2000000000000010LL) {
        goto LABEL_34;
      }
      *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = v10;
      v16[2] = v10;
      v16[0] = v10;
      if (DERParseSequenceContent( &v17[1],  (unsigned __int16)DERNumExtensionItemSpecs,  (uint64_t)&DERExtensionItemSpecs,  (unint64_t)v16,  0x30uLL)) {
        goto LABEL_34;
      }
      if (*((void *)&v16[0] + 1) != 10LL
        || memcmp(*(const void **)&v16[0], &_oidGoogleEmbeddedSignedCertificateTimestamp, 0xAuLL))
      {
        if (v8 > *(void *)(a1 + 512)) {
          goto LABEL_34;
        }
        v4[v8] = *(_OWORD *)&v17[1];
        uint64_t v11 = &v6[24 * v8];
        *((_WORD *)v11 + _Block_object_dispose(va, 8) = 0;
        *(void *)uint64_t v11 = 16 * v8;
        *((void *)v11 + 1) = 0x2000000000000010LL;
        ++v8;
      }
    }

    if (v9 != 1) {
      goto LABEL_34;
    }
  }

  else
  {
    LOWORD(v_Block_object_dispose(va, 8) = 0;
  }

  *((void *)&v21 + 1) = DERLengthOfEncodedSequence( 0x2000000000000010LL,  (unint64_t)v4,  (unsigned __int16)v8,  (uint64_t)v6);
  int v12 = malloc(*((size_t *)&v21 + 1));
  *(void *)&__int128 v21 = v12;
  if (v12)
  {
    if (!DEREncodeSequence( 0x2000000000000010LL,  (unint64_t)v4,  (unsigned __int16)v8,  (uint64_t)v6,  (unint64_t)v12,  (unint64_t *)&v21 + 1))
    {
      __int128 v20 = v21;
      size_t v13 = DERLengthOfEncodedSequence( 0x2000000000000010LL,  (unint64_t)v19,  (unsigned __int16)DERNumTBSCertItemSpecs,  (uint64_t)&DERTBSCertItemSpecs);
      CFIndex v23 = v13;
      if (v13 <= 0x7FFFFFFFFFFFFFFELL)
      {
        int v14 = (UInt8 *)malloc(v13);
        uint64_t v22 = v14;
        if (v14)
        {
          if (!DEREncodeSequence( 0x2000000000000010LL,  (unint64_t)v19,  (unsigned __int16)DERNumTBSCertItemSpecs,  (uint64_t)&DERTBSCertItemSpecs,  (unint64_t)v14,  (unint64_t *)&v23))
          {
            CFDataRef v1 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v22, v23);
            goto LABEL_25;
          }
        }
      }
    }

void appendProperty( void *cf, void *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, char a6)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    if ((a6 & 1) != 0)
    {
      if (a4)
      {
        CFStringRef v10 = 0LL;
      }

      else
      {
        CFStringRef v10 = SecFrameworkCopyLocalizedString(a3, @"Certificate");
        a4 = v10;
      }
    }

    else
    {
      CFRetain(a3);
      CFStringRef v10 = a3;
      a4 = a3;
    }

    keys = @"type";
    __int128 v20 = @"label";
    __int128 v21 = @"localized label";
    uint64_t v22 = @"value";
    values = a2;
    uint64_t v16 = a3;
    unsigned __int8 v17 = a4;
    uint64_t v18 = a5;
    size_t v13 = CFGetAllocator(cf);
    if (a5) {
      CFIndex v14 = 4LL;
    }
    else {
      CFIndex v14 = 3LL;
    }
    CFDictionaryRef v12 = CFDictionaryCreate( v13,  (const void **)&keys,  (const void **)&values,  v14,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    if (v10) {
      CFRelease(v10);
    }
  }

  else
  {
    keys = @"type";
    __int128 v20 = @"value";
    values = a2;
    uint64_t v16 = a5;
    uint64_t v11 = CFGetAllocator(cf);
    CFDictionaryRef v12 = CFDictionaryCreate( v11,  (const void **)&keys,  (const void **)&values,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  }

  CFArrayAppendValue((CFMutableArrayRef)cf, v12);
  CFRelease(v12);
}

double SecAbsoluteTimeFromDateContent(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  return SecAbsoluteTimeFromDateContentWithError(a1, a2, a3, 0LL);
}

BOOL SecCertificateIsValid(BOOL result, double a2)
{
  if (result) {
    return *(double *)(result + 168) <= a2 && *(double *)(result + 176) >= a2;
  }
  return result;
}

uint64_t SecCertificateVersion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96) + 1LL;
}

double SecCertificateNotValidBefore(uint64_t a1)
{
  return *(double *)(a1 + 168);
}

double SecCertificateNotValidAfter(uint64_t a1)
{
  return *(double *)(a1 + 176);
}

CFDateRef SecCertificateCopyNotValidBeforeDate(CFDateRef result)
{
  if (result) {
    return CFDateCreate(0LL, *((CFAbsoluteTime *)result + 21));
  }
  return result;
}

CFDateRef SecCertificateCopyNotValidAfterDate(CFDateRef result)
{
  if (result) {
    return CFDateCreate(0LL, *((CFAbsoluteTime *)result + 22));
  }
  return result;
}

CFMutableArrayRef SecCertificateCopySummaryProperties(double *a1, double a2)
{
  SecCertificateRef v4 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v4, 0LL, MEMORY[0x189605228]);
  CFStringRef v6 = SecCertificateCopySubjectSummary((SecCertificateRef)a1);
  if (v6)
  {
    __int128 v7 = v6;
    appendProperty(Mutable, @"title", 0LL, 0LL, v6, 1);
    CFRelease(v7);
  }

  double v8 = a1[22];
  if (v8 >= a2)
  {
    double v12 = a1[21];
    if (v12 <= a2) {
      uint64_t v11 = @"Expires";
    }
    else {
      uint64_t v11 = @"Valid from";
    }
    if (v12 <= a2)
    {
      CFStringRef v10 = @"This certificate is valid";
    }

    else
    {
      double v8 = a1[21];
      CFStringRef v10 = @"This certificate is not yet valid";
    }

    if (v12 <= a2) {
      int v9 = @"success";
    }
    else {
      int v9 = @"error";
    }
  }

  else
  {
    int v9 = @"error";
    CFStringRef v10 = @"This certificate has expired";
    uint64_t v11 = @"Expired";
  }

  appendDateProperty(Mutable, v11, 1, v8);
  size_t v13 = SecFrameworkCopyLocalizedString(v10, @"Certificate");
  appendProperty(Mutable, v9, 0LL, 0LL, v13, 1);
  CFRelease(v13);
  return Mutable;
}

void appendDateProperty(void *a1, const __CFString *a2, char a3, CFAbsoluteTime a4)
{
  double v8 = CFGetAllocator(a1);
  int v9 = (const __CFString *)CFDateCreate(v8, a4);
  appendProperty(a1, @"date", a2, 0LL, v9, a3);
  CFRelease(v9);
}

CFMutableArrayRef SecCertificateCopyLegacyProperties(uint64_t a1)
{
  unint64_t v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0LL, MEMORY[0x189605228]);
  PropertiesForX501NameContent = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 184), 0LL);
  appendProperty( Mutable,  @"section",  @"Subject Name",  0LL,  (const __CFString *)PropertiesForX501NameContent,  0);
  CFRelease(PropertiesForX501NameContent);
  uint64_t v5 = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 152), 0LL);
  appendProperty(Mutable, @"section", @"Issuer Name", 0LL, (const __CFString *)v5, 0);
  CFRelease(v5);
  CFStringRef v6 = CFStringCreateWithFormat(v2, 0LL, @"%d", *(unsigned __int8 *)(a1 + 96) + 1);
  appendProperty(Mutable, @"string", @"Version", 0LL, v6, 0);
  CFRelease(v6);
  if (*(void *)(a1 + 112)) {
    appendIntegerProperty(Mutable, @"Serial Number", a1 + 104, 0);
  }
  appendAlgorithmProperty(Mutable, @"Signature Algorithm", a1 + 120, 0);
  appendDateProperty(Mutable, @"Not Valid Before", 0, *(CFAbsoluteTime *)(a1 + 168));
  appendDateProperty(Mutable, @"Not Valid After", 0, *(CFAbsoluteTime *)(a1 + 176));
  if (*(void *)(a1 + 288)) {
    appendDataProperty(Mutable, @"Subject Unique ID", 0LL, a1 + 280, 0);
  }
  if (*(void *)(a1 + 272)) {
    appendDataProperty(Mutable, @"Issuer Unique ID", 0LL, a1 + 264, 0);
  }
  appendAlgorithmProperty(Mutable, @"Public Key Algorithm", a1 + 216, 0);
  appendDataProperty(Mutable, @"Public Key Data", 0LL, a1 + 248, 0);
  appendDataProperty(Mutable, @"Signature", 0LL, a1 + 80, 0);
  if (*(uint64_t *)(a1 + 512) >= 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    do
    {
      appendExtension(Mutable, *(void *)(a1 + 520) + v7, 0LL);
      ++v8;
      v7 += 40LL;
    }

    while (v8 < *(void *)(a1 + 512));
  }

  appendFingerprintsProperty(Mutable, (__CFData *)a1, 0);
  return Mutable;
}

__CFArray *createPropertiesForX501NameContent(const __CFAllocator *a1, unint64_t *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( a2,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty,  a3))
  {
    CFArrayRemoveAllValues(Mutable);
    appendRelabeledProperty(Mutable, @"X.501 Name", 0LL, (uint64_t)a2, @"Invalid %@", a3);
  }

  return Mutable;
}

void appendIntegerProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  uint64_t v8 = CFGetAllocator(a1);
  int v9 = copyIntegerContentDescription(v8, a3);
  appendProperty(a1, @"string", a2, 0LL, v9, a4);
  CFRelease(v9);
}

void appendAlgorithmProperty(void *a1, const __CFString *a2, uint64_t a3, int a4)
{
  uint64_t v8 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v8, 0LL, MEMORY[0x189605228]);
  appendOIDProperty(Mutable, @"Algorithm", 0LL, a3, a4);
  uint64_t v10 = *(void *)(a3 + 24);
  if (v10)
  {
    uint64_t v11 = a3 + 16;
    if (v10 == 2 && **(_BYTE **)v11 == 5 && !*(_BYTE *)(*(void *)v11 + 1LL))
    {
      double v12 = SecFrameworkCopyLocalizedString(@"none", @"Certificate");
      appendProperty(Mutable, @"string", @"Parameters", 0LL, v12, a4);
      CFRelease(v12);
    }

    else
    {
      appendRelabeledProperty(Mutable, @"Parameters", 0LL, v11, @"Unparsed %@", a4);
    }
  }

  appendProperty(a1, @"section", a2, 0LL, Mutable, a4);
  CFRelease(Mutable);
}

void appendDataProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, char a5)
{
  if ((*(void *)(a4 + 8) & 0x8000000000000000LL) == 0)
  {
    uint64_t v10 = CFGetAllocator(a1);
    uint64_t v11 = (const __CFString *)CFDataCreate(v10, *(const UInt8 **)a4, *(void *)(a4 + 8));
    appendProperty(a1, @"data", a2, a3, v11, a5);
    CFRelease(v11);
  }

void appendExtension(void *a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v6, 0LL, MEMORY[0x189605228]);
  appendBoolProperty(Mutable, @"Critical", *(unsigned __int8 *)(a2 + 16), a3);
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8 == 3 && (int v9 = *(_BYTE **)a2, !memcmp(*(const void **)a2, &_oidSubjectKeyIdentifier, 2uLL)))
  {
    switch(v9[2])
    {
      case 0xE:
        appendSubjectKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0xF:
        uint64_t v11 = appendKeyUsage_usageNames;
        double v12 = Mutable;
        uint64_t v13 = a2 + 24;
        unsigned __int16 v14 = 9;
        goto LABEL_7;
      case 0x10:
        appendPrivateKeyUsagePeriod(Mutable, a2 + 24, a3);
        break;
      case 0x11:
      case 0x12:
        appendGeneralNames(Mutable, a2 + 24, a3);
        break;
      case 0x13:
        appendBasicConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1E:
        appendNameConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1F:
        appendCrlDistributionPoints(Mutable, a2 + 24, a3);
        break;
      case 0x20:
        appendCertificatePolicies(Mutable, a2 + 24, a3);
        break;
      case 0x23:
        appendAuthorityKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0x24:
        appendPolicyConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x25:
        appendExtendedKeyUsage(Mutable, a2 + 24, a3);
        break;
      default:
        goto LABEL_13;
    }
  }

  else
  {
    if (v8 == 8 && (uint64_t v10 = *(unsigned __int8 **)a2, !memcmp(*(const void **)a2, &_oidAuthorityInfoAccess, 7uLL)))
    {
      int v15 = v10[7];
      if (v15 == 11 || v15 == 1)
      {
        appendInfoAccess(Mutable, a2 + 24, a3);
        goto LABEL_26;
      }
    }

    else if (DEROidCompare(a2, (uint64_t)&oidNetscapeCertType))
    {
      uint64_t v11 = appendNetscapeCertType_certTypes;
      double v12 = Mutable;
      uint64_t v13 = a2 + 24;
      unsigned __int16 v14 = 8;
LABEL_7:
      appendBitStringNames(v12, v13, (const __CFString **)v11, v14, a3);
      goto LABEL_26;
    }

void appendFingerprintsProperty(void *a1, __CFData *a2, char a3)
{
  CFStringRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v6, 0LL, MEMORY[0x189605228]);
  uint64_t v8 = SecCertificateCopySHA256Digest(a2);
  if (v8)
  {
    int v9 = v8;
    appendProperty(Mutable, @"data", @"SHA-256", 0LL, (const __CFString *)v8, a3);
    CFRelease(v9);
  }

  SHA1Digest = SecCertificateGetSHA1Digest(a2);
  appendProperty(Mutable, @"data", @"SHA-1", 0LL, (const __CFString *)SHA1Digest, a3);
  appendProperty(a1, @"section", @"Fingerprints", 0LL, Mutable, a3);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

__CFData *SecCertificateCopySHA256Digest(void *cf)
{
  if (!cf || !cf[2] || (cf[3] & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  unint64_t v2 = CFGetAllocator(cf);
  return SecSHA256DigestCreate(v2, cf[2], cf[3]);
}

__CFData *SecCertificateGetSHA1Digest(__CFData *cf)
{
  if (cf)
  {
    CFDataRef v1 = cf;
    if (!*((void *)cf + 2) || (*((void *)cf + 3) & 0x8000000000000000LL) != 0)
    {
      return 0LL;
    }

    else
    {
      CFTypeRef cf = (__CFData *)*((void *)cf + 76);
      if (!cf)
      {
        unint64_t v2 = CFGetAllocator(v1);
        CFTypeRef cf = SecSHA1DigestCreate(v2, *((void *)v1 + 2), *((void *)v1 + 3));
        *((void *)v1 + 76) = cf;
      }
    }
  }

  return cf;
}

void appendBoolProperty(void *cf, const __CFString *a2, int a3, int a4)
{
  char v4 = a4;
  if (a3) {
    uint64_t v7 = @"Yes";
  }
  else {
    uint64_t v7 = @"No";
  }
  if (a4) {
    uint64_t v7 = SecFrameworkCopyLocalizedString(v7, @"Certificate");
  }
  appendProperty(cf, @"string", a2, 0LL, v7, v4);
  CFRelease(v7);
}

void appendSubjectKeyIdentifier(void *a1, uint64_t a2, char a3)
{
  else {
    appendDataProperty(a1, @"Key Identifier", 0LL, (uint64_t)&v6[1], a3);
  }
}

void appendBitStringNames(void *a1, uint64_t a2, const __CFString **a3, unsigned __int16 a4, int a5)
{
  else {
    appendBitStringContentNames(a1, @"Usage", (unsigned __int8 **)&v10[1], a3, a4, a5);
  }
}

void appendPrivateKeyUsagePeriod(void *a1, uint64_t a2, char a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v7 = v6;
  __int128 v8 = v6;
  if (DERParseSequence( a2,  (unsigned __int16)DERNumPrivateKeyUsagePeriodItemSpecs,  (uint64_t)&DERPrivateKeyUsagePeriodItemSpecs,  (unint64_t)&v7,  0x20uLL))
  {
    appendRelabeledProperty(a1, @"Private Key Usage Period", 0LL, a2, @"Invalid %@", a3);
  }

  else
  {
    if (*((void *)&v7 + 1)) {
      appendDateContentProperty(a1, @"Not Valid Before", (uint64_t)&v7, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendDateContentProperty(a1, @"Not Valid After", (uint64_t)&v8, a3);
    }
  }

void appendGeneralNames(void *a1, uint64_t a2, uint64_t a3)
{
  else {
    appendGeneralNamesContent(a1, &v6[1], a3);
  }
}

void appendBasicConstraints(void *a1, uint64_t a2, int a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v7 = v6;
  __int128 v8 = v6;
  if (DERParseSequence( a2,  (unsigned __int16)DERNumBasicConstraintsItemSpecs,  (uint64_t)&DERBasicConstraintsItemSpecs,  (unint64_t)&v7,  0x20uLL))
  {
    appendRelabeledProperty(a1, @"Basic Constraints", 0LL, a2, @"Invalid %@", a3);
  }

  else
  {
    char v9 = -86;
    else {
      appendBoolProperty(a1, @"Certificate Authority", v9, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendIntegerProperty(a1, @"Path Length Constraint", (uint64_t)&v8, a3);
    }
  }

void appendNameConstraints(void *a1, uint64_t a2, uint64_t a3)
{
  allocator = CFGetAllocator(a1);
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v30 = v6;
  *(_OWORD *)uint64_t v31 = v6;
  uint64_t v22 = a2;
  if (DERParseSequence( a2,  (unsigned __int16)DERNumNameConstraintsItemSpecs,  (uint64_t)&DERNameConstraintsItemSpecs,  (unint64_t)&v30,  0x20uLL)) {
    goto LABEL_29;
  }
  if (*((void *)&v30 + 1))
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    memset(v27, 170, sizeof(v27));
    while (1)
    {
      int v7 = DERDecodeSeqNext(&v28, v27);
      if (v7) {
        break;
      }
      *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v25 = v8;
      __int128 v26 = v8;
      __int128 v24 = v8;
      if (v27[0] != 0x2000000000000010LL
        || DERParseSequenceContent( &v27[1],  (unsigned __int16)DERNumGeneralSubtreeItemSpecs,  (uint64_t)&DERGeneralSubtreeItemSpecs,  (unint64_t)&v24,  0x30uLL))
      {
        goto LABEL_29;
      }

      if (*((void *)&v25 + 1)) {
        appendIntegerProperty(a1, @"Permitted Subtree Minimum", (uint64_t)&v25, a3);
      }
      if (*((void *)&v26 + 1)) {
        appendIntegerProperty(a1, @"Permitted Subtree Maximum", (uint64_t)&v26, a3);
      }
      if (*((void *)&v24 + 1))
      {
        CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(allocator, 0LL, MEMORY[0x189605228]);
        appendProperty(a1, @"section", @"Permitted Subtree General Name", 0LL, Mutable, a3);
        appendGeneralNameProperty(Mutable, (uint64_t)&v24, a3);
        CFRelease(Mutable);
      }
    }

    if (v7 != 1) {
      goto LABEL_29;
    }
  }

  if (v31[1])
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v10 = &v25;
    uint64_t v11 = &v26;
    double v12 = &DERGeneralSubtreeItemSpecs;
    memset(v27, 170, sizeof(v27));
    uint64_t v13 = @"Excluded Subtree Maximum";
    while (1)
    {
      int v14 = DERDecodeSeqNext(&v28, v27);
      if (v14) {
        break;
      }
      *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v25 = v15;
      __int128 v26 = v15;
      __int128 v24 = v15;
      if (v27[0] != 0x2000000000000010LL
        || DERParseSequenceContent( &v27[1],  (unsigned __int16)DERNumGeneralSubtreeItemSpecs,  (uint64_t)v12,  (unint64_t)&v24,  0x30uLL))
      {
        goto LABEL_29;
      }

      if (*((void *)&v25 + 1)) {
        appendIntegerProperty(a1, @"Excluded Subtree Minimum", (uint64_t)v10, a3);
      }
      if (*((void *)&v26 + 1)) {
        appendIntegerProperty(a1, v13, (uint64_t)v11, a3);
      }
      if (*((void *)&v24 + 1))
      {
        char v16 = v11;
        int v17 = v10;
        uint64_t v18 = v12;
        id v19 = v13;
        __int128 v20 = (__CFString *)CFArrayCreateMutable(allocator, 0LL, MEMORY[0x189605228]);
        appendProperty(a1, @"section", @"Excluded Subtree General Name", 0LL, v20, a3);
        appendGeneralNameProperty(v20, (uint64_t)&v24, a3);
        __int128 v21 = v20;
        uint64_t v13 = v19;
        double v12 = v18;
        uint64_t v10 = v17;
        uint64_t v11 = v16;
        CFRelease(v21);
      }
    }

    if (v14 != 1) {
LABEL_29:
    }
      appendRelabeledProperty(a1, @"Name Constraints", 0LL, v22, @"Invalid %@", a3);
  }

void appendCrlDistributionPoints(void *a1, uint64_t a2, uint64_t a3)
{
  __int128 v6 = CFGetAllocator(a1);
  memset(v16, 170, sizeof(v16));
  memset(v15, 170, sizeof(v15));
  while (1)
  {
    int v7 = DERDecodeSeqNext(v16, v15);
    if (v7) {
      break;
    }
    if (v15[0] != 0x2000000000000010LL) {
      goto LABEL_20;
    }
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v13 = v8;
    __int128 v14 = v8;
    __int128 v12 = v8;
    if (DERParseSequenceContent( &v15[1],  (unsigned __int16)DERNumDistributionPointItemSpecs,  (uint64_t)&DERDistributionPointItemSpecs,  (unint64_t)&v12,  0x30uLL)) {
      goto LABEL_20;
    }
    if (*((void *)&v12 + 1))
    {
      memset(v11, 170, sizeof(v11));
      if (v11[0] == 0xA000000000000001LL)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(v6, 0LL, MEMORY[0x189605228]);
        if (parseRDNContent( (unint64_t *)&v13,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty,  a3))
        {
          CFArrayRemoveAllValues(Mutable);
          appendRelabeledProperty(Mutable, @"RDN", 0LL, (uint64_t)&v13, @"Invalid %@", a3);
        }

        appendProperty(a1, @"section", @"Name Relative To CRL Issuer", 0LL, (const __CFString *)Mutable, a3);
        CFRelease(Mutable);
      }

      else
      {
        if (v11[0] != 0xA000000000000000LL) {
          goto LABEL_20;
        }
        appendGeneralNamesContent(a1, &v11[1], a3);
      }
    }

    if (*((void *)&v13 + 1)) {
      appendBitStringContentNames( a1,  @"Reasons",  (unsigned __int8 **)&v13,  (const __CFString **)appendCrlDistributionPoints_reasonNames,  9u,  a3);
    }
    if (*((void *)&v14 + 1))
    {
      uint64_t v10 = (__CFString *)CFArrayCreateMutable(v6, 0LL, MEMORY[0x189605228]);
      appendProperty(a1, @"section", @"CRL Issuer", 0LL, v10, a3);
      CFRelease(v10);
      appendGeneralNames(v10, (uint64_t)&v14, a3);
    }
  }

  if (v7 != 1) {
LABEL_20:
  }
    appendRelabeledProperty(a1, @"CRL Distribution Points", 0LL, a2, @"Invalid %@", a3);
}

void appendCertificatePolicies(void *a1, uint64_t a2, int a3)
{
  char v4 = CFGetAllocator(a1);
  memset(v49, 170, sizeof(v49));
  if (DERDecodeSeqInit(a2, &v49[2], v49) || v49[2] != 0x2000000000000010LL)
  {
LABEL_63:
    appendRelabeledProperty(a1, @"Certificate Policies", 0LL, a2, @"Invalid %@", a3);
    return;
  }

  uint64_t v5 = &v48[1];
  memset(v48, 170, sizeof(v48));
  uint64_t v6 = 1LL;
  uint64_t v7 = (unsigned __int16)DERNumPolicyInformationItemSpecs;
LABEL_4:
  int v8 = DERDecodeSeqNext(v49, v48);
  if (!v8)
  {
    if (v48[0] != 0x2000000000000010LL) {
      goto LABEL_63;
    }
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v46 = v9;
    __int128 v47 = v9;
    if (DERParseSequenceContent( v5,  v7,  (uint64_t)&DERPolicyInformationItemSpecs,  (unint64_t)&v46,  0x20uLL)) {
      goto LABEL_63;
    }
    CFStringRef v10 = CFStringCreateWithFormat(v4, 0LL, @"Policy Identifier #%d", v6);
    if (!v10) {
      goto LABEL_63;
    }
    uint64_t v11 = v10;
    __int128 v12 = @"Policy Identifier #%d";
    if (a3)
    {
      __int128 v12 = SecFrameworkCopyLocalizedString(@"Policy Identifier #%d", @"Certificate");
      if (!v12) {
        goto LABEL_62;
      }
    }

    uint64_t v13 = v7;
    __int128 v14 = v5;
    __int128 v15 = v4;
    CFStringRef v16 = CFStringCreateWithFormat(v4, 0LL, v12, v6);
    if (!v16)
    {
LABEL_60:
      if (v12) {
        CFRelease(v12);
      }
LABEL_62:
      CFRelease(v11);
      goto LABEL_63;
    }

    int v17 = v16;
    uint64_t v6 = (v6 + 1);
    CFRelease(v12);
    appendOIDProperty(a1, v11, v17, (uint64_t)&v46, a3);
    CFRelease(v11);
    CFRelease(v17);
    if (!*((void *)&v47 + 1))
    {
      char v4 = v15;
      goto LABEL_57;
    }

    v45[0] = 0xAAAAAAAAAAAAAAAALL;
    v45[1] = 0xAAAAAAAAAAAAAAAALL;
    char v4 = v15;
    uint64_t v18 = 1LL;
    memset(v44, 170, sizeof(v44));
    __int128 v12 = @"Policy Qualifier #%d";
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            int v19 = DERDecodeSeqNext(v45, v44);
            if (v19)
            {
              if (v19 != 1) {
                goto LABEL_63;
              }
LABEL_57:
              uint64_t v5 = v14;
              uint64_t v7 = v13;
              goto LABEL_4;
            }

            *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __int128 v42 = v20;
            __int128 v43 = v20;
            if (DERParseSequenceContent( &v44[1],  (unsigned __int16)DERNumPolicyQualifierInfoItemSpecs,  (uint64_t)&DERPolicyQualifierInfoItemSpecs,  (unint64_t)&v42,  0x20uLL)) {
              goto LABEL_63;
            }
            memset(v41, 170, sizeof(v41));
            CFStringRef v21 = CFStringCreateWithFormat(v4, 0LL, @"Policy Qualifier #%d", v18);
            if (!v21) {
              goto LABEL_63;
            }
            uint64_t v11 = v21;
            if (a3)
            {
              __int128 v12 = SecFrameworkCopyLocalizedString(@"Policy Qualifier #%d", @"Certificate");
              if (!v12) {
                goto LABEL_62;
              }
            }

            CFStringRef v22 = CFStringCreateWithFormat(v4, 0LL, v12, v18);
            if (!v22) {
              goto LABEL_60;
            }
            uint64_t v23 = v22;
            uint64_t v18 = (v18 + 1);
            CFRelease(v12);
            appendOIDProperty(a1, v11, v23, (uint64_t)&v42, a3);
            CFRelease(v11);
            CFRelease(v23);
            __int128 v12 = @"Policy Qualifier #%d";
            if (v41[0] != 22) {
              goto LABEL_63;
            }
            char v4 = v15;
            appendURLContentProperty(a1, @"CPS URI", (uint64_t)&v41[1], a3);
          }

          char v4 = v15;
          __int128 v12 = @"Policy Qualifier #%d";
          appendRelabeledProperty(a1, @"Qualifier", 0LL, (uint64_t)&v43, @"Unparsed %@", a3);
        }

        if (v41[0] != 0x2000000000000010LL) {
          goto LABEL_63;
        }
        *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __int128 v39 = v24;
        __int128 v40 = v24;
        if (DERParseSequenceContent( &v41[1],  (unsigned __int16)DERNumUserNoticeItemSpecs,  (uint64_t)&DERUserNoticeItemSpecs,  (unint64_t)&v39,  0x20uLL)) {
          goto LABEL_63;
        }
        if (*((void *)&v39 + 1)) {
          break;
        }
        if (*((void *)&v40 + 1)) {
          goto LABEL_52;
        }
      }

      uint64_t v34 = a2;
      *(void *)&__int128 v25 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v37 = v25;
      __int128 v38 = v25;
      if (DERParseSequenceContent( (unint64_t *)&v39,  (unsigned __int16)DERNumNoticeReferenceItemSpecs,  (uint64_t)&DERNoticeReferenceItemSpecs,  (unint64_t)&v37,  0x20uLL)) {
        goto LABEL_63;
      }
      appendDERThingProperty(a1, @"Organization", 0LL, (unsigned __int8 **)&v37, a3);
      __int128 v26 = CFGetAllocator(a1);
      v51[0] = 0xAAAAAAAAAAAAAAAALL;
      v51[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!DERDecodeSeqContentInit((unint64_t *)&v38, v51))
      {
        CFStringRef v27 = @"%@, %@";
        memset(v50, 170, sizeof(v50));
        if (!a3 || (CFStringRef v27 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate")) != 0LL)
        {
          for (uint64_t i = 0LL; ; uint64_t i = MutableCopy)
          {
            int v29 = DERDecodeSeqNext(v51, v50);
            if (v29) {
              break;
            }
            if (v50[0] != 2 || (__int128 v30 = copyIntegerContentDescription(v26, (uint64_t)&v50[1])) == 0LL)
            {
              CFRelease(v27);
              goto LABEL_48;
            }

            uint64_t v31 = v30;
            if (i)
            {
              CFStringRef MutableCopy = CFStringCreateWithFormat(v26, 0LL, v27, i, v30);
              CFRelease(i);
              if (!MutableCopy) {
                goto LABEL_53;
              }
            }

            else
            {
              CFStringRef MutableCopy = CFStringCreateMutableCopy(v26, 0LL, v30);
              if (!MutableCopy)
              {
LABEL_53:
                CFRelease(v27);
                uint64_t i = v31;
                __int128 v12 = @"Policy Qualifier #%d";
                goto LABEL_49;
              }
            }

            CFRelease(v31);
          }

          int v33 = v29;
          CFRelease(v27);
          if (v33 == 1 && i)
          {
            appendProperty(a1, @"string", @"Notice Numbers", 0LL, i, a3);
            CFRelease(i);
            char v4 = v15;
            __int128 v12 = @"Policy Qualifier #%d";
            goto LABEL_51;
          }

LABEL_48:
          __int128 v12 = @"Policy Qualifier #%d";
          if (!i) {
            goto LABEL_50;
          }
LABEL_49:
          CFRelease(i);
        }
      }

            __int128 v42 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v81 = 0;
              _os_log_impl( &dword_1804F4000,  v42,  OS_LOG_TYPE_DEFAULT,  "csr: extensions or parameters wrong input type",  v81,  2u);
            }

            goto LABEL_50;
          }
        }

        else if (!a5)
        {
          goto LABEL_54;
        }

        __int128 v37 = CFGetTypeID(a5);
        if (v37 == CFDataGetTypeID())
        {
          __int128 v38 = CFDataGetLength((CFDataRef)a5);
          __int128 v39 = (char *)CFDataGetBytePtr((CFDataRef)a5);
          if (!SEC_ASN1Decode( (uint64_t)v14,  (uint64_t)v76,  (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate,  v39,  v38)) {
            goto LABEL_56;
          }
          __int128 v40 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v81 = 0;
            _os_log_impl( &dword_1804F4000,  v40,  OS_LOG_TYPE_DEFAULT,  "failed to decode requested CSR extensions",  v81,  2u);
          }
        }

        else
        {
          __int128 v41 = CFGetTypeID(a5);
          if (v41 == CFDictionaryGetTypeID())
          {
            uint64_t v34 = (uint64_t)v14;
            __int16 v35 = (const __CFDictionary *)a5;
            goto LABEL_46;
          }
        }

        goto LABEL_48;
      }

      __int128 v26 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v81 = 0;
        CFStringRef v27 = "csr: failed to decode input subject";
        goto LABEL_21;
      }
    }

    else
    {
LABEL_19:
      __int128 v26 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v81 = 0;
        CFStringRef v27 = "csr: unsupported subject CFType";
LABEL_21:
        _os_log_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEFAULT, v27, v81, 2u);
      }
    }

    unint64_t v28 = 0LL;
    CFStringRef v21 = 0LL;
LABEL_23:
    CFStringRef v22 = 0LL;
LABEL_24:
    int v29 = 0LL;
    __int128 v30 = 0LL;
LABEL_25:
    int v17 = 0LL;
LABEL_66:
    if (v80) {
      free(v72[1]);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (v28) {
      CFRelease(v28);
    }
    PORT_FreeArena(v14, 1);
    if (v30) {
      CFRelease(v30);
    }
    if (v29) {
      CFRelease(v29);
    }
    if (error)
    {
      v51 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v81 = 138412290;
        v82 = error;
        _os_log_impl(&dword_1804F4000, v51, OS_LOG_TYPE_DEFAULT, "csr: cert issuance failed: %@", v81, 0xCu);
      }

      CFDataRef v52 = error;
      if (error)
      {
        error = 0LL;
        CFRelease(v52);
      }
    }

    return v17;
  }

  CFStringRef v16 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
  }

  return 0LL;
}

    SecError( -50,  (__CFString **)error,  @"incorrect or missing kSecAttrKeyType in key generation request",  context);
LABEL_15:
    __int128 v20 = 0;
    goto LABEL_16;
  }

  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFStringRef v27 = SecCFAllocatorZeroize_sAllocator;
  unint64_t v28 = (__SecKey *)SecKeyCreate( SecCFAllocatorZeroize_sAllocator,  (uint64_t)&kSecRSAPrivateKeyDescriptor,  (uint64_t)parameters,  0LL,  5LL);
  if (v28)
  {
    int v29 = v28;
    __int128 v30 = SecKeyCreate(v27, (uint64_t)&kSecRSAPublicKeyDescriptor, *((void *)v28 + 3), 0LL, 6LL);
    if (v30)
    {
      __int128 v20 = 0;
      CFTypeRef cf = v30;
      key = v29;
      goto LABEL_17;
    }

    CFRelease(v29);
  }

  __int128 v20 = -50;
LABEL_10:
  _SECKEY_LOG_9790();
  CFStringRef v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v32 = CFDictionaryGetValue(parameters, @"bsiz");
    *(_DWORD *)__int128 buf = 138543874;
    *(void *)&uint8_t buf[4] = Value;
    __int128 v43 = 2114;
    uint64_t v44 = v32;
    CFDataRef v45 = 1024;
    __int128 v46 = v20;
    _os_log_error_impl( &dword_1804F4000,  v21,  OS_LOG_TYPE_ERROR,  "Failed to generate software key %{public}@:%{public}@, error: %d",  buf,  0x1Cu);
  }

LABEL_16:
  if (!key) {
    goto LABEL_23;
  }
LABEL_17:
  if (getBoolForKey(v5, 0LL))
  {
    CFDictionaryRemoveValue(v5, @"tkid");
    uint64_t v23 = (void *)cf;
    if (!cf)
    {
      uint64_t v23 = SecKeyCopyPublicKey(key);
      CFTypeRef cf = v23;
    }

    if (!add_key(v23, v5, &v40))
    {
      uint64_t v34 = key;
      if (!key) {
        goto LABEL_23;
      }
      goto LABEL_50;
    }
  }

  __int128 v24 = CFDictionaryContainsKey(v6, @"tkid") != 0;
  if (getBoolForKey(v6, v24) && !add_key(key, v6, &v40))
  {
    uint64_t v34 = key;
    if (key)
    {
LABEL_50:
      key = 0LL;
      CFRelease(v34);
    }
  }

void appendAuthorityKeyIdentifier(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v8 = v6;
  __int128 v9 = v6;
  __int128 v7 = v6;
  if (DERParseSequence( a2,  (unsigned __int16)DERNumAuthorityKeyIdentifierItemSpecs,  (uint64_t)&DERAuthorityKeyIdentifierItemSpecs,  (unint64_t)&v7,  0x30uLL)) {
    goto LABEL_9;
  }
  if (*((void *)&v7 + 1)) {
    appendDataProperty(a1, @"Key Identifier", 0LL, (uint64_t)&v7, a3);
  }
  if (*((void *)&v8 + 1) | *((void *)&v9 + 1))
  {
    if (*((void *)&v8 + 1) && *((void *)&v9 + 1))
    {
      appendGeneralNamesContent(a1, (unint64_t *)&v8, a3);
      appendIntegerProperty(a1, @"Authority Certificate Serial Number", (uint64_t)&v9, a3);
      return;
    }

void appendPolicyConstraints(void *a1, uint64_t a2, char a3)
{
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v7 = v6;
  __int128 v8 = v6;
  if (DERParseSequence( a2,  (unsigned __int16)DERNumPolicyConstraintsItemSpecs,  (uint64_t)&DERPolicyConstraintsItemSpecs,  (unint64_t)&v7,  0x20uLL))
  {
    appendRelabeledProperty(a1, @"Policy Constraints", 0LL, a2, @"Invalid %@", a3);
  }

  else
  {
    if (*((void *)&v7 + 1)) {
      appendIntegerProperty(a1, @"Require Explicit Policy", (uint64_t)&v7, a3);
    }
    if (*((void *)&v8 + 1)) {
      appendIntegerProperty(a1, @"Inhibit Policy Mapping", (uint64_t)&v8, a3);
    }
  }

void appendExtendedKeyUsage(void *a1, uint64_t a2, int a3)
{
  while (1)
  {
    int v6 = DERDecodeSeqNext(v8, v7);
    if (v6) {
      break;
    }
    if (v7[0] != 6) {
      goto LABEL_8;
    }
    appendOIDProperty(a1, @"Purpose", 0LL, (uint64_t)&v7[1], a3);
  }

  if (v6 != 1) {
LABEL_8:
  }
    appendRelabeledProperty(a1, @"Extended Key Usage", 0LL, a2, @"Invalid %@", a3);
}

void appendInfoAccess(void *a1, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    int v6 = DERDecodeSeqNext(v11, v10);
    if (v6) {
      break;
    }
    if (v10[0] != 0x2000000000000010LL) {
      goto LABEL_9;
    }
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v8 = v7;
    __int128 v9 = v7;
    if (DERParseSequenceContent( &v10[1],  (unsigned __int16)DERNumAccessDescriptionItemSpecs,  (uint64_t)&DERAccessDescriptionItemSpecs,  (unint64_t)&v8,  0x20uLL)) {
      goto LABEL_9;
    }
    appendOIDProperty(a1, @"Access Method", 0LL, (uint64_t)&v8, a3);
    appendGeneralNameProperty(a1, (uint64_t)&v9, a3);
  }

  if (v6 != 1) {
LABEL_9:
  }
    appendRelabeledProperty(a1, @"Authority Information Access", 0LL, a2, @"Invalid %@", a3);
}

void appendRelabeledProperty( void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, char a6)
{
  __int128 v12 = CFGetAllocator(a1);
  uint64_t v13 = CFStringCreateWithFormat(v12, 0LL, a5, a2);
  if ((a6 & 1) != 0)
  {
    if (a3)
    {
      a2 = 0LL;
    }

    else
    {
      a2 = SecFrameworkCopyLocalizedString(a2, @"Certificate");
      a3 = a2;
    }

    a5 = SecFrameworkCopyLocalizedString(a5, @"Certificate");
  }

  else
  {
    if (a2) {
      CFRetain(a2);
    }
    if (a5) {
      CFRetain(a5);
    }
    a3 = a2;
  }

  __int128 v14 = CFGetAllocator(a1);
  __int128 v15 = CFStringCreateWithFormat(v14, 0LL, a5, a3);
  if (a2) {
    CFRelease(a2);
  }
  if (a5) {
    CFRelease(a5);
  }
  appendDataProperty(a1, v13, v15, a4, a6);
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
}

void appendOIDProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, int a5)
{
  CFStringRef v10 = CFGetAllocator(a1);
  uint64_t v11 = copyOidDescription(v10, a4, a5);
  appendProperty(a1, @"string", a2, a3, v11, a5);
  CFRelease(v11);
}

void appendGeneralNameProperty(void *a1, uint64_t a2, uint64_t a3)
{
  if (DERDecodeItem(a2, (unint64_t *)v6)
    || (appendGeneralNameContentProperty(a1, *(uint64_t *)v6, (unint64_t *)&v6[2], a3) & 1) == 0)
  {
    appendRelabeledProperty(a1, @"General Name", 0LL, a2, @"Invalid %@", a3);
  }

uint64_t appendGeneralNameContentProperty(void *cf, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v5 = (unsigned __int8 **)a3;
  uint64_t result = 0LL;
  switch(a2)
  {
    case 0x8000000000000001LL:
      __int128 v14 = @"Email Address";
      goto LABEL_12;
    case 0x8000000000000002LL:
      __int128 v14 = @"DNS Name";
LABEL_12:
      appendStringContentProperty(cf, v14, (uint64_t)a3, a4);
      return 1LL;
    case 0x8000000000000003LL:
    case 0x8000000000000004LL:
    case 0x8000000000000005LL:
      return result;
    case 0x8000000000000006LL:
      __int128 v15 = cf;
LABEL_29:
      appendURLContentProperty(v15, @"URI", (uint64_t)a3, a4);
      return 1LL;
    case 0x8000000000000007LL:
      CFStringRef v16 = CFGetAllocator(cf);
      CFStringRef v17 = copyIPAddressContentDescription(v16, v5);
      if (v17)
      {
        CFMutableArrayRef Mutable = (__CFString *)v17;
        uint64_t v18 = @"string";
        int v19 = @"IP Address";
LABEL_23:
        appendProperty(cf, v18, v19, 0LL, Mutable, a4);
LABEL_24:
        CFRelease(Mutable);
      }

      else
      {
        __int128 v20 = @"IP Address";
LABEL_33:
        CFStringRef v22 = @"Unparsed %@";
LABEL_34:
        appendRelabeledProperty(cf, v20, 0LL, (uint64_t)v5, v22, a4);
      }

      return 1LL;
    case 0x8000000000000008LL:
      appendOIDProperty(cf, @"Registered ID", 0LL, (uint64_t)a3, a4);
      return 1LL;
    default:
      switch(a2)
      {
        case 0xA000000000000000LL:
          *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)uint64_t v23 = v8;
          *(_OWORD *)&v23[16] = v8;
          if (DERParseSequenceContent( a3,  (unsigned __int16)DERNumOtherNameItemSpecs,  (uint64_t)&DEROtherNameItemSpecs,  (unint64_t)v23,  0x20uLL))
          {
            __int128 v20 = @"Other Name";
            goto LABEL_31;
          }

          __int128 v9 = CFGetAllocator(cf);
          CFStringRef v10 = SecDERItemCopyOIDDecimalRepresentation(v9, (unsigned __int8 **)v23);
          CFMutableArrayRef Mutable = (__CFString *)copyOidDescription(v9, (uint64_t)v23, a4);
          __int128 v12 = copyDERThingDescription(v9, (unsigned __int8 **)&v23[16], 0, a4);
          if (v12)
          {
            uint64_t v13 = v12;
            appendProperty(cf, @"string", v10, Mutable, v12, a4);
            CFRelease(v13);
            if (!v10) {
              goto LABEL_7;
            }
            goto LABEL_6;
          }

          appendRelabeledProperty(cf, v10, Mutable, (uint64_t)&v23[16], @"Unparsed %@", a4);
          if (v10) {
LABEL_6:
          }
            CFRelease(v10);
LABEL_7:
          if (Mutable) {
            goto LABEL_24;
          }
          return 1LL;
        case 0xA000000000000003LL:
          __int128 v20 = @"X.400 Address";
          goto LABEL_33;
        case 0xA000000000000004LL:
          CFStringRef v21 = CFGetAllocator(cf);
          CFMutableArrayRef Mutable = (__CFString *)CFArrayCreateMutable(v21, 0LL, MEMORY[0x189605228]);
          memset(v23, 170, 24);
          if (DERDecodeItem((uint64_t)v5, (unint64_t *)v23)
            || *(void *)v23 != 0x2000000000000010LL
            || parseX501NameContent( (unint64_t *)&v23[8],  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty,  a4))
          {
            CFArrayRemoveAllValues((CFMutableArrayRef)Mutable);
            appendRelabeledProperty(Mutable, @"X.501 Name", 0LL, (uint64_t)v5, @"Invalid %@", a4);
          }

          uint64_t v18 = @"section";
          int v19 = @"Directory Name";
          goto LABEL_23;
        case 0xA000000000000005LL:
          __int128 v20 = @"EDI Party Name";
          goto LABEL_33;
        case 0xA000000000000006LL:
          memset(v23, 170, 24);
          if (!DERDecodeItem((uint64_t)a3, (unint64_t *)v23) && *(void *)v23 == 22LL)
          {
            a3 = (unint64_t *)&v23[8];
            __int128 v15 = cf;
            goto LABEL_29;
          }

          __int128 v20 = @"URI";
LABEL_31:
          CFStringRef v22 = @"Invalid %@";
          goto LABEL_34;
        default:
          return result;
      }
  }

void appendStringContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0
    || (__int128 v8 = CFGetAllocator(cf),
        (__int128 v9 = CFStringCreateWithBytes(v8, *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0)) == 0LL))
  {
    appendRelabeledProperty(cf, a2, 0LL, a3, @"Invalid %@", a4);
  }

  else
  {
    CFStringRef v10 = v9;
    appendProperty(cf, @"string", a2, 0LL, v9, a4);
    CFRelease(v10);
  }

uint64_t appendRDNProperty( const __CFArray *cf, unsigned __int8 **a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  Value = cf;
  if (a4 >= 1)
  {
    CFIndex v10 = CFArrayGetCount(cf) - 1;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v10);
    __int128 v12 = ValueAtIndex;
    if (a4 == 1)
    {
      uint64_t v13 = CFGetAllocator(Value);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v13, 0LL, MEMORY[0x189605228]);
      CFArrayAppendValue(Mutable, v12);
      CFArrayRemoveValueAtIndex(Value, v10);
      appendProperty(Value, @"section", 0LL, 0LL, (const __CFString *)Mutable, a5);
      if (Mutable)
      {
        CFRelease(Mutable);
        Value = Mutable;
      }

      else
      {
        Value = 0LL;
      }
    }

    else
    {
      Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"value");
    }
  }

  __int128 v15 = CFGetAllocator(Value);
  CFStringRef v16 = SecDERItemCopyOIDDecimalRepresentation(v15, a2);
  CFStringRef v17 = CFGetAllocator(Value);
  uint64_t v18 = copyOidDescription(v17, (uint64_t)a2, a5);
  appendDERThingProperty(Value, v16, v18, a3, a5);
  if (v16) {
    CFRelease(v16);
  }
  if (v18) {
    CFRelease(v18);
  }
  return 0LL;
}

void appendURLContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0
    || (__int128 v8 = CFGetAllocator(cf),
        (__int128 v9 = (const __CFString *)CFURLCreateWithBytes(v8, *(const UInt8 **)a3, *(void *)(a3 + 8), 0x600u, 0LL)) == 0LL))
  {
    appendRelabeledProperty(cf, a2, 0LL, a3, @"Invalid %@", a4);
  }

  else
  {
    CFIndex v10 = v9;
    appendProperty(cf, @"url", a2, 0LL, v9, a4);
    CFRelease(v10);
  }

CFStringRef copyIPAddressContentDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2 = a2[1];
  if (v2 == (unsigned __int8 *)16) {
    return CFStringCreateWithFormat( a1,  0LL,  @"%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X",  **a2,  (*a2)[1],  (*a2)[2],  (*a2)[3],  (*a2)[4],  (*a2)[5],  (*a2)[6],  (*a2)[7],  (*a2)[8],  (*a2)[9],  (*a2)[10],  (*a2)[11],  (*a2)[12],  (*a2)[13],  (*a2)[14],  (*a2)[15]);
  }
  return 0LL;
}

void appendDERThingProperty( void *a1, const __CFString *a2, const __CFString *a3, unsigned __int8 **a4, int a5)
{
  CFIndex v10 = CFGetAllocator(a1);
  uint64_t v11 = copyDERThingDescription(v10, a4, 0, a5);
  if (v11)
  {
    __int128 v12 = v11;
    appendProperty(a1, @"string", a2, a3, v11, a5);
    CFRelease(v12);
  }

void appendGeneralNamesContent(void *a1, unint64_t *a2, uint64_t a3)
{
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(v7, 170, sizeof(v7));
  while (1)
  {
    int v6 = DERDecodeSeqNext(v8, (unint64_t *)v7);
    if (v6) {
      break;
    }
  }

  if (v6 != 1) {
LABEL_5:
  }
    appendRelabeledProperty(a1, @"General Names", 0LL, (uint64_t)a2, @"Invalid %@", a3);
}

void appendBitStringContentNames( void *a1, const __CFString *a2, unsigned __int8 **a3, const __CFString **a4, unsigned __int16 a5, int a6)
{
  unint64_t v9 = (unint64_t)a3[1];
  if ((v9 & 0xFFFFFFFFFFFFFFFELL) == 2
    && (uint64_t v10 = (uint64_t)*a3, v11 = **a3, v11 <= 7)
    && (unint64_t v12 = v9 - 1, LOWORD(v13) = 8 * v12 - v11, (unsigned __int16)v13 <= a5))
  {
    int v14 = *(unsigned __int8 *)(v10 + 1);
    if (v12 < 2)
    {
      int v15 = 128;
    }

    else
    {
      int v14 = *(unsigned __int8 *)(v10 + 2) | (v14 << 8);
      int v15 = 0x8000;
    }

    if (a6)
    {
      CFStringRef v16 = SecFrameworkCopyLocalizedString(@"%@, %@", @"Certificate");
      if ((_WORD)v13)
      {
LABEL_9:
        CFStringRef v17 = 0LL;
        uint64_t v13 = (unsigned __int16)v13;
        while (1)
        {
          CFStringRef v18 = *a4;
          if (a6)
          {
            CFStringRef v18 = SecFrameworkCopyLocalizedString(*a4, @"Certificate");
          }

          else if (v18)
          {
            CFRetain(*a4);
          }

          if ((v14 & v15) == 0) {
            goto LABEL_17;
          }
          if (v17) {
            break;
          }
          int v15 = (unsigned __int16)v15 >> 1;
          if (!v18)
          {
            CFStringRef v17 = 0LL;
            goto LABEL_22;
          }

          CFRetain(v18);
          CFStringRef v17 = v18;
LABEL_21:
          CFRelease(v18);
LABEL_22:
          ++a4;
          if (!--v13) {
            goto LABEL_27;
          }
        }

        int v19 = CFGetAllocator(a1);
        CFStringRef v20 = CFStringCreateWithFormat(v19, 0LL, v16, v17, v18);
        CFRelease(v17);
        CFStringRef v17 = v20;
LABEL_17:
        int v15 = (unsigned __int16)v15 >> 1;
        if (!v18) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }

    else
    {
      CFStringRef v16 = @"%@, %@";
      if (8 * (_WORD)v12 != (_WORD)v11) {
        goto LABEL_9;
      }
    }

    CFStringRef v17 = 0LL;
LABEL_27:
    CFRelease(v16);
    if (v17) {
      CFStringRef v21 = v17;
    }
    else {
      CFStringRef v21 = &stru_1896794C8;
    }
    appendProperty(a1, @"string", a2, 0LL, v21, a6);
    if (v17) {
      CFRelease(v17);
    }
  }

  else
  {
    appendRelabeledProperty(a1, a2, 0LL, (uint64_t)a3, @"Invalid %@", a6);
  }

void appendDateContentProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  CFAbsoluteTime at = NAN;
  if (derDateContentGetAbsoluteTime(24LL, *(unsigned __int8 **)a3, *(void *)(a3 + 8), &at))
  {
    __int128 v8 = CFGetAllocator(a1);
    unint64_t v9 = (const __CFString *)CFDateCreate(v8, at);
    appendProperty(a1, @"date", a2, 0LL, v9, a4);
    CFRelease(v9);
  }

  else
  {
    appendRelabeledProperty(a1, a2, 0LL, a3, @"Invalid %@", a4);
  }

uint64_t SecCertificateCopyProperties(unsigned __int8 *a1)
{
  return CopyProperties(a1, 1);
}

uint64_t CopyProperties(unsigned __int8 *cf, int a2)
{
  CFMutableArrayRef v3 = (CFMutableArrayRef)*((void *)cf + 70);
  if (!v3)
  {
    uint64_t v5 = CFGetAllocator(cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v5, 0LL, MEMORY[0x189605228]);
    if (Mutable)
    {
      CFMutableArrayRef v3 = Mutable;
      PropertiesForX501NameContent = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 23, a2 != 0);
      if (PropertiesForX501NameContent)
      {
        __int128 v8 = PropertiesForX501NameContent;
        appendProperty( v3,  @"section",  @"Subject Name",  0LL,  (const __CFString *)PropertiesForX501NameContent,  a2 != 0);
        CFRelease(v8);
      }

      unint64_t v9 = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 19, a2 != 0);
      if (v9)
      {
        uint64_t v10 = v9;
        appendProperty(v3, @"section", @"Issuer Name", 0LL, (const __CFString *)v9, a2 != 0);
        CFRelease(v10);
      }

      unint64_t v11 = SecFrameworkCopyLocalizedString(@"%d", @"Certificate");
      if (v11)
      {
        unint64_t v12 = v11;
        uint64_t v13 = CFStringCreateWithFormat(v5, 0LL, v11, cf[96] + 1);
        CFRelease(v12);
        if (v13)
        {
          appendProperty(v3, @"string", @"Version", 0LL, v13, a2 != 0);
          CFRelease(v13);
        }
      }

      int v14 = CFGetAllocator(v3);
      CFMutableArrayRef v15 = CFArrayCreateMutable(v14, 0LL, MEMORY[0x189605228]);
      CFStringRef v16 = (const __CFString *)v15;
      if (*((void *)cf + 14))
      {
        appendIntegerProperty(v15, @"Serial Number", (uint64_t)(cf + 104), a2 != 0);
        appendProperty(v3, @"section", @"Serial Number", 0LL, v16, a2 != 0);
      }

      if (v16) {
        CFRelease(v16);
      }
      CFStringRef v17 = CFGetAllocator(v3);
      CFStringRef v18 = (__CFString *)CFArrayCreateMutable(v17, 0LL, MEMORY[0x189605228]);
      appendDateProperty(v18, @"Not Valid Before", a2 != 0, *((CFAbsoluteTime *)cf + 21));
      appendDateProperty(v18, @"Not Valid After", a2 != 0, *((CFAbsoluteTime *)cf + 22));
      appendProperty(v3, @"section", @"Validity Period", 0LL, v18, a2 != 0);
      if (v18) {
        CFRelease(v18);
      }
      if (*((void *)cf + 36)) {
        appendDataProperty(v3, @"Subject Unique ID", 0LL, (uint64_t)(cf + 280), a2 != 0);
      }
      if (*((void *)cf + 34)) {
        appendDataProperty(v3, @"Issuer Unique ID", 0LL, (uint64_t)(cf + 264), a2 != 0);
      }
      int v19 = CFGetAllocator(v3);
      CFStringRef v20 = (__CFString *)CFArrayCreateMutable(v19, 0LL, MEMORY[0x189605228]);
      appendAlgorithmProperty(v20, @"Public Key Algorithm", (uint64_t)(cf + 216), a2 != 0);
      CFStringRef v21 = SecCertificateCopyKey((SecCertificateRef)cf);
      if (v21)
      {
        CFStringRef v22 = v21;
        uint64_t valuePtr = 0LL;
        uint64_t v23 = SecKeyCopyAttributes(v21);
        if (!v23) {
          goto LABEL_25;
        }
        __int128 v24 = v23;
        Value = (const __CFNumber *)CFDictionaryGetValue(v23, @"bsiz");
        if (Value) {
          CFNumberGetValue(Value, kCFNumberLongType, &valuePtr);
        }
        CFRelease(v24);
        __int128 v26 = valuePtr;
        if (!valuePtr)
        {
LABEL_25:
          _SecKeyCheck((uint64_t)v22, (uint64_t)"SecKeyGetBlockSize");
          __int128 v26 = *(uint64_t (**)(__SecKey *))(*((void *)v22 + 2) + 80LL);
          if (v26) {
            __int128 v26 = (uint64_t (*)(__SecKey *))(8 * v26(v22));
          }
          uint64_t valuePtr = v26;
        }

        CFStringRef v27 = CFStringCreateWithFormat(v19, 0LL, @"%ld", v26, valuePtr);
        if (v27)
        {
          unint64_t v28 = v27;
          appendProperty(v20, @"string", @"Public Key Size", 0LL, v27, a2 != 0);
          CFRelease(v28);
        }

        CFRelease(v22);
      }

      appendDataProperty(v20, @"Public Key Data", 0LL, (uint64_t)(cf + 248), a2 != 0);
      appendProperty(v3, @"section", @"Public Key Info", 0LL, v20, a2 != 0);
      if (v20) {
        CFRelease(v20);
      }
      if (*((uint64_t *)cf + 64) >= 1)
      {
        uint64_t v29 = 0LL;
        uint64_t v30 = 0LL;
        do
        {
          appendExtension(v3, *((void *)cf + 65) + v29, a2 != 0);
          ++v30;
          v29 += 40LL;
        }

        while (v30 < *((void *)cf + 64));
      }

      uint64_t v31 = CFGetAllocator(v3);
      uint64_t v32 = (__CFString *)CFArrayCreateMutable(v31, 0LL, MEMORY[0x189605228]);
      appendAlgorithmProperty(v32, @"Signature Algorithm", (uint64_t)(cf + 120), a2 != 0);
      appendDataProperty(v32, @"Signature Data", 0LL, (uint64_t)(cf + 80), a2 != 0);
      appendProperty(v3, @"section", @"Signature", 0LL, v32, a2 != 0);
      if (v32) {
        CFRelease(v32);
      }
      appendFingerprintsProperty(v3, (__CFData *)cf, a2 != 0);
      *((void *)cf + 70) = v3;
    }

    else
    {
      CFMutableArrayRef v3 = (CFMutableArrayRef)*((void *)cf + 70);
      if (!v3) {
        return 0LL;
      }
    }
  }

  CFRetain(v3);
  return *((void *)cf + 70);
}

CFDataRef SecCertificateCopySerialNumberData(SecCertificateRef certificate, CFErrorRef *error)
{
  if (certificate)
  {
    CFDataRef result = (CFDataRef)*((void *)certificate + 71);
    if (result)
    {
      CFRetain(result);
      return (CFDataRef)*((void *)certificate + 71);
    }
  }

  else if (error)
  {
    uint64_t v5 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -26275LL, 0LL);
    CFDataRef result = 0LL;
    *error = v5;
  }

  else
  {
    return 0LL;
  }

  return result;
}

CFDataRef SecCertificateCopySerialNumber(CFDataRef certificate)
{
  if (certificate)
  {
    CFDataRef v1 = certificate;
    certificate = (CFDataRef)*((void *)certificate + 71);
    if (certificate)
    {
      CFRetain(certificate);
      return (CFDataRef)*((void *)v1 + 71);
    }
  }

  return certificate;
}

uint64_t SecCertificateGetNormalizedIssuerContent(uint64_t a1)
{
  return *(void *)(a1 + 576);
}

uint64_t SecCertificateGetNormalizedSubjectContent(uint64_t a1)
{
  return *(void *)(a1 + 584);
}

uint64_t SecCertificateIsSignedBy(void *a1, __SecKey *a2)
{
  userInfoKeys[1] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v4 = (uint64_t)(a1 + 15);
  if (!DEROidCompare((uint64_t)(a1 + 6), (uint64_t)(a1 + 15)))
  {
    unint64_t v12 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v12,  OS_LOG_TYPE_DEFAULT,  "Signature algorithm mismatch in certificate (see RFC5280 4.1.1.2)",  buf,  2u);
    }

    return 4294941029LL;
  }

  CFErrorRef error = 0LL;
  unint64_t v5 = a1[5];
  unint64_t v6 = a1[11];
  if (v5 > 0x7FFFFFFFFFFFFFFELL || v6 > 0x7FFFFFFFFFFFFFFELL)
  {
LABEL_63:
    CFErrorRef v22 = error;
    if (error
      || (uint64_t v23 = (void *)*MEMORY[0x189604F38],
          uint64_t v26 = 0LL,
          userInfoKeys[0] = v23,
          *(void *)__int128 buf = @"Unable to verify signature",
          CFErrorRef v22 = CFErrorCreateWithUserInfoKeysAndValues( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFErrorDomain)*MEMORY[0x189604F50],  -50LL,  (const void *const *)userInfoKeys,  (const void *const *)buf,  1LL),  (error = v22) != 0LL))
    {
      CFRelease(v22);
    }

    return 4294941029LL;
  }

  __int128 v8 = (const UInt8 *)a1[4];
  unint64_t v9 = (const UInt8 *)a1[10];
  uint64_t v10 = 0LL;
  char v11 = 1;
  switch(SecKeyGetAlgorithmId((uint64_t)a2))
  {
    case 1LL:
      if (DEROidCompare(v4, (uint64_t)&oidMd5Rsa) || DEROidCompare(v4, (uint64_t)&oidMd5))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:MD5";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha1Rsa) || DEROidCompare(v4, (uint64_t)&oidSha1))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:SHA1";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha224Rsa) || DEROidCompare(v4, (uint64_t)&oidSha224))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:SHA224";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha256Rsa) || DEROidCompare(v4, (uint64_t)&oidSha256))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:SHA256";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha384Rsa) || DEROidCompare(v4, (uint64_t)&oidSha384))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:SHA384";
      }

      else
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:RSA:message-PKCS1v15:SHA512";
      }

      break;
    case 3LL:
      if (DEROidCompare(v4, (uint64_t)&oidSha1Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha1))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:ECDSA:message-X962:SHA1";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha224Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha224))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:ECDSA:message-X962:SHA224";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha256Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha256))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:ECDSA:message-X962:SHA256";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha384Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha384))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:ECDSA:message-X962:SHA384";
      }

      else if (DEROidCompare(v4, (uint64_t)&oidSha512Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha512))
      {
        char v11 = 0;
        uint64_t v10 = @"algid:sign:ECDSA:message-X962:SHA512";
      }

      else
      {
LABEL_60:
        uint64_t v10 = 0LL;
      }

      break;
    case 4LL:
      char v11 = 0;
      uint64_t v10 = @"algid:sign:EdDSA:message-Curve25519:SHA512";
      break;
    case 6LL:
      char v11 = 0;
      uint64_t v10 = @"algid:sign:EdDSA:message-Curve448:SHAKE256";
      break;
    default:
      break;
  }

  CFDataRef v14 = CFDataCreate(0LL, v8, v5);
  CFMutableArrayRef v15 = CFDataCreate(0LL, v9, v6);
  CFStringRef v16 = v15;
  if ((v11 & 1) != 0 || !v14 || !v15)
  {
    if (v14) {
      CFRelease(v14);
    }
    if (!v16) {
      goto LABEL_63;
    }
    CFDataRef v21 = v16;
    goto LABEL_62;
  }

  if (!SecKeyVerifySignature(a2, v10, v14, v15, &error))
  {
    CFRelease(v16);
    CFStringRef v17 = SecRecreateSignatureWithDERAlgorithmId((uint64_t)a2, v4, (uint64_t)v9, v6);
    if (v17)
    {
      CFStringRef v18 = v17;
      CFErrorRef v19 = error;
      if (error)
      {
        CFErrorRef error = 0LL;
        CFRelease(v19);
      }

      int v20 = SecKeyVerifySignature(a2, v10, v14, v18, &error);
      CFRelease(v14);
      CFRelease(v18);
      if (v20) {
        return 0LL;
      }
      goto LABEL_63;
    }

    CFDataRef v21 = v14;
LABEL_62:
    CFRelease(v21);
    goto LABEL_63;
  }

  CFRelease(v14);
  CFRelease(v16);
  return 0LL;
}

uint64_t SecCertificateGetSubjectAltName(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 456);
  if (v1) {
    return v1 + 24;
  }
  else {
    return 0LL;
  }
}

uint64_t SecFrameworkIsIPAddress(const __CFString *a1)
{
  return convertIPAddress(a1, 0LL);
}

uint64_t convertIPAddress(const __CFString *a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  if (CFStringGetLength(a1) >= 7 && CFStringGetLength(a1) <= 15)
  {
    uint64_t v4 = CFCharacterSetCreateWithCharactersInString(0LL, @"0123456789.");
    CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0LL, v4);
    CFMutableDataRef Mutable = CFDataCreateMutable(0LL, 0LL);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, a1, @".");
    __int128 v8 = ArrayBySeparatingStrings;
    if (ArrayBySeparatingStrings) {
      CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    }
    else {
      CFIndex Count = 0LL;
    }
    v45.size_t length = CFStringGetLength(a1);
    v45.location = 0LL;
    if (CFStringFindCharacterFromSet(a1, InvertedSet, v45, 0x200uLL, 0LL) || CFArrayGetCount(v8) != 4)
    {
      char v17 = 0;
      if (!Mutable) {
        goto LABEL_24;
      }
    }

    else
    {
      __int128 v41 = a2;
      if (Count < 1)
      {
LABEL_18:
        a2 = v41;
        if (v41) {
          CFTypeRef *v41 = CFRetain(Mutable);
        }
        char v17 = 1;
        if (!Mutable) {
          goto LABEL_24;
        }
      }

      else
      {
        CFIndex v10 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v10);
          if (ValueAtIndex)
          {
            unint64_t v12 = ValueAtIndex;
            CFRetain(ValueAtIndex);
            CFIndex Length = CFStringGetLength(v12);
            CFIndex v14 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            CFMutableArrayRef v15 = (char *)malloc(v14);
            if (!CFStringGetCString(v12, v15, v14, 0x8000100u)) {
              *CFMutableArrayRef v15 = 0;
            }
            CFRelease(v12);
          }

          else
          {
            CFMutableArrayRef v15 = strdup((const char *)&unk_18065A197);
          }

          int v16 = atoi(v15);
          free(v15);
          if (v16 > 255) {
            break;
          }
          UInt8 bytes = v16;
          CFDataAppendBytes(Mutable, &bytes, 1LL);
          if (Count == ++v10) {
            goto LABEL_18;
          }
        }

        char v17 = 0;
        a2 = v41;
        if (!Mutable)
        {
LABEL_24:
          if (v8) {
            CFRelease(v8);
          }
          if (v4) {
            CFRelease(v4);
          }
          if (InvertedSet)
          {
            CFRelease(InvertedSet);
            if ((v17 & 1) != 0) {
              return 1LL;
            }
          }

          else if ((v17 & 1) != 0)
          {
            return 1LL;
          }

          goto LABEL_32;
        }
      }
    }

    CFRelease(Mutable);
    goto LABEL_24;
  }

LABEL_64:
      free(v36);
    }
  }

  if (CFDataGetLength(v27) != 16)
  {
LABEL_69:
    uint64_t v18 = 0LL;
  }

  else
  {
    if (v42) {
      CFTypeRef *v42 = CFRetain(v27);
    }
    uint64_t v18 = 1LL;
  }

  if (v27) {
    CFRelease(v27);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  return v18;
}

      *((_BYTE *)this + 23) = 0;
LABEL_74:
      *(_BYTE *)this = 0;
      goto LABEL_75;
    }

    CFIndex v30 = *(Security::CodeSigning::BundleDiskRep **)this;
    if (!memcmp(*(const void **)this, v28, *((void *)this + 1)))
    {
      *uint64_t v23 = 0LL;
      this = v30;
      goto LABEL_74;
    }
  }

CFTypeRef SecFrameworkCopyIPAddressData(const __CFString *a1)
{
  CFTypeRef v2 = 0LL;
  else {
    return 0LL;
  }
}

CFArrayRef SecCertificateCopyIPAddresses(uint64_t a1)
{
  uint64_t v1 = SecCertificateCopyIPAddressDatas(a1);
  if (v1)
  {
    uint64_t v7 = 0LL;
    __int128 v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    CFMutableArrayRef Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 0x40000000LL;
    context[2] = __SecCertificateCopyIPAddresses_block_invoke;
    context[3] = &unk_18966F850;
    void context[4] = &v7;
    v11.size_t length = CFArrayGetCount(v1);
    v11.location = 0LL;
    CFArrayApplyFunction(v1, v11, (CFArrayApplierFunction)apply_block_1_8257, context);
    CFRelease(v1);
    CFIndex Count = CFArrayGetCount((CFArrayRef)v8[3]);
    CFMutableArrayRef v3 = v8;
    if (!Count)
    {
      uint64_t v4 = (const void *)v8[3];
      if (v4)
      {
        unint64_t v8[3] = 0LL;
        CFRelease(v4);
        CFMutableArrayRef v3 = v8;
      }
    }

    uint64_t v1 = (const __CFArray *)v3[3];
    _Block_object_dispose(&v7, 8);
  }

  return v1;
}

CFMutableArrayRef SecCertificateCopyIPAddressDatas(uint64_t a1)
{
  if (!*(void *)(a1 + 456)) {
    return 0LL;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (SecCertificateParseGeneralNames( *(void *)(a1 + 456) + 24LL,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendIPAddressesFromGeneralNames)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

void __SecCertificateCopyIPAddresses_block_invoke(uint64_t a1, CFDataRef theData)
{
  if ((CFDataGetLength(theData) & 0x8000000000000000LL) == 0)
  {
    v6[0] = (unsigned __int8 *)CFDataGetBytePtr(theData);
    v6[1] = (unsigned __int8 *)CFDataGetLength(theData);
    CFStringRef v4 = copyIPAddressContentDescription(0LL, v6);
    if (v4)
    {
      CFStringRef v5 = v4;
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v4);
      CFRelease(v5);
    }
  }

uint64_t apply_block_1_8257(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t appendIPAddressesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 7) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3 != 16 && v3 != 4) {
    return 4294941021LL;
  }
  CFDataRef v6 = CFDataCreate(0LL, *(const UInt8 **)a3, *(void *)(a3 + 8));
  CFArrayAppendValue(a1, v6);
  if (v6) {
    CFRelease(v6);
  }
  return 0LL;
}

CFMutableArrayRef SecCertificateCopyDNSNamesFromSAN(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames( v3 + 24,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendDNSNamesFromGeneralNames))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    CFIndex v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    CFMutableArrayRef v12 = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableArrayRef v12 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 0x40000000LL;
    context[2] = __filterIPAddresses_block_invoke;
    context[3] = &unk_18966FA40;
    void context[4] = &v9;
    v13.size_t length = CFArrayGetCount(Mutable);
    v13.location = 0LL;
    CFArrayApplyFunction(Mutable, v13, (CFArrayApplierFunction)apply_block_1_8257, context);
    if (Mutable) {
      CFRelease(Mutable);
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)v10[3]);
    CFStringRef v5 = v10;
    if (!Count)
    {
      CFDataRef v6 = (const void *)v10[3];
      if (v6)
      {
        unint64_t v10[3] = 0LL;
        CFRelease(v6);
        CFStringRef v5 = v10;
      }
    }

    CFMutableArrayRef Mutable = (CFMutableArrayRef)v5[3];
    _Block_object_dispose(&v9, 8);
  }

  return Mutable;
}

void __filterIPAddresses_block_invoke(uint64_t a1, const __CFString *a2)
{
  if ((convertIPAddress(a2, 0LL) & 1) == 0) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a2);
  }
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSAN(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames( v3 + 24,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendRFC822NamesFromGeneralNames)
    || !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  OSStatus result = -50;
  if (certificate && emailAddresses)
  {
    CFStringRef v5 = SecCertificateCopyRFC822Names((uint64_t)certificate);
    *emailAddresses = v5;
    if (v5)
    {
      return 0;
    }

    else
    {
      CFDataRef v6 = CFArrayCreate(0LL, 0LL, 0LL, MEMORY[0x189605228]);
      OSStatus result = 0;
      *emailAddresses = v6;
    }
  }

  return result;
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSubject(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRFC822NamesFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

CFMutableArrayRef SecCertificateCopyURIs(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames( v3 + 24,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendURIsFromGeneralNames)
    || !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

uint64_t appendURIsFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  if (a2 != 6) {
    return 0LL;
  }
  if ((*(void *)(a3 + 8) & 0x8000000000000000LL) != 0) {
    return 4294941021LL;
  }
  CFStringRef v4 = CFStringCreateWithBytes( (CFAllocatorRef)*MEMORY[0x189604DB0],  *(const UInt8 **)a3,  *(void *)(a3 + 8),  0x600u,  0);
  if (!v4) {
    return 4294941021LL;
  }
  CFStringRef v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0LL;
}

CFMutableArrayRef SecCertificateCopyCommonNames(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendCommonNamesFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendCommonNamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidCommonName);
  if ((_DWORD)result)
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFIndex v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  if (!certificate) {
    return -50;
  }
  uint64_t v3 = SecCertificateCopyCommonNames((uint64_t)certificate);
  if (!v3) {
    return -26276;
  }
  CFStringRef v4 = v3;
  if (commonName)
  {
    CFIndex Count = CFArrayGetCount(v3);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, Count - 1);
    uint64_t v7 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
    *commonName = v7;
  }

  CFRelease(v4);
  return 0;
}

CFMutableArrayRef SecCertificateCopyOrganizationFromX501NameContent(unint64_t *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( a1,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendOrganizationFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendOrganizationFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidOrganizationName);
  if ((_DWORD)result)
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFIndex v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

CFMutableArrayRef SecCertificateCopyOrganization(uint64_t a1)
{
  return SecCertificateCopyOrganizationFromX501NameContent((unint64_t *)(a1 + 184));
}

CFMutableArrayRef SecCertificateCopyOrganizationalUnit(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendOrganizationalUnitFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendOrganizationalUnitFromX501Name( __CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidOrganizationalUnitName);
  if ((_DWORD)result)
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFIndex v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

CFMutableArrayRef SecCertificateCopyCountry(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendCountryFromX501Name,  1LL)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendCountryFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, (uint64_t)&oidCountryName);
  if ((_DWORD)result)
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFIndex v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0LL;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

const void *SecCertificateCopySubjectAttributeValue(uint64_t a1, uint64_t a2)
{
  CFStringRef v5 = 0LL;
  v4[0] = a2;
  v4[1] = &v5;
  int v2 = parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)v4,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))copyAttributeValueFromX501Name,  0LL);
  uint64_t result = v5;
  if (v2)
  {
    if (v5)
    {
      CFStringRef v5 = 0LL;
      CFRelease(result);
      return v5;
    }
  }

  return result;
}

uint64_t copyAttributeValueFromX501Name(uint64_t *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result = DEROidCompare(a2, *a1);
  if ((_DWORD)result)
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFIndex v10 = v9;
      uint64_t v11 = (CFTypeRef *)a1[1];
      if (*v11) {
        CFRelease(*v11);
      }
      uint64_t result = 0LL;
      CFTypeRef *v11 = v10;
    }

    else
    {
      return 4294941021LL;
    }
  }

  return result;
}

uint64_t SecCertificateGetBasicConstraints(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 300)) {
    return a1 + 300;
  }
  else {
    return 0LL;
  }
}

uint64_t SecCertificateGetPermittedSubtrees(uint64_t a1)
{
  return *(void *)(a1 + 488);
}

uint64_t SecCertificateGetExcludedSubtrees(uint64_t a1)
{
  return *(void *)(a1 + 496);
}

uint64_t SecCertificateGetPolicyConstraints(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 308)) {
    return a1 + 308;
  }
  else {
    return 0LL;
  }
}

uint64_t SecCertificateGetPolicyMappings(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 328)) {
    return a1 + 328;
  }
  else {
    return 0LL;
  }
}

uint64_t SecCertificateGetCertificatePolicies(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 352)) {
    return a1 + 352;
  }
  else {
    return 0LL;
  }
}

uint64_t SecCertificateGetInhibitAnyPolicySkipCerts(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 376)) {
    return a1 + 376;
  }
  else {
    return 0LL;
  }
}

CFMutableArrayRef SecCertificateCopyNTPrincipalNames(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames( v3 + 24,  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendNTPrincipalNamesFromGeneralNames)
    || !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendNTPrincipalNamesFromGeneralNames(__CFArray *a1, int a2, unint64_t *a3)
{
  if (a2) {
    return 0LL;
  }
  uint64_t v12 = v3;
  uint64_t v13 = v4;
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v10 = v7;
  __int128 v11 = v7;
  if (DERParseSequenceContent( a3,  (unsigned __int16)DERNumOtherNameItemSpecs,  (uint64_t)&DEROtherNameItemSpecs,  (unint64_t)&v10,  0x20uLL)) {
    return 4294941021LL;
  }
  if (DEROidCompare((uint64_t)&v10, (uint64_t)&oidMSNTPrincipalName))
  {
    __int128 v8 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], (unsigned __int8 **)&v11, 1, 1);
    if (v8)
    {
      uint64_t v9 = v8;
      CFArrayAppendValue(a1, v8);
      CFRelease(v9);
      return 0LL;
    }

    return 4294941021LL;
  }

  return 0LL;
}

CFMutableStringRef SecCertificateCopySubjectString(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendToRFC2253String,  1LL)
    || !CFStringGetLength(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendToRFC2253String(__CFString *theString, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a4 <= 0)
  {
    if (!CFStringGetLength(theString)) {
      goto LABEL_6;
    }
    uint64_t v9 = @",";
  }

  else
  {
    uint64_t v9 = @"+";
  }

  CFStringAppend(theString, v9);
LABEL_6:
  if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCommonName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"CN";
  }

  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidLocalityName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"L";
  }

  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidStateOrProvinceName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"ST";
  }

  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"O";
  }

  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationalUnitName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"OU";
  }

  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCountryName))
  {
    CFStringRef v10 = 0LL;
    __int128 v11 = @"C";
  }

  else
  {
    CFStringRef v10 = SecDERItemCopyOIDDecimalRepresentation((const __CFAllocator *)*MEMORY[0x189604DB0], a2);
    __int128 v11 = v10;
  }

  CFStringAppend(theString, v11);
  CFStringAppend(theString, @"=");
  if (v10
    || (CFIndex v14 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], (unsigned __int8 **)a3, 1, a5)) == 0LL)
  {
    CFStringAppend(theString, @"#");
    if (*(void *)(a3 + 8))
    {
      unint64_t v12 = 0LL;
      do
        CFStringAppendFormat(theString, 0LL, @"%02X", *(unsigned __int8 *)(*(void *)a3 + v12++));
      while (v12 < *(void *)(a3 + 8));
    }

    if (v10) {
      CFRelease(v10);
    }
  }

  else
  {
    CFMutableArrayRef v15 = v14;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    *(_OWORD *)buffer = 0u;
    __int128 v37 = 0u;
    CFIndex Length = CFStringGetLength(v14);
    CFStringRef v44 = v15;
    uint64_t v47 = 0LL;
    CFIndex v48 = Length;
    CharactersPtr = CFStringGetCharactersPtr(v15);
    CStringPtr = 0LL;
    CFRange v45 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(v15, 0x600u);
    }
    CFRange v46 = CStringPtr;
    int64_t v49 = 0LL;
    int64_t v50 = 0LL;
    if (Length >= 1)
    {
      uint64_t v19 = 0LL;
      int64_t v20 = 0LL;
      uint64_t v21 = 64LL;
      do
      {
        else {
          uint64_t v22 = v20;
        }
        __int16 v35 = -21846;
        CFIndex v23 = v48;
        if (v48 <= v20)
        {
          UniChar v24 = 0;
          __int16 v35 = 0;
        }

        else
        {
          if (v45)
          {
            UniChar v24 = v45[v20 + v47];
          }

          else if (v46)
          {
            UniChar v24 = v46[v47 + v20];
          }

          else
          {
            int64_t v25 = v49;
            if (v50 <= v20 || v49 > v20)
            {
              uint64_t v27 = v22 + v19;
              uint64_t v28 = v21 - v22;
              int64_t v29 = v20 - v22;
              CFIndex v30 = v29 + 64;
              if (v29 + 64 >= v48) {
                CFIndex v30 = v48;
              }
              int64_t v49 = v29;
              int64_t v50 = v30;
              if (v48 >= v28) {
                CFIndex v23 = v28;
              }
              v51.size_t length = v23 + v27;
              v51.location = v29 + v47;
              CFStringGetCharacters(v44, v51, buffer);
              int64_t v25 = v49;
            }

            UniChar v24 = buffer[v20 - v25];
          }

          __int16 v35 = v24;
          if (v24 > 0x1Fu)
          {
            if (v24 == 32)
            {
              if (!v20 || Length - 1 == v20) {
                goto LABEL_54;
              }
LABEL_64:
              uint64_t v31 = (UniChar *)&v35;
              uint64_t v32 = theString;
              CFIndex v33 = 1LL;
            }

            else
            {
LABEL_63:
              if (v20 || v24 != 35) {
                goto LABEL_64;
              }
LABEL_54:
              chars[0] = 92;
              chars[1] = v24;
              uint64_t v31 = chars;
              uint64_t v32 = theString;
              CFIndex v33 = 2LL;
            }

            CFStringAppendCharacters(v32, v31, v33);
            goto LABEL_56;
          }
        }

        CFStringAppendFormat(theString, 0LL, @"\\%02X", v24);
LABEL_56:
        ++v20;
        --v19;
        ++v21;
      }

      while (Length != v20);
    }

    CFRelease(v15);
  }

  return 0LL;
}

CFMutableStringRef SecCertificateCopyCompanyName(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (parseX501NameContent( (unint64_t *)(a1 + 184),  (uint64_t)Mutable,  (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendToCompanyNameString,  1LL)
    || !CFStringGetLength(Mutable))
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t appendToCompanyNameString(__CFString *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  if (!CFStringGetLength(a1) && DEROidCompare(a2, (uint64_t)&oidOrganizationName))
  {
    uint64_t v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x189604DB0], a3, 1, a5);
    if (v9)
    {
      CFStringRef v10 = v9;
      CFStringAppend(a1, v9);
      CFRelease(v10);
    }
  }

  return 0LL;
}

__CFData *SecCertificateCopyIssuerSequence(uint64_t a1)
{
  return SecDERItemCopySequence(a1 + 152);
}

__CFData *SecCertificateCopySubjectSequence(uint64_t a1)
{
  return SecDERItemCopySequence(a1 + 184);
}

CFDataRef SecCertificateCopyNormalizedIssuerSequence(SecCertificateRef certificate)
{
  if (certificate && (uint64_t v1 = (const __CFData *)*((void *)certificate + 72)) != 0LL) {
    return SecCopySequenceFromContent(v1);
  }
  else {
    return 0LL;
  }
}

CFDataRef SecCertificateCopyNormalizedSubjectSequence(SecCertificateRef certificate)
{
  if (certificate && (uint64_t v1 = (const __CFData *)*((void *)certificate + 73)) != 0LL) {
    return SecCopySequenceFromContent(v1);
  }
  else {
    return 0LL;
  }
}

uint64_t SecCertificateGetPublicKeyAlgorithm(uint64_t a1)
{
  return a1 + 216;
}

uint64_t SecCertificateGetPublicKeyData(uint64_t a1)
{
  return a1 + 248;
}

uint64_t SecCertificateIsWeakKey(__SecCertificate *a1)
{
  if (!a1) {
    return 1LL;
  }
  unint64_t v4 = 0LL;
  uint64_t v1 = SecCertificateGetPublicKeyAlgorithmIdAndSize(a1, (uint64_t *)&v4) - 1;
  uint64_t result = 0LL;
  switch(v1)
  {
    case 0LL:
      BOOL v3 = v4 >= 0x80;
      goto LABEL_6;
    case 2LL:
      BOOL v3 = v4 >= 0x14;
LABEL_6:
      uint64_t result = !v3;
      break;
    case 3LL:
    case 5LL:
      return result;
    default:
      uint64_t result = 1LL;
      break;
  }

  return result;
}

uint64_t SecCertificateGetPublicKeyAlgorithmIdAndSize(__SecCertificate *a1, uint64_t *a2)
{
  SecKeyRef v3 = SecCertificateCopyKey(a1);
  if (!v3)
  {
    uint64_t AlgorithmId = 0LL;
    uint64_t v6 = 0LL;
    if (!a2) {
      return AlgorithmId;
    }
    goto LABEL_6;
  }

  unint64_t v4 = v3;
  _SecKeyCheck((uint64_t)v3, (uint64_t)"SecKeyGetBlockSize");
  CFStringRef v5 = *(uint64_t (**)(void *))(v4[2] + 80LL);
  if (v5) {
    uint64_t v6 = v5(v4);
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)v4);
  CFRelease(v4);
  if (a2) {
LABEL_6:
  }
    *a2 = v6;
  return AlgorithmId;
}

uint64_t SecCertificateIsStrongKey(uint64_t result)
{
  if (result)
  {
    unint64_t v3 = 0LL;
    uint64_t v1 = SecCertificateGetPublicKeyAlgorithmIdAndSize((__SecCertificate *)result, (uint64_t *)&v3) - 1;
    uint64_t result = 1LL;
    switch(v1)
    {
      case 0LL:
        BOOL v2 = v3 > 0xFF;
        goto LABEL_5;
      case 2LL:
        BOOL v2 = v3 > 0x1B;
LABEL_5:
        uint64_t result = v2;
        break;
      case 3LL:
      case 5LL:
        return result;
      default:
        uint64_t result = 0LL;
        break;
    }
  }

  return result;
}

BOOL SecCertificateIsWeakHash(uint64_t a1)
{
  return !a1 || SecSignatureHashAlgorithmForAlgorithmOid((void *)(a1 + 120)) < 5;
}

uint64_t SecSignatureHashAlgorithmForAlgorithmOid(void *a1)
{
  if (!a1 || !*a1 || !a1[1]) {
    return 0LL;
  }
  uint64_t v2 = 8LL;
  else {
    uint64_t v4 = 0LL;
  }
  if (!DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512Ecdsa)
    && !DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512Rsa)
    && !DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512))
  {
    if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384Ecdsa)
      || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384Rsa)
      || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384))
    {
      return 7LL;
    }

    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256Ecdsa) {
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256Rsa)
    }
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256))
    {
      return 6LL;
    }

    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224Ecdsa) {
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224Rsa)
    }
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224))
    {
      return 5LL;
    }

    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Ecdsa) {
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Rsa)
    }
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Dsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1DsaOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1DsaCommonOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1RsaOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Fee)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1))
    {
      return 4LL;
    }

    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5Rsa) {
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5Fee)
    }
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5))
    {
      return 3LL;
    }

    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd4Rsa) || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd4))
    {
      return 2LL;
    }

    else
    {
      uint64_t v2 = v4;
    }
  }

  return v2;
}

uint64_t SecCertificateGetSignatureHashAlgorithm(uint64_t a1)
{
  if (a1) {
    return SecSignatureHashAlgorithmForAlgorithmOid((void *)(a1 + 120));
  }
  else {
    return SecSignatureHashAlgorithmForAlgorithmOid(0LL);
  }
}

__SecCertificate *SecCertificateIsAtLeastMinKeySize(__SecCertificate *result, const __CFDictionary *a2)
{
  if (result)
  {
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v8 = 0LL;
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v3 = SecCertificateGetPublicKeyAlgorithmIdAndSize(result, (uint64_t *)&v8) - 1;
    if (v3 <= 5
      && ((0x2Du >> v3) & 1) != 0
      && (uint64_t v4 = *off_18966FB10[v3]) != 0LL
      && (CFDictionaryGetValueIfPresent(a2, v4, (const void **)&value) ? (BOOL v5 = value == 0LL) : (BOOL v5 = 1), !v5))
    {
      uint64_t result = (__SecCertificate *)CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, &valuePtr);
      if ((_DWORD)result) {
        return (__SecCertificate *)(v8 >= (valuePtr + 7) >> 3);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

__CFData *SecCertificateCopyIssuerSHA1Digest(uint64_t a1)
{
  uint64_t result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    uint64_t v2 = result;
    unint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t BytePtr = CFDataGetBytePtr(result);
    CFIndex Length = CFDataGetLength(v2);
    uint64_t v6 = SecSHA1DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }

  return result;
}

__CFData *SecCertificateCopyIssuerSHA256Digest(uint64_t a1)
{
  uint64_t result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    uint64_t v2 = result;
    unint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t BytePtr = CFDataGetBytePtr(result);
    CFIndex Length = CFDataGetLength(v2);
    uint64_t v6 = SecSHA256DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }

  return result;
}

__CFData *SecCertificateCopyPublicKeySHA1Digest(void *cf)
{
  if (!cf || !cf[31] || (cf[32] & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  uint64_t v2 = CFGetAllocator(cf);
  return SecSHA1DigestCreate(v2, cf[31], cf[32]);
}

__CFData *SecCertificateCopyPublicKeySHA256Digest(void *cf)
{
  if (!cf || !cf[31] || (cf[32] & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  uint64_t v2 = CFGetAllocator(cf);
  return SecSHA256DigestCreate(v2, cf[31], cf[32]);
}

CFDataRef SecCertificateCopySubjectPublicKeyInfoSHA1Digest(const void *a1)
{
  CFDataRef result = SecCertificateCopySPKIEncoded((uint64_t)a1);
  if (result)
  {
    unint64_t v3 = result;
    uint64_t v4 = CFGetAllocator(a1);
    uint64_t BytePtr = CFDataGetBytePtr(v3);
    CFIndex Length = CFDataGetLength(v3);
    __int128 v7 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    CFRelease(v3);
    return v7;
  }

  return result;
}

CFDataRef SecCertificateCopySubjectPublicKeyInfoSHA256Digest(const void *a1)
{
  CFDataRef result = SecCertificateCopySPKIEncoded((uint64_t)a1);
  if (result)
  {
    unint64_t v3 = result;
    uint64_t v4 = CFGetAllocator(a1);
    uint64_t BytePtr = CFDataGetBytePtr(v3);
    CFIndex Length = CFDataGetLength(v3);
    __int128 v7 = SecSHA256DigestCreate(v4, (uint64_t)BytePtr, Length);
    CFRelease(v3);
    return v7;
  }

  return result;
}

void *SecCertificateCopyKeychainItem(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFDataRef result = (void *)result[77];
    if (result)
    {
      CFRetain(result);
      return (void *)v1[77];
    }
  }

  return result;
}

CFDataRef SecCertificateGetAuthorityKeyID(CFDataRef result)
{
  if (result)
  {
    CFDataRef v1 = result;
    CFDataRef result = (CFDataRef)*((void *)result + 74);
    if (!result)
    {
      CFIndex v2 = *((void *)v1 + 52);
      if ((unint64_t)(v2 - 1) > 0x7FFFFFFFFFFFFFFDLL)
      {
        return 0LL;
      }

      else
      {
        CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], *((const UInt8 **)v1 + 51), v2);
        *((void *)v1 + 74) = result;
      }
    }
  }

  return result;
}

CFDataRef SecCertificateGetSubjectKeyID(CFDataRef result)
{
  if (result)
  {
    CFDataRef v1 = result;
    CFDataRef result = (CFDataRef)*((void *)result + 75);
    if (!result)
    {
      CFIndex v2 = *((void *)v1 + 50);
      if ((unint64_t)(v2 - 1) > 0x7FFFFFFFFFFFFFFDLL)
      {
        return 0LL;
      }

      else
      {
        CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], *((const UInt8 **)v1 + 49), v2);
        *((void *)v1 + 75) = result;
      }
    }
  }

  return result;
}

uint64_t SecCertificateGetCRLDistributionPoints(uint64_t result)
{
  if (result) {
    return *(void *)(result + 464);
  }
  return result;
}

uint64_t SecCertificateGetOCSPResponders(uint64_t result)
{
  if (result) {
    return *(void *)(result + 472);
  }
  return result;
}

uint64_t SecCertificateGetCAIssuers(uint64_t result)
{
  if (result) {
    return *(void *)(result + 480);
  }
  return result;
}

BOOL SecCertificateHasCriticalSubjectAltName(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 456);
    return v1 && *(unsigned __int8 *)(v1 + 16) != 0;
  }

  return result;
}

BOOL SecCertificateHasSubject(BOOL result)
{
  if (result) {
    return *(void *)(result + 192) != 0LL;
  }
  return result;
}

BOOL SecCertificateHasUnknownCriticalExtension(BOOL result)
{
  if (result) {
    return *(_BYTE *)(result + 296) != 0;
  }
  return result;
}

uint64_t SecCertificateShow(const void *a1)
{
  uint64_t v1 = (FILE **)MEMORY[0x1895F89D0];
  fprintf((FILE *)*MEMORY[0x1895F89D0], "SecCertificate instance %p:\n", a1);
  return fputc(10, *v1);
}

CFDictionaryRef SecCertificateCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  CFIndex v2 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v3 = ((uint64_t (*)(void))MEMORY[0x1895F8858])();
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v36 = v4;
  __int128 v37 = v4;
  __int128 v34 = v4;
  __int128 v35 = v4;
  __int128 v33 = v4;
  BOOL v5 = (const __CFAllocator *)MEMORY[0x1895F8858](v3);
  uint64_t v32 = v6;
  __int128 v30 = v7;
  __int128 v31 = v7;
  __int128 v28 = v7;
  __int128 v29 = v7;
  __int128 v27 = v7;
  int v8 = *(unsigned __int8 *)(a1 + 96) + 1;
  int v41 = 3;
  int valuePtr = v8;
  CFNumberRef v40 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
  if (!v40) {
    return 0LL;
  }
  CFNumberRef v9 = CFNumberCreate(v2, kCFNumberSInt32Type, &v41);
  if (v9)
  {
    CFNumberRef v10 = v9;
    CFDataRef v11 = SecCertificateCopyData((SecCertificateRef)a1);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFDataRef SubjectKeyID = SecCertificateGetSubjectKeyID((CFDataRef)a1);
      CFIndex v14 = SecCertificateCopyPublicKeySHA1Digest((void *)a1);
      if (v14)
      {
        CFMutableArrayRef v15 = v14;
        *(void *)&__int128 v33 = @"class";
        *((void *)&v33 + 1) = @"ctyp";
        *(void *)&__int128 v27 = @"cert";
        *((void *)&v27 + 1) = v40;
        *(void *)&__int128 v34 = @"cenc";
        *(void *)&__int128 v28 = v10;
        int v16 = *(const void **)(a1 + 584);
        uint64_t v39 = (uint64_t)&v39;
        if (v16 && (CFTypeID v17 = CFGetTypeID(v16), v17 == CFDataGetTypeID()))
        {
          *((void *)&v34 + 1) = @"subj";
          *((void *)&v28 + 1) = *(void *)(a1 + 584);
          uint64_t v18 = 4LL;
        }

        else
        {
          uint64_t v18 = 3LL;
        }

        int64_t v20 = *(const void **)(a1 + 576);
        if (v20 {
          && (CFTypeID v21 = CFGetTypeID(v20), v21 == CFDataGetTypeID())
        }
          && (*((void *)&v33 + v1_Block_object_dispose(va, 8) = @"issr",
              *((void *)&v27 + v1_Block_object_dispose(va, 8) = *(void *)(a1 + 576),
              (uint64_t v22 = *(const void **)(a1 + 568)) != 0LL)
          && (CFTypeID v23 = CFGetTypeID(v22), v23 == CFDataGetTypeID()))
        {
          *((void *)&v33 + v18 + 1) = @"slnr";
          *((void *)&v27 + v18 + 1) = *(void *)(a1 + 568);
          uint64_t v24 = v18 + 2;
          if (SubjectKeyID)
          {
            *((void *)&v33 + v24) = @"skid";
            *((void *)&v27 + v24) = SubjectKeyID;
            uint64_t v24 = v18 + 3;
          }

          *((void *)&v33 + v24) = @"pkhh";
          *((void *)&v27 + v24) = v15;
          uint64_t v25 = 8 * v24 + 8;
          *(void *)((char *)&v33 + v25) = @"v_Data";
          *(void *)((char *)&v27 + v25) = v12;
          CFDictionaryRef v19 = CFDictionaryCreate(v2, (const void **)&v33, (const void **)&v27, v24 + 2, 0LL, MEMORY[0x189605250]);
        }

        else
        {
          CFDictionaryRef v19 = 0LL;
        }

        CFRelease(v15);
      }

      else
      {
        CFDictionaryRef v19 = 0LL;
      }

      CFRelease(v12);
    }

    else
    {
      CFDictionaryRef v19 = 0LL;
    }

    CFRelease(v10);
  }

  else
  {
    CFDictionaryRef v19 = 0LL;
  }

  CFRelease(v40);
  return v19;
}

void *SecCertificateIsCertificate(void *result)
{
  if (result)
  {
    if (!result[2] || (result[3] & 0x8000000000000000LL) != 0)
    {
      return 0LL;
    }

    else
    {
      CFTypeID v1 = CFGetTypeID(result);
      return (void *)(v1 == SecCertificateGetTypeID());
    }
  }

  return result;
}

CFDataRef SecCertificateCreateFromAttributeDictionary(const __CFDictionary *a1)
{
  CFDataRef result = (const __CFData *)CFDictionaryGetValue(a1, @"v_Data");
  if (result) {
    return SecCertificateCreateWithData(0LL, result);
  }
  return result;
}

void *SecCertificateIsCA(uint64_t a1)
{
  CFDataRef result = SecCertificateIsCertificate((void *)a1);
  if ((_DWORD)result)
  {
    if (*(unsigned __int8 *)(a1 + 96) < 2u)
    {
      return (void *)_SecCertificateIsSelfSigned(a1);
    }

    else if (*(_BYTE *)(a1 + 300))
    {
      return (void *)(*(_BYTE *)(a1 + 302) != 0);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL _SecCertificateIsSelfSigned(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 624))
  {
    *(_BYTE *)(a1 + 624) = 1;
    if (SecCertificateIsCertificate((void *)a1))
    {
      SecKeyRef v2 = SecCertificateCopyKey((SecCertificateRef)a1);
      if (v2)
      {
        uint64_t v3 = v2;
        __int128 v4 = *(const void **)(a1 + 576);
        if (v4)
        {
          BOOL v5 = *(const void **)(a1 + 584);
          if (v5)
          {
            if (CFEqual(v4, v5))
            {
              CFDataRef AuthorityKeyID = SecCertificateGetAuthorityKeyID((CFDataRef)a1);
              CFDataRef SubjectKeyID = SecCertificateGetSubjectKeyID((CFDataRef)a1);
              if ((!AuthorityKeyID || SubjectKeyID && CFEqual(SubjectKeyID, AuthorityKeyID))
                && !SecCertificateIsSignedBy((void *)a1, v3))
              {
                *(_BYTE *)(a1 + 624) = 2;
              }
            }
          }
        }

        CFRelease(v3);
      }
    }
  }

  return *(_BYTE *)(a1 + 624) == 2;
}

void *SecCertificateIsSelfSignedCA(uint64_t a1)
{
  CFDataRef result = (void *)_SecCertificateIsSelfSigned(a1);
  if ((_DWORD)result) {
    return SecCertificateIsCA(a1);
  }
  return result;
}

uint64_t SecCertificateIsSelfSigned(void *a1, BOOL *a2)
{
  if (!a2) {
    return 4294967246LL;
  }
  BOOL IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a1);
  uint64_t result = 0LL;
  *a2 = IsSelfSigned;
  return result;
}

uint64_t SecCertificateGetKeyUsage(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 384);
  }
  return result;
}

__CFArray *SecCertificateCopyExtendedKeyUsage(uint64_t a1)
{
  SecKeyRef v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  __int128 v4 = Mutable;
  if (!a1 || !Mutable) {
    goto LABEL_8;
  }
  uint64_t v5 = *(void *)(a1 + 512);
  if (v5 < 1) {
    goto LABEL_9;
  }
  uint64_t v6 = 0LL;
  uint64_t v7 = *(void *)(a1 + 520);
  int v8 = (void *)(v7 + 8);
  while (*v8 != 3LL || memcmp((const void *)*(v8 - 1), &_oidExtendedKeyUsage, 3uLL))
  {
    ++v6;
    v8 += 5;
    if (v5 == v6) {
      goto LABEL_8;
    }
  }

  memset(v15, 170, sizeof(v15));
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    int v10 = DERDecodeSeqNext(v15, v14);
    if (v10) {
      break;
    }
    if (v14[0] != 6) {
      goto LABEL_8;
    }
    if (v14[2] > 0x7FFFFFFFFFFFFFFELL) {
      goto LABEL_8;
    }
    CFDataRef v11 = CFDataCreate(v2, (const UInt8 *)v14[1], v14[2]);
    if (!v11) {
      goto LABEL_8;
    }
    CFDataRef v12 = v11;
    CFArrayAppendValue(v4, v11);
    CFRelease(v12);
  }

  if (v10 != 1)
  {
LABEL_8:
    if (!v4) {
      return v4;
    }
LABEL_9:
    CFRelease(v4);
    return 0LL;
  }

  return v4;
}

__CFArray *SecCertificateCopySignedCertificateTimestamps(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 512);
  if (v1 < 1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = *(void *)(a1 + 520);
  for (CFIndex i = (void *)(v3 + 8);
        *i != 10LL || memcmp((const void *)*(i - 1), &_oidGoogleEmbeddedSignedCertificateTimestamp, 0xAuLL);
        i += 5)
  {
    if (v1 == ++v2) {
      return 0LL;
    }
  }

  memset(v19, 170, sizeof(v19));
  int v8 = (unsigned __int16 *)v19[1];
  unint64_t v9 = v19[2];
  int v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v5 = Mutable;
  if (v9 < 3 || !Mutable) {
    goto LABEL_24;
  }
  unint64_t v12 = __rev16(*v8);
  if (v12 == v9 - 2)
  {
    uint64_t v13 = (const UInt8 *)(v8 + 1);
    if (!v12) {
      return v5;
    }
    while (v12 != 1)
    {
      unint64_t v14 = __rev16(*(unsigned __int16 *)v13);
      BOOL v15 = v12 - 2 >= v14;
      unint64_t v12 = v12 - 2 - v14;
      if (!v15) {
        break;
      }
      int v16 = v13 + 2;
      CFDataRef v17 = CFDataCreate(v10, v16, v14);
      if (!v17) {
        break;
      }
      CFDataRef v18 = v17;
      uint64_t v13 = &v16[v14];
      CFArrayAppendValue(v5, v17);
      CFRelease(v18);
      if (!v12) {
        return v5;
      }
    }

CFStringRef SecCertificateIsOidString(CFStringRef theString)
{
  uint64_t v1 = theString;
  if (theString)
  {
    if (CFStringGetLength(theString) >= 3)
    {
      uint64_t v2 = CFCharacterSetCreateWithCharactersInString(0LL, @"0123456789.");
      CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0LL, v2);
      v8.size_t length = CFStringGetLength(v1);
      v8.location = 0LL;
      int CharacterFromSet = CFStringFindCharacterFromSet(v1, InvertedSet, v8, 0x200uLL, 0LL);
      *(_DWORD *)buffer = -1431655766;
      v7.location = 0LL;
      v7.size_t length = 2LL;
      CFStringGetCharacters(v1, v7, buffer);
      if (buffer[1] != 46
        || (uint64_t v1 = (const __CFString *)(CharacterFromSet == 0), buffer[0] - 51 <= 0xFFFFFFFC))
      {
        uint64_t v1 = 0LL;
      }

      if (v2) {
        CFRelease(v2);
      }
      if (InvertedSet) {
        CFRelease(InvertedSet);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v1;
}

CFArrayRef SecCertificateCreateOidDataFromString(const __CFAllocator *a1, CFStringRef theString)
{
  if (!theString) {
    return 0LL;
  }
  uint64_t result = CFStringCreateArrayBySeparatingStrings(a1, theString, @".");
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  CFIndex Count = CFArrayGetCount(result);
  uint64_t v7 = Count;
  if (!Count) {
    goto LABEL_25;
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable(a1, 5 * Count - 9);
  SInt32 v22 = -1431655766;
  UInt8 bytes = -86;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0LL);
  if (GetDecimalValueOfString(ValueAtIndex, &v22) && v22 <= 6)
  {
    char v10 = 40 * v22;
    UInt8 bytes = 40 * v22;
    if (v7 <= 1)
    {
      CFDataAppendBytes(Mutable, &bytes, 1LL);
LABEL_24:
      uint64_t v7 = (uint64_t)Mutable;
      goto LABEL_25;
    }

    CFDataRef v11 = (const __CFString *)CFArrayGetValueAtIndex(v5, 1LL);
    if (GetDecimalValueOfString(v11, &v22) && v22 <= 39)
    {
      UInt8 bytes = v10 + v22;
      CFDataAppendBytes(Mutable, &bytes, 1LL);
      if ((unint64_t)v7 >= 3)
      {
        CFIndex v12 = 2LL;
        while (1)
        {
          uint64_t v13 = (const __CFString *)CFArrayGetValueAtIndex(v5, v12);
          unint64_t v15 = 0LL;
          char v20 = v22 & 0x7F;
          v14.i32[0] = v22;
          int16x8_t v16 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v22), (uint32x4_t)xmmword_18065A230);
          v16.i32[0] = vshlq_s32(v14, (int32x4_t)xmmword_18065A230).u32[0];
          v16.i64[0] = *(void *)&vmovn_s32((int32x4_t)v16) | 0x80008000800080LL;
          unsigned __int32 v19 = vmovn_s16(v16).u32[0];
          do
          {
            unint64_t v17 = v15;
            int v18 = *((unsigned __int8 *)&v19 + v15++);
          }

          while (v18 == 128);
          if (v17 > 5 || 5 - v17 > 0x7FFFFFFFFFFFFFFELL) {
            goto LABEL_21;
          }
          CFDataAppendBytes(Mutable, (const UInt8 *)&v19 + v17, 5 - v17);
          if (++v12 == v7) {
            goto LABEL_24;
          }
        }
      }

      goto LABEL_24;
    }
  }

uint64_t GetDecimalValueOfString(const __CFString *a1, SInt32 *a2)
{
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0LL, Predefined);
  if (CFStringGetLength(a1) < 1
    || (v8.size_t length = CFStringGetLength(a1),
        v8.location = 0LL,
        CFStringFindCharacterFromSet(a1, InvertedSet, v8, 0x200uLL, 0LL)))
  {
    uint64_t v6 = 0LL;
    if (InvertedSet) {
LABEL_4:
    }
      CFRelease(InvertedSet);
  }

  else
  {
    if (a2) {
      *a2 = CFStringGetIntValue(a1);
    }
    uint64_t v6 = 1LL;
    if (InvertedSet) {
      goto LABEL_4;
    }
  }

  return v6;
}

uint64_t SecCertificateHasMarkerExtension(uint64_t a1, const __CFString *a2)
{
  uint64_t result = 0LL;
  if (!a1 || !a2) {
    return result;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
    CFIndex v7 = Count - 1;
    if (Count >= 1)
    {
      CFIndex v8 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v8);
        uint64_t result = SecCertificateHasMarkerExtension(a1, ValueAtIndex);
        if ((result & 1) != 0) {
          break;
        }
      }

      while (v7 != v8++);
      return result;
    }

    return 0LL;
  }

  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 == CFDictionaryGetTypeID())
  {
    v16[0] = 0xAAAAAAAAAAAAAA00LL;
    v16[1] = a1;
    CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)check_for_marker, v16);
    return LOBYTE(v16[0]) != 0;
  }

  CFTypeID v12 = CFGetTypeID(a2);
  if (v12 == CFDataGetTypeID()) {
    return cert_contains_marker_extension_value(a1, (CFDataRef)a2, 0LL);
  }
  CFTypeID v13 = CFGetTypeID(a2);
  if (v13 != CFStringGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)SecCertificateCreateOidDataFromString(0LL, a2);
  if (result)
  {
    int32x4_t v14 = (const void *)result;
    BOOL v15 = cert_contains_marker_extension_value(a1, (CFDataRef)result, 0LL);
    CFRelease(v14);
    return v15;
  }

  return result;
}

void check_for_marker(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  if (a1)
  {
    if (!*(_BYTE *)a3)
    {
      CFTypeID v6 = CFGetTypeID(a1);
      if (v6 == CFStringGetTypeID())
      {
        OidDataFromString = SecCertificateCreateOidDataFromString(0LL, a1);
        if (OidDataFromString)
        {
          CFIndex v8 = OidDataFromString;
          CFTypeID v9 = CFGetTypeID(OidDataFromString);
          if (v9 == CFDataGetTypeID() && cert_contains_marker_extension_value(*(void *)(a3 + 8), v8, a2)) {
            *(_BYTE *)a3 = 1;
          }
          CFRelease(v8);
        }
      }
    }
  }

BOOL cert_contains_marker_extension_value(uint64_t a1, CFDataRef theData, const __CFString *a3)
{
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (Length < 0) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a1 + 512);
  if (v8 < 1) {
    return 0LL;
  }
  size_t v9 = Length;
  uint64_t v10 = 0LL;
  uint64_t v11 = *(void *)(a1 + 520);
  for (CFIndex i = (void *)(v11 + 8); *i != v9 || memcmp((const void *)*(i - 1), BytePtr, v9); i += 5)
  {
    if (v8 == ++v10) {
      return 0LL;
    }
  }

  uint64_t v13 = v11 + 40 * v10;
  uint64_t v15 = *(void *)(v13 + 24);
  unint64_t v14 = *(void *)(v13 + 32);
  v27[0] = v15;
  v27[1] = v14;
  if (v14 < 2) {
    return 0LL;
  }
  memset(v26, 170, sizeof(v26));
  DERDecodeItem((uint64_t)v27, v26);
  if ((v26[2] & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  if ((uint64_t)v26[0] > 4)
  {
    if (v26[0] != 22 && v26[0] != 12)
    {
      if (v26[0] == 5) {
        return ((unint64_t)a3 | v26[2]) == 0;
      }
      return 0LL;
    }

    if (!a3) {
      return 0LL;
    }
    CFTypeID v19 = CFGetTypeID(a3);
    if (v19 != CFStringGetTypeID()) {
      return 0LL;
    }
    int v18 = CFStringCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const UInt8 *)v26[1],  v26[2],  0x8000100u,  0,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
    BOOL v16 = CFStringCompare(a3, v18, 0LL) == kCFCompareEqualTo;
    if (!v18) {
      return v16;
    }
LABEL_24:
    CFRelease(v18);
    return v16;
  }

  if (v26[0] != 2)
  {
    if (v26[0] != 4) {
      return 0LL;
    }
    if (!a3) {
      return 0LL;
    }
    CFTypeID v17 = CFGetTypeID(a3);
    if (v17 != CFDataGetTypeID()) {
      return 0LL;
    }
    int v18 = (const __CFString *)CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const UInt8 *)v26[1],  v26[2],  (CFAllocatorRef)*MEMORY[0x189604DC8]);
    BOOL v16 = CFEqual(a3, v18) != 0;
    if (!v18) {
      return v16;
    }
    goto LABEL_24;
  }

  SInt32 valuePtr = 0;
  if (a3)
  {
    CFTypeID v20 = CFGetTypeID(a3);
    if (v20 == CFStringGetTypeID())
    {
      SInt32 valuePtr = CFStringGetIntValue(a3);
    }

    else
    {
      CFTypeID v21 = CFGetTypeID(a3);
      if (v21 == CFNumberGetTypeID()) {
        CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, &valuePtr);
      }
    }
  }

  int v24 = 0;
  int v22 = DERParseInteger((char **)&v26[1], &v24);
  BOOL v16 = valuePtr == v24;
  if (v22) {
    return 0LL;
  }
  return v16;
}

uint64_t SecCertificateHasOCSPNoCheckMarkerExtension(uint64_t a1)
{
  if (SecCertificateHasOCSPNoCheckMarkerExtension_onceToken != -1) {
    dispatch_once(&SecCertificateHasOCSPNoCheckMarkerExtension_onceToken, &__block_literal_global_104);
  }
  return SecCertificateHasMarkerExtension( a1,  (const __CFString *)SecCertificateHasOCSPNoCheckMarkerExtension_sOCSPNoCheckOIDData);
}

uint64_t SecCertificateGetExtensionValue(uint64_t a1, const __CFString *cf)
{
  if (!a1 || !cf) {
    return 0LL;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID()) {
    return cert_extension_value_for_marker(a1, (CFDataRef)cf);
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID()) {
    return 0LL;
  }
  OidDataFromString = SecCertificateCreateOidDataFromString(0LL, cf);
  if (!OidDataFromString) {
    return 0LL;
  }
  uint64_t v8 = OidDataFromString;
  uint64_t v9 = cert_extension_value_for_marker(a1, OidDataFromString);
  CFRelease(v8);
  return v9;
}

uint64_t cert_extension_value_for_marker(uint64_t a1, CFDataRef theData)
{
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (Length < 0) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 512);
  if (v6 < 1) {
    return 0LL;
  }
  size_t v7 = Length;
  uint64_t v8 = 0LL;
  uint64_t v9 = *(void *)(a1 + 520);
  for (CFIndex i = (void *)(v9 + 8); *i != v7 || memcmp((const void *)*(i - 1), BytePtr, v7); i += 5)
  {
    if (v6 == ++v8) {
      return 0LL;
    }
  }

  return v9 + 40 * v8 + 24;
}

CFDataRef SecCertificateCopyExtensionValue(uint64_t a1, const __CFString *cf, _BYTE *a3)
{
  CFDataRef v3 = 0LL;
  if (a1)
  {
    OidDataFromString = cf;
    if (cf)
    {
      CFTypeID v7 = CFGetTypeID(cf);
      if (v7 == CFDataGetTypeID())
      {
        CFRetain(OidDataFromString);
      }

      else
      {
        CFTypeID v8 = CFGetTypeID(OidDataFromString);
        if (v8 != CFStringGetTypeID()) {
          return 0LL;
        }
        OidDataFromString = (const __CFString *)SecCertificateCreateOidDataFromString(0LL, OidDataFromString);
        if (!OidDataFromString) {
          return 0LL;
        }
      }

      uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)OidDataFromString);
      CFIndex Length = CFDataGetLength((CFDataRef)OidDataFromString);
      if (Length < 0) {
        goto LABEL_13;
      }
      uint64_t v11 = *(void *)(a1 + 512);
      if (v11 < 1) {
        goto LABEL_13;
      }
      size_t v12 = Length;
      uint64_t v13 = 0LL;
      uint64_t v14 = *(void *)(a1 + 520);
      uint64_t v15 = (void *)(v14 + 8);
      while (*v15 != v12 || memcmp((const void *)*(v15 - 1), BytePtr, v12))
      {
        ++v13;
        v15 += 5;
        if (v11 == v13) {
          goto LABEL_13;
        }
      }

      if (a3) {
        *a3 = *(_BYTE *)(v14 + 40 * v13 + 16);
      }
      CFIndex v17 = *(void *)(v14 + 40 * v13 + 32);
      if (v17 < 0) {
LABEL_13:
      }
        CFDataRef v3 = 0LL;
      else {
        CFDataRef v3 = CFDataCreate(0LL, *(const UInt8 **)(v14 + 40 * v13 + 24), v17);
      }
      CFRelease(OidDataFromString);
    }
  }

  return v3;
}

CFDataRef SecCertificateCopyiAPAuthCapabilities(uint64_t a1)
{
  int v2 = SecCertificateGetiAuthVersion(a1);
  if (v2 == 5)
  {
    CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.71.1");
    if (!result) {
      return result;
    }
    if (*((void *)result + 1) == 32LL) {
      return CFDataCreate(0LL, *(const UInt8 **)result, 32LL);
    }
  }

  else if (v2 == 3)
  {
    CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.36");
    if (!result) {
      return result;
    }
    CFTypeID v4 = (unint64_t *)result;
    if (*((void *)result + 1) == 34LL)
    {
      memset(v6, 170, sizeof(v6));
      if (!DERDecodeItem((uint64_t)result, v6))
      {
        if (v6[0] == 4)
        {
          if (v6[2] == 32)
          {
            unint64_t v5 = v6[1];
            return CFDataCreate(0LL, (const UInt8 *)v5, 32LL);
          }
        }

        else
        {
          unint64_t v5 = *v4;
          if (!*(_BYTE *)(*v4 + 33) && !*(_BYTE *)(v5 + 32)) {
            return CFDataCreate(0LL, (const UInt8 *)v5, 32LL);
          }
        }
      }
    }
  }

  return 0LL;
}

uint64_t SecCertificateGetiAuthVersion(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (SecCertificateGetExtensionValue(result, @"1.2.840.113635.100.6.36"))
    {
      return 3LL;
    }

    else if (SecCertificateGetExtensionValue(v1, @"1.2.840.113635.100.6.59.1"))
    {
      return 4LL;
    }

    else if (SecCertificateGetExtensionValue(v1, @"1.2.840.113635.100.6.71.1"))
    {
      return 5LL;
    }

    else
    {
      int v2 = *(unsigned __int8 **)(v1 + 104);
      if (v2 && *(void *)(v1 + 112) == 15LL && v2[2] == 170 && v2[6] == 170 && v2[8] == 170 && v2[11] == 170) {
        return 2LL;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

CFDataRef SecCertificateCopyiAPSWAuthCapabilities(uint64_t a1, unsigned int a2)
{
  CFDataRef result = 0LL;
  if (a1)
  {
    if (a2 <= 2)
    {
      unint64_t v7[3] = v2;
      void v7[4] = v3;
      CFDataRef result = (CFDataRef)SecCertificateGetExtensionValue(a1, off_18966FB40[a2]);
      if (result)
      {
        memset(v7, 170, 24);
        else {
          BOOL v6 = v7[0] == 4;
        }
        if (v6 && v7[2] <= 0x7FFFFFFFFFFFFFFELL) {
          return CFDataCreate(0LL, (const UInt8 *)v7[1], v7[2]);
        }
        else {
          return 0LL;
        }
      }
    }
  }

  return result;
}

CFStringRef SecCertificateCopyComponentType(CFStringRef result)
{
  if (result)
  {
    CFDataRef result = (CFStringRef)SecCertificateGetExtensionValue((uint64_t)result, @"1.2.840.113635.100.11.1");
    if (result)
    {
      CFStringRef v1 = result;
      memset(v6, 170, sizeof(v6));
      int v2 = DERDecodeItem((uint64_t)result, v6);
      if (!v2 && v6[0] == 22)
      {
        unint64_t info = v6[2];
        if (v6[2] <= 0x7FFFFFFFFFFFFFFELL)
        {
          isa = (const UInt8 *)v6[1];
          CFStringEncoding v5 = 1536;
          return CFStringCreateWithBytes(0LL, isa, info, v5, 0);
        }

        return 0LL;
      }

      if (v2 || v6[0] != 12)
      {
        if (v2 != 3) {
          return 0LL;
        }
        unint64_t info = v1->info;
        if (info > 0x7FFFFFFFFFFFFFFELL) {
          return 0LL;
        }
        isa = (const UInt8 *)v1->isa;
      }

      else
      {
        unint64_t info = v6[2];
        if (v6[2] > 0x7FFFFFFFFFFFFFFELL) {
          return 0LL;
        }
        isa = (const UInt8 *)v6[1];
      }

      CFStringEncoding v5 = 134217984;
      return CFStringCreateWithBytes(0LL, isa, info, v5, 0);
    }
  }

  return result;
}

CFDictionaryRef SecCertificateCopyComponentAttributes(const __CFDictionary *a1)
{
  CFDictionaryRef Copy = a1;
  if (a1)
  {
    uint64_t v7 = 0LL;
    CFTypeID v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    uint64_t ExtensionValue = SecCertificateGetExtensionValue((uint64_t)Copy, @"1.2.840.113635.100.11.3");
    if (ExtensionValue
      && (v6[0] = MEMORY[0x1895F87A8],
          v6[1] = 0x40000000LL,
          v6[2] = __SecCertificateCopyComponentAttributes_block_invoke,
          unint64_t v6[3] = &unk_18966F8B8,
          void v6[4] = &v7,
          !DERDecodeSequenceWithBlock(ExtensionValue, (uint64_t)v6))
      && (unint64_t v3 = (const __CFDictionary *)v8[3]) != 0LL
      && CFDictionaryGetCount(v3) >= 1)
    {
      CFDictionaryRef Copy = CFDictionaryCreateCopy(0LL, (CFDictionaryRef)v8[3]);
    }

    else
    {
      CFDictionaryRef Copy = 0LL;
    }

    CFTypeID v4 = (const void *)v8[3];
    if (v4)
    {
      unint64_t v8[3] = 0LL;
      CFRelease(v4);
    }

    _Block_object_dispose(&v7, 8);
  }

  return Copy;
}

uint64_t __SecCertificateCopyComponentAttributes_block_invoke(uint64_t a1, void *a2)
{
  cf[3] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  uint64_t v3 = (uint64_t)(a2 + 1);
  uint64_t valuePtr = *a2 & 0x1FFFFFFFFFFFFFFFLL;
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
  memset(v17, 170, sizeof(v17));
  uint64_t v5 = DERDecodeItem(v3, v17);
  if ((_DWORD)v5)
  {
LABEL_14:
    uint64_t v13 = v5;
LABEL_15:
    uint64_t v14 = 0LL;
  }

  else
  {
    switch(v17[0])
    {
      case 1uLL:
        LOBYTE(cf[0]) = 0;
        uint64_t v5 = DERParseBoolean((unsigned __int8 **)&v17[1], (BOOL *)cf);
        if (LOBYTE(cf[0])) {
          size_t v12 = (const void **)MEMORY[0x189604DE8];
        }
        else {
          size_t v12 = (const void **)MEMORY[0x189604DE0];
        }
        if ((_DWORD)v5) {
          goto LABEL_14;
        }
        goto LABEL_23;
      case 2uLL:
        cf[0] = 0LL;
        uint64_t v5 = DERParseInteger64((char **)&v17[1], (unint64_t *)cf);
        if ((_DWORD)v5) {
          goto LABEL_14;
        }
        uint64_t v9 = CFNumberCreate(0LL, kCFNumberSInt64Type, cf);
        goto LABEL_28;
      case 3uLL:
        *(_OWORD *)CFTypeRef cf = 0uLL;
        uint64_t v5 = DERParseBitString((uint64_t)&v17[1], (unint64_t *)cf, 0LL);
        if ((_DWORD)v5) {
          goto LABEL_14;
        }
        CFTypeRef v7 = cf[1];
        if (((unint64_t)cf[1] & 0x8000000000000000LL) == 0)
        {
          CFTypeID v8 = (const UInt8 *)cf[0];
          goto LABEL_21;
        }

        uint64_t v13 = 7LL;
        goto LABEL_15;
      case 4uLL:
      case 6uLL:
        CFTypeRef v7 = (CFTypeRef)v17[2];
        if ((v17[2] & 0x8000000000000000LL) != 0)
        {
          uint64_t v14 = 0LL;
          uint64_t v13 = 7LL;
          break;
        }

        CFTypeID v8 = (const UInt8 *)v17[1];
LABEL_21:
        uint64_t v9 = CFDataCreate(0LL, v8, (CFIndex)v7);
        goto LABEL_28;
      case 5uLL:
        size_t v12 = (const void **)MEMORY[0x189605018];
LABEL_23:
        uint64_t v14 = *v12;
        goto LABEL_29;
      case 0xCuLL:
      case 0x1BuLL:
      case 0x1CuLL:
        CFStringEncoding v6 = 134217984;
        goto LABEL_7;
      case 0x13uLL:
      case 0x16uLL:
        CFStringEncoding v6 = 1536;
LABEL_7:
        uint64_t v9 = copyContentString(0LL, (uint64_t)&v17[1], v6);
        goto LABEL_28;
      case 0x17uLL:
      case 0x18uLL:
        cf[0] = 0LL;
        double v10 = SecAbsoluteTimeFromDateContentWithError(v17[0], (unsigned __int8 *)v17[1], v17[2], (CFErrorRef *)cf);
        CFTypeRef v11 = cf[0];
        if (cf[0])
        {
          cf[0] = 0LL;
          CFRelease(v11);
LABEL_26:
          uint64_t v14 = 0LL;
          uint64_t v13 = 0LL;
        }

        else
        {
          uint64_t v9 = CFDateCreate(0LL, v10);
LABEL_28:
          uint64_t v14 = v9;
LABEL_29:
          uint64_t v13 = 0LL;
          if (v4 && v14)
          {
            CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v4, v14);
            uint64_t v13 = 0LL;
            goto LABEL_34;
          }
        }

        break;
      default:
        uint64_t v15 = (os_log_s *)secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(cf[0]) = 134217984;
          *(unint64_t *)((char *)cf + 4) = v17[0];
          _os_log_impl( &dword_1804F4000,  v15,  OS_LOG_TYPE_DEFAULT,  "unsupported value tag (%lld) found in Component Attribute dictionary, skipping",  (uint8_t *)cf,  0xCu);
        }

        goto LABEL_26;
    }
  }

  if (v4) {
LABEL_34:
  }
    CFRelease(v4);
  if (v14) {
    CFRelease(v14);
  }
  return v13;
}

CFDataRef SecCertificateCopyCompressedMFiCert(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 < 0) {
    return 0LL;
  }
  size_t __size = 0LL;
  int v3 = CTCompressComputeBufferSize(*(void *)(a1 + 16), v2, &__size);
  if (v3)
  {
    int v6 = v3;
LABEL_10:
    CFTypeID v8 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v12 = v6;
      _os_log_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEFAULT, "coretrust compress failed: %04x", buf, 8u);
    }

    return 0LL;
  }

  size_t v4 = __size;
  uint64_t v5 = malloc(__size);
  if (!v5)
  {
    CFDataRef v7 = 0LL;
    goto LABEL_8;
  }

  int v6 = CTCompress(*(void *)(a1 + 16), *(void *)(a1 + 24), v5, v4);
  if (v6 || __size > 0x7FFFFFFFFFFFFFFELL)
  {
    free(v5);
    if (v6) {
      goto LABEL_10;
    }
    return 0LL;
  }

  CFDataRef v7 = CFDataCreate(0LL, v5, __size);
LABEL_8:
  free(v5);
  return v7;
}

CFDataRef SecCertificateCreateWithCompressedMFiCert(const __CFData *cf)
{
  CFStringRef v1 = cf;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFDataGetTypeID() && (CFDataGetLength(v1) & 0x8000000000000000LL) == 0)
    {
      size_t __size = 0LL;
      uint64_t BytePtr = CFDataGetBytePtr(v1);
      CFIndex Length = CFDataGetLength(v1);
      int v5 = CTDecompressComputeBufferSize((unint64_t)BytePtr, Length, &__size);
      if (v5)
      {
        int v10 = v5;
        int v6 = 0LL;
      }

      else
      {
        int v6 = malloc(__size);
        if (!v6) {
          goto LABEL_9;
        }
        CFDataRef v7 = CFDataGetBytePtr(v1);
        CFIndex v8 = CFDataGetLength(v1);
        int v9 = CTDecompress((unint64_t)v7, v8, (unint64_t)v6, __size);
        if (!v9)
        {
          if (__size <= 0x7FFFFFFFFFFFFFFELL)
          {
            CFStringRef v1 = (const __CFData *)SecCertificateCreateWithBytes(0LL, v6, __size);
LABEL_10:
            free(v6);
            return v1;
          }

void *SecCertificateCreateWithPEM(int a1, CFDataRef theData)
{
  if (!theData || CFDataGetLength(theData) < 1) {
    return 0LL;
  }
  uint64_t BytePtr = (const char *)CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  int v5 = strnstr(BytePtr, "-----BEGIN CERTIFICATE-----", Length);
  int v6 = strnstr(BytePtr, "-----END CERTIFICATE-----", Length);
  CFDataRef v7 = 0LL;
  if (!v5 || !v6 || v5 > v6) {
    return v7;
  }
  CFIndex v8 = v5 + 27;
  if (v5 + 27 < v6)
  {
    uint64_t v9 = v6 - v5 - 27;
    while (1)
    {
      int v10 = *v8;
      if (v10 != 32 && v10 != 9) {
        break;
      }
      ++v8;
      if (!--v9)
      {
        CFIndex v8 = v6;
        break;
      }
    }
  }

  int v12 = *v8;
  if (v12 == 13)
  {
    int v15 = v8[1];
    uint64_t v14 = (unsigned __int8 *)(v8 + 1);
    if (v15 == 10) {
      uint64_t v13 = v14 + 1;
    }
    else {
      uint64_t v13 = v14;
    }
    goto LABEL_21;
  }

  if (v12 != 10) {
    return 0LL;
  }
  uint64_t v13 = (unsigned __int8 *)(v8 + 1);
LABEL_21:
  unint64_t v16 = v6 - (char *)v13;
  unint64_t v17 = (unint64_t)(v6 - (char *)v13) >> 2;
  if (!v17) {
    return 0LL;
  }
  size_t v18 = 3 * v17;
  if (3 * v17 >= CFDataGetLength(theData)) {
    return 0LL;
  }
  CFTypeID v19 = calloc(1uLL, v18);
  if (!v19) {
    return 0LL;
  }
  CFTypeID v20 = v19;
  CFTypeID v21 = SecBase64Decode_(v13, v16, v19, v18, 0, &v24, &v23);
  if (v21) {
    CFDataRef v7 = SecCertificateCreateWithBytes(*MEMORY[0x189604DB0], v20, (int64_t)v21);
  }
  else {
    CFDataRef v7 = 0LL;
  }
  free(v20);
  return v7;
}

CFStringRef SecCertificateCopyPEMRepresentation(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  CFStringRef v1 = *(unsigned __int8 **)(a1 + 16);
  unint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = (2 * (((v2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v4 = v3 + 2 * ((unint64_t)(v3 + 63) >> 6);
  unint64_t v5 = v4 - 2;
  size_t v6 = v4 + 53;
  CFDataRef v7 = (char *)malloc(v4 + 53);
  CFIndex v8 = &v7[snprintf(v7, v6, "-----BEGIN %s-----\n", "CERTIFICATE")];
  int v12 = -1431655766;
  unint64_t v9 = SecBase64Encode_(v1, v2, v8, v5, 0x40u, &v12);
  if (v12)
  {
    CFStringRef v10 = 0LL;
  }

  else
  {
    snprintf(&v8[v9], &v7[v6] - &v8[v9], "\n-----END %s-----\n", "CERTIFICATE");
    CFStringRef v10 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)v7, v6, 0x8000100u, 0);
  }

  free(v7);
  return v10;
}

BOOL SecCertificateAppendToXPCArray(uint64_t a1, xpc_object_t xarray, __CFString **a3)
{
  if (a1)
  {
    size_t v3 = *(void *)(a1 + 24);
    if ((v3 & 0x8000000000000000LL) == 0)
    {
      uint64_t v4 = *(const void **)(a1 + 16);
      if (v3) {
        BOOL v5 = v4 == 0LL;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5) {
        return SecError(-50, a3, @"failed to der encode certificate");
      }
      xpc_array_set_data(xarray, 0xFFFFFFFFFFFFFFFFLL, v4, v3);
    }
  }

  return 1LL;
}

xpc_object_t SecCertificateArrayCopyXPCArray(const __CFArray *a1, __CFString **a2)
{
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (v6 == ++v7) {
          return v4;
        }
      }

      xpc_release(v4);
      return 0LL;
    }
  }

  else
  {
    SecError(-108, a2, @"failed to create xpc_array");
  }

  return v4;
}

__CFArray *SecCertificateXPCArrayCopyArray(void *a1, __CFString **a2)
{
  if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9220])
  {
    SecError(-50, a2, @"certificates xpc value is not an array");
    return 0LL;
  }

  unint64_t count = xpc_array_get_count(a1);
  unint64_t v5 = count;
  if (count >= 0x7FFFFFFFFFFFFFFFLL)
  {
    SecError(-108, a2, @"failed to create CFArray of capacity %zu", count);
    return 0LL;
  }

  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], count, MEMORY[0x189605228]);
  if (!Mutable)
  {
    SecError(-108, a2, @"failed to create CFArray of capacity %zu", v5);
    return Mutable;
  }

  if (v5)
  {
    size_t v7 = 0LL;
    while (1)
    {
      CFIndex v8 = SecCertificateCreateWithXPCArrayAtIndex(a1, v7, a2);
      if (!v8) {
        break;
      }
      unint64_t v9 = v8;
      CFArraySetValueAtIndex(Mutable, v7, v8);
      CFRelease(v9);
      if (v5 == ++v7) {
        return Mutable;
      }
    }

    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

CFArrayRef SecCertificateCopyEscrowRoots(uint64_t a1)
{
  v13[1] = *MEMORY[0x1895F89C0];
  if (a1 > 5)
  {
    unint64_t v2 = &kBaseLineEscrowEnrollmentRoots;
    CFIndex v1 = 4LL;
  }

  else
  {
    CFIndex v1 = qword_180657568[a1];
    unint64_t v2 = off_18966FB58[a1];
  }

  MEMORY[0x1895F8858](a1);
  xpc_object_t v4 = (CFTypeRef *)((char *)v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  memset(v4, 170, v3);
  uint64_t v5 = 0LL;
  CFIndex v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  do
  {
    size_t v7 = (CFIndex *)v2[v5];
    if (v7)
    {
      if (*v7 >= 1)
      {
        CFIndex v8 = (const UInt8 *)v7[1];
        if (v8)
        {
          unint64_t v9 = CFDataCreate(v6, v8, *v7);
          if (v9)
          {
            CFStringRef v10 = v9;
            v4[v5] = SecCertificateCreateWithData(v6, v9);
            CFRelease(v10);
          }
        }
      }
    }

    ++v5;
  }

  while (v1 != v5);
  CFArrayRef v11 = CFArrayCreate(v6, v4, v1, MEMORY[0x189605228]);
  do
  {
    if (*v4) {
      CFRelease(*v4);
    }
    ++v4;
    --v1;
  }

  while (v1);
  return v11;
}

uint64_t SecCertificateCopyTrustedCTLogs()
{
  CFTypeRef cf = 0LL;
  uint64_t v5 = 0LL;
  CFIndex v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  if (gTrustd && (uint64_t v0 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 104)) != 0LL)
  {
    uint64_t v1 = v0(&cf);
  }

  else
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __CopyTrustedCTLogs_block_invoke_2;
    unint64_t v4[3] = &unk_18966FAA8;
    void v4[4] = &v5;
    securityd_send_sync_and_do(0x19u, &cf, (uint64_t)&__block_literal_global_417, (uint64_t)v4);
    uint64_t v1 = v6[3];
  }

  _Block_object_dispose(&v5, 8);
  if (cf) {
    CFRelease(cf);
  }
  return v1;
}

BOOL __CopyTrustedCTLogs_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (!xdict || !xpc_dictionary_get_value(xdict, "status") || MEMORY[0x186E0087C]() != MEMORY[0x1895F9250]) {
    return SecError(-26276, a3, @"Unable to get CT logs");
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t __CopyTrustedCTLogs_block_invoke()
{
  return 1LL;
}

uint64_t SecCertificateCopyCTLogForKeyID(const __CFData *a1)
{
  CFTypeRef cf = 0LL;
  uint64_t v11 = 0LL;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  if (a1 && (CFTypeID v2 = CFGetTypeID(a1), v2 == CFDataGetTypeID()))
  {
    uint64_t BytePtr = CFDataGetBytePtr(a1);
    if (BytePtr && (xpc_object_t v4 = BytePtr, CFDataGetLength(a1) == 32))
    {
      if (gTrustd)
      {
        uint64_t v5 = *(uint64_t (**)(const __CFData *, CFTypeRef *))(gTrustd + 112);
        if (v5)
        {
          uint64_t v6 = v5(a1, &cf);
          goto LABEL_11;
        }
      }

      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 0x40000000LL;
      v10[2] = __CopyCTLogForKeyID_block_invoke;
      unint64_t v10[3] = &__block_descriptor_tmp_425;
      void v10[4] = v4;
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 0x40000000LL;
      v9[2] = __CopyCTLogForKeyID_block_invoke_2;
      v9[3] = &unk_18966FAF0;
      void v9[4] = &v11;
      securityd_send_sync_and_do(0x1Au, &cf, (uint64_t)v10, (uint64_t)v9);
    }

    else
    {
      SecError(-50, (__CFString **)&cf, @"keyID data was not the expected length");
    }
  }

  else
  {
    SecError(-50, (__CFString **)&cf, @"keyID was not a valid CFDataRef");
  }

  uint64_t v6 = v12[3];
LABEL_11:
  _Block_object_dispose(&v11, 8);
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t __CopyCTLogForKeyID_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  return 1LL;
}

BOOL __CopyCTLogForKeyID_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (!xdict || !xpc_dictionary_get_value(xdict, "status") || MEMORY[0x186E0087C]() != MEMORY[0x1895F9250]) {
    return SecError(-26276, a3, @"Unable to match CT log");
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

__CFArray *SecCertificateCopyiPhoneDeviceCAChain()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0LL, &_AppleiPhoneDeviceCA, 877LL);
  if (!v0) {
    return 0LL;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0LL, &_AppleiPhoneCA, 1015LL);
  if (!v2)
  {
    uint64_t v6 = 0LL;
    xpc_object_t v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }

  size_t v3 = v2;
  xpc_object_t v4 = SecCertificateCreateWithBytes(0LL, &_AppleRootCA, 1215LL);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 3LL, MEMORY[0x189605228]);
    uint64_t v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  CFRelease(v1);
  CFRelease(v3);
  if (v4) {
    goto LABEL_7;
  }
  return v6;
}

BOOL SecCertificateGetDeveloperIDDate(uint64_t a1, double *a2, __CFString **a3)
{
  if (!a1 || !a2) {
    return SecError(-50, a3, @"DeveloperID Date parsing: missing required input");
  }
  uint64_t ExtensionValue = SecCertificateGetExtensionValue(a1, @"1.2.840.113635.100.6.1.33");
  if (!ExtensionValue) {
    return SecError(-67880, a3, @"DeveloperID Date parsing: extension not found");
  }
  memset(v8, 170, sizeof(v8));
  CFTypeRef cf = 0LL;
  if (v8[0] != 12) {
    return SecError(-26275, a3, @"DeveloperID Date parsing: extension value wrong tag", cf);
  }
  *a2 = SecAbsoluteTimeFromDateContentWithError(24LL, (unsigned __int8 *)v8[1], v8[2], (CFErrorRef *)&cf);
  if (!cf) {
    return 1LL;
  }
  if (a3 && !*a3)
  {
    BOOL result = 0LL;
    *a3 = (__CFString *)cf;
  }

  else
  {
    CFRelease(cf);
    return 0LL;
  }

  return result;
}

uint64_t SecCertificateGetUnparseableKnownExtension(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 528);
  }
  else {
    return -1LL;
  }
}

uint64_t SecCertificateGetDuplicateExtension(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 536);
  }
  else {
    return -1LL;
  }
}

__CFArray *SecCertificateCopyAppleExternalRoots()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0LL, &_AppleExternalECRootCA, 519LL);
  if (!v0) {
    return 0LL;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0LL, &_TestAppleExternalECRootCA, 530LL);
  if (v2)
  {
    size_t v3 = v2;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    uint64_t v5 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
    }

    CFRelease(v1);
  }

  else
  {
    uint64_t v5 = 0LL;
    size_t v3 = v1;
  }

  CFRelease(v3);
  return v5;
}

__CFArray *SecCertificateCopyAppleCorporateRoots()
{
  uint64_t v0 = SecCertificateCreateWithBytes(0LL, &_AppleCorporateRootCA, 949LL);
  if (!v0) {
    return 0LL;
  }
  uint64_t v1 = v0;
  CFTypeID v2 = SecCertificateCreateWithBytes(0LL, &_AppleCorporateRootCA2, 585LL);
  if (!v2)
  {
    uint64_t v6 = 0LL;
    xpc_object_t v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }

  size_t v3 = v2;
  xpc_object_t v4 = SecCertificateCreateWithBytes(0LL, &_AppleCorporateRootCA3, 1417LL);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
    uint64_t v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  CFRelease(v1);
  CFRelease(v3);
  if (v4) {
    goto LABEL_7;
  }
  return v6;
}

uint64_t SecCurve25519PublicKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  xpc_object_t v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 6)
  {
    if (a4 != 7) {
      return 4294967246LL;
    }
    if (a3 == 32)
    {
      uint64_t result = 0LL;
      __int128 v6 = a2[1];
      *xpc_object_t v4 = *a2;
      v4[1] = v6;
      return result;
    }

    return 4294941021LL;
  }

  if (a3 != 32) {
    return 4294941021LL;
  }
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7 == &kSecEd25519PublicKeyDescriptor || v7 == &kSecEd25519PrivateKeyDescriptor)
  {
    ccsha512_di();
    ccrng();
    uint64_t result = cced25519_make_pub_with_rng();
    if (!(_DWORD)result) {
      return result;
    }
    int v9 = result;
    _SECKEY_LOG();
    CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    int v13 = 67109120;
    int v14 = v9;
    uint64_t v11 = "cced25519_make_pub_with_rng() failed, error %d";
    goto LABEL_21;
  }

  ccrng();
  uint64_t result = cccurve25519_make_pub_with_rng();
  if ((_DWORD)result)
  {
    int v12 = result;
    _SECKEY_LOG();
    CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021LL;
    }

    int v13 = 67109120;
    int v14 = v12;
    uint64_t v11 = "cccurve25519_make_pub_with_rng() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_1804F4000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v13, 8u);
    goto LABEL_18;
  }

  return result;
}

uint64_t SecCurve25519PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PublicKeyBlockSize()
{
  return 32LL;
}

__CFDictionary *SecCurve25519PublicKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor) {
    size_t v3 = @"105";
  }
  else {
    size_t v3 = @"106";
  }
  xpc_object_t v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0LL);
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v4);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x189604DE0]);
  if (v4) {
    CFRelease(v4);
  }
  return MutableCopy;
}

uint64_t SecCurve25519PublicKeyCopyKeyDescription(uint64_t a1)
{
  CFTypeID v2 = *(void **)(a1 + 16);
  size_t v3 = (void *)NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  uint64_t v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v8) {
    uint64_t v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  CFStringRef v10 = "kSecX25519";
  if (v9) {
    CFStringRef v10 = "kSecEd25519";
  }
  objc_msgSend( v3,  "stringWithFormat:",  @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v10,  AlgorithmId,  v6,  v7,  v8,  a1);
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecCurve25519KeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor) {
    return 4LL;
  }
  else {
    return 5LL;
  }
}

uint64_t SecCurve25519PublicKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  size_t v3 = (const UInt8 *)a1[3];
  xpc_object_t v4 = CFGetAllocator(a1);
  CFDataRef v5 = CFDataCreate(v4, v3, 32LL);
  *a2 = v5;
  if (v5) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

uint64_t SecCurve25519KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0LL;
}

CFDataRef SecCurve25519PublicKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v1 = (const UInt8 *)a1[3];
  CFTypeID v2 = CFGetAllocator(a1);
  return CFDataCreate(v2, v1, 32LL);
}

uint64_t SecCurve25519PublicKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  uint64_t v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd25519PublicKeyDescriptor || v8 == &kSecEd25519PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve25519:SHA512"))
  {
    uint64_t v14 = MEMORY[0x189605018];
    return *(void *)v14;
  }

  if (a5)
  {
LABEL_9:
    uint64_t v14 = MEMORY[0x189604DE8];
    return *(void *)v14;
  }

  CFIndex Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 64)
  {
    ccsha512_di();
    uint64_t v17 = cced25519_verify();
    if (!(_DWORD)v17) {
      goto LABEL_9;
    }
    SecError(-67808, a8, @"Ed25519 signature verification failed (ccerr %d)", v17);
  }

  else
  {
    SecError(-67808, a8, @"Ed25519 signature verification failed (invalid signature length)");
  }

  return 0LL;
}

uint64_t SecCurve25519PrivateKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  xpc_object_t v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 5)
  {
    if (a4 != 7) {
      return 4294899625LL;
    }
    if (a3 == 32)
    {
      uint64_t result = 0LL;
      __int128 v6 = a2[1];
      *xpc_object_t v4 = *a2;
      v4[1] = v6;
      return result;
    }

    return 4294941021LL;
  }

  __int128 v17 = 0u;
  __int128 v18 = 0u;
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7 != &kSecEd25519PublicKeyDescriptor && v7 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    int key_pair = cccurve25519_make_key_pair();
    if (!key_pair) {
      goto LABEL_15;
    }
    int v14 = key_pair;
    _SECKEY_LOG();
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021LL;
    }

    int v15 = 67109120;
    int v16 = v14;
    int v12 = "cccurve25519_make_key_pair() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_1804F4000, (os_log_t)v11, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v15, 8u);
    goto LABEL_18;
  }

  ccsha512_di();
  ccrng();
  int v9 = cced25519_make_key_pair();
  if (v9)
  {
    int v10 = v9;
    _SECKEY_LOG();
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    int v15 = 67109120;
    int v16 = v10;
    int v12 = "cced25519_make_key_pair() failed, error %d";
    goto LABEL_21;
  }

uint64_t SecCurve25519PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PrivateKeyBlockSize()
{
  return 32LL;
}

CFDictionaryRef SecCurve25519PrivateKeyCopyAttributeDictionary(void *a1)
{
  CFTypeID v2 = (const UInt8 *)a1[3];
  size_t v3 = CFGetAllocator(a1);
  xpc_object_t v4 = CFDataCreate(v3, v2, 32LL);
  CFDataRef v5 = (void *)a1[2];
  if (v5 == &kSecEd25519PrivateKeyDescriptor || v5 == &kSecEd25519PublicKeyDescriptor) {
    uint64_t v7 = @"105";
  }
  else {
    uint64_t v7 = @"106";
  }
  CFDictionaryRef v8 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v7, v4);
  if (v4) {
    CFRelease(v4);
  }
  return v8;
}

CFStringRef SecCurve25519PrivateKeyCopyKeyDescription(uint64_t a1)
{
  CFTypeID v2 = *(void **)(a1 + 16);
  size_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  CFDataRef v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFDictionaryRef v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v8) {
    CFDictionaryRef v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  int v10 = "kSecX25519";
  if (v9) {
    int v10 = "kSecEd25519";
  }
  return CFStringCreateWithFormat( v3,  0LL,  @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v10,  AlgorithmId,  v6,  v7,  v8,  a1);
}

uint64_t SecCurve25519PrivateKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  memset(v9, 0, sizeof(v9));
  xpc_object_t v4 = (void *)a1[2];
  if (v4 != &kSecEd25519PublicKeyDescriptor && v4 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    return 4294941020LL;
  }

  ccsha512_di();
  ccrng();
LABEL_9:
  CFDictionaryRef v8 = CFGetAllocator(a1);
  *a2 = CFDataCreate(v8, (const UInt8 *)v9, 32LL);
  cc_clear();
  if (*a2) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

uint64_t SecCurve25519KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0LL;
}

CFDataRef SecCurve25519PrivateKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v1 = (const UInt8 *)a1[3];
  CFTypeID v2 = CFGetAllocator(a1);
  return CFDataCreate(v2, v1, 32LL);
}

__CFData *SecCurve25519PrivateKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x189605018];
  if (a2 != 4)
  {
    if (a2) {
      return Mutable;
    }
    int v14 = *(void **)(a1 + 16);
    BOOL v15 = v14 == &kSecEd25519PublicKeyDescriptor || v14 == &kSecEd25519PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve25519:SHA512")) {
      return Mutable;
    }
    if (!a5)
    {
      ccsha512_di();
      ccrng();
      if (cced25519_make_pub_with_rng())
      {
        SecError(-2070, a8, @"%@: Failed to get public key from private key", a1);
        return Mutable;
      }

      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
      CFDataSetLength(Mutable, 64LL);
      if (!Mutable)
      {
        SecError(-108, a8, @"%@: Failed to create buffer for a signature", a1);
        return Mutable;
      }

      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccsha512_di();
      ccrng();
      uint64_t v16 = cced25519_sign_with_rng();
      cc_clear();
      if ((_DWORD)v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, @"%@: Ed25519 signing failed (ccerr %d)", a1, v16, 0LL, 0LL, 0LL, 0LL);
        return 0LL;
      }

      return Mutable;
    }

    return (__CFData *)*MEMORY[0x189604DE8];
  }

  __int128 v17 = *(void **)(a1 + 16);
  BOOL v18 = v17 == &kSecEd25519PublicKeyDescriptor || v17 == &kSecEd25519PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x189604DE8];
  }
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 32)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
    CFDataSetLength(Mutable, 32LL);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    uint64_t v19 = cccurve25519_with_rng();
    if ((_DWORD)v19)
    {
      uint64_t v21 = v19;
      if (Mutable) {
        CFRelease(Mutable);
      }
      SecError(-50, a8, @"%@: X25519 DH failed (ccerr %d)", a1, v21);
      return 0LL;
    }

    CFDataSetLength(Mutable, 32LL);
  }

  else
  {
    SecError(-50, a8, @"X25519priv sharedsecret: bad public key");
  }

  return Mutable;
}

id _SECKEY_LOG()
{
  if (_SECKEY_LOG_once != -1) {
    dispatch_once(&_SECKEY_LOG_once, &__block_literal_global_8340);
  }
  return (id)_SECKEY_LOG_log;
}

uint64_t curve25519KeyGeneratePair(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 4) {
    BOOL v9 = &kSecEd25519PrivateKeyDescriptor;
  }
  else {
    BOOL v9 = &kSecX25519PrivateKeyDescriptor;
  }
  uint64_t v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0LL, 5LL);
  if (!v10) {
    return 4294967246LL;
  }
  uint64_t v11 = v10;
  if (a4 == 4) {
    int v12 = &kSecEd25519PublicKeyDescriptor;
  }
  else {
    int v12 = &kSecX25519PublicKeyDescriptor;
  }
  int v13 = SecKeyCreate(v8, (uint64_t)v12, v10[3], 32LL, 6LL);
  if (!v13)
  {
    uint64_t v14 = 4294967246LL;
LABEL_18:
    CFRelease(v11);
    return v14;
  }

  if (a2)
  {
    *a2 = v13;
    int v13 = 0LL;
  }

  if (a3)
  {
    *a3 = v11;
    uint64_t v11 = 0LL;
  }

  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = 0LL;
  uint64_t result = 0LL;
  if (v11) {
    goto LABEL_18;
  }
  return result;
}

CFDataRef SecGenerateCertificateRequestWithParameters( const __CFString ***a1, const __CFDictionary *a2, void *a3, __SecKey *a4)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  xpc_object_t v4 = a1;
  if (!*a1) {
    return 0LL;
  }
  char v66 = 0;
  uint64_t v8 = PORT_NewArena(1024);
  CFErrorRef error = 0LL;
  if (!v8)
  {
    BOOL v18 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }

    return 0LL;
  }

  BOOL v9 = v8;
  int64_t v50 = a4;
  __int128 v64 = 0u;
  __int128 v62 = 0u;
  memset(v63, 0, sizeof(v63));
  *(_OWORD *)uint64_t v61 = 0u;
  memset(v60, 0, sizeof(v60));
  char v57 = 0;
  *(void *)__int128 buf = 1LL;
  v59 = &v57;
  uint64_t v10 = *v4;
  if (*v4)
  {
    unsigned int v11 = 0;
    unsigned int v12 = 0;
    int v13 = *v4;
    uint64_t v14 = v4;
    do
    {
      if (*v13)
      {
        BOOL v15 = (uint64_t *)(v13 + 3);
        do
        {
          ++v12;
          uint64_t v16 = *v15;
          v15 += 3;
        }

        while (v16);
      }

      ++v12;
      ++v11;
      __int128 v17 = v14[1];
      ++v14;
      int v13 = v17;
    }

    while (v17);
  }

  else
  {
    unsigned int v12 = 0;
    unsigned int v11 = 0;
  }

  int64_t v49 = a2;
  if (v12 <= 1) {
    uint64_t v21 = 1LL;
  }
  else {
    uint64_t v21 = v12;
  }
  if (v11 <= 1) {
    unsigned int v22 = 1;
  }
  else {
    unsigned int v22 = v11;
  }
  int v23 = (char *)malloc(8 * (v21 + 4LL * v21));
  int v24 = malloc(8LL * v21);
  uint64_t v25 = (char *)malloc(8LL * v22);
  uint64_t v26 = malloc(8LL * (v11 + 1));
  CFRange v51 = v26;
  CFDataRef v52 = v25;
  unsigned int v27 = 0;
  if (v10)
  {
    LODWORD(v2_Block_object_dispose(va, 8) = 0;
    while (1)
    {
      *(void *)&v25[8 * v27] = &v24[v28];
      *((void *)v26 + v27) = &v25[8 * v27];
      __int128 v29 = *v10;
      if (*v10) {
        break;
      }
      uint64_t v32 = v28;
LABEL_30:
      ++v27;
      LODWORD(v2_Block_object_dispose(va, 8) = v28 + 1;
      v24[v32] = 0LL;
      __int128 v33 = v4[1];
      ++v4;
      uint64_t v10 = v33;
      if (!v33) {
        goto LABEL_31;
      }
    }

    __int128 v30 = v10 + 3;
    while ((make_nss_atv( (uint64_t)v9,  v29,  *(v30 - 1),  *((unsigned __int8 *)v30 - 16),  (uint64_t)&v23[40 * v28],  (__CFString **)&error) & 1) != 0)
    {
      v24[v28] = &v23[40 * v28];
      uint64_t v28 = (v28 + 1);
      __int128 v31 = *v30;
      v30 += 3;
      __int128 v29 = v31;
      if (!v31)
      {
        uint64_t v32 = v28;
        uint64_t v26 = v51;
        uint64_t v25 = v52;
        goto LABEL_30;
      }
    }

    CFNumberRef v40 = (os_log_s *)secLogObjForScope("SecError");
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    *(_WORD *)int v67 = 0;
    int v41 = "csr: failed to encode atv";
    goto LABEL_44;
  }

uint64_t make_nss_atv( uint64_t a1, const __CFString *a2, const __CFString *cf, int a4, uint64_t a5, __CFString **a6)
{
  CFTypeID v12 = CFGetTypeID(cf);
  if (v12 == CFStringGetTypeID())
  {
    CFIndex Length = CFStringGetLength(cf);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    BOOL v15 = (char *)PORT_ArenaAlloc(a1, MaximumSizeForEncoding);
    if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x600u))
    {
      if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x8000100u))
      {
        SecError(-50, a6, @"ATV value is not a Printable or UTF8 string");
        return 0LL;
      }

      char v16 = 12;
      if (a4 && a4 != 12)
      {
        SecError(-50, a6, @"ATV input type does not match value encoding");
        return 0LL;
      }

      goto LABEL_26;
    }

    if (a4 != 19)
    {
      char v16 = a4;
      if (a4)
      {
LABEL_26:
        size_t v21 = strlen(v15);
        LOBYTE(a4) = v16;
        goto LABEL_27;
      }
    }

    if (!a2) {
      goto LABEL_22;
    }
    CFTypeID v17 = CFGetTypeID(a2);
    if (v17 == CFStringGetTypeID())
    {
      if (!CFEqual(@"1.2.840.113549.1.9.1", a2) && CFStringCompare(@"EMAIL", a2, 1uLL))
      {
LABEL_22:
        int v19 = 0;
        char v18 = 19;
LABEL_23:
        else {
          char v16 = 12;
        }
        goto LABEL_26;
      }
    }

    else
    {
      CFTypeID v22 = CFGetTypeID(a2);
      if (v22 != CFDataGetTypeID()) {
        goto LABEL_22;
      }
      if (CFDataGetLength((CFDataRef)a2) != 9) {
        goto LABEL_22;
      }
      uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)a2);
      if (memcmp(BytePtr, &_oidEmailAddress, 9uLL)) {
        goto LABEL_22;
      }
    }

    char v18 = 22;
    int v19 = 1;
    goto LABEL_23;
  }

  CFTypeID v20 = CFGetTypeID(cf);
  if (v20 != CFDataGetTypeID())
  {
    SecError(-50, a6, @"ATV value of unsupported type");
    return 0LL;
  }

  size_t v21 = CFDataGetLength((CFDataRef)cf);
  BOOL v15 = (char *)CFDataGetBytePtr((CFDataRef)cf);
LABEL_27:
  CFIndex v30 = 0LL;
  CFTypeID v24 = CFGetTypeID(a2);
  if (v24 == CFStringGetTypeID())
  {
    if (CFEqual(@"CN", a2))
    {
      uint64_t v25 = &oidCommonName;
LABEL_46:
      uint64_t data = (uint64_t)v25->data;
      CFIndex v27 = v25->length;
      goto LABEL_47;
    }

    if (CFEqual(@"C", a2))
    {
      uint64_t v25 = &oidCountryName;
      goto LABEL_46;
    }

    if (CFEqual(@"ST", a2))
    {
      uint64_t v25 = &oidStateOrProvinceName;
      goto LABEL_46;
    }

    if (CFEqual(@"L", a2))
    {
      uint64_t v25 = &oidLocalityName;
      goto LABEL_46;
    }

    if (CFEqual(@"O", a2))
    {
      uint64_t v25 = &oidOrganizationName;
      goto LABEL_46;
    }

    if (CFEqual(@"OU", a2))
    {
      uint64_t v25 = &oidOrganizationalUnitName;
      goto LABEL_46;
    }

    if (CFEqual(@"EMAIL", a2))
    {
      uint64_t v25 = &oidEmailAddress;
      goto LABEL_46;
    }

    uint64_t data = oid_der_data(a1, a2, &v30);
    if (data)
    {
      CFIndex v27 = v30;
      goto LABEL_47;
    }

    SecError(-26276, a6, @"ATV OID encode failed for %@", a2);
    return 0LL;
  }

  CFTypeID v26 = CFGetTypeID(a2);
  if (v26 != CFDataGetTypeID())
  {
    SecError(-50, a6, @"ATV OID of unsupported type");
    return 0LL;
  }

  CFIndex v27 = CFDataGetLength((CFDataRef)a2);
  uint64_t data = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
LABEL_47:
  *(void *)a5 = v27;
  *(void *)(a5 + _Block_object_dispose(va, 8) = data;
  *(void *)(a5 + 16) = v21;
  *(void *)(a5 + 24) = v15;
  *(_BYTE *)(a5 + 32) = a4;
  *(_DWORD *)(a5 + 33) = -1431655766;
  uint64_t result = 1LL;
  *(_DWORD *)(a5 + 36) = -1431655766;
  return result;
}

CFDataRef make_public_key(__SecKey *a1, uint64_t a2, char *a3, CFErrorRef *error)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v8 = SecKeyCopyExternalRepresentation(a1, error);
  if (v8)
  {
    if (SecKeyGetAlgorithmId((uint64_t)a1) == 1)
    {
      char v9 = 0;
      *(void *)a2 = 9LL;
      *(void *)(a2 + _Block_object_dispose(va, 8) = &_oidRsa;
      *(_OWORD *)(a2 + 16) = asn1_null;
LABEL_8:
      *a3 = v9;
      *(void *)(a2 + 40) = CFDataGetBytePtr(v8);
      *(void *)(a2 + 32) = 8 * CFDataGetLength(v8);
      return v8;
    }

    if (SecKeyGetAlgorithmId((uint64_t)a1) == 3)
    {
      *(void *)a2 = 7LL;
      *(void *)(a2 + _Block_object_dispose(va, 8) = &_oidEcPubKey;
      unsigned int v10 = SecECKeyGetNamedCurve(a1) - 23;
      if (v10 <= 2)
      {
        unsigned int v11 = off_189679138[v10];
        size_t v12 = *(void *)*(&off_189679150 + (int)v10);
        int v13 = malloc(v12 + 2);
        memcpy(v13 + 2, v11->data, v12);
        *int v13 = 6;
        v13[1] = v12;
        *(void *)(a2 + 16) = v12 + 2;
        *(void *)(a2 + 24) = v13;
        char v9 = 1;
        goto LABEL_8;
      }

      SecError(-4, (__CFString **)error, @"unsupported EC curve");
    }

    else
    {
      SecError(-4, (__CFString **)error, @"unsupported key algorithmId");
    }

    CFRelease(v8);
    return 0LL;
  }

  return v8;
}

void *nss_attributes_from_parameters_dict(uint64_t a1, CFDictionaryRef theDict)
{
  if (!theDict) {
    return 0LL;
  }
  Value = (const __CFString *)CFDictionaryGetValue(theDict, @"csrChallengePassword");
  CFDataRef v5 = Value;
  if (Value)
  {
    CFIndex Length = CFStringGetLength(Value);
    unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v8 = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding <= 1) {
      unint64_t v9 = 1LL;
    }
    else {
      unint64_t v9 = MaximumSizeForEncoding;
    }
    unsigned int v10 = (char *)PORT_ArenaAlloc(a1, v9);
    unsigned int v11 = v10;
    if (v10) {
      bzero(v10, v9);
    }
    if (CFStringGetCString(v5, v11, v8, 0x600u))
    {
      else {
        size_t v12 = kSecAsn1UTF8StringTemplate;
      }
    }

    else
    {
      if (!CFStringGetCString(v5, v11, v8, 0x8000100u))
      {
        CFTypeID v24 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v39[0]) = 0;
          uint64_t v25 = "csr: unable to get challenge bytes";
          __int128 v34 = (uint8_t *)v39;
LABEL_51:
          _os_log_impl(&dword_1804F4000, v24, OS_LOG_TYPE_DEFAULT, v25, v34, 2u);
          return 0LL;
        }

        return 0LL;
      }

      size_t v12 = kSecAsn1UTF8StringTemplate;
    }

    CFTypeID v17 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
    char v18 = v17;
    if (v17)
    {
      *CFTypeID v17 = 0LL;
      v17[1] = 0LL;
    }

    v39[0] = strlen(v11);
    v39[1] = v11;
    if (!SEC_ASN1EncodeItem(a1, v18, (uint64_t)v39, (uint64_t)v12))
    {
      CFTypeID v24 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_WORD *)__int128 buf = 0;
      uint64_t v25 = "csr: failed to encode challenge";
      goto LABEL_50;
    }

    int v19 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
    BOOL v15 = v19;
    if (v19) {
      v19[1] = 0LL;
    }
    *int v19 = v18;
    unsigned int v16 = 1;
    uint64_t v14 = &pkcs9ChallengePassword_8416;
    uint64_t v13 = 9LL;
  }

  else
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    BOOL v15 = 0LL;
    unsigned int v16 = 0;
  }

  v39[0] = 0LL;
  if ((extensions_from_parameters(a1, theDict, v39, 0LL) & 1) == 0)
  {
    CFTypeID v24 = (os_log_s *)secLogObjForScope("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      return 0LL;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v25 = "csr: failed to encode extensions";
LABEL_50:
    __int128 v34 = buf;
    goto LABEL_51;
  }

  uint64_t v20 = v39[0];
  if (!v39[0])
  {
    uint64_t v36 = 0LL;
    __int128 v37 = 0LL;
    int v23 = 0LL;
    goto LABEL_32;
  }

  size_t v21 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
  CFTypeID v22 = v21;
  if (v21)
  {
    *size_t v21 = 0LL;
    v21[1] = 0LL;
  }

  if (!SEC_ASN1EncodeItem(a1, v21, (uint64_t)v39, (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate))
  {
    CFTypeID v24 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v25 = "csr: failed to encode extension attributes";
      goto LABEL_50;
    }

    return 0LL;
  }

  int v23 = (void *)PORT_ArenaAlloc(a1, 0x10uLL);
  *int v23 = v22;
  v23[1] = 0LL;
  ++v16;
  uint64_t v36 = 9LL;
  __int128 v37 = &pkcs9ExtensionsRequested;
LABEL_32:
  else {
    unint64_t v26 = 8LL * (v16 + 1);
  }
  CFIndex v27 = (void *)PORT_ArenaAlloc(a1, v26);
  uint64_t v28 = v27;
  if (v27) {
    bzero(v27, v26);
  }
  else {
    unint64_t v29 = 24LL * v16;
  }
  CFIndex v30 = (char *)PORT_ArenaAlloc(a1, v29);
  __int128 v31 = v30;
  if (v30) {
    bzero(v30, v29);
  }
  if (v5)
  {
    uint64_t v32 = (uint64_t *)&v31[24 * --v16];
    uint64_t *v32 = v13;
    v32[1] = (uint64_t)v14;
    v32[2] = (uint64_t)v15;
    v28[v16] = v32;
  }

  if (v20)
  {
    __int128 v33 = (uint64_t *)&v31[24 * v16 - 24];
    *__int128 v33 = v36;
    v33[1] = (uint64_t)v37;
    v33[2] = (uint64_t)v23;
    v28[v16 - 1] = v33;
  }

  return v28;
}

CFDataRef make_signature( const UInt8 *a1, CFIndex a2, __SecKey *a3, const void *a4, DERSize *a5, __CFString **a6)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a3);
  if (AlgorithmId == 3)
  {
    if (!a4 || kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
    {
      uint64_t v20 = &oidSha256Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }

    else if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
    {
      uint64_t v20 = &oidSha384Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }

    else
    {
      if (!kSecCMSHashingAlgorithmSHA512 || !CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
      {
        BOOL v15 = 0LL;
LABEL_18:
        a5[2] = 0LL;
        a5[3] = 0LL;
        if (v15) {
          goto LABEL_9;
        }
LABEL_19:
        SecError(-4, a6, @"unsupported key or hashing algorithm");
        return 0LL;
      }

      uint64_t v20 = &oidSha512Ecdsa;
      size_t v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }

    BOOL v15 = *v21;
    int v23 = v20;
    uint64_t data = v20->data;
    *a5 = v23->length;
    a5[1] = (DERSize)data;
    goto LABEL_18;
  }

  if (AlgorithmId != 1) {
    goto LABEL_19;
  }
  if (!a4 || kSecCMSHashingAlgorithmSHA1 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA1))
  {
    uint64_t v13 = &oidSha1Rsa;
    uint64_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
LABEL_7:
    BOOL v15 = *v14;
    CFTypeID v17 = v13;
    unsigned int v16 = v13->data;
    *a5 = v17->length;
    a5[1] = (DERSize)v16;
    goto LABEL_8;
  }

  if (kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
  {
    uint64_t v13 = &oidSha256Rsa;
    uint64_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_7;
  }

  if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
  {
    uint64_t v13 = &oidSha384Rsa;
    uint64_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_7;
  }

  if (kSecCMSHashingAlgorithmSHA512 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
  {
    uint64_t v13 = &oidSha512Rsa;
    uint64_t v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_7;
  }

  BOOL v15 = 0LL;
LABEL_8:
  *((_OWORD *)a5 + 1) = asn1_null;
  if (!v15) {
    goto LABEL_19;
  }
LABEL_9:
  CFDataRef Signature = 0LL;
  if (a1)
  {
    if (a2)
    {
      int v19 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  a1,  a2,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
      CFDataRef Signature = SecKeyCreateSignature(a3, v15, v19, (CFErrorRef *)a6);
      if (v19) {
        CFRelease(v19);
      }
    }
  }

  return Signature;
}

uint64_t printable_string(const __CFString *a1, int a2)
{
  LODWORD(v2) = a2;
  xpc_object_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v5 = CFCharacterSetCreateWithCharactersInString( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 '()+,-./:=?@");
  CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(v4, v5);
  uint64_t v7 = CFCharacterSetCreateWithCharactersInString(v4, @"@");
  v9.size_t length = CFStringGetLength(a1);
  v9.location = 0LL;
  if (CFStringFindCharacterFromSet(a1, InvertedSet, v9, 0LL, 0LL))
  {
    uint64_t v2 = 0LL;
    if (!v5) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  v10.size_t length = CFStringGetLength(a1);
  v10.location = 0LL;
  if (CFStringFindCharacterFromSet(a1, v7, v10, 0LL, 0LL)) {
    uint64_t v2 = v2;
  }
  else {
    uint64_t v2 = 1LL;
  }
  if (v5) {
LABEL_3:
  }
    CFRelease(v5);
LABEL_4:
  if (InvertedSet) {
    CFRelease(InvertedSet);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v2;
}

uint64_t extensions_from_parameters(uint64_t a1, const __CFDictionary *a2, void *a3, __CFString **a4)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  uint64_t v8 = PORT_ArenaAlloc(a1, 0x58uLL);
  CFRange v9 = (void *)v8;
  if (v8)
  {
    *(void *)(v8 + 80) = 0LL;
    *(_OWORD *)(v8 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v8 + 64) = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
    *(_OWORD *)(v8 + 32) = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
  }

  CFRange v10 = (_OWORD *)PORT_ArenaAlloc(a1, 0x1E0uLL);
  unsigned int v11 = v10;
  if (v10)
  {
    v10[28] = 0u;
    v10[29] = 0u;
    v10[26] = 0u;
    v10[27] = 0u;
    v10[24] = 0u;
    v10[25] = 0u;
    v10[22] = 0u;
    v10[23] = 0u;
    v10[20] = 0u;
    v10[21] = 0u;
    v10[18] = 0u;
    v10[19] = 0u;
    v10[16] = 0u;
    v10[17] = 0u;
    v10[14] = 0u;
    v10[15] = 0u;
    v10[12] = 0u;
    v10[13] = 0u;
    v10[10] = 0u;
    v10[11] = 0u;
    v10[8] = 0u;
    void v10[9] = 0u;
    v10[6] = 0u;
    v10[7] = 0u;
    void v10[4] = 0u;
    void v10[5] = 0u;
    v10[2] = 0u;
    unint64_t v10[3] = 0u;
    *CFRange v10 = 0u;
    v10[1] = 0u;
  }

  CFTypeRef cf = 0LL;
  unint64_t Value = (unint64_t)CFDictionaryGetValue(a2, @"basicConstraintsCA");
  uint64_t v13 = (const __CFNumber *)CFDictionaryGetValue(a2, @"basicConstraints");
  if (Value | (unint64_t)v13)
  {
    if (Value == *MEMORY[0x189604DE0] && v13 != 0LL)
    {
      SecError(-50, (__CFString **)&cf, @"non-CA cert does not support path len");
LABEL_83:
      if (cf)
      {
        BOOL v72 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = cf;
          _os_log_impl( &dword_1804F4000,  v72,  OS_LOG_TYPE_DEFAULT,  "csr: extension encoding failed: %@",  (uint8_t *)&context,  0xCu);
        }

        int v73 = (__CFString *)cf;
        if (a4)
        {
          if (cf)
          {
            CFRetain(cf);
            CFDateRef v74 = (__CFString *)cf;
          }

          else
          {
            CFDateRef v74 = 0LL;
          }

          *a4 = v73;
          int v73 = v74;
        }

        if (v73)
        {
          CFTypeRef cf = 0LL;
          CFRelease(v73);
        }
      }

      return 0LL;
    }

    if (Value == *MEMORY[0x189604DE0]) {
      BOOL v15 = &asn1_false;
    }
    else {
      BOOL v15 = &asn1_true;
    }
    __int128 context = *v15;
    uint64_t v85 = 0LL;
    v86 = 0LL;
    LOBYTE(v82) = -86;
    if (v13)
    {
      LODWORD(valuePtr) = 0;
      if (!CFNumberGetValue(v13, kCFNumberIntType, &valuePtr))
      {
        SecError(-50, (__CFString **)&cf, @"failed to get basic constraints path length value");
        goto LABEL_83;
      }

      if (valuePtr <= 0xFF)
      {
        LOBYTE(v82) = valuePtr;
        uint64_t v85 = 1LL;
        v86 = (__CFString **)&v82;
      }
    }

    void *v11 = 3LL;
    v11[1] = &_oidBasicConstraints;
    *((_OWORD *)v11 + 1) = asn1_true;
    if (!SEC_ASN1EncodeItem(a1, v11 + 4, (uint64_t)&context, (uint64_t)&kSecAsn1BasicConstraintsTemplate))
    {
      SecError(-50, (__CFString **)&cf, @"failed to encode basic constraints extension");
      goto LABEL_83;
    }

    unsigned int v16 = 1;
  }

  else
  {
    unsigned int v16 = 0;
  }

  CFTypeID v17 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"subjectAltName");
  if (v17)
  {
    char v18 = v17;
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for subjectAltName");
      goto LABEL_83;
    }

    __int128 valuePtr = 0uLL;
    __int128 context = (unint64_t)a1;
    uint64_t v85 = 0LL;
    v86 = a4;
    CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)make_general_names, &context);
    else {
      unint64_t v20 = 8LL * (v85 + 1);
    }
    size_t v21 = (void *)PORT_ArenaAlloc(a1, v20);
    CFTypeID v22 = v21;
    if (v21) {
      bzero(v21, v20);
    }
    int v23 = &v11[6 * v16];
    if ((_DWORD)v85)
    {
      uint64_t v24 = 0LL;
      uint64_t v25 = 16LL * v85;
      unint64_t v26 = v22;
      do
      {
        *v26++ = *((void *)&context + 1) + v24;
        v24 += 16LL;
      }

      while (v25 != v24);
    }

    v82 = v22;
    *((_OWORD *)v23 + 2) = valuePtr;
    *int v23 = 3LL;
    v23[1] = &_oidSubjectAltName;
    ++v16;
  }

  theDict = a2;
  CFIndex v27 = (const __CFArray *)CFDictionaryGetValue(a2, @"certificateEKUs");
  if (v27)
  {
    uint64_t v28 = v27;
    CFTypeID v29 = CFGetTypeID(v27);
    if (v29 != CFArrayGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, @"wrong value type for EKU");
      goto LABEL_83;
    }

    unsigned int v76 = v16;
    uint64_t v77 = a3;
    v78 = a4;
    __int128 context = 0uLL;
    CFIndex Count = CFArrayGetCount(v28);
    uint64_t v31 = Count;
    else {
      unint64_t v32 = 8 * Count + 8;
    }
    __int128 v33 = (void *)PORT_ArenaAlloc(a1, v32);
    __int128 v34 = v33;
    if (v33) {
      bzero(v33, v32);
    }
    if (v31 >= 1)
    {
      CFIndex v35 = 0LL;
      unsigned int v36 = 1;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v28, v35);
        if (!ValueAtIndex
          || (unint64_t v38 = ValueAtIndex, v39 = CFGetTypeID(ValueAtIndex), v39 != CFStringGetTypeID())
          || !SecCertificateIsOidString(v38))
        {
          BOOL v70 = @"eku is not an OID";
          goto LABEL_80;
        }

        OidDataFromString = SecCertificateCreateOidDataFromString(0LL, v38);
        if (!OidDataFromString) {
          break;
        }
        int v41 = OidDataFromString;
        v34[v35] = PORT_ArenaAlloc(a1, 0x10uLL);
        *(void *)v34[v35] = CFDataGetLength(v41);
        CFIndex Length = CFDataGetLength(v41);
        *(void *)(v34[v35] + 8LL) = PORT_ArenaAlloc(a1, Length);
        uint64_t v43 = *(void **)(v34[v35] + 8LL);
        uint64_t BytePtr = CFDataGetBytePtr(v41);
        CFIndex v45 = CFDataGetLength(v41);
        memcpy(v43, BytePtr, v45);
        CFRelease(v41);
        CFIndex v35 = v36;
        if (v31 <= v36++) {
          goto LABEL_49;
        }
      }

      BOOL v70 = @"failed to create EKU data";
LABEL_80:
      int v71 = -50;
      goto LABEL_81;
    }

void make_general_names(const __CFString *a1, const __CFString *cf, uint64_t a3)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (!cf) {
    return;
  }
  uint64_t v6 = *(__CFString ***)(a3 + 24);
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFRange v9 = 0LL;
    CFRange v10 = (const __CFArray *)cf;
    if (!a1) {
      return;
    }
  }

  else
  {
    CFTypeID v11 = CFGetTypeID(cf);
    if (v11 != CFStringGetTypeID())
    {
      SecError(-50, v6, @"unsupported subjectAltName value type");
      return;
    }

    CFRange v10 = 0LL;
    CFIndex Count = 1LL;
    CFRange v9 = cf;
    if (!a1) {
      return;
    }
  }

  if (Count < 1) {
    return;
  }
  CFTypeID v12 = CFGetTypeID(a1);
  if (v12 != CFStringGetTypeID())
  {
    SecError(-50, v6, @"unsupported subjectAltName key type");
    return;
  }

  if (*(void *)(a3 + 8))
  {
    int v13 = *(_DWORD *)(a3 + 16);
    if (v13 != *(_DWORD *)(a3 + 20)) {
      goto LABEL_24;
    }
  }

  else
  {
    int v13 = *(_DWORD *)(a3 + 20);
  }

  if (v13) {
    unsigned int v14 = 2 * v13;
  }
  else {
    unsigned int v14 = 10;
  }
  else {
    unint64_t v15 = 16LL * v14;
  }
  unsigned int v16 = (void *)PORT_ArenaAlloc(*(void *)a3, v15);
  CFTypeID v17 = v16;
  if (v16) {
    bzero(v16, v15);
  }
  char v18 = *(const void **)(a3 + 8);
  if (v18) {
    memcpy(v17, v18, *(unsigned int *)(a3 + 20));
  }
  *(void *)(a3 + _Block_object_dispose(va, 8) = v17;
  *(_DWORD *)(a3 + 20) = v14;
LABEL_24:
  __int128 v42 = xmmword_180657670;
  uint64_t v43 = 255LL;
  if (CFStringCompare(@"dNSName", a1, 1uLL))
  {
    char v19 = 1;
    if (CFStringCompare(@"rfc822Name", a1, 1uLL))
    {
      if (CFStringCompare(@"uniformResourceIdentifier", a1, 1uLL))
      {
        if (CFStringCompare(@"ntPrincipalName", a1, 1uLL))
        {
          unint64_t v20 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v3_Block_object_dispose(va, 8) = 0;
            _os_log_impl( &dword_1804F4000,  v20,  OS_LOG_TYPE_DEFAULT,  "csr: unsupported SubjectAltName type, skipping",  (uint8_t *)&v38,  2u);
          }

          return;
        }

        __int16 v45 = 770;
        uint64_t v44 = 0x143782010401062BLL;
        if (!v9)
        {
          SecError(-50, v6, @"NTPrincipalName types do not allow multiple values");
          return;
        }

        CFTypeID v34 = CFGetTypeID(v9);
        if (v34 == CFStringGetTypeID())
        {
          CFIndex Length = CFStringGetLength(cf);
          CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          __int128 v37 = (char *)PORT_ArenaAlloc(*(void *)a3, MaximumSizeForEncoding);
          if (!CFStringGetCString(cf, v37, MaximumSizeForEncoding, 0x8000100u))
          {
            SecError(-50, v6, @"failed to get NTPrincipalName value bytes");
            return;
          }

          uint64_t v38 = 10LL;
          CFTypeID v39 = &v44;
          size_t v40 = strlen(v37);
          int v41 = v37;
          if (!SEC_ASN1EncodeItem( *(void *)a3,  (void *)(*(void *)(a3 + 8) + 16LL * *(unsigned int *)(a3 + 16)),  (uint64_t)&v38,  (uint64_t)&my_other_name_template_cons)) {
            SecError(-26276, v6, @"failed to encode NTPrincipalName", v38, v39);
          }
LABEL_52:
          ++*(_DWORD *)(a3 + 16);
          return;
        }

        return;
      }

      char v19 = 6;
    }
  }

  else
  {
    char v19 = 2;
  }

  LOBYTE(v43) = v19;
  if (!v10)
  {
    if (!v9) {
      return;
    }
    CFIndex v29 = CFStringGetLength(v9);
    unint64_t v30 = CFStringGetMaximumSizeForEncoding(v29, 0x8000100u);
    if (v30 <= 1) {
      unint64_t v31 = 1LL;
    }
    else {
      unint64_t v31 = v30;
    }
    unint64_t v32 = (char *)PORT_ArenaAlloc(*(void *)a3, v31);
    __int128 v33 = v32;
    if (v32) {
      bzero(v32, v31);
    }
    if (!CFStringGetCString(v9, v33, v30, 0x600u))
    {
      SecError(-50, v6, @"failed to get subjectAltName value bytes");
      return;
    }

    *((void *)&v42 + 1) = v33;
    *(void *)&__int128 v42 = strlen(v33);
    SEC_ASN1EncodeItem( *(void *)a3,  (void *)(*(void *)(a3 + 8) + 16LL * *(unsigned int *)(a3 + 16)),  (uint64_t)&v42,  (uint64_t)&kSecAsn1GeneralNameTemplate);
    goto LABEL_52;
  }

  CFIndex v21 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v21);
    CFTypeID v23 = CFGetTypeID(ValueAtIndex);
    if (v23 != CFStringGetTypeID())
    {
      SecError(-50, v6, @"subjectAltName value is not a string");
      return;
    }

    CFIndex v24 = CFStringGetLength(ValueAtIndex);
    unint64_t v25 = CFStringGetMaximumSizeForEncoding(v24, 0x8000100u);
    if (v25 <= 1) {
      unint64_t v26 = 1LL;
    }
    else {
      unint64_t v26 = v25;
    }
    CFIndex v27 = (char *)PORT_ArenaAlloc(*(void *)a3, v26);
    uint64_t v28 = v27;
    if (v27) {
      bzero(v27, v26);
    }
    if (!CFStringGetCString(ValueAtIndex, v28, v25, 0x600u)) {
      break;
    }
    *((void *)&v42 + 1) = v28;
    *(void *)&__int128 v42 = strlen(v28);
    SEC_ASN1EncodeItem( *(void *)a3,  (void *)(*(void *)(a3 + 8) + 16LL * *(unsigned int *)(a3 + 16)),  (uint64_t)&v42,  (uint64_t)&kSecAsn1GeneralNameTemplate);
    ++*(_DWORD *)(a3 + 16);
    if (Count == ++v21) {
      return;
    }
  }

  SecError(-50, v6, @"failed to get subjectAltName value bytes");
}

uint64_t add_custom_extension(CFStringRef theString, const __CFString *a2, uint64_t a3)
{
  size_t v3 = *(__CFString ***)(a3 + 32);
  if (*(_DWORD *)(a3 + 16) >= *(_DWORD *)(a3 + 20)) {
    return SecError(-50, v3, @"too many extensions");
  }
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = oid_der_data(*(void *)a3, theString, &v20);
  __int128 v19 = 0uLL;
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == CFStringGetTypeID())
  {
    if (!*(_BYTE *)(a3 + 24)) {
      return SecError(-50, v3, @"encoded extensions must be a data type");
    }
    CFIndex Length = CFStringGetLength(a2);
    unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding <= 1) {
      unint64_t v10 = 1LL;
    }
    else {
      unint64_t v10 = MaximumSizeForEncoding;
    }
    CFTypeID v11 = (char *)PORT_ArenaAlloc(*(void *)a3, v10);
    CFTypeID v12 = v11;
    if (v11) {
      bzero(v11, v10);
    }
    if (!CFStringGetCString(a2, v12, MaximumSizeForEncoding, 0x8000100u)) {
      return SecError(-50, v3, @"failed to get custom extension string bytes");
    }
    size_t v17 = strlen(v12);
    uint64_t BytePtr = (const UInt8 *)v12;
    uint64_t result = (uint64_t)SEC_ASN1EncodeItem(*(void *)a3, &v19, (uint64_t)&v17, (uint64_t)kSecAsn1UTF8StringTemplate);
    if (!result) {
      uint64_t result = SecError(-26276, v3, @"failed to encode extension string");
    }
  }

  else
  {
    CFTypeID v14 = CFGetTypeID(a2);
    if (v14 != CFDataGetTypeID()) {
      return SecError(-50, v3, @"unsupported custom extensions value type");
    }
    if (!*(_BYTE *)(a3 + 24))
    {
      *(void *)&__int128 v19 = CFDataGetLength((CFDataRef)a2);
      uint64_t result = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
      *((void *)&v19 + 1) = result;
      if (!v6) {
        return result;
      }
      goto LABEL_17;
    }

    size_t v17 = CFDataGetLength((CFDataRef)a2);
    uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)a2);
    uint64_t result = (uint64_t)SEC_ASN1EncodeItem(*(void *)a3, &v19, (uint64_t)&v17, (uint64_t)kSecAsn1OctetStringTemplate);
    if (!result) {
      uint64_t result = SecError(-26276, v3, @"failed to encode extension data");
    }
  }

  if (!v6) {
    return result;
  }
LABEL_17:
  if ((void)v19)
  {
    *(_OWORD *)(*(void *)(a3 + 8) + 48LL * *(unsigned int *)(a3 + 16) + 32) = v19;
    unsigned int v15 = *(_DWORD *)(a3 + 16);
    unsigned int v16 = (unint64_t *)(*(void *)(a3 + 8) + 48LL * v15);
    *unsigned int v16 = v20;
    v16[1] = v6;
    *(_DWORD *)(a3 + 16) = v15 + 1;
  }

  return result;
}

uint64_t oid_der_data(uint64_t a1, CFStringRef theString, void *a3)
{
  CFIndex Length = CFStringGetLength(theString);
  uint64_t v7 = ((unint64_t)(4 * Length) * (unsigned __int128)0x2492492492492493uLL) >> 64;
  uint64_t v8 = PORT_ArenaAlloc(a1, ((v7 + ((unint64_t)(4 * Length - v7) >> 1)) >> 2) + 1);
  if (v8)
  {
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)*MEMORY[0x189604DB0],  theString,  @".");
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    CFTypeID v11 = (_BYTE *)v8;
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      SInt32 v13 = 0;
      CFIndex v14 = 0LL;
      CFTypeID v11 = (_BYTE *)v8;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v14);
        SInt32 IntValue = CFStringGetIntValue(ValueAtIndex);
        SInt32 v17 = IntValue >= 0 ? IntValue : -IntValue;
        if (v17 == 0x7FFFFFFF) {
          break;
        }
        if (v14)
        {
          if (v14 == 1) {
            unsigned int v18 = IntValue + 40 * v13;
          }
          else {
            unsigned int v18 = IntValue;
          }
          CFTypeID v11 = mod128_oid_encoding_ptr(v11, v18, 1);
        }

        else
        {
          SInt32 v13 = IntValue;
        }

        if (v12 == ++v14) {
          goto LABEL_16;
        }
      }

      if (ArrayBySeparatingStrings) {
        CFRelease(ArrayBySeparatingStrings);
      }
      return 0LL;
    }

_BYTE *mod128_oid_encoding_ptr(_BYTE *a1, unsigned int a2, int a3)
{
  char v4 = a2;
  if (a2 >= 0x81) {
    a1 = (_BYTE *)mod128_oid_encoding_ptr(a1, a2 >> 7, 0LL);
  }
  if (a3) {
    char v5 = 0;
  }
  else {
    char v5 = 0x80;
  }
  *a1 = v5 & 0x80 | v4 & 0x7F;
  return a1 + 1;
}

CFDataRef SecGenerateCertificateRequest( const __CFArray *a1, const __CFDictionary *a2, void *a3, __SecKey *a4)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v8 = PORT_NewArena(1024);
  char v43 = 0;
  CFErrorRef error = 0LL;
  if (v8)
  {
    CFRange v9 = v8;
    uint64_t BytePtr = 0LL;
    __int128 v40 = 0u;
    memset(v39, 0, sizeof(v39));
    __int128 v38 = 0u;
    *(_OWORD *)__int128 v37 = 0u;
    __int128 v36 = 0u;
    char v32 = 0;
    *(void *)__int128 v33 = 1LL;
    CFTypeID v34 = &v32;
    subject = make_subject((uint64_t)v8, a1, (__CFString **)&error);
    if (a4)
    {
      unint64_t v10 = SecKeyCopyPublicKey(a4);
      if (v10)
      {
LABEL_7:
        public_key = make_public_key(v10, (uint64_t)&v36, &v43, &error);
        if (public_key)
        {
          SInt32 v13 = public_key;
          *(void *)&v39[0] = nss_attributes_from_parameters_dict((uint64_t)v9, a2);
          SecCmsArraySortByDER(*(int8x16_t **)&v39[0], (uint64_t)&kSecAsn1AttributeTemplate, 0LL);
          CFIndex v30 = 0LL;
          unint64_t v31 = 0LL;
          if (!SEC_ASN1EncodeItem((uint64_t)v9, &v30, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
          {
            CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", buf, 2u);
            }
          }

          if (a2) {
            unint64_t Value = CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
          }
          else {
            unint64_t Value = 0LL;
          }
          signature = make_signature(v31, v30, a4, Value, (DERSize *)v39 + 1, (__CFString **)&error);
          if (signature)
          {
            __int128 v19 = signature;
            uint64_t BytePtr = CFDataGetBytePtr(signature);
            *((void *)&v40 + 1) = 8 * CFDataGetLength(v19);
            CFIndex v28 = 0LL;
            CFIndex v29 = 0LL;
            if (SEC_ASN1EncodeItem((uint64_t)v9, &v28, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestTemplate))
            {
              CFDataRef v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v29, v28);
              char v20 = 0;
LABEL_24:
              if (v43) {
                free(v37[1]);
              }
              PORT_FreeArena(v9, 1);
              if ((v20 & 1) == 0) {
                CFRelease(v10);
              }
              if (v13) {
                CFRelease(v13);
              }
              if (v19) {
                CFRelease(v19);
              }
              if (error)
              {
                CFTypeID v22 = (os_log_s *)secLogObjForScope("SecError");
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 138412290;
                  CFErrorRef v45 = error;
                  _os_log_impl( &dword_1804F4000,  v22,  OS_LOG_TYPE_DEFAULT,  "csr: cert request encoding failed: %@",  buf,  0xCu);
                }

                CFErrorRef v23 = error;
                if (error)
                {
                  CFErrorRef error = 0LL;
                  CFRelease(v23);
                }
              }

              return v17;
            }

            CFIndex v27 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl(&dword_1804F4000, v27, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", buf, 2u);
            }

            char v20 = 0;
          }

          else
          {
            unint64_t v26 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl(&dword_1804F4000, v26, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", buf, 2u);
            }

            char v20 = 0;
            __int128 v19 = 0LL;
          }
        }

        else
        {
          unint64_t v25 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl(&dword_1804F4000, v25, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", buf, 2u);
          }

          char v20 = 0;
          __int128 v19 = 0LL;
          SInt32 v13 = 0LL;
        }

        CFDataRef v17 = 0LL;
        goto LABEL_24;
      }
    }

    CFTypeID v11 = (os_log_s *)secLogObjForScope("csr");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEBUG,  "unable to create public key from private, using input public key",  buf,  2u);
      if (a3) {
        goto LABEL_6;
      }
    }

    else if (a3)
    {
LABEL_6:
      CFRetain(a3);
      unint64_t v10 = (__SecKey *)a3;
      goto LABEL_7;
    }

    CFIndex v21 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v21, OS_LOG_TYPE_DEFAULT, "csr: failed to get public key", buf, 2u);
    }

    unint64_t v10 = 0LL;
    __int128 v19 = 0LL;
    SInt32 v13 = 0LL;
    CFDataRef v17 = 0LL;
    char v20 = 1;
    goto LABEL_24;
  }

  unsigned int v16 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 v33 = 0;
    _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", v33, 2u);
  }

  return 0LL;
}

void *make_subject(uint64_t a1, CFArrayRef theArray, __CFString **a3)
{
  if (!theArray) {
    return 0LL;
  }
  char v4 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v7 = Count;
  unint64_t v8 = 8 * Count;
  else {
    unint64_t v9 = 8 * Count + 8;
  }
  unint64_t v10 = (void *)PORT_ArenaAlloc(a1, v9);
  CFTypeID v11 = v10;
  if (v10) {
    bzero(v10, v9);
  }
  if (v8 <= 1) {
    unint64_t v12 = 1LL;
  }
  else {
    unint64_t v12 = v8;
  }
  SInt32 v13 = (char *)PORT_ArenaAlloc(a1, v12);
  CFIndex v14 = v13;
  if (v13) {
    bzero(v13, v12);
  }
  if (v7 >= 1)
  {
    CFIndex v15 = 0LL;
    __int128 v33 = v11;
    CFTypeID v34 = v4;
    unint64_t v31 = v14;
    uint64_t v32 = v7;
    while (1)
    {
      unsigned int v16 = &v14[8 * v15];
      v11[v15] = v16;
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v4, v15);
      CFIndex v18 = CFArrayGetCount(ValueAtIndex);
      uint64_t v19 = v18;
      else {
        unint64_t v20 = 8 * v18 + 8;
      }
      CFIndex v21 = (void *)PORT_ArenaAlloc(a1, v20);
      CFTypeID v22 = v21;
      if (v21) {
        bzero(v21, v20);
      }
      *(void *)unsigned int v16 = v22;
      unint64_t v23 = (unint64_t)(40 * v19) <= 1 ? 1LL : 40 * v19;
      CFIndex v24 = (void *)PORT_ArenaAlloc(a1, v23);
      uint64_t v25 = (uint64_t)v24;
      if (v24) {
        bzero(v24, v23);
      }
      if (v19 >= 1) {
        break;
      }
LABEL_29:
      ++v15;
      CFTypeID v11 = v33;
      char v4 = v34;
      CFIndex v14 = v31;
      if (v15 == v32) {
        return v11;
      }
    }

    CFIndex v26 = 0LL;
    while (1)
    {
      *(void *)(*(void *)v16 + 8 * v26) = v25;
      CFIndex v27 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v26);
      if (CFArrayGetCount(v27) != 2) {
        break;
      }
      CFIndex v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0LL);
      CFIndex v29 = (const __CFString *)CFArrayGetValueAtIndex(v27, 1LL);
      if ((make_nss_atv(a1, v28, v29, 0, v25, a3) & 1) == 0) {
        return 0LL;
      }
      ++v26;
      v25 += 40LL;
      if (v19 == v26) {
        goto LABEL_29;
      }
    }

    SecError(-50, a3, @"subject input incorrect: 2 values required in ATV array");
    return 0LL;
  }

  return v11;
}

uint64_t SecVerifyCertificateRequest( const __CFData *a1, __SecKey **a2, CFStringRef *a3, CFDataRef *a4, CFDataRef *a5)
{
  unint64_t v10 = PORT_NewArena(1024);
  __int128 v67 = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)__s2 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  memset(v65, 0, sizeof(v65));
  __int128 v66 = 0u;
  CFIndex v11 = CFDataGetLength(a1);
  uint64_t BytePtr = (char *)CFDataGetBytePtr(a1);
  if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)&v67, (uint64_t)&kSecAsn1CertRequestTemplate, BytePtr, v11))
  {
    CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
    uint64_t v15 = 0LL;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)__int128 buf = 0;
    unsigned int v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }

  if (SEC_ASN1Decode( (uint64_t)v10,  (uint64_t)v65,  (uint64_t)&kSecAsn1SignedCertRequestTemplate,  BytePtr,  v11))
  {
    CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
    uint64_t v15 = 0LL;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)__int128 buf = 0;
    unsigned int v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }

  size_t v13 = __n[1];
  if (__n[1] == 9 && !memcmp(&_oidRsa, __s2[0], 9uLL))
  {
    uint64_t v58 = a4;
    int v17 = 1;
    allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex v18 = (__SecKey *)SecKeyCreate( *MEMORY[0x189604DB0],  (uint64_t)&kSecRSAPublicKeyDescriptor,  v71,  *((void *)&v70 + 1) >> 3,  1LL);
    if (v18)
    {
      uint64_t v19 = v18;
      unint64_t v20 = 0LL;
      CFMutableDictionaryRef Mutable = 0LL;
      goto LABEL_14;
    }

    CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
    uint64_t v15 = 0LL;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)__int128 buf = 0;
    unsigned int v16 = "csr: failed to create RSA public key";
LABEL_9:
    _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    uint64_t v15 = 0LL;
    goto LABEL_98;
  }

  if (v13 != 7 || memcmp(&_oidEcPubKey, __s2[0], 7uLL))
  {
    CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
    uint64_t v15 = 0LL;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_WORD *)__int128 buf = 0;
    unsigned int v16 = "csr: unsupported public key algorithm in CSR";
    goto LABEL_9;
  }

  uint64_t v58 = a4;
  allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
  unint64_t v20 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const UInt8 *)v71,  *((void *)&v70 + 1) >> 3,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFDictionaryAddValue(Mutable, @"type", @"73");
  CFDictionaryAddValue(Mutable, @"kcls", @"0");
  SecKeyRef v22 = SecKeyCreateWithData(v20, Mutable, 0LL);
  if (!v22)
  {
    unsigned int v54 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v54, OS_LOG_TYPE_DEFAULT, "csr: failed to create EC public key", buf, 2u);
    }

    uint64_t v15 = 0LL;
    CFIndex v26 = 0LL;
    CFIndex v27 = 0LL;
    if (!Mutable) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }

  uint64_t v19 = v22;
  int v17 = 0;
LABEL_14:
  __int128 v23 = v72;
  if (!(void)v73) {
    goto LABEL_17;
  }
  if ((void)v73 != 2LL)
  {
    uint64_t v25 = (os_log_s *)secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
LABEL_30:
      uint64_t v15 = 0LL;
      CFIndex v26 = 0LL;
      CFIndex v27 = 0LL;
      goto LABEL_90;
    }

    *(_WORD *)__int128 buf = 0;
LABEL_29:
    _os_log_impl(&dword_1804F4000, v25, OS_LOG_TYPE_DEFAULT, "csr: non-empty signature algorithm parameters", buf, 2u);
    goto LABEL_30;
  }

  if (**((_WORD **)&v73 + 1) != 5)
  {
    uint64_t v25 = (os_log_s *)secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_WORD *)__int128 buf = 0;
    goto LABEL_29;
  }

LABEL_110:
    uint64_t v15 = 0LL;
    goto LABEL_90;
  }

  CFIndex v55 = a2;
  v56 = a3;
  CFIndex length = 0LL;
  UInt8 bytes = 0LL;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &length, (uint64_t)__n, (uint64_t)&kSecAsn1NameTemplate))
  {
    uint64_t v52 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      int v53 = "csr: failed to decode CSR subject name";
      goto LABEL_109;
    }

    goto LABEL_110;
  }

  uint64_t v32 = v19;
  __int128 v33 = Mutable;
  CFTypeID v34 = v20;
  uint64_t v35 = **((void **)&v71 + 1);
  if (**((void **)&v71 + 1))
  {
    unint64_t v36 = 0LL;
    __int128 v37 = 0LL;
    __int128 v38 = 0LL;
    CFIndex v39 = 0LL;
    unsigned int v40 = 1;
    do
    {
      if (*(void *)v35 == 9LL)
      {
        int v41 = *(uint64_t **)(v35 + 8);
        if (*v41 == 0x9010DF78648862ALL && *((_BYTE *)v41 + 8) == 7)
        {
          uint64_t v47 = **(unint64_t ***)(v35 + 16);
          unint64_t v36 = *v47;
          __int128 v37 = (char *)v47[1];
        }

        else
        {
          uint64_t v43 = *v41;
          int v44 = *((unsigned __int8 *)v41 + 8);
          if (v43 == 0x9010DF78648862ALL && v44 == 14)
          {
            uint64_t v46 = **(CFIndex ***)(v35 + 16);
            CFIndex v39 = *v46;
            __int128 v38 = (const UInt8 *)v46[1];
          }
        }
      }

      uint64_t v35 = *(void *)(*((void *)&v71 + 1) + 8LL * v40++);
    }

    while (v35);
  }

  else
  {
    unint64_t v36 = 0LL;
    __int128 v37 = 0LL;
    CFIndex v39 = 0LL;
    __int128 v38 = 0LL;
  }

  if (v58 && length) {
    *uint64_t v58 = CFDataCreate(allocator, bytes, length);
  }
  if (v57 && v39) {
    *unsigned int v57 = CFDataCreate(allocator, v38, v39);
  }
  unint64_t v20 = v34;
  CFMutableDictionaryRef Mutable = v33;
  uint64_t v19 = v32;
  if (v56 && v36)
  {
    *(void *)__int128 buf = 0LL;
    __int128 v62 = 0LL;
    CFIndex v48 = (os_log_s *)secLogObjForScope("csr");
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)CFTypeID v60 = 0;
      _os_log_debug_impl( &dword_1804F4000,  v48,  OS_LOG_TYPE_DEBUG,  "challenge failed to decode with UTF8, attempting PrintableString",  v60,  2u);
    }

    if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)buf, (uint64_t)kSecAsn1PrintableStringTemplate, v37, v36))
    {
      int64_t v49 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeID v60 = 0;
        _os_log_impl(&dword_1804F4000, v49, OS_LOG_TYPE_DEFAULT, "csr: failed to decode challenge", v60, 2u);
      }

      CFStringRef v50 = 0LL;
    }

    else
    {
LABEL_84:
      CFStringRef v50 = CFStringCreateWithBytes(allocator, v62, *(CFIndex *)buf, 0x8000100u, 0);
    }

    CFStringRef *v56 = v50;
  }

  if (v55)
  {
    __CFArray *v55 = v32;
    uint64_t v15 = 1LL;
    if (!Mutable) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }

  uint64_t v15 = 1LL;
LABEL_90:
  CFRelease(v19);
  if (Mutable) {
LABEL_91:
  }
    CFRelease(Mutable);
LABEL_92:
  if (v20) {
    CFRelease(v20);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v27) {
    CFRelease(v27);
  }
LABEL_98:
  if (v10) {
    PORT_FreeArena(v10, 1);
  }
  return v15;
}

void *SecGenerateSelfSignedCertificateWithError( const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  unint64_t v9 = PORT_NewArena(1024);
  char v47 = 0;
  CFErrorRef error = 0LL;
  if (!v9)
  {
    SecError(-67672, a5, @"pool allocation failure");
    return 0LL;
  }

  unint64_t v10 = v9;
  uint64_t BytePtr = 0LL;
  __int128 v44 = 0u;
  memset(v43, 0, sizeof(v43));
  __int128 v42 = 0u;
  __int128 v41 = 0u;
  __int128 v40 = 0u;
  *(_OWORD *)CFIndex v39 = 0u;
  __int128 v38 = 0u;
  __int128 v37 = 0u;
  __int128 v36 = 0u;
  memset(v35, 0, sizeof(v35));
  __int128 v34 = 0u;
  char v32 = 2;
  v33[0] = 1LL;
  v33[1] = &v32;
  if (a2
    && (unint64_t Value = (const __CFData *)CFDictionaryGetValue(a2, @"certificateSerial")) != 0LL
    && (CFDataRef v12 = Value, v13 = CFGetTypeID(Value), v13 == CFDataGetTypeID())
    && (unint64_t)(CFDataGetLength(v12) - 21) >= 0xFFFFFFFFFFFFFFECLL)
  {
    CFRetain(v12);
  }

  else
  {
    bytes[0] = 1;
    CFDataRef v12 = CFDataCreate(0LL, bytes, 1LL);
    if (!v12)
    {
      SecError(-67672, (__CFString **)&error, @"failed to allocate serial number");
      goto LABEL_30;
    }
  }

  *(void *)&__int128 v34 = CFDataGetLength(v12);
  *((void *)&v34 + 1) = CFDataGetBytePtr(v12);
  *(void *)&v35[2] = make_subject((uint64_t)v10, a1, (__CFString **)&error);
  *((void *)&v37 + 1) = *(void *)&v35[2];
  if (a2)
  {
    CFIndex v14 = (const __CFNumber *)CFDictionaryGetValue(a2, @"certificateLifetime");
    uint64_t valuePtr = 31536000LL;
    if (v14) {
      CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr);
    }
  }

  else
  {
    uint64_t valuePtr = 31536000LL;
  }

  double Current = CFAbsoluteTimeGetCurrent();
  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v35[2] + 8, Current))
  {
    __int128 v23 = @"failed to encode notBefore";
    goto LABEL_29;
  }

  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v36, Current + (double)valuePtr))
  {
    __int128 v23 = @"failed to encode notAfter";
    goto LABEL_29;
  }

  if ((extensions_from_parameters((uint64_t)v10, a2, v43, (__CFString **)&error) & 1) == 0)
  {
    __int128 v23 = @"failed to encode extensions";
    goto LABEL_29;
  }

  if (!a4 || (unsigned int v16 = SecKeyCopyPublicKey(a4)) == 0LL)
  {
    __int128 v23 = @"failed get public key";
LABEL_29:
    SecError(-26276, (__CFString **)&error, v23);
LABEL_30:
    SecKeyRef v22 = 0LL;
    CFIndex v21 = 0LL;
    public_key = 0LL;
    int v17 = 0LL;
    goto LABEL_31;
  }

  int v17 = v16;
  public_key = make_public_key(v16, (uint64_t)&v38, &v47, &error);
  if (!public_key)
  {
    SecError(-26276, (__CFString **)&error, @"failed to encode public key");
    SecKeyRef v22 = 0LL;
    CFIndex v21 = 0LL;
    goto LABEL_31;
  }

  if (a2) {
    a2 = (const __CFDictionary *)CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
  }
  CFDataRef signature = make_signature(0LL, 0LL, a4, a2, (DERSize *)v35, (__CFString **)&error);
  if (signature) {
    CFRelease(signature);
  }
  CFIndex v29 = 0LL;
  CFIndex v30 = 0LL;
  unint64_t v20 = make_signature(v30, v29, a4, a2, &v43[5], (__CFString **)&error);
  CFIndex v21 = v20;
  if (!v20)
  {
    SecError(-67688, (__CFString **)&error, @"failed to make signature");
LABEL_60:
    SecKeyRef v22 = 0LL;
    goto LABEL_31;
  }

  uint64_t BytePtr = CFDataGetBytePtr(v20);
  *((void *)&v44 + 1) = 8 * CFDataGetLength(v21);
  int64_t v27 = 0LL;
  CFIndex v28 = 0LL;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &v27, (uint64_t)v33, (uint64_t)&kSecAsn1SignedCertTemplate))
  {
    SecError(-26276, (__CFString **)&error, @"failed to encode certificate");
    goto LABEL_60;
  }

  SecKeyRef v22 = SecCertificateCreateWithBytes(*MEMORY[0x189604DB0], v28, v27);
  if (!v22) {
    SecError(-26276, (__CFString **)&error, @"failed to decode encoded certificate");
  }
LABEL_31:
  if (v47) {
    free(v39[1]);
  }
  PORT_FreeArena(v10, 1);
  if (v17) {
    CFRelease(v17);
  }
  if (public_key) {
    CFRelease(public_key);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (error)
  {
    CFIndex v24 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)UInt8 bytes = 138412290;
      CFErrorRef v49 = error;
      _os_log_impl( &dword_1804F4000,  v24,  OS_LOG_TYPE_DEFAULT,  "csr: failed to generate self-signed certificate %@",  bytes,  0xCu);
    }

    if (v22) {
      CFRelease(v22);
    }
    if (a5)
    {
      CFErrorRef v25 = error;
      if (*a5) {
        CFRelease(*a5);
      }
      SecKeyRef v22 = 0LL;
      *a5 = (__CFString *)v25;
      return v22;
    }

    return 0LL;
  }

  return v22;
}

void *SecGenerateSelfSignedCertificate( const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4)
{
  return SecGenerateSelfSignedCertificateWithError(a1, a2, a3, a4, 0LL);
}

void *SecIdentitySignCertificate( uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5)
{
  return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0LL);
}

void *SecIdentitySignCertificateWithParameters( uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, CFDictionaryRef theDict)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  if (theDict) {
    unint64_t Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSSignHashAlgorithm);
  }
  else {
    unint64_t Value = 0LL;
  }
  char v80 = 0;
  CFErrorRef error = 0LL;
  CFTypeID v13 = PORT_NewArena(1024);
  if (v13)
  {
    CFIndex v14 = v13;
    v78 = 0LL;
    __int128 v77 = 0u;
    __int128 v75 = 0u;
    memset(v76, 0, sizeof(v76));
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v71 = 0u;
    *(_OWORD *)__int128 v72 = 0u;
    __int128 v69 = 0u;
    __int128 v70 = 0u;
    memset(v68, 0, sizeof(v68));
    memset(v67, 0, sizeof(v67));
    __int128 v66 = 0u;
    char v63 = 2;
    *(void *)__int128 buf = 1LL;
    uint64_t v65 = &v63;
    *(void *)&__int128 v66 = CFDataGetLength(a2);
    *((void *)&v66 + 1) = CFDataGetBytePtr(a2);
    if (!a4) {
      goto LABEL_19;
    }
    CFTypeID v15 = CFGetTypeID(a4);
    if (v15 == CFArrayGetTypeID())
    {
      *((void *)&v70 + 1) = make_subject((uint64_t)v14, (CFArrayRef)a4, (__CFString **)&error);
      goto LABEL_13;
    }

    CFTypeID v18 = CFGetTypeID(a4);
    if (v18 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)a4);
      uint64_t BytePtr = (char *)CFDataGetBytePtr((CFDataRef)a4);
      if (!SEC_ASN1Decode( (uint64_t)v14,  (uint64_t)&v70 + 8,  (uint64_t)&kSecAsn1NameTemplate,  BytePtr,  Length))
      {
LABEL_13:
        CFIndex v21 = *(const void **)(a1 + 16);
        CFRetain(v21);
        SecKeyRef v22 = SecDERItemCopySequence((uint64_t)v21 + 184);
        CFIndex v23 = CFDataGetLength(v22);
        CFIndex v24 = (char *)CFDataGetBytePtr(v22);
        if (SEC_ASN1Decode((uint64_t)v14, (uint64_t)v68, (uint64_t)&kSecAsn1NameTemplate, v24, v23))
        {
          v56 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v81 = 0;
            _os_log_impl( &dword_1804F4000,  v56,  OS_LOG_TYPE_DEFAULT,  "csr: failed to decoder subject name from CA identity",  v81,  2u);
          }

          CFIndex v28 = 0LL;
          goto LABEL_24;
        }

        if (v22) {
          CFRelease(v22);
        }
        if (theDict)
        {
          CFErrorRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"certificateLifetime");
          uint64_t valuePtr = 31536000LL;
          if (v25) {
            CFNumberGetValue(v25, kCFNumberLongLongType, &valuePtr);
          }
        }

        else
        {
          uint64_t valuePtr = 31536000LL;
        }

        double Current = CFAbsoluteTimeGetCurrent();
        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)v68 + 8, Current))
        {
          uint64_t v43 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          *(_WORD *)v81 = 0;
          __int128 v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }

        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)&v69, Current + (double)valuePtr))
        {
          uint64_t v43 = (os_log_s *)secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          *(_WORD *)v81 = 0;
          __int128 v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }

        if (theDict)
        {
          CFTypeID v32 = CFGetTypeID(theDict);
          if (v32 == CFDictionaryGetTypeID() && parameters_contains_extensions(theDict))
          {
            __int128 v33 = (os_log_s *)secLogObjForScope("csr");
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)v81 = 0;
              _os_log_debug_impl( &dword_1804F4000,  v33,  OS_LOG_TYPE_DEBUG,  "overriding request extensions with parameters extensions",  v81,  2u);
            }

            uint64_t v34 = (uint64_t)v14;
            uint64_t v35 = theDict;
LABEL_46:
            if ((extensions_from_parameters(v34, v35, v76, (__CFString **)&error) & 1) == 0)
            {
LABEL_50:
              uint64_t v43 = (os_log_s *)secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
LABEL_53:
                CFIndex v28 = 0LL;
                goto LABEL_23;
              }

              *(_WORD *)v81 = 0;
              __int128 v44 = "csr: failed to encode extensions";
LABEL_52:
              _os_log_impl(&dword_1804F4000, v43, OS_LOG_TYPE_DEFAULT, v44, v81, 2u);
              goto LABEL_53;
            }

BOOL parameters_contains_extensions(const __CFDictionary *a1)
{
  return CFDictionaryContainsKey(a1, @"subjectAltName")
      || CFDictionaryContainsKey(a1, @"keyUsage")
      || CFDictionaryContainsKey(a1, @"basicConstraintsCA")
      || CFDictionaryContainsKey(a1, @"basicConstraints")
      || CFDictionaryContainsKey(a1, @"certificateEKUs")
      || CFDictionaryContainsKey(a1, @"certificateExtensions")
      || CFDictionaryContainsKey(a1, @"certificateExtensionsEncoded") != 0;
}

void *SecIdentitySignCertificateWithAlgorithm( uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, const void *a6)
{
  if (!a6) {
    return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0LL);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 1LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFDictionaryAddValue(Mutable, (const void *)kSecCMSSignHashAlgorithm, a6);
  CFTypeID v13 = SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v13;
}

__CFData *SecGenerateCertificateRequestSubject(uint64_t a1, const __CFArray *a2)
{
  char v4 = PORT_NewArena(1024);
  if (v4)
  {
    char v5 = v4;
    uint64_t v6 = SecDERItemCopySequence(a1 + 184);
    *(void *)__int128 buf = 0LL;
    SecKeyRef v22 = 0LL;
    CFIndex Length = CFDataGetLength(v6);
    uint64_t BytePtr = CFDataGetBytePtr(v6);
    subject = make_subject((uint64_t)v5, a2, 0LL);
    if (SEC_ASN1EncodeItem((uint64_t)v5, buf, (uint64_t)&subject, (uint64_t)&kSecAsn1NameTemplate))
    {
      uint64_t v18 = DERLengthOfLength(*(void *)buf + Length);
      CFIndex v9 = Length + *(void *)buf + v18 + 1;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
      CFDataSetLength(Mutable, v9);
      Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
      UInt8 *MutableBytePtr = 48;
      CFDataRef v12 = MutableBytePtr + 1;
      if (DEREncodeLength( *(void *)buf + Length,  (unint64_t)(MutableBytePtr + 1),  (unint64_t *)&v18))
      {
        int v17 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v19 = 0;
          _os_log_impl( &dword_1804F4000,  v17,  OS_LOG_TYPE_DEFAULT,  "csr: failed to encode outer subject sequence",  v19,  2u);
        }
      }

      else
      {
        CFTypeID v13 = &v12[v18];
        memcpy(v13, BytePtr, Length);
        memcpy(&v13[Length], v22, *(size_t *)buf);
      }
    }

    else
    {
      unsigned int v16 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v19 = 0;
        _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "csr: failed to encode subject", v19, 2u);
      }

      CFMutableDictionaryRef Mutable = 0LL;
    }

    if (v6) {
      CFRelease(v6);
    }
    PORT_FreeArena(v5, 1);
  }

  else
  {
    CFIndex v14 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }

    return 0LL;
  }

  return Mutable;
}

uint64_t SecDHGetMaxKeyLength()
{
  return 8 * MEMORY[0x186DFEEB4]();
}

uint64_t SecDHCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  unint64_t v8 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v9 = ccdh_gp_size();
  unint64_t v10 = malloc(v9 + 2 * v8 + 23);
  cc_clear();
  uint64_t result = ccdh_init_gp_from_bytes();
  if ((_DWORD)result)
  {
    SecDHDestroy(v10);
    unint64_t v10 = 0LL;
    uint64_t result = 4294941020LL;
  }

  *a7 = v10;
  return result;
}

void SecDHDestroy(void *a1)
{
}

uint64_t SecDHCreateFromParameters(uint64_t a1, uint64_t a2, void *a3)
{
  v13[0] = a1;
  v13[1] = a2;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[0] = v4;
  v12[1] = v4;
  v11[0] = v4;
  v11[1] = v4;
  int v10 = 0;
  uint64_t result = DERParseSequence((uint64_t)v13, 4u, (uint64_t)&DER_DHParamsItemSpecs, (unint64_t)v11, 0x40uLL);
  if (!(_DWORD)result)
  {
    if (!*((void *)&v12[0] + 1) || (uint64_t result = DERParseInteger((char **)v12, &v10), !(_DWORD)result))
    {
      unint64_t v6 = (*((void *)&v11[0] + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      size_t v7 = ccdh_gp_size() + 2 * v6 + 23;
      unint64_t v8 = malloc(v7);
      if (v8)
      {
        uint64_t v9 = v8;
        bzero(v8, v7);
        uint64_t result = ccdh_init_gp_from_bytes();
        if ((_DWORD)result)
        {
          SecDHDestroy(v9);
          uint64_t v9 = 0LL;
          uint64_t result = 4294941021LL;
        }

        *a3 = v9;
      }

      else
      {
        return 4294967188LL;
      }
    }
  }

  return result;
}

uint64_t SecDHCreateFromAlgorithmId(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v8 = v4;
  __int128 v9 = v4;
  v7[0] = a1;
  v7[1] = a2;
  int v5 = DERParseSequence( (uint64_t)v7,  (unsigned __int16)DERNumAlgorithmIdItemSpecs,  (uint64_t)&DERAlgorithmIdItemSpecs,  (unint64_t)&v8,  0x20uLL);
  uint64_t result = 4294941021LL;
  switch(v5)
  {
    case 0:
      uint64_t result = SecDHCreateFromParameters(v9, *((uint64_t *)&v9 + 1), a3);
      break;
    case 1:
    case 2:
    case 3:
    case 5:
      return result;
    case 4:
      uint64_t result = 4294967292LL;
      break;
    case 6:
      uint64_t result = 4294967246LL;
      break;
    case 7:
      uint64_t result = 4294941995LL;
      break;
    default:
      uint64_t result = 4294941020LL;
      break;
  }

  return result;
}

uint64_t SecDHGenerateKeypair(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t result = ccdh_generate_key();
  if (!(_DWORD)result)
  {
    MEMORY[0x186DFEEB4](a1);
    unint64_t v6 = ccn_write_uint_size();
    if (*a3 >= v6)
    {
      unint64_t v7 = v6;
      MEMORY[0x186DFEEB4](a1);
      ccn_write_uint();
      uint64_t result = 0LL;
      *a3 = v7;
    }

    else
    {
      return 4294941995LL;
    }
  }

  return result;
}

uint64_t dhRngCallback()
{
  return CCRandomCopyBytes();
}

uint64_t SecDHComputeKey(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t *a5)
{
  v17[1] = *MEMORY[0x1895F89C0];
  MEMORY[0x186DFEEB4]();
  ccdh_gp_size();
  uint64_t v7 = ccdh_ccn_size();
  MEMORY[0x1895F8858](v7);
  if (v9 >= 0x10)
  {
    int v10 = (size_t *)((char *)v17 - v8);
    do
    {
      *int v10 = 0xAAAAAAAAAAAAAAAALL;
      v10[1] = 0xAAAAAAAAAAAAAAAALL;
      v10 += 2;
      v8 -= 16LL;
    }

    while (v8);
  }

  v17[0] = ccdh_ccn_size();
  CFDataRef v12 = calloc(1uLL, v17[0]);
  if (!v12) {
    return 4294967188LL;
  }
  CFTypeID v13 = v12;
  if (ccdh_compute_shared_secret())
  {
    uint64_t v11 = 4294941021LL;
  }

  else
  {
    size_t v14 = v17[0];
    size_t v15 = *a5;
    if (v17[0] < *a5)
    {
      *a5 = v17[0];
      size_t v15 = v14;
    }

    memcpy(a4, v13, v15);
    uint64_t v11 = 0LL;
  }

  free(v13);
  return v11;
}

__CFData *SecSHA1DigestCreate(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  CFMutableDictionaryRef Mutable = 0LL;
  if (a2 && !(a3 >> 31))
  {
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 20LL);
    CFDataSetLength(Mutable, 20LL);
    CFDataGetMutableBytePtr(Mutable);
    CCDigest();
  }

  return Mutable;
}

__CFData *SecSHA256DigestCreate(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  CFMutableDictionaryRef Mutable = 0LL;
  if (a2 && !(a3 >> 31))
  {
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 32LL);
    CFDataSetLength(Mutable, 32LL);
    CFDataGetMutableBytePtr(Mutable);
    CCDigest();
  }

  return Mutable;
}

__CFData *SecSHA256DigestCreateFromData(const __CFAllocator *a1, const __CFData *a2)
{
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 32LL);
  CFDataSetLength(Mutable, 32LL);
  CFDataGetBytePtr(a2);
  CFDataGetLength(a2);
  CFDataGetMutableBytePtr(Mutable);
  CCDigest();
  return Mutable;
}

__CFData *SecDigestCreate( const __CFAllocator *a1, SecAsn1Oid *oid1, uint64_t a3, uint64_t a4, unint64_t a5)
{
  CFMutableDictionaryRef Mutable = 0LL;
  if (a4 && !(a5 >> 31))
  {
    if (SecAsn1OidCompare(oid1, &CSSMOID_SHA1))
    {
      int v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1895F8290];
      CFIndex v11 = 20LL;
    }

    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA224))
    {
      int v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1895F82B0];
      CFIndex v11 = 28LL;
    }

    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA256))
    {
      int v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1895F82D0];
      CFIndex v11 = 32LL;
    }

    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA384))
    {
      int v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1895F82F0];
      CFIndex v11 = 48LL;
    }

    else
    {
      if (!SecAsn1OidCompare(oid1, &CSSMOID_SHA512)) {
        return 0LL;
      }
      int v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1895F8310];
      CFIndex v11 = 64LL;
    }

    CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, v11);
    CFDataSetLength(Mutable, v11);
    Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
    v10(a4, a5, MutableBytePtr);
  }

  return Mutable;
}

uint64_t SecECPublicKeyInit(uint64_t a1, unint64_t **__src, uint64_t a3, int a4)
{
  if (a4 == 7)
  {
    uint64_t v6 = 4294941021LL;
    if (!getCPForPublicSize()) {
      return v6;
    }
    goto LABEL_11;
  }

  if (a4 == 6)
  {
    unint64_t v7 = **__src;
    if (v7 <= 9)
    {
      memcpy(*(void **)(a1 + 24), __src, 24 * v7 + 16);
      return 0LL;
    }

    return 4294967246LL;
  }

  if (a4 != 4) {
    return 4294967246LL;
  }
  if (a3 != 48) {
    return 4294941021LL;
  }
  uint64_t v4 = (uint64_t)__src[2];
  if (!v4) {
    return 4294941021LL;
  }
  uint64_t v5 = (uint64_t)__src[3];
  uint64_t v6 = 4294941021LL;
  if (ccec_cp_for_oid_0(v4))
  {
LABEL_11:
    else {
      return 0LL;
    }
  }

  return v6;
}

uint64_t SecECPublicKeyDestroy(uint64_t result)
{
  if (**(void **)(result + 24)) {
    return cc_clear();
  }
  return result;
}

unint64_t SecECPublicKeyBlockSize()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

__CFDictionary *SecECPublicKeyCopyAttributeDictionary(const void *a1)
{
  uint64_t v1 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)@"73", 0LL);
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v1);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x189604DE0]);
  if (v1) {
    CFRelease(v1);
  }
  return MutableCopy;
}

uint64_t SecECPublicKeyCopyKeyDescription(__SecKey *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  unsigned int v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2) {
    size_t v3 = "kSecECCurveNone";
  }
  else {
    size_t v3 = off_189670120[v2];
  }
  CFIndex v21 = v3;
  uint64_t v22 = (uint64_t)a1;
  unint64_t v24 = cczp_bitlen() + 7;
  [MEMORY[0x189603FB8] dataWithLength:v24 >> 3];
  id v23 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = 0LL;
  if (v24 >> 3 <= 1) {
    uint64_t v5 = 1LL;
  }
  else {
    uint64_t v5 = v24 >> 3;
  }
  char v6 = 1;
  do
  {
    char v7 = v6;
    id v8 = v23;
    [v8 mutableBytes];
    ccn_write_uint();
    [MEMORY[0x189607940] stringWithCapacity:2 * (v24 >> 3)];
    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    int v10 = (void *)*(&v25 + v4);
    *(&v25 + v4) = (uint64_t)v9;

    if (v24 >= 8)
    {
      uint64_t v11 = 0LL;
      do
        objc_msgSend( v9, "appendFormat:", @"%02X", *(unsigned __int8 *)(objc_msgSend(v8, "bytes") + v11++));
      while (v5 != v11);
    }

    char v6 = 0;
    uint64_t v4 = 1LL;
  }

  while ((v7 & 1) != 0);
  CFDataRef v12 = (void *)NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(v22);
  size_t v14 = *(unsigned int **)(v22 + 16);
  uint64_t v15 = *((void *)v14 + 1);
  uint64_t v16 = *v14;
  _SecKeyCheck(v22, (uint64_t)"SecKeyGetBlockSize");
  int v17 = *(uint64_t (**)(uint64_t))(*(void *)(v22 + 16) + 80LL);
  if (v17) {
    int v17 = (uint64_t (*)(uint64_t))(8 * v17(v22));
  }
  uint64_t v18 = [v12 stringWithFormat:@"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, y: %@, x: %@, addr: %p>", v21, AlgorithmId, v15, v16, v17, v26, v25, v22];

  for (uint64_t i = 8LL; i != -8; i -= 8LL)
  return v18;
}

uint64_t SecECKeyGetAlgorithmID()
{
  return 3LL;
}

uint64_t SecECPublicKeyCopyPublicOctets(const void *a1, __CFData **a2)
{
  size_t v3 = CFGetAllocator(a1);
  uint64_t v4 = SecECPublicKeyExport(v3);
  *a2 = v4;
  if (v4) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecECKeyCopyWrapKey( __SecKey *a1, int a2, const __CFData *a3, const __CFDictionary *a4, uint64_t a5, __CFString **a6)
{
  char valuePtr = 0;
  int v27 = 0;
  if (a2 != 1)
  {
    SecError(-4, a6, @"unsupported key wrapping algorithm");
    return 0LL;
  }

  int NamedCurve = SecECKeyGetNamedCurve(a1);
  uint64_t v10 = MEMORY[0x1895F9BE0];
  if (NamedCurve != 25) {
    uint64_t v10 = 0LL;
  }
  if (NamedCurve == 23) {
    uint64_t v11 = MEMORY[0x1895F9BD8];
  }
  else {
    uint64_t v11 = v10;
  }
  if (!v11)
  {
    SecError(-4, a6, @"unsupported curve");
    return 0LL;
  }

  unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPSymAlg");
  if (!Value
    || (CFTypeID v13 = Value, v14 = CFGetTypeID(Value), v14 != CFNumberGetTypeID())
    || !CFNumberGetValue(v13, kCFNumberSInt8Type, &valuePtr))
  {
    SecError(-4, a6, @"unknown symalg given");
    return 0LL;
  }

  uint64_t v15 = (const __CFData *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPFingerprint");
  if (!v15 || (uint64_t v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, @"invalid fingerprint");
    return 0LL;
  }

  unint64_t v20 = CFDictionaryGetValue(a4, @"kSecKeyWrapPGPWrapAlg");
  if (!v20)
  {
    SecError(-4, a6, @"no wrap alg");
    return 0LL;
  }

  CFIndex v21 = v20;
  if (!CFEqual(v20, @"kSecKeyWrapPGPECWrapDigestSHA256KekAES128")
    && !CFEqual(v21, @"kSecKeyWrapPGPECWrapDigestSHA512KekAES256"))
  {
    SecError(-4, a6, @"unknown wrap alg");
    return 0LL;
  }

  uint64_t v22 = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPECFlags");
  if (isNumber(v22))
  {
    if (!CFNumberGetValue(v22, kCFNumberSInt32Type, &v27))
    {
      SecError(-4, a6, @"invalid flags: %@", v22);
      return 0LL;
    }
  }

  else if (v22)
  {
    SecError(-4, a6, @"unknown flags");
    return 0LL;
  }

  CFDataGetLength(a3);
  uint64_t v23 = ccec_rfc6637_wrap_key_size();
  if (!v23)
  {
    SecError(-4, a6, @"can't wrap that key, can't build size");
    return 0LL;
  }

  CFIndex v24 = v23;
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(Mutable, v24);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(a3);
    CFDataGetBytePtr(a3);
    uint64_t BytePtr = CFDataGetBytePtr(v16);
    uint64_t v26 = ccrng();
    if (ccec_rfc6637_wrap_key())
    {
      SecError(-4, a6, @"Failed to wrap key", BytePtr, v26);
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

__CFData *SecECPublicKeyCopyExternalRepresentation()
{
  return SecECPublicKeyExport(0LL);
}

uint64_t SecECPublicKeyCopyOperationResult( int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  if (a2 != 1 || !CFEqual(cf1, @"algid:sign:ECDSA:digest-X962"))
  {
    uint64_t v12 = MEMORY[0x189605018];
    return *(void *)v12;
  }

  if (a5)
  {
    uint64_t v12 = MEMORY[0x189604DE8];
    return *(void *)v12;
  }

  CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  uint64_t v14 = ccec_verify();
  if ((_DWORD)v14) {
    SecError(-67808, a8, @"EC signature verification failed (ccerr %d)", v14);
  }
  else {
    SecError(-67808, a8, @"EC signature verification failed, no match");
  }
  return 0LL;
}

__CFData *SecECPublicKeyExport(const __CFAllocator *a1)
{
  CFIndex v2 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 0LL);
  CFDataSetLength(Mutable, v2);
  CFDataGetMutableBytePtr(Mutable);
  ccec_export_pub();
  return Mutable;
}

uint64_t SecECKeyGetNamedCurve(__SecKey *a1)
{
  CFIndex v2 = SecKeyCopyAttributes(a1);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  size_t v3 = v2;
  unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(v2, @"bsiz");
  uint64_t valuePtr = 0LL;
  if (!Value) {
    goto LABEL_10;
  }
  uint64_t v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFNumberGetTypeID() || !CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr)) {
    goto LABEL_10;
  }
  switch(valuePtr)
  {
    case 521LL:
      uint64_t v7 = 25LL;
      break;
    case 384LL:
      uint64_t v7 = 24LL;
      break;
    case 256LL:
      uint64_t v7 = 23LL;
      break;
    default:
LABEL_10:
      uint64_t v7 = 0xFFFFFFFFLL;
      break;
  }

  CFRelease(v3);
  return v7;
}

const void *isNumber(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFNumberGetTypeID());
  }

  return result;
}

uint64_t ccec_cp_for_oid_0(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  else {
    return 0LL;
  }
}

uint64_t getCPForPublicSize()
{
  else {
    return 0LL;
  }
}

uint64_t SecECPrivateKeyInit(uint64_t a1, CFDictionaryRef theDict, unint64_t a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  CFTypeID v6 = *(uint64_t **)(a1 + 24);
  if (a4 == 7)
  {
    ccec_x963_import_priv_size();
    uint64_t cp = ccec_get_cp();
    if (!cp) {
      return 4294967246LL;
    }
    uint64_t v13 = cp;
    *CFTypeID v6 = cp;
    unint64_t v14 = (unint64_t)(cczp_bitlen() + 7) >> 2;
    if (a3 <= (v14 | 1)) {
      return 4294967246LL;
    }
    uint64_t v15 = 4294941021LL;
    if (!MEMORY[0x186DFF004](v13, v14 | 1, theDict, v6))
    {
      else {
        return 0LL;
      }
    }
  }

  else
  {
    if (a4 != 5)
    {
      if (a4 == 1)
      {
        *(void *)uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
        if (!ccec_der_import_priv_keytype())
        {
          uint64_t v7 = ccec_cp_for_oid_0(*(uint64_t *)valuePtr);
          if (!v7)
          {
            ccec_cp_192();
            MEMORY[0x186DFEF80]();
            MEMORY[0x186DFEF8C]();
            MEMORY[0x186DFEF98]();
            ccec_cp_521();
            uint64_t v7 = ccec_curve_for_length_lookup();
            if (!v7) {
              return 4294941021LL;
            }
          }

          *CFTypeID v6 = v7;
          int key_fips = ccec_der_import_priv();
          goto LABEL_23;
        }
      }

      return 4294967246LL;
    }

    unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"bsiz");
    if (Value)
    {
      uint64_t v10 = Value;
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFNumberGetTypeID())
      {
        *(void *)uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
        CFNumberGetValue(v10, kCFNumberCFIndexType, valuePtr);
      }

      else
      {
        CFTypeID v16 = CFGetTypeID(v10);
        if (v16 == CFStringGetTypeID()) {
          CFStringGetIntValue((CFStringRef)v10);
        }
      }
    }

    if (ccec_get_cp())
    {
      ccrng();
      int key_fips = ccec_generate_key_fips();
LABEL_23:
      if (key_fips) {
        return 4294967246LL;
      }
      else {
        return 0LL;
      }
    }

    secLogObjForScope("SecWarning");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t valuePtr = 138412290;
      *(void *)&valuePtr[4] = theDict;
      _os_log_impl(&dword_1804F4000, v18, OS_LOG_TYPE_DEFAULT, "Invalid or missing key size in: %@", valuePtr, 0xCu);
    }

    return 4294941985LL;
  }

  return v15;
}

uint64_t SecECPrivateKeyDestroy(uint64_t result)
{
  if (**(void **)(result + 24)) {
    return cc_clear();
  }
  return result;
}

unint64_t SecECPrivateKeyBlockSize()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

CFDictionaryRef SecECPrivateKeyCopyAttributeDictionary(const void *a1)
{
  CFIndex v2 = SecECPrivateKeyCopyExternalRepresentation();
  CFDictionaryRef v3 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)@"73", v2);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

CFStringRef SecECPrivateKeyCopyKeyDescription(__SecKey *a1)
{
  unsigned int v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2) {
    CFDictionaryRef v3 = "kSecECCurveNone";
  }
  else {
    CFDictionaryRef v3 = off_189670120[v2];
  }
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
  CFTypeID v6 = (unsigned int *)*((void *)a1 + 2);
  uint64_t v7 = *((void *)v6 + 1);
  uint64_t v8 = *v6;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  unint64_t v9 = *(uint64_t (**)(__SecKey *))(*((void *)a1 + 2) + 80LL);
  if (v9) {
    unint64_t v9 = (uint64_t (*)(__SecKey *))(8 * v9(a1));
  }
  return CFStringCreateWithFormat( v4,  0LL,  @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v3,  AlgorithmId,  v7,  v8,  v9,  a1);
}

uint64_t SecECPrivateKeyCopyPublicOctets(const void *a1, __CFData **a2)
{
  CFDictionaryRef v3 = CFGetAllocator(a1);
  uint64_t v4 = SecECPublicKeyExport(v3);
  *a2 = v4;
  if (v4) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecECKeyCopyUnwrapKey( __SecKey *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFDictionary **a5, __CFString **a6)
{
  char v31 = 0;
  int valuePtr = 0;
  int NamedCurve = SecECKeyGetNamedCurve(a1);
  uint64_t v11 = MEMORY[0x1895F9BE0];
  if (NamedCurve != 25) {
    uint64_t v11 = 0LL;
  }
  if (NamedCurve == 23) {
    uint64_t v12 = MEMORY[0x1895F9BD8];
  }
  else {
    uint64_t v12 = v11;
  }
  if (!v12)
  {
    SecError(-4, a6, @"unsupported curve");
    return 0LL;
  }

  unint64_t Value = CFDictionaryGetValue(a4, @"kSecKeyWrapPGPWrapAlg");
  if (!Value)
  {
    SecError(-4, a6, @"no wrap alg");
    return 0LL;
  }

  unint64_t v14 = Value;
  if (!CFEqual(Value, @"kSecKeyWrapPGPECWrapDigestSHA256KekAES128")
    && !CFEqual(v14, @"kSecKeyWrapPGPECWrapDigestSHA512KekAES256"))
  {
    SecError(-4, a6, @"unknown wrap alg");
    return 0LL;
  }

  uint64_t v15 = (const __CFData *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPFingerprint");
  if (!v15 || (CFTypeID v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, @"invalid fingerprint");
    return 0LL;
  }

  uint64_t v20 = (const __CFNumber *)CFDictionaryGetValue(a4, @"kSecKeyWrapPGPECFlags");
  if (v20)
  {
    CFIndex v21 = v20;
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 != CFNumberGetTypeID())
    {
      SecError(-4, a6, @"unknown flags");
      return 0LL;
    }

    if (!CFNumberGetValue(v21, kCFNumberSInt32Type, &valuePtr))
    {
      SecError(-4, a6, @"invalid flags: %@", v21);
      return 0LL;
    }
  }

  unint64_t Length = CFDataGetLength(a3);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(Mutable, Length);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetBytePtr(v16);
    CFIndex v28 = CFDataGetLength(a3);
    uint64_t BytePtr = CFDataGetBytePtr(a3);
    if (ccec_rfc6637_unwrap_key())
    {
      CFRelease(Mutable);
      SecError(-4, a6, @"failed to wrap key", v28, BytePtr);
      return 0LL;
    }

    if (Length > CFDataGetLength(Mutable)) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
    CFDataSetLength(Mutable, Length);
    if (a5)
    {
      CFMutableDictionaryRef v24 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      if (v24)
      {
        uint64_t v25 = v24;
        CFNumberRef v26 = CFNumberCreate(0LL, kCFNumberSInt8Type, &v31);
        if (v26)
        {
          CFNumberRef v27 = v26;
          CFDictionarySetValue(v25, @"kSecKeyWrapPGPSymAlg", v26);
          CFRelease(v27);
        }

        *a5 = v25;
      }
    }
  }

  return Mutable;
}

__CFData *SecECPrivateKeyCopyExternalRepresentation()
{
  uint64_t v0 = cczp_bitlen();
  uint64_t v1 = cczp_bitlen();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(Mutable, (((unint64_t)(v1 + 7) >> 2) | 1) + ((unint64_t)(v0 + 7) >> 3));
  CFDataGetMutableBytePtr(Mutable);
  ccec_export_pub();
  CFDataGetMutableBytePtr(Mutable);
  cczp_bitlen();
  ccn_write_uint_padded();
  return Mutable;
}

__CFData *SecECPrivateKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x189605018];
  if (a2 != 4)
  {
    if (a2 || !CFEqual(cf1, @"algid:sign:ECDSA:digest-X962")) {
      return Mutable;
    }
    if (!a5)
    {
      unint64_t v29 = (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
      CFDataSetLength(Mutable, v29);
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v14 = ccec_sign();
      if ((_DWORD)v14)
      {
        uint64_t v28 = v14;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-50, a8, @"%@: X962 signing failed (ccerr %d)", a1, v28, v29, v30);
        return 0LL;
      }

      else
      {
        CFDataSetLength(Mutable, v29);
      }

      return Mutable;
    }

    return (__CFData *)*MEMORY[0x189604DE8];
  }

  if (!CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x189604DE8];
  }
  CFDataGetLength(a6);
  uint64_t CPForPublicSize = getCPForPublicSize();
  if (CPForPublicSize)
  {
    CFTypeID v16 = (void *)CPForPublicSize;
    MEMORY[0x1895F8858](CPForPublicSize);
    uint64_t v18 = (char *)&v29 - v17;
    if (v19 >= 0x10)
    {
      uint64_t v20 = (unint64_t *)((char *)&v29 - v17);
      do
      {
        *uint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
        v20[1] = 0xAAAAAAAAAAAAAAAALL;
        v20 += 2;
        v17 -= 16LL;
      }

      while (v17);
    }

    CFIndex Length = CFDataGetLength(a6);
    uint64_t BytePtr = CFDataGetBytePtr(a6);
    uint64_t v23 = MEMORY[0x186DFF004](v16, Length, BytePtr, v18);
    if ((_DWORD)v23)
    {
      SecError(-50, a8, @"ECpriv sharedsecret: bad public key (err %d)", v23);
    }

    else
    {
      CFIndex v24 = 8LL * *v16;
      unint64_t v29 = v24;
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
      CFDataSetLength(Mutable, v24);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v25 = ccecdh_compute_shared_secret();
      if ((_DWORD)v25)
      {
        uint64_t v27 = v25;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-26275, a8, @"ECpriv failed to compute shared secret (err %d)", v27);
        return 0LL;
      }

      else
      {
        CFDataSetLength(Mutable, v29);
      }
    }
  }

  else
  {
    SecError(-50, a8, @"ECpriv sharedsecret: bad public key");
  }

  return Mutable;
}

void *SecKeyCreateECPublicKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, a2, a3, a4);
}

void *SecKeyCreateECPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPrivateKeyDescriptor, a2, a3, a4);
}

uint64_t SecECKeyGeneratePair(uint64_t a1, void *a2, void *a3)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v6 = SecCFAllocatorZeroize_sAllocator;
  uint64_t v7 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecECPrivateKeyDescriptor, a1, 0LL, 5LL);
  if (!v7) {
    return 4294967246LL;
  }
  uint64_t v8 = v7;
  unint64_t v9 = SecKeyCreate(v6, (uint64_t)&kSecECPublicKeyDescriptor, v7[3], 0LL, 6LL);
  if (!v9)
  {
    uint64_t v10 = 4294967246LL;
LABEL_12:
    CFRelease(v8);
    return v10;
  }

  if (a2)
  {
    *a2 = v9;
    unint64_t v9 = 0LL;
  }

  if (a3)
  {
    *a3 = v8;
    uint64_t v8 = 0LL;
  }

  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = 0LL;
  uint64_t result = 0LL;
  if (v8) {
    goto LABEL_12;
  }
  return result;
}

uint64_t SecECKeyCopyPublicBits(uint64_t a1)
{
  uint64_t v2 = 0LL;
  SecKeyCopyPublicBytes(a1, (uint64_t)&v2);
  return v2;
}

BOOL SecECDoWithFullKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) != &kSecECPrivateKeyDescriptor) {
    return SecError(-50, a2, @"Not an EC Full Key object, sorry can't do.");
  }
  (*(void (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 24));
  return 1LL;
}

BOOL SecECDoWithPubKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) != &kSecECPublicKeyDescriptor) {
    return SecError(-50, a2, @"Not an EC Public Key object, sorry can't do.");
  }
  (*(void (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 24));
  return 1LL;
}

uint64_t SecCurve448PublicKeyInit(uint64_t a1, void *__src, size_t a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a4 != 6)
  {
    if (a4 != 7) {
      return 4294967246LL;
    }
    uint64_t v4 = *(void **)(a1 + 16);
    BOOL v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
    uint64_t v6 = 56LL;
    if (v5) {
      uint64_t v6 = 57LL;
    }
    if (v6 == a3)
    {
      memcpy(*(void **)(a1 + 24), __src, a3);
      return 0LL;
    }

    return 4294941021LL;
  }

  uint64_t v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  int v10 = v9;
  uint64_t v11 = 56LL;
  if (v9) {
    uint64_t v11 = 57LL;
  }
  if (v11 != a3) {
    return 4294941021LL;
  }
  ccrng();
  if (v10)
  {
    uint64_t result = cced448_make_pub();
    if ((_DWORD)result)
    {
      int v12 = result;
      _SECKEY_LOG_8658();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v16 = 67109120;
        int v17 = v12;
        uint64_t v14 = "cced448_make_pub() failed, error %d";
LABEL_30:
        _os_log_error_impl(&dword_1804F4000, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v16, 8u);
        goto LABEL_27;
      }

      goto LABEL_27;
    }
  }

  else
  {
    uint64_t result = cccurve448_make_pub();
    if ((_DWORD)result)
    {
      int v15 = result;
      _SECKEY_LOG_8658();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v16 = 67109120;
        int v17 = v15;
        uint64_t v14 = "cccurve448_make_pub() failed, error %d";
        goto LABEL_30;
      }

uint64_t SecCurve448PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PublicKeyBlockSize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 57LL;
  }
  else {
    return 56LL;
  }
}

__CFDictionary *SecCurve448PublicKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    CFDictionaryRef v3 = @"107";
  }
  else {
    CFDictionaryRef v3 = @"108";
  }
  uint64_t v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0LL);
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v4);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x189604DE0]);
  if (v4) {
    CFRelease(v4);
  }
  return MutableCopy;
}

uint64_t SecCurve448PublicKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  CFDictionaryRef v3 = (void *)NSString;
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  BOOL v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v8) {
    uint64_t v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  int v10 = "kSecX448";
  if (v9) {
    int v10 = "kSecEd448";
  }
  objc_msgSend( v3,  "stringWithFormat:",  @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v10,  AlgorithmId,  v6,  v7,  v8,  a1);
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecCurve448KeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 6LL;
  }
  else {
    return 7LL;
  }
}

uint64_t SecCurve448PublicKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  uint64_t v4 = (const UInt8 *)a1[3];
  BOOL v5 = CFGetAllocator(a1);
  uint64_t v6 = (void *)a1[2];
  if (v6 == &kSecEd448PrivateKeyDescriptor || v6 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v8 = 57LL;
  }
  else {
    CFIndex v8 = 56LL;
  }
  CFDataRef v9 = CFDataCreate(v5, v4, v8);
  *a2 = v9;
  if (v9) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

uint64_t SecCurve448KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0LL;
}

CFDataRef SecCurve448PublicKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFDictionaryRef v3 = CFGetAllocator(a1);
  uint64_t v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57LL;
  }
  else {
    CFIndex v6 = 56LL;
  }
  return CFDataCreate(v3, v2, v6);
}

uint64_t SecCurve448PublicKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  CFIndex v8 = *(void **)(a1 + 16);
  BOOL v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve448:SHAKE256"))
  {
    uint64_t v14 = MEMORY[0x189605018];
    return *(void *)v14;
  }

  if (a5)
  {
LABEL_9:
    uint64_t v14 = MEMORY[0x189604DE8];
    return *(void *)v14;
  }

  CFIndex Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 114)
  {
    uint64_t v17 = cced448_verify();
    if (!(_DWORD)v17) {
      goto LABEL_9;
    }
    SecError(-67808, a8, @"Ed448 signature verification failed (ccerr %d)", v17);
  }

  else
  {
    SecError(-67808, a8, @"Ed448 signature verification failed (invalid signature length)");
  }

  return 0LL;
}

uint64_t SecCurve448PrivateKeyInit(uint64_t a1, const void *a2, size_t a3, int a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (a4 == 5)
  {
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7 == &kSecEd448PublicKeyDescriptor || v7 == &kSecEd448PrivateKeyDescriptor)
    {
      __int128 v19 = 0u;
      memset(v20, 0, sizeof(v20));
      __int128 v18 = 0u;
      ccrng();
      int key_pair = cced448_make_key_pair();
      if (!key_pair)
      {
LABEL_19:
        cc_clear();
        return 0LL;
      }

      int v14 = key_pair;
      _SECKEY_LOG_8658();
      int v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR))
      {
LABEL_25:

        return 4294941021LL;
      }

      *(_DWORD *)__int128 buf = 67109120;
      int v17 = v14;
      uint64_t v13 = "cced448_make_key_pair() failed, error %d";
    }

    else
    {
      __int128 v19 = 0u;
      memset(v20, 0, 24);
      __int128 v18 = 0u;
      ccrng();
      int v11 = cccurve448_make_key_pair();
      if (!v11) {
        goto LABEL_19;
      }
      int v15 = v11;
      _SECKEY_LOG_8658();
      int v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 67109120;
      int v17 = v15;
      uint64_t v13 = "ccec448_make_key_pair() failed, error %d";
    }

    _os_log_error_impl(&dword_1804F4000, (os_log_t)v12, OS_LOG_TYPE_ERROR, v13, buf, 8u);
    goto LABEL_25;
  }

  if (a4 != 7) {
    return 4294899625LL;
  }
  uint64_t v4 = *(void **)(a1 + 16);
  BOOL v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
  uint64_t v6 = 56LL;
  if (v5) {
    uint64_t v6 = 57LL;
  }
  if (v6 != a3) {
    return 4294941021LL;
  }
  memcpy(*(void **)(a1 + 24), a2, a3);
  return 0LL;
}

uint64_t SecCurve448PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PrivateKeyBlockSize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor) {
    return 57LL;
  }
  else {
    return 56LL;
  }
}

CFDictionaryRef SecCurve448PrivateKeyCopyAttributeDictionary(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFDictionaryRef v3 = CFGetAllocator(a1);
  uint64_t v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57LL;
  }
  else {
    CFIndex v6 = 56LL;
  }
  uint64_t v7 = CFDataCreate(v3, v2, v6);
  CFIndex v8 = (void *)a1[2];
  if (v8 == &kSecEd448PrivateKeyDescriptor || v8 == &kSecEd448PublicKeyDescriptor) {
    int v10 = @"107";
  }
  else {
    int v10 = @"108";
  }
  CFDictionaryRef v11 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v10, v7);
  if (v7) {
    CFRelease(v7);
  }
  return v11;
}

CFStringRef SecCurve448PrivateKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  CFDictionaryRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  BOOL v5 = *(unsigned int **)(a1 + 16);
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v8) {
    CFIndex v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  }
  BOOL v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  int v10 = "kSecX448";
  if (v9) {
    int v10 = "kSecEd448";
  }
  return CFStringCreateWithFormat( v3,  0LL,  @"<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v10,  AlgorithmId,  v6,  v7,  v8,  a1);
}

uint64_t SecCurve448PrivateKeyCopyPublicOctets(void *a1, CFDataRef *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (void *)a1[2];
  if (v4 == &kSecEd448PublicKeyDescriptor || v4 == &kSecEd448PrivateKeyDescriptor)
  {
    __int128 v11 = 0u;
    memset(v12, 0, sizeof(v12));
    __int128 v10 = 0u;
    ccrng();
    uint64_t v6 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v6, (const UInt8 *)&v10, 57LL);
  }

  else
  {
    __int128 v11 = 0u;
    memset(v12, 0, 24);
    __int128 v10 = 0u;
    ccrng();
    BOOL v9 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v9, (const UInt8 *)&v10, 56LL);
  }

  cc_clear();
  if (*a2) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

uint64_t SecCurve448KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  return 0LL;
}

CFDataRef SecCurve448PrivateKeyCopyExternalRepresentation(void *a1)
{
  uint64_t v2 = (const UInt8 *)a1[3];
  CFDictionaryRef v3 = CFGetAllocator(a1);
  uint64_t v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor) {
    CFIndex v6 = 57LL;
  }
  else {
    CFIndex v6 = 56LL;
  }
  return CFDataCreate(v3, v2, v6);
}

__CFData *SecCurve448PrivateKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFMutableDictionaryRef Mutable = (__CFData *)*MEMORY[0x189605018];
  if (a2 != 4)
  {
    if (a2) {
      return Mutable;
    }
    int v14 = *(void **)(a1 + 16);
    BOOL v15 = v14 == &kSecEd448PublicKeyDescriptor || v14 == &kSecEd448PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, @"algid:sign:EdDSA:message-Curve448:SHAKE256")) {
      return Mutable;
    }
    if (!a5)
    {
      ccrng();
      if (cced448_make_pub())
      {
        SecError(-2070, a8, @"%@: Failed to get public key from private key", a1);
        return Mutable;
      }

      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
      CFDataSetLength(Mutable, 114LL);
      if (!Mutable)
      {
        SecError(-108, a8, @"%@: Failed to create buffer for a signature", a1);
        return Mutable;
      }

      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      uint64_t v16 = cced448_sign();
      cc_clear();
      if ((_DWORD)v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, @"%@: Ed448 signing failed (ccerr %d)", a1, v16, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0);
        return 0LL;
      }

      return Mutable;
    }

    return (__CFData *)*MEMORY[0x189604DE8];
  }

  int v17 = *(void **)(a1 + 16);
  BOOL v18 = v17 == &kSecEd448PublicKeyDescriptor || v17 == &kSecEd448PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, @"algid:keyexchange:ECDH") && !CFEqual(cf1, @"algid:keyexchange:ECDHC")) {
    return Mutable;
  }
  if (a5) {
    return (__CFData *)*MEMORY[0x189604DE8];
  }
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 56)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
    CFDataSetLength(Mutable, 56LL);
    CFDataSetLength(Mutable, 56LL);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    uint64_t v19 = cccurve448();
    if ((_DWORD)v19)
    {
      uint64_t v21 = v19;
      if (Mutable) {
        CFRelease(Mutable);
      }
      SecError(-50, a8, @"%@: X448 DH failed (ccerr %d)", a1, v21);
      return 0LL;
    }
  }

  else
  {
    SecError(-50, a8, @"X448priv sharedsecret: bad public key");
  }

  return Mutable;
}

id _SECKEY_LOG_8658()
{
  if (_SECKEY_LOG_once_8661 != -1) {
    dispatch_once(&_SECKEY_LOG_once_8661, &__block_literal_global_8662);
  }
  return (id)_SECKEY_LOG_log_8663;
}

uint64_t curve448KeyGeneratePair(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 6) {
    BOOL v9 = &kSecEd448PrivateKeyDescriptor;
  }
  else {
    BOOL v9 = &kSecX448PrivateKeyDescriptor;
  }
  __int128 v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0LL, 5LL);
  if (!v10) {
    return 4294967246LL;
  }
  __int128 v11 = v10;
  if (a4 == 6) {
    int v12 = &kSecEd448PublicKeyDescriptor;
  }
  else {
    int v12 = &kSecX448PublicKeyDescriptor;
  }
  if (a4 == 6) {
    uint64_t v13 = 57LL;
  }
  else {
    uint64_t v13 = 56LL;
  }
  int v14 = SecKeyCreate(v8, (uint64_t)v12, v10[3], v13, 6LL);
  if (!v14)
  {
    uint64_t v15 = 4294967246LL;
LABEL_21:
    CFRelease(v11);
    return v15;
  }

  if (a2)
  {
    *a2 = v14;
    int v14 = 0LL;
  }

  if (a3)
  {
    *a3 = v11;
    __int128 v11 = 0LL;
  }

  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = 0LL;
  uint64_t result = 0LL;
  if (v11) {
    goto LABEL_21;
  }
  return result;
}

id SecEMCSCreateDerivedEMCSKey(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = a1;
  unint64_t Value = CFDictionaryGetValue(v4, @"salt");
  CFIndex v6 = CFDictionaryGetValue(v4, @"iter");
  uint64_t v7 = CFDictionaryGetValue(v4, @"wkey");

  if (!Value) {
    goto LABEL_10;
  }
  CFTypeID v8 = CFGetTypeID(Value);
  BOOL v9 = 0LL;
  if (v8 == CFDataGetTypeID())
  {
    if (v6)
    {
      CFTypeID v10 = CFGetTypeID(v6);
      BOOL v9 = 0LL;
      if (v10 == CFNumberGetTypeID())
      {
        if (v7)
        {
          CFTypeID v11 = CFGetTypeID(v7);
          if (v11 == CFDataGetTypeID())
          {
            if (CFNumberGetValue((CFNumberRef)v6, kCFNumberLongType, &valuePtr))
            {
              DerivedKey = CreateDerivedKey((const __CFData *)Value, valuePtr, v3);
              if (DerivedKey)
              {
                uint64_t v13 = DerivedKey;
                CopyUnwrappedKey(DerivedKey, (const __CFData *)v7);
                BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
                CFRelease(v13);
                goto LABEL_11;
              }
            }
          }

__CFData *CreateDerivedKey(const __CFData *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a2 < 1000 || CFDataGetLength(a1) < 16) {
    goto LABEL_8;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 16LL);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 16LL);
    ccsha256_di();
    id v8 = v5;
    strlen((const char *)[v8 UTF8String]);
    [v8 UTF8String];
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    CFDataGetMutableBytePtr(v7);
    if (ccpbkdf2_hmac())
    {
      CFRelease(v7);
LABEL_8:
      uint64_t v7 = 0LL;
    }
  }

  return v7;
}

__CFData *CopyUnwrappedKey(const __CFData *a1, const __CFData *a2)
{
  v14[1] = *MEMORY[0x1895F89C0];
  ccaes_ecb_decrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1895F8858](v4);
  if (v6 >= 0x10)
  {
    uint64_t v7 = (void *)((char *)v14 - v5);
    do
    {
      *uint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16LL;
    }

    while (v5);
  }

  if (CFDataGetLength(a2) < 8 || CFDataGetLength(a1) != 16) {
    goto LABEL_11;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  id v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFDataGetLength(a2);
  CFIndex v9 = ccwrap_unwrapped_size();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v8, 0LL);
  CFDataSetLength(Mutable, v9);
  if (!Mutable) {
    goto LABEL_11;
  }
  v14[0] = 0LL;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFTypeID v11 = Mutable;
  -[__CFData mutableBytes](v11, "mutableBytes");
  if (ccwrap_auth_decrypt())
  {

LABEL_11:
    CFTypeID v11 = 0LL;
    goto LABEL_14;
  }

  uint64_t v12 = v14[0];
  if (v12 != -[__CFData length](v11, "length")) {
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
LABEL_14:
  ccecb_context_size();
  cc_clear();
  return v11;
}

__CFData *SecEMCSCreateNewiDMSKey(void *a1, void *a2, void *a3, void *a4)
{
  keys[3] = *(void **)MEMORY[0x1895F89C0];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  uint64_t v21 = 1000LL;
  if (a4) {
    *a4 = 0LL;
  }
  if (!v8 || (CFTypeID v10 = CFGetTypeID(v8), v10 == CFDataGetTypeID()) && CFDataGetLength(v8) == 16)
  {
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
    CFDataSetLength(Mutable, 16LL);
    if (!Mutable)
    {
      uint64_t v12 = 0LL;
      goto LABEL_12;
    }

    CFDataGetLength(Mutable);
    CFDataGetMutableBytePtr(Mutable);
    if (CCRandomCopyBytes() || (CFNumberRef v16 = CFNumberCreate(0LL, kCFNumberLongType, &v21)) == 0LL)
    {
      uint64_t v12 = 0LL;
      uint64_t v13 = Mutable;
LABEL_9:
      CFRelease(v13);
LABEL_12:
      int v14 = v12;
      goto LABEL_13;
    }

    CFNumberRef v17 = v16;
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    if (v8)
    {
      CFMutableStringRef MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL, v8);
    }

    else
    {
      CFMutableStringRef MutableCopy = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
      CFDataSetLength(MutableCopy, 16LL);
      if (!MutableCopy
        || (CFDataGetLength(MutableCopy), CFDataGetMutableBytePtr(MutableCopy), CCRandomCopyBytes()))
      {
        uint64_t v13 = 0LL;
        goto LABEL_27;
      }
    }

    DerivedKey = CreateDerivedKey(Mutable, 1000LL, v9);
    uint64_t v12 = DerivedKey;
    if (!DerivedKey)
    {
      uint64_t v13 = 0LL;
      goto LABEL_29;
    }

    uint64_t v13 = CopyWrappedKey(DerivedKey, MutableCopy);
    CFRelease(v12);
    if (v13)
    {
      keys[0] = @"salt";
      keys[1] = @"iter";
      keys[2] = @"wkey";
      values[0] = Mutable;
      values[1] = v17;
      values[2] = v13;
      CFDictionaryRef v20 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  3LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      uint64_t v12 = v20;
      if (a4 && v20)
      {
        CFRetain(MutableCopy);
        *a4 = (id)objc_claimAutoreleasedReturnValue();
      }

__CFData *CopyWrappedKey(const __CFData *a1, const __CFData *a2)
{
  v12[1] = *MEMORY[0x1895F89C0];
  ccaes_ecb_encrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1895F8858](v4);
  if (v6 >= 0x10)
  {
    id v7 = (void *)((char *)v12 - v5);
    do
    {
      *id v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16LL;
    }

    while (v5);
  }

  if (CFDataGetLength(a1) != 16) {
    goto LABEL_8;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  CFDataGetLength(a2);
  CFIndex v8 = ccwrap_wrapped_size();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
  CFDataSetLength(Mutable, v8);
  v12[0] = 0LL;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFDataGetMutableBytePtr(Mutable);
  if (ccwrap_auth_encrypt())
  {
    if (Mutable)
    {
      CFRelease(Mutable);
LABEL_8:
      CFMutableDictionaryRef Mutable = 0LL;
    }
  }

  else
  {
    uint64_t v10 = v12[0];
    if (v10 != CFDataGetLength(Mutable)) {
      __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    }
  }

  ccecb_context_size();
  cc_clear();
  return Mutable;
}

uint64_t SecKyberPublicKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 24) = a2;
    return result;
  }

  cckem_kyber768();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber768();
    goto LABEL_7;
  }

  cckem_kyber1024();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber1024();
LABEL_7:
    size_t v6 = cckem_sizeof_pub_ctx();
    *(void *)(a1 + 24) = calloc(1uLL, v6);
    uint64_t result = cckem_import_pubkey();
    if (!(_DWORD)result) {
      return result;
    }
    int v7 = result;
    secLogObjForScope("SecWarning");
    CFIndex v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 67109376;
      int v13 = a3;
      __int16 v14 = 1024;
      int v15 = v7;
      id v9 = "Kyber pubkey size=%dbytes import failed: %d";
      uint64_t v10 = v8;
      uint32_t v11 = 14;
LABEL_12:
      _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, v11);
      goto LABEL_13;
    }

    goto LABEL_13;
  }

  secLogObjForScope("SecWarning");
  CFIndex v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 67109120;
    int v13 = a3;
    id v9 = "Kyber pubkey size=%dbytes is invalid";
    uint64_t v10 = v8;
    uint32_t v11 = 8;
    goto LABEL_12;
  }

void SecKyberPublicKeyDestroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_pub_ctx();
    free(v1);
  }

uint64_t SecKyberPublicKeyBlockSize()
{
  return cckem_pubkey_nbytes_ctx();
}

uint64_t SecKyberPublicKeyCopyAttributeDictionary(uint64_t a1)
{
  v32[23] = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_pubkey_nbytes_info())
  {
    id v3 = @"768";
LABEL_5:
    uint64_t v5 = v3;
    goto LABEL_9;
  }

  uint64_t v4 = cckem_pubkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_pubkey_nbytes_info())
  {
    id v3 = @"1024";
    goto LABEL_5;
  }

  secLogObjForScope("SecError");
  size_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  id v3 = (__CFString *)&unk_18969C138;
LABEL_9:
  CFDictionaryRef v20 = v3;
  int v7 = SecKyberPublicKeyCopyData(v1, 0LL);
  CFIndex v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v25 = v7;
  unint64_t v29 = SecSHA1DigestCreate(v8, -[__CFData bytes](v25, "bytes"), -[__CFData length](v25, "length"));
  v31[0] = @"class";
  v31[1] = @"type";
  v32[0] = @"keys";
  v32[1] = @"109";
  v31[2] = @"bsiz";
  v31[3] = @"esiz";
  v32[2] = v3;
  v32[3] = v3;
  unint64_t v31[4] = @"kcls";
  void v31[5] = @"klbl";
  v32[4] = @"0";
  v32[5] = v29;
  v31[6] = @"perm";
  [MEMORY[0x189607968] numberWithBool:1];
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  v32[6] = v28;
  v31[7] = @"priv";
  [MEMORY[0x189607968] numberWithBool:1];
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
  v32[7] = v27;
  v31[8] = @"modi";
  [MEMORY[0x189607968] numberWithBool:1];
  CFNumberRef v26 = (void *)objc_claimAutoreleasedReturnValue();
  v32[8] = v26;
  v31[9] = @"sens";
  [MEMORY[0x189607968] numberWithBool:0];
  CFIndex v24 = (void *)objc_claimAutoreleasedReturnValue();
  v32[9] = v24;
  v31[10] = @"asen";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  v32[10] = v23;
  v31[11] = @"extr";
  [MEMORY[0x189607968] numberWithBool:1];
  CFTypeID v22 = (void *)objc_claimAutoreleasedReturnValue();
  v32[11] = v22;
  v31[12] = @"next";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  v32[12] = v21;
  v31[13] = @"encr";
  [MEMORY[0x189607968] numberWithBool:0];
  id v9 = (void *)objc_claimAutoreleasedReturnValue();
  v32[13] = v9;
  v31[14] = @"decr";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  v32[14] = v10;
  v31[15] = @"drve";
  [MEMORY[0x189607968] numberWithBool:0];
  uint32_t v11 = (void *)objc_claimAutoreleasedReturnValue();
  v32[15] = v11;
  v31[16] = @"sign";
  [MEMORY[0x189607968] numberWithBool:0];
  int v12 = (void *)objc_claimAutoreleasedReturnValue();
  v32[16] = v12;
  v31[17] = @"vrfy";
  [MEMORY[0x189607968] numberWithBool:0];
  int v13 = (void *)objc_claimAutoreleasedReturnValue();
  v32[17] = v13;
  v31[18] = @"snrc";
  [MEMORY[0x189607968] numberWithBool:0];
  __int16 v14 = (void *)objc_claimAutoreleasedReturnValue();
  v32[18] = v14;
  v31[19] = @"vyrc";
  [MEMORY[0x189607968] numberWithBool:0];
  int v15 = (void *)objc_claimAutoreleasedReturnValue();
  v32[19] = v15;
  v31[20] = @"wrap";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  v32[20] = v16;
  v31[21] = @"unwp";
  [MEMORY[0x189607968] numberWithBool:0];
  CFNumberRef v17 = (void *)objc_claimAutoreleasedReturnValue();
  v31[22] = @"v_Data";
  v32[21] = v17;
  v32[22] = v25;
  uint64_t v19 = [MEMORY[0x189603F68] dictionaryWithObjects:v32 forKeys:v31 count:23];

  return v19;
}

uint64_t SecKyberPublicKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = cckem_pubkey_nbytes_ctx();
  [MEMORY[0x189607940] stringWithCapacity:2 * v2];
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v5 = cckem_pubkey_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v4, 0LL);
  CFDataSetLength(Mutable, v5);
  uint64_t v15 = -[__CFData length](Mutable, "length");
  int v7 = Mutable;
  -[__CFData mutableBytes](v7, "mutableBytes");
  if (!cckem_export_pubkey())
  {
    -[__CFData setLength:](v7, "setLength:", v15);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        objc_msgSend( v3, "appendFormat:", @"%02X", *(unsigned __int8 *)(-[__CFData bytes](v7, "bytes") + i));
    }
  }

  uint64_t v9 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v9 == cckem_pubkey_nbytes_info())
  {
    uint64_t v10 = @"Kyber-768-pubKey";
  }

  else
  {
    uint64_t v11 = cckem_pubkey_nbytes_ctx();
    cckem_kyber1024();
    uint64_t v12 = cckem_pubkey_nbytes_info();
    uint64_t v10 = @"Kyber";
    if (v11 == v12) {
      uint64_t v10 = @"Kyber-1024-pubKey";
    }
  }

  uint64_t v13 = [NSString stringWithFormat:@"<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, bytes: %@, addr: %p>", v10, 8, *(void *)(*(void *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), v3, a1];

  return v13;
}

uint64_t SecKyberKeyGetAlgorithmID()
{
  return 8LL;
}

uint64_t SecKyberPublicKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  id v3 = SecKyberPublicKeyCopyData(*(void *)(a1 + 24), 0LL);
  *a2 = v3;
  if (v3) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecKyberPublicKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  return SecKyberPublicKeyCopyData(*(void *)(a1 + 24), a2);
}

uint64_t SecKyberPublicKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  void v23[2] = *MEMORY[0x1895F89C0];
  if (a2 != 5 || !CFEqual(cf1, @"algid:kem:kyber"))
  {
    uint64_t v11 = MEMORY[0x189605018];
    return *(void *)v11;
  }

  if (a5)
  {
    uint64_t v11 = MEMORY[0x189604DE8];
    return *(void *)v11;
  }

  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  __int16 v14 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v15 = cckem_shared_key_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v14, 0LL);
  CFDataSetLength(Mutable, v15);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFNumberRef v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v18 = cckem_encapsulated_key_nbytes_ctx();
  uint64_t v19 = CFDataCreateMutable(v17, 0LL);
  CFDataSetLength(v19, v18);
  -[__CFData length](v19, "length");
  CFDictionaryRef v20 = v19;
  -[__CFData mutableBytes](v20, "mutableBytes");
  -[__CFData length](Mutable, "length");
  uint64_t v21 = Mutable;
  -[__CFData mutableBytes](v21, "mutableBytes");
  ccrng();
  uint64_t v22 = cckem_encapsulate();
  if ((_DWORD)v22) {
    SecError(-26275, a8, @"Key encapsulation failed, err=%d for key %@", v22, a1);
  }
  v23[0] = v20;
  v23[1] = v21;
  uint64_t v12 = [MEMORY[0x189603F18] arrayWithObjects:v23 count:2];

  return v12;
}

__CFData *SecKyberPublicKeyCopyData(uint64_t a1, __CFString **a2)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  id v3 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v4 = cckem_pubkey_nbytes_ctx();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v3, 0LL);
  CFDataSetLength(Mutable, v4);
  uint64_t v9 = -[__CFData length](Mutable, "length");
  size_t v6 = Mutable;
  -[__CFData mutableBytes](v6, "mutableBytes");
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, @"Failed to export Kyber pubkey");
    int v7 = 0LL;
  }

  else
  {
    -[__CFData setLength:](v6, "setLength:", v9);
    int v7 = v6;
  }

  return v7;
}

uint64_t SecKyberPrivateKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 24) = a2;
    return result;
  }

  cckem_kyber768();
  uint64_t v5 = cckem_pubkey_nbytes_info();
  cckem_kyber768();
  if (cckem_privkey_nbytes_info() + v5 == a3)
  {
    cckem_kyber768();
  }

  else
  {
    cckem_kyber1024();
    uint64_t v7 = cckem_pubkey_nbytes_info();
    cckem_kyber1024();
    if (cckem_privkey_nbytes_info() + v7 != a3)
    {
      secLogObjForScope("SecWarning");
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 67109120;
        int v17 = a3;
        uint64_t v12 = "Kyber pubkey size=%dbytes is invalid";
        __int16 v14 = v11;
        uint32_t v15 = 8;
        goto LABEL_16;
      }

      goto LABEL_17;
    }

    cckem_kyber1024();
  }

  size_t v8 = cckem_sizeof_full_ctx();
  *(void *)(a1 + 24) = calloc(1uLL, v8);
  cckem_pubkey_nbytes_info();
  int v9 = cckem_import_privkey();
  if (v9)
  {
    int v10 = v9;
    secLogObjForScope("SecWarning");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 67109376;
      int v17 = a3;
      __int16 v18 = 1024;
      int v19 = v10;
      uint64_t v12 = "Kyber privkey size=%dbytes import or priv part failed: %d";
LABEL_13:
      __int16 v14 = v11;
      uint32_t v15 = 14;
LABEL_16:
      _os_log_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, v15);
    }
  }

  else
  {
    cckem_public_ctx();
    uint64_t result = cckem_import_pubkey();
    if (!(_DWORD)result) {
      return result;
    }
    int v13 = result;
    secLogObjForScope("SecWarning");
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 67109376;
      int v17 = a3;
      __int16 v18 = 1024;
      int v19 = v13;
      uint64_t v12 = "Kyber privkey size=%dbytes import of pub part failed: %d";
      goto LABEL_13;
    }
  }

void SecKyberPrivateKeyDestroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_full_ctx();
    free(v1);
  }

uint64_t SecKyberPrivateKeyBlockSize()
{
  return cckem_privkey_nbytes_ctx();
}

uint64_t SecKyberPrivateKeyCopyAttributeDictionary(uint64_t a1)
{
  v38[23] = *MEMORY[0x1895F89C0];
  uint64_t v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    id v3 = @"768";
LABEL_5:
    uint64_t v5 = v3;
    goto LABEL_9;
  }

  uint64_t v4 = cckem_privkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_privkey_nbytes_info())
  {
    id v3 = @"1024";
    goto LABEL_5;
  }

  secLogObjForScope("SecError");
  size_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  id v3 = (__CFString *)&unk_18969C138;
LABEL_9:
  uint64_t v7 = cckem_public_ctx();
  size_t v8 = SecKyberPublicKeyCopyData(v7, 0LL);
  if (v8)
  {
    int v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    int v10 = v8;
    uint64_t v11 = SecSHA1DigestCreate(v9, -[__CFData bytes](v10, "bytes"), -[__CFData length](v10, "length"));
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  v37[0] = @"class";
  v37[1] = @"type";
  v38[0] = @"keys";
  v38[1] = @"109";
  v37[2] = @"bsiz";
  v37[3] = @"esiz";
  v38[3] = v3;
  v38[4] = @"1";
  v37[4] = @"kcls";
  v37[5] = @"klbl";
  uint64_t v12 = (uint64_t)v11;
  v38[2] = v3;
  uint64_t v34 = v11;
  uint64_t v35 = v3;
  if (!v11)
  {
    uint64_t v12 = [MEMORY[0x189603F48] data];
  }

  v38[5] = v12;
  v37[6] = @"perm";
  objc_msgSend(MEMORY[0x189607968], "numberWithBool:", 1, v12);
  __int128 v33 = (void *)objc_claimAutoreleasedReturnValue();
  v38[6] = v33;
  v37[7] = @"priv";
  [MEMORY[0x189607968] numberWithBool:1];
  CFTypeID v32 = (void *)objc_claimAutoreleasedReturnValue();
  v38[7] = v32;
  v37[8] = @"modi";
  [MEMORY[0x189607968] numberWithBool:1];
  char v31 = (void *)objc_claimAutoreleasedReturnValue();
  v38[8] = v31;
  v37[9] = @"sens";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue();
  v38[9] = v30;
  v37[10] = @"asen";
  [MEMORY[0x189607968] numberWithBool:0];
  unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  v38[10] = v29;
  v37[11] = @"extr";
  [MEMORY[0x189607968] numberWithBool:1];
  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
  v38[11] = v28;
  v37[12] = @"next";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
  v38[12] = v27;
  v37[13] = @"encr";
  [MEMORY[0x189607968] numberWithBool:0];
  CFNumberRef v26 = (void *)objc_claimAutoreleasedReturnValue();
  v38[13] = v26;
  v37[14] = @"decr";
  [MEMORY[0x189607968] numberWithBool:0];
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
  v38[14] = v25;
  v37[15] = @"drve";
  [MEMORY[0x189607968] numberWithBool:0];
  int v13 = (void *)objc_claimAutoreleasedReturnValue();
  v38[15] = v13;
  v37[16] = @"sign";
  [MEMORY[0x189607968] numberWithBool:0];
  __int16 v14 = (void *)objc_claimAutoreleasedReturnValue();
  v38[16] = v14;
  v37[17] = @"vrfy";
  [MEMORY[0x189607968] numberWithBool:0];
  uint32_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  v38[17] = v15;
  v37[18] = @"snrc";
  [MEMORY[0x189607968] numberWithBool:0];
  int v16 = (void *)objc_claimAutoreleasedReturnValue();
  v38[18] = v16;
  v37[19] = @"vyrc";
  [MEMORY[0x189607968] numberWithBool:0];
  int v17 = (void *)objc_claimAutoreleasedReturnValue();
  v38[19] = v17;
  v37[20] = @"wrap";
  [MEMORY[0x189607968] numberWithBool:0];
  __int16 v18 = (void *)objc_claimAutoreleasedReturnValue();
  v38[20] = v18;
  v37[21] = @"unwp";
  [MEMORY[0x189607968] numberWithBool:0];
  int v19 = (void *)objc_claimAutoreleasedReturnValue();
  v38[21] = v19;
  v37[22] = @"v_Data";
  uint64_t v20 = SecKyberPrivateKeyCopyExternalRepresentation(a1, 0LL);
  uint64_t v21 = v20;
  if (!v20)
  {
    [MEMORY[0x189603FB8] data];
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  }

  v38[22] = v21;
  uint64_t v22 = [MEMORY[0x189603F68] dictionaryWithObjects:v38 forKeys:v37 count:23];
  if (!v20) {

  }
  if (!v34) {
  return v22;
  }
}

uint64_t SecKyberPrivateKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    id v3 = @"Kyber-768-privKey";
  }

  else
  {
    uint64_t v4 = cckem_privkey_nbytes_ctx();
    cckem_kyber1024();
    uint64_t v5 = cckem_privkey_nbytes_info();
    id v3 = @"Kyber";
    if (v4 == v5) {
      id v3 = @"Kyber-1024-privKey";
    }
  }

  [NSString stringWithFormat:@"<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, addr: %p>", v3, 8, *(void *)(*(void *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), a1];
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecKyberPrivateKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  uint64_t v3 = cckem_public_ctx();
  uint64_t v4 = SecKyberPublicKeyCopyData(v3, 0LL);
  *a2 = v4;
  if (v4) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecKyberPrivateKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  uint64_t v4 = cckem_pubkey_nbytes_ctx();
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v5 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v6 = cckem_privkey_nbytes_ctx() + v4;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v5, 0LL);
  CFDataSetLength(Mutable, v6);
  uint64_t v13 = -[__CFData length](Mutable, "length");
  cckem_public_ctx();
  size_t v8 = Mutable;
  -[__CFData mutableBytes](v8, "mutableBytes");
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, @"Failed to export public part of %@", a1);
  }

  else
  {
    uint64_t v12 = -[__CFData length](v8, "length") - v13;
    int v9 = v8;
    -[__CFData mutableBytes](v9, "mutableBytes");
    if (!cckem_export_privkey())
    {
      -[__CFData setLength:](v9, "setLength:", v12 + v13);
      int v10 = v9;
      goto LABEL_8;
    }

    SecError(-26275, a2, @"Failed to export %@", a1);
  }

  int v10 = 0LL;
LABEL_8:

  return v10;
}

__CFData *SecKyberPrivateKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, __CFString **a8)
{
  if (a2 != 6 || !CFEqual(cf1, @"algid:kem:kyber"))
  {
    uint64_t v12 = MEMORY[0x189605018];
    return *(__CFData **)v12;
  }

  if (a5)
  {
    uint64_t v12 = MEMORY[0x189604DE8];
    return *(__CFData **)v12;
  }

  id v15 = a6;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && (uint64_t v16 = [v15 length], v16 == cckem_encapsulated_key_nbytes_info()))
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    int v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    CFIndex v18 = cckem_shared_key_nbytes_info();
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(v17, 0LL);
    CFDataSetLength(Mutable, v18);
    [v15 length];
    [v15 bytes];
    -[__CFData length](Mutable, "length");
    uint64_t v13 = Mutable;
    -[__CFData mutableBytes](v13, "mutableBytes");
    uint64_t v20 = cckem_decapsulate();
    if ((_DWORD)v20) {
      SecError(-26275, a8, @"Key decapsulation failed, err=%d for key %@", v20, a1);
    }
  }

  else
  {
    uint64_t v21 = cckem_encapsulated_key_nbytes_info();
    SecError(-50, a8, @"Kyber decapsulation failed: expecting input data of size %dbytes", v21);
    uint64_t v13 = 0LL;
  }

  return v13;
}

uint64_t SecKyberKeyGeneratePair(void *a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  cckem_kyber768();
  [a1 objectForKeyedSubscript:@"bsiz"];
  CFIndex v6 = (void *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = v6;
  if (!v6)
  {
LABEL_6:
    size_t v10 = cckem_sizeof_full_ctx();
    uint64_t v11 = calloc(1uLL, v10);
    cckem_full_ctx_init();
    ccrng();
    int key = cckem_generate_key();
    if (key)
    {
      int v13 = key;
      free(v11);
      secLogObjForScope("SecWarning");
      __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 67109120;
        LODWORD(v26) = v13;
        _os_log_impl( &dword_1804F4000,  v14,  OS_LOG_TYPE_DEFAULT,  "Failed to generate Kyber key: err %d",  (uint8_t *)&v25,  8u);
      }

      uint64_t v15 = 4294941021LL;
    }

    else
    {
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      uint64_t v16 = SecKeyCreate( SecCFAllocatorZeroize_sAllocator,  (uint64_t)&kSecKyberPrivateKeyDescriptor,  (uint64_t)v11,  0LL,  0LL);
      if (v16)
      {
        size_t v17 = cckem_sizeof_pub_ctx();
        CFIndex v18 = calloc(1uLL, v17);
        int v19 = (const void *)cckem_public_ctx();
        size_t v20 = cckem_sizeof_pub_ctx();
        memcpy(v18, v19, v20);
        if (SecCFAllocatorZeroize_sOnce != -1) {
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
        }
        uint64_t v21 = SecKeyCreate( SecCFAllocatorZeroize_sAllocator,  (uint64_t)&kSecKyberPublicKeyDescriptor,  (uint64_t)v18,  0LL,  0LL);
        uint64_t v22 = v21;
        if (v21)
        {
          if (a2) {
            *a2 = v21;
          }
          uint64_t v15 = 0LL;
          if (a3) {
            *a3 = v16;
          }
        }

        else
        {
          uint64_t v15 = 4294967246LL;
        }
      }

      else
      {
        uint64_t v15 = 4294967246LL;
      }
    }

    goto LABEL_27;
  }

  uint64_t v8 = [v6 integerValue];
  if (v8 == [@"768" integerValue])
  {
    cckem_kyber768();
    goto LABEL_6;
  }

  uint64_t v9 = [v7 integerValue];
  if (v9 == [@"1024" integerValue])
  {
    cckem_kyber1024();
    goto LABEL_6;
  }

  secLogObjForScope("SecWarning");
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 138412290;
    CFNumberRef v26 = v7;
    _os_log_impl( &dword_1804F4000,  v23,  OS_LOG_TYPE_DEFAULT,  "Invalid kyber type %@ requested for Kyber key generation",  (uint8_t *)&v25,  0xCu);
  }

  uint64_t v15 = 4294967246LL;
LABEL_27:

  return v15;
}

CFTypeID SecIdentityGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_8732;
  block[4] = &SecIdentityGetTypeID_sSecIdentityGetTypeIDSingleton;
  if (SecIdentityGetTypeID_sSecIdentityGetTypeIDOnce != -1) {
    dispatch_once(&SecIdentityGetTypeID_sSecIdentityGetTypeIDOnce, block);
  }
  return SecIdentityGetTypeID_sSecIdentityGetTypeIDSingleton;
}

uint64_t __SecIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SecIdentityDestroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 24) = 0LL;
    CFRelease(v3);
  }

uint64_t SecIdentityCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if ((_DWORD)result) {
    return CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
  }
  return result;
}

CFHashCode SecIdentityHash(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return CFHash(*(CFTypeRef *)(a1 + 24)) + v2;
}

CFStringRef SecIdentityCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SecIdentityRef: %p>", a1);
}

CFStringRef SecIdentityCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SecIdentityRef: %p>", a1);
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  CFHashCode v2 = (__SecCertificate *)*((void *)identityRef + 2);
  *certificateRef = v2;
  CFRetain(v2);
  return 0;
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  CFHashCode v2 = (__SecKey *)*((void *)identityRef + 3);
  *privateKeyRef = v2;
  CFRetain(v2);
  return 0;
}

uint64_t SecIdentityCreate(int a1, CFTypeRef cf, const void *a3)
{
  if (!cf) {
    return 0LL;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  CFTypeID TypeID = SecCertificateGetTypeID();
  uint64_t Instance = 0LL;
  if (!a3 || v5 != TypeID) {
    return Instance;
  }
  CFTypeID v8 = CFGetTypeID(a3);
  if (v8 != SecKeyGetTypeID()) {
    return 0LL;
  }
  SecIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(cf);
    CFRetain(a3);
    *(void *)(Instance + 16) = cf;
    *(void *)(Instance + 24) = a3;
  }

  return Instance;
}

OSStatus SecPKCS12Import(CFDataRef pkcs12_data, CFDictionaryRef options, CFArrayRef *items)
{
  SecAsn1CoderRef coder = 0LL;
  CFTypeRef cf = 0LL;
  CFDictionaryRef theDict = 0LL;
  SecAsn1CoderCreate(&coder);
  if (options)
  {
    unint64_t Value = CFDictionaryGetValue(options, @"passphrase");
    CFTypeRef cf = Value;
    if (Value) {
      CFRetain(Value);
    }
  }

  if (!cf) {
    CFTypeRef cf = CFStringCreateWithCString(0LL, (const char *)&unk_18065A197, 0x8000100u);
  }
  CFDictionaryRef theDict = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  uint64_t v50 = 0LL;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v47 = 0u;
  CFIndex Length = CFDataGetLength(pkcs12_data);
  uint64_t BytePtr = (char *)CFDataGetBytePtr(pkcs12_data);
  int v9 = -50;
  if (coder && BytePtr)
  {
    if (SEC_ASN1Decode( *(void *)coder,  (uint64_t)&v47,  (uint64_t)&NSS_P12_DecodedPFXTemplate,  BytePtr,  Length)) {
      int v9 = -26275;
    }
    else {
      int v9 = 0;
    }
  }

  int v10 = 1;
  if (v9) {
    goto LABEL_25;
  }
  if ((_DWORD)v49 != 1) {
    goto LABEL_25;
  }
  uint64_t v11 = v50;
  if (!v50) {
    goto LABEL_25;
  }
  *(void *)&__int128 context = v50[1];
  *((void *)&context + 1) = *v50;
  if (DEROidCompare((uint64_t)&oidSha1, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 0;
    unsigned int v13 = 20;
LABEL_18:
    CC_LONG v14 = 64;
    goto LABEL_19;
  }

  if (DEROidCompare((uint64_t)&oidSha256, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 2;
    unsigned int v13 = 32;
    goto LABEL_18;
  }

  if (DEROidCompare((uint64_t)&oidSha384, (uint64_t)&context))
  {
    CCHmacAlgorithm v12 = 3;
    unsigned int v13 = 48;
  }

  else
  {
    if (!DEROidCompare((uint64_t)&oidSha512, (uint64_t)&context))
    {
      CCHmacAlgorithm v12 = 5;
      unsigned int v13 = 28;
      goto LABEL_18;
    }

    CCHmacAlgorithm v12 = 4;
    unsigned int v13 = 64;
  }

  CC_LONG v14 = 128;
LABEL_19:
  if (!*((void *)&context + 1))
  {
LABEL_23:
    size_t v17 = 0LL;
LABEL_24:
    free(v17);
    int v10 = 2;
LABEL_25:
    LODWORD(v51) = v10;
    goto LABEL_59;
  }

  unint64_t v15 = v11[8];
  if (!v15) {
    goto LABEL_31;
  }
  uint64_t v16 = (unsigned __int8 *)v11[9];
  if (!v16) {
    goto LABEL_31;
  }
  if (v15 > 4) {
    goto LABEL_23;
  }
  unsigned int v18 = 0;
  do
  {
    int v19 = *v16++;
    unsigned int v18 = v19 | (v18 << 8);
    --v15;
  }

  while (v15);
  if (!v18) {
LABEL_31:
  }
    unsigned int v18 = 1;
  size_t v20 = v13;
  size_t v17 = malloc(v13);
  uint64_t v21 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v51 = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  if (coder)
  {
    uint64_t v21 = (void *)PORT_ArenaAlloc(*(void *)coder, v20);
    unint64_t v52 = (unint64_t)v21;
    if (v21) {
      unsigned int v51 = (void *)v20;
    }
  }

  CCHmac(v12, v17, v20, *(const void **)(*((void *)&v49 + 1) + 8LL), **((void **)&v49 + 1), v21);
  free(v17);
  unsigned int v51 = 0LL;
  if (!coder
    || (uint64_t v22 = *(char **)(*((void *)&v49 + 1) + 8LL)) == 0LL
    || SEC_ASN1Decode( *(void *)coder,  (uint64_t)&v51,  (uint64_t)&NSS_P12_AuthenticatedSafeTemplate,  v22,  **((void **)&v49 + 1)))
  {
LABEL_80:
    int v10 = 1;
    goto LABEL_25;
  }

  if (v51)
  {
    if (*v51)
    {
      uint64_t v23 = 0LL;
      while (v51[++v23])
        ;
      if ((_DWORD)v23)
      {
        unint64_t v25 = 0LL;
        uint64_t v26 = 8LL * v23;
        while (1)
        {
          uint64_t v27 = v51[v25 / 8];
          int v28 = *(_DWORD *)(v27 + 16);
          if (v28 == 6) {
            break;
          }
          if (v28 == 1)
          {
            unint64_t v29 = *(unint64_t **)(v27 + 24);
            unint64_t v30 = *v29;
            char v31 = (char *)v29[1];
            goto LABEL_51;
          }

LABEL_52:
          v25 += 8LL;
          if (v26 == v25) {
            goto LABEL_53;
          }
        }

        __int128 context = 0uLL;
        p12Decrypt((uint64_t)&coder, (void *)(*(void *)(v27 + 24) + 32LL), *(void *)(v27 + 24) + 64LL, &context);
        if (v32) {
          goto LABEL_80;
        }
        char v31 = (char *)*((void *)&context + 1);
        unint64_t v30 = context;
LABEL_51:
        goto LABEL_52;
      }
    }
  }

          operator delete(v47[0]);
          if ((v51 & 0x80) == 0)
          {
LABEL_49:
            if (!v36) {
              goto LABEL_54;
            }
            goto LABEL_60;
          }

void collect_certs(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (!CFDictionaryContainsKey(theDict, @"key"))
  {
    unint64_t Value = (const __CFData *)CFDictionaryGetValue(theDict, @"cert");
    if (Value)
    {
      SecCertificateRef v6 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x189604DB0], Value);
      if (v6)
      {
        SecCertificateRef v7 = v6;
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, v6);
        CFRelease(v7);
      }

      else
      {
        **(_DWORD **)(a3 + _Block_object_dispose(va, 8) = 1;
      }
    }
  }

void build_trust_chains(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  SecTrustRef trust = 0LL;
  unint64_t Value = (const __CFData *)CFDictionaryGetValue(a2, @"key");
  if (!Value) {
    goto LABEL_34;
  }
  CFTypeID v8 = (const __CFData *)CFDictionaryGetValue(a2, @"cert");
  if (!v8)
  {
    unint64_t v15 = 0LL;
    CFArrayRef v17 = 0LL;
    SecPolicyRef BasicX509 = 0LL;
    unsigned int v13 = 0LL;
    unint64_t Value = 0LL;
    goto LABEL_17;
  }

  int v9 = (const __CFData *)CFDictionaryGetValue(a2, @"algid");
  v19[0] = CFDataGetBytePtr(v9);
  v19[1] = CFDataGetLength(v9);
  if (DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v19))
  {
    uint64_t BytePtr = CFDataGetBytePtr(Value);
    CFIndex Length = CFDataGetLength(Value);
    CCHmacAlgorithm v12 = &kSecECPrivateKeyDescriptor;
  }

  else
  {
    if (!DEROidCompare((uint64_t)&oidRsa, (uint64_t)v19))
    {
      unint64_t v15 = 0LL;
      CFArrayRef v17 = 0LL;
      SecPolicyRef BasicX509 = 0LL;
      unsigned int v13 = 0LL;
      CFTypeID v8 = 0LL;
      unint64_t Value = 0LL;
LABEL_16:
      **(_DWORD **)(a3 + 24) = 1;
      goto LABEL_17;
    }

    uint64_t BytePtr = CFDataGetBytePtr(Value);
    CFIndex Length = CFDataGetLength(Value);
    CCHmacAlgorithm v12 = &kSecRSAPrivateKeyDescriptor;
  }

  unint64_t Value = (const __CFData *)SecKeyCreate((uint64_t)v5, (uint64_t)v12, (uint64_t)BytePtr, Length, 1LL);
  if (!Value)
  {
LABEL_34:
    unint64_t v15 = 0LL;
    CFArrayRef v17 = 0LL;
    SecPolicyRef BasicX509 = 0LL;
    unsigned int v13 = 0LL;
    CFTypeID v8 = 0LL;
    goto LABEL_17;
  }

  CFTypeID v8 = SecCertificateCreateWithData(v5, v8);
  if (!v8)
  {
    unint64_t v15 = 0LL;
    CFArrayRef v17 = 0LL;
    SecPolicyRef BasicX509 = 0LL;
    unsigned int v13 = 0LL;
    goto LABEL_16;
  }

  unsigned int v13 = (const void *)SecIdentityCreate((int)v5, v8, Value);
  if (!v13)
  {
    unint64_t v15 = 0LL;
    CFArrayRef v17 = 0LL;
    SecPolicyRef BasicX509 = 0LL;
    goto LABEL_16;
  }

  CFDictionarySetValue(Mutable, @"identity", v13);
  CC_LONG v14 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  unint64_t v15 = v14;
  if (v14)
  {
    CFArrayAppendValue(v14, v8);
    v21.CFIndex length = CFArrayGetCount(*(CFArrayRef *)(a3 + 16));
    v21.location = 0LL;
    CFArrayAppendArray(v15, *(CFArrayRef *)(a3 + 16), v21);
    SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
    if (BasicX509 && (int v18 = -1431655766, SecTrustCreateWithCertificates(v15, BasicX509, &trust), trust))
    {
      SecTrustEvaluateInternal(trust, &v18);
      CFDictionarySetValue(Mutable, @"trust", trust);
      CFArrayRef v17 = SecTrustCopyCertificateChain(trust);
      if (v17)
      {
        CFDictionarySetValue(Mutable, @"chain", v17);
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, Mutable);
      }
    }

    else
    {
      CFArrayRef v17 = 0LL;
    }
  }

  else
  {
    CFArrayRef v17 = 0LL;
    SecPolicyRef BasicX509 = 0LL;
  }

uint64_t __SecPKCS12ImportToModernKeychain_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(const __CFDictionary **)(a1 + 40);
  CFTypeID v5 = CFGetTypeID(cf);
  uint64_t result = CFDictionaryGetTypeID();
  if (v5 == result)
  {
    if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"identity"))
    {
      int v11 = 0;
LABEL_17:
      uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)cf, @"chain");
      if (!(_DWORD)result)
      {
LABEL_35:
        if (!v11) {
          return result;
        }
        goto LABEL_36;
      }

      uint64_t result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)cf, @"chain");
      if (result)
      {
        unint64_t v15 = (const __CFArray *)result;
        CFTypeID v16 = CFGetTypeID((CFTypeRef)result);
        uint64_t result = CFArrayGetTypeID();
        if (v16 == result)
        {
          unsigned int v17 = 0;
          int v18 = (const void *)*MEMORY[0x189604DE8];
          while (1)
          {
            uint64_t result = CFArrayGetCount(v15);
            if (result <= v17) {
              goto LABEL_35;
            }
            unsigned int v19 = v17;
            ValueAtIndex = CFArrayGetValueAtIndex(v15, v17);
            CFRange v21 = secItemOptionsFromPKCS12Options(v4);
            CFDictionaryAddValue(v21, @"nleg", v18);
            CFDictionaryAddValue(v21, @"class", @"cert");
            CFDictionaryAddValue(v21, @"v_Ref", ValueAtIndex);
            OSStatus v22 = SecItemAdd(v21, 0LL);
            if (v22 == -25299) {
              break;
            }
            int v11 = v22;
            if (!v22)
            {
              uint64_t v23 = (os_log_s *)secLogObjForScope("p12Decode");
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_31;
              }
              *(_WORD *)__int128 buf = 0;
              CFIndex v24 = v23;
              unint64_t v25 = "cert added to keychain";
LABEL_28:
              _os_log_impl(&dword_1804F4000, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
              int v11 = 0;
              goto LABEL_31;
            }

            uint64_t v27 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              int v29 = v11;
              _os_log_impl( &dword_1804F4000,  v27,  OS_LOG_TYPE_DEFAULT,  "p12Decode: Error %d adding identity to keychain",  buf,  8u);
            }

uint64_t apply_block_1_8757(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__CFDictionary *secItemOptionsFromPKCS12Options(CFDictionaryRef theDict)
{
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, theDict);
  CFDictionaryRemoveValue(MutableCopy, @"passphrase");
  CFDictionaryRemoveValue(MutableCopy, @"memory");
  return MutableCopy;
}

uint64_t osstatus_for_kern_return(uint64_t a1)
{
  char v1 = a1 + 63;
  if (((1LL << v1) & 0x20000000DLL) != 0) {
    return 4294941988LL;
  }
  if (((1LL << v1) & 0x6000) != 0) {
    return 4294942003LL;
  }
  if (a1 == -536870206) {
    return 4294967246LL;
  }
LABEL_8:
  if (a1) {
    unsigned int v3 = -25291;
  }
  else {
    unsigned int v3 = 0;
  }
  if (a1 == -536870212) {
    return 4294941021LL;
  }
  else {
    return v3;
  }
}

const void *SecCopyLastError(int a1)
{
  if (getLastErrorKey_onceToken != -1) {
    dispatch_once(&getLastErrorKey_onceToken, &__block_literal_global_81);
  }
  if (getLastErrorKey_haveKey != 1) {
    return 0LL;
  }
  CFHashCode v2 = pthread_getspecific(getLastErrorKey_key);
  unsigned int v3 = v2;
  if (v2)
  {
    if (!a1 || SecErrorGetOSStatus((uint64_t)v2) == a1)
    {
      CFRetain(v3);
      return v3;
    }

    return 0LL;
  }

  return v3;
}

uint64_t __getLastErrorKey_block_invoke()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&getLastErrorKey_key, (void (__cdecl *)(void *))lastErrorReleaseError);
  if (!(_DWORD)result) {
    getLastErrorKey_haveKey = 1;
  }
  return result;
}

CFDataRef _SecItemCreatePersistentRef(CFStringRef theString, unint64_t a2, const __CFDictionary *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a3 && (TokenPersistentRefData = CreateTokenPersistentRefData(theString, a3)) != 0LL)
  {
    SecCertificateRef v6 = TokenPersistentRefData;
    SecCertificateRef v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex Length = CFDataGetLength(TokenPersistentRefData);
    CFMutableArrayRef Mutable = CFDataCreateMutable(v7, Length + 4);
    CFDataAppendBytes(Mutable, (const UInt8 *)"tkpr", 4LL);
    uint64_t BytePtr = CFDataGetBytePtr(v6);
    CFIndex v11 = CFDataGetLength(v6);
    CFDataAppendBytes(Mutable, BytePtr, v11);
    CFRelease(v6);
  }

  else
  {
    if ((a2 & 0x8000000000000000LL) != 0) {
      return 0LL;
    }
    memset(buffer, 170, 12);
    if (!CFStringGetCString(theString, buffer, 5LL, 0x8000100u))
    {
      return 0LL;
    }

    else
    {
      *(void *)&buffer[4] = bswap64(a2);
      return CFDataCreate(0LL, (const UInt8 *)buffer, 12LL);
    }
  }

  return Mutable;
}

__CFData *CreateTokenPersistentRefData(const void *a1, CFDictionaryRef theDict)
{
  if (CFDictionaryGetValue(theDict, @"toid"))
  {
    unint64_t Value = CFDictionaryGetValue(theDict, @"tkid");
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      unsigned int v13 = 0LL;
      DERData = 0LL;
      if (v5 != CFStringGetTypeID()) {
        return DERData;
      }
      goto LABEL_4;
    }

    return 0LL;
  }

  if (CFEqual(a1, @"idnt"))
  {
    CFRange v21 = CFDictionaryGetValue(theDict, @"certtkid");
    if (!v21) {
      return 0LL;
    }
    CFTypeID v22 = CFGetTypeID(v21);
    if (v22 != CFStringGetTypeID()) {
      return 0LL;
    }
    uint64_t v23 = @"certdata";
  }

  else
  {
    CFIndex v24 = CFDictionaryGetValue(theDict, @"tkid");
    if (!v24) {
      return 0LL;
    }
    CFTypeID v25 = CFGetTypeID(v24);
    if (v25 != CFStringGetTypeID()) {
      return 0LL;
    }
    uint64_t v23 = @"v_Data";
  }

  uint64_t v26 = CFDictionaryGetValue(theDict, v23);
  if (!v26) {
    return 0LL;
  }
  uint64_t v27 = v26;
  CFTypeID v28 = CFGetTypeID(v26);
  if (v28 != CFDataGetTypeID()) {
    return 0LL;
  }
  int v29 = SecTokenItemValueCopy(v27, 0LL);
  if (!v29) {
    return 0LL;
  }
  unsigned int v13 = v29;
  uint64_t v30 = CFDictionaryGetValue(v29, @"oid");
  if (!v30 || (CFTypeID v31 = CFGetTypeID(v30), v31 != CFDataGetTypeID()))
  {
    DERData = 0LL;
    goto LABEL_5;
  }

CFDictionaryRef SecTokenItemValueCopy(const void *a1, CFTypeRef *a2)
{
  CFDictionaryRef theDict = 0LL;
  if (!a1) {
    goto LABEL_13;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID()) {
    goto LABEL_13;
  }
  uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  uint64_t v7 = &BytePtr[Length];
  uint64_t v11 = der_decode_plist(0LL, (uint64_t)&theDict, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v8, v9, v10);
  if (!v11)
  {
LABEL_14:
    uint64_t v12 = 0LL;
    goto LABEL_15;
  }

  if ((const UInt8 *)v11 != v7)
  {
    SecError(-26275, (__CFString **)a2, @"trailing garbage at end of token data field");
    goto LABEL_14;
  }

  uint64_t v12 = theDict;
  unint64_t Value = CFDictionaryGetValue(theDict, @"oid");
  if (!Value || (CFTypeID v14 = CFGetTypeID(Value), v14 != CFDataGetTypeID()))
  {
    SecError(-26276, (__CFString **)a2, @"token based item data does not have OID");
    goto LABEL_14;
  }

  if ((v15 = CFDictionaryGetValue(v12, @"ac")) != 0LL && (CFTypeID v16 = CFGetTypeID(v15), v16 != CFDataGetTypeID())
    || (uint64_t v17 = CFDictionaryGetValue(v12, @"data")) != 0LL && (v18 = CFGetTypeID(v17), v18 != CFDataGetTypeID()))
  {
LABEL_13:
    SecError(-50, (__CFString **)a2, @"Unexpected type");
    goto LABEL_14;
  }

  if (!v12) {
    return v12;
  }
  CFRetain(v12);
LABEL_15:
  if (theDict) {
    CFRelease(theDict);
  }
  return v12;
}

__CFData *_SecItemCreateUUIDBasedPersistentRef( const __CFString *a1, CFDataRef theData, CFDictionaryRef theDict)
{
  if (theDict)
  {
    TokenPersistentRefData = CreateTokenPersistentRefData(a1, theDict);
    if (TokenPersistentRefData)
    {
      uint64_t v6 = TokenPersistentRefData;
      uint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex Length = CFDataGetLength(TokenPersistentRefData);
      CFMutableArrayRef Mutable = CFDataCreateMutable(v7, Length + 4);
      CFDataAppendBytes(Mutable, (const UInt8 *)"tkpr", 4LL);
      uint64_t BytePtr = CFDataGetBytePtr(v6);
      CFIndex v11 = CFDataGetLength(v6);
      CFDataAppendBytes(Mutable, BytePtr, v11);
LABEL_14:
      CFRelease(v6);
      return Mutable;
    }
  }

  if (!theData) {
    return 0LL;
  }
  CFIndex v12 = CFDataGetLength(theData);
  CFMutableArrayRef Mutable = 0LL;
  if (!a1 || v12 != 16) {
    return Mutable;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (v13 != CFStringGetTypeID() || CFStringGetLength(a1) < 1) {
    return 0LL;
  }
  CFTypeID v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v6 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFTypeID v15 = CFGetTypeID(a1);
  CFMutableArrayRef Mutable = 0LL;
  if (v15 == CFStringGetTypeID())
  {
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    void v23[2] = ___SecItemCreateUUIDBasedPersistentRef_block_invoke;
    void v23[3] = &__block_descriptor_40_e19_v16__0____CFData__8l;
    v23[4] = v6;
    CFIndex maxBufLen = 0LL;
    CFIndex v16 = CFStringGetLength(a1);
    v26.location = 0LL;
    v26.CFIndex length = v16;
    CFStringGetBytes(a1, v26, 0x8000100u, 0, 0, 0LL, 0LL, &maxBufLen);
    CFIndex v17 = maxBufLen;
    CFTypeID v18 = CFDataCreateMutable(v14, 0LL);
    CFDataSetLength(v18, v17);
    CFIndex usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(v18);
    v27.location = 0LL;
    v27.CFIndex length = v16;
    CFStringGetBytes(a1, v27, 0x8000100u, 0, 0, MutableBytePtr, maxBufLen, &usedBufLen);
    ___SecItemCreateUUIDBasedPersistentRef_block_invoke((uint64_t)v23, v18);
    if (v18) {
      CFRelease(v18);
    }
    uint64_t v20 = CFDataGetBytePtr(theData);
    CFIndex v21 = CFDataGetLength(theData);
    CFDataAppendBytes(v6, v20, v21);
    CFMutableArrayRef Mutable = CFDataCreateCopy(v14, v6);
  }

  if (v6) {
    goto LABEL_14;
  }
  return Mutable;
}

BOOL _SecItemParsePersistentRef( const void *a1, void *a2, void *a3, const void **a4, CFDictionaryRef *a5)
{
  CFTypeID v10 = CFGetTypeID(a1);
  if (v10 != CFDataGetTypeID()) {
    return 0LL;
  }
  if (CFDataGetLength((CFDataRef)a1) < 5 || *(_DWORD *)CFDataGetBytePtr((CFDataRef)a1) != 1919970164)
  {
    if (CFDataGetLength((CFDataRef)a1) == 12)
    {
      uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      unint64_t v12 = *(void *)(BytePtr + 4);
      CFTypeID v13 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex Length = CFStringGetLength(@"genp");
      CFStringRef v15 = CFStringCreateWithBytes(v13, BytePtr, Length, 0x8000100u, 1u);
      if (v15)
      {
        CFIndex v16 = (const __CFArray *)v15;
        BOOL valid = isValidClass(v15, a2);
        BOOL v18 = valid;
        if (a3 && valid) {
          *a3 = bswap64(v12);
        }
        goto LABEL_31;
      }
    }

    else if (SecKeychainIsStaticPersistentRefsEnabled() && CFDataGetLength((CFDataRef)a1) == 20)
    {
      uint64_t v19 = CFDataGetBytePtr((CFDataRef)a1);
      uint64_t v20 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex v21 = CFStringGetLength(@"genp");
      CFStringRef v22 = CFStringCreateWithBytes(v20, v19, v21, 0x8000100u, 1u);
      if (v22)
      {
        uint64_t v23 = v22;
        BOOL v24 = isValidClass(v22, a2);
        BOOL v18 = v24;
        if (a4 && v24)
        {
          CFIndex v25 = CFStringGetLength(v23);
          CFIndex v26 = CFDataGetLength((CFDataRef)a1);
          CFIndex v27 = CFStringGetLength(v23);
          CFDataRef v28 = CFDataCreateWithBytesNoCopy(v20, &v19[v25], v26 - v27, (CFAllocatorRef)*MEMORY[0x189604DC8]);
          int v29 = *a4;
          if (*a4 != v28)
          {
            if (!v28 || (CFRetain(v28), (int v29 = *a4) != 0LL)) {
              CFRelease(v29);
            }
            *a4 = v28;
          }

          if (v28) {
            CFRelease(v28);
          }
        }

        uint64_t v30 = v23;
        goto LABEL_32;
      }
    }

    return 0LL;
  }

  CFTypeRef cf = 0LL;
  CFTypeID v31 = CFDataGetBytePtr((CFDataRef)a1);
  uint64_t v32 = (uint64_t)&v31[CFDataGetLength((CFDataRef)a1)];
  uint64_t v36 = der_decode_plist(0LL, (uint64_t)&cf, 0LL, (uint64_t)(v31 + 4), v32, v33, v34, v35);
  BOOL v18 = 0LL;
  CFIndex v16 = (const __CFArray *)cf;
  if (v36 && v36 == v32)
  {
    CFTypeID v37 = CFGetTypeID(cf);
    if (v37 != CFArrayGetTypeID() || CFArrayGetCount(v16) != 3)
    {
      BOOL v18 = 0LL;
      if (!v16) {
        return v18;
      }
      goto LABEL_31;
    }

    ValueAtIndex = CFArrayGetValueAtIndex(v16, 0LL);
    BOOL v39 = isValidClass(ValueAtIndex, a2);
    BOOL v18 = v39;
    if (a5 && v39)
    {
      __int128 v40 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      BOOL v18 = 1LL;
      CFTypeID v41 = CFArrayGetValueAtIndex(v16, 1LL);
      CFArrayGetValueAtIndex(v16, 2LL);
      *a5 = CFDictionaryCreateForCFTypes(v40, v42, v43, v44, v45, v46, v47, v48, (uint64_t)@"tkid", (uint64_t)v41);
    }
  }

  if (v16)
  {
LABEL_31:
    uint64_t v30 = v16;
LABEL_32:
    CFRelease(v30);
  }

  return v18;
}

BOOL isValidClass(CFTypeRef cf2, void *a2)
{
  unint64_t v4 = 0LL;
  v8[6] = *MEMORY[0x1895F89C0];
  v8[0] = @"genp";
  v8[1] = @"inet";
  unint64_t v8[2] = @"apls";
  unint64_t v8[3] = @"cert";
  void v8[4] = @"keys";
  void v8[5] = @"idnt";
  BOOL v5 = 1;
  while (1)
  {
    if (cf2)
    {
      uint64_t v6 = v8[v4];
      if (v6)
      {
        if (CFEqual((CFTypeRef)v8[v4], cf2)) {
          break;
        }
      }
    }

    BOOL v5 = v4++ < 5;
    if (v4 == 6) {
      return 0;
    }
  }

  if (a2) {
    *a2 = v6;
  }
  return v5;
}

uint64_t apply_block_2_8844(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  unint64_t v4 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v19 = 0LL;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x3010000000LL;
  CFStringRef v22 = &unk_18069119A;
  CFDictionaryRef v23 = attributes;
  uint64_t v24 = 0LL;
  int v18 = -1431655766;
  BOOL v5 = _os_activity_create(&dword_1804F4000, "SecItemAdd_ios", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  if ((explode_identity(v20[4], SecItemAdd, &v18, result) & 1) == 0)
  {
    uint64_t v6 = (CFDictionaryRef *)(v20 + 4);
    if (!CFDictionaryContainsKey((CFDictionaryRef)v20[4], @"labl"))
    {
      unint64_t Value = (__SecCertificate *)CFDictionaryGetValue(*v6, @"v_Ref");
      CFIndex v11 = Value;
      if (Value)
      {
        CFTypeID v12 = CFGetTypeID(Value);
        if (v12 == SecCertificateGetTypeID())
        {
          CFStringRef v13 = SecCertificateCopySubjectSummary(v11);
          if (v13)
          {
            CFStringRef v14 = v13;
            CFStringRef v15 = SecCFDictionaryCOWGetMutable(v6);
            CFDictionarySetValue(v15, @"labl", v14);
            CFRelease(v14);
          }
        }
      }
    }

    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    void v16[2] = __SecItemAdd_block_invoke;
    unint64_t v16[3] = &unk_1896702A0;
    v16[4] = &v19;
    v16[5] = result;
    int v18 = SecOSStatusWith((uint64_t)v16);
  }

  uint64_t v7 = (const void *)v20[5];
  if (v7) {
    CFRelease(v7);
  }
  OSStatus v8 = v18;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v19, 8);
  objc_autoreleasePoolPop(v4);
  return v8;
}

void sub_1805C6228( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, uint64_t a17, char a18)
{
}

BOOL __SecItemAdd_block_invoke(uint64_t a1, __CFString **a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unsigned int v3 = (CFDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 32LL);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = __SecItemAdd_block_invoke_2;
  v5[3] = &__block_descriptor_40_e105_B48__0__TKClientTokenSession_8____CFDictionary__16____CFDictionary__24____CFDictionary__32_____CFError_40l;
  void v5[4] = v2;
  return SecItemAuthDoQuery(v3, 0LL, SecItemAdd, a2, v5);
}

uint64_t __SecItemAdd_block_invoke_2( uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4, const __CFDictionary *a5, CFErrorRef *a6)
{
  id v10 = a2;
  CFIndex v11 = v10;
  if (v10)
  {
    CFTypeID v12 = *(CFTypeRef **)(a1 + 32);
    id v13 = v10;
    CFTypeRef cf = 0LL;
    CFTypeRef v32 = 0LL;
    CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a3);
    CFDictionarySetValue(MutableCopy, @"pdmn", @"dk");
    unint64_t Value = CFDictionaryGetValue(MutableCopy, @"toid");
    if (Value)
    {
      CFIndex v16 = Value;
      CFRetain(Value);
      CFDictionaryRemoveValue(MutableCopy, @"toid");
      CFIndex v17 = SecTokenCopyUpdatedObjectID(v13, (uint64_t)v16, MutableCopy, a6);
      CFRelease(v16);
      if (v17) {
        goto LABEL_4;
      }
    }

    else
    {
      CFDictionaryRemoveValue(MutableCopy, @"toid");
      CFIndex v17 = SecTokenCopyUpdatedObjectID(v13, 0LL, MutableCopy, a6);
      if (v17)
      {
LABEL_4:
        CFDictionaryRemoveValue(MutableCopy, @"toid");
        if (CFDictionaryContainsKey(MutableCopy, @"v_Ref"))
        {
          CFDictionaryRemoveValue(MutableCopy, @"v_Ref");
        }

        else
        {
          if (!SecTokenItemCreateFromAttributes( MutableCopy,  a5,  v13,  v17,  (uint64_t *)&v32,  (__CFString **)a6))
          {
            int v18 = 0LL;
            goto LABEL_47;
          }

          if (v32)
          {
            CFDataRef v28 = SecItemCopyAttributeDictionary(v32, 0);
            int v18 = v28;
            if (v28)
            {
              context[0] = (const void *)MEMORY[0x1895F87A8];
              context[1] = (const void *)3221225472LL;
              context[2] = __SecTokenItemAdd_block_invoke;
              context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
              void context[4] = MutableCopy;
              CFDictionaryApplyFunction(v28, (CFDictionaryApplierFunction)apply_block_2_8844, context);
            }

            goto LABEL_7;
          }
        }

        int v18 = 0LL;
LABEL_7:
        uint64_t v19 = (const void *)*MEMORY[0x189604DE8];
        CFDictionarySetValue(MutableCopy, @"r_Attributes", (const void *)*MEMORY[0x189604DE8]);
        CFDictionarySetValue(MutableCopy, @"r_Data", v19);
        uint64_t v20 = CFDictionaryGetValue(MutableCopy, @"perm");
        uint64_t v21 = (const void *)*MEMORY[0x189604DE0];
        if (v20 && v21)
        {
          if (CFEqual(v20, v21))
          {
LABEL_10:
            CFTypeRef cf = CFRetain(MutableCopy);
LABEL_32:
            uint64_t v24 = SecItemResultProcess(a3, a5, v13, cf, v12, (__CFString **)a6);
LABEL_33:
            CFIndex v27 = v17;
            goto LABEL_34;
          }
        }

        else if (v20 == v21)
        {
          goto LABEL_10;
        }

        if (gSecurityd
          && (CFIndex v25 = *(uint64_t (**)(__CFDictionary *, uint64_t, CFTypeRef *, CFErrorRef *))gSecurityd) != 0LL)
        {
          uint64_t v26 = SecSecurityClientGet();
          if ((v25(MutableCopy, v26, &cf, a6) & 1) != 0) {
            goto LABEL_32;
          }
        }

        else
        {
          SecSecurityClientGet();
          uint64_t v38 = MEMORY[0x1895F87A8];
          uint64_t v39 = 3221225472LL;
          __int128 v40 = __cftype_to_BOOL_cftype_error_request_block_invoke;
          CFTypeID v41 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
          int v42 = MutableCopy;
          uint64_t v33 = MEMORY[0x1895F87A8];
          uint64_t v34 = 3221225472LL;
          uint64_t v35 = __cftype_to_BOOL_cftype_error_request_block_invoke_2;
          uint64_t v36 = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
          p_CFTypeRef cf = &cf;
        }

uint64_t __Block_byref_object_copy__8849(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__8850(uint64_t a1)
{
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  unint64_t v4 = (void *)MEMORY[0x186DFF9D0]();
  BOOL v5 = _os_activity_create(&dword_1804F4000, "SecItemUpdate_ios", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  void v7[2] = __SecItemUpdate_block_invoke;
  unint64_t v7[3] = &__block_descriptor_48_e20_B16__0_____CFError_8l;
  void v7[4] = query;
  unint64_t v7[5] = attributesToUpdate;
  LODWORD(attributesToUpdate) = SecOSStatusWith((uint64_t)v7);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v4);
  return (int)attributesToUpdate;
}

void sub_1805C67F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  keys[2] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v16 = 0LL;
  CFIndex v17 = &v16;
  uint64_t v18 = 0x3010000000LL;
  uint64_t v19 = &unk_18069119A;
  CFDictionaryRef v20 = query;
  uint64_t v21 = 0LL;
  unsigned int v3 = _os_activity_create(&dword_1804F4000, "SecItemDelete_ios", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  unint64_t v4 = (const __CFDictionary **)(v17 + 4);
  unint64_t Value = (void *)CFDictionaryGetValue((CFDictionaryRef)v17[4], @"v_PersistentRef");
  uint64_t v6 = Value;
  CFTypeRef v24 = 0LL;
  if (Value && _SecItemParsePersistentRef(Value, &v24, 0LL, 0LL, 0LL) && CFEqual(v24, @"idnt"))
  {
    keys[0] = @"r_Ref";
    keys[1] = @"v_PersistentRef";
    values[0] = *(void **)MEMORY[0x189604DE8];
    values[1] = v6;
    uint64_t v7 = CFDictionaryCreate(0LL, (const void **)keys, (const void **)values, 2LL, 0LL, 0LL);
    CFTypeRef result = 0LL;
    OSStatus v8 = SecItemCopyMatching(v7, &result);
    if (v7) {
      CFRelease(v7);
    }
    if (v8) {
      goto LABEL_7;
    }
    if (!result)
    {
      OSStatus v8 = -25300;
LABEL_7:
      OSStatus v22 = v8;
      goto LABEL_12;
    }

    uint64_t v9 = SecCFDictionaryCOWGetMutable(v4);
    CFDictionaryRemoveValue(v9, @"v_PersistentRef");
    id v10 = SecCFDictionaryCOWGetMutable(v4);
    CFDictionarySetValue(v10, @"v_Ref", result);
    CFRelease(result);
  }

  OSStatus v22 = 0;
  if ((explode_identity(v17[4], SecItemDelete, &v22, 0LL) & 1) == 0)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    void v14[2] = __SecItemDelete_block_invoke;
    unint64_t v14[3] = &unk_189670408;
    v14[4] = &v16;
    OSStatus v22 = SecOSStatusWith((uint64_t)v14);
  }

void sub_1805C6A5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, char a16)
{
}

uint64_t SecItemShareWithGroup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v14 = 0LL;
  CFStringRef v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  uint64_t v17 = 0LL;
  uint64_t v12 = a1;
  CFTypeRef cf = 0LL;
  uint64_t v7 = _os_activity_create(&dword_1804F4000, "SecItemShareWithGroup", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __SecItemShareWithGroup_block_invoke;
  unint64_t v10[3] = &unk_1896702F0;
  void v10[4] = &v14;
  void v10[5] = a2;
  SecItemAuthDoQuery(&v12, 0LL, SecItemShareWithGroup, a3, v10);
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v8 = v15[3];
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v14, 8);
  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_1805C6BA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, uint64_t a16, uint64_t a17, char a18)
{
}

void SecItemAuthMaxAttemptsReached(const __CFArray *a1, __CFString **a2)
{
  unsigned int v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0LL; i != v6; ++i)
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a1, i);
      uint64_t v9 = (const __CFData *)CFArrayGetValueAtIndex(ValueAtIndex, 0LL);
      CFIndex Length = CFDataGetLength(v9);
      CFIndex v11 = CFStringCreateMutable(v3, 2 * Length);
      uint64_t BytePtr = CFDataGetBytePtr(v9);
      CFIndex v13 = CFDataGetLength(v9);
      if (v13 >= 1)
      {
        CFIndex v14 = v13;
        do
        {
          unsigned int v15 = *BytePtr++;
          CFStringAppendFormat(v11, 0LL, @"%02X", v15);
          --v14;
        }

        while (v14);
      }

      uint64_t v16 = CFArrayGetValueAtIndex(ValueAtIndex, 1LL);
      uint64_t v17 = CFStringCreateWithFormat(v3, 0LL, @"operation: %@ acl:%@\n", v16, v11);
      CFStringAppend(Mutable, v17);
      CFRelease(v11);
      CFRelease(v17);
    }
  }

  uint64_t v18 = (__CFString *)CFStringCreateWithFormat( v3,  0LL,  @"Reached maximum count of authentication attempts\n %@",  Mutable);
  SecError(-25293, a2, @"%@", v18);
  __security_simulatecrash(v18, 0x53C00006u);
  CFRelease(v18);
  CFRelease(Mutable);
}

id SecTokenSessionCreate(CFStringRef theString, const __CFDictionary **a2, __CFString **a3)
{
  v22[1] = *MEMORY[0x1895F89C0];
  if ((!*a2 || !CFDictionaryGetValue(*a2, @"u_CredRef"))
    && !CFStringHasPrefix(theString, @"com.apple.setoken"))
  {
    if (SecTokenSessionCreate_onceToken != -1) {
      dispatch_once(&SecTokenSessionCreate_onceToken, &__block_literal_global_130);
    }
    os_unfair_lock_lock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
    unint64_t Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value) {
      goto LABEL_7;
    }
    if (!LocalAuthenticationLibraryCore())
    {
      SecError(-26276, a3, @"LocalAuthentication is not available");
      return 0LL;
    }

    id v18 = objc_alloc_init((Class)getLAContextClass());
    if (!v18)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
      SecError(-26276, a3, @"Failed to create authentication context");
      return 0LL;
    }

    uint64_t v19 = v18;
    CFDictionarySetValue((CFMutableDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString, v18);
    CFRelease(v19);
    unint64_t Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value)
    {
LABEL_7:
      [Value externalizedContext];
      uint64_t v7 = (const void *)objc_claimAutoreleasedReturnValue();
      if (v7)
      {
        uint64_t v8 = SecCFDictionaryCOWGetMutable(a2);
        CFDictionarySetValue(v8, @"u_AuthCtx", Value);
        uint64_t v9 = SecCFDictionaryCOWGetMutable(a2);
        CFDictionarySetValue(v9, @"u_CredRef", v7);
        CFRelease(v7);
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
  }

  -[__CFDictionary objectForKey:](*a2, "objectForKey:", @"u_AuthCtx");
  id v10 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v10)
  {
    -[__CFDictionary objectForKey:](*a2, "objectForKey:", @"u_CredRef");
    CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v11)
    {
      id v10 = 0LL;
      goto LABEL_15;
    }

    if (LocalAuthenticationLibraryCore())
    {
      id v10 = (void *)[objc_alloc((Class)getLAContextClass()) initWithExternalizedContext:v11];
LABEL_15:

      goto LABEL_16;
    }

    SecError(-26276, a3, @"LocalAuthentication is not available");

    return 0LL;
  }

CFMutableDictionaryRef __SecTokenSessionCreate_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  SecTokenSessionCreate_sharedLAContexts = (uint64_t)result;
  return result;
}

CFDictionaryRef SecItemCopyAttributeDictionary(void *a1, int a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != SecKeyGetTypeID())
  {
    if (v4 == SecCertificateGetTypeID()) {
      return SecCertificateCopyAttributeDictionary((uint64_t)a1);
    }
    if (v4 != SecIdentityGetTypeID()) {
      return 0LL;
    }
    __security_simulatecrash(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    id v10 = (void *)a1[2];
    CFRetain(v10);
    CFIndex v6 = (const __CFDictionary *)a1[3];
    CFRetain(v6);
    CFDataRef v11 = SecCertificateCopyData((SecCertificateRef)v10);
    uint64_t v12 = SecKeyCopyAttributes(v6);
    CFIndex v13 = v12;
    if (v12 && v11)
    {
      CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v12);
      CFDictionarySetValue(MutableCopy, @"certdata", v11);
    }

    else
    {
      CFMutableStringRef MutableCopy = 0LL;
      uint64_t v8 = 0LL;
      if (!v12) {
        goto LABEL_16;
      }
    }

    CFRelease(v13);
    uint64_t v8 = MutableCopy;
LABEL_16:
    if (v11) {
      CFRelease(v11);
    }
    if (v10) {
      CFRelease(v10);
    }
    if (!v6) {
      return v8;
    }
    goto LABEL_21;
  }

  BOOL v5 = SecKeyCopyAttributes((SecKeyRef)a1);
  CFIndex v6 = v5;
  if (v5 && a2)
  {
    uint64_t v7 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v5);
    uint64_t v8 = v7;
    if (v7)
    {
      CFDictionaryRemoveValue(v7, @"sign");
      CFDictionaryRemoveValue(v8, @"vrfy");
      CFDictionaryRemoveValue(v8, @"encr");
      CFDictionaryRemoveValue(v8, @"decr");
      CFDictionaryRemoveValue(v8, @"drve");
      CFDictionaryRemoveValue(v8, @"wrap");
      CFDictionaryRemoveValue(v8, @"unwp");
      CFDictionaryRemoveValue(v8, @"snrc");
      CFDictionaryRemoveValue(v8, @"vyrc");
      CFDictionaryRemoveValue(v8, @"perm");
    }

void __SecItemAttributesPrepare_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  BOOL v5 = SecCFDictionaryCOWGetMutable(*(const __CFDictionary ***)(a1 + 32));
  CFDictionaryAddValue(v5, a2, a3);
}

uint64_t __SecItemShareWithGroup_block_invoke( uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4, const __CFDictionary *a5, CFTypeRef *a6)
{
  id v10 = a2;
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash( @"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit",  0x53C0000Fu);
  }
  if (!v10)
  {
    if (gSecurityd
      && (uint64_t v12 = *(uint64_t (**)(const __CFDictionary *, uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 96)) != 0LL)
    {
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v14 = SecSecurityClientGet();
      unsigned int v15 = (const void *)v12(a3, v13, v14, a6);
      if (!v15)
      {
LABEL_8:
        uint64_t v11 = 0LL;
        goto LABEL_11;
      }
    }

    else
    {
      uint64_t v16 = *(void *)(a1 + 40);
      SecSecurityClientGet();
      uint64_t v20 = 0LL;
      uint64_t v21 = &v20;
      uint64_t v22 = 0x2020000000LL;
      uint64_t v23 = 0LL;
      v18[4] = &v20;
      v19[0] = MEMORY[0x1895F87A8];
      v19[1] = 3221225472LL;
      void v19[2] = __share_with_group_request_block_invoke;
      unint64_t v19[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
      v19[4] = a3;
      v19[5] = v16;
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 3221225472LL;
      unint64_t v18[2] = __share_with_group_request_block_invoke_2;
      void v18[3] = &unk_1896702C8;
      securityd_send_sync_and_do(0x83u, a6, (uint64_t)v19, (uint64_t)v18);
      unsigned int v15 = (const void *)v21[3];
      _Block_object_dispose(&v20, 8);
      if (!v15) {
        goto LABEL_8;
      }
    }

    uint64_t v11 = SecItemResultProcess( a3,  a5,  0LL,  v15,  (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  (__CFString **)a6);
    CFRelease(v15);
    goto LABEL_11;
  }

  uint64_t v11 = SecError(-50, (__CFString **)a6, @"Can't share token-protected items");
LABEL_11:

  return v11;
}

BOOL __share_with_group_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  if (SecXPCDictionarySetPListWithRepair( v5,  "query",  *(const __CFString **)(a1 + 32),  a3,  v6,  v7,  v8,  v9)) {
    BOOL v10 = SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"sharingGroup", *(const __CFString **)(a1 + 40), a3);
  }
  else {
    BOOL v10 = 0LL;
  }

  return v10;
}

BOOL __share_with_group_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyPListOptional(a2, (void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a3);
}

uint64_t SecTokenItemCreateFromAttributes( const __CFDictionary *a1, const __CFDictionary *a2, void *a3, const void *a4, uint64_t *a5, __CFString **a6)
{
  id v11 = a3;
  int v29 = a2;
  CFTypeRef cf = 0LL;
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a1);
  unint64_t Value = (const __CFString *)CFDictionaryGetValue(a1, @"tkid");
  if (!a4) {
    goto LABEL_10;
  }
  uint64_t v14 = Value;
  if (!Value) {
    goto LABEL_10;
  }
  CFTypeID v15 = CFGetTypeID(Value);
  if (v15 != CFStringGetTypeID())
  {
    SecError(-50, a6, @"Unexpected type");
    uint64_t v20 = 0LL;
LABEL_17:

    if (!MutableCopy) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v11)
  {
LABEL_7:
    if (a2)
    {
      context[0] = MEMORY[0x1895F87A8];
      context[1] = 3221225472LL;
      context[2] = __SecTokenItemCreateFromAttributes_block_invoke;
      context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
      void context[4] = MutableCopy;
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2_8844, context);
    }

    CFDictionarySetValue(MutableCopy, @"u_TokenSession", v11);
    CFDictionarySetValue(MutableCopy, @"toid", a4);
LABEL_10:
    uint64_t v17 = CFDictionaryGetValue(MutableCopy, @"class");
    if (CFEqual(v17, @"keys"))
    {
      SecKeyRef v18 = SecKeyCreateFromAttributeDictionary(MutableCopy);
LABEL_14:
      uint64_t v19 = (uint64_t)v18;
LABEL_15:
      *a5 = v19;
      uint64_t v20 = 1LL;
      goto LABEL_17;
    }

    if (CFEqual(v17, @"cert"))
    {
      SecKeyRef v18 = SecCertificateCreateFromAttributeDictionary(MutableCopy);
      goto LABEL_14;
    }

    if (!CFEqual(v17, @"idnt"))
    {
      uint64_t v19 = 0LL;
      goto LABEL_15;
    }

    uint64_t v22 = (const __CFData *)CFDictionaryGetValue(MutableCopy, @"certdata");
    uint64_t v23 = *MEMORY[0x189604DB0];
    SecCertificateRef v24 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x189604DB0], v22);
    SecKeyRef v25 = SecKeyCreateFromAttributeDictionary(MutableCopy);
    if (v25 && v24)
    {
      uint64_t v26 = SecIdentityCreate(v23, v24, v25);
    }

    else
    {
      secLogObjForScope("SecError");
      CFIndex v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl(&dword_1804F4000, v27, OS_LOG_TYPE_DEFAULT, "SecItem: failed to create identity", buf, 2u);
      }

      uint64_t v26 = 0LL;
      uint64_t v19 = 0LL;
      if (!v25) {
        goto LABEL_31;
      }
    }

    CFRelease(v25);
    uint64_t v19 = v26;
LABEL_31:
    if (v24) {
      CFRelease(v24);
    }
    goto LABEL_15;
  }

  uint64_t v16 = SecTokenSessionCreate(v14, &v29, a6);
  if (v16)
  {
    id v11 = (id)v16;
    a2 = v29;
    goto LABEL_7;
  }

  uint64_t v20 = 0LL;
  if (MutableCopy) {
LABEL_18:
  }
    CFRelease(MutableCopy);
LABEL_19:
  if (cf) {
    CFRelease(cf);
  }
  return v20;
}

void __SecTokenItemCreateFromAttributes_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t __SecItemDelete_block_invoke(uint64_t a1, uint64_t a2)
{
  return SecItemAuthDoQuery( *(void *)(*(void *)(a1 + 32) + 8LL) + 32LL,  0LL,  SecItemDelete,  a2,  &__block_literal_global_32);
}

uint64_t __SecItemDelete_block_invoke_2( uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  id v8 = a2;
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash( @"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit",  0x53C0000Fu);
  }
  if (v8)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    void v14[2] = __SecItemDelete_block_invoke_3;
    unint64_t v14[3] = &unk_1896703E0;
    id v15 = v8;
    uint64_t v9 = SecTokenItemForEachMatching(a3, a6, v14);
  }

  else
  {
    if (gSecurityd
      && (BOOL v10 = *(uint64_t (**)(const __CFDictionary *, uint64_t, CFTypeRef *))(gSecurityd + 24)) != 0LL)
    {
      uint64_t v11 = SecSecurityClientGet();
      uint64_t v12 = v10(a3, v11, a6);
    }

    else
    {
      SecSecurityClientGet();
      v16[0] = MEMORY[0x1895F87A8];
      v16[1] = 3221225472LL;
      void v16[2] = __dict_to_error_request_block_invoke;
      unint64_t v16[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
      v16[4] = a3;
      uint64_t v12 = securityd_send_sync_and_do(3u, a6, (uint64_t)v16, 0LL);
    }

    uint64_t v9 = v12;
  }

  return v9;
}

size_t __dict_to_error_request_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __SecItemDelete_block_invoke_3(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, CFTypeRef *a4)
{
  unint64_t Value = CFDictionaryGetValue(theDict, @"oid");
  id v8 = *(void **)(a1 + 32);
  id v20 = 0LL;
  char v9 = [v8 deleteObject:Value error:&v20];
  id v10 = v20;
  if ((v9 & 1) != 0) {
    goto LABEL_6;
  }
  if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc())
  {
    [v10 domain];
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    getTKErrorDomain();
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    if ([v11 isEqual:v12])
    {
      uint64_t v13 = [v10 code];

      if (v13 == -6)
      {
LABEL_6:
        if (gSecurityd && (uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 24)) != 0LL)
        {
          uint64_t v15 = SecSecurityClientGet();
          uint64_t v16 = v14(a3, v15, a4);
        }

        else
        {
          SecSecurityClientGet();
          v21[0] = MEMORY[0x1895F87A8];
          v21[1] = 3221225472LL;
          void v21[2] = __dict_to_error_request_block_invoke;
          v21[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
          v21[4] = a3;
          uint64_t v16 = securityd_send_sync_and_do(3u, a4, (uint64_t)v21, 0LL);
        }

        uint64_t v17 = v16;
        goto LABEL_18;
      }
    }

    else
    {
    }
  }

  id v18 = v10;
  if (v18)
  {
    if (a4 && !*a4) {
      *a4 = v18;
    }
    else {
      CFRelease(v18);
    }
  }

  SecTokenProcessError((uint64_t)@"odel", *(void **)(a1 + 32), (uint64_t)Value, (CFErrorRef *)a4);
  uint64_t v17 = 0LL;
LABEL_18:

  return v17;
}

uint64_t SecTokenItemForEachMatching(const __CFDictionary *a1, CFTypeRef *a2, void *a3)
{
  id v5 = a3;
  CFTypeRef cf = 0LL;
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a1);
  if (!CFDictionaryGetValue(MutableCopy, @"m_Limit")) {
    CFDictionarySetValue(MutableCopy, @"m_Limit", @"m_LimitAll");
  }
  uint64_t v7 = (const void *)*MEMORY[0x189604DE8];
  CFDictionarySetValue(MutableCopy, @"r_Data", (const void *)*MEMORY[0x189604DE8]);
  CFDictionarySetValue(MutableCopy, @"r_PersistentRef", v7);
  if (gSecurityd
    && (id v8 = *(uint64_t (**)(__CFDictionary *, uint64_t, CFTypeRef *, CFTypeRef *))(gSecurityd + 8)) != 0LL)
  {
    uint64_t v9 = SecSecurityClientGet();
    if ((v8(MutableCopy, v9, &cf, a2) & 1) == 0) {
      goto LABEL_6;
    }
  }

  else
  {
    SecSecurityClientGet();
    v35[0] = MEMORY[0x1895F87A8];
    v35[1] = 3221225472LL;
    v35[2] = __cftype_to_BOOL_cftype_error_request_block_invoke;
    v35[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    _OWORD v35[4] = MutableCopy;
    v34[0] = MEMORY[0x1895F87A8];
    v34[1] = 3221225472LL;
    v34[2] = __cftype_to_BOOL_cftype_error_request_block_invoke_2;
    v34[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v34[4] = &cf;
    if (!securityd_send_sync_and_do(1u, a2, (uint64_t)v35, (uint64_t)v34))
    {
LABEL_6:
      CFMutableArrayRef Mutable = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      if (!MutableCopy) {
        goto LABEL_29;
      }
LABEL_28:
      CFRelease(MutableCopy);
      goto LABEL_29;
    }
  }

  CFTypeID v13 = CFGetTypeID(cf);
  CFTypeID TypeID = CFArrayGetTypeID();
  uint64_t v22 = cf;
  if (v13 != TypeID)
  {
    uint64_t v22 = CFArrayCreateForCFTypes(0LL, v15, v16, v17, v18, v19, v20, v21, (uint64_t)cf);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = v22;
  }

  CFIndex Count = CFArrayGetCount((CFArrayRef)v22);
  if (Count < 1)
  {
    CFMutableArrayRef Mutable = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v12 = 1LL;
    if (MutableCopy) {
      goto LABEL_28;
    }
  }

  else
  {
    CFIndex v24 = Count;
    CFTypeRef v32 = MutableCopy;
    CFIndex v25 = 0LL;
    uint64_t v26 = 0LL;
    CFIndex v27 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v25);
      unint64_t Value = CFDictionaryGetValue(ValueAtIndex, @"v_Data");
      if (!Value)
      {
        SecError(-26276, (__CFString **)a2, @"value not present for token item");
        uint64_t v12 = 0LL;
        CFMutableArrayRef Mutable = v27;
        uint64_t v11 = v26;
        goto LABEL_27;
      }

      uint64_t v11 = SecTokenItemValueCopy(Value, a2);
      if (v26) {
        CFRelease(v26);
      }
      if (!v11) {
        break;
      }
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      if (v27) {
        CFRelease(v27);
      }
      uint64_t v30 = CFDictionaryGetValue(ValueAtIndex, @"v_PersistentRef");
      CFDictionarySetValue(Mutable, @"v_PersistentRef", v30);
      if ((v5[2](v5, v11, Mutable, a2) & 1) == 0)
      {
        uint64_t v12 = 0LL;
        goto LABEL_27;
      }

      ++v25;
      uint64_t v26 = v11;
      CFIndex v27 = Mutable;
      if (v24 == v25)
      {
        uint64_t v12 = 1LL;
        goto LABEL_27;
      }
    }

    uint64_t v12 = 0LL;
    CFMutableArrayRef Mutable = v27;
LABEL_27:
    CFMutableStringRef MutableCopy = v32;
    if (v32) {
      goto LABEL_28;
    }
  }

void SecTokenProcessError(uint64_t a1, void *a2, uint64_t a3, CFErrorRef *a4)
{
  valuePtr[1] = *(const void **)MEMORY[0x1895F89C0];
  id v6 = a2;
  if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc())
  {
    CFErrorDomain Domain = CFErrorGetDomain(*a4);
    getTKErrorDomain();
    if (Domain && v8)
    {
      if (!CFEqual(Domain, v8)) {
        goto LABEL_16;
      }
    }

    else if (Domain != v8)
    {
      goto LABEL_16;
    }

    if (CFErrorGetCode(*a4) == -9)
    {
      id v30 = 0LL;
      [v6 objectForObjectID:a3 error:&v30];
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
      id v10 = v30;
      uint64_t v11 = v10;
      if (!v9) {
        *a4 = (CFErrorRef)v10;
      }
      [v9 accessControl];
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();

      if (v12)
      {
        [v9 accessControl];
        CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue();
        CFArrayRef v21 = CFArrayCreateForCFTypes(0LL, v14, v15, v16, v17, v18, v19, v20, (uint64_t)v13);
        userInfoValues = CFArrayCreateForCFTypes(0LL, v22, v23, v24, v25, v26, v27, v28, (uint64_t)v21);
        valuePtr[0] = (const void *)-25330LL;
        valuePtr[0] = CFNumberCreate(0LL, kCFNumberCFIndexType, valuePtr);
        CFErrorRef v29 = CFErrorCreateWithUserInfoKeysAndValues( 0LL,  (CFErrorDomain)*MEMORY[0x189604F50],  -25330LL,  valuePtr,  (const void *const *)&userInfoValues,  1LL);
        if (*a4) {
          CFRelease(*a4);
        }
        *a4 = v29;
        CFRelease(valuePtr[0]);
        CFRelease(userInfoValues);
        CFRelease(v21);
      }
    }
  }

uint64_t __SecItemUpdate_block_invoke(uint64_t a1, uint64_t a2)
{
  return SecItemUpdateWithError(*(const __CFDictionary **)(a1 + 32), *(void *)(a1 + 40), a2);
}

uint64_t SecItemUpdateWithError(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  id v6 = (void *)MEMORY[0x186DFF9D0]();
  CFArrayRef v21 = a1;
  CFTypeRef cf = 0LL;
  uint64_t v19 = a2;
  CFTypeRef v20 = 0LL;
  unint64_t Value = CFDictionaryGetValue(a1, @"v_Ref");
  if (Value)
  {
    CFErrorDomain v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == SecIdentityGetTypeID())
    {
      id v10 = (const void *)v8[2];
      CFRetain(v10);
      uint64_t v11 = (const void *)v8[3];
      CFRetain(v11);
      CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, a1);
      if (!MutableCopy)
      {
        uint64_t v14 = 0LL;
        if (!v10) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }

      CFTypeID v13 = MutableCopy;
      CFDictionarySetValue(MutableCopy, @"v_Ref", v10);
      if (SecItemUpdateWithError(v13, a2, a3))
      {
        CFDictionarySetValue(v13, @"v_Ref", v11);
        uint64_t v14 = SecItemUpdateWithError(v13, a2, a3);
        goto LABEL_11;
      }

      goto LABEL_24;
    }

uint64_t __SecItemUpdateWithError_block_invoke( uint64_t a1, void *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5, CFTypeRef *a6)
{
  id v9 = a2;
  if ((isModifyingAPIRateWithinLimits() & 1) == 0) {
    __security_simulatecrash( @"BUG IN CLIENT OF SECITEM: too many writes. See https://at.apple.com/secitemratelimit",  0x53C0000Fu);
  }
  if (v9)
  {
    id v10 = v9;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    void v13[2] = __SecTokenItemUpdate_block_invoke;
    v13[3] = &unk_189670790;
    id v14 = v10;
    uint64_t v15 = a4;
    uint64_t v11 = SecTokenItemForEachMatching(a3, a6, v13);
  }

  else
  {
    uint64_t v11 = SecItemRawUpdate((const __CFString *)a3, a4, a6);
  }

  return v11;
}

uint64_t SecItemRawUpdate(const __CFString *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  if (gSecurityd)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], 0LL);
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = __SecItemRawUpdate_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    void context[4] = Mutable;
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2_8844, context);
    uint64_t v7 = *(uint64_t (**)(const __CFString *, CFMutableDictionaryRef, uint64_t, CFTypeRef *))(gSecurityd + 16);
    uint64_t v8 = SecSecurityClientGet();
    uint64_t v9 = v7(a1, Mutable, v8, a3);
    CFRelease(Mutable);
  }

  else
  {
    xpc_object_t message = securityd_create_message(2u, a3);
    uint64_t v15 = message;
    if (message
      && SecXPCDictionarySetPListWithRepair(message, "query", a1, (__CFString **)a3, v11, v12, v13, v14)
      && SecXPCDictionarySetPListWithRepair( v15,  "attributesToUpdate",  (const __CFString *)a2,  (__CFString **)a3,  v16,  v17,  v18,  v19))
    {
      logUnreasonableDataLength(a2);
      uint64_t v20 = securityd_message_with_reply_sync(v15, (uint64_t)a3);
      CFArrayRef v21 = (void *)v20;
      if (v20) {
        uint64_t v9 = securityd_message_no_error(v20, (CFErrorRef *)a3);
      }
      else {
        uint64_t v9 = 0LL;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }
  }

  return v9;
}

uint64_t __SecTokenItemUpdate_block_invoke( uint64_t a1, const __CFDictionary *a2, const __CFString *a3, CFErrorRef *a4)
{
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, *(CFDictionaryRef *)(a1 + 40));
  uint64_t v9 = *(void **)(a1 + 32);
  unint64_t Value = CFDictionaryGetValue(a2, @"oid");
  uint64_t v11 = SecTokenCopyUpdatedObjectID(v9, (uint64_t)Value, MutableCopy, a4);
  if (!v11)
  {
    uint64_t v13 = 0LL;
    if (!MutableCopy) {
      return v13;
    }
    goto LABEL_3;
  }

  uint64_t v12 = v11;
  uint64_t v13 = SecItemRawUpdate(a3, MutableCopy, (CFTypeRef *)a4);
  CFRelease(v12);
  if (MutableCopy) {
LABEL_3:
  }
    CFRelease(MutableCopy);
  return v13;
}

void *SecTokenCopyUpdatedObjectID(void *a1, uint64_t a2, const __CFDictionary *a3, CFErrorRef *a4)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v7 = a1;
  CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a3);
  if (a2)
  {
    uint64_t v38 = 0LL;
    uint64_t v9 = (id *)&v38;
    uint64_t v10 = [v7 objectForObjectID:a2 error:&v38];
  }

  else
  {
    uint64_t v39 = 0LL;
    uint64_t v9 = (id *)&v39;
    uint64_t v10 = [v7 createObjectWithAttributes:a3 error:&v39];
  }

  uint64_t v11 = (void *)v10;
  id v12 = *v9;
  uint64_t v13 = v12;
  if (a4 && !v11)
  {
    *a4 = (CFErrorRef)v12;
LABEL_7:
    if (a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (uint64_t)a3;
    }
    SecTokenProcessError((uint64_t)@"oe", v7, v14, a4);
    uint64_t v15 = 0LL;
    goto LABEL_28;
  }

  if (!v11) {
    goto LABEL_7;
  }
  id v32 = v12;
  CFDictionaryRemoveAllValues(a3);
  [v11 keychainAttributes];
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue();
  -[__CFDictionary addEntriesFromDictionary:](a3, "addEntriesFromDictionary:", v16);

  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  uint64_t v33 = Copy;
  uint64_t v17 = Copy;
  uint64_t v18 = -[__CFDictionary countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v34,  v40,  16LL);
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(void *)v35;
    do
    {
      for (uint64_t i = 0LL; i != v19; ++i)
      {
        if (*(void *)v35 != v20) {
          objc_enumerationMutation(v17);
        }
        uint64_t v22 = *(void **)(*((void *)&v34 + 1) + 8 * i);
        if ((objc_msgSend(v22, "isEqualToString:", @"v_Data", v32) & 1) == 0) {
          CFDictionaryAddValue(a3, v22, (const void *)-[__CFDictionary objectForKey:](v17, "objectForKey:", v22));
        }
      }

      uint64_t v19 = -[__CFDictionary countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v34,  v40,  16LL);
    }

    while (v19);
  }

  [v11 accessControl];
  uint64_t v23 = (const void *)objc_claimAutoreleasedReturnValue();
  [v11 objectID];
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
  unint64_t Value = CFDictionaryGetValue(a3, @"v_Data");
  id v30 = SecTokenItemValueCreate((uint64_t)v24, (int)v23, Value, (CFTypeRef *)a4, v26, v27, v28, v29);

  if (v30)
  {
    CFDictionarySetValue(a3, @"v_Data", v30);
    CFDictionaryRemoveValue(a3, @"accc");
    [v11 objectID];
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();

    if (v15) {
      CFRetain(v15);
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v13 = v32;
  CFDictionaryRef Copy = v33;
  if (v23) {
    CFRelease(v23);
  }
  if (v30) {
    CFRelease(v30);
  }
LABEL_28:
  if (Copy) {
    CFRelease(Copy);
  }

  return v15;
}

__CFData *SecTokenItemValueCreate( uint64_t a1, int a2, const void *a3, CFTypeRef *a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith_8917 = CFDictionaryCreateMutableForCFTypesWith_8917( a1,  a2,  (int)a3,  (int)a4,  a5,  a6,  a7,  a8,  @"oid",  a1);
  uint64_t v16 = (const __CFString *)MutableForCFTypesWith_8917;
  if (a3) {
    CFDictionarySetValue(MutableForCFTypesWith_8917, @"data", a3);
  }
  DERData = CFPropertyListCreateDERData((uint64_t)MutableForCFTypesWith_8917, v16, a4, v11, v12, v13, v14, v15);
  CFRelease(v16);
  return DERData;
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith_8917( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v14 = (const void **)&a10;
  uint64_t v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      uint64_t v12 = v14 + 1;
      v14 += 2;
      uint64_t v11 = *v12;
    }

    while (*v12);
  }

  return Mutable;
}

void __SecItemRawUpdate_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

void logUnreasonableDataLength(const void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == CFDictionaryGetTypeID())
    {
      unint64_t Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a1, @"v_Data");
      if (Value)
      {
        CFTypeID v4 = Value;
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFDataGetTypeID())
        {
          CFIndex Length = CFDataGetLength(v4);
          if (Length > 0x8000)
          {
            CFIndex v7 = Length;
            secLogObjForScope("SecWarning");
            uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              int v9 = 134217984;
              CFIndex v10 = v7;
              _os_log_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEFAULT,  "keychain item data exceeds reasonable size (%lu bytes)",  (uint8_t *)&v9,  0xCu);
            }
          }
        }
      }
    }
  }

void __SecTokenItemAdd_block_invoke(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!CFEqual(cf1, @"v_Data") && !CFEqual(cf1, @"toid") && !CFEqual(cf1, @"accc")) {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), cf1, a3);
  }
}

uint64_t SecDeleteItemsOnSignOut(CFTypeRef *a1)
{
  CFTypeID v2 = (void *)MEMORY[0x186DFF9D0]();
  unsigned int v3 = _os_activity_create(&dword_1804F4000, "SecDeleteItemsOnSignOut", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  if (gSecurityd)
  {
    CFTypeID v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 104);
    uint64_t v5 = SecSecurityClientGet();
    uint64_t v6 = v4(v5, a1);
  }

  else
  {
    uint64_t v9 = 0LL;
    CFIndex v10 = &v9;
    uint64_t v11 = 0x2020000000LL;
    char v12 = 0;
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    unint64_t v8[2] = __SecDeleteItemsOnSignOut_block_invoke;
    unint64_t v8[3] = &unk_1896702C8;
    void v8[4] = &v9;
    securityd_send_sync_and_do(0x84u, a1, 0LL, (uint64_t)v8);
    uint64_t v6 = *((_BYTE *)v10 + 24) != 0;
    _Block_object_dispose(&v9, 8);
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return v6;
}

void sub_1805C8BBC(_Unwind_Exception *a1)
{
}

uint64_t __SecDeleteItemsOnSignOut_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t _SecKeychainForceUpgradeIfNeeded()
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  int v8 = -26276;
  uint64_t v0 = (void *)MEMORY[0x186DFF9D0]();
  SecuritydXPCProxyObject(1LL, &__block_literal_global_35_8925);
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  void v4[2] = ___SecKeychainForceUpgradeIfNeeded_block_invoke_36;
  unint64_t v4[3] = &unk_189670470;
  void v4[4] = &v5;
  [v1 secKeychainForceUpgradeIfNeeded:v4];

  objc_autoreleasePoolPop(v0);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1805C8CDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t SecItemDeleteAll()
{
  uint64_t v0 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v1 = SecOSStatusWith((uint64_t)&__block_literal_global_39);
  objc_autoreleasePoolPop(v0);
  return v1;
}

uint64_t __SecItemDeleteAll_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (!gSecurityd) {
    return securityd_send_sync_and_do(7u, a2, 0LL, 0LL);
  }
  return SecError(-26276, (__CFString **)a2, @"sec_item_delete_all is NULL");
}

uint64_t SecItemDeleteAllWithAccessGroups()
{
  return 1LL;
}

uint64_t SecItemUpdateTokenItemsForAccessGroups(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v7 = _os_activity_create( &dword_1804F4000,  "SecItemUpdateTokenItemsForAccessGroups",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __SecItemUpdateTokenItemsForAccessGroups_block_invoke;
  unint64_t v10[3] = &__block_descriptor_56_e20_B16__0_____CFError_8l;
  void v10[4] = a3;
  void v10[5] = a1;
  void v10[6] = a2;
  uint64_t v8 = SecOSStatusWith((uint64_t)v10);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_1805C8FF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

uint64_t __SecItemUpdateTokenItemsForAccessGroups_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v2 = a1;
  if (*(void *)(a1 + 32))
  {
    allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
    CFIndex v4 = 0LL;
    uint64_t v5 = @"accc";
    uint64_t v6 = @"toid";
    uint64_t v7 = @"v_Data";
    while (v4 < CFArrayGetCount(*(CFArrayRef *)(v2 + 32)))
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 32), v4);
      unint64_t Value = CFDictionaryGetValue(ValueAtIndex, v5);
      CFIndex v10 = CFDictionaryGetValue(ValueAtIndex, v6);
      uint64_t v11 = CFDictionaryGetValue(ValueAtIndex, v7);
      if (v10) {
        BOOL v12 = Value == 0LL;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12) {
        goto LABEL_14;
      }
      uint64_t v13 = v11;
      CFIndex v40 = v4;
      uint64_t v14 = v2;
      uint64_t v15 = Mutable;
      uint64_t v16 = v7;
      uint64_t v17 = v6;
      uint64_t v18 = v5;
      CFTypeID TypeID = CFDataGetTypeID();
      BOOL v12 = TypeID == CFGetTypeID(Value);
      uint64_t v5 = v18;
      uint64_t v6 = v17;
      uint64_t v7 = v16;
      CFMutableDictionaryRef Mutable = v15;
      uint64_t v2 = v14;
      CFIndex v4 = v40;
      if (v12)
      {
        uint64_t v24 = SecTokenItemValueCreate((uint64_t)v10, (int)Value, v13, a2, v20, v21, v22, v23);
        if (!v24)
        {
          uint64_t v36 = 0LL;
          if (Mutable) {
            goto LABEL_34;
          }
          return v36;
        }

        uint64_t v25 = v24;
        CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0LL, ValueAtIndex);
        CFDictionarySetValue(MutableCopy, v7, v25);
        CFDictionarySetValue(MutableCopy, @"tkid", *(const void **)(v2 + 40));
        CFDictionaryRemoveValue(MutableCopy, v5);
        CFDictionaryRemoveValue(MutableCopy, v6);
        CFArrayAppendValue(Mutable, MutableCopy);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        CFRelease(v25);
      }

      else
      {
LABEL_14:
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }

      ++v4;
    }
  }

  else
  {
    CFMutableDictionaryRef Mutable = 0LL;
  }

  if (gSecurityd
    && (int v27 = *(uint64_t (**)(uint64_t, uint64_t, __CFArray *, uint64_t, CFTypeRef *))(gSecurityd + 80)) != 0LL)
  {
    uint64_t v28 = *(void *)(v2 + 40);
    if (*(void *)(v2 + 48)) {
      uint64_t v29 = *(void *)(v2 + 48);
    }
    else {
      uint64_t v29 = MEMORY[0x189604A58];
    }
    if (Mutable) {
      id v30 = Mutable;
    }
    else {
      id v30 = (__CFArray *)MEMORY[0x189604A58];
    }
    uint64_t v31 = SecSecurityClientGet();
    uint64_t v32 = v27(v28, v29, v30, v31, a2);
  }

  else
  {
    uint64_t v33 = *(void *)(v2 + 40);
    if (*(void *)(v2 + 48)) {
      uint64_t v34 = *(void *)(v2 + 48);
    }
    else {
      uint64_t v34 = MEMORY[0x189604A58];
    }
    if (Mutable) {
      __int128 v35 = Mutable;
    }
    else {
      __int128 v35 = (__CFArray *)MEMORY[0x189604A58];
    }
    SecSecurityClientGet();
    v41[0] = MEMORY[0x1895F87A8];
    v41[1] = 3221225472LL;
    v41[2] = __cfstring_array_array_to_error_request_block_invoke;
    unint64_t v41[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v41[4] = v33;
    v41[5] = v34;
    v41[6] = v35;
    uint64_t v32 = securityd_send_sync_and_do(0x62u, a2, (uint64_t)v41, 0LL);
  }

  uint64_t v36 = v32;
  if (Mutable) {
LABEL_34:
  }
    CFRelease(Mutable);
  return v36;
}

BOOL __cfstring_array_array_to_error_request_block_invoke(void *a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  CFIndex v10 = v5;
  uint64_t v11 = (const __CFString *)a1[4];
  BOOL v14 = 0;
  if (!v11 || SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"cfstring", v11, a3))
  {
    BOOL v12 = (const __CFString *)a1[5];
    if (!v12 || SecXPCDictionarySetPListWithRepair(v10, "cfarray", v12, a3, v6, v7, v8, v9))
    {
      uint64_t v13 = (const __CFString *)a1[6];
    }
  }

  return v14;
}

uint64_t _SecKeychainSyncUpdateMessage(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 3221225472LL;
  activity_block[2] = ___SecKeychainSyncUpdateMessage_block_invoke;
  activity_block[3] = &unk_1896704F8;
  activity_block[4] = &v8;
  activity_void block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainSyncUpdateMessage", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t _SecKeychainRollKeys(uint64_t a1, CFTypeRef *a2)
{
  CFIndex v4 = (void *)MEMORY[0x186DFF9D0]();
  if (gSecurityd && (uint64_t v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 72)) != 0LL)
  {
    uint64_t v6 = v5(a1, a2);
  }

  else
  {
    uint64_t v11 = 0LL;
    BOOL v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    char v14 = 0;
    void v8[4] = &v11;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    _OWORD v9[2] = ___SecKeychainRollKeys_block_invoke;
    v9[3] = &__block_descriptor_33_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    char v10 = a1;
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    unint64_t v8[2] = ___SecKeychainRollKeys_block_invoke_2;
    unint64_t v8[3] = &unk_1896702C8;
    securityd_send_sync_and_do(0x1Du, a2, (uint64_t)v9, (uint64_t)v8);
    uint64_t v6 = *((_BYTE *)v12 + 24) != 0;
    _Block_object_dispose(&v11, 8);
  }

  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t SecItemCopyParentCertificates_ios(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v7 = _os_activity_create( &dword_1804F4000,  "SecItemCopyParentCertificates_ios",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  if (gSecurityd && (uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 40)) != 0LL)
  {
    uint64_t v9 = v8(a1, a2, a3);
  }

  else
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000LL;
    uint64_t v17 = 0LL;
    v12[4] = &v14;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    void v13[2] = __data_array_to_array_error_request_block_invoke;
    v13[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    void v13[4] = a1;
    v13[5] = a2;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    void v12[2] = __data_array_to_array_error_request_block_invoke_2;
    v12[3] = &unk_1896702C8;
    securityd_send_sync_and_do(0x6Du, a3, (uint64_t)v13, (uint64_t)v12);
    uint64_t v9 = v15[3];
    _Block_object_dispose(&v14, 8);
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v9;
}

void sub_1805C97E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
}

uint64_t __data_array_to_array_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v5 = *(const __CFData **)(a1 + 32);
  id v6 = a2;
  SecXPCDictionarySetData(v6, "normIssuer", v5, a3);
  SecXPCDictionarySetPListWithRepair(v6, "accessGroups", *(const __CFString **)(a1 + 40), a3, v7, v8, v9, v10);

  return 1LL;
}

BOOL __data_array_to_array_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", (void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a3);
}

uint64_t SecItemCertificateExists(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v9 = _os_activity_create(&dword_1804F4000, "SecItemCertificateExists", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v13.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &v13);
  if (gSecurityd && (uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 48)) != 0LL)
  {
    uint64_t v11 = v10(a1, a2, a3, a4);
  }

  else
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = &v16;
    uint64_t v18 = 0x2020000000LL;
    char v19 = 0;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    unint64_t v15[2] = __data_data_array_to_BOOL_error_request_block_invoke;
    unint64_t v15[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    void v15[4] = a1;
    void v15[5] = a2;
    v15[6] = a3;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    void v14[2] = __data_data_array_to_BOOL_error_request_block_invoke_2;
    unint64_t v14[3] = &unk_1896702C8;
    void v14[4] = &v16;
    securityd_send_sync_and_do(0x6Eu, a4, (uint64_t)v15, (uint64_t)v14);
    uint64_t v11 = *((_BYTE *)v17 + 24) != 0;
    _Block_object_dispose(&v16, 8);
  }

  os_activity_scope_leave(&v13);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_1805C99E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

uint64_t _SecItemAddAndNotifyOnSync(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x3010000000LL;
  char v19 = &unk_18069119A;
  uint64_t v20 = a1;
  uint64_t v21 = 0LL;
  id v6 = _os_activity_create( &dword_1804F4000,  "_SecItemAddAndNotifyOnSync",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  _OWORD v11[2] = ___SecItemAddAndNotifyOnSync_block_invoke;
  unint64_t v11[3] = &unk_1896705E0;
  os_activity_scope_state_s v13 = &v16;
  id v7 = v5;
  id v12 = v7;
  uint64_t v14 = a2;
  uint64_t v8 = SecOSStatusWith((uint64_t)v11);
  uint64_t v9 = (const void *)v17[5];
  if (v9)
  {
    v17[5] = 0LL;
    CFRelease(v9);
  }

  os_activity_scope_leave(&state);
  _Block_object_dispose(&v16, 8);

  return v8;
}

void sub_1805C9BDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1805C9EE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void SecItemSetCurrentItemAcrossAllDevices( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id v12 = a8;
  os_activity_scope_state_s v13 = _os_activity_create( &dword_1804F4000,  "SecItemSetCurrentItemAcrossAllDevices",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  uint64_t v14 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v15 = MEMORY[0x1895F87A8];
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  v24[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke;
  v24[3] = &unk_189670540;
  id v16 = v12;
  id v25 = v16;
  SecuritydXPCProxyObject(0LL, v24);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  v22[0] = v15;
  v22[1] = 3221225472LL;
  void v22[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke_2;
  v22[3] = &unk_189670540;
  id v18 = v16;
  id v23 = v18;
  [v17 secItemSetCurrentItemAcrossAllDevices:a4 newCurrentItemHash:a5 accessGroup:a1 identifier:a2 viewHint:a3 oldCurrentItemReference:a6 old CurrentItemHash:a7 complete:v22];

  objc_autoreleasePoolPop(v14);
  os_activity_scope_leave(&state);
}

void sub_1805CA134( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, os_activity_scope_state_s state)
{
}

uint64_t __SecItemSetCurrentItemAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __SecItemSetCurrentItemAcrossAllDevices_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void SecItemUnsetCurrentItemsAcrossAllDevices(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = _os_activity_create( &dword_1804F4000,  "SecItemUnsetCurrentItemsAcrossAllDevices",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  uint64_t v9 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v10 = MEMORY[0x1895F87A8];
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 3221225472LL;
  void v16[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke;
  unint64_t v16[3] = &unk_189670540;
  id v11 = v7;
  id v17 = v11;
  SecuritydXPCProxyObject(0LL, v16);
  id v12 = (void *)objc_claimAutoreleasedReturnValue();
  v14[0] = v10;
  v14[1] = 3221225472LL;
  void v14[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke_2;
  unint64_t v14[3] = &unk_189670540;
  id v13 = v11;
  id v15 = v13;
  [v12 secItemUnsetCurrentItemsAcrossAllDevices:a1 identifiers:a2 viewHint:a3 complete:v14];

  objc_autoreleasePoolPop(v9);
  os_activity_scope_leave(&state);
}

void sub_1805CA2AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void SecItemFetchCurrentItemAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  _OWORD v11[2] = __SecItemFetchCurrentItemAcrossAllDevices_block_invoke;
  unint64_t v11[3] = &unk_189670608;
  id v12 = v9;
  id v10 = v9;
  SecItemFetchCurrentItemDataAcrossAllDevices(a1, a2, a3, a4, v11);
}

void __SecItemFetchCurrentItemAcrossAllDevices_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  [a2 persistentRef];
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v6, v5);
}

void SecItemFetchCurrentItemDataAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  id v12 = a5;
  id v13 = _os_activity_create( &dword_1804F4000,  "SecItemFetchCurrentItemDataAcrossAllDevices",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  uint64_t v14 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v15 = MEMORY[0x1895F87A8];
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  void v21[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke;
  v21[3] = &unk_189670540;
  id v16 = v12;
  id v22 = v16;
  SecuritydXPCProxyObject(0LL, v21);
  id v17 = (void *)objc_claimAutoreleasedReturnValue();
  v19[0] = v15;
  v19[1] = 3221225472LL;
  void v19[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke_2;
  unint64_t v19[3] = &unk_189670630;
  id v18 = v16;
  id v20 = v18;
  [v17 secItemFetchCurrentItemAcrossAllDevices:v9 identifier:v10 viewHint:v11 fetchCloudValue:a4 complete:v19];

  objc_autoreleasePoolPop(v14);
  os_activity_scope_leave(&state);
}

void sub_1805CA55C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

uint64_t __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke_2( uint64_t a1, SecItemCurrentItemData *a2, void *a3, void *a4)
{
  id v9 = a4;
  if (a2)
  {
    id v7 = a3;
    uint64_t v8 = a2;
    a2 = -[SecItemCurrentItemData initWithPersistentRef:]( objc_alloc(&OBJC_CLASS___SecItemCurrentItemData),  "initWithPersistentRef:",  v8);

    -[SecItemCurrentItemData setCurrentItemPointerModificationTime:](a2, "setCurrentItemPointerModificationTime:", v7);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void _SecItemFetchDigests(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = _os_activity_create(&dword_1804F4000, "_SecItemFetchDigests", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  _OWORD v11[2] = ___SecItemFetchDigests_block_invoke;
  unint64_t v11[3] = &unk_189670540;
  id v9 = v7;
  id v12 = v9;
  SecuritydXPCProxyObject(0LL, v11);
  id v10 = (void *)objc_claimAutoreleasedReturnValue();
  [v10 secItemDigest:v5 accessGroup:v6 complete:v9];

  os_activity_scope_leave(&state);
}

void sub_1805CA730( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void _SecKeychainDeleteMultiUser(void *a1, void *a2)
{
  v33[1] = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  id v5 = _os_activity_create( &dword_1804F4000,  "_SecKeychainDeleteMultiUser",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  id v6 = (void *)[objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v3];
  id v7 = v6;
  if (v6)
  {
    v32[0] = 0xAAAAAAAAAAAAAAAALL;
    v32[1] = 0xAAAAAAAAAAAAAAAALL;
    [v6 getUUIDBytes:v32];
    uint64_t v8 = MEMORY[0x1895F87A8];
    v25[0] = MEMORY[0x1895F87A8];
    v25[1] = 3221225472LL;
    int v26 = ___SecKeychainDeleteMultiUser_block_invoke;
    uint64_t v27 = &unk_189670540;
    id v9 = v4;
    id v28 = v9;
    id v10 = v25;
    if (gSecurityd && *(void *)(gSecurityd + 696)) {
      id v11 = objc_alloc_init(&OBJC_CLASS___FakeSecuritydXPCClient);
    }
    else {
      id v11 = -[SecuritydXPCClient initTargetingSession:]( objc_alloc(&OBJC_CLASS___SecuritydXPCClient),  "initTargetingSession:",  0LL);
    }
    id v12 = v11;
    if (v11)
    {

      v23[0] = v8;
      v23[1] = 3221225472LL;
      void v23[2] = ___SecKeychainDeleteMultiUser_block_invoke_2;
      void v23[3] = &unk_189670540;
      id v13 = v9;
      id v24 = v13;
      -[FakeSecuritydXPCClient protocolWithSync:errorHandler:](v12, "protocolWithSync:errorHandler:", 0LL, v23);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      if (v14)
      {
        cf[0] = 0LL;
        cf[1] = cf;
        cf[2] = (CFTypeRef)0x3032000000LL;
        cf[3] = __Block_byref_object_copy__8849;
        CFTypeRef cf[4] = __Block_byref_object_dispose__8850;
        uint64_t v31 = v12;
        [MEMORY[0x189603F48] dataWithBytes:v32 length:16];
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
        v20[0] = v8;
        v20[1] = 3221225472LL;
        v20[2] = ___SecKeychainDeleteMultiUser_block_invoke_74;
        v20[3] = &unk_189670658;
        id v21 = v13;
        id v22 = cf;
        [v14 secKeychainDeleteMultiuser:v15 complete:v20];

        _Block_object_dispose(cf, 8);
      }
    }

    else
    {
      id v17 = (void *)MEMORY[0x189607870];
      v33[0] = *MEMORY[0x1896075E0];
      cf[0] = @"Could not create SecuritydXPCClientObject";
      [MEMORY[0x189603F68] dictionaryWithObjects:cf forKeys:v33 count:1];
      id v18 = (void *)objc_claimAutoreleasedReturnValue();
      [v17 errorWithDomain:@"securityd" code:-1 userInfo:v18];
      char v19 = (void *)objc_claimAutoreleasedReturnValue();
      ((void (*)(void *, void *))v26)(v10, v19);
    }
  }

  else
  {
    cf[0] = 0LL;
    SecError(-50, (__CFString **)cf, @"_SecKeychainDeleteMultiUser: invalid UUID %@", v3);
    (*((void (**)(id, void, CFTypeRef))v4 + 2))(v4, 0LL, cf[0]);
    CFTypeRef v16 = cf[0];
    if (cf[0])
    {
      cf[0] = 0LL;
      CFRelease(v16);
    }
  }

  os_activity_scope_leave(&state);
}

void sub_1805CAAA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, os_activity_scope_state_s state, char a27)
{
}

uint64_t SecItemDeleteKeychainItemsForAppClip(uint64_t a1)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  int v10 = -26276;
  uint64_t v2 = (void *)MEMORY[0x186DFF9D0]();
  SecuritydXPCProxyObject(1LL, &__block_literal_global_75);
  id v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __SecItemDeleteKeychainItemsForAppClip_block_invoke_76;
  unint64_t v6[3] = &unk_189670470;
  void v6[4] = &v7;
  [v3 secItemDeleteForAppClipApplicationIdentifier:a1 completion:v6];

  objc_autoreleasePoolPop(v2);
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1805CAC0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __SecItemDeleteKeychainItemsForAppClip_block_invoke_76(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  secLogObjForScope("xpc");
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "app clip deletion result: %i", (uint8_t *)v5, 8u);
  }

  if (!a2 || a2 == -34018) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
}

void __SecItemDeleteKeychainItemsForAppClip_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  id v2 = a2;
  secLogObjForScope("SecError");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "xpc: failure to obtain XPC proxy object for app clip deletion, %@",  (uint8_t *)&v4,  0xCu);
  }
}

uint64_t SecItemPersistKeychainWritesAtHighPerformanceCost(void *a1)
{
  id v2 = _os_activity_create( &dword_1804F4000,  "SecItemPersistKeychainWritesAtHighPerformanceCost",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  uint64_t v18 = 0LL;
  char v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  int v21 = -26276;
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  uint64_t v17 = 0LL;
  id v3 = (void *)MEMORY[0x186DFF9D0]();
  secLogObjForScope("xpc");
  int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "This process is requesting a expensive full keychain database checkpoint",  buf,  2u);
  }

  uint64_t v5 = MEMORY[0x1895F87A8];
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  void v12[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke;
  v12[3] = &unk_189672C48;
  v12[4] = &v14;
  SecuritydXPCProxyObject(1LL, v12);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  v11[0] = v5;
  v11[1] = 3221225472LL;
  _OWORD v11[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke_77;
  unint64_t v11[3] = &unk_1896706A0;
  void v11[4] = &v14;
  void v11[5] = &v18;
  [v6 secItemPersistKeychainWritesAtHighPerformanceCost:v11];

  objc_autoreleasePoolPop(v3);
  uint64_t v7 = v15;
  uint64_t v8 = (const void *)v15[3];
  if (v8)
  {
    if (!a1 || (CFRetain((CFTypeRef)v15[3]), *a1 = v8, uint64_t v7 = v15, (v8 = (const void *)v15[3]) != 0LL))
    {
      unint64_t v7[3] = 0LL;
      CFRelease(v8);
    }
  }

  uint64_t v9 = *((unsigned int *)v19 + 6);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  os_activity_scope_leave(&state);

  return v9;
}

void sub_1805CAF84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  secLogObjForScope("SecError");
  int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "xpc: failure to obtain XPC proxy object for Item Persistence, %@",  (uint8_t *)&v6,  0xCu);
  }

  id v5 = v3;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v5;
}

void __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke_77(uint64_t a1, int a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (a2)
  {
    secLogObjForScope("SecError");
    int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109378;
      v8[1] = a2;
      __int16 v9 = 2112;
      id v10 = v5;
      _os_log_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_DEFAULT,  "xpc: Failed to persist keychain writes: %d %@",  (uint8_t *)v8,  0x12u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v5;
  }

  else
  {
    secLogObjForScope("xpc");
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "Successfully persisted keychain data to disk",  (uint8_t *)v8,  2u);
    }
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
}

uint64_t SecItemPromoteAppClipItemsToParentApp(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0LL;
  id v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  int v12 = -26276;
  int v4 = (void *)MEMORY[0x186DFF9D0]();
  SecuritydXPCProxyObject(1LL, &__block_literal_global_79);
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = __SecItemPromoteAppClipItemsToParentApp_block_invoke_80;
  unint64_t v8[3] = &unk_189670470;
  void v8[4] = &v9;
  [v5 secItemPromoteItemsForAppClip:a1 toParentApp:a2 completion:v8];

  objc_autoreleasePoolPop(v4);
  uint64_t v6 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_1805CB29C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __SecItemPromoteAppClipItemsToParentApp_block_invoke_80(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  secLogObjForScope("xpc");
  int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "app clip promotion result: %i", (uint8_t *)v5, 8u);
  }

  if (a2 == -34018 || !a2 || a2 == -25308) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  }
}

void __SecItemPromoteAppClipItemsToParentApp_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  id v2 = a2;
  secLogObjForScope("SecError");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "xpc: failure to obtain XPC proxy object for app clip promotion, %@",  (uint8_t *)&v4,  0xCu);
  }
}

uint64_t _SecKeychainCopyOTABackup()
{
  uint64_t v3 = 0LL;
  int v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  unint64_t v6 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = ___SecKeychainCopyOTABackup_block_invoke;
  activity_block[3] = &unk_1896707D8;
  activity_block[4] = &v3;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainCopyOTABackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t client_data_data_BOOL_to_data_error_request(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __client_data_data_BOOL_to_data_error_request_block_invoke;
  unint64_t v6[3] = &__block_descriptor_tmp_33_8963;
  void v6[4] = a1;
  void v6[5] = a2;
  char v7 = a3;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __client_data_data_BOOL_to_data_error_request_block_invoke_2;
  v5[3] = &unk_189670BE8;
  void v5[4] = &v8;
  securityd_send_sync_and_do(9u, 0LL, (uint64_t)v6, (uint64_t)v5);
  uint64_t v3 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t _SecKeychainCopyBackup(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = ___SecKeychainCopyBackup_block_invoke;
  activity_block[3] = &unk_189670800;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainCopyBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _SecKeychainCopyEMCSBackup(uint64_t a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = ___SecKeychainCopyEMCSBackup_block_invoke;
  v3[3] = &unk_189670828;
  void v3[4] = &v4;
  v3[5] = a1;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainCopyEMCSBackup", OS_ACTIVITY_FLAG_DEFAULT, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t _SecKeychainWriteBackupToFileDescriptor(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  char v11 = 0;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = ___SecKeychainWriteBackupToFileDescriptor_block_invoke;
  activity_block[3] = &unk_189670898;
  activity_block[6] = a1;
  void activity_block[7] = a2;
  int v7 = a3;
  activity_block[4] = &v8;
  activity_void block[5] = a4;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainWriteBackupToFile", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainRestoreBackupFromFileDescriptor(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  char v11 = -86;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = ___SecKeychainRestoreBackupFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_189670908;
  int v7 = a1;
  activity_block[6] = a2;
  void activity_block[7] = a3;
  activity_block[4] = &v8;
  activity_void block[5] = a4;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainCopyKeybagUUIDFromFileDescriptor(int a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = ___SecKeychainCopyKeybagUUIDFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_189670978;
  int v5 = a1;
  activity_block[4] = &v6;
  activity_void block[5] = a2;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainCopyKeybagUUID", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t _SecKeychainRestoreBackup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = -1431655766;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = ___SecKeychainRestoreBackup_block_invoke;
  v5[3] = &unk_1896709C0;
  void v5[4] = &v6;
  void v5[5] = a1;
  v5[6] = a2;
  v5[7] = a3;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL __data_client_data_data_to_error_request_block_invoke(CFDataRef *a1, void *a2, __CFString **a3)
{
  BOOL result = SecXPCDictionarySetData(a2, "backup", a1[4], a3);
  if (result)
  {
    BOOL result = SecXPCDictionarySetData(a2, "keybag", a1[5], a3);
    if (result)
    {
      int v7 = a1[6];
      return !v7 || SecXPCDictionarySetData(a2, "password", v7, a3);
    }
  }

  return result;
}

CFMutableDataRef SecItemBackupCreateManifest(const __CFDictionary *a1)
{
  if (!a1) {
    return CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  }
  CFIndex Count = CFDictionaryGetCount(a1);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 20 * Count);
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 0x40000000LL;
  context[2] = __SecItemBackupCreateManifest_block_invoke;
  context[3] = &__block_descriptor_tmp_19_8986;
  void context[4] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_8987, context);
  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
  CFIndex Length = CFDataGetLength(Mutable);
  qsort(MutableBytePtr, Length / 20, 0x14uLL, (int (__cdecl *)(const void *, const void *))compareDigests);
  return Mutable;
}

void __SecItemBackupCreateManifest_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDictionaryGetTypeID())
    {
      unint64_t Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"hash");
      int v7 = Value;
      if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFDataGetTypeID()) && CFDataGetLength(v7) == 20)
      {
        int v9 = *(__CFData **)(a1 + 32);
        uint64_t BytePtr = CFDataGetBytePtr(v7);
        CFIndex Length = CFDataGetLength(v7);
        CFDataAppendBytes(v9, BytePtr, Length);
      }

      else
      {
        int v12 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFIndex v13 = CFDataGetLength(v7);
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(v12, 2 * v13);
        uint64_t v15 = CFDataGetBytePtr(v7);
        CFIndex v16 = CFDataGetLength(v7);
        if (v16 >= 1)
        {
          CFIndex v17 = v16;
          do
          {
            unsigned int v18 = *v15++;
            CFStringAppendFormat(Mutable, 0LL, @"%02X", v18);
            --v17;
          }

          while (v17);
        }

        char v19 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          int v21 = Mutable;
          _os_log_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEFAULT, "bad hash %@ in backup", buf, 0xCu);
        }

        if (Mutable) {
          CFRelease(Mutable);
        }
      }
    }
  }

uint64_t apply_block_2_8987(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t compareDigests(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)a1);
  unint64_t v3 = bswap64(*(void *)a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 8));
    unint64_t v3 = bswap64(*(void *)(a2 + 8));
    if (v2 == v3)
    {
      unint64_t v2 = bswap32(*(_DWORD *)(a1 + 16));
      unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3) {
        return 0LL;
      }
    }
  }

  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1LL;
}

uint64_t _SecKeychainBackupSyncable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = ___SecKeychainBackupSyncable_block_invoke;
  v5[3] = &__block_descriptor_tmp_20;
  void v5[4] = a4;
  void v5[5] = a3;
  v5[6] = a1;
  v5[7] = a2;
  return SecOSStatusWith((uint64_t)v5);
}

uint64_t __data_data_dict_to_dict_error_request_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v11 = *(const __CFString **)(a1 + 32);
  if (!v11 || (uint64_t result = SecXPCDictionarySetPListWithRepair(a2, "backup", v11, a3, a5, a6, a7, a8), (_DWORD)result))
  {
    uint64_t result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      CFIndex v13 = *(const __CFData **)(a1 + 48);
      return !v13 || SecXPCDictionarySetData(a2, "password", v13, a3);
    }
  }

  return result;
}

BOOL __data_data_dict_to_dict_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v4 = SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return v4 != 0LL;
}

uint64_t _SecKeychainRestoreSyncable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = -1431655766;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = ___SecKeychainRestoreSyncable_block_invoke;
  v5[3] = &unk_189670A48;
  void v5[4] = &v6;
  void v5[5] = a3;
  v5[6] = a1;
  v5[7] = a2;
  _os_activity_initiate(&dword_1804F4000, "_SecKeychainRestoreSyncable", OS_ACTIVITY_FLAG_DEFAULT, v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __dict_data_data_to_error_request_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = SecXPCDictionarySetPListWithRepair(a2, "backup", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    uint64_t result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      int v12 = *(const __CFData **)(a1 + 48);
      return !v12 || SecXPCDictionarySetData(a2, "password", v12, a3);
    }
  }

  return result;
}

BOOL SecItemBackupWithRegisteredBackups(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0LL;
  char v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __SecItemBackupCopyNames_block_invoke;
  v9[3] = &unk_189670C98;
  void v9[4] = &v10;
  void v9[5] = a1;
  _os_activity_initiate(&dword_1804F4000, "SecItemBackupCopyNames", OS_ACTIVITY_FLAG_DEFAULT, v9);
  uint64_t v3 = (const __CFArray *)v11[3];
  _Block_object_dispose(&v10, 8);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0LL; i != v5; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }

    CFRelease(v3);
  }

  return v3 != 0LL;
}

void __SecItemBackupCopyNames_block_invoke(uint64_t a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void))(gSecurityd + 136)) != 0LL)
  {
    uint64_t v3 = v2(*(void *)(a1 + 40));
  }

  else
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 40);
    uint64_t v6 = 0LL;
    int v7 = &v6;
    uint64_t v8 = 0x2000000000LL;
    uint64_t v9 = 0LL;
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    _DWORD v5[2] = __to_array_error_request_block_invoke_2;
    v5[3] = &unk_189670D00;
    void v5[4] = &v6;
    securityd_send_sync_and_do(0xDu, v4, (uint64_t)&__block_literal_global_9004, (uint64_t)v5);
    uint64_t v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
}

BOOL __to_array_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v4 = SecXPCDictionaryCopyArray(a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return v4 != 0LL;
}

uint64_t __to_array_error_request_block_invoke()
{
  return 1LL;
}

BOOL SecItemBackupWithRegisteredViewBackup(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecItemBackupViewAndCopyBackupPeerID_block_invoke;
  activity_block[3] = &unk_189670D28;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate( &dword_1804F4000,  "SecItemBackupViewAndCopyBackupPeerID",  OS_ACTIVITY_FLAG_DEFAULT,  activity_block);
  unint64_t v2 = (const void *)v6[3];
  _Block_object_dispose(&v5, 8);
  if (v2) {
    CFRelease(v2);
  }
  return v2 != 0LL;
}

void __SecItemBackupViewAndCopyBackupPeerID_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 144)) != 0LL)
  {
    uint64_t v3 = v2(a1[5], a1[6]);
  }

  else
  {
    uint64_t v5 = a1[5];
    uint64_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = 0LL;
    void v6[4] = &v8;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __string_to_string_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_45_9008;
    void v7[4] = v5;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __string_to_string_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_189670D70;
    securityd_send_sync_and_do(0xEu, v4, (uint64_t)v7, (uint64_t)v6);
    uint64_t v3 = v9[3];
    _Block_object_dispose(&v8, 8);
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
}

BOOL __string_to_string_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"cfstring", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_string_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFStringRef v4 = SecXPCDictionaryCopyString(a2, a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return v4 != 0LL;
}

uint64_t SecItemBackupWithChanges(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t v53 = 0LL;
  unsigned int v54 = &v53;
  uint64_t v55 = 0x2000000000LL;
  char v56 = 1;
  uint64_t v49 = 0LL;
  uint64_t v50 = &v49;
  uint64_t v51 = 0x2000000000LL;
  __darwin_ino64_t v52 = 0LL;
  v48[0] = MEMORY[0x1895F87A8];
  v48[1] = 0x40000000LL;
  v48[2] = __SecItemBackupWithChanges_block_invoke;
  unint64_t v48[3] = &unk_189670A70;
  v48[5] = &v53;
  v48[6] = &v49;
  v48[4] = a3;
  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2000000000LL;
  *(_DWORD *)&buf[24] = -1;
  *(void *)&activity_block.st_dev = MEMORY[0x1895F87A8];
  activity_block.st_ino = 0x40000000LL;
  *(void *)&activity_block.st_uid = __SecItemBackupHandoffFD_block_invoke;
  *(void *)&activity_block.st_rdev = &unk_189670D98;
  activity_block.st_atimespec.tv_sec = (__darwin_time_t)buf;
  activity_block.st_atimespec.tv_nsec = a1;
  activity_block.st_mtimespec.tv_sec = (__darwin_time_t)&v52;
  _os_activity_initiate(&dword_1804F4000, "SecItemBackupHandoffFD", OS_ACTIVITY_FLAG_DEFAULT, &activity_block);
  int v6 = *(_DWORD *)(*(void *)&buf[8] + 24LL);
  _Block_object_dispose(buf, 8);
  if (v6 < 0)
  {
    uint64_t v14 = (os_log_s *)secLogObjForScope("backup");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      activity_block.st_dev = 67109378;
      *(_DWORD *)&activity_block.st_mode = v6;
      LOWORD(activity_block.st_ino) = 2112;
      *(__darwin_ino64_t *)((char *)&activity_block.st_ino + 2) = v52;
      _os_log_impl( &dword_1804F4000,  v14,  OS_LOG_TYPE_DEFAULT,  "SecItemBackupHandoffFD returned %d: %@",  (uint8_t *)&activity_block,  0x12u);
    }

    goto LABEL_7;
  }

  uint64_t v7 = lseek(v6, 0LL, 0);
  if (v7)
  {
    unint64_t v13 = @"lseek";
    goto LABEL_4;
  }

  CFIndex v16 = fdopen(v6, "r");
  if (!v16)
  {
    uint64_t v31 = (os_log_s *)secLogObjForScope("backup");
    BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
    if (v32)
    {
      int v38 = *__error();
      activity_block.st_dev = 138412546;
      *(void *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v38;
      _os_log_impl( &dword_1804F4000,  v31,  OS_LOG_TYPE_DEFAULT,  "Receiving file for %@ failed, %d",  (uint8_t *)&activity_block,  0x12u);
    }

    SecCheckErrno(v32, (CFTypeRef *)&v52, @"fdopen", v33, v34, v35, v36, v37, v47);
    if (!close(v6)) {
      goto LABEL_7;
    }
    uint64_t v39 = (os_log_s *)secLogObjForScope("backup");
    uint64_t v7 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v7)
    {
      int v40 = *__error();
      activity_block.st_dev = 138412546;
      *(void *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v40;
      _os_log_impl( &dword_1804F4000,  v39,  OS_LOG_TYPE_DEFAULT,  "Encountered error closing file %@: %d",  (uint8_t *)&activity_block,  0x12u);
    }

    unint64_t v13 = @"close";
    goto LABEL_4;
  }

  CFIndex v17 = v16;
  v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&activity_block.st_blksize = v18;
  *(timespec *)activity_block.st_qspare = v18;
  activity_block.st_birthtimespec = v18;
  *(timespec *)&activity_block.st_size = v18;
  activity_block.st_mtimespec = v18;
  activity_block.st_ctimespec = v18;
  *(timespec *)&activity_block.st_uid = v18;
  activity_block.st_atimespec = v18;
  *(timespec *)&activity_block.st_dev = v18;
  int v19 = fstat(v6, &activity_block);
  uint64_t v20 = (os_log_s *)secLogObjForScope("backup");
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (v21)
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      _os_log_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEFAULT, "Unable to get file metadata for %@, fd %d", buf, 0x12u);
    }

    SecCheckErrno(v21, (CFTypeRef *)&v52, @"fstat", v22, v23, v24, v25, v26, v47);
    if (!fclose(v17)) {
      goto LABEL_7;
    }
    uint64_t v27 = (os_log_s *)secLogObjForScope("backup");
    uint64_t v7 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v7)
    {
      int v28 = *__error();
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v28;
      _os_log_impl(&dword_1804F4000, v27, OS_LOG_TYPE_DEFAULT, "Encountered error closing file %@: %d", buf, 0x12u);
    }

    unint64_t v13 = @"fclose";
LABEL_4:
    SecCheckErrno(v7, (CFTypeRef *)&v52, v13, v8, v9, v10, v11, v12, v47);
LABEL_7:
    *((_BYTE *)v54 + 24) = 0;
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, void, void))(a3 + 16))(a3, 3LL, 0LL, 0LL);
    uint64_t v15 = (const void *)v50[3];
    if (v15)
    {
      if (a2 && !*a2) {
        *a2 = v15;
      }
      else {
        CFRelease(v15);
      }
    }

    goto LABEL_21;
  }

  if (v21)
  {
    *(_DWORD *)__int128 buf = 138412802;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = activity_block.st_size;
    _os_log_impl( &dword_1804F4000,  v20,  OS_LOG_TYPE_DEFAULT,  "Receiving file for %@ with fd %d of size %llu",  buf,  0x1Cu);
  }

  __SecItemBackupWithChanges_block_invoke((uint64_t)v48, v17);
  uint64_t v41 = fclose(v17);
  if ((_DWORD)v41) {
    SecCheckErrno(v41, (CFTypeRef *)&v52, @"fclose", v42, v43, v44, v45, v46, v47);
  }
  if (!*((_BYTE *)v54 + 24)) {
    goto LABEL_8;
  }
LABEL_21:
  uint64_t v29 = *((unsigned __int8 *)v54 + 24);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  return v29;
}

void __SecItemBackupWithChanges_block_invoke(uint64_t a1, FILE *a2)
{
  uint64_t v37 = (__CFString **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  uint64_t v3 = (unsigned __int8 *)malloc(0x10uLL);
  size_t v4 = 0LL;
  char v5 = 1;
  unint64_t v6 = 16LL;
  while (1)
  {
    size_t v7 = fread(&v3[v4], 1uLL, 16 - v4, a2);
    if (!v7) {
      break;
    }
    size_t v8 = v7 + v4;
    uint64_t v9 = &v3[v7 + v4];
    uint64_t v10 = (unsigned __int8 *)ccder_decode_tag();
    if (v10) {
      BOOL v11 = v10 >= v9;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
LABEL_29:
      BOOL v34 = SecError(-26275, v37, @"failed to decode backup event header");
      goto LABEL_30;
    }

    uint64_t v12 = v10 + 1;
    unint64_t v13 = *v10;
    if ((char)*v10 < 0)
    {
      if ((_DWORD)v13 == 131)
      {
        if (v9 - v12 < 3) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 4;
        unint64_t v13 = ((unint64_t)v10[1] << 16) | ((unint64_t)v10[2] << 8) | v10[3];
      }

      else if ((_DWORD)v13 == 130)
      {
        if (v9 - v12 < 2) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 3;
        unint64_t v13 = __rev16(*(unsigned __int16 *)(v10 + 1));
      }

      else
      {
        if ((_DWORD)v13 != 129 || v9 - v12 < 1) {
          goto LABEL_29;
        }
        uint64_t v12 = v10 + 2;
        unint64_t v13 = v10[1];
      }
    }

    int64_t v14 = v12 - v3;
    unint64_t v15 = v14 + v13;
    size_t v16 = v14 + v13 - v8;
    if (v14 + v13 > v8)
    {
      if (v6 >= v15)
      {
        CFIndex v17 = (char *)v3;
      }

      else
      {
        CFIndex v17 = (char *)realloc(v3, v14 + v13);
        unint64_t v6 = v15;
        if (!v17)
        {
          BOOL v34 = SecError(-108, v37, @"realloc buf failed");
LABEL_30:
          char v5 = v34;
          goto LABEL_37;
        }
      }

      size_t v18 = fread(&v17[v8], 1uLL, v16, a2);
      if (v18 < v16)
      {
        size_t v27 = v18;
        uint64_t v28 = feof(a2);
        if ((_DWORD)v28)
        {
          char v5 = SecError(-26275, v37, @"unexpected end of event file %zu of %zu bytes read", v27, v16);
        }

        else
        {
          SecCheckErrno(v28, (CFTypeRef *)v37, @"failed to read event body", v29, v30, v31, v32, v33, v35);
          char v5 = 0;
        }

        uint64_t v3 = (unsigned __int8 *)v17;
        goto LABEL_37;
      }

      uint64_t v3 = (unsigned __int8 *)v17;
    }

    int v19 = (char *)&v3[v15];
    ccder_decode_tag();
    BOOL v20 = SecError(-26275, v37, @"unsupported event tag: %lu", 0xAAAAAAAAAAAAAAAALL);
    if (v15 >= v8)
    {
      size_t v4 = 0LL;
    }

    else
    {
      size_t v4 = v8 - v15;
      memmove(v3, v19, v4);
    }

    v5 &= v20;
  }

  uint64_t v21 = feof(a2);
  if (!(_DWORD)v21)
  {
    SecCheckErrno(v21, (CFTypeRef *)v37, @"read backup event header", v22, v23, v24, v25, v26, v35);
    char v5 = 0;
  }

void __SecItemBackupHandoffFD_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 152)) != 0LL)
  {
    int v3 = v2(a1[5], a1[6]);
  }

  else
  {
    uint64_t v5 = a1[5];
    size_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    int v11 = -1;
    void v6[4] = &v8;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __string_to_fd_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_60_9031;
    void v7[4] = v5;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __string_to_fd_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_189670DE0;
    securityd_send_sync_and_do(0xFu, v4, (uint64_t)v7, (uint64_t)v6);
    int v3 = *((_DWORD *)v9 + 6);
    _Block_object_dispose(&v8, 8);
  }

  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
}

BOOL __string_to_fd_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"backup", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_fd_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  int v5 = xpc_dictionary_dup_fd(xdict, "status");
  if (v5 < 0) {
    SecError(-50, a3, @"missing fd for key %s", "status");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v5;
  return 1LL;
}

uint64_t SecItemBackupSetConfirmedManifest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = -86;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecItemBackupSetConfirmedManifest_block_invoke;
  activity_block[3] = &unk_189670A98;
  activity_block[4] = &v7;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  void activity_block[7] = a3;
  void activity_block[8] = a4;
  _os_activity_initiate(&dword_1804F4000, "SecItemBackupSetConfirmedManifest", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __SecItemBackupSetConfirmedManifest_block_invoke(void *a1)
{
  if (gSecurityd && (unint64_t v2 = *(uint64_t (**)(void, void, void, void))(gSecurityd + 160)) != 0LL)
  {
    uint64_t result = v2(a1[5], a1[6], a1[7], a1[8]);
  }

  else
  {
    uint64_t v5 = a1[7];
    uint64_t v4 = (CFTypeRef *)a1[8];
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __string_data_data_to_BOOL_error_request_block_invoke;
    unint64_t v6[3] = &__block_descriptor_tmp_86_9060;
    __int128 v7 = *(_OWORD *)(a1 + 5);
    uint64_t v8 = v5;
    uint64_t result = securityd_send_sync_and_do(0x10u, v4, (uint64_t)v6, (uint64_t)&__block_literal_global_88_9061);
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

void SecItemBackupRestore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = 0LL;
  char v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecItemBackupRestore_block_invoke;
  unint64_t v8[3] = &unk_189670AC0;
  v8[6] = a2;
  void v8[7] = a3;
  _BYTE v8[8] = a4;
  v8[9] = a5;
  void v8[4] = &v9;
  void v8[5] = a1;
  _os_activity_initiate(&dword_1804F4000, "SecItemBackupRestore", OS_ACTIVITY_FLAG_DEFAULT, v8);
  (*(void (**)(uint64_t, uint64_t))(a6 + 16))(a6, v10[3]);
  __int128 v7 = (const void *)v10[3];
  if (v7) {
    CFRelease(v7);
  }
  _Block_object_dispose(&v9, 8);
}

uint64_t __SecItemBackupRestore_block_invoke(void *a1)
{
  if (gSecurityd)
  {
    uint64_t v1 = *(uint64_t (**)(void, void, void, void, void, uint64_t))(gSecurityd + 168);
    if (v1) {
      return v1(a1[5], a1[6], a1[7], a1[8], a1[9], *(void *)(a1[4] + 8LL) + 24LL);
    }
  }

  uint64_t v3 = a1[9];
  uint64_t v4 = (CFTypeRef *)(*(void *)(a1[4] + 8LL) + 24LL);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __string_string_data_data_data_to_BOOL_error_request_block_invoke;
  unint64_t v6[3] = &__block_descriptor_tmp_89_9064;
  __int128 v5 = *(_OWORD *)(a1 + 7);
  __int128 v7 = *(_OWORD *)(a1 + 5);
  __int128 v8 = v5;
  uint64_t v9 = v3;
  return securityd_send_sync_and_do(0x11u, v4, (uint64_t)v6, (uint64_t)&__block_literal_global_91);
}

uint64_t SecBackupKeybagAdd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0LL;
  __int128 v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecBackupKeybagAdd_block_invoke;
  activity_block[3] = &unk_189670B30;
  activity_block[4] = &v7;
  activity_void block[5] = a4;
  void activity_block[6] = a1;
  void activity_block[7] = a2;
  void activity_block[8] = a3;
  _os_activity_initiate(&dword_1804F4000, "_SecServerBackupKeybagAdd", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __SecBackupKeybagAdd_block_invoke(uint64_t a1)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecBackupKeybagAdd_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_27_9068;
  uint64_t v1 = *(CFTypeRef **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 48);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecBackupKeybagAdd_block_invoke_3;
  v3[3] = &unk_189670B08;
  void v3[4] = *(void *)(a1 + 32);
  __int128 v4 = *(_OWORD *)(a1 + 56);
  return securityd_send_sync_and_do(0x6Fu, v1, (uint64_t)v5, (uint64_t)v3);
}

BOOL __SecBackupKeybagAdd_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  __int128 v4 = *(const __CFData **)(a1 + 32);
  return !v4 || SecXPCDictionarySetData(a2, "password", v4, a3);
}

uint64_t __SecBackupKeybagAdd_block_invoke_3(void *a1, xpc_object_t xdict, __CFString **a3)
{
  unint64_t v6 = (CFDataRef *)a1[5];
  size_t length = 0LL;
  if (xpc_dictionary_get_data(xdict, "backupKeybagID", &length))
  {
    CFDataRef v7 = SecXPCDictionaryCopyData(xdict, "backupKeybagID", a3);
    *unint64_t v6 = v7;
    if (!v7) {
      goto LABEL_12;
    }
  }

  else
  {
    *unint64_t v6 = 0LL;
  }

  __int128 v8 = (CFURLRef *)a1[6];
  size_t length = 0LL;
  if (!xpc_dictionary_get_data(xdict, "backupKeybagPath", &length))
  {
    CFURLRef *v8 = 0LL;
LABEL_11:
    LOBYTE(v7) = xpc_dictionary_get_BOOL(xdict, "status");
    goto LABEL_12;
  }

  uint64_t v9 = SecXPCDictionaryCopyData(xdict, "backupKeybagPath", a3);
  if (v9)
  {
    char v10 = v9;
    uint64_t v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t BytePtr = CFDataGetBytePtr(v9);
    CFIndex v13 = CFDataGetLength(v10);
    CFURLRef *v8 = CFURLCreateWithBytes(v11, BytePtr, v13, 0x8000100u, 0LL);
    CFRelease(v10);
  }

  if (*v8) {
    goto LABEL_11;
  }
  LOBYTE(v7) = 0;
LABEL_12:
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = (_BYTE)v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8LL) + 24LL);
}

uint64_t SecBackupKeybagDelete(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  unint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecBackupKeybagDelete_block_invoke;
  activity_block[3] = &unk_189670BA0;
  activity_void block[5] = a2;
  void activity_block[6] = a1;
  activity_block[4] = &v5;
  _os_activity_initiate(&dword_1804F4000, "_SecBackupKeybagDelete", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecBackupKeybagDelete_block_invoke(void *a1)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecBackupKeybagDelete_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_30_9072;
  uint64_t v1 = (CFTypeRef *)a1[5];
  void v4[4] = a1[6];
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecBackupKeybagDelete_block_invoke_3;
  v3[3] = &unk_189670B78;
  void v3[4] = a1[4];
  return securityd_send_sync_and_do(0x70u, v1, (uint64_t)v4, (uint64_t)v3);
}

size_t __SecBackupKeybagDelete_block_invoke_2( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __SecBackupKeybagDelete_block_invoke_3(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

__CFData *SecKeyCopyPublicKeyHash(const void *a1)
{
  CFDataRef theData = 0LL;
  int v2 = SecKeyCopyPublicBytes((uint64_t)a1, (uint64_t)&theData);
  uint64_t v3 = 0LL;
  CFDataRef v4 = theData;
  if (!v2 && theData)
  {
    uint64_t v5 = CFGetAllocator(a1);
    uint64_t BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    uint64_t v3 = SecSHA1DigestCreate(v5, (uint64_t)BytePtr, Length);
    CFDataRef v4 = theData;
  }

  if (v4)
  {
    CFDataRef theData = 0LL;
    CFRelease(v4);
  }

  return v3;
}

uint64_t _SecKeyCheck(uint64_t result, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!result)
  {
    _SECKEY_LOG_9790();
    uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v5 = a2;
      _os_log_fault_impl(&dword_1804F4000, v3, OS_LOG_TYPE_FAULT, "%{public}s called with NULL SecKeyRef", buf, 0xCu);
    }

    return objc_msgSend( MEMORY[0x189603F70],  "raise:format:",  *MEMORY[0x189603A60],  @"%s called with NULL SecKeyRef",  a2);
  }

  return result;
}

id _SECKEY_LOG_9790()
{
  if (_SECKEY_LOG_once_9794 != -1) {
    dispatch_once(&_SECKEY_LOG_once_9794, &__block_literal_global_9795);
  }
  return (id)_SECKEY_LOG_log_9796;
}

CFDictionaryRef SecKeyCopyAttributeDictionaryWithLocalKey(const void *a1, uint64_t a2, const __CFData *a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v6 = CFGetAllocator(a1);
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)keys = v7;
  __int128 v37 = v7;
  __int128 v38 = v7;
  __int128 v39 = v7;
  __int128 v40 = v7;
  __int128 v41 = v7;
  __int128 v42 = v7;
  __int128 v43 = v7;
  __int128 v44 = v7;
  __int128 v45 = v7;
  __int128 v46 = v7;
  __int128 v47 = v7;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)values = v7;
  __int128 v24 = v7;
  __int128 v25 = v7;
  __int128 v26 = v7;
  __int128 v27 = v7;
  __int128 v28 = v7;
  __int128 v29 = v7;
  __int128 v30 = v7;
  __int128 v31 = v7;
  __int128 v32 = v7;
  __int128 v33 = v7;
  __int128 v34 = v7;
  unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
  CFDataRef theData = 0LL;
  uint64_t Size = SecKeyGetSize((uint64_t)a1, 0);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberLongType, &Size);
  if (!theData)
  {
    CFDictionaryRef v19 = 0LL;
    if (!v8) {
      return v19;
    }
    goto LABEL_18;
  }

  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v11 = SecSHA1DigestCreate(v6, (uint64_t)BytePtr, Length);
  if (!v11)
  {
LABEL_20:
    CFDictionaryRef v19 = 0LL;
  }

  else
  {
    uint64_t v12 = v11;
    keys[0] = @"class";
    keys[1] = @"kcls";
    CFIndex v13 = @"1";
    if (!a3) {
      CFIndex v13 = @"0";
    }
    values[0] = @"keys";
    values[1] = (void *)v13;
    *(void *)&__int128 v37 = @"klbl";
    *((void *)&v37 + 1) = @"perm";
    uint64_t v14 = *MEMORY[0x189604DE8];
    *(void *)&__int128 v24 = v11;
    *((void *)&v24 + 1) = v14;
    *(void *)&__int128 v38 = @"priv";
    *((void *)&v38 + 1) = @"modi";
    *(void *)&__int128 v25 = v14;
    *((void *)&v25 + 1) = v14;
    *(void *)&__int128 v39 = @"type";
    *((void *)&v39 + 1) = @"bsiz";
    *(void *)&__int128 v26 = a2;
    *((void *)&v26 + 1) = v8;
    *(void *)&__int128 v40 = @"esiz";
    *((void *)&v40 + 1) = @"sens";
    uint64_t v15 = *MEMORY[0x189604DE0];
    *(void *)&__int128 v27 = v8;
    *((void *)&v27 + 1) = v15;
    *(void *)&__int128 v41 = @"asen";
    *((void *)&v41 + 1) = @"extr";
    *(void *)&__int128 v28 = v15;
    *((void *)&v28 + 1) = v14;
    *(void *)&__int128 v42 = @"next";
    *((void *)&v42 + 1) = @"encr";
    if (a3) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v14;
    }
    *(void *)&__int128 v29 = v15;
    *((void *)&v29 + 1) = v16;
    if (a3) {
      uint64_t v17 = v14;
    }
    else {
      uint64_t v17 = v15;
    }
    *(void *)&__int128 v43 = @"decr";
    *((void *)&v43 + 1) = @"drve";
    *(void *)&__int128 v30 = v17;
    *((void *)&v30 + 1) = v14;
    *(void *)&__int128 v44 = @"sign";
    *((void *)&v44 + 1) = @"vrfy";
    *(void *)&__int128 v31 = v17;
    *((void *)&v31 + 1) = v16;
    *(void *)&__int128 v45 = @"snrc";
    *((void *)&v45 + 1) = @"vyrc";
    *(void *)&__int128 v32 = v15;
    *((void *)&v32 + 1) = v15;
    *(void *)&__int128 v46 = @"wrap";
    *((void *)&v46 + 1) = @"unwp";
    *(void *)&__int128 v33 = v16;
    *((void *)&v33 + 1) = v17;
    *(void *)&__int128 v47 = @"v_Data";
    CFDataRef v18 = theData;
    if (a3) {
      CFDataRef v18 = a3;
    }
    *(void *)&__int128 v34 = v18;
    CFDictionaryRef v19 = CFDictionaryCreate( v6,  (const void **)keys,  (const void **)values,  23LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFRelease(v12);
  }

  if (theData) {
    CFRelease(theData);
  }
  if (v8) {
LABEL_18:
  }
    CFRelease(v8);
  return v19;
}

uint64_t SecKeyGetSize(uint64_t a1, int a2)
{
  CFDataRef v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v4) {
    unint64_t v5 = v4(a1);
  }
  else {
    unint64_t v5 = 0LL;
  }
  if (SecKeyGetAlgorithmId(a1) == 3)
  {
    if (a2 == 10 || a2 == 0) {
      int v7 = 0;
    }
    else {
      int v7 = a2;
    }
    if (v7)
    {
      uint64_t v8 = 8LL;
      if (v5 > 0x41) {
        uint64_t v8 = 9LL;
      }
      unint64_t v9 = v8 + 2 * v5;
      if (v7 == 2) {
        unint64_t v10 = 0LL;
      }
      else {
        unint64_t v10 = v5;
      }
      if (v7 == 1) {
        unint64_t v5 = v9;
      }
      else {
        unint64_t v5 = v10;
      }
    }

    else if (v5 > 0x41)
    {
      return 521LL;
    }
  }

  if (a2 == 10 || !a2) {
    v5 *= 8LL;
  }
  return v5;
}

CFDictionaryRef SecKeyGeneratePublicAttributeDictionary(const void *a1, uint64_t a2)
{
  return SecKeyCopyAttributeDictionaryWithLocalKey(a1, a2, 0LL);
}

uint64_t __SecKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SecKeyEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != *(void *)(a2 + 16)) {
    return 0LL;
  }
  if (*(_DWORD *)v3 >= 4u)
  {
    unint64_t v5 = *(uint64_t (**)(void))(v3 + 160);
    if (v5) {
      return v5();
    }
  }

  size_t v6 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v6) {
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v6) == 0;
  }
  CFDictionaryRef v7 = SecKeyCopyAttributes((SecKeyRef)a1);
  CFDictionaryRef v8 = SecKeyCopyAttributes((SecKeyRef)a2);
  CFDictionaryRef v9 = v8;
  if (!v7 || !v8)
  {
    if (v7) {
      CFRelease(v7);
    }
    if (v9) {
      CFRelease(v9);
    }
    return 0LL;
  }

  uint64_t v10 = CFEqual(v7, v8);
  CFRelease(v7);
  CFRelease(v9);
  return v10;
}

CFStringRef SecKeyCopyDescription(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 96LL);
  if (v1) {
    return (CFStringRef)v1();
  }
  else {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SecKeyRef: %p>", a1);
  }
}

CFDictionaryRef SecKeyCopyAttributes(SecKeyRef key)
{
  int v2 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v3 = _os_activity_create(&dword_1804F4000, "SecKeyCopyAttributes", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyAttributes");
  CFDataRef v4 = *(uint64_t (**)(SecKeyRef))(*((void *)key + 2) + 88LL);
  if (v4)
  {
    CFMutableDictionaryRef Mutable = (__CFDictionary *)v4(key);
    goto LABEL_14;
  }

  size_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFDictionaryRef v7 = *(uint64_t (**)(SecKeyRef))(*((void *)key + 2) + 80LL);
  if (v7)
  {
    uint64_t valuePtr = 8 * v7(key);
    if (valuePtr >= 1)
    {
      CFNumberRef v8 = CFNumberCreate(v6, kCFNumberCFIndexType, &valuePtr);
      CFDictionarySetValue(Mutable, @"bsiz", v8);
      CFRelease(v8);
    }
  }

  else
  {
    uint64_t valuePtr = 0LL;
  }

  unint64_t v9 = SecKeyGetAlgorithmId((uint64_t)key) - 1;
  if (v9 <= 6 && ((0x7Du >> v9) & 1) != 0) {
    CFDictionarySetValue(Mutable, @"type", *off_1896719C0[v9]);
  }
  uint64_t v10 = (void *)*((void *)key + 2);
  if (v10[5] || v10[8])
  {
    uint64_t v11 = (const void **)&kSecAttrKeyClassPrivate;
LABEL_13:
    CFDictionarySetValue(Mutable, @"kcls", *v11);
    goto LABEL_14;
  }

  if (v10[6] || v10[7])
  {
    uint64_t v11 = (const void **)&kSecAttrKeyClassPublic;
    goto LABEL_13;
  }

void sub_1805CE900( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

OSStatus SecKeyGeneratePair(CFDictionaryRef parameters, SecKeyRef *publicKey, SecKeyRef *privateKey)
{
  CFErrorRef error = 0LL;
  SecKeyRef v5 = SecKeyCreateRandomKey(parameters, &error);
  size_t v6 = v5;
  if (v5)
  {
    if (privateKey) {
      *privateKey = v5;
    }
    OSStatus Code = 0;
    if (publicKey) {
      *publicKey = SecKeyCopyPublicKey(v6);
    }
  }

  else
  {
    OSStatus Code = CFErrorGetCode(error);
    if (error) {
      CFRelease(error);
    }
  }

  return Code;
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  __int128 context = (void *)MEMORY[0x186DFF9D0]();
  CFDataRef v4 = _os_activity_create(&dword_1804F4000, "SecKeyCreateRandomKey", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  SecKeyRef key = 0LL;
  __int128 v40 = 0LL;
  CFTypeRef cf = 0LL;
  SecKeyRef v5 = merge_params(parameters, @"public");
  size_t v6 = merge_params(parameters, @"private");
  unint64_t Value = CFDictionaryGetValue(parameters, @"type");
  if (CFDictionaryGetValue(parameters, @"tkid"))
  {
    CFNumberRef v8 = (void *)-[__CFDictionary mutableCopy](parameters, "mutableCopy", context);
    uint64_t v9 = [v8 objectForKeyedSubscript:@"private"];
    uint64_t v10 = (void *)v9;
    uint64_t v11 = (void *)MEMORY[0x189604A60];
    if (v9) {
      uint64_t v11 = (void *)v9;
    }
    id v12 = v11;

    [v8 removeObjectForKey:@"private"];
    [v8 removeObjectForKey:@"public"];
    CFIndex v13 = (void *)[v12 mutableCopy];
    [v13 addEntriesFromDictionary:v8];
    uint64_t v14 = objc_alloc(&OBJC_CLASS___SecCTKKey);
    *(void *)__int128 buf = 0LL;
    uint64_t v15 = -[SecCTKKey initWithAttributes:error:](v14, "initWithAttributes:error:", v13, buf);
    id v16 = *(id *)buf;
    uint64_t v17 = v16;
    if (v15)
    {
      CFDataRef v18 = (__SecKey *)SecKeyCreate(*MEMORY[0x189604DB0], (uint64_t)&kSecCTKKeyDescriptor, 0LL, 0LL, 0LL);
      *((void *)v18 + 3) = v15;
    }

    else
    {
      CFDataRef v18 = 0LL;
      __int128 v40 = (__CFString *)v16;
    }

    SecKeyRef key = v18;
    int OSStatus = SecErrorGetOSStatus((uint64_t)v40);
    SecError(OSStatus, &v40, @"Failed to generate keypair", contexta);
    goto LABEL_15;
  }

  if (!Value) {
    goto LABEL_48;
  }
  if (CFEqual(Value, @"73"))
  {
    int v19 = SecECKeyGeneratePair((uint64_t)parameters, &cf, &key);
    goto LABEL_9;
  }

  if (!CFEqual(Value, @"42"))
  {
    if (CFEqual(Value, @"105"))
    {
      uint64_t v31 = 4LL;
LABEL_40:
      int v19 = curve25519KeyGeneratePair((uint64_t)parameters, &cf, &key, v31);
      goto LABEL_9;
    }

    if (CFEqual(Value, @"106"))
    {
      uint64_t v31 = 5LL;
      goto LABEL_40;
    }

    if (CFEqual(Value, @"107"))
    {
      uint64_t v33 = 6LL;
LABEL_45:
      int v19 = curve448KeyGeneratePair((uint64_t)parameters, &cf, &key, v33);
      goto LABEL_9;
    }

    if (CFEqual(Value, @"108"))
    {
      uint64_t v33 = 7LL;
      goto LABEL_45;
    }

    if (CFEqual(Value, @"109"))
    {
      int v19 = SecKyberKeyGeneratePair(parameters, &cf, &key);
LABEL_9:
      int v20 = v19;
      if (!v19) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }

void sub_1805CEF08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  int v2 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v3 = _os_activity_create(&dword_1804F4000, "SecKeyCopyPublicKey", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyPublicKey");
  uint64_t v4 = *((void *)key + 2);
  if (*(_DWORD *)v4 < 4u
    || (SecKeyRef v5 = *(uint64_t (**)(SecKeyRef))(v4 + 144)) == 0LL
    || (size_t v6 = (__SecKey *)v5(key)) == 0LL)
  {
    CFTypeRef cf = 0LL;
    int v7 = SecKeyCopyPublicBytes((uint64_t)key, (uint64_t)&cf);
    size_t v6 = 0LL;
    CFTypeRef v8 = cf;
    if (!v7 && cf)
    {
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      uint64_t v9 = SecCFAllocatorZeroize_sAllocator;
      uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
      size_t v6 = (__SecKey *)SecKeyCreateFromPublicData(v9, AlgorithmId, (CFDataRef)cf);
      CFTypeRef v8 = cf;
    }

    if (v8) {
      CFRelease(v8);
    }
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return v6;
}

void sub_1805CF080( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

void *SecKeyCreateFromPublicData(uint64_t a1, uint64_t a2, CFDataRef theData)
{
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  return SecKeyCreateFromPublicBytes(a1, a2, (uint64_t)BytePtr, Length);
}

void *SecKeyCreateFromPublicBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  switch(a2)
  {
    case 1LL:
      uint64_t v4 = &kSecRSAPublicKeyDescriptor;
      goto LABEL_11;
    case 3LL:
      uint64_t v4 = &kSecECPublicKeyDescriptor;
      goto LABEL_11;
    case 4LL:
      uint64_t v4 = &kSecEd25519PublicKeyDescriptor;
      goto LABEL_11;
    case 5LL:
      uint64_t v4 = &kSecX25519PublicKeyDescriptor;
      goto LABEL_11;
    case 6LL:
      uint64_t v4 = &kSecEd448PublicKeyDescriptor;
      goto LABEL_11;
    case 7LL:
      uint64_t v4 = &kSecX448PublicKeyDescriptor;
LABEL_11:
      uint64_t v6 = 7LL;
      goto LABEL_9;
    case 8LL:
      uint64_t v4 = &kSecKyberPublicKeyDescriptor;
      uint64_t v6 = 0LL;
LABEL_9:
      uint64_t result = SecKeyCreate(a1, (uint64_t)v4, a3, a4, v6);
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

CFMutableDictionaryRef merge_params(const __CFDictionary *a1, const void *a2)
{
  unint64_t Value = (const __CFDictionary *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, Value);
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)merge_params_applier, MutableCopy);
  }

  else
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a1);
  }

  CFDictionaryRemoveValue(MutableCopy, @"public");
  CFDictionaryRemoveValue(MutableCopy, @"private");
  CFDictionaryRemoveValue(MutableCopy, @"type");
  CFDictionaryRemoveValue(MutableCopy, @"bsiz");
  return MutableCopy;
}

BOOL getBoolForKey(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  unint64_t Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"perm");
  if (Value)
  {
    uint64_t v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
    {
      return CFBooleanGetValue(v4) != 0;
    }

    else
    {
      _SECKEY_LOG_9790();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v8 = 138543618;
        uint64_t v9 = v4;
        __int16 v10 = 2114;
        uint64_t v11 = @"perm";
        _os_log_error_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_ERROR,  "Value %{public}@ for key %{public}@ is not BOOL",  (uint8_t *)&v8,  0x16u);
      }
    }
  }

  return a2;
}

BOOL add_key(void *value, CFMutableDictionaryRef theDict, __CFString **a3)
{
  uint64_t v6 = SecKeyCopyAttributes((SecKeyRef)value);
  if (v6)
  {
    int v7 = v6;
    if (CFDictionaryContainsKey(v6, @"accc")) {
      CFDictionaryRemoveValue(theDict, @"accc");
    }
    CFRelease(v7);
  }

  CFDictionaryRemoveValue(theDict, @"applepay");
  CFDictionaryRemoveValue(theDict, @"osbound");
  CFDictionaryRemoveValue(theDict, @"sealedhashesbound");
  OSStatus v8 = SecItemAdd(theDict, 0LL);
  return SecError(v8, a3, @"failed to add key to keychain: %@", value);
}

uint64_t _SecKeyErrorPropagate(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if ((a1 & 1) == 0)
  {
    _SECKEY_LOG_9790();
    OSStatus v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136446466;
      uint64_t v11 = a2;
      __int16 v12 = 2114;
      CFIndex v13 = a3;
      _os_log_error_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s failed: %{public}@",  (uint8_t *)&v10,  0x16u);
    }

    if (a4) {
      *a4 = a3;
    }
    else {
      CFRelease(a3);
    }
  }

  return a1;
}

void merge_params_applier(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

CFDictionaryRef CreatePrivateKeyMatchingQuery(const void *a1)
{
  uint64_t v1 = SecKeyCopyPublicKeyHash(a1);
  CFDictionaryRef v9 = CFDictionaryCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  v2,  v3,  v4,  v5,  v6,  v7,  v8,  (uint64_t)@"class",  (uint64_t)@"keys");
  if (v1) {
    CFRelease(v1);
  }
  return v9;
}

CFTypeRef SecKeyCreatePersistentRefToMatchingPrivateKey(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0LL;
  PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  OSStatus v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  SecError(v5, a2, @"Error finding persistent ref to key from public: %@", a1);
  if (PrivateKeyMatchingQuery) {
    CFRelease(PrivateKeyMatchingQuery);
  }
  return result;
}

CFTypeRef SecKeyCopyMatchingPrivateKey(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0LL;
  if (!a1)
  {
    SecError(-50, a2, @"Null Public Key");
    return 0LL;
  }

  PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  OSStatus v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  if (!SecError(v5, a2, @"Error finding private key from public: %@", a1)
    || (CFTypeID v6 = CFGetTypeID(result), v6 != SecKeyGetTypeID()))
  {
    CFTypeRef v7 = 0LL;
    if (!PrivateKeyMatchingQuery) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  CFTypeRef v7 = result;
  CFTypeRef result = 0LL;
  if (PrivateKeyMatchingQuery) {
LABEL_7:
  }
    CFRelease(PrivateKeyMatchingQuery);
LABEL_8:
  CFTypeRef v8 = result;
  if (result)
  {
    CFTypeRef result = 0LL;
    CFRelease(v8);
  }

  return v7;
}

uint64_t SecKeyGetMatchingPrivateKeyStatus(const void *a1, __CFString **a2)
{
  CFTypeRef result = 0LL;
  if (a1)
  {
    PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
    uint64_t v3 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
    if (!(_DWORD)v3)
    {
      CFTypeID v4 = CFGetTypeID(result);
      if (v4 == SecKeyGetTypeID()) {
        uint64_t v3 = 0LL;
      }
      else {
        uint64_t v3 = 4294965226LL;
      }
    }

    if (PrivateKeyMatchingQuery) {
      CFRelease(PrivateKeyMatchingQuery);
    }
    CFTypeRef v5 = result;
    if (result)
    {
      CFTypeRef result = 0LL;
      CFRelease(v5);
    }
  }

  else
  {
    uint64_t v3 = 4294967246LL;
    SecError(-50, a2, 0LL, @"Null Public Key");
  }

  return v3;
}

void *SecKeyCreatePublicFromDER(uint64_t a1, SecAsn1Oid *oid1, uint64_t *a3, uint64_t *a4)
{
  if (SecAsn1OidCompare(oid1, &CSSMOID_RSA)) {
    return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a4[1], *a4, 1LL);
  }
  if (SecAsn1OidCompare(oid1, &CSSMOID_ecPublicKey))
  {
    size_t Length = oid1->Length;
    v13[0] = oid1->Data;
    v13[1] = Length;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v10 = *a4;
    uint64_t v16 = a4[1];
    uint64_t v17 = v10;
    if (a3)
    {
      uint64_t v11 = *a3;
      uint64_t v14 = a3[1];
      uint64_t v15 = v11;
    }

    return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, (uint64_t)v13, 48LL, 4LL);
  }

  else
  {
    _SECKEY_LOG_9790();
    __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v13[0]) = 0;
      _os_log_debug_impl(&dword_1804F4000, v12, OS_LOG_TYPE_DEBUG, "Unsupported algorithm oid", (uint8_t *)v13, 2u);
    }

    return 0LL;
  }

OSStatus SecKeyRawSign( SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, dataToSignLen);
  if (!SignatureAlgorithmForPadding) {
    return -50;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyRawSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = key;
  v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(dataToSign, dataToSignLen, 0LL, 0LL, sig, (CFIndex *)sigLen, v13);
}

CFStringRef SecKeyGetSignatureAlgorithmForPadding(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  if (AlgorithmId == 3)
  {
    if (a2 == 0x4000) {
      return @"algid:sign:ECDSA:digest-RFC4754";
    }
    if (a2 != 1) {
      return @"algid:sign:ECDSA:digest-X962";
    }
    if (*(void *)ccsha1_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA1";
    }
    if (*(void *)ccsha224_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA224";
    }
    if (*(void *)ccsha256_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA256";
    }
    if (*(void *)ccsha384_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA384";
    }
    if (*(void *)ccsha512_di() == a3) {
      return @"algid:sign:ECDSA:digest-X962:SHA512";
    }
    else {
      return @"algid:sign:ECDSA:digest-X962";
    }
  }

  else if (AlgorithmId == 1)
  {
    switch(a2)
    {
      case 32770:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA1";
        break;
      case 32771:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA224";
        break;
      case 32772:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA256";
        break;
      case 32773:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA384";
        break;
      case 32774:
        CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15:SHA512";
        break;
      default:
        CFTypeRef v7 = @"algid:sign:RSA:raw";
        if (a2) {
          CFTypeRef v7 = 0LL;
        }
        if (a2 == 1) {
          CFTypeRef result = @"algid:sign:RSA:digest-PKCS1v15";
        }
        else {
          CFTypeRef result = v7;
        }
        break;
    }
  }

  else
  {
    return 0LL;
  }

  return result;
}

CFDataRef __SecKeyRawSign_block_invoke(uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

uint64_t SecKeyPerformLegacyOperation( const UInt8 *a1, CFIndex a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6, void *a7)
{
  CFTypeRef cf = 0LL;
  CFIndex v13 = (const __CFAllocator *)*MEMORY[0x189604DC8];
  uint64_t v14 = a7;
  CFDataRef v15 = CFDataCreateWithBytesNoCopy(0LL, a1, a2, v13);
  CFDataRef v16 = CFDataCreateWithBytesNoCopy(0LL, a3, a4, v13);
  CFRange range = (CFRange)xmmword_18065A2B0;
  uint64_t v17 = (const void *)v14[2](v14, v15, v16, &range, &cf);

  if (!v17 || (CFTypeID v18 = CFGetTypeID(v17), TypeID = CFDataGetTypeID(), !a6) || v18 != TypeID)
  {
LABEL_8:
    if (!v15) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  v20.size_t length = range.length;
  if (range.length == -1)
  {
    v20.size_t length = CFDataGetLength((CFDataRef)v17);
    range.size_t length = v20.length;
  }

  if (v20.length <= (unint64_t)*a6)
  {
    *a6 = v20.length;
    v20.location = range.location;
    CFDataGetBytes((CFDataRef)v17, v20, a5);
    goto LABEL_8;
  }

  SecError(-50, (__CFString **)&cf, @"buffer too small (required %d, provided %d)", v20.length, *a6);
  if (v15) {
LABEL_9:
  }
    CFRelease(v15);
LABEL_10:
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (!cf) {
    return 0LL;
  }
  unsigned int OSStatus = SecErrorGetOSStatus((uint64_t)cf);
  if (OSStatus == -67808) {
    uint64_t v22 = 4294957487LL;
  }
  else {
    uint64_t v22 = OSStatus;
  }
  CFRelease(cf);
  return v22;
}

CFDataRef SecKeyCreateSignature( SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error)
{
  CFTypeRef v8 = (void *)MEMORY[0x186DFF9D0]();
  CFDictionaryRef v9 = _os_activity_create(&dword_1804F4000, "SecKeyCreateSignature", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCreateSignature");
  if (!dataToSign) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCreateSignature() called with NULL dataToSign"];
  }
  uint64_t v17 = 0LL;
  v14[0] = (uint64_t)key;
  v14[1] = 0LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, algorithm);
  CFTypeRef cf = Mutable;
  uint64_t v16 = 0LL;
  uint64_t v11 = SecKeyRunAlgorithmAndCopyResult(v14, dataToSign, 0LL, &v17);
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v12);
  }

  _SecKeyErrorPropagate(v11 != 0LL, (uint64_t)"SecKeyCreateSignature", v17, error);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_1805CFDA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

__CFData *SecKeyRunAlgorithmAndCopyResult( uint64_t *a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  CFTypeRef v8 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1[2]);
  CFIndex v10 = Count - 1;
  if (Count > 1)
  {
    CFIndex v11 = Count;
    CFIndex v12 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v12++);
      if (v12 < v11) {
        break;
      }
LABEL_7:
      if (v12 == v10) {
        goto LABEL_8;
      }
    }

    uint64_t v14 = ValueAtIndex;
    CFIndex v15 = v12;
    while (1)
    {
      uint64_t v16 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v15);
      if (CFEqual(v14, v16)) {
        break;
      }
      if (v11 == ++v15) {
        goto LABEL_7;
      }
    }

OSStatus SecKeyRawVerify( SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, signedDataLen);
  if (!SignatureAlgorithmForPadding) {
    return -50;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyRawVerify_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = key;
  v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(signedData, signedDataLen, sig, sigLen, 0LL, 0LL, v13);
}

uint64_t __SecKeyRawVerify_block_invoke( uint64_t a1, CFDataRef signedData, CFDataRef signature, uint64_t a4, CFErrorRef *a5)
{
  if (SecKeyVerifySignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), signedData, signature, a5)) {
    return *MEMORY[0x189604DE8];
  }
  else {
    return 0LL;
  }
}

Boolean SecKeyVerifySignature( SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  CFIndex v10 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v11 = _os_activity_create(&dword_1804F4000, "SecKeyVerifySignature", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyVerifySignature");
  if (!signedData) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyVerifySignature() called with NULL signedData"];
  }
  if (!signature) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyVerifySignature() called with NULL signature"];
  }
  uint64_t v22 = 0LL;
  v19[0] = (uint64_t)key;
  v19[1] = 1LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, algorithm);
  CFTypeRef cf = Mutable;
  uint64_t v21 = 0LL;
  CFIndex v13 = SecKeyRunAlgorithmAndCopyResult(v19, signedData, signature, &v22);
  uint64_t v14 = v13;
  CFIndex v15 = (__CFData *)*MEMORY[0x189604DE8];
  if (v13 && v15)
  {
    BOOL v16 = CFEqual(v13, v15) != 0;
  }

  else
  {
    BOOL v16 = v13 == v15;
    if (!v13) {
      goto LABEL_10;
    }
  }

  CFRelease(v14);
LABEL_10:
  CFTypeRef v17 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v17);
  }

  _SecKeyErrorPropagate(v16, (uint64_t)"SecKeyVerifySignature", v22, error);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v16;
}

void sub_1805D05E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

OSStatus SecKeyEncrypt( SecKeyRef key, SecPadding padding, const uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  OSStatus result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    uint64_t v14 = off_189679108[padding];
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    unint64_t v15[2] = __SecKeyEncrypt_block_invoke;
    unint64_t v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    void v15[4] = key;
    void v15[5] = v14;
    return SecKeyPerformLegacyOperation(plainText, plainTextLen, 0LL, 0LL, cipherText, (CFIndex *)cipherTextLen, v15);
  }

  return result;
}

__CFData *SecKeyCreateEncryptedDataWithParameters( uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, void *a5)
{
  CFIndex v10 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v11 = _os_activity_create( &dword_1804F4000,  "SecKeyCreateEncryptedDataWithParameters",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateEncryptedDataWithParameters");
  if (!a3) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCreateEncryptedData() called with NULL plaintext"];
  }
  uint64_t v19 = 0LL;
  v16[0] = a1;
  v16[1] = 2LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v18 = 0LL;
  CFIndex v13 = SecKeyRunAlgorithmAndCopyResult(v16, a3, a4, &v19);
  CFTypeRef v14 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v14);
  }

  _SecKeyErrorPropagate(v13 != 0LL, (uint64_t)"SecKeyCreateEncryptedDataWithParameters", v19, a5);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v13;
}

void sub_1805D0828( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

CFDataRef SecKeyCreateEncryptedData( SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef plaintext, CFErrorRef *error)
{
  return SecKeyCreateEncryptedDataWithParameters((uint64_t)key, algorithm, plaintext, 0LL, error);
}

OSStatus SecKeyDecrypt( SecKeyRef key, SecPadding padding, const uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  OSStatus result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    CFTypeRef v14 = off_189679120[padding];
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    unint64_t v15[2] = __SecKeyDecrypt_block_invoke;
    unint64_t v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    void v15[4] = key;
    void v15[5] = v14;
    return SecKeyPerformLegacyOperation(cipherText, cipherTextLen, 0LL, 0LL, plainText, (CFIndex *)plainTextLen, v15);
  }

  return result;
}

__CFData *SecKeyCreateDecryptedDataWithParameters( uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, void *a5)
{
  CFIndex v10 = (void *)MEMORY[0x186DFF9D0]();
  CFIndex v11 = _os_activity_create( &dword_1804F4000,  "SecKeyCreateDecryptedDataWithParameters",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecryptedDataWithParameters");
  if (!a3) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCreateDecryptedData() called with NULL ciphertext"];
  }
  uint64_t v19 = 0LL;
  v16[0] = a1;
  v16[1] = 3LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v18 = 0LL;
  CFIndex v13 = SecKeyRunAlgorithmAndCopyResult(v16, a3, a4, &v19);
  CFTypeRef v14 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v14);
  }

  _SecKeyErrorPropagate(v13 != 0LL, (uint64_t)"SecKeyCreateDecryptedDataWithParameters", v19, a5);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v13;
}

void sub_1805D0B04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

CFDataRef SecKeyCreateDecryptedData( SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef ciphertext, CFErrorRef *error)
{
  return SecKeyCreateDecryptedDataWithParameters((uint64_t)key, algorithm, ciphertext, 0LL, error);
}

size_t SecKeyGetBlockSize(SecKeyRef key)
{
  int v2 = *(uint64_t (**)(SecKeyRef))(*((void *)key + 2) + 80LL);
  if (v2) {
    return v2(key);
  }
  else {
    return 0LL;
  }
}

SecKeyRef SecKeyCreateFromAttributeDictionary(const __CFDictionary *a1)
{
  CFErrorRef error = 0LL;
  unint64_t Value = (const __CFData *)CFDictionaryGetValue(a1, @"v_Data");
  SecKeyRef v3 = SecKeyCreateWithData(Value, a1, &error);
  if (!v3) {
    CFRelease(error);
  }
  return v3;
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  *(void *)&v55[5] = *MEMORY[0x1895F89C0];
  CFTypeID v6 = (void *)MEMORY[0x186DFF9D0]();
  CFTypeRef v7 = _os_activity_create(&dword_1804F4000, "SecKeyCreateWithData", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v8 = SecCFAllocatorZeroize_sAllocator;
  unint64_t Value = CFDictionaryGetValue(attributes, @"tkid");
  if (!Value)
  {
    if (!keyData)
    {
      SecError(-50, (__CFString **)error, @"Failed to provide key data to SecKeyCreateWithData");
LABEL_27:
      CTKKey = 0LL;
      goto LABEL_28;
    }

    CFIndex v13 = (void *)CFDictionaryGetValue(attributes, @"type");
    uint64_t v14 = SecKeyParamsAsInt64(v13, (uint64_t)@"key type", (__CFString **)error);
    if ((v14 & 0x8000000000000000LL) == 0)
    {
      CFIndex v15 = (void *)CFDictionaryGetValue(attributes, @"kcls");
      uint64_t v16 = SecKeyParamsAsInt64(v15, (uint64_t)@"key class", (__CFString **)error);
      int v17 = v16;
      if (v16 < 0) {
        goto LABEL_25;
      }
      if (v16 == 2)
      {
        SecError(-4, (__CFString **)error, @"Unsupported symmetric key type: %@", v13);
        goto LABEL_25;
      }

      if (v16 == 1)
      {
        if (v14 <= 104)
        {
          if (v14 == 42)
          {
            uint64_t BytePtr = CFDataGetBytePtr(keyData);
            CFIndex Length = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecRSAPrivateKeyDescriptor, (uint64_t)BytePtr, Length, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"RSA private key creation from data failed");
          }

          else if (v14 == 43 || v14 == 73)
          {
            uint64_t v23 = CFDataGetBytePtr(keyData);
            CFIndex v24 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecECPrivateKeyDescriptor, (uint64_t)v23, v24, 7LL);
            if (CTKKey) {
              goto LABEL_28;
            }
            SecError(-50, (__CFString **)error, @"EC private key creation from data failed");
          }

          else
          {
LABEL_56:
            SecError(-50, (__CFString **)error, @"Unsupported private key type: %@", v13);
          }
        }

        else
        {
          switch(v14)
          {
            case 'i':
              CFRange v20 = CFDataGetBytePtr(keyData);
              CFIndex v21 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd25519PrivateKeyDescriptor, (uint64_t)v20, v21, 7LL);
              if (CTKKey) {
                goto LABEL_28;
              }
              SecError(-50, (__CFString **)error, @"Ed25519 private key creation from data failed");
              break;
            case 'j':
              uint64_t v32 = CFDataGetBytePtr(keyData);
              CFIndex v33 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX25519PrivateKeyDescriptor, (uint64_t)v32, v33, 7LL);
              if (CTKKey) {
                goto LABEL_28;
              }
              SecError(-50, (__CFString **)error, @"X25519 private key creation from data failed");
              break;
            case 'k':
              SecKeyRef v34 = CFDataGetBytePtr(keyData);
              CFIndex v35 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd448PrivateKeyDescriptor, (uint64_t)v34, v35, 7LL);
              if (CTKKey) {
                goto LABEL_28;
              }
              SecError(-50, (__CFString **)error, @"Ed448 private key creation from data failed");
              break;
            case 'l':
              CFTypeID v36 = CFDataGetBytePtr(keyData);
              CFIndex v37 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX448PrivateKeyDescriptor, (uint64_t)v36, v37, 7LL);
              if (CTKKey) {
                goto LABEL_28;
              }
              SecError(-50, (__CFString **)error, @"X448 private key creation from data failed");
              break;
            case 'm':
              __int128 v38 = CFDataGetBytePtr(keyData);
              CFIndex v39 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecKyberPrivateKeyDescriptor, (uint64_t)v38, v39, 0LL);
              if (CTKKey) {
                goto LABEL_28;
              }
              SecError(-50, (__CFString **)error, @"Kyber public key creation from data failed");
              break;
            default:
              goto LABEL_56;
          }
        }

        int v17 = 1;
LABEL_25:
        _SECKEY_LOG_9790();
        CFIndex v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          if (error) {
            CFErrorRef v28 = *error;
          }
          else {
            CFErrorRef v28 = 0LL;
          }
          *(_DWORD *)__int128 buf = 67109634;
          *(_DWORD *)uint64_t v54 = v14;
          *(_WORD *)&v54[4] = 1024;
          *(_DWORD *)&v54[6] = v17;
          v55[0] = 2114;
          *(void *)&v55[1] = v28;
          uint64_t v29 = "Failed to create key from data, algorithm:%d, class:%d: %{public}@";
          __int128 v30 = v11;
          uint32_t v31 = 24;
          goto LABEL_60;
        }

void sub_1805D1350( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

uint64_t SecKeyParamsAsInt64(void *a1, uint64_t a2, __CFString **a3)
{
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      return [a1 longLongValue];
    }
    SecError(-50, a3, @"Unsupported %@: %@", a2, a1);
    return -1LL;
  }

  uint64_t v6 = [a1 longLongValue];
  objc_msgSend(NSString, "stringWithFormat:", @"%lld", v6);
  CFTypeRef v7 = (void *)objc_claimAutoreleasedReturnValue();
  char v8 = [v7 isEqualToString:a1];

  if ((v8 & 1) == 0)
  {
    [MEMORY[0x189607968] numberWithLongLong:v6];
    CFDictionaryRef v9 = (void *)objc_claimAutoreleasedReturnValue();
    SecError(-50, a3, @"Unsupported %@: %@ (converted value: %@"), a2, a1, v9;

    return -1LL;
  }

  return v6;
}

uint64_t SecKeyDigestAndVerify( uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, CFIndex a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 1u);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyDigestAndVerify_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, a5, a6, 0LL, 0LL, v13);
}

const SecAsn1Oid *SecKeyGetAlgorithmForSecAsn1AlgId(uint64_t a1, const SecAsn1Oid *a2, unsigned int a3)
{
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  if (AlgorithmId == 1)
  {
    uint64_t v6 = SecKeyGetAlgorithmForSecAsn1AlgId_translationTableRSA;
  }

  else
  {
    if (AlgorithmId != 3) {
      return 0LL;
    }
    uint64_t v6 = SecKeyGetAlgorithmForSecAsn1AlgId_translationTableECDSA;
  }

  OSStatus result = *v6;
  if (*v6)
  {
    while (!SecAsn1OidCompare(result, a2))
    {
      char v8 = v6[1];
      if (v8)
      {
        if (SecAsn1OidCompare(v8, a2)) {
          break;
        }
      }

      CFDictionaryRef v9 = v6[4];
      v6 += 4;
      OSStatus result = v9;
      if (!v9) {
        return result;
      }
    }

    return (const SecAsn1Oid *)v6[a3 + 2]->Length;
  }

  return result;
}

uint64_t __SecKeyDigestAndVerify_block_invoke( uint64_t a1, CFDataRef signedData, CFDataRef signature, uint64_t a4, CFErrorRef *a5)
{
  if (SecKeyVerifySignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), signedData, signature, a5)) {
    return *MEMORY[0x189604DE8];
  }
  else {
    return 0LL;
  }
}

uint64_t SecKeyDigestAndSign( uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 1u);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyDigestAndSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0LL, 0LL, a5, a6, v13);
}

CFDataRef __SecKeyDigestAndSign_block_invoke( uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

uint64_t SecKeyVerifyDigest( uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, CFIndex a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyVerifyDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, a5, a6, 0LL, 0LL, v13);
}

uint64_t __SecKeyVerifyDigest_block_invoke( uint64_t a1, CFDataRef signedData, CFDataRef signature, uint64_t a4, CFErrorRef *a5)
{
  if (SecKeyVerifySignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), signedData, signature, a5)) {
    return *MEMORY[0x189604DE8];
  }
  else {
    return 0LL;
  }
}

uint64_t SecKeySignDigest( uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId) {
    return 4294967292LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeySignDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  void v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0LL, 0LL, a5, a6, v13);
}

CFDataRef __SecKeySignDigest_block_invoke( uint64_t a1, CFDataRef dataToSign, int a3, int a4, CFErrorRef *error)
{
  return SecKeyCreateSignature(*(SecKeyRef *)(a1 + 32), *(SecKeyAlgorithm *)(a1 + 40), dataToSign, error);
}

uint64_t SecKeyFindWithPersistentRef( uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  CFDictionaryRef v9 = CFDictionaryCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  (int)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"r_Ref",  *MEMORY[0x189604DE8]);
  CFTypeRef result = 0LL;
  uint64_t v10 = SecItemCopyMatching(v9, &result);
  if (!(_DWORD)v10)
  {
    CFTypeID v11 = CFGetTypeID(result);
    if (v11 == SecKeyGetTypeID())
    {
      uint64_t v10 = 0LL;
      *a2 = result;
      CFTypeRef result = 0LL;
      goto LABEL_7;
    }

    uint64_t v10 = 4294941996LL;
  }

  if (result) {
    CFRelease(result);
  }
LABEL_7:
  if (v9) {
    CFRelease(v9);
  }
  return v10;
}

uint64_t SecKeyCopyPersistentRef(uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    secLogObjForScope("SecError");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEFAULT,  "SecKeyCopyPersistentRef: Need a key reference for this to work",  buf,  2u);
    }

    goto LABEL_26;
  }

  if (!a2)
  {
    secLogObjForScope("SecError");
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEFAULT,  "SecKeyCopyPersistentRef: Need a persistentRef pointer for this to work",  buf,  2u);
    }

void sub_1805D1DF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t _SecKeyCopyWrapKey(uint64_t a1, int a2, int a3, int a4, void *a5, __CFString **a6)
{
  if (a6) {
    *a6 = 0LL;
  }
  if (a5) {
    *a5 = 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u)
  {
    CFTypeRef v7 = *(uint64_t (**)(void))(v6 + 120);
    if (v7) {
      return v7();
    }
  }

  SecError(-4, a6, @"No key wrap supported for key %@", a1);
  return 0LL;
}

uint64_t _SecKeyCopyUnwrapKey(uint64_t a1, int a2, int a3, int a4, void *a5, __CFString **a6)
{
  if (a6) {
    *a6 = 0LL;
  }
  if (a5) {
    *a5 = 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u)
  {
    CFTypeRef v7 = *(uint64_t (**)(void))(v6 + 128);
    if (v7) {
      return v7();
    }
  }

  SecError(-4, a6, @"No key unwrap for key %@", a1);
  return 0LL;
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  CFTypeID v4 = (void *)MEMORY[0x186DFF9D0]();
  CFTypeRef v5 = _os_activity_create( &dword_1804F4000,  "SecKeyCopyExternalRepresentation",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyExternalRepresentation");
  uint64_t v6 = *(uint64_t (**)(SecKeyRef, _BYTE *))(*((void *)key + 2) + 136LL);
  if (v6)
  {
    *(void *)__int128 buf = 0LL;
    CFTypeRef v7 = (const __CFData *)v6(key, buf);
    _SecKeyErrorPropagate(v7 != 0LL, (uint64_t)"SecKeyCopyExternalRepresentation", *(const void **)buf, error);
  }

  else
  {
    if (error) {
      *CFErrorRef error = 0LL;
    }
    SecError(-4, (__CFString **)error, @"export not implemented for key %@", key);
    _SECKEY_LOG_9790();
    char v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "SecKeyCopyExternalRepresentation";
      __int16 v12 = 2114;
      SecKeyRef v13 = key;
      _os_log_debug_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s failed, export not implemented for key %{public}@",  buf,  0x16u);
    }

    CFTypeRef v7 = 0LL;
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v4);
  return v7;
}

void sub_1805D2070( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

CFTypeRef SecKeyCreateDuplicate(void *a1)
{
  int v2 = (void *)MEMORY[0x186DFF9D0]();
  SecKeyRef v3 = _os_activity_create(&dword_1804F4000, "SecKeyCreateDuplicate", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &v9);
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyCreateDuplicate");
  uint64_t v4 = a1[2];
  else {
    CFTypeRef v6 = CFRetain(a1);
  }
  CFTypeRef v7 = v6;
  os_activity_scope_leave(&v9);

  objc_autoreleasePoolPop(v2);
  return v7;
}

void sub_1805D2150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

BOOL SecKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  char v8 = (void *)MEMORY[0x186DFF9D0]();
  os_activity_scope_state_s v9 = _os_activity_create(&dword_1804F4000, "SecKeySetParameter", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeySetParameter");
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(_DWORD *)v10 >= 4u
    && (uint64_t v11 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, const void **))(v10 + 176)) != 0LL)
  {
    uint64_t v14 = 0LL;
    BOOL v12 = v11(a1, a2, a3, &v14) != 0;
    _SecKeyErrorPropagate(v12, (uint64_t)"SecKeySetParameter", v14, a4);
  }

  else
  {
    if (a4) {
      *a4 = 0LL;
    }
    BOOL v12 = SecError(-4, a4, @"setParameter not implemented for %@", a1);
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v12;
}

void sub_1805D2280( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

CFDataRef SecKeyCopyKeyExchangeResult( SecKeyRef privateKey, SecKeyAlgorithm algorithm, SecKeyRef publicKey, CFDictionaryRef parameters, CFErrorRef *error)
{
  uint64_t v10 = (void *)MEMORY[0x186DFF9D0]();
  uint64_t v11 = _os_activity_create( &dword_1804F4000,  "SecKeyCopyKeyExchangeResult",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck((uint64_t)privateKey, (uint64_t)"SecKeyCopyKeyExchangeResult");
  if (!publicKey) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCopyKeyExchangeResult() called with NULL publicKey"];
  }
  CFTypeID v19 = 0LL;
  v16[0] = (uint64_t)privateKey;
  v16[1] = 4LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, algorithm);
  CFTypeRef cf = Mutable;
  uint64_t v18 = 0LL;
  SecKeyRef v13 = SecKeyCopyExternalRepresentation(publicKey, error);
  if (!v13)
  {
    uint64_t v14 = 0LL;
    if (!Mutable) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  uint64_t v14 = SecKeyRunAlgorithmAndCopyResult(v16, v13, parameters, &v19);
  _SecKeyErrorPropagate(v14 != 0LL, (uint64_t)"SecKeyCopyKeyExchangeResult", v19, error);
  CFRelease(v13);
  CFMutableDictionaryRef Mutable = (__CFArray *)cf;
  if (cf)
  {
LABEL_5:
    CFTypeRef cf = 0LL;
    CFRelease(Mutable);
  }

void sub_1805D2414( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

uint64_t SecKeyCreateEncapsulatedKey(uint64_t a1, const void *a2, uint64_t *a3, void *a4)
{
  char v8 = (void *)MEMORY[0x186DFF9D0]();
  os_activity_scope_state_s v9 = _os_activity_create( &dword_1804F4000,  "SecKeyCreateEncapsulatedKey",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateEncapsulatedKey");
  if (!a3) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCreateEncapsulatedKey() requires encapsulatedKey output parameter"];
  }
  uint64_t v18 = 0LL;
  v15[0] = a1;
  v15[1] = 5LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v17 = 0LL;
  uint64_t v11 = SecKeyRunAlgorithmAndCopyResult(v15, 0LL, 0LL, &v18);
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v12);
  }

  _SecKeyErrorPropagate(v11 != 0LL, (uint64_t)"SecKeyCreateEncapsulatedKey", v18, a4);
  if (v11)
  {
    *a3 = -[__CFData objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 0LL);
    uint64_t v13 = -[__CFData objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 1LL);
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  os_activity_scope_leave(&state);
  objc_autoreleasePoolPop(v8);
  return v13;
}

void sub_1805D25AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

__CFData *SecKeyCreateDecapsulatedKey(uint64_t a1, const void *a2, const __CFData *a3, void *a4)
{
  char v8 = (void *)MEMORY[0x186DFF9D0]();
  os_activity_scope_state_s v9 = _os_activity_create( &dword_1804F4000,  "SecKeyCreateDecapsulatedKey",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecapsulatedKey");
  if (!a3) {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603A60] format:@"SecKeyCreateDecapsulatedKey() requires encapsulatedKey input parameter"];
  }
  uint64_t v17 = 0LL;
  v14[0] = a1;
  v14[1] = 6LL;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, a2);
  CFTypeRef cf = Mutable;
  uint64_t v16 = 0LL;
  uint64_t v11 = SecKeyRunAlgorithmAndCopyResult(v14, a3, 0LL, &v17);
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v12);
  }

  _SecKeyErrorPropagate(v11 != 0LL, (uint64_t)"SecKeyCreateDecapsulatedKey", v17, a4);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_1805D270C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

Boolean SecKeyIsAlgorithmSupported(SecKeyRef key, SecKeyOperationType operation, SecKeyAlgorithm algorithm)
{
  CFTypeRef v6 = (void *)MEMORY[0x186DFF9D0]();
  CFTypeRef v7 = _os_activity_create( &dword_1804F4000,  "SecKeyIsAlgorithmSupported",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyIsAlgorithmSupported");
  v16[0] = (uint64_t)key;
  v16[1] = operation;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, algorithm);
  CFTypeRef v17 = Mutable;
  uint64_t v18 = 1LL;
  CFTypeRef cf = 0LL;
  os_activity_scope_state_s v9 = SecKeyRunAlgorithmAndCopyResult(v16, 0LL, 0LL, (__CFString **)&cf);
  uint64_t v10 = v9;
  uint64_t v11 = (__CFData *)*MEMORY[0x189604DE8];
  if (v9 && v11)
  {
    Boolean v12 = CFEqual(v9, v11) != 0;
  }

  else
  {
    Boolean v12 = v9 == v11;
    if (!v9) {
      goto LABEL_6;
    }
  }

  CFRelease(v10);
LABEL_6:
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef v13 = v17;
  if (v17)
  {
    CFTypeRef v17 = 0LL;
    CFRelease(v13);
  }

  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v12;
}

void sub_1805D2870( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

CFDictionaryRef __SecKeyGetAlgorithmAdaptor_block_invoke()
{
  __dst[47] = *(const void **)MEMORY[0x1895F89C0];
  memcpy(__dst, &off_189671CC8, 0x178uLL);
  memcpy(values, off_189671E40, sizeof(values));
  uint64_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
  SecKeyGetAlgorithmAdaptor_adaptors[0] = (uint64_t)CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  __dst,  (const void **)values,  47LL,  MEMORY[0x189605240],  0LL);
  memcpy(keys, &off_189671FB8, sizeof(keys));
  memcpy(v20, &off_189672128, sizeof(v20));
  qword_18C487260 = (uint64_t)CFDictionaryCreate(v0, (const void **)keys, (const void **)v20, 46LL, v1, 0LL);
  v18[12] = xmmword_189672358;
  v18[13] = *(_OWORD *)&off_189672368;
  v18[14] = xmmword_189672378;
  CFTypeID v19 = @"algid:encrypt:ECIES:ECDHC:KDFX963:SHA512:AESGCM-KDFIV";
  v18[8] = xmmword_189672318;
  v18[9] = *(_OWORD *)&off_189672328;
  v18[10] = xmmword_189672338;
  v18[11] = *(_OWORD *)&off_189672348;
  v18[4] = xmmword_1896722D8;
  void v18[5] = *(_OWORD *)&off_1896722E8;
  v18[6] = xmmword_1896722F8;
  v18[7] = *(_OWORD *)&off_189672308;
  v18[0] = xmmword_189672298;
  v18[1] = *(_OWORD *)&off_1896722A8;
  unint64_t v18[2] = xmmword_1896722B8;
  void v18[3] = *(_OWORD *)&off_1896722C8;
  v16[12] = xmmword_189672450;
  v16[13] = *(_OWORD *)&off_189672460;
  v16[14] = xmmword_189672470;
  CFTypeRef v17 = SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA512;
  v16[8] = xmmword_189672410;
  v16[9] = *(_OWORD *)&off_189672420;
  v16[10] = xmmword_189672430;
  v16[11] = *(_OWORD *)&off_189672440;
  void v16[4] = xmmword_1896723D0;
  void v16[5] = *(_OWORD *)&off_1896723E0;
  void v16[6] = xmmword_1896723F0;
  v16[7] = *(_OWORD *)&off_189672400;
  v16[0] = xmmword_189672390;
  v16[1] = *(_OWORD *)&off_1896723A0;
  uint64_t v16[2] = xmmword_1896723B0;
  unint64_t v16[3] = *(_OWORD *)&off_1896723C0;
  qword_18C487268 = (uint64_t)CFDictionaryCreate(v0, (const void **)v18, (const void **)v16, 31LL, v1, 0LL);
  v15[12] = xmmword_189672548;
  v15[13] = *(_OWORD *)&off_189672558;
  v15[14] = xmmword_189672568;
  v15[15] = *(_OWORD *)&off_189672578;
  v15[8] = xmmword_189672508;
  v15[9] = *(_OWORD *)&off_189672518;
  v15[10] = xmmword_189672528;
  v15[11] = *(_OWORD *)&off_189672538;
  void v15[4] = xmmword_1896724C8;
  void v15[5] = *(_OWORD *)&off_1896724D8;
  void v15[6] = xmmword_1896724E8;
  void v15[7] = *(_OWORD *)&off_1896724F8;
  v15[0] = xmmword_189672488;
  v15[1] = *(_OWORD *)&off_189672498;
  uint64_t v15[2] = xmmword_1896724A8;
  unint64_t v15[3] = *(_OWORD *)&off_1896724B8;
  v14[12] = xmmword_189672648;
  v14[13] = *(_OWORD *)&off_189672658;
  v14[14] = xmmword_189672668;
  v14[15] = *(_OWORD *)&off_189672678;
  _BYTE v14[8] = xmmword_189672608;
  v14[9] = *(_OWORD *)&off_189672618;
  v14[10] = xmmword_189672628;
  v14[11] = *(_OWORD *)&off_189672638;
  void v14[4] = xmmword_1896725C8;
  void v14[5] = *(_OWORD *)&off_1896725D8;
  void v14[6] = xmmword_1896725E8;
  v14[7] = *(_OWORD *)&off_1896725F8;
  v14[0] = xmmword_189672588;
  v14[1] = *(_OWORD *)&off_189672598;
  uint64_t v14[2] = xmmword_1896725A8;
  unint64_t v14[3] = *(_OWORD *)&off_1896725B8;
  qword_18C487270 = (uint64_t)CFDictionaryCreate(v0, (const void **)v15, (const void **)v14, 32LL, v1, 0LL);
  __int128 v12 = *(_OWORD *)&off_1896726B8;
  __int128 v13 = xmmword_1896726C8;
  __int128 v10 = *(_OWORD *)&off_189672698;
  __int128 v11 = xmmword_1896726A8;
  __int128 v6 = xmmword_1896726F8;
  __int128 v7 = *(_OWORD *)&off_189672708;
  __int128 v8 = xmmword_189672718;
  *(_OWORD *)os_activity_scope_state_s v9 = xmmword_189672688;
  *(_OWORD *)uint64_t v4 = xmmword_1896726D8;
  __int128 v5 = *(_OWORD *)&off_1896726E8;
  qword_18C487278 = (uint64_t)CFDictionaryCreate(v0, (const void **)v9, (const void **)v4, 10LL, v1, 0LL);
  qword_18C487280 = (uint64_t)CFDictionaryCreate(v0, (const void **)&v3, (const void **)&v3, 0LL, v1, 0LL);
  CFDictionaryRef result = CFDictionaryCreate(v0, (const void **)&v3, (const void **)&v3, 0LL, v1, 0LL);
  qword_18C487288 = (uint64_t)result;
  return result;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA1( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha1_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA224( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha224_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA256( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha256_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA384( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha384_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA512( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha512_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA1( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha1_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA224( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha224_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA256( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha256_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA384( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha384_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA512( uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8 = ccsha512_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyECDHCopyX963Result( uint64_t *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFString **a5)
{
  uint64_t v8 = SecKeyRunAlgorithmAndCopyResult(a1, a3, 0LL, a5);
  if (!v8) {
    return 0LL;
  }
  os_activity_scope_state_s v9 = v8;
  if (!a1[3])
  {
    CFIndex valuePtr = 0LL;
    unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"requestedSize");
    if (Value
      && (__int128 v12 = Value, v13 = CFGetTypeID(Value), v13 == CFNumberGetTypeID())
      && CFNumberGetValue(v12, kCFNumberCFIndexType, &valuePtr))
    {
      uint64_t v14 = (const __CFData *)CFDictionaryGetValue(a4, @"sharedInfo");
      if (!v14)
      {
LABEL_10:
        if (SecCFAllocatorZeroize_sOnce != -1) {
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
        }
        CFIndex v17 = valuePtr;
        CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
        CFDataSetLength(Mutable, v17);
        CFDataGetLength(v9);
        CFDataGetBytePtr(v9);
        CFDataGetMutableBytePtr(Mutable);
        uint64_t v18 = ccansikdf_x963();
        if (!(_DWORD)v18) {
          goto LABEL_13;
        }
        uint64_t v20 = v18;
        if (Mutable) {
          CFRelease(Mutable);
        }
        SecError(-50, a5, @"ECDHKeyExchange wrong input (%d)", v20);
        goto LABEL_21;
      }

      CFIndex v15 = v14;
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 == CFDataGetTypeID())
      {
        CFDataGetBytePtr(v15);
        CFDataGetLength(v15);
        goto LABEL_10;
      }

      SecError(-50, a5, @"ECDHKeyExchange wrong sharedInfo type (must be CFData/NSData)");
    }

    else
    {
      SecError(-50, a5, @"kSecKeyKeyExchangeParameterRequestedSize is missing");
    }

__CFData *SecKeyAlgorithmAdaptorCopyResult_EncryptDecrypt_RSAEncryptionRaw( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_EncryptDecrypt_RSAEncryptionRawCCUnit( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionPKCS1( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyDecryptedWithPadding(a1, 0LL, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  __int128 v7 = (void *)ccsha1_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  __int128 v7 = (void *)ccsha224_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  __int128 v7 = (void *)ccsha256_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  __int128 v7 = (void *)ccsha384_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  __int128 v7 = (void *)ccsha512_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1AESGCM( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA1", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224AESGCM( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA224", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256AESGCM( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA256", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384AESGCM( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA384", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512AESGCM( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA512", a2, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA1( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA1",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA224( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA224",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA256( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA256",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA384( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA384",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA512( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA512",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA1( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA1",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA224( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA224",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA256( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA256",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA384( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA384",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA512( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA512",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  0LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA224( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA224",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA256( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA256",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA384( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA384",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA512( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH:KDFX963:SHA512",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA224( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA224",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA256( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA256",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA384( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA384",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA512( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDHC:KDFX963:SHA512",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult,  1LL,  a2,  a3,  a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIES_Standard_SHA256_2PubKeys( void *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData( a1,  (uint64_t)@"algid:keyexchange:ECDH",  (uint64_t (*)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult,  (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESCBCCopyResult,  0LL,  a2,  a3,  a4);
}

__CFData *SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult( uint64_t a1, const void *a2, uint64_t a3, const __CFData *a4, const __CFData *a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  v22[1] = *MEMORY[0x1895F89C0];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(void *)(a1 + _Block_object_dispose(va, 8) = 4LL;
  __int128 v12 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a4, 0LL, a8);
  if (v12 && !*(void *)(a1 + 24))
  {
    uint64_t v13 = ccsha256_di();
    MEMORY[0x1895F8858](v13);
    CFTypeID v16 = (char *)v22 - v15;
    if (v17 >= 8) {
      memset((char *)v22 - v15, 170, v14);
    }
    ccdigest_init();
    CFDataGetLength(v12);
    CFDataGetBytePtr(v12);
    ccdigest_update();
    CFDataGetLength(a4);
    CFDataGetBytePtr(a4);
    ccdigest_update();
    CFDataGetLength(a5);
    CFDataGetBytePtr(a5);
    ccdigest_update();
    CFIndex v18 = *(void *)v13;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    CFDataSetLength(Mutable, v18);
    CFRelease(v12);
    Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
    (*(void (**)(uint64_t, char *, UInt8 *))(v13 + 56))(v13, v16, MutableBytePtr);
    return Mutable;
  }

  return v12;
}

__CFData *SecKeyECIESDecryptAESCBCCopyResult(const __CFData *a1, CFDataRef theData)
{
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v4, 0LL);
  CFDataSetLength(Mutable, Length);
  ccaes_cbc_decrypt_mode();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  CFDataGetBytePtr(theData);
  CFDataGetMutableBytePtr(Mutable);
  cccbc_one_shot();
  return Mutable;
}

CFTypeRef SecKeyECIESCopyDecryptedData( void *a1, uint64_t a2, uint64_t (*a3)(void *, uint64_t, void, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **), uint64_t (*a4)(const void *, CFDataRef, uint64_t, __CFString **), uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  size_t v14 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v14)
  {
    SecError(-50, a8, @"Unable to export key parameters");
    return 0LL;
  }

  uint64_t v15 = v14;
  unint64_t Value = CFDictionaryGetValue(v14, @"type");
  if (!CFEqual(Value, @"73")
    && (unint64_t v17 = CFDictionaryGetValue(v15, @"type"), !CFEqual(v17, @"106"))
    && (CFIndex v18 = CFDictionaryGetValue(v15, @"type"), !CFEqual(v18, @"108"))
    || (CFTypeID v19 = CFDictionaryGetValue(v15, @"kcls"), !CFEqual(v19, @"1")))
  {
    CFTypeRef v34 = (CFTypeRef)*MEMORY[0x189605018];
LABEL_37:
    __int128 v38 = v15;
    goto LABEL_31;
  }

  CFDataRef theData = a6;
  __int128 v41 = a4;
  if (a1[3])
  {
    CFIndex v20 = 0LL;
    CFTypeID v21 = 0LL;
    CFTypeRef cf = 0LL;
    CFDataRef v22 = 0LL;
    CFDataRef v23 = 0LL;
    goto LABEL_17;
  }

  CFIndex v24 = CFDictionaryGetValue(v15, @"type");
  int v25 = CFEqual(v24, @"73");
  uint64_t v26 = (const __CFString *)CFDictionaryGetValue(v15, @"bsiz");
  uint64_t CFIndexFromRef = SecKeyGetCFIndexFromRef(v26);
  uint64_t v28 = CFIndexFromRef + 7;
  if (CFIndexFromRef < -7) {
    uint64_t v28 = CFIndexFromRef + 14;
  }
  uint64_t v29 = v28 >> 3;
  if (v25) {
    CFIndex v20 = (2 * v29) | 1;
  }
  else {
    CFIndex v20 = v29;
  }
  if (CFDataGetLength(a6) < v20)
  {
    SecError(-50, a8, @"%@: too small input packet for ECIES decrypt", *a1, a6);
    CFTypeRef v34 = 0LL;
    goto LABEL_37;
  }

  uint64_t BytePtr = CFDataGetBytePtr(a6);
  CFDataRef v23 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  BytePtr,  v20,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint32_t v31 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v31)
  {
    SecError(-50, a8, @"%@: Unable to get public key", *a1);
    CFDataRef v35 = 0LL;
    CFTypeRef cf = 0LL;
    CFDataRef v22 = 0LL;
LABEL_40:
    CFIndex v33 = 0LL;
    goto LABEL_41;
  }

  CFTypeRef cf = v31;
  CFDataRef v22 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a8);
  if (!v22)
  {
    CFDataRef v35 = 0LL;
    goto LABEL_40;
  }

  CFTypeID v21 = &BytePtr[v20];
LABEL_17:
  uint64_t v32 = (const void *)a3(a1, a2, 0LL, v23, v22, a5, a7, a8);
  CFIndex v33 = v32;
  if (!v32)
  {
    CFDataRef v35 = 0LL;
LABEL_41:
    CFTypeRef v34 = 0LL;
    goto LABEL_21;
  }

  if (a1[3])
  {
    CFTypeRef v34 = CFRetain(v32);
    CFDataRef v35 = 0LL;
  }

  else
  {
    CFTypeID v36 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex Length = CFDataGetLength(theData);
    CFDataRef v35 = CFDataCreateWithBytesNoCopy(v36, v21, Length - v20, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    CFTypeRef v34 = (CFTypeRef)v41(v33, v35, a7, a8);
  }

uint64_t SecKeyGetCFIndexFromRef(const __CFString *a1)
{
  uint64_t valuePtr = 0LL;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &valuePtr)) {
      return valuePtr;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID()) {
      return CFStringGetIntValue(a1);
    }
    else {
      return 0LL;
    }
  }

id SecKeyECIESKeyExchangeKDFX963CopyResult( uint64_t a1, const void *a2, int a3, void *a4, const __CFData *a5, int a6, void *a7, __CFString **a8)
{
  v34[2] = *MEMORY[0x1895F89C0];
  id v15 = a7;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(void *)(a1 + _Block_object_dispose(va, 8) = 4LL;
  if (*(void *)(a1 + 24))
  {
    CFTypeID v16 = 0LL;
    unint64_t v17 = 0LL;
  }

  else
  {
    *(void *)uint32_t v31 = a8;
    uint64_t v32 = v15;
    [v15 objectForKeyedSubscript:@"symKeySize"];
    CFIndex v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v18)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        SecError(-50, a8, @"Bad requested kSecKeyEncryptionParameterSymmetricKeySizeInBits: %@", v18);

        id v29 = 0LL;
        id v15 = v32;
        goto LABEL_22;
      }

      uint64_t v19 = [v18 integerValue] / 8;
    }

    else
    {
      CFIndex Length = CFDataGetLength(a5);
      uint64_t v19 = 16LL;
      if (Length > 66) {
        uint64_t v19 = 32LL;
      }
    }

    if (a6) {
      uint64_t v21 = v19 + 16;
    }
    else {
      uint64_t v21 = v19;
    }
    unint64_t v17 = (void *)[a4 mutableCopy];
    [v32 objectForKeyedSubscript:@"sharedInfo"];
    CFDataRef v22 = (void *)objc_claimAutoreleasedReturnValue();
    if (v22) {
      [v17 appendData:v22];
    }
    v33[0] = @"sharedInfo";
    v33[1] = @"requestedSize";
    v34[0] = v17;
    [MEMORY[0x189607968] numberWithInteger:v21];
    CFDataRef v23 = (void *)objc_claimAutoreleasedReturnValue();
    v34[1] = v23;
    [MEMORY[0x189603F68] dictionaryWithObjects:v34 forKeys:v33 count:2];
    CFTypeID v16 = (const __CFData *)objc_claimAutoreleasedReturnValue();

    a8 = *(__CFString ***)v31;
    id v15 = v32;
  }

  if (a3) {
    CFIndex v24 = a5;
  }
  else {
    CFIndex v24 = (const __CFData *)a4;
  }
  int v25 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v24, v16, a8);
  uint64_t v26 = v25;
  if (!*(void *)(a1 + 24) && (a6 & 1) == 0 && v25)
  {
    CFIndex v27 = (void *)-[__CFData mutableCopy](v25, "mutableCopy");
    [v27 appendBytes:&kSecKeyIESIV length:16];
    uint64_t v28 = [MEMORY[0x189603F48] dataWithData:v27];

    uint64_t v26 = (void *)v28;
  }

  id v29 = v26;

LABEL_22:
  return v29;
}

CFTypeRef SecKeyECIESDecryptAESGCMCopyResult( const __CFData *a1, CFDataRef theData, const __CFDictionary *a3, __CFString **a4)
{
  if (CFDataGetLength(theData) <= 15)
  {
    SecError(-50, a4, @"ECIES: Input data too short");
    return 0LL;
  }

  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  uint64_t v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFIndex v9 = CFDataGetLength(theData) - 16;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v8, 0LL);
  CFDataSetLength(Mutable, v9);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  __int128 v11 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(v11, 16LL);
  CFIndex v12 = CFDataGetLength(theData) - 16;
  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(v11);
  v20.location = v12;
  v20.CFIndex length = 16LL;
  CFDataGetBytes(theData, v20, MutableBytePtr);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (a3) {
    unint64_t Value = (const __CFData *)CFDictionaryGetValue(a3, @"aad");
  }
  else {
    unint64_t Value = 0LL;
  }
  ccaes_gcm_decrypt_mode();
  CFDataGetBytePtr(a1);
  if (Value)
  {
    CFDataGetLength(Value);
    CFDataGetBytePtr(Value);
  }

  CFDataGetLength(Mutable);
  CFDataGetBytePtr(theData);
  id v15 = CFDataGetMutableBytePtr(Mutable);
  uint64_t v19 = CFDataGetMutableBytePtr(v11);
  uint64_t v16 = ccgcm_one_shot();
  if (!(_DWORD)v16)
  {
    CFTypeRef v17 = CFRetain(Mutable);
    if (!Mutable) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  SecError(-50, a4, @"ECIES: Failed to aes-gcm decrypt data (err %d)", v16, v15, 16LL, v19);
  CFTypeRef v17 = 0LL;
  if (Mutable) {
LABEL_13:
  }
    CFRelease(Mutable);
LABEL_14:
  if (v11) {
    CFRelease(v11);
  }
  return v17;
}

void *SecKeyRSAAESGCMCopyDecryptedData(uint64_t *a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v8)
  {
    SecError(-50, a4, @"Unable to export key parameters");
    return 0LL;
  }

  CFIndex v9 = v8;
  unint64_t Value = CFDictionaryGetValue(v8, @"type");
  if (!CFEqual(Value, @"42") || (__int128 v11 = CFDictionaryGetValue(v9, @"kcls"), !CFEqual(v11, @"1")))
  {
    uint32_t v31 = (void *)*MEMORY[0x189605018];
LABEL_34:
    uint64_t v32 = v9;
    goto LABEL_28;
  }

  CFArrayAppendValue((CFMutableArrayRef)a1[2], a2);
  if (a1[3])
  {
    uint32_t v31 = SecKeyRunAlgorithmAndCopyResult(a1, 0LL, 0LL, a4);
    goto LABEL_34;
  }

  CFIndex v12 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v12)
  {
    SecError(-50, a4, @"%@: unable to get public key", *a1);
    uint32_t v31 = 0LL;
    goto LABEL_34;
  }

  uint64_t v13 = v12;
  CFDataRef v35 = SecKeyCopyExternalRepresentation(v12, (CFErrorRef *)a4);
  if (!v35)
  {
    CFRelease(v9);
    CFRelease(v13);
    return 0LL;
  }

  SecKeyRef v14 = (SecKeyRef)*a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  id v15 = *(uint64_t (**)(SecKeyRef))(*((void *)v14 + 2) + 80LL);
  if (v15) {
    CFIndex v16 = v15(v14);
  }
  else {
    CFIndex v16 = 0LL;
  }
  if (CFDataGetLength(a3) < v16 + 16)
  {
    SecError(-50, a4, @"RSA-WRAP too short input data");
LABEL_38:
    CFMutableDictionaryRef Mutable = 0LL;
    uint32_t v31 = 0LL;
LABEL_25:
    CFRelease(v9);
    goto LABEL_26;
  }

  CFTypeRef v17 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t BytePtr = CFDataGetBytePtr(a3);
  uint64_t v19 = CFDataCreateWithBytesNoCopy(v17, BytePtr, v16, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  CFRange v20 = SecKeyRunAlgorithmAndCopyResult(a1, v19, 0LL, a4);
  if (v19) {
    CFRelease(v19);
  }
  if (!v20) {
    goto LABEL_38;
  }
  uint64_t v21 = (const __CFString *)CFDictionaryGetValue(v9, @"bsiz");
  if (SecKeyGetCFIndexFromRef(v21) <= 4095) {
    uint64_t v22 = 16LL;
  }
  else {
    uint64_t v22 = 32LL;
  }
  if (CFDataGetLength(v20) == v22)
  {
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFDataRef v23 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    CFIndex v24 = CFDataGetLength(a3) - v16 - 16;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(v23, 0LL);
    CFDataSetLength(Mutable, v24);
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    uint64_t v26 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
    CFDataSetLength(v26, 16LL);
    CFIndex v27 = CFDataGetLength(a3) - 16;
    Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(v26);
    v36.location = v27;
    v36.CFIndex length = 16LL;
    CFDataGetBytes(a3, v36, MutableBytePtr);
    CFDataGetBytePtr(a3);
    ccaes_gcm_decrypt_mode();
    CFDataGetLength(v20);
    CFDataGetBytePtr(v20);
    CFDataGetLength(v35);
    CFDataGetBytePtr(v35);
    CFDataGetLength(Mutable);
    id v29 = CFDataGetMutableBytePtr(Mutable);
    CFTypeRef v34 = CFDataGetMutableBytePtr(v26);
    uint64_t v30 = ccgcm_one_shot();
    if ((_DWORD)v30)
    {
      SecError(-50, a4, @"RSA-WRAP: Failed to aes-gcm decrypt data (err %d)", v30, v29, 16LL, v34);
      uint32_t v31 = 0LL;
    }

    else
    {
      uint32_t v31 = (void *)CFRetain(Mutable);
    }
  }

  else
  {
    SecError(-50, a4, @"RSA-WRAP bad ciphertext, unexpected session key size");
    uint64_t v26 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    uint32_t v31 = 0LL;
  }

  CFRelease(v9);
  CFRelease(v20);
  CFIndex v9 = v26;
  if (v26) {
    goto LABEL_25;
  }
LABEL_26:
  CFRelease(v35);
  CFRelease(v13);
  if (Mutable)
  {
    uint64_t v32 = Mutable;
LABEL_28:
    CFRelease(v32);
  }

  return v31;
}

__CFData *SecKeyRSACopyDecryptedWithPadding(uint64_t a1, void *a2, const __CFData *a3, __CFString **a4)
{
  if (a2) {
    unint64_t v8 = 2LL * *a2 + 2;
  }
  else {
    unint64_t v8 = 11LL;
  }
  uint64_t v9 = *(void *)a1;
  _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
  __int128 v10 = *(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 80LL);
  if (v10) {
    unint64_t v11 = v10(v9);
  }
  else {
    unint64_t v11 = 0LL;
  }
  if (v11 < v8) {
    return (__CFData *)*MEMORY[0x189605018];
  }
  if (*(void *)(a1 + 24) == 1LL) {
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a4);
  }
  uint64_t v18 = 0LL;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  uint64_t v21 = 0LL;
  uint64_t v14 = *(void *)a1;
  _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
  id v15 = *(uint64_t (**)(uint64_t))(*(void *)(v14 + 16) + 80LL);
  if (v15) {
    unint64_t v16 = v15(v14);
  }
  else {
    unint64_t v16 = 0LL;
  }
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  size_t v17[2] = __SecKeyRSACopyDecryptedWithPadding_block_invoke;
  unint64_t v17[3] = &unk_189672780;
  v17[4] = &v18;
  v17[5] = a1;
  v17[6] = a4;
  v17[7] = a2;
  PerformWithBigEndianToCCUnit(a3, v16, v17);
  uint64_t v12 = v19[3];
  _Block_object_dispose(&v18, 8);
  return (__CFData *)v12;
}

void sub_1805D5D2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __SecKeyRSACopyDecryptedWithPadding_block_invoke(uint64_t a1, const __CFData *a2)
{
  SecKeyRef v3 = SecKeyRunAlgorithmAndCopyResult(*(uint64_t **)(a1 + 40), a2, 0LL, *(__CFString ***)(a1 + 48));
  if (v3)
  {
    CFTypeID v4 = v3;
    uint64_t v5 = **(void **)(a1 + 40);
    _SecKeyCheck(v5, (uint64_t)"SecKeyGetBlockSize");
    __int128 v6 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 16) + 80LL);
    if (v6) {
      CFIndex v7 = v6(v5);
    }
    else {
      CFIndex v7 = 0LL;
    }
    CFIndex length = v7;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, 0LL);
    CFDataSetLength(Mutable, v7);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = Mutable;
    if (*(void *)(a1 + 56))
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_oaep_decode();
    }

    else if (*(_UNKNOWN **)(**(void **)(a1 + 40) + 16LL) == &kSecRSAPrivateKeyDescriptor)
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_eme_pkcs1v15_decode_safe();
    }

    else
    {
      CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      CFDataGetBytePtr(v4);
      uint64_t v9 = ccrsa_eme_pkcs1v15_decode();
    }

    uint64_t v10 = v9;
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v12 = *(void **)(v11 + 24);
    if ((_DWORD)v10)
    {
      if (v12)
      {
        *(void *)(v11 + 24) = 0LL;
        CFRelease(v12);
      }

      SecError(-50, *(__CFString ***)(a1 + 48), @"RSAdecrypt wrong input (err %d)", v10, length);
    }

    else
    {
      CFDataSetLength((CFMutableDataRef)v12, length);
    }

    CFRelease(v4);
  }

void PerformWithBigEndianToCCUnit(const __CFData *a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  __int128 v6 = v5;
  if (a1)
  {
    unint64_t Length = CFDataGetLength(a1);
    if (Length <= a2) {
      unint64_t v8 = a2;
    }
    else {
      unint64_t v8 = Length;
    }
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 3221225472LL;
    size_t v9 = (v8 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    v10[2] = __PerformWithBigEndianToCCUnit_block_invoke;
    unint64_t v10[3] = &unk_1896727A8;
    unint64_t v12 = v8;
    unint64_t v13 = Length;
    uint64_t v14 = a1;
    id v11 = v6;
    PerformWithCFDataBuffer(v9, v10);
  }

  else
  {
    (*((void (**)(id, void))v5 + 2))(v5, 0LL);
  }
}

uint64_t __PerformWithBigEndianToCCUnit_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void PerformWithCFDataBuffer(size_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = MEMORY[0x1895F87A8];
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __PerformWithCFDataBuffer_block_invoke;
  unint64_t v6[3] = &unk_189672758;
  id v7 = v3;
  id v5 = v3;
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __PerformWithBufferAndClear_block_invoke;
  unint64_t v8[3] = &unk_189676A80;
  void v8[4] = v6;
  PerformWithBuffer(a1, (uint64_t)v8);
}

void __PerformWithCFDataBuffer_block_invoke(uint64_t a1, CFIndex length, UInt8 *bytes)
{
  CFDataRef v4 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  bytes,  length,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  CFRelease(v4);
}

__CFData *SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian(uint64_t *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  if (a1[3] == 1) {
    return SecKeyRunAlgorithmAndCopyResult(a1, 0LL, 0LL, a4);
  }
  uint64_t v17 = 0LL;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  uint64_t v20 = 0LL;
  uint64_t v9 = *a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 80LL);
  if (v10) {
    size_t v11 = v10(v9);
  }
  else {
    size_t v11 = 0LL;
  }
  uint64_t v12 = MEMORY[0x1895F87A8];
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 3221225472LL;
  uint64_t v16[2] = __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke;
  unint64_t v16[3] = &unk_189672780;
  void v16[4] = &v17;
  void v16[5] = a1;
  void v16[6] = a3;
  v16[7] = a4;
  unint64_t v13 = v16;
  uint64_t v14 = v13;
  if (a2)
  {
    v21[0] = v12;
    v21[1] = 3221225472LL;
    void v21[2] = __PerformWithCCUnitToBigEndian_block_invoke;
    v21[3] = &unk_1896727D0;
    uint64_t v23 = a2;
    size_t v24 = v11;
    uint64_t v22 = v13;
    PerformWithCFDataBuffer(v11, v21);
  }

  else
  {
    __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke((uint64_t)v13, 0LL);
  }

  uint64_t v15 = v18[3];
  _Block_object_dispose(&v17, 8);
  return (__CFData *)v15;
}

void sub_1805D62B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke(uint64_t a1, const __CFData *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SecKeyRunAlgorithmAndCopyResult( *(uint64_t **)(a1 + 40),  a2,  *(const __CFData **)(a1 + 48),  *(__CFString ***)(a1 + 56));
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  CFDataRef v4 = *(const __CFData **)(v3 + 24);
  if (v4)
  {
    uint64_t v5 = **(void **)(a1 + 40);
    _SecKeyCheck(v5, (uint64_t)"SecKeyGetBlockSize");
    __int128 v6 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 16) + 80LL);
    if (v6) {
      unint64_t v7 = v6(v5);
    }
    else {
      unint64_t v7 = 0LL;
    }
    unint64_t Length = CFDataGetLength(v4);
    if (Length > v7) {
      unint64_t v7 = Length;
    }
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFIndex v9 = (v7 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
    CFDataSetLength(Mutable, v9);
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetBytePtr(v4);
    ccn_read_uint();
    size_t v11 = *(const void **)(v3 + 24);
    if (v11) {
      CFRelease(v11);
    }
    *(void *)(v3 + 24) = Mutable;
  }

uint64_t __PerformWithCCUnitToBigEndian_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

__CFData *SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit( uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  if (a1[3] == 1) {
    return SecKeyRunAlgorithmAndCopyResult(a1, 0LL, 0LL, a4);
  }
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  uint64_t v17 = 0LL;
  uint64_t v9 = *a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 80LL);
  if (v10) {
    unint64_t v11 = v10(v9);
  }
  else {
    unint64_t v11 = 0LL;
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  void v13[2] = __SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit_block_invoke;
  v13[3] = &unk_189672780;
  void v13[4] = &v14;
  v13[5] = a1;
  void v13[6] = a3;
  v13[7] = a4;
  PerformWithBigEndianToCCUnit(a2, v11, v13);
  uint64_t v12 = v15[3];
  _Block_object_dispose(&v14, 8);
  return (__CFData *)v12;
}

void sub_1805D6578( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit_block_invoke(uint64_t a1, const __CFData *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SecKeyRunAlgorithmAndCopyResult( *(uint64_t **)(a1 + 40),  a2,  *(const __CFData **)(a1 + 48),  *(__CFString ***)(a1 + 56));
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  CFDataRef v4 = *(const __CFData **)(v3 + 24);
  if (v4)
  {
    uint64_t v5 = **(void **)(a1 + 40);
    _SecKeyCheck(v5, (uint64_t)"SecKeyGetBlockSize");
    __int128 v6 = *(uint64_t (**)(uint64_t))(*(void *)(v5 + 16) + 80LL);
    if (v6) {
      CFIndex v7 = v6(v5);
    }
    else {
      CFIndex v7 = 0LL;
    }
    unint64_t v8 = SecKeyRSACopyCCUnitToBigEndian(v4, v7);
    uint64_t v9 = *(const void **)(v3 + 24);
    if (v9) {
      CFRelease(v9);
    }
    *(void *)(v3 + 24) = v8;
  }

__CFData *SecKeyRSACopyCCUnitToBigEndian(const __CFData *a1, CFIndex a2)
{
  if (!a1) {
    return 0LL;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  CFDataSetLength(Mutable, a2);
  CFDataGetLength(Mutable);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint_padded();
  return Mutable;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionPKCS1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyEncryptedWithPadding(a1, 0LL, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha1_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha224_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha256_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha384_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFIndex v7 = (void *)ccsha512_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1AESGCM( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA1", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224AESGCM( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA224", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256AESGCM( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA256", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384AESGCM( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA384", a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512AESGCM( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, @"algid:encrypt:RSA:OAEP:SHA512", a2, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA1( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA1", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA224( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA256( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA384( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA512( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA1( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA1", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA224( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA256( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA384( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA512( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA224( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA224", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA256( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA256", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA384( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA384", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA512( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDH:KDFX963:SHA512", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA224( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA224", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA256( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA256", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA384( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA384", 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA512( uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, @"algid:keyexchange:ECDHC:KDFX963:SHA512", 1, a2, a3, a4);
}

CFTypeRef SecKeyECIESCopyEncryptedData( uint64_t a1, const void *a2, int a3, const __CFData *a4, void *a5, __CFString **a6)
{
  SecKeyRef v11 = *(SecKeyRef *)a1;
  uint64_t v12 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v12)
  {
    SecError(-50, a6, @"Unable to export key parameters");
    CFTypeRef v37 = 0LL;
    goto LABEL_35;
  }

  unint64_t v13 = v12;
  CFDataRef theData = a4;
  unint64_t Value = CFDictionaryGetValue(v12, @"type");
  if (!CFEqual(Value, @"73")
    && (uint64_t v15 = CFDictionaryGetValue(v13, @"type"), !CFEqual(v15, @"106"))
    && (uint64_t v16 = CFDictionaryGetValue(v13, @"type"), !CFEqual(v16, @"108"))
    || (uint64_t v17 = CFDictionaryGetValue(v13, @"kcls"), !CFEqual(v17, @"0")))
  {
    uint64_t v30 = 0LL;
    uint64_t v32 = 0LL;
    CFIndex v33 = 0LL;
    CFDataRef v34 = 0LL;
    CFRange v36 = 0LL;
    CFMutableDictionaryRef MutableCopy = 0LL;
    CFTypeRef v37 = (CFTypeRef)*MEMORY[0x189605018];
    goto LABEL_22;
  }

  __int16 v50 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a6);
  if (!v50)
  {
    uint64_t v30 = 0LL;
    uint64_t v32 = 0LL;
    CFIndex v33 = 0LL;
    CFDataRef v34 = 0LL;
    CFRange v36 = 0LL;
    CFTypeRef v37 = 0LL;
    CFMutableDictionaryRef MutableCopy = 0LL;
    goto LABEL_22;
  }

  unint64_t v48 = v11;
  uint64_t v18 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v19 = CFDictionaryGetValue(v13, @"type");
  CFDictionaryGetValue(v13, @"bsiz");
  CFDictionaryRef v27 = CFDictionaryCreateForCFTypes(v18, v20, v21, v22, v23, v24, v25, v26, (uint64_t)@"type", (uint64_t)v19);
  uint64_t v28 = v13;
  unint64_t v13 = v27;
  CFRelease(v28);
  RandomKey = SecKeyCreateRandomKey(v13, (CFErrorRef *)a6);
  uint64_t v30 = RandomKey;
  if (!RandomKey)
  {
    CFMutableDictionaryRef MutableCopy = 0LL;
    CFTypeRef v37 = 0LL;
    CFRange v36 = 0LL;
    CFDataRef v34 = 0LL;
    uint64_t v32 = 0LL;
    SecKeyRef v11 = v48;
    CFIndex v33 = v50;
    if (!v13) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  uint32_t v31 = SecKeyCopyPublicKey(RandomKey);
  uint64_t v32 = v31;
  CFIndex v33 = v50;
  if (!v31)
  {
    SecError(-50, a6, @"Unable to get public key from generated ECkey");
    CFMutableDictionaryRef MutableCopy = 0LL;
    CFTypeRef v37 = 0LL;
    CFRange v36 = 0LL;
    CFDataRef v34 = 0LL;
    goto LABEL_13;
  }

  CFDataRef v34 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a6);
  if (!v34)
  {
    CFMutableDictionaryRef MutableCopy = 0LL;
    CFTypeRef v37 = 0LL;
    CFRange v36 = 0LL;
    goto LABEL_13;
  }

  *(void *)a1 = v30;
  CFDataRef v35 = (const __CFData *)SecKeyECIESKeyExchangeKDFX963CopyResult(a1, a2, 1, v34, v50, a3, a5, a6);
  CFRange v36 = v35;
  if (!v35)
  {
    CFMutableDictionaryRef MutableCopy = 0LL;
    CFTypeRef v37 = 0LL;
LABEL_13:
    SecKeyRef v11 = v48;
    if (!v13) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  if (*(void *)(a1 + 24))
  {
    CFTypeRef v37 = CFRetain(v35);
    CFMutableDictionaryRef MutableCopy = 0LL;
    goto LABEL_13;
  }

  CFIndex v45 = v13;
  CFIndex v39 = (const __CFData *)a5;
  CFMutableDictionaryRef MutableCopy = CFDataCreateMutableCopy(v18, 0LL, v34);
  CFIndex Length = CFDataGetLength(MutableCopy);
  CFIndex v41 = CFDataGetLength(theData);
  CFDataSetLength(MutableCopy, Length + v41 + 16);
  int v46 = &CFDataGetMutableBytePtr(MutableCopy)[Length];
  CFIndex v42 = CFDataGetLength(theData);
  CFDataGetLength(v36);
  CFDataGetBytePtr(v36);
  if (a5) {
    CFIndex v39 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a5, @"aad");
  }
  ccaes_gcm_encrypt_mode();
  CFDataGetBytePtr(v36);
  if (v39)
  {
    CFDataGetLength(v39);
    CFDataGetBytePtr(v39);
  }

  CFDataGetLength(theData);
  CFDataGetBytePtr(theData);
  uint64_t v43 = ccgcm_one_shot();
  if ((_DWORD)v43)
  {
    SecError(-50, a6, @"ECIES: Failed to aes-gcm encrypt data (err %d)", v43, v46, 16LL, &v46[v42], 0LL);
    CFTypeRef v37 = 0LL;
  }

  else
  {
    CFTypeRef v37 = CFRetain(MutableCopy);
  }

  SecKeyRef v11 = v48;
  CFIndex v33 = v50;
  unint64_t v13 = v45;
  if (!v45) {
    goto LABEL_23;
  }
LABEL_22:
  CFRelease(v13);
LABEL_23:
  if (v30) {
    CFRelease(v30);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
LABEL_35:
  *(void *)a1 = v11;
  return v37;
}

void *SecKeyRSAAESGCMCopyEncryptedData(uint64_t a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  unint64_t v8 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v8)
  {
    SecError(-50, a4, @"Unable to export key parameters");
    return 0LL;
  }

  uint64_t v9 = v8;
  unint64_t Value = CFDictionaryGetValue(v8, @"type");
  if (!CFEqual(Value, @"42") || (SecKeyRef v11 = CFDictionaryGetValue(v9, @"kcls"), !CFEqual(v11, @"0")))
  {
    CFDictionaryRef v27 = (void *)*MEMORY[0x189605018];
LABEL_25:
    uint64_t v28 = v9;
    goto LABEL_19;
  }

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24))
  {
    CFDictionaryRef v27 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a4);
    goto LABEL_25;
  }

  CFDataRef v12 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a4);
  if (!v12)
  {
    CFDictionaryRef v27 = 0LL;
    goto LABEL_25;
  }

  unint64_t v13 = v12;
  uint64_t v14 = (const __CFString *)CFDictionaryGetValue(v9, @"bsiz");
  if (SecKeyGetCFIndexFromRef(v14) <= 4095) {
    size_t v15 = 16LL;
  }
  else {
    size_t v15 = 32LL;
  }
  uint64_t v16 = (const __CFData *)CFDataCreateWithRandomBytes(v15);
  if (v16)
  {
    uint64_t v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v16, 0LL, a4);
    uint64_t v18 = v17;
    if (v17)
    {
      uint64_t v19 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex Length = CFDataGetLength(v17);
      CFIndex v21 = Length + CFDataGetLength(a3) + 16;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(v19, 0LL);
      CFDataSetLength(Mutable, v21);
      Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
      v30.CFIndex length = CFDataGetLength(v18);
      v30.location = 0LL;
      CFDataGetBytes(v18, v30, MutableBytePtr);
      int v24 = &MutableBytePtr[CFDataGetLength(v18)];
      CFIndex v25 = (CFIndex)&v24[CFDataGetLength(a3)];
      ccaes_gcm_encrypt_mode();
      CFDataGetLength(v16);
      CFDataGetBytePtr(v16);
      CFDataGetLength(v13);
      CFDataGetBytePtr(v13);
      CFDataGetLength(a3);
      CFDataGetBytePtr(a3);
      uint64_t v26 = ccgcm_one_shot();
      if ((_DWORD)v26)
      {
        SecError(-50, a4, @"RSAWRAP: Failed to aes-gcm encrypt data (err %d)", v26, v24, 16LL, v25);
        CFDictionaryRef v27 = 0LL;
      }

      else
      {
        CFDictionaryRef v27 = (void *)CFRetain(Mutable);
      }
    }

    else
    {
      CFDictionaryRef v27 = 0LL;
      CFMutableDictionaryRef Mutable = 0LL;
    }
  }

  else
  {
    SecError(-50, a4, @"Failed to generate session key");
    CFDictionaryRef v27 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    uint64_t v18 = 0LL;
  }

  CFRelease(v9);
  CFRelease(v13);
  if (v18) {
    CFRelease(v18);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (Mutable)
  {
    uint64_t v28 = Mutable;
LABEL_19:
    CFRelease(v28);
  }

  return v27;
}

__CFData *SecKeyRSACopyEncryptedWithPadding(uint64_t a1, void *a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = *(void *)a1;
  _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
  uint64_t v9 = *(uint64_t (**)(uint64_t))(*(void *)(v8 + 16) + 80LL);
  if (v9)
  {
    unint64_t v10 = v9(v8);
    if (a2)
    {
LABEL_3:
      unint64_t v11 = 2LL * *a2 + 2;
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v10 = 0LL;
    if (a2) {
      goto LABEL_3;
    }
  }

  unint64_t v11 = 11LL;
LABEL_6:
  if (v10 < v11) {
    return (__CFData *)*MEMORY[0x189605018];
  }
  if (*(void *)(a1 + 24) == 1LL) {
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a4);
  }
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  uint64_t v18 = 0LL;
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 3221225472LL;
  uint64_t v14[2] = __SecKeyRSACopyEncryptedWithPadding_block_invoke;
  unint64_t v14[3] = &unk_1896727F8;
  void v14[6] = v10;
  v14[7] = a3;
  void v14[4] = &v15;
  void v14[5] = a2;
  _BYTE v14[8] = a4;
  v14[9] = a1;
  PerformWithCFDataBuffer((v10 + 7) & 0xFFFFFFFFFFFFFFF8LL, v14);
  uint64_t v12 = v16[3];
  _Block_object_dispose(&v15, 8);
  return (__CFData *)v12;
}

void __SecKeyRSACopyEncryptedWithPadding_block_invoke(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t v5 = *(void *)(a1 + 40);
  ccrng();
  CFDataGetLength(*(CFDataRef *)(a1 + 56));
  CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  if (v5)
  {
    uint64_t v6 = ccrsa_oaep_encode();
    if (!(_DWORD)v6) {
      goto LABEL_3;
    }
LABEL_7:
    SecError(-50, *(__CFString ***)(a1 + 64), @"RSAencrypt wrong input size (err %d)", v6);
    return;
  }

  uint64_t v6 = ccrsa_eme_pkcs1v15_encode();
  if ((_DWORD)v6) {
    goto LABEL_7;
  }
LABEL_3:
  cc_clear();
  CFIndex v7 = SecKeyRunAlgorithmAndCopyResult(*(uint64_t **)(a1 + 72), a3, 0LL, *(__CFString ***)(a1 + 64));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v7;
  if (v7)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v9 = *(const __CFData **)(v8 + 24);
    uint64_t v10 = **(void **)(a1 + 72);
    _SecKeyCheck(v10, (uint64_t)"SecKeyGetBlockSize");
    unint64_t v11 = *(uint64_t (**)(uint64_t))(*(void *)(v10 + 16) + 80LL);
    if (v11) {
      CFIndex v12 = v11(v10);
    }
    else {
      CFIndex v12 = 0LL;
    }
    unint64_t v13 = SecKeyRSACopyCCUnitToBigEndian(v9, v12);
    uint64_t v14 = *(const void **)(v8 + 24);
    if (v14) {
      CFRelease(v14);
    }
    *(void *)(v8 + 24) = v13;
  }

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA1( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA1_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA256( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA256_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA384( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA384_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  void v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512( uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  _DWORD v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  void v5[4] = a1;
  void v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15MD5( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccmd5_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA1( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = (void *)ccsha1_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)@"algid:sign:ECDSA:digest-X962:SHA1", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA224( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = (void *)ccsha224_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)@"algid:sign:ECDSA:digest-X962:SHA224", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA256( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = (void *)ccsha256_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)@"algid:sign:ECDSA:digest-X962:SHA256", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA384( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = (void *)ccsha384_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)@"algid:sign:ECDSA:digest-X962:SHA384", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA512( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  uint64_t v8 = (void *)ccsha512_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)@"algid:sign:ECDSA:digest-X962:SHA512", v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA1( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA1",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA224( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA224",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA256( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA256",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA384( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA384",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA512( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA512",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureRFC4754( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted( uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24) == 1LL) {
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a5);
  }
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v12 = *(uint64_t (**)(uint64_t))(*(void *)(v10 + 16) + 80LL);
  CFIndex v21 = a3;
  if (!v12)
  {
    uint64_t v13 = 0LL;
    goto LABEL_7;
  }

  uint64_t v13 = v12(v10);
  unint64_t v14 = (8 * ((unint64_t)(v13 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0LL;
  uint64_t v11 = MEMORY[0x1895F8858](v13);
  if (v15 <= 7)
  {
LABEL_7:
    MEMORY[0x1895F8858](v11);
    goto LABEL_8;
  }

  uint64_t v16 = memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
  MEMORY[0x1895F8858](v16);
  memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
LABEL_8:
  CFDataGetBytePtr(a4);
  if (CFDataGetLength(a4) != 2 * v13 || ccn_read_uint() || ccn_read_uint())
  {
    SecError(-67808, a5, @"Wrong ECDSA RFC4754 signature");
  }

  else
  {
    ccder_sizeof_integer();
    ccder_sizeof_integer();
    CFIndex v18 = ccder_sizeof();
    CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    CFDataSetLength(Mutable, v18);
    CFDataGetMutableBytePtr(Mutable);
    ccder_encode_integer();
    ccder_encode_integer();
    if (ccder_encode_constructed_tl())
    {
      if (Mutable)
      {
        uint64_t v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v21, Mutable, a5);
        CFRelease(Mutable);
        return v17;
      }
    }

    else
    {
      SecError(-26276, a5, @"Failed to encode X962 signature");
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
  }

  return 0LL;
}

__CFData *SecKeyCopyDigestForMessage(uint64_t *a1, uint64_t a2, uint64_t a3, size_t *a4, __CFString **a5)
{
  if (a1[3] == 1) {
    return SecKeyRunAlgorithmAndCopyResult(a1, 0LL, 0LL, a5);
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  size_t v6 = *a4;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = __SecKeyCopyDigestForMessage_block_invoke;
  unint64_t v8[3] = &unk_1896727F8;
  void v8[4] = &v9;
  void v8[5] = a4;
  v8[6] = a2;
  void v8[7] = a1;
  _BYTE v8[8] = a3;
  v8[9] = a5;
  PerformWithCFDataBuffer(v6, v8);
  uint64_t v7 = v10[3];
  _Block_object_dispose(&v9, 8);
  return (__CFData *)v7;
}

__CFData *SecKeyCopyECDSASignatureForDigest( uint64_t a1, const __CFData *a2, const __CFData *a3, uint64_t a4, void *a5, __CFString **a6)
{
  if (*(void *)(a1 + 24) == 1LL)
  {
    unint64_t v12 = (uint64_t *)a1;
    uint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    return SecKeyRunAlgorithmAndCopyResult(v12, v13, v14, a6);
  }

  if (CFDataGetLength(a2) == *a5)
  {
    unint64_t v12 = (uint64_t *)a1;
    uint64_t v13 = a2;
    unint64_t v14 = a3;
    return SecKeyRunAlgorithmAndCopyResult(v12, v13, v14, a6);
  }

  SecError(-50, a6, @"bad digest size for signing with algorithm %@", a4);
  return 0LL;
}

__CFData *SecKeyRSAVerifyAdaptorCopyResult(uint64_t a1, const __CFData *a2, __CFString **a3, void *a4)
{
  uint64_t v7 = a4;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 3LL;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:encrypt:RSA:raw");
  uint64_t v8 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a2, 0LL, a3);
  uint64_t v9 = v8;
  if (*(void *)(a1 + 24)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v8 == 0LL;
  }
  if (v10) {
    goto LABEL_15;
  }
  if (!v7[2](v7, v8))
  {
    unint64_t v12 = (__CFData *)*MEMORY[0x189604DE0];
    if (v9 != (__CFData *)*MEMORY[0x189604DE0])
    {
      if (v12) {
        CFRetain((CFTypeRef)*MEMORY[0x189604DE0]);
      }
      CFRelease(v9);
      uint64_t v9 = v12;
    }

    SecError(-67808, a3, @"RSA signature verification failed, no match");
    goto LABEL_15;
  }

  uint64_t v11 = (__CFData *)*MEMORY[0x189604DE8];
  if (v9 == (__CFData *)*MEMORY[0x189604DE8])
  {
LABEL_15:
    uint64_t v11 = v9;
    goto LABEL_16;
  }

  if (v11) {
    CFRetain((CFTypeRef)*MEMORY[0x189604DE8]);
  }
  CFRelease(v9);
LABEL_16:

  return v11;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha1_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha224_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha256_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha384_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha512_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15Raw( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, 0LL);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15MD5( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccmd5_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA1( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha1_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA224( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha224_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA256( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha256_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA384( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha384_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA512( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v7 = (void *)ccsha512_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRaw( uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRawCCUnit( uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA1( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA1",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA224( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA224",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA256( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA256",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA384( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA384",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA512( uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( a1,  @"algid:sign:ECDSA:digest-X962:SHA512",  a2,  a3,  a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted( uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(void *)(a1 + 24) == 1LL) {
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a5);
  }
  BOOL v10 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a3, a4, a5);
  uint64_t v11 = v10;
  if (v10 && !CFEqual(v10, (CFTypeRef)*MEMORY[0x189605018]))
  {
    uint64_t v12 = *(void *)a1;
    uint64_t v13 = _SecKeyCheck(v12, (uint64_t)"SecKeyGetBlockSize");
    unint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)(v12 + 16) + 80LL);
    if (v14)
    {
      uint64_t v15 = v14(v12);
      unint64_t v16 = (8 * ((unint64_t)(v15 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0LL;
      uint64_t v13 = MEMORY[0x1895F8858](v15);
      if (v17 > 7)
      {
        CFIndex v18 = memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
        MEMORY[0x1895F8858](v18);
        memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
LABEL_10:
        uint64_t BytePtr = CFDataGetBytePtr(v11);
        uint64_t v20 = &BytePtr[CFDataGetLength(v11)];
        if ((const UInt8 *)ccder_decode_seqii() == v20)
        {
          CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
          CFDataSetLength(Mutable, 2 * v15);
          CFDataGetMutableBytePtr(Mutable);
          ccn_write_uint_padded();
          ccn_write_uint_padded();
        }

        else
        {
          SecError(-50, a5, @"Wrong ECDSA X962 signature");
          CFMutableDictionaryRef Mutable = 0LL;
        }

        CFRelease(v11);
        return Mutable;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    MEMORY[0x1895F8858](v13);
    goto LABEL_10;
  }

  return v11;
}

__CFData *SecKeyRSACopyEMSASignature(uint64_t a1, uint64_t a2, __CFString **a3, int a4, void *a5)
{
  uint64_t v25 = 0LL;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000LL;
  uint64_t v28 = 0LL;
  BOOL v10 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  uint64_t v11 = v10;
  if (!v10)
  {
    SecError(-50, a3, @"Unable to export key parameters");
    goto LABEL_16;
  }

  unint64_t Value = CFDictionaryGetValue(v10, @"type");
  if (!CFEqual(Value, @"42") || (uint64_t v13 = CFDictionaryGetValue(v11, @"kcls"), !CFEqual(v13, @"1")))
  {
    unint64_t v26[3] = *MEMORY[0x189605018];
    goto LABEL_20;
  }

  if (a4)
  {
    uint64_t v14 = objc_msgSend((id)CFDictionaryGetValue(v11, @"bsiz"), "integerValue");
    if (v14 < ((16LL * *a5) | 9))
    {
      uint64_t v15 = *(const __CFArray **)(a1 + 16);
      CFIndex Count = CFArrayGetCount(v15);
      ValueAtIndex = CFArrayGetValueAtIndex(v15, Count - 1);
      SecError(-50, a3, @"algorithm %@ incompatible with %lubit RSA key", ValueAtIndex, v14);
LABEL_20:
      CFRelease(v11);
LABEL_16:
      CFIndex v18 = (__CFData *)v26[3];
      goto LABEL_18;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  CFRelease(v11);
  if (a5 && (a4 & 1) == 0) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:digest-PKCS1v15");
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), @"algid:sign:RSA:raw-cc");
  if (*(void *)(a1 + 24) != 1LL)
  {
    SecKeyRef v19 = *(SecKeyRef *)a1;
    _SecKeyCheck(*(void *)a1, (uint64_t)"SecKeyGetBlockSize");
    uint64_t v20 = *(uint64_t (**)(SecKeyRef))(*((void *)v19 + 2) + 80LL);
    if (!v20 || (uint64_t v21 = v20(v19)) == 0)
    {
      SecError(-50, a3, @"expecting RSA key");
      CFIndex v18 = 0LL;
      goto LABEL_18;
    }

    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    void v23[2] = __SecKeyRSACopyEMSASignature_block_invoke;
    void v23[3] = &unk_189672730;
    char v24 = a4;
    v23[6] = a3;
    void v23[7] = a5;
    v23[8] = a2;
    v23[9] = v14;
    void v23[4] = &v25;
    void v23[5] = v21;
    v23[10] = a1;
    PerformWithCFDataBuffer((v21 + 7) & 0xFFFFFFFFFFFFFFF8LL, v23);
    goto LABEL_16;
  }

  CFIndex v18 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0LL, 0LL, a3);
LABEL_18:
  _Block_object_dispose(&v25, 8);
  return v18;
}

void sub_1805D9AE4(_Unwind_Exception *a1)
{
}

void __SecKeyRSACopyEMSASignature_block_invoke(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  id v16 = (id)objc_claimAutoreleasedReturnValue();
  if (!v16)
  {
    SecError(-108, *(__CFString ***)(a1 + 48), @"out of memory");
    goto LABEL_12;
  }

  if (!*(_BYTE *)(a1 + 88))
  {
    [v16 mutableBytes];
    CFDataGetLength(*(CFDataRef *)(a1 + 64));
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
    if (ccrsa_emsa_pkcs1v15_encode())
    {
      SecError(-50, *(__CFString ***)(a1 + 48), @"RSAsign wrong input data length");
      goto LABEL_12;
    }

    goto LABEL_8;
  }

  [MEMORY[0x189603FB8] dataWithLength:**(void **)(a1 + 56)];
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v5)
  {
    SecError(-108, *(__CFString ***)(a1 + 48), @"out of memory");
LABEL_18:

    goto LABEL_12;
  }

  size_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))ccrng();
  uint64_t v7 = ccrng();
  uint64_t v8 = **(void **)(a1 + 56);
  id v9 = v5;
  uint64_t v10 = v6(v7, v8, [v9 mutableBytes]);
  if ((_DWORD)v10)
  {
    SecError( -26276,  *(__CFString ***)(a1 + 48),  @"PSS salt gen fail (%zu bytes), err %d",  **(void **)(a1 + 56),  v10);
    goto LABEL_18;
  }

  id v11 = v9;
  [v11 bytes];
  CFDataGetLength(*(CFDataRef *)(a1 + 64));
  CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
  [v16 mutableBytes];
  if (ccrsa_emsa_pss_encode())
  {
    SecError(-50, *(__CFString ***)(a1 + 48), @"RSASSA-PSS incompatible algorithm for key size");
    goto LABEL_18;
  }

LABEL_8:
  [v16 bytes];
  ccn_read_uint();
  uint64_t v12 = SecKeyRunAlgorithmAndCopyResult(*(uint64_t **)(a1 + 80), a3, 0LL, *(__CFString ***)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v12;
  if (v12)
  {
    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v14 = SecKeyRSACopyCCUnitToBigEndian(*(const __CFData **)(v13 + 24), *(void *)(a1 + 40));
    uint64_t v15 = *(const void **)(v13 + 24);
    if (v15) {
      CFRelease(v15);
    }
    *(void *)(v13 + 24) = v14;
  }

uint64_t SecOTRFullDHKeyGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRFullDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_10454;
  block[4] = &SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
  if (SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce, block);
  }
  return SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
}

uint64_t __SecOTRFullDHKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

double SecOTRFullDHKeyDestroy(_OWORD *a1)
{
  double result = 0.0;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

BOOL SecOTRFullDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 160) == *(void *)(a2 + 160)
      && *(void *)(a1 + 168) == *(void *)(a2 + 168)
      && *(_DWORD *)(a1 + 176) == (unint64_t)*(unsigned int *)(a2 + 176);
}

uint64_t SecOTRFullDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecOTRFullDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_1896729B8;
  void v3[4] = &v4;
  void v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t SecOTRFullDHKeyCopyDescription(uint64_t a1)
{
  return SecOTRFullDHKeyCopyFormatDescription(a1);
}

void __SecOTRFullDHKeyCopyFormatDescription_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecOTRFullDHKeyCopyFormatDescription_block_invoke_2;
  v5[3] = &unk_189672990;
  void v5[4] = v4;
  void v5[5] = v3;
  void v5[6] = a2;
  v5[7] = a3;
  BufferPerformWithHexString((UInt8 *)(v3 + 160), 20LL, (uint64_t)v5);
}

void withXandY(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const void *)CCNCopyAsHex();
  uint64_t v4 = (const void *)CCNCopyAsHex();
  (*(void (**)(uint64_t, const void *, const void *))(a2 + 16))(a2, v3, v4);
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t CCNCopyAsHex()
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v0 = ccn_write_uint_size();
  uint64_t v1 = MEMORY[0x1895F8858](v0);
  uint64_t v3 = (UInt8 *)v6 - v2;
  if (v1) {
    memset((char *)v6 - v2, 170, v0);
  }
  ccn_write_uint();
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __CCNCopyAsHex_block_invoke;
  unint64_t v6[3] = &unk_1896729E0;
  void v6[4] = &v7;
  BufferPerformWithHexString(v3, v0, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

CFTypeRef __CCNCopyAsHex_block_invoke(CFTypeRef result, CFTypeRef cf)
{
  uint64_t v3 = (uint64_t)result;
  if (cf) {
    double result = CFRetain(cf);
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = cf;
  return result;
}

void BufferPerformWithHexString(UInt8 *bytes, CFIndex length, uint64_t a3)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v5 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  bytes,  length,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  if (v5)
  {
    uint64_t v6 = v5;
    CFIndex v7 = CFDataGetLength(v5);
    CFMutableDictionaryRef Mutable = CFStringCreateMutable(v4, 2 * v7);
    uint64_t BytePtr = CFDataGetBytePtr(v6);
    CFIndex v10 = CFDataGetLength(v6);
    if (v10 >= 1)
    {
      CFIndex v11 = v10;
      do
      {
        unsigned int v12 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v12);
        --v11;
      }

      while (v11);
    }

    (*(void (**)(uint64_t, __CFString *))(a3 + 16))(a3, Mutable);
    CFRelease(Mutable);
  }

  else
  {
    uint64_t v6 = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, const __CFString *))(a3 + 16))(a3, @"(null)");
  }

  CFRelease(v6);
}

CFStringRef __SecOTRFullDHKeyCopyFormatDescription_block_invoke_2(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<SecOTRFullDHKeyRef@%p: x: %@ y: %@ [%@]>",  a1[5],  a1[6],  a1[7],  a2);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t SecOTRFullDHKCreate()
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  SecFDHKNewKey();
  return Instance;
}

uint64_t SecFDHKNewKey()
{
  return GenerateHashForKey();
}

uint64_t GenerateHashForKey()
{
  uint64_t v0 = cczp_bitlen();
  uint64_t v1 = malloc(((unint64_t)(v0 + 7) >> 2) | 1);
  if (!v1) {
    return 4294899624LL;
  }
  uint64_t v2 = v1;
  ccec_export_pub();
  ccsha1_di();
  ccdigest();
  free(v2);
  return 0LL;
}

void *SecOTRFullDHKCreateFromBytes(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = MEMORY[0x186DFEF8C]();
  if (!a2) {
    goto LABEL_10;
  }
  if (!a3) {
    goto LABEL_10;
  }
  unint64_t v6 = *a3 - 4;
  if (*a3 < 4) {
    goto LABEL_10;
  }
  unint64_t v7 = bswap32(*(*a2)++);
  *a3 = v6;
  if (v6 < v7) {
    goto LABEL_10;
  }
  unint64_t v8 = *a3 - v7;
  *a3 = v8;
  uint64_t v9 = (unsigned int *)((char *)*a2 + v7);
  *a2 = v9;
  if (v8 < 5
    || (unint64_t v10 = bswap32(*v9), *a2 = v9 + 1, v11 = v8 - 4, *a3 = v11, v11 < v10)
    || (ccn_read_uint(), *a2 = (unsigned int *)((char *)*a2 + v10), *a3 -= v10, GenerateHashForKey()))
  {
LABEL_10:
    CFRelease(Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t SecFDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  uint64_t v3 = ccn_write_uint_size();
  *(_DWORD *)UInt8 bytes = bswap32(v3);
  CFDataAppendBytes(a2, bytes, 4LL);
  CFDataGetLength(a2);
  CFDataIncreaseLength(a2, v3);
  CFDataGetMutableBytePtr(a2);
  return ccn_write_uint();
}

uint64_t AppendECPublicKeyAsDATA(__CFData *a1)
{
  uint64_t v2 = cczp_bitlen();
  CFIndex v3 = ((unint64_t)(v2 + 7) >> 2) | 1;
  bytes[0] = (unint64_t)(v2 + 7) >> 26;
  bytes[1] = (unint64_t)(v2 + 7) >> 18;
  bytes[2] = (unint64_t)(v2 + 7) >> 10;
  bytes[3] = ((unint64_t)(v2 + 7) >> 2) | 1;
  CFDataAppendBytes(a1, bytes, 4LL);
  CFDataGetLength(a1);
  CFDataIncreaseLength(a1, v3);
  CFDataGetMutableBytePtr(a1);
  return ccec_export_pub();
}

uint64_t SecFDHKAppendPublicSerialization(uint64_t a1, __CFData *a2)
{
  uint64_t result = cczp_bitlen();
  if (result == 256) {
    return AppendECPublicKeyAsDATA(a2);
  }
  return result;
}

uint64_t SecFDHKAppendCompactPublicSerialization(uint64_t a1, const __CFData *a2)
{
  uint64_t result = cczp_bitlen();
  if (result == 256)
  {
    CFIndex v4 = (unint64_t)(cczp_bitlen() + 7) >> 3;
    CFDataGetLength(a2);
    CFDataIncreaseLength(a2, v4);
    CFDataGetMutableBytePtr(a2);
    return ccec_compact_export();
  }

  return result;
}

uint64_t SecFDHKGetHash(uint64_t a1)
{
  return a1 + 160;
}

uint64_t SecOTRPublicDHKeyGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRPublicDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_3_10468;
  block[4] = &SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
  if (SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce, block);
  }
  return SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
}

uint64_t __SecOTRPublicDHKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL SecOTRPublicDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 128) == *(void *)(a2 + 128)
      && *(void *)(a1 + 136) == *(void *)(a2 + 136)
      && *(_DWORD *)(a1 + 144) == (unint64_t)*(unsigned int *)(a2 + 144);
}

uint64_t SecOTRPublicDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecOTRPublicDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_189672A30;
  void v3[4] = &v4;
  void v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t SecOTRPublicDHKeyCopyDescription(uint64_t a1)
{
  return SecOTRPublicDHKeyCopyFormatDescription(a1);
}

void __SecOTRPublicDHKeyCopyFormatDescription_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecOTRPublicDHKeyCopyFormatDescription_block_invoke_2;
  v5[3] = &unk_189672A08;
  void v5[4] = v4;
  void v5[5] = v3;
  void v5[6] = a2;
  v5[7] = a3;
  BufferPerformWithHexString((UInt8 *)(v3 + 128), 20LL, (uint64_t)v5);
}

CFStringRef __SecOTRPublicDHKeyCopyFormatDescription_block_invoke_2(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<SecOTRPublicDHKeyRef@%p: x: %@ y: %@ [%@]>",  a1[5],  a1[6],  a1[7],  a2);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t SecOTRPublicDHKCreateFromFullKey(uint64_t a1, uint64_t a2)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = *(void **)(a2 + 16);
  a2 += 16LL;
  memcpy((void *)(Instance + 16), (const void *)a2, 24LL * *v4 + 16);
  int v5 = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(Instance + 12_Block_object_dispose((const void *)(v1 - 96), 8) = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(Instance + 144) = v5;
  return Instance;
}

char *SecOTRPublicDHKCreateFromSerialization(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  uint64_t v3 = 0LL;
  if (a2 && a3)
  {
    unint64_t v4 = *a3 - 4;
    if (*a3 >= 4 && (unint64_t v5 = bswap32(**a2), ++*a2, *a3 = v4, v9 = v5, v6 = v4 >= v5, v7 = v4 - v5, v6))
    {
      *a3 = v7;
      return SecOTRPublicDHKCreateFromBytes(a1, a2, &v9);
    }

    else
    {
      return 0LL;
    }
  }

  return (char *)v3;
}

char *SecOTRPublicDHKCreateFromBytes(uint64_t a1, void *a2, void *a3)
{
  uint64_t Instance = (char *)_CFRuntimeCreateInstance();
  uint64_t v6 = MEMORY[0x186DFEF8C]();
  if (MEMORY[0x186DFF004](v6, *a3, *a2, Instance + 16)
    || (*a2 += *a3, *a3 = 0LL, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0LL;
    }
  }

  return Instance;
}

const void *SecOTRPublicDHKCreateFromCompactSerialization(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
  MEMORY[0x186DFEF8C]();
  unint64_t v6 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  if (v6 > *a3 || ccec_compact_import_pub() || (*a3 -= v6, *a2 += v6, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0LL;
    }
  }

  return Instance;
}

uint64_t SecPDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKAppendCompactSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKGetHash(uint64_t a1)
{
  return a1 + 128;
}

uint64_t SecPDHKeyGenerateS()
{
  return ccec_compute_key();
}

BOOL SecDHKIsGreater()
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  size_t v0 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  unint64_t v1 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  if (v0 == v1)
  {
    if (v0 < 0x42)
    {
      char v13 = -86;
      *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v11 = v5;
      __int128 v12 = v5;
      *(_OWORD *)__int128 buf = v5;
      __int128 v10 = v5;
      char v8 = -86;
      void v7[2] = v5;
      unint64_t v7[3] = v5;
      v7[0] = v5;
      v7[1] = v5;
      ccec_export_pub();
      ccec_export_pub();
      int v4 = memcmp(buf, v7, v0);
    }

    else
    {
      uint64_t v2 = (os_log_s *)secLogObjForScope("SecError");
      BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
      int v4 = 0;
      if (v3)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "The size of an SecOTRDHKey is larger than 65 bytes.                      This is not supported in SecOTR and w ill result in malformed ciphertexts.",  buf,  2u);
        int v4 = 0;
      }
    }
  }

  else if (v1 < v0)
  {
    int v4 = -1;
  }

  else
  {
    int v4 = 1;
  }

  return v4 > 0;
}

void SecOTRDHKGenerateOTRKeys( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v26 = v11;
  __int128 v27 = v11;
  __int128 v24 = v11;
  __int128 v25 = v11;
  __int128 v22 = v11;
  __int128 v23 = v11;
  __int128 v20 = v11;
  __int128 v21 = v11;
  __int128 v18 = v11;
  __int128 v19 = v11;
  __int128 v16 = v11;
  __int128 v17 = v11;
  ccn_zero();
  *(void *)UInt8 bytes = 192LL;
  ccec_compute_key();
  if (SecDHKIsGreater()) {
    UInt8 v12 = 1;
  }
  else {
    UInt8 v12 = 2;
  }
  bytes[0] = v12;
  CFDataAppendBytes(Mutable, bytes, 1LL);
  uint64_t v13 = ccn_write_uint_size();
  *(_DWORD *)UInt8 bytes = bswap32(v13);
  CFDataAppendBytes(Mutable, bytes, 4LL);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v13);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  ccn_zero();
  DeriveKeys((uint64_t)Mutable, a5, a6);
  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
  *MutableBytePtr ^= 3u;
  DeriveKeys((uint64_t)Mutable, a3, a4);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t DeriveKeys(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a2 | a3)
  {
    __int128 v5 = (const __CFData *)result;
    memset(v6, 170, sizeof(v6));
    ccsha1_di();
    CFDataGetLength(v5);
    CFDataGetBytePtr(v5);
    CFStringRef result = ccdigest();
    if (a2) {
      *(_OWORD *)a2 = *(_OWORD *)v6;
    }
    if (a3)
    {
      ccsha1_di();
      return ccdigest();
    }
  }

  return result;
}

double __EnsureOTRAlgIDInited_block_invoke()
{
  double result = *(double *)&CSSMOID_ECDSA_WithSHA1.Length;
  EnsureOTRAlgIDInited_kOTRECSignatureAlgID = (__int128)CSSMOID_ECDSA_WithSHA1;
  kOTRSignatureAlgIDPtr = (uint64_t)&EnsureOTRAlgIDInited_kOTRECSignatureAlgID;
  return result;
}

uint64_t SecOTRFullIdentityGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRFullIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_2_10479;
  block[4] = &SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
  if (SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce, block);
  }
  return SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
}

uint64_t __SecOTRFullIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SecOTRFullIdentityDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    a1[3] = 0LL;
    CFRelease(v2);
  }

  BOOL v3 = (const void *)a1[2];
  if (v3)
  {
    a1[2] = 0LL;
    CFRelease(v3);
  }

  int v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0LL;
    CFRelease(v4);
  }

CFStringRef SecOTRFullIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>",  a1,  a1[41],  a1[42],  a1[43],  a1[44],  a1[45],  a1[46],  a1[47],  a1[48]);
}

CFStringRef SecOTRFullIdentityCopyDescription(unsigned __int8 *a1)
{
  return SecOTRFullIdentityCopyFormatDescription(a1);
}

uint64_t SecOTRFullIdentityCreate(const __CFAllocator *a1, __CFString **a2)
{
  keys[5] = *(void **)MEMORY[0x1895F89C0];
  SecKeyRef privateKey = 0LL;
  SecKeyRef publicKey = 0LL;
  int valuePtr = 256;
  CFNumberRef v4 = CFNumberCreate(a1, kCFNumberIntType, &valuePtr);
  keys[0] = @"type";
  keys[1] = @"bsiz";
  keys[2] = @"perm";
  keys[3] = @"pdmn";
  keys[4] = @"labl";
  values[0] = @"73";
  values[1] = v4;
  values[2] = *(void **)MEMORY[0x189604DE8];
  values[3] = @"dku";
  values[4] = @"OTR Signing Key";
  CFDictionaryRef v5 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 5LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (v4) {
    CFRelease(v4);
  }
  if (SecKeyGeneratePair(v5, &publicKey, &privateKey))
  {
    unint64_t v9 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 v10 = 0;
      _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "keygen failed", v10, 2u);
    }
  }

  else
  {
    SecOTRFIPurgeFromKeychainByValue(publicKey);
    if (v5) {
      CFRelease(v5);
    }
  }

  SecKeyRef v6 = privateKey;
  uint64_t v7 = SecOTRFullIdentityCreateFromSecKeyRefSOS((uint64_t)a1, privateKey, a2);
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

uint64_t SecOTRFIPurgeFromKeychainByValue(void *a1)
{
  keys[3] = *(void **)MEMORY[0x1895F89C0];
  keys[0] = @"class";
  keys[1] = @"labl";
  keys[2] = @"v_Ref";
  values[0] = @"keys";
  values[1] = @"OTR Signing Key";
  values[2] = a1;
  unint64_t v1 = CFDictionaryCreate(0LL, (const void **)keys, (const void **)values, 3LL, 0LL, 0LL);
  uint64_t v2 = SecItemDelete(v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRefSOS(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v5 = SecOTRFullIdentityCreateFromSecKeyRef(a1, a2, a3);
  CFTypeRef v15 = 0LL;
  uint64_t v12 = SecKeyCopyPersistentRef((uint64_t)a2, &v15, v6, v7, v8, v9, v10, v11);
  if ((_DWORD)v12) {
    SecError(v12, a3, @"failed to find persistent ref for key: %d", v12);
  }
  CFTypeRef v13 = v15;
  *(void *)(v5 + 32) = v15;
  if (v13)
  {
    *(_BYTE *)(v5 + 40) = 0;
  }

  else
  {
    CFRelease((CFTypeRef)v5);
    return 0LL;
  }

  return v5;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRef(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  int v6 = *(const void **)(Instance + 24);
  if (v6 != a2)
  {
    *(void *)(Instance + 24) = a2;
  }

  SecKeyRef v7 = SecKeyCopyPublicKey((SecKeyRef)a2);
  *(void *)(Instance + 16) = v7;
  if (!v7)
  {
    SecError(-2070, a3, @"Failed to extract public key from private key");
    goto LABEL_10;
  }

  *(void *)(Instance + 32) = 0LL;
  *(_BYTE *)(Instance + 40) = 1;
  if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a3))
  {
LABEL_10:
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

BOOL SecOTRFICachePublicHash(uint64_t a1, CFErrorRef *a2)
{
  BOOL v3 = SecOTRPublicIdentityCopyFromPrivate(0LL, a1, a2);
  CFNumberRef v4 = v3;
  if (v3)
  {
    __int128 v5 = *(_OWORD *)((char *)v3 + 25);
    *(_DWORD *)(a1 + 57) = *(_DWORD *)((char *)v3 + 41);
    *(_OWORD *)(a1 + 41) = v5;
    CFRelease(v3);
  }

  return v4 != 0LL;
}

uint64_t SecOTRFullIdentityCreateFromBytes( const __CFAllocator *a1, const UInt8 **a2, unint64_t *a3, __CFString **a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_10476);
  }
  unint64_t v9 = *a3;
  if (!*a3) {
    goto LABEL_28;
  }
  int v10 = *a2;
  int v11 = **a2;
  switch(v11)
  {
    case 3:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      BOOL v16 = v9 >= 3;
      unint64_t v17 = v9 - 3;
      if (v16)
      {
        CFIndex v18 = __rev16(*(unsigned __int16 *)(v10 + 1));
        *a3 = v17;
        *a2 = v10 + 3;
        LODWORD(valuePtr) = 256;
        CFNumberRef v19 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
        __int128 v20 = CFDataCreate(a1, *a2, v18);
        uint64_t v28 = CFDictionaryCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  v21,  v22,  v23,  v24,  v25,  v26,  v27,  (uint64_t)@"type",  (uint64_t)@"73");
        CFErrorRef error = (CFErrorRef)0xAAAAAAAAAAAAAAAALL;
        id v29 = SecKeyCreateWithData(v20, v28, &error);
        if (v28) {
          CFRelease(v28);
        }
        if (v20) {
          CFRelease(v20);
        }
        if (v19) {
          CFRelease(v19);
        }
        if (v29)
        {
          *(_BYTE *)(Instance + 40) = 1;
          *(void *)(Instance + 24) = v29;
          *(void *)(Instance + 32) = 0LL;
          *(void *)(Instance + 16) = SecKeyCopyPublicKey(v29);
          goto LABEL_23;
        }

        CFRelease(error);
      }

      SecError(-67673, a4, @"failed to decode v3 otr session: %d", 4294899623LL);
      goto LABEL_28;
    case 2:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      CFDataRef valuePtr = 0LL;
      CFErrorRef error = 0LL;
      uint64_t v30 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if ((_DWORD)v30)
      {
        uint64_t v38 = v30;
      }

      else
      {
        ECPublicKeyFrom = CreateECPublicKeyFrom(a2, a3);
        *(void *)(Instance + 16) = ECPublicKeyFrom;
        if (ECPublicKeyFrom)
        {
          CFDataRef v32 = valuePtr;
          *(void *)(Instance + 24) = error;
          *(void *)(Instance + 32) = v32;
          *(_BYTE *)(Instance + 40) = 0;
LABEL_23:
          if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a4)) {
            goto LABEL_29;
          }
          return Instance;
        }

        uint64_t v38 = 4294965226LL;
      }

      if (error) {
        CFRelease(error);
      }
      if (valuePtr) {
        CFRelease(valuePtr);
      }
      CFIndex v39 = *(const void **)(Instance + 32);
      if (v39)
      {
        *(void *)(Instance + 32) = 0LL;
        CFRelease(v39);
      }

      __int128 v40 = *(const void **)(Instance + 16);
      if (v40)
      {
        *(void *)(Instance + 16) = 0LL;
        CFRelease(v40);
      }

      CFIndex v41 = *(const void **)(Instance + 24);
      if (v41)
      {
        *(void *)(Instance + 24) = 0LL;
        CFRelease(v41);
      }

      SecError(v38, a4, @"failed to decode v2 otr session: %d", v38);
      goto LABEL_29;
    case 1:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      CFDataRef valuePtr = 0LL;
      CFErrorRef error = 0LL;
      uint64_t v12 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if ((_DWORD)v12)
      {
        uint64_t v34 = v12;
        CFErrorRef v13 = error;
      }

      else
      {
        CFErrorRef v13 = error;
        SecKeyRef v14 = SecKeyCopyPublicKey(error);
        *(void *)(Instance + 16) = v14;
        if (v14)
        {
          CFDataRef v15 = valuePtr;
          *(void *)(Instance + 24) = v13;
          *(void *)(Instance + 32) = v15;
          goto LABEL_23;
        }

        uint64_t v34 = 4294965226LL;
      }

      if (v13) {
        CFRelease(v13);
      }
      if (valuePtr) {
        CFRelease(valuePtr);
      }
      CFDataRef v35 = *(const void **)(Instance + 16);
      if (v35)
      {
        *(void *)(Instance + 16) = 0LL;
        CFRelease(v35);
      }

      CFRange v36 = *(const void **)(Instance + 24);
      if (v36)
      {
        *(void *)(Instance + 24) = 0LL;
        CFRelease(v36);
      }

      CFTypeRef v37 = *(const void **)(Instance + 32);
      if (v37)
      {
        *(void *)(Instance + 32) = 0LL;
        CFRelease(v37);
      }

      SecError(v34, a4, @"failed to decode v1 otr session: %d", v34);
      goto LABEL_29;
  }

  SecError(-50, a4, @"unknown otr session version %hhu", **a2);
LABEL_28:
  if (Instance)
  {
LABEL_29:
    SecOTRFIPurgeFromKeychain(Instance, 0LL);
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t SecOTRFICreatePrivateKeyReadPersistentRef( const UInt8 **a1, unint64_t *a2, CFTypeRef *a3, CFDataRef *a4)
{
  if (!a4) {
    return 4294967246LL;
  }
  uint64_t v5 = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      unint64_t v7 = *a2 - 2;
      if (*a2 >= 2)
      {
        int v8 = *a1 + 2;
        unint64_t v9 = __rev16(*(unsigned __int16 *)*a1);
        *a2 = v7;
        *a1 = v8;
        if (v7 >= v9)
        {
          CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v8, v9);
          if (v12)
          {
            CFDataRef v19 = v12;
            uint64_t v5 = SecKeyFindWithPersistentRef((uint64_t)v12, a3, v13, v14, v15, v16, v17, v18);
            if ((_DWORD)v5)
            {
              CFRelease(v19);
            }

            else
            {
              *a1 += v9;
              *a2 -= v9;
              *a4 = v19;
            }
          }
        }
      }
    }
  }

  return v5;
}

BOOL SecOTRFIPurgeFromKeychain(uint64_t a1, CFErrorRef *a2)
{
  int v3 = SecOTRFIPurgeFromKeychainByValue(*(void **)(a1 + 24));
  int v4 = v3;
  if (v3) {
    SecOTRCreateError(1, v3, @"OSStatus returned in error code", 0LL, a2);
  }
  return v4 == 0;
}

uint64_t SecOTRFullIdentityCreateFromData(const __CFAllocator *a1, CFDataRef theData, __CFString **a3)
{
  if (!theData) {
    return 0LL;
  }
  CFIndex Length = CFDataGetLength(theData);
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  return SecOTRFullIdentityCreateFromBytes(a1, &BytePtr, (unint64_t *)&Length, a3);
}

BOOL SecOTRFIPurgeAllFromKeychain(CFErrorRef *a1)
{
  keys[3] = *(void **)MEMORY[0x1895F89C0];
  keys[0] = @"class";
  keys[1] = @"kcls";
  keys[2] = @"labl";
  values[0] = @"keys";
  values[1] = @"1";
  values[2] = @"OTR Signing Key";
  uint64_t v2 = CFDictionaryCreate(0LL, (const void **)keys, (const void **)values, 3LL, 0LL, 0LL);
  char v3 = 0;
  int v4 = 500;
  do
  {
    OSStatus v5 = SecItemDelete(v2);
    v3 |= v5 == 0;
    BOOL v6 = v4-- != 0;
  }

  while (!v5 && v4 != 0 && v6);
  if (v2) {
    CFRelease(v2);
  }
  if ((v3 & 1) != 0) {
    int v7 = 0;
  }
  else {
    int v7 = -25300;
  }
  if (v5 == -25300) {
    int v8 = v7;
  }
  else {
    int v8 = v5;
  }
  if (v8) {
    SecOTRCreateError(1, v8, @"OSStatus returned in error code", 0LL, a1);
  }
  return v8 == 0;
}

BOOL SecOTRFIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  if (!*(_BYTE *)(a1 + 40))
  {
    UInt8 v13 = 2;
    CFIndex Length = CFDataGetLength(theData);
    CFDataAppendBytes(theData, &v13, 1LL);
    appendSizeAndData(*(const __CFData **)(a1 + 32), theData);
LABEL_7:
    CFDataSetLength(theData, Length);
    int v9 = -50;
    SecOTRCreateError(1, -50LL, @"OSStatus returned in error code", 0LL, a3);
    return v9 == 0;
  }

  UInt8 bytes = 3;
  CFIndex Length = CFDataGetLength(theData);
  CFDataAppendBytes(theData, &bytes, 1LL);
  CFErrorRef v11 = 0LL;
  int v7 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)(a1 + 24), &v11);
  if (!v7) {
    goto LABEL_7;
  }
  int v8 = v7;
  appendSizeAndData(v7, theData);
  CFRelease(v8);
LABEL_5:
  int v9 = 0;
  return v9 == 0;
}

uint64_t AES_CTR_HighHalf_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  v7[0] = HIBYTE(a3);
  v7[1] = BYTE6(a3);
  void v7[2] = BYTE5(a3);
  unint64_t v7[3] = BYTE4(a3);
  _OWORD v7[4] = BYTE3(a3);
  void v7[5] = BYTE2(a3);
  void v7[6] = BYTE1(a3);
  v7[7] = a3;
  uint64_t v8 = 0LL;
  return AES_CTR_Transform(a1, a2, (uint64_t)v7, a4, a5, a6);
}

uint64_t AES_CTR_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v18[1] = *MEMORY[0x1895F89C0];
  uint64_t v12 = ccaes_ctr_crypt_mode();
  MEMORY[0x1895F8858](v12);
  int v14 = (char *)v18 - v13;
  if (v15 >= 0x10)
  {
    int v16 = (void *)((char *)v18 - v13);
    do
    {
      *int v16 = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      v16 += 2;
      v13 -= 16LL;
    }

    while (v13);
  }

  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(v12 + 24))(v12, v14, a1, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 40))(v14, a4, a5, a6);
}

uint64_t AES_CTR_IV0_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AES_CTR_Transform(a1, a2, (uint64_t)&kIVZero, a3, a4, a5);
}

void DeriveOTR256BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
}

void HashMPIWithPrefix(UInt8 a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  UInt8 bytes = a1;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataAppendBytes(Mutable, &bytes, 1LL);
  uint64_t v6 = ccn_write_uint_size();
  *(_DWORD *)int v10 = bswap32(v6);
  CFDataAppendBytes(Mutable, v10, 4LL);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v6);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
  CFIndex Length = CFDataGetLength(Mutable);
  CC_SHA256(MutableBytePtr, Length, a4);
  bzero(MutableBytePtr, Length);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void DeriveOTR128BitPairFromS( UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5, unint64_t a6, void *a7)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v11;
  v14[1] = v11;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v14);
  if (a5)
  {
    if (a4 >= 0x10) {
      size_t v12 = 16LL;
    }
    else {
      size_t v12 = a4;
    }
    memcpy(a5, v14, v12);
  }

  if (a7)
  {
    if (a6 >= 0x10) {
      size_t v13 = 16LL;
    }
    else {
      size_t v13 = a6;
    }
    memcpy(a7, v14, v13);
  }

void *DeriveOTR64BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v7;
  v10[1] = v7;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v10);
  if (a4 >= 0x10) {
    size_t v8 = 16LL;
  }
  else {
    size_t v8 = a4;
  }
  return memcpy(a5, v10, v8);
}

void SecOTRAppendDHMessage(uint64_t a1, __CFData *a2)
{
  if (a1)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    if (Mutable)
    {
      OSStatus v5 = Mutable;
      *(_WORD *)UInt8 bytes = 512;
      CFDataAppendBytes(a2, bytes, 2LL);
      UInt8 v12 = 2;
      CFDataAppendBytes(a2, &v12, 1LL);
      SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), v5);
      CFIndex Length = CFDataGetLength(v5);
      if (Length)
      {
        CFIndex v7 = Length;
        uint64_t BytePtr = CFDataGetBytePtr(v5);
        *(_DWORD *)size_t v13 = bswap32(v7);
        CFDataAppendBytes(a2, v13, 4LL);
        CFIndex v9 = CFDataGetLength(a2);
        CFDataIncreaseLength(a2, v7);
        Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(a2);
        AES_CTR_Transform(16LL, a1 + 40, (uint64_t)&kIVZero, v7, (uint64_t)BytePtr, (uint64_t)&MutableBytePtr[v9]);
        *(_DWORD *)int v14 = 0x20000000;
        CFDataAppendBytes(a2, v14, 4LL);
        CFDataGetLength(a2);
        CFDataIncreaseLength(a2, 32LL);
        CFDataGetMutableBytePtr(a2);
        ccsha256_di();
        ccdigest();
      }

      CFRelease(v5);
    }
  }

uint64_t SecOTRAppendDHKeyMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2LL);
  UInt8 v6 = 10;
  CFDataAppendBytes(theData, &v6, 1LL);
  return SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), theData);
}

void SecOTRAppendRevealSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2LL);
  UInt8 v6 = 17;
  CFDataAppendBytes(theData, &v6, 1LL);
  *(_DWORD *)CFIndex v7 = 0x10000000;
  CFDataAppendBytes(theData, v7, 4LL);
  CFIndex Length = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, 16LL);
  *(_OWORD *)&CFDataGetMutableBytePtr(theData)[Length] = *(_OWORD *)(a1 + 40);
  AppendMACedEncryptedSignature(a1, 0, theData);
}

void AppendMACedEncryptedSignature(uint64_t a1, int a2, const __CFData *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v34[10] = v5;
  v34[11] = v5;
  v34[8] = v5;
  v34[9] = v5;
  v34[6] = v5;
  v34[7] = v5;
  v34[4] = v5;
  void v34[5] = v5;
  v34[2] = v5;
  void v34[3] = v5;
  v34[0] = v5;
  v34[1] = v5;
  ccn_zero();
  *(void *)UInt8 bytes = 192LL;
  ccec_compute_key();
  CFDataGetLength(a3);
  UInt8 v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  size_t v8 = CFDataCreateMutable(v6, 0LL);
  CFIndex v9 = CFDataCreateMutable(v6, 0LL);
  SecFDHKAppendPublicSerialization(*(void *)(a1 + 80), v8);
  AppendECPublicKeyAsDATA(v8);
  CFIndex Length = CFDataGetLength(v8);
  uint64_t v11 = SecOTRPublicIdentityCopyFromPrivate((uint64_t)v6, *(void *)(a1 + 24), 0LL);
  *(_WORD *)UInt8 bytes = 240;
  CFDataAppendBytes(v8, bytes, 2LL);
  UInt8 v12 = CFDataCreateMutable(v6, 0LL);
  SecOTRPIAppendSerialization((uint64_t)v11, v12, 0LL);
  CFIndex v13 = CFDataGetLength(v12);
  uint64_t BytePtr = CFDataGetBytePtr(v12);
  *(_DWORD *)UInt8 bytes = bswap32(v13);
  CFDataAppendBytes(v8, bytes, 4LL);
  CFDataAppendBytes(v8, BytePtr, v13);
  if (v12) {
    CFRelease(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  *(_DWORD *)UInt8 bytes = bswap32(*(_DWORD *)(a1 + 72));
  CFDataAppendBytes(v8, bytes, 4LL);
  CFDataGetLength(v8);
  CFDataGetBytePtr(v8);
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v15;
  __int128 v37 = v15;
  if (a2) {
    UInt8 v16 = 4;
  }
  else {
    UInt8 v16 = 2;
  }
  HashMPIWithPrefix(v16, 24LL, (uint64_t)v34, bytes);
  CFDataGetLength(v9);
  CFDataIncreaseLength(v9, 32LL);
  CFDataGetMutableBytePtr(v9);
  ccsha256_di();
  cchmac();
  v39.location = 0LL;
  v39.CFIndex length = Length;
  CFDataDeleteBytes(v8, v39);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t Size = SecKeyGetSize(*(void *)(v17 + 16), 1);
  CFIndex v19 = CFDataGetLength(v9);
  __int128 v20 = CFDataGetBytePtr(v9);
  CFIndex v21 = CFDataGetLength(Mutable);
  if ((Size & 0x8000000000000000LL) == 0)
  {
    CFDataIncreaseLength(Mutable, Size + 1);
    int v22 = &CFDataGetMutableBytePtr(Mutable)[v21];
    *(void *)UInt8 bytes = Size;
    if (!SecKeyDigestAndSign( *(void *)(v17 + 24),  (const SecAsn1Oid *)kOTRSignatureAlgIDPtr,  v20,  v19,  v22 + 1,  (CFIndex *)bytes))
    {
      uint64_t v23 = *(void *)bytes;
      if (*(void *)bytes <= 0xFFuLL)
      {
        *int v22 = bytes[0];
        v21 += v23 + 1;
      }
    }
  }

  CFDataSetLength(Mutable, v21);
  if (v9) {
    CFRelease(v9);
  }
  CFIndex v24 = CFDataGetLength(Mutable);
  int v25 = CFDataGetBytePtr(Mutable);
  *(_DWORD *)UInt8 bytes = bswap32(v24);
  CFDataAppendBytes(v8, bytes, 4LL);
  CFDataAppendBytes(v8, v25, v24);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFIndex v26 = CFDataGetLength(v8);
  CFDataGetLength(a3);
  *(_DWORD *)UInt8 bytes = bswap32(v26);
  CFDataAppendBytes(a3, bytes, 4LL);
  CFIndex v27 = CFDataGetLength(a3);
  CFDataIncreaseLength(a3, v26);
  uint64_t v28 = &CFDataGetMutableBytePtr(a3)[v27];
  *(void *)&__int128 v35 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v29;
  __int128 v37 = v29;
  HashMPIWithPrefix(1u, 24LL, (uint64_t)v34, bytes);
  __int128 v35 = *(_OWORD *)bytes;
  uint64_t v30 = CFDataGetBytePtr(v8);
  AES_CTR_Transform(16LL, (uint64_t)&v35, (uint64_t)&kIVZero, v26, (uint64_t)v30, (uint64_t)v28);
  __int128 v35 = 0uLL;
  if (v8) {
    CFRelease(v8);
  }
  CFDataGetMutableBytePtr(a3);
  CFDataGetLength(a3);
  *(void *)&__int128 v31 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)UInt8 bytes = v31;
  __int128 v37 = v31;
  if (a2) {
    UInt8 v32 = 5;
  }
  else {
    UInt8 v32 = 3;
  }
  HashMPIWithPrefix(v32, 24LL, (uint64_t)v34, bytes);
  CFDataGetLength(a3);
  CFDataIncreaseLength(a3, 32LL);
  CFDataGetMutableBytePtr(a3);
  ccsha256_di();
  cchmac();
  v40.location = CFDataGetLength(a3) - 12;
  v40.CFIndex length = 12LL;
  CFDataDeleteBytes(a3, v40);
}

void SecOTRAppendSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  *(_WORD *)UInt8 bytes = 512;
  CFDataAppendBytes(theData, bytes, 2LL);
  UInt8 v5 = 18;
  CFDataAppendBytes(theData, &v5, 1LL);
  AppendMACedEncryptedSignature(a1, 1, theData);
}

uint64_t SecOTRPublicIdentityGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRPublicIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_10504;
  block[4] = &SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
  if (SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce, block);
  }
  return SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
}

uint64_t __SecOTRPublicIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SecOTRPublicIdentityDestroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0LL;
    CFRelease(v2);
  }

CFStringRef SecOTRPublicIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>",  a1,  a1[25],  a1[26],  a1[27],  a1[28],  a1[29],  a1[30],  a1[31],  a1[32]);
}

CFStringRef SecOTRPublicIdentityCopyDescription(unsigned __int8 *a1)
{
  return SecOTRPublicIdentityCopyFormatDescription(a1);
}

uint64_t SecOTRAdvertiseHashes(uint64_t result)
{
  sAdvertiseHashes = result;
  return result;
}

void *SecOTRPublicIdentityCopyFromPrivate(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_10476);
  }
  UInt8 v6 = *(const void **)(a2 + 16);
  Instance[2] = v6;
  CFRetain(v6);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t SecOTRPICacheHash(uint64_t a1, CFErrorRef *a2)
{
  CFMutableDataRef Mutable = CFDataCreateMutable(0LL, 0LL);
  uint64_t v5 = SecOTRPIAppendSerialization(a1, Mutable, a2);
  if ((_DWORD)v5)
  {
    CFDataGetBytePtr(Mutable);
    CFDataGetLength(Mutable);
    CCDigest();
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  return v5;
}

uint64_t SecOTRPIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataGetLength(Mutable);
  ccder_sizeof();
  if (sAdvertiseHashes) {
    ccder_sizeof();
  }
  CFIndex v8 = ccder_sizeof();
  CFDataIncreaseLength(theData, v8);
  CFIndex v9 = &CFDataGetMutableBytePtr(theData)[Length];
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(Mutable);
  if (sAdvertiseHashes) {
    ccder_encode_implicit_raw_octet_string();
  }
  ccder_encode_implicit_raw_octet_string();
  if ((UInt8 *)ccder_encode_constructed_tl() != v9)
  {
LABEL_10:
    if (Mutable) {
      CFRelease(Mutable);
    }
    CFDataSetLength(theData, Length);
    SecOTRCreateError(0, -10LL, @"Unable to create public key bytes", 0LL, a3);
    return 0LL;
  }

  else
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 1LL;
  }

CFTypeRef *SecOTRPublicIdentityCreateFromSecKeyRef(uint64_t a1, const void *a2, CFErrorRef *a3)
{
  uint64_t Instance = (CFTypeRef *)_CFRuntimeCreateInstance();
  Instance[2] = a2;
  CFRetain(a2);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance[2]);
    CFRelease(Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromBytes(uint64_t a1, uint64_t *a2, void *a3, CFErrorRef *a4)
{
  CFTypeRef cf = 0LL;
  SecOTRPublicIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1) {
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_10476);
  }
  uint64_t v15 = *a2 + *a3;
  if (!ccder_decode_sequence_tl())
  {
    SecOTRCreateError(0, -9LL, @"Error creating public identity from bytes", 0LL, a4);
    if (!Instance) {
      return Instance;
    }
    goto LABEL_24;
  }

  uint64_t v8 = *a2;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  int v18 = (const UInt8 *)ccder_decode_tl();
  CFIndex v9 = CreateECPublicKeyFrom(&v18, &v17);
  if (v9) {
    BOOL v10 = v17 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  int v11 = v10;
  if (v9 && (v11 & 1) == 0)
  {
    CFRelease(v9);
    CFTypeRef v14 = 0LL;
    *(void *)(Instance + 16) = 0LL;
LABEL_23:
    SecOTRCreateError(0, -9LL, @"Error creating public identity from bytes", v14, a4);
LABEL_24:
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  if (v11) {
    UInt8 v12 = v9;
  }
  else {
    UInt8 v12 = 0LL;
  }
  *(void *)(Instance + 16) = v12;
  if (!v12)
  {
    CFTypeRef v14 = 0LL;
    goto LABEL_23;
  }

  *(_BYTE *)(Instance + 24) = ccder_decode_tl() != 0;
  if ((SecOTRPICacheHash(Instance, (CFErrorRef *)&cf) & 1) == 0)
  {
    CFTypeRef v14 = cf;
    goto LABEL_23;
  }

  *a2 += v15 - v8;
  *a3 -= v15 - v8;
  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromData(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  if (!theData) {
    return 0LL;
  }
  CFIndex Length = CFDataGetLength(theData);
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  return SecOTRPublicIdentityCreateFromBytes(a1, (uint64_t *)&BytePtr, &Length, a3);
}

void __SecOTRPIEqualToBytes_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFData **)(a1 + 32);
  uint64_t v10 = MEMORY[0x1895F87A8];
  uint64_t v11 = 0x40000000LL;
  UInt8 v12 = __SecOTRPIEqualToBytes_block_invoke_2;
  CFIndex v13 = &__block_descriptor_tmp_5_10523;
  uint64_t v14 = a2;
  if (v2)
  {
    char v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFIndex Length = CFDataGetLength(v2);
    CFMutableDataRef Mutable = CFStringCreateMutable(v3, 2 * Length);
    uint64_t BytePtr = CFDataGetBytePtr(v2);
    CFIndex v7 = CFDataGetLength(v2);
    if (v7 >= 1)
    {
      CFIndex v8 = v7;
      do
      {
        unsigned int v9 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v9, v10, v11, v12, v13, v14);
        --v8;
      }

      while (v8);
    }
  }

  else
  {
    CFMutableDataRef Mutable = @"(null)";
  }

  __SecOTRPIEqualToBytes_block_invoke_2((uint64_t)&v10, (uint64_t)Mutable);
  CFRelease(Mutable);
}

void __SecOTRPIEqualToBytes_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  int v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "ID Comparison failed: d: %@ id: %@", (uint8_t *)&v6, 0x16u);
  }

uint64_t SecOTRPIRecreateSignature(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t v15[3] = *MEMORY[0x1895F89C0];
  __int16 v8 = (uint64_t *)MEMORY[0x186DFEF8C]();
  uint64_t v9 = *v8;
  size_t v10 = 8 * *v8;
  MEMORY[0x1895F8858](v8);
  unint64_t v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  if (v9)
  {
    UInt8 v12 = memset((char *)v15 - v11, 170, v10);
    MEMORY[0x1895F8858](v12);
    memset((char *)v15 - v11, 170, v10);
  }

  v15[1] = a1 + a2;
  ccder_decode_sequence_tl();
  mp_decode_forced_uint();
  mp_decode_forced_uint();
  uint64_t v13 = *a3 + *a4;
  ccder_encode_integer();
  ccder_encode_integer();
  uint64_t result = ccder_encode_constructed_tl();
  *a3 = result;
  *a4 = (v13 - result) & ~((v13 - result) >> 63);
  return result;
}

uint64_t mp_decode_forced_uint()
{
  uint64_t result = ccder_decode_tl();
  if (result)
  {
    uint64_t v1 = result;
    else {
      return v1 - 0x5555555555555556LL;
    }
  }

  return result;
}

void sub_1805DDCDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1805DDFA8(_Unwind_Exception *a1)
{
}

void sub_1805DE210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10627(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__10628(uint64_t a1)
{
}

uint64_t SecRemoteKeyInit(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  return 0LL;
}

void SecRemoteKeyDestroy(uint64_t a1)
{
  id v1 = *(id *)(a1 + 24);
  [v1 invalidate];
}

uint64_t SecRemoteKeyBlockSize(uint64_t a1)
{
  uint64_t v5 = 0LL;
  int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  uint64_t v8 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, 0LL);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  void v4[2] = __SecRemoteKeyBlockSize_block_invoke;
  unint64_t v4[3] = &unk_189672D50;
  void v4[4] = &v5;
  [v1 getBlockSizeWithReply:v4];

  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1805DE570( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t SecRemoteKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v9 = 0LL;
  size_t v10 = &v9;
  uint64_t v11 = 0x3032000000LL;
  uint64_t v12 = __Block_byref_object_copy__10627;
  uint64_t v13 = __Block_byref_object_dispose__10628;
  id v14 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, 0LL);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = __SecRemoteKeyCopyAttributeDictionary_block_invoke;
  unint64_t v8[3] = &unk_189672D78;
  void v8[4] = &v9;
  [v1 getAttributesWithReply:v8];

  [(id)v10[5] objectForKeyedSubscript:@"accc"];
  uint64_t v2 = (const __CFData *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    uint64_t v7 = 0LL;
    char v3 = SecAccessControlCreateFromData((const __CFAllocator *)*MEMORY[0x189604DB0], v2, &v7);
    int v4 = (void *)v10[5];
    if (v3) {
      [v4 setObject:v3 forKeyedSubscript:@"accc"];
    }
    else {
      [v4 removeObjectForKey:@"accc"];
    }
  }

  uint64_t v5 = [(id)v10[5] copy];

  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_1805DE6D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id SecRemoteKeyCopyDescription(uint64_t a1)
{
  uint64_t v5 = 0LL;
  int v6 = &v5;
  uint64_t v7 = 0x3032000000LL;
  uint64_t v8 = __Block_byref_object_copy__10627;
  uint64_t v9 = __Block_byref_object_dispose__10628;
  id v10 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, 0LL);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  void v4[2] = __SecRemoteKeyCopyDescription_block_invoke;
  unint64_t v4[3] = &unk_189672DA0;
  void v4[4] = &v5;
  [v1 getDescriptionWithReply:v4];

  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1805DE7BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t SecRemoteKeyGetAlgorithmID(uint64_t a1)
{
  uint64_t v5 = 0LL;
  int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  uint64_t v8 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, 0LL);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  void v4[2] = __SecRemoteKeyGetAlgorithmID_block_invoke;
  unint64_t v4[3] = &unk_189672DC8;
  void v4[4] = &v5;
  [v1 getAlgorithmIDWithReply:v4];

  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1805DE87C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id SecRemoteKeyCopyExternalRepresentation(uint64_t a1, void *a2)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3032000000LL;
  uint64_t v18 = __Block_byref_object_copy__10627;
  CFIndex v19 = __Block_byref_object_dispose__10628;
  id v20 = 0LL;
  uint64_t v9 = 0LL;
  id v10 = &v9;
  uint64_t v11 = 0x3032000000LL;
  uint64_t v12 = __Block_byref_object_copy__10627;
  uint64_t v13 = __Block_byref_object_dispose__10628;
  id v14 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, a2);
  char v3 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = __SecRemoteKeyCopyExternalRepresentation_block_invoke;
  unint64_t v8[3] = &unk_189672DF0;
  void v8[4] = &v15;
  void v8[5] = &v9;
  [v3 getExternalRepresentationWithReply:v8];

  int v4 = v16;
  uint64_t v5 = (void *)v16[5];
  if (a2 && !v5)
  {
    *a2 = (id)v10[5];
    uint64_t v5 = (void *)v4[5];
  }

  id v6 = v5;
  _Block_object_dispose(&v9, 8);

  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_1805DE9B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id SecRemoteKeyCopyPublicKey(uint64_t a1)
{
  uint64_t v5 = 0LL;
  id v6 = &v5;
  uint64_t v7 = 0x3032000000LL;
  uint64_t v8 = __Block_byref_object_copy__10627;
  uint64_t v9 = __Block_byref_object_dispose__10628;
  id v10 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, 0LL);
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  void v4[2] = __SecRemoteKeyCopyPublicKey_block_invoke;
  unint64_t v4[3] = &unk_189672E18;
  void v4[4] = &v5;
  [v1 getPublicKey:v4];

  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1805DEAA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id SecRemoteKeyCopyOperationResult( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = (void *)[MEMORY[0x189604A58] mutableCopy];
  uint64_t v16 = v15;
  if (a6)
  {
    [v15 addObject:a6];
    if (a7) {
      [v16 addObject:a7];
    }
  }

  uint64_t v21 = 0LL;
  int v22 = &v21;
  uint64_t v23 = 0x3032000000LL;
  CFIndex v24 = __Block_byref_object_copy__10627;
  int v25 = __Block_byref_object_dispose__10628;
  id v26 = 0LL;
  +[SecKeyProxy targetForKey:error:](&OBJC_CLASS___SecKeyProxy, "targetForKey:error:", a1, a8);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
  v20[0] = MEMORY[0x1895F87A8];
  v20[1] = 3221225472LL;
  v20[2] = __SecRemoteKeyCopyOperationResult_block_invoke;
  v20[3] = &unk_189672E40;
  void v20[4] = &v21;
  void v20[5] = a8;
  [v17 performOperation:a2 mode:a5 algorithm:a3 parameters:v16 reply:v20];

  id v18 = (id)v22[5];
  _Block_object_dispose(&v21, 8);

  return v18;
}

void sub_1805DEBFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __SecRemoteKeyCopyOperationResult_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if ([v9 count])
  {
    uint64_t v6 = [v9 objectAtIndexedSubscript:0];
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }

  else if (*(void *)(a1 + 40))
  {
    **(void **)(a1 + 40) = v5;
  }
}

void __SecRemoteKeyCopyPublicKey_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    char v3 = +[SecKeyProxy createKeyFromEndpoint:error:](&OBJC_CLASS___SecKeyProxy, "createKeyFromEndpoint:error:", a2, 0LL);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
    id v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

void __SecRemoteKeyCopyExternalRepresentation_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v11 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
}

uint64_t __SecRemoteKeyGetAlgorithmID_block_invoke(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  return result;
}

void __SecRemoteKeyCopyDescription_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [NSString stringWithFormat:@"<SecKeyRef remoteKey: %@>", a2];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void __SecRemoteKeyCopyAttributeDictionary_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 mutableCopy];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

uint64_t __SecRemoteKeyBlockSize_block_invoke(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  return result;
}

uint64_t SecOTRSessionGetTypeID()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRSessionGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_10689;
  block[4] = &SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
  if (SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce != -1) {
    dispatch_once(&SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce, block);
  }
  return SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
}

uint64_t __SecOTRSessionGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void SecOTRSessionDestroy(uint64_t a1)
{
  id v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 56) = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 64) = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 24) = 0LL;
    CFRelease(v4);
  }

  id v5 = *(const void **)(a1 + 80);
  if (v5)
  {
    *(void *)(a1 + 80) = 0LL;
    CFRelease(v5);
  }

  id v6 = *(const void **)(a1 + 88);
  if (v6)
  {
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    CFRelease(v6);
  }

  uint64_t v7 = *(const void **)(a1 + 32);
  if (v7)
  {
    *(void *)(a1 + 32) = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = *(const void **)(a1 + 112);
  if (v8)
  {
    *(void *)(a1 + 112) = 0LL;
    CFRelease(v8);
  }

  uint64_t v9 = *(const void **)(a1 + 104);
  if (v9)
  {
    *(void *)(a1 + 104) = 0LL;
    CFRelease(v9);
  }

  id v10 = *(const void **)(a1 + 120);
  if (v10)
  {
    *(void *)(a1 + 120) = 0LL;
    CFRelease(v10);
  }

  dispatch_release(*(dispatch_object_t *)(a1 + 128));
}

CFStringRef SecOTRSessionCopyFormatDescription(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  else {
    uint64_t v4 = off_1896731F0[v3];
  }
  double v5 = *(double *)(a1 + 672);
  id v6 = "e";
  if (v5 != 0.0 && v5 > Current) {
    id v6 = "E";
  }
  uint64_t v8 = "S";
  if (!*(_BYTE *)(a1 + 664)) {
    uint64_t v8 = "s";
  }
  uint64_t v9 = "R";
  id v10 = "M";
  if (!*(_BYTE *)(a1 + 681)) {
    uint64_t v9 = "r";
  }
  if (!*(_BYTE *)(a1 + 680)) {
    id v10 = "m";
  }
  id v11 = "t";
  if (*(void *)(a1 + 112)) {
    id v11 = "T";
  }
  if (*(void *)(a1 + 104)) {
    uint64_t v12 = "P";
  }
  else {
    uint64_t v12 = "p";
  }
  if (*(void *)(a1 + 64)) {
    uint64_t v13 = "K";
  }
  else {
    uint64_t v13 = "k";
  }
  if (*(void *)(a1 + 56)) {
    id v14 = "D";
  }
  else {
    id v14 = "d";
  }
  if (*(void *)(a1 + 32)) {
    uint64_t v15 = "P";
  }
  else {
    uint64_t v15 = "p";
  }
  if (*(void *)(a1 + 24)) {
    uint64_t v16 = "F";
  }
  else {
    uint64_t v16 = "f";
  }
  if (*(_BYTE *)(a1 + 650)) {
    uint64_t v17 = "I";
  }
  else {
    uint64_t v17 = "i";
  }
  if (*(_BYTE *)(a1 + 649)) {
    id v18 = "C";
  }
  else {
    id v18 = "c";
  }
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<%s %s %s %s%s%s%s %d:%d %s%s %llu %s%s%s%s>",  Current,  v4,  v18,  v17,  v16,  v15,  v14,  v13,  *(unsigned int *)(a1 + 72),  *(unsigned int *)(a1 + 96),  v12,  v11,  *(void *)(a1 + 656),  v10,  v9,  v8,  v6);
}

CFStringRef SecOTRSessionCopyDescription(uint64_t a1)
{
  return SecOTRSessionCopyFormatDescription(a1);
}

const char *SecOTRPacketTypeString(const __CFData *a1)
{
  if (!a1) {
    return "NoMessage";
  }
  int v1 = SecOTRSGetMessageType(a1);
  if (v1 > 0x1F)
  {
    if (v1 <= 47)
    {
      if (v1 == 32) {
        return "kEvenCompactDatamessage (0x20)";
      }
      if (v1 == 33) {
        return "kOddCompactDataMessage (0x21)";
      }
    }

    else
    {
      switch(v1)
      {
        case 48:
          return "kEvenCompactDatamessage (0x30)";
        case 49:
          return "kOddCompactDataMessage (0x31)";
        case 255:
          return "InvalidMessage (0xFF)";
      }
    }
  }

  else if (v1 <= 9)
  {
    if (v1 == 2) {
      return "DHMessage (0x02)";
    }
    if (v1 == 3) {
      return "DataMessage (0x03)";
    }
  }

  else
  {
    switch(v1)
    {
      case 10:
        return "DHKeyMessage (0x0A)";
      case 17:
        return "RevealSignatureMessage (0x11)";
      case 18:
        return "SignatureMessage (0x12)";
    }
  }

  return "UnknownMessage";
}

uint64_t SecOTRSGetMessageType(const __CFData *a1)
{
  int v1 = (const __CFData *)SecOTRCopyIncomingBytes(a1);
  uint64_t BytePtr = CFDataGetBytePtr(v1);
  if ((unint64_t)CFDataGetLength(v1) > 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    uint64_t v3 = BytePtr[2];
  }

  else
  {
    uint64_t v3 = *CFDataGetBytePtr(v1);
  }

  if (v1) {
    CFRelease(v1);
  }
  return v3;
}

uint64_t SecOTRSGetKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t SecOTRSGetTheirKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

void SecOTRSessionReset(dispatch_queue_t *context)
{
}

double SecOTRSessionResetInternal(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  id v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 56) = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 64) = 0LL;
    CFRelease(v3);
  }

  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v4 = *(const void **)(a1 + 80);
  if (v4)
  {
    *(void *)(a1 + 80) = 0LL;
    CFRelease(v4);
  }

  double v5 = *(const void **)(a1 + 88);
  if (v5)
  {
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    CFRelease(v5);
  }

  *(_DWORD *)(a1 + 96) = 0;
  id v6 = *(const void **)(a1 + 112);
  if (v6)
  {
    *(void *)(a1 + 112) = 0LL;
    CFRelease(v6);
  }

  uint64_t v7 = *(const void **)(a1 + 104);
  if (v7)
  {
    *(void *)(a1 + 104) = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = *(const void **)(a1 + 120);
  if (v8)
  {
    *(void *)(a1 + 120) = 0LL;
    CFRelease(v8);
  }

  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  double result = 0.0;
  *(_OWORD *)(a1 + 136) = 0u;
  id v11 = (_OWORD *)(a1 + 136);
  *((void *)v11 - 2) = Mutable;
  v11[1] = 0u;
  _OWORD v11[2] = 0u;
  unint64_t v11[3] = 0u;
  void v11[4] = 0u;
  void v11[5] = 0u;
  void v11[6] = 0u;
  v11[7] = 0u;
  v11[8] = 0u;
  v11[9] = 0u;
  v11[10] = 0u;
  v11[11] = 0u;
  v11[12] = 0u;
  v11[13] = 0u;
  v11[14] = 0u;
  v11[15] = 0u;
  v11[16] = 0u;
  v11[17] = 0u;
  v11[18] = 0u;
  v11[19] = 0u;
  v11[20] = 0u;
  v11[21] = 0u;
  v11[22] = 0u;
  v11[23] = 0u;
  v11[24] = 0u;
  v11[25] = 0u;
  v11[26] = 0u;
  v11[27] = 0u;
  v11[28] = 0u;
  v11[29] = 0u;
  v11[30] = 0u;
  v11[31] = 0u;
  return result;
}

uint64_t SecOTRSessionCreateFromID(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10734);
  }
  *(void *)(Instance + 12_Block_object_dispose(va, 8) = dispatch_queue_create("OTRSession", 0LL);
  if (a2) {
    CFRetain(a2);
  }
  *(void *)(Instance + 24) = a2;
  if (a3) {
    CFRetain(a3);
  }
  *(void *)(Instance + 32) = a3;
  *(_WORD *)(Instance + 64_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(Instance + 650) = 0;
  *(void *)(Instance + 672) = 0LL;
  *(_BYTE *)(Instance + 664) = 0;
  *(void *)(Instance + 656) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 64) = 0LL;
  *(void *)(Instance + 80) = 0LL;
  *(void *)(Instance + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(Instance + 112) = 0LL;
  *(void *)(Instance + 120) = 0LL;
  *(void *)(Instance + 104) = 0LL;
  *(_WORD *)(Instance + 680) = 1;
  SecOTRSessionResetInternal(Instance);
  id v6 = SecOTRPublicIdentityCopyFromPrivate(*MEMORY[0x189604DB0], *(void *)(Instance + 24), 0LL);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecOTRSessionCreateFromID_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_18_10736;
  void v8[4] = Instance;
  SecOTRPIPerformWithSerializationString((uint64_t)v6, (uint64_t)v8);
  if (v6) {
    CFRelease(v6);
  }
  return Instance;
}

void __SecOTRSessionCreateFromID_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecOTRSessionCreateFromID_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_17_10742;
  void v4[4] = v2;
  void v4[5] = a2;
  SecOTRPIPerformWithSerializationString(v3, (uint64_t)v4);
}

void SecOTRPIPerformWithSerializationString(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  SecOTRPIAppendSerialization(a1, Mutable, 0LL);
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(Mutable);
    uint64_t v7 = CFStringCreateMutable(v4, 2 * Length);
    uint64_t BytePtr = CFDataGetBytePtr(Mutable);
    CFIndex v9 = CFDataGetLength(Mutable);
    if (v9 >= 1)
    {
      CFIndex v10 = v9;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(v7, 0LL, @"%02X", v11);
        --v10;
      }

      while (v10);
    }

    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, v7);
    CFRelease(v7);
  }

  else
  {
    CFMutableDataRef Mutable = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, @"(null)");
  }

  CFRelease(Mutable);
}

void __SecOTRSessionCreateFromID_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ Creating with M: %@, T: %@", (uint8_t *)&v7, 0x20u);
  }

CFIndex __SecOTRGetDefaultsWriteSeconds_block_invoke()
{
  keyExistsAndHasValidFormCFAbsoluteTime at = 0;
  CFIndex result = CFPreferencesGetAppIntegerValue(@"OTR", @"com.apple.security", &keyExistsAndHasValidFormat);
  uint64_t v1 = 900LL;
  if (keyExistsAndHasValidFormat) {
    uint64_t v1 = result;
  }
  SecOTRGetDefaultsWriteSeconds_seconds = v1;
  return result;
}

uint64_t SecOTRSessionCreateFromIDAndFlags(uint64_t a1, const void *a2, const void *a3, char a4)
{
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10734);
  }
  uint64_t v8 = SecOTRGetDefaultsWriteSeconds_seconds;
  uint64_t result = SecOTRSessionCreateFromID(a1, a2, a3);
  if ((a4 & 1) != 0)
  {
    *(_BYTE *)(result + 64_Block_object_dispose(va, 8) = 1;
    if ((a4 & 2) == 0)
    {
LABEL_5:
      if ((a4 & 4) == 0) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }

  else if ((a4 & 2) == 0)
  {
    goto LABEL_5;
  }

  *(_BYTE *)(result + 649) = 1;
  if ((a4 & 4) == 0)
  {
LABEL_6:
    if ((a4 & 8) == 0) {
      return result;
    }
    goto LABEL_7;
  }

uint64_t SecOTRSessionCreateFromData(uint64_t a1, const __CFData *a2)
{
  if (!a2) {
    return 0LL;
  }
  SecOTRSessionGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t BytePtr = (UInt8 *)CFDataGetBytePtr(a2);
  UInt8 bytes = BytePtr;
  unint64_t Length = CFDataGetLength(a2);
  unint64_t v68 = Length;
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10734);
  }
  dispatch_queue_t v6 = dispatch_queue_create("OTRSession", 0LL);
  *(void *)(Instance + 104) = 0LL;
  *(void *)(Instance + 12_Block_object_dispose(va, 8) = v6;
  *(void *)(Instance + 80) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(_WORD *)(Instance + 64_Block_object_dispose(va, 8) = 0;
  *(void *)(Instance + 672) = 0LL;
  *(_BYTE *)(Instance + 664) = 0;
  *(void *)(Instance + 656) = 0LL;
  *(void *)(Instance + 24) = 0LL;
  *(void *)(Instance + 32) = 0LL;
  *(void *)(Instance + 64) = 0LL;
  *(void *)(Instance + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(Instance + 112) = 0LL;
  *(_WORD *)(Instance + 680) = 1;
  *(_OWORD *)(Instance + 232) = 0u;
  *(_OWORD *)(Instance + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 200) = 0u;
  *(_OWORD *)(Instance + 216) = 0u;
  *(_OWORD *)(Instance + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 184) = 0u;
  *(_OWORD *)(Instance + 152) = 0u;
  *(_OWORD *)(Instance + 136) = 0u;
  *(_OWORD *)(Instance + 616) = 0u;
  *(_OWORD *)(Instance + 632) = 0u;
  *(_OWORD *)(Instance + 584) = 0u;
  *(_OWORD *)(Instance + 600) = 0u;
  *(_OWORD *)(Instance + 552) = 0u;
  *(_OWORD *)(Instance + 56_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 520) = 0u;
  *(_OWORD *)(Instance + 536) = 0u;
  *(_OWORD *)(Instance + 48_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 504) = 0u;
  *(_OWORD *)(Instance + 456) = 0u;
  *(_OWORD *)(Instance + 472) = 0u;
  *(_OWORD *)(Instance + 424) = 0u;
  *(_OWORD *)(Instance + 440) = 0u;
  *(_OWORD *)(Instance + 392) = 0u;
  *(_OWORD *)(Instance + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 360) = 0u;
  *(_OWORD *)(Instance + 376) = 0u;
  *(_OWORD *)(Instance + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 344) = 0u;
  *(_OWORD *)(Instance + 296) = 0u;
  *(_OWORD *)(Instance + 312) = 0u;
  *(_OWORD *)(Instance + 264) = 0u;
  *(_OWORD *)(Instance + 280) = 0u;
  if (!Length) {
    goto LABEL_76;
  }
  unsigned int v7 = *BytePtr;
  UInt8 bytes = BytePtr + 1;
  unint64_t v68 = Length - 1;
  if (v7 > 6) {
    goto LABEL_76;
  }
  if (Length < 5) {
    goto LABEL_76;
  }
  *(_DWORD *)(Instance + 16) = bswap32(*(_DWORD *)(BytePtr + 1));
  unint64_t v68 = Length - 5;
  UInt8 bytes = BytePtr + 5;
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v9 = SecOTRFullIdentityCreateFromBytes((const __CFAllocator *)*MEMORY[0x189604DB0], (const UInt8 **)&bytes, &v68, 0LL);
  *(void *)(Instance + 24) = v9;
  if (!v9) {
    goto LABEL_76;
  }
  uint64_t v10 = SecOTRPublicIdentityCreateFromBytes((uint64_t)v8, (uint64_t *)&bytes, &v68, 0LL);
  *(void *)(Instance + 32) = v10;
  if (!v10) {
    goto LABEL_76;
  }
  unint64_t v11 = v68;
  unint64_t v12 = v68 - 17;
  if (v68 < 0x11) {
    goto LABEL_76;
  }
  uint64_t v13 = bytes;
  *(_OWORD *)(Instance + 40) = *(_OWORD *)bytes;
  int v14 = v13[16];
  uint64_t v15 = v13 + 17;
  unint64_t v68 = v12;
  UInt8 bytes = v13 + 17;
  if (v14)
  {
    if (v12 < 4
      || (unint64_t v16 = bswap32(*(_DWORD *)(v13 + 17)),
          uint64_t v15 = v13 + 21,
          unint64_t v12 = v11 - 21,
          unint64_t v68 = v11 - 21,
          UInt8 bytes = v13 + 21,
          v11 - 21 < v16))
    {
      CFMutableDataRef Mutable = 0LL;
    }

    else
    {
      CFMutableDataRef Mutable = CFDataCreateMutable(v8, 0LL);
      CFDataAppendBytes(Mutable, bytes, v16);
      uint64_t v15 = &bytes[v16];
      unint64_t v12 = v68 - v16;
      v68 -= v16;
      bytes += v16;
    }

    *(void *)(Instance + 56) = Mutable;
  }

  if (v7 < 2) {
    goto LABEL_25;
  }
  if (v12)
  {
    id v18 = v15 + 1;
    int v19 = *v15;
    unint64_t v20 = v12 - 1;
    unint64_t v68 = v12 - 1;
    UInt8 bytes = v15 + 1;
    if (v19)
    {
      BOOL v21 = v12 >= 5;
      unint64_t v22 = v12 - 5;
      if (v21)
      {
        unint64_t v23 = bswap32(*(_DWORD *)(v15 + 1));
        id v18 = v15 + 5;
        unint64_t v68 = v22;
        UInt8 bytes = v15 + 5;
        if (v22 < v23)
        {
          __int128 v66 = 0LL;
          unint64_t v20 = v22;
        }

        else
        {
          __int128 v66 = CFDataCreateMutable(v8, 0LL);
          CFDataAppendBytes(v66, bytes, v23);
          id v18 = &bytes[v23];
          unint64_t v20 = v68 - v23;
          v68 -= v23;
          bytes += v23;
        }
      }

      else
      {
        __int128 v66 = 0LL;
      }

      *(void *)(Instance + 64) = v66;
    }

    uint64_t v15 = v18;
  }

  else
  {
    unint64_t v20 = 0LL;
  }

  unint64_t v12 = v20;
  if (v7 <= 2)
  {
LABEL_25:
    if (!v12) {
      goto LABEL_76;
    }
    int v24 = *v15++;
    unint64_t v20 = v12 - 1;
    unint64_t v68 = v12 - 1;
    UInt8 bytes = v15;
    if (v24 && !*(_DWORD *)(Instance + 16)) {
      *(_DWORD *)(Instance + 16) = 4;
    }
  }

  unint64_t v25 = v20 - 4;
  if (v20 < 4) {
    goto LABEL_76;
  }
  unsigned int v26 = bswap32(*(_DWORD *)v15);
  *(_DWORD *)(Instance + 72) = v26;
  unint64_t v68 = v25;
  UInt8 bytes = v15 + 4;
  if (v26)
  {
    CFIndex v27 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 80) = v27;
    if (!v27) {
      goto LABEL_76;
    }
    uint64_t v28 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 8_Block_object_dispose(va, 8) = v28;
    if (!v28) {
      goto LABEL_76;
    }
    unint64_t v25 = v68;
  }

  if (!v25 || (v29 = bytes, v30 = *bytes, ++bytes, v68 = v25 - 1, unint64_t v31 = v25 - 5, v25 < 5))
  {
LABEL_76:
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  unsigned int v32 = bswap32(*(_DWORD *)(v29 + 1));
  *(_DWORD *)(Instance + 96) = v32;
  unint64_t v68 = v31;
  UInt8 bytes = v29 + 5;
  if (v7 > 4)
  {
    if (!v30) {
      goto LABEL_44;
    }
    if (v30 == 1) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }

  if (!v32) {
    goto LABEL_44;
  }
  if (v32 != 1)
  {
LABEL_42:
    CFIndex v33 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(void *)(Instance + 104) = v33;
    if (!v33) {
      goto LABEL_76;
    }
  }

void SecOTRSFindKeysForMessage( uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5, void *a6, uint64_t **a7)
{
  if (a2 && a3)
  {
    unint64_t v31 = a7;
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    unint64_t v11 = (_DWORD *)(a2 + 160);
    unint64_t v12 = (_DWORD *)(a3 + 128);
    uint64_t v13 = a1 + 136;
    uint64_t v14 = a1 + 156;
    while (1)
    {
      uint64_t v15 = a1 + (v9 << 7);
      uint64_t v16 = v15 + 136;
      if (!timingsafe_bcmp((const void *)(v15 + 136), v11, 0x14uLL)
        && !timingsafe_bcmp((const void *)(v15 + 156), v12, 0x14uLL))
      {
        break;
      }

      if (!v10)
      {
        unint64_t v17 = 0LL;
        do
        {
          int v18 = *(unsigned __int8 *)(v13 + v17);
          if (v17 > 0x12) {
            break;
          }
          ++v17;
        }

        while (!v18);
        if (v18)
        {
          uint64_t v10 = 0LL;
        }

        else
        {
          unint64_t v19 = 0LL;
          do
          {
            char v20 = *(_BYTE *)(v14 + v19);
            if (v19 > 0x12) {
              break;
            }
            ++v19;
          }

          while (!v20);
          if (v20) {
            uint64_t v10 = 0LL;
          }
          else {
            uint64_t v10 = v15 + 136;
          }
        }
      }

      ++v9;
      v13 += 128LL;
      v14 += 128LL;
      if (v9 == 4)
      {
        if (v10) {
          uint64_t v16 = v10;
        }
        else {
          uint64_t v16 = a1 + 136;
        }
        __int128 v21 = *(_OWORD *)v11;
        *(_DWORD *)(v16 + 16) = v11[4];
        *(_OWORD *)uint64_t v16 = v21;
        __int128 v22 = *(_OWORD *)v12;
        *(_DWORD *)(v16 + 36) = v12[4];
        *(_OWORD *)(v16 + 20) = v22;
        *(void *)(v16 + 112) = 0LL;
        *(void *)(v16 + 120) = 0LL;
        SecOTRDHKGenerateOTRKeys(a2, a3, v16 + 60, v16 + 40, v16 + 96, v16 + 76);
        break;
      }
    }

    a7 = v31;
    if (a5)
    {
      uint64_t v23 = 96LL;
      if (a4) {
        uint64_t v23 = 60LL;
      }
      *a5 = v16 + v23;
    }

    if (a6)
    {
      uint64_t v24 = 76LL;
      if (a4) {
        uint64_t v24 = 40LL;
      }
      *a6 = v16 + v24;
    }

    if (v31)
    {
      uint64_t v25 = 120LL;
      if (a4) {
        uint64_t v25 = 112LL;
      }
      unsigned int v26 = (uint64_t *)(v16 + v25);
      goto LABEL_41;
    }
  }

  else
  {
    if (a5) {
      *a5 = 0LL;
    }
    if (a6) {
      *a6 = 0LL;
    }
    if (a7)
    {
      unsigned int v26 = &constant_zero;
LABEL_41:
      *a7 = v26;
    }
  }

uint64_t SecOTRSAppendSerialization(uint64_t a1, CFDataRef theData)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v2 = 4294967246LL;
  int v12 = -50;
  if (a1 && theData)
  {
    CFIndex Length = CFDataGetLength(theData);
    dispatch_queue_t v6 = *(dispatch_queue_s **)(a1 + 128);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecOTRSAppendSerialization_block_invoke;
    block[3] = &unk_189672F28;
    void block[5] = theData;
    block[6] = a1;
    block[4] = &v9;
    dispatch_sync(v6, block);
    if (*((_DWORD *)v10 + 6))
    {
      CFDataSetLength(theData, Length);
      uint64_t v2 = *((unsigned int *)v10 + 6);
    }

    else
    {
      uint64_t v2 = 0LL;
    }
  }

  _Block_object_dispose(&v9, 8);
  return v2;
}

void __SecOTRSAppendSerialization_block_invoke(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  UInt8 bytes = 6;
  CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), &bytes, 1LL);
  uint64_t v2 = *(__CFData **)(a1 + 40);
  *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 16LL));
  CFDataAppendBytes(v2, v54, 4LL);
  if (SecOTRFIAppendSerialization(*(void *)(*(void *)(a1 + 48) + 24LL), *(CFDataRef *)(a1 + 40), 0LL)) {
    int v3 = 0;
  }
  else {
    int v3 = -50;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    int v4 = SecOTRPIAppendSerialization( *(void *)(*(void *)(a1 + 48) + 32LL),  *(CFDataRef *)(a1 + 40),  0LL)
       ? 0
       : -50;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 40), (const UInt8 *)(*(void *)(a1 + 48) + 40LL), 16LL);
      uint64_t v5 = *(__CFData **)(a1 + 40);
      if (*(void *)(*(void *)(a1 + 48) + 56LL))
      {
        v54[0] = 1;
        CFDataAppendBytes(v5, v54, 1LL);
        dispatch_queue_t v6 = *(__CFData **)(a1 + 40);
        unsigned int v7 = *(const __CFData **)(*(void *)(a1 + 48) + 56LL);
        CFIndex Length = CFDataGetLength(v7);
        uint64_t BytePtr = CFDataGetBytePtr(v7);
        *(_DWORD *)uint64_t v54 = bswap32(Length);
        CFDataAppendBytes(v6, v54, 4LL);
        uint64_t v5 = v6;
        uint64_t v10 = (UInt8 *)BytePtr;
        CFIndex v11 = Length;
      }

      else
      {
        v54[0] = 0;
        uint64_t v10 = v54;
        CFIndex v11 = 1LL;
      }

      CFDataAppendBytes(v5, v10, v11);
      int v12 = *(__CFData **)(a1 + 40);
      if (*(void *)(*(void *)(a1 + 48) + 64LL))
      {
        v54[0] = 1;
        CFDataAppendBytes(v12, v54, 1LL);
        uint64_t v13 = *(__CFData **)(a1 + 40);
        uint64_t v14 = *(const __CFData **)(*(void *)(a1 + 48) + 64LL);
        CFIndex v15 = CFDataGetLength(v14);
        uint64_t v16 = CFDataGetBytePtr(v14);
        *(_DWORD *)uint64_t v54 = bswap32(v15);
        CFDataAppendBytes(v13, v54, 4LL);
        int v12 = v13;
        unint64_t v17 = (UInt8 *)v16;
        CFIndex v18 = v15;
      }

      else
      {
        v54[0] = 0;
        unint64_t v17 = v54;
        CFIndex v18 = 1LL;
      }

      CFDataAppendBytes(v12, v17, v18);
      unint64_t v19 = *(__CFData **)(a1 + 40);
      *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 72LL));
      CFDataAppendBytes(v19, v54, 4LL);
      uint64_t v20 = *(void *)(a1 + 48);
      if (*(_DWORD *)(v20 + 72))
      {
        SecFDHKAppendSerialization(*(void *)(v20 + 80), *(__CFData **)(a1 + 40));
        SecFDHKAppendSerialization(*(void *)(*(void *)(a1 + 48) + 88LL), *(__CFData **)(a1 + 40));
        uint64_t v20 = *(void *)(a1 + 48);
      }

      uint64_t v22 = *(void *)(v20 + 104);
      uint64_t v21 = *(void *)(v20 + 112);
      BOOL v23 = v22 == 0;
      BOOL v24 = v22 != 0;
      if (v23) {
        char v25 = 1;
      }
      else {
        char v25 = 2;
      }
      if (v21) {
        UInt8 v26 = v25;
      }
      else {
        UInt8 v26 = v24;
      }
      CFIndex v27 = *(__CFData **)(a1 + 40);
      v54[0] = v26;
      CFDataAppendBytes(v27, v54, 1LL);
      uint64_t v28 = *(__CFData **)(a1 + 40);
      *(_DWORD *)uint64_t v54 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 96LL));
      CFDataAppendBytes(v28, v54, 4LL);
      __int128 v29 = *(uint64_t **)(a1 + 48);
      if (v29[13])
      {
        AppendECPublicKeyAsDATA(*(__CFData **)(a1 + 40));
        __int128 v29 = *(uint64_t **)(a1 + 48);
      }

      if (v29[14])
      {
        AppendECPublicKeyAsDATA(*(__CFData **)(a1 + 40));
        __int128 v29 = *(uint64_t **)(a1 + 48);
        uint64_t v30 = v29[14];
      }

      else
      {
        uint64_t v30 = 0LL;
      }

      __int16 v52 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
      SecOTRSFindKeysForMessage((uint64_t)v29, v29[10], v30, 0, 0LL, 0LL, (uint64_t **)&v52);
      unint64_t v31 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v31, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 80LL),  *(void *)(*(void *)(a1 + 48) + 112LL),  1,  0LL,  0LL,  (uint64_t **)&v52);
      unsigned int v32 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v32, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 80LL),  *(void *)(*(void *)(a1 + 48) + 104LL),  0,  0LL,  0LL,  (uint64_t **)&v52);
      CFIndex v33 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v33, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 80LL),  *(void *)(*(void *)(a1 + 48) + 104LL),  1,  0LL,  0LL,  (uint64_t **)&v52);
      uint64_t v34 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v34, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 88LL),  *(void *)(*(void *)(a1 + 48) + 112LL),  0,  0LL,  0LL,  (uint64_t **)&v52);
      unint64_t v35 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v35, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 88LL),  *(void *)(*(void *)(a1 + 48) + 112LL),  1,  0LL,  0LL,  (uint64_t **)&v52);
      CFRange v36 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v36, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 88LL),  *(void *)(*(void *)(a1 + 48) + 104LL),  0,  0LL,  0LL,  (uint64_t **)&v52);
      unint64_t v37 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v37, v54, 8LL);
      SecOTRSFindKeysForMessage( *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 48) + 88LL),  *(void *)(*(void *)(a1 + 48) + 104LL),  1,  0LL,  0LL,  (uint64_t **)&v52);
      uint64_t v38 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64(*v52);
      CFDataAppendBytes(v38, v54, 8LL);
      unint64_t v39 = *(__CFData **)(a1 + 40);
      CFRange v40 = *(const __CFData **)(*(void *)(a1 + 48) + 120LL);
      CFIndex v41 = CFDataGetLength(v40);
      CFIndex v42 = CFDataGetBytePtr(v40);
      *(_DWORD *)uint64_t v54 = bswap32(v41);
      CFDataAppendBytes(v39, v54, 4LL);
      CFDataAppendBytes(v39, v42, v41);
      unint64_t v43 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 648LL);
      CFDataAppendBytes(v43, v54, 1LL);
      int v44 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 649LL);
      CFDataAppendBytes(v44, v54, 1LL);
      unint64_t v45 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 650LL);
      CFDataAppendBytes(v45, v54, 1LL);
      int v46 = *(__CFData **)(a1 + 40);
      unint64_t v47 = *(void *)(*(void *)(a1 + 48) + 656LL);
      if (!v47) {
        unint64_t v47 = constant_zero;
      }
      *(void *)uint64_t v54 = bswap64(v47);
      CFDataAppendBytes(v46, v54, 8LL);
      unint64_t v48 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 664LL);
      CFDataAppendBytes(v48, v54, 1LL);
      unint64_t v49 = *(__CFData **)(a1 + 40);
      *(void *)uint64_t v54 = bswap64((unint64_t)*(double *)(*(void *)(a1 + 48) + 672LL));
      CFDataAppendBytes(v49, v54, 8LL);
      unint64_t v50 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 680LL);
      CFDataAppendBytes(v50, v54, 1LL);
      CFIndex v51 = *(__CFData **)(a1 + 40);
      v54[0] = *(_BYTE *)(*(void *)(a1 + 48) + 681LL);
      CFDataAppendBytes(v51, v54, 1LL);
    }
  }

uint64_t SecOTRSIsForKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  int v3 = *(dispatch_queue_s **)(a1 + 128);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __SecOTRSIsForKeys_block_invoke;
  unint64_t v6[3] = &unk_189672F50;
  void v6[4] = &v7;
  void v6[5] = a1;
  void v6[6] = a2;
  v6[7] = a3;
  dispatch_sync(v3, v6);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *__SecOTRSIsForKeys_block_invoke(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = (const void *)a1[6];
  uint64_t result = *(const void **)(*(void *)(v3 + 24) + 16LL);
  if (v2) {
    BOOL v5 = result == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (result == v2) {
      goto LABEL_10;
    }
LABEL_16:
    BOOL v8 = 0;
    goto LABEL_17;
  }

  uint64_t result = (const void *)CFEqual(result, v2);
  if (!(_DWORD)result) {
    goto LABEL_16;
  }
  uint64_t v3 = a1[5];
LABEL_10:
  dispatch_queue_t v6 = (const void *)a1[7];
  uint64_t result = *(const void **)(*(void *)(v3 + 32) + 16LL);
  if (v6) {
    BOOL v7 = result == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    BOOL v8 = result == v6;
  }

  else
  {
    uint64_t result = (const void *)CFEqual(result, v6);
    BOOL v8 = (_DWORD)result != 0;
  }

uint64_t SecOTRSGetIsReadyForMessages(uint64_t a1)
{
  uint64_t v5 = 0LL;
  dispatch_queue_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = -86;
  uint64_t v1 = *(dispatch_queue_s **)(a1 + 128);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecOTRSGetIsReadyForMessages_block_invoke;
  unint64_t v4[3] = &unk_189672F78;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecOTRSGetIsReadyForMessages_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 16LL) == 4;
  return result;
}

uint64_t SecOTRSGetIsIdle(uint64_t a1)
{
  uint64_t v5 = 0LL;
  dispatch_queue_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = -86;
  uint64_t v1 = *(dispatch_queue_s **)(a1 + 128);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecOTRSGetIsIdle_block_invoke;
  unint64_t v4[3] = &unk_189672FA0;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecOTRSGetIsIdle_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 16LL) == 0;
  return result;
}

void SecOTRSPrecalculateKeys(dispatch_queue_t *context)
{
}

void SecOTRSPrecalculateKeysInternal(uint64_t *a1)
{
}

void SecOTRSPrecalculateForPair(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      SecOTRSFindKeysForMessage(a1, a2, a3, 1, 0LL, 0LL, 0LL);
      SecOTRSFindKeysForMessage(a1, a2, a3, 0, 0LL, 0LL, 0LL);
    }
  }

uint64_t SecOTRSGetMessageKind(uint64_t a1, const __CFData *a2)
{
  unsigned __int8 v2 = SecOTRSGetMessageType(a2);
  if (v2 > 0x31u) {
    return 2LL;
  }
  if (((1LL << v2) & 0x3000300000008LL) != 0) {
    return 1LL;
  }
  if (((1LL << v2) & 0x60404) != 0) {
    return 0LL;
  }
  else {
    return 2LL;
  }
}

uint64_t SecOTRSSignAndProtectMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  char v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v3 = 4294967246LL;
  int v10 = -50;
  if (a1 && a2 && a3 && *(_DWORD *)(a1 + 16) == 4)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a1 + 128);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __SecOTRSSignAndProtectMessage_block_invoke;
    unint64_t v6[3] = &unk_189672FC8;
    void v6[4] = &v7;
    void v6[5] = a1;
    void v6[6] = a3;
    v6[7] = a2;
    dispatch_sync(v4, v6);
    uint64_t v3 = *((unsigned int *)v8 + 6);
  }

  _Block_object_dispose(&v7, 8);
  return v3;
}

void __SecOTRSSignAndProtectMessage_block_invoke(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 80))
  {
    uint64_t v3 = *(void *)(v2 + 112);
    if (v3)
    {
      memset(v21, 170, sizeof(v21));
      int v4 = *(_DWORD *)(v2 + 96);
      SecOTRSRollIfTime(v2);
      uint64_t v5 = *(void *)(a1 + 40);
      if (*(_BYTE *)(v5 + 664) && *(void *)(v5 + 104))
      {
        int v4 = *(_DWORD *)(v5 + 96) - 1;
        uint64_t v3 = *(void *)(v5 + 104);
      }

      SecOTRSFindKeysForMessage(v5, *(void *)(v5 + 80), v3, 1, &v21[2], &v21[1], v21);
      if (*(_BYTE *)(*(void *)(a1 + 40) + 648LL) || (CFMutableDataRef Mutable = *(const __CFData **)(a1 + 48)) == 0LL) {
        CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
      }
      else {
        CFRetain(*(CFTypeRef *)(a1 + 48));
      }
      uint64_t v7 = *(void *)(a1 + 40);
      char v8 = *(const __CFData **)(a1 + 56);
      uint64_t v9 = v21[2];
      int v10 = v21[0];
      if (*(_BYTE *)(v7 + 649))
      {
        SecOTRSSignAndProtectCompact_locked( *(void *)(a1 + 40),  *(const __CFData **)(a1 + 56),  Mutable,  (uint64_t)v21[2],  (uint64_t)v21[1],  v21[0],  v4,  v3);
      }

      else
      {
        CFDataGetLength(Mutable);
        *(_WORD *)UInt8 bytes = 512;
        CFDataAppendBytes(Mutable, bytes, 2LL);
        bytes[0] = 3;
        CFDataAppendBytes(Mutable, bytes, 1LL);
        bytes[0] = 0;
        CFDataAppendBytes(Mutable, bytes, 1LL);
        *(_DWORD *)UInt8 bytes = bswap32(*(_DWORD *)(v7 + 72));
        CFDataAppendBytes(Mutable, bytes, 4LL);
        *(_DWORD *)UInt8 bytes = bswap32(v4);
        CFDataAppendBytes(Mutable, bytes, 4LL);
        SecFDHKAppendPublicSerialization(*(void *)(v7 + 88), Mutable);
        unint64_t v11 = *v10 + 1;
        *int v10 = v11;
        *(void *)UInt8 bytes = bswap64(v11);
        CFDataAppendBytes(Mutable, bytes, 8LL);
        CFIndex Length = CFDataGetLength(v8);
        *(_DWORD *)UInt8 bytes = bswap32(Length);
        CFDataAppendBytes(Mutable, bytes, 4LL);
        CFIndex v13 = CFDataGetLength(Mutable);
        CFDataIncreaseLength(Mutable, Length);
        uint64_t v14 = &CFDataGetMutableBytePtr(Mutable)[v13];
        uint64_t v15 = *v10;
        uint64_t BytePtr = CFDataGetBytePtr(v8);
        AES_CTR_HighHalf_Transform(16LL, (uint64_t)v9, v15, Length, (uint64_t)BytePtr, (uint64_t)v14);
        CFDataGetLength(Mutable);
        CFDataGetLength(Mutable);
        CFDataIncreaseLength(Mutable, 20LL);
        CFDataGetMutableBytePtr(Mutable);
        ccsha1_di();
        CFDataGetBytePtr(Mutable);
        cchmac();
        unint64_t v17 = *(const __CFData **)(v7 + 120);
        CFIndex v18 = CFDataGetBytePtr(v17);
        CFIndex v19 = CFDataGetLength(v17);
        CFDataAppendBytes(Mutable, v18, v19);
      }

      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
      if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
      {
        uint64_t v20 = *(void *)(a1 + 40);
        if (*(_BYTE *)(v20 + 648))
        {
          SecOTRPrepareOutgoingBytes(Mutable, *(__CFData **)(a1 + 48));
          uint64_t v20 = *(void *)(a1 + 40);
        }

        CFDataSetLength(*(CFMutableDataRef *)(v20 + 120), 0LL);
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    }
  }

void SecOTRSRollIfTime(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(a1 + 672);
  if (v3 < Current || v3 > Current + (double)*(unint64_t *)(a1 + 656))
  {
    *(_BYTE *)(a1 + 664) = 0;
    if (*(_BYTE *)(a1 + 681))
    {
      SecOTRGenerateNewProposedKey(a1);
      char v4 = 0;
      *(_BYTE *)(a1 + 681) = 0;
    }

    else
    {
      char v4 = 1;
    }

    *(_BYTE *)(a1 + 680) = v4;
    *(void *)(a1 + 672) = 0LL;
  }

void SecOTRSSignAndProtectCompact_locked( uint64_t a1, const __CFData *a2, CFDataRef theData, uint64_t a4, uint64_t a5, uint64_t *a6, char a7, uint64_t a8)
{
  uint64_t v34 = a5;
  uint64_t v37 = *MEMORY[0x1895F89C0];
  CFDataGetLength(theData);
  int v15 = *(unsigned __int8 *)(a1 + 650);
  if (*(_BYTE *)(a1 + 650)) {
    char v16 = 48;
  }
  else {
    char v16 = 32;
  }
  bytes[0] = v16 & 0xFE | a7 & 1;
  CFDataAppendBytes(theData, bytes, 1LL);
  SecFDHKAppendCompactPublicSerialization(*(void *)(a1 + 88), theData);
  unint64_t v17 = *a6 + 1;
  *a6 = v17;
  CFIndex v18 = (const UInt8 *)&v36;
  memset(bytes, 170, sizeof(bytes));
  char v36 = v17 & 0x7F;
  if (v17 >= 0x80)
  {
    do
    {
      unint64_t v19 = v17 >> 14;
      v17 >>= 7;
      *--CFIndex v18 = v17 | 0x80;
    }

    while (v19);
  }

  CFDataAppendBytes(theData, v18, bytes - v18 + 10);
  CFIndex Length = CFDataGetLength(a2);
  CFIndex v21 = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, Length);
  uint64_t v22 = &CFDataGetMutableBytePtr(theData)[v21];
  uint64_t v23 = *a6;
  uint64_t BytePtr = CFDataGetBytePtr(a2);
  AES_CTR_HighHalf_Transform(16LL, a4, v23, Length, (uint64_t)BytePtr, (uint64_t)v22);
  if (v15)
  {
    CFIndex v25 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20LL);
    UInt8 v26 = &CFDataGetMutableBytePtr(theData)[v25];
    uint64_t v27 = *(void *)(a1 + 80);
    int v28 = *(_DWORD *)(v27 + 176);
    *(_OWORD *)UInt8 v26 = *(_OWORD *)(v27 + 160);
    *((_DWORD *)v26 + 4) = v28;
    CFIndex v29 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20LL);
    uint64_t v30 = &CFDataGetMutableBytePtr(theData)[v29];
    int v31 = *(_DWORD *)(a8 + 144);
    *(_OWORD *)uint64_t v30 = *(_OWORD *)(a8 + 128);
    *((_DWORD *)v30 + 4) = v31;
  }

  CFIndex v32 = CFDataGetLength(theData);
  MEMORY[0x1895F8858](v32);
  memset(v33, 170, 20);
  ccsha1_di();
  CFDataGetBytePtr(theData);
  cchmac();
  CFDataAppendBytes(theData, v33, 16LL);
}

uint64_t SecOTRGenerateNewProposedKey(uint64_t a1)
{
  uint64_t v2 = 0LL;
  double v3 = (const void *)(*(void *)(a1 + 80) + 160LL);
  do
  {
    if (!timingsafe_bcmp((const void *)(a1 + v2 + 136), v3, 0x14uLL))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(a1 + v2 + 212), 20LL);
      *(_OWORD *)(a1 + v2 + 232) = 0u;
      *(_OWORD *)(a1 + v2 + 24_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a1 + v2 + 200) = 0u;
      *(_OWORD *)(a1 + v2 + 216) = 0u;
      *(_OWORD *)(a1 + v2 + 16_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(a1 + v2 + 184) = 0u;
      *(_OWORD *)(a1 + v2 + 136) = 0u;
      *(_OWORD *)(a1 + v2 + 152) = 0u;
    }

    v2 += 128LL;
  }

  while (v2 != 512);
  *(int8x16_t *)(a1 + 80) = vextq_s8(*(int8x16_t *)(a1 + 80), *(int8x16_t *)(a1 + 80), 8uLL);
  uint64_t result = SecFDHKNewKey();
  ++*(_DWORD *)(a1 + 72);
  return result;
}

void SecOTRSKickTimeToRoll(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 672) = CFAbsoluteTimeGetCurrent();
}

uint64_t SecOTRSetupInitialRemoteKey(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 56_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 48_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  char v4 = *(const void **)(a1 + 104);
  if (v4)
  {
    *(void *)(a1 + 104) = 0LL;
    CFRelease(v4);
  }

  uint64_t v5 = *(const void **)(a1 + 112);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 112) = a2;
  *(_DWORD *)(a1 + 96) = 1;
  return 0LL;
}

uint64_t SOSOTRSRoll(uint64_t result)
{
  uint64_t v1 = result;
  *(_BYTE *)(result + 664) = 0;
  if (*(_BYTE *)(result + 681))
  {
    uint64_t result = SecOTRGenerateNewProposedKey(result);
    char v2 = 0;
    *(_BYTE *)(v1 + 681) = 0;
  }

  else
  {
    char v2 = 1;
  }

  *(_BYTE *)(v1 + 680) = v2;
  return result;
}

uint64_t SecOTRSVerifyAndExposeMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v10 = 0LL;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v3 = 4294967246LL;
  int v13 = -50;
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      dispatch_queue_t v6 = *(dispatch_queue_s **)(a1 + 128);
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 0x40000000LL;
      _OWORD v9[2] = __SecOTRSVerifyAndExposeMessage_block_invoke;
      v9[3] = &unk_189672FF0;
      void v9[4] = &v10;
      void v9[5] = a2;
      void v9[6] = a1;
      v9[7] = a3;
      dispatch_sync(v6, v9);
      uint64_t v3 = *((unsigned int *)v11 + 6);
    }

    else
    {
      uint64_t v7 = (os_log_s *)secLogObjForScope("OTR");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218498;
        uint64_t v15 = a1;
        __int16 v16 = 2112;
        uint64_t v17 = a2;
        __int16 v18 = 2112;
        uint64_t v19 = a1;
        _os_log_impl( &dword_1804F4000,  v7,  OS_LOG_TYPE_DEFAULT,  "session[%p]Cannot process message:%@, session is not done negotiating, session state: %@",  buf,  0x20u);
      }

      uint64_t v3 = 4294941965LL;
      *((_DWORD *)v11 + 6) = -25331;
    }
  }

  _Block_object_dispose(&v10, 8);
  return v3;
}

void __SecOTRSVerifyAndExposeMessage_block_invoke(uint64_t a1)
{
  uint64_t v1 = (void *)a1;
  v92[3] = *MEMORY[0x1895F89C0];
  char v2 = (const __CFData *)SecOTRCopyIncomingBytes(*(const __CFData **)(a1 + 40));
  unsigned __int8 v3 = SecOTRSGetMessageType(v2);
  int v4 = -25256;
  if (v3 > 0x31u) {
    goto LABEL_85;
  }
  if (((1LL << v3) & 0x3000300000000LL) == 0)
  {
    if (v3 != 3LL) {
      goto LABEL_85;
    }
    uint64_t v29 = v1[6];
    uint64_t v30 = (const __CFData *)v1[7];
    v79 = v1;
    uint64_t BytePtr = CFDataGetBytePtr(v2);
    unint64_t Length = CFDataGetLength(v2);
    if (Length >= 2)
    {
      if (__rev16(*(unsigned __int16 *)BytePtr) != 2)
      {
        uint64_t v34 = 0LL;
        uint64_t v35 = 0LL;
        int v4 = -26275;
        goto LABEL_93;
      }

      unint64_t v33 = Length;
      if (Length != 2)
      {
        uint64_t v34 = 0LL;
        int v4 = -26275;
        if (Length == 3)
        {
          uint64_t v35 = 0LL;
          goto LABEL_93;
        }

        uint64_t v35 = 0LL;
        if (BytePtr[2] != 3)
        {
LABEL_93:
          *(void *)__b1 = MEMORY[0x1895F87A8];
          *(void *)&__b1[8] = 0x40000000LL;
          *(void *)&__b1[16] = __SecOTRVerifyAndExposeRaw_locked_block_invoke;
          v86 = &__block_descriptor_tmp_68_10758;
          uint64_t v87 = v29;
          uint64_t v88 = v35;
          uint64_t v89 = v34;
          if (v2)
          {
            __int128 v66 = (const __CFAllocator *)*MEMORY[0x189604DB0];
            CFIndex v67 = CFDataGetLength(v2);
            CFMutableDataRef Mutable = CFStringCreateMutable(v66, 2 * v67);
            __int128 v69 = CFDataGetBytePtr(v2);
            CFIndex v70 = CFDataGetLength(v2);
            uint64_t v1 = v79;
            if (v70 >= 1)
            {
              CFIndex v71 = v70;
              do
              {
                unsigned int v72 = *v69++;
                CFStringAppendFormat(Mutable, 0LL, @"%02X", v72);
                --v71;
              }

              while (v71);
            }
          }

          else
          {
            CFMutableDataRef Mutable = @"(null)";
            uint64_t v1 = v79;
          }

          __SecOTRVerifyAndExposeRaw_locked_block_invoke((uint64_t)__b1, (uint64_t)Mutable);
          uint64_t v64 = Mutable;
          goto LABEL_84;
        }

        if (BytePtr[3])
        {
          uint64_t v34 = 0LL;
          uint64_t v35 = 0LL;
          goto LABEL_93;
        }

        unint64_t v36 = Length & 0xFFFFFFFFFFFFFFFCLL;
        if ((Length & 0xFFFFFFFFFFFFFFFCLL) != 4)
        {
          unsigned int v37 = bswap32(*((_DWORD *)BytePtr + 1));
          unsigned int v38 = *(_DWORD *)(v29 + 96);
          if (v37 != v38 && (v37 != v38 - 1 || !*(void *)(v29 + 104)))
          {
            uint64_t v34 = 0LL;
            uint64_t v35 = 0LL;
            BOOL v65 = v37 + 1 >= v38;
            goto LABEL_90;
          }

          theDataa = v30;
          if (v36 != 8)
          {
            unsigned int v39 = bswap32(*((_DWORD *)BytePtr + 2));
            unsigned int v40 = *(_DWORD *)(v29 + 72);
            if (v39 == v40 || v39 == v40 + 1 && *(void *)(v29 + 88))
            {
              v92[0] = 0xAAAAAAAAAAAAAAAALL;
              uint64_t v83 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
              unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
              BOOL v10 = v39 == v40;
              uint64_t v41 = 88LL;
              if (v10) {
                uint64_t v41 = 80LL;
              }
              uint64_t v34 = *(void *)(v29 + v41);
              BOOL v10 = v37 == v38;
              uint64_t v42 = 104LL;
              if (v10) {
                uint64_t v42 = 112LL;
              }
              uint64_t v35 = *(void *)(v29 + v42);
              SecOTRSFindKeysForMessage(v29, v34, v35, 0, v92, &v84, (uint64_t **)&v83);
              if (v36 != 12)
              {
                unint64_t v43 = (uint64_t *)bswap32(*((_DWORD *)BytePtr + 3));
                unint64_t v44 = v33 - 16 - (void)v43;
                v82[1] = (uint64_t *)(BytePtr + 16);
                v82[2] = v43;
                if (v44 >= 8)
                {
                  unint64_t v45 = (char *)v43 + (void)(BytePtr + 16);
                  unint64_t v46 = bswap64(*(void *)v45);
                  if (v46 <= *v83)
                  {
                    int v4 = -25328;
                    goto LABEL_93;
                  }

                  if ((v44 & 0xFFFFFFFFFFFFFFFCLL) != 8)
                  {
                    unint64_t v47 = bswap32(*((_DWORD *)v45 + 2));
                    unint64_t v48 = v44 - 12;
                    BOOL v65 = v48 >= v47;
                    unint64_t v49 = v48 - v47;
                    if (v65)
                    {
                      CFDataRef v81 = v2;
                      memset(__b1, 170, 20);
                      if (v49 >= 0x14)
                      {
                        uint64_t v50 = (uint64_t)(v45 + 12);
                        CFIndex v51 = &v45[v47 + 12];
                        ccsha1_di();
                        cchmac();
                        if (!timingsafe_bcmp(__b1, v51, 0x14uLL))
                        {
                          CFIndex v52 = CFDataGetLength(theDataa);
                          CFDataIncreaseLength(theDataa, v47);
                          Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(theDataa);
                          AES_CTR_HighHalf_Transform(16LL, v92[0], v46, v47, v50, (uint64_t)&MutableBytePtr[v52]);
                          unint64_t *v83 = v46;
                          uint64_t v54 = SecOTRPublicDHKCreateFromBytes(*MEMORY[0x189604DB0], &v82[1], &v82[2]);
                          uint64_t v1 = v79;
                          char v2 = v81;
                          if (v54 && v37 == *(_DWORD *)(v29 + 96)) {
                            SecOTRAcceptNewRemoteKey(v29, v54);
                          }
                          if (v39 == *(_DWORD *)(v29 + 72) + 1) {
                            SecOTRSHandleProposalAcknowledge(v29);
                          }
                          SecOTRSRollIfTime(v29);
                          SecOTRSPrecalculateForPair(v29, *(void *)(v29 + 80), *(void *)(v29 + 112));
                          if (v54) {
                            CFRelease(v54);
                          }
                          int v4 = 0;
                          goto LABEL_85;
                        }

                        int v4 = -25293;
                      }

                      char v2 = v81;
                    }

                    goto LABEL_93;
                  }
                }
              }

LABEL_102:
              int v4 = -50;
              goto LABEL_93;
            }

            uint64_t v34 = 0LL;
            uint64_t v35 = 0LL;
            BOOL v65 = v39 >= v40;
LABEL_90:
            if (v65) {
              int v4 = -25329;
            }
            else {
              int v4 = -25328;
            }
            goto LABEL_93;
          }
        }
      }
    }

    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    goto LABEL_102;
  }

  uint64_t v6 = v1[6];
  uint64_t v5 = (const __CFData *)v1[7];
  uint64_t v7 = CFDataGetBytePtr(v2);
  unint64_t v84 = (unint64_t)v7;
  char v8 = (uint64_t *)CFDataGetLength(v2);
  uint64_t v83 = (unint64_t *)v8;
  if (!v8)
  {
    LOBYTE(v9) = 0;
    uint64_t v15 = 0LL;
    uint64_t v13 = 0LL;
    uint64_t v18 = 0LL;
    int v4 = -50;
LABEL_69:
    *(void *)__b1 = MEMORY[0x1895F87A8];
    *(void *)&__b1[8] = 0x40000000LL;
    *(void *)&__b1[16] = __SecOTRVerifyAndExposeRawCompact_locked_block_invoke;
    v86 = &__block_descriptor_tmp_71_10759;
    uint64_t v87 = v6;
    uint64_t v88 = v18;
    uint64_t v89 = v13;
    CFTypeRef v90 = v15;
    char v91 = v9;
    if (v2)
    {
      uint64_t v55 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFIndex v56 = CFDataGetLength(v2);
      uint64_t v57 = CFStringCreateMutable(v55, 2 * v56);
      int v58 = CFDataGetBytePtr(v2);
      CFIndex v59 = CFDataGetLength(v2);
      if (v59 >= 1)
      {
        CFIndex v60 = v59;
        do
        {
          unsigned int v61 = *v58++;
          CFStringAppendFormat(v57, 0LL, @"%02X", v61);
          --v60;
        }

        while (v60);
      }
    }

    else
    {
      uint64_t v57 = @"(null)";
    }

    __SecOTRVerifyAndExposeRawCompact_locked_block_invoke((uint64_t)__b1, (uint64_t)v57);
    CFRelease(v57);
    if (v15) {
      goto LABEL_83;
    }
    goto LABEL_85;
  }

  unsigned int v9 = *v7;
  unint64_t v84 = (unint64_t)(v7 + 1);
  uint64_t v83 = (unint64_t *)((char *)v8 - 1);
  BOOL v10 = v9 > 0x31 || ((1LL << v9) & 0x3000300000000LL) == 0;
  if (v10)
  {
    uint64_t v15 = 0LL;
    uint64_t v13 = 0LL;
LABEL_68:
    uint64_t v18 = 0LL;
    int v4 = -26275;
    goto LABEL_69;
  }

  char v11 = ((v9 & 0xFFFFFFEF) != 32) ^ *(_BYTE *)(v6 + 72);
  uint64_t v12 = 80LL;
  if ((v11 & 1) != 0) {
    uint64_t v12 = 88LL;
  }
  uint64_t v13 = *(void *)(v6 + v12);
  if (!v13)
  {
    uint64_t v15 = 0LL;
    goto LABEL_68;
  }

  uint64_t v14 = (__CFString *)SecOTRPublicDHKCreateFromCompactSerialization( *MEMORY[0x189604DB0],  &v84,  (unint64_t *)&v83);
  uint64_t v15 = v14;
  if (!v14) {
    goto LABEL_68;
  }
  __int16 v16 = *(const void **)(v6 + 112);
  if (!v16) {
    goto LABEL_68;
  }
  char v75 = v11;
  CFDataRef theData = v5;
  CFDataRef v80 = v2;
  int v74 = CFEqual(v14, v16);
  uint64_t v17 = 104LL;
  if (!v74) {
    uint64_t v17 = 112LL;
  }
  uint64_t v18 = *(void *)(v6 + v17);
  if (!v18)
  {
LABEL_65:
    int v4 = -26275;
LABEL_66:
    char v2 = v80;
    goto LABEL_69;
  }

  int v19 = v9 & 0xFE;
  memset(v82, 170, sizeof(v82));
  SecOTRSFindKeysForMessage(v6, v13, v18, 0, &v82[2], &v82[1], v82);
  unint64_t v20 = 0LL;
  CFIndex v21 = (uint64_t *)v83;
  uint64_t v22 = (char *)v84;
  uint64_t v23 = (char *)v83 + v84;
  do
  {
    if (!v21)
    {
      uint64_t v83 = 0LL;
      unint64_t v84 = (unint64_t)v23;
      goto LABEL_65;
    }

    char v24 = *v22++;
    unint64_t v25 = v24 & 0x7F | (v20 << 7);
    CFIndex v21 = (uint64_t *)((char *)v21 - 1);
    unint64_t v20 = v25;
  }

  while (v24 < 0);
  uint64_t v83 = (unint64_t *)v21;
  unint64_t v84 = (unint64_t)v22;
  if (v25 <= *v82[0])
  {
    int v4 = -25328;
    goto LABEL_66;
  }

  v78 = v1;
  uint64_t v26 = 16LL;
  if (v19 == 48) {
    uint64_t v26 = 56LL;
  }
  uint64_t v27 = 0x1FFFFFFFFFFFFFFELL;
  if (v19 == 48) {
    uint64_t v27 = 0x1FFFFFFFFFFFFFF9LL;
  }
  extraunint64_t Length = (CFIndex)&v21[v27];
  int v28 = (char *)&v21[v27] + (void)v22;
  uint64_t v83 = (unint64_t *)v26;
  unint64_t v84 = (unint64_t)v28;
  if (v19 == 48)
  {
    v28 += 40;
    uint64_t v83 = (unint64_t *)(v26 - 40);
    unint64_t v84 = (unint64_t)v28;
    memset(v92, 170, 20);
    if (v26 != 56)
    {
      int v4 = -26275;
LABEL_109:
      uint64_t v1 = v78;
      goto LABEL_66;
    }
  }

  else
  {
    memset(v92, 170, 20);
  }

  ccsha1_di();
  cchmac();
  if (timingsafe_bcmp(v92, v28, 0x10uLL))
  {
    int v4 = -25293;
    goto LABEL_109;
  }

  CFIndex v62 = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, extraLength);
  int v63 = CFDataGetMutableBytePtr(theData);
  AES_CTR_HighHalf_Transform(16LL, (uint64_t)v82[2], v25, extraLength, (uint64_t)v22, (uint64_t)&v63[v62]);
  *v82[0] = v25;
  uint64_t v1 = v78;
  if (!v74) {
    SecOTRAcceptNewRemoteKey(v6, v15);
  }
  char v2 = v80;
  if ((v75 & 1) != 0) {
    SecOTRSHandleProposalAcknowledge(v6);
  }
  SecOTRSRollIfTime(v6);
  SecOTRSPrecalculateForPair(v6, *(void *)(v6 + 80), *(void *)(v6 + 112));
  int v4 = 0;
  if (v15)
  {
LABEL_83:
    uint64_t v64 = v15;
LABEL_84:
    CFRelease(v64);
  }

void SecOTRAcceptNewRemoteKey(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (const void *)(v4 + 128);
    do
    {
      uint64_t v7 = a1 + v5;
      if (!timingsafe_bcmp((const void *)(a1 + v5 + 156), v6, 0x14uLL))
      {
        CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(v7 + 212), 20LL);
        *(_OWORD *)(v7 + 24_Block_object_dispose(va, 8) = 0u;
        *(_OWORD *)(v7 + 232) = 0u;
        *(_OWORD *)(v7 + 216) = 0u;
        *(_OWORD *)(v7 + 200) = 0u;
        *(_OWORD *)(v7 + 184) = 0u;
        *(_OWORD *)(v7 + 16_Block_object_dispose(va, 8) = 0u;
        *(_OWORD *)(v7 + 152) = 0u;
        *(_OWORD *)(v7 + 136) = 0u;
      }

      v5 += 128LL;
    }

    while (v5 != 512);
    char v8 = *(const void **)(a1 + 104);
    if (v8)
    {
      *(void *)(a1 + 104) = 0LL;
      CFRelease(v8);
    }
  }

  *(void *)(a1 + 104) = *(void *)(a1 + 112);
  CFRetain(cf);
  *(void *)(a1 + 112) = cf;
  *(_BYTE *)(a1 + 664) = 1;
  ++*(_DWORD *)(a1 + 96);
  double v9 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
  double v10 = *(double *)(a1 + 672);
  if (v10 == 0.0 || v10 > v9) {
    *(double *)(a1 + 672) = v9;
  }
}

void SecOTRSHandleProposalAcknowledge(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 680))
  {
    SecOTRGenerateNewProposedKey(a1);
    *(_BYTE *)(a1 + 680) = 0;
  }

  else
  {
    *(_BYTE *)(a1 + 681) = 1;
    double v2 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
    double v3 = *(double *)(a1 + 672);
    if (v3 == 0.0 || v3 > v2) {
      *(double *)(a1 + 672) = v2;
    }
  }

uint64_t SecOTRSessionCreateRemote(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecOTRSessionCreateRemote_block_invoke;
  activity_block[3] = &unk_189673018;
  activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_1804F4000, "SecOTRSessionCreateRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void __SecOTRSessionCreateRemote_block_invoke(void *a1)
{
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1) {
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10734);
  }
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 176)) != 0LL)
  {
    uint64_t v3 = v2(a1[5], a1[6]);
  }

  else
  {
    uint64_t v5 = a1[5];
    uint64_t v4 = (CFTypeRef *)a1[6];
    uint64_t v8 = 0LL;
    double v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = 0LL;
    void v6[4] = &v8;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __data_to_data_error_request_block_invoke;
    unint64_t v7[3] = &__block_descriptor_tmp_73_10770;
    UInt8 v7[4] = v5;
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __data_to_data_error_request_block_invoke_2;
    unint64_t v6[3] = &unk_189673188;
    securityd_send_sync_and_do(0x15u, v4, (uint64_t)v7, (uint64_t)v6);
    uint64_t v3 = v9[3];
    _Block_object_dispose(&v8, 8);
  }

  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
}

BOOL __data_to_data_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v4 = *(const __CFData **)(a1 + 32);
  return !v4 || SecXPCDictionarySetData(a2, "publicPeerId", v4, a3);
}

BOOL __data_to_data_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFDataRef v4 = SecXPCDictionaryCopyData(a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return v4 != 0LL;
}

uint64_t SecOTRSessionProcessPacketRemote( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = -86;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecOTRSessionProcessPacketRemote_block_invoke;
  activity_block[3] = &unk_189673040;
  activity_block[4] = &v9;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  void activity_block[7] = a3;
  void activity_block[8] = a4;
  void activity_block[9] = a5;
  activity_block[10] = a6;
  _os_activity_initiate(&dword_1804F4000, "SecOTRSessionProcessPacketRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void __SecOTRSessionProcessPacketRemote_block_invoke(void *a1)
{
  if (gSecurityd
    && (uint64_t v2 = *(uint64_t (**)(void, void, void, void, void, void))(gSecurityd + 184)) != 0LL)
  {
    char v3 = v2(a1[5], a1[6], a1[7], a1[8], a1[9], a1[10]);
  }

  else
  {
    uint64_t v5 = (void *)a1[7];
    CFDataRef v4 = (void *)a1[8];
    uint64_t v7 = (_BYTE *)a1[9];
    uint64_t v6 = (CFTypeRef *)a1[10];
    uint64_t v19 = 0LL;
    unint64_t v20 = &v19;
    uint64_t v21 = 0x2000000000LL;
    uint64_t v22 = 0LL;
    uint64_t v15 = 0LL;
    __int16 v16 = &v15;
    uint64_t v17 = 0x2000000000LL;
    uint64_t v18 = 0LL;
    uint64_t v11 = 0LL;
    char v12 = &v11;
    uint64_t v13 = 0x2000000000LL;
    char v14 = 0;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    _OWORD v9[2] = __data_data_to_data_data_BOOL_error_request_block_invoke;
    v9[3] = &__block_descriptor_tmp_75_10775;
    __int128 v10 = *(_OWORD *)(a1 + 5);
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    _DWORD v8[2] = __data_data_to_data_data_BOOL_error_request_block_invoke_2;
    unint64_t v8[3] = &unk_1896731D0;
    void v8[4] = &v19;
    void v8[5] = &v15;
    void v8[6] = &v11;
    char v3 = securityd_send_sync_and_do(0x16u, v6, (uint64_t)v9, (uint64_t)v8);
    *uint64_t v5 = v20[3];
    *CFDataRef v4 = v16[3];
    *uint64_t v7 = *((_BYTE *)v12 + 24);
    _Block_object_dispose(&v11, 8);
    _Block_object_dispose(&v15, 8);
    _Block_object_dispose(&v19, 8);
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
}

uint64_t SecOTRSessionIsSessionInAwaitingState(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1 < 5) {
    return (0xFu >> v1) & 1;
  }
  char v3 = (os_log_s *)secLogObjForScope("otrtimer");
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v4)
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "unknown otr auth state", v5, 2u);
    return 0LL;
  }

  return result;
}

uint64_t SecOTRSAppendStartPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = 0;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 128);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRSAppendStartPacket_block_invoke;
  block[3] = &unk_189673240;
  block[4] = &v6;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecOTRSAppendStartPacket_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  *(_DWORD *)(v2 + 16) = 1;
  SecOTRInitMyDHKeys(v2);
  uint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = CCRandomCopyBytes();
  if (!*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    SecOTRAppendDHMessage(a1[5], Mutable);
  }
  uint64_t v15 = MEMORY[0x1895F87A8];
  uint64_t v16 = 0x40000000LL;
  uint64_t v17 = __SecOTRSAppendStartPacket_block_invoke_2;
  uint64_t v18 = &__block_descriptor_tmp_10781;
  uint64_t v19 = a1[5];
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(Mutable);
    uint64_t v6 = CFStringCreateMutable(v3, 2 * Length);
    uint64_t BytePtr = CFDataGetBytePtr(Mutable);
    CFIndex v8 = CFDataGetLength(Mutable);
    if (v8 >= 1)
    {
      CFIndex v9 = v8;
      do
      {
        unsigned int v10 = *BytePtr++;
        CFStringAppendFormat(v6, 0LL, @"%02X", v10, v15, v16, v17, v18, v19);
        --v9;
      }

      while (v9);
    }
  }

  else
  {
    uint64_t v6 = @"(null)";
  }

  __SecOTRSAppendStartPacket_block_invoke_2((uint64_t)&v15, (uint64_t)v6);
  CFRelease(v6);
  uint64_t v11 = a1[5];
  char v12 = (__CFData *)a1[6];
  if (*(_BYTE *)(v11 + 648))
  {
    SecOTRPrepareOutgoingBytes(Mutable, v12);
    if (!Mutable) {
      return;
    }
    goto LABEL_11;
  }

  uint64_t v13 = CFDataGetBytePtr(Mutable);
  CFIndex v14 = CFDataGetLength(Mutable);
  CFDataAppendBytes(v12, v13, v14);
  if (Mutable) {
LABEL_11:
  }
    CFRelease(Mutable);
}

void SecOTRInitMyDHKeys(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 80) = 0LL;
    CFRelease(v2);
  }

  *(void *)(a1 + 80) = SecOTRFullDHKCreate();
  uint64_t v3 = *(const void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = SecOTRFullDHKCreate();
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v4;
  *(_DWORD *)(a1 + 72) = 1;
  *(_WORD *)(a1 + 680) = 1;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 48_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 56_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  uint64_t v5 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 80);
    int v7 = 138412546;
    uint64_t v8 = a1;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "%@ Reinitializing DH Keys, first: %@",  (uint8_t *)&v7,  0x16u);
  }

void __SecOTRSAppendStartPacket_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ Start packet: %@", (uint8_t *)&v6, 0x16u);
  }

uint64_t SecOTRSAppendRestartPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  int v9 = 0;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 128);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecOTRSAppendRestartPacket_block_invoke;
  block[3] = &unk_189673288;
  block[4] = &v6;
  void block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecOTRSAppendRestartPacket_block_invoke(void *a1)
{
  if (*(void *)(a1[5] + 80LL))
  {
    uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
    uint64_t v4 = a1[5];
    *(_DWORD *)(v4 + 16) = 1;
    uint64_t v5 = *(const void **)(v4 + 56);
    if (v5)
    {
      *(void *)(v4 + 56) = 0LL;
      CFRelease(v5);
      uint64_t v4 = a1[5];
    }

    uint64_t v6 = *(const void **)(v4 + 64);
    if (v6)
    {
      *(void *)(v4 + 64) = 0LL;
      CFRelease(v6);
      uint64_t v4 = a1[5];
    }

    SecOTRAppendDHMessage(v4, Mutable);
    uint64_t v18 = MEMORY[0x1895F87A8];
    uint64_t v19 = 0x40000000LL;
    unint64_t v20 = __SecOTRSAppendRestartPacket_block_invoke_6;
    uint64_t v21 = &__block_descriptor_tmp_7_10793;
    uint64_t v22 = a1[5];
    if (Mutable)
    {
      CFIndex Length = CFDataGetLength(Mutable);
      uint64_t v8 = CFStringCreateMutable(v2, 2 * Length);
      uint64_t BytePtr = CFDataGetBytePtr(Mutable);
      CFIndex v10 = CFDataGetLength(Mutable);
      if (v10 >= 1)
      {
        CFIndex v11 = v10;
        do
        {
          unsigned int v12 = *BytePtr++;
          CFStringAppendFormat(v8, 0LL, @"%02X", v12, v18, v19, v20, v21, v22);
          --v11;
        }

        while (v11);
      }
    }

    else
    {
      uint64_t v8 = @"(null)";
    }

    __SecOTRSAppendRestartPacket_block_invoke_6((uint64_t)&v18, (uint64_t)v8);
    CFRelease(v8);
    uint64_t v14 = a1[5];
    uint64_t v15 = (__CFData *)a1[6];
    if (*(_BYTE *)(v14 + 648))
    {
      SecOTRPrepareOutgoingBytes(Mutable, v15);
      if (!Mutable) {
        return;
      }
      goto LABEL_17;
    }

    uint64_t v16 = CFDataGetBytePtr(Mutable);
    CFIndex v17 = CFDataGetLength(Mutable);
    CFDataAppendBytes(v15, v16, v17);
    if (Mutable) {
LABEL_17:
    }
      CFRelease(Mutable);
  }

  else
  {
    uint64_t v13 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEFAULT, "_myKey is NULL, avoiding crash", buf, 2u);
    }

    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = -26275;
  }

void __SecOTRSAppendRestartPacket_block_invoke_6(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ Restart packet: %@", (uint8_t *)&v6, 0x16u);
  }

uint64_t SecOTRSProcessPacket(uint64_t a1, CFDataRef theData, uint64_t a3)
{
  uint64_t v10 = 0LL;
  CFIndex v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  int v13 = -50;
  if (CFDataGetLength(theData) >= 1)
  {
    int v6 = *(dispatch_queue_s **)(a1 + 128);
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 0x40000000LL;
    _OWORD v9[2] = __SecOTRSProcessPacket_block_invoke;
    v9[3] = &unk_189673300;
    void v9[6] = a1;
    v9[7] = a3;
    void v9[4] = &v10;
    void v9[5] = theData;
    dispatch_sync(v6, v9);
  }

  uint64_t v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void __SecOTRSProcessPacket_block_invoke_2(uint64_t a1)
{
  uint64_t v108 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (const __CFData *)SecOTRCopyIncomingBytes(*(const __CFData **)(a1 + 40));
  uint64_t BytePtr = CFDataGetBytePtr(v2);
  unint64_t Length = CFDataGetLength(v2);
  else {
    int v7 = 255;
  }
  __int16 v8 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (*(_BYTE *)(*(void *)(a1 + 48) + 648LL))
  {
    CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  }

  else
  {
    CFMutableDataRef Mutable = *(__CFData **)(a1 + 56);
    if (Mutable) {
      CFRetain(*(CFTypeRef *)(a1 + 56));
    }
  }

  int v10 = -26275;
  if (v7 > 16)
  {
    if (v7 != 17)
    {
      if (v7 != 18) {
        goto LABEL_124;
      }
      uint64_t v18 = *(void *)(a1 + 48);
      if (*(_DWORD *)(v18 + 16) != 3) {
        goto LABEL_107;
      }
      uint64_t v19 = CFDataGetBytePtr(v2);
      unint64_t v20 = CFDataGetLength(v2);
      if (v20 >= 2)
      {
        if (v20 != 2)
        {
          int v21 = v19[2];
          v95 = (unsigned int *)(v20 - 3);
          *(void *)__int128 buf = v19 + 3;
          if (v21 == 18)
          {
            int v22 = SecVerifySignatureAndMac(v18, 1, (uint64_t)buf, (uint64_t)&v95);
            if (v22)
            {
              int v10 = v22;
            }

            else
            {
              uint64_t v23 = *(const void **)(v18 + 64);
              if (v23)
              {
                *(void *)(v18 + 64) = 0LL;
                CFRelease(v23);
              }

              int v10 = 0;
              *(_DWORD *)(v18 + 16) = 4;
            }

            goto LABEL_124;
          }

LABEL_111:
          int v10 = -26275;
          goto LABEL_124;
        }
      }

      int v10 = -50;
      goto LABEL_124;
    }

    uint64_t v34 = *(void *)(a1 + 48);
    if (*(_DWORD *)(v34 + 16) != 2)
    {
LABEL_107:
      int v10 = 0;
      goto LABEL_124;
    }

    uint64_t v35 = CFDataGetBytePtr(v2);
    v93 = v35;
    unint64_t v36 = CFDataGetLength(v2);
    unint64_t v92 = v36;
    unsigned int v37 = *(const __CFData **)(v34 + 56);
    if (!v37) {
      goto LABEL_116;
    }
    if (v36 < 2) {
      goto LABEL_116;
    }
    unsigned int v38 = *(unsigned __int16 *)v35;
    v93 = v35 + 2;
    unint64_t v92 = v36 - 2;
    if (v36 == 2) {
      goto LABEL_116;
    }
    if (__rev16(v38) != 2) {
      goto LABEL_116;
    }
    int v39 = v35[2];
    unint64_t v92 = v36 - 3;
    v93 = v35 + 3;
    if (v36 - 3 < 4) {
      goto LABEL_116;
    }
    if (v39 != 17) {
      goto LABEL_116;
    }
    unsigned int v40 = bswap32(*(_DWORD *)(v35 + 3));
    unint64_t v92 = v36 - 7;
    v93 = v35 + 7;
    if (v40 != 16) {
      goto LABEL_116;
    }
    *(_OWORD *)(v34 + 40) = *(_OWORD *)(v35 + 7);
    unint64_t v92 = v36 - 23;
    v93 = v35 + 23;
    *(void *)&__int128 v41 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)__int128 buf = v41;
    *(_OWORD *)&uint8_t buf[16] = v41;
    __int128 v97 = v41;
    __int128 v98 = v41;
    __int128 v99 = v41;
    __int128 v100 = v41;
    __int128 v101 = v41;
    __int128 v102 = v41;
    __int128 v103 = v41;
    __int128 v104 = v41;
    __int128 v105 = v41;
    __int128 v106 = v41;
    int v107 = -1431655766;
    v95 = (unsigned int *)buf;
    uint64_t v42 = CFDataGetBytePtr(v37);
    unint64_t v43 = CFDataGetLength(*(CFDataRef *)(v34 + 56));
    if (v43 >= 2)
    {
      if (v43 != 2)
      {
        if (v42[2] != 2) {
          goto LABEL_113;
        }
        if (v43 - 3 >= 4)
        {
          uint64_t v44 = bswap32(*(_DWORD *)(v42 + 3));
          uint64_t v94 = v44;
          if (v44 < 0xC5)
          {
            AES_CTR_Transform(16LL, v34 + 40, (uint64_t)&kIVZero, v44, (uint64_t)(v42 + 7), (uint64_t)buf);
            int v45 = SecOTRSetupTheirKeyFrom(v34, &v95, (unint64_t *)&v94);
            if (!v45)
            {
              int v45 = SecVerifySignatureAndMac(v34, 0, (uint64_t)&v93, (uint64_t)&v92);
              if (!v45)
              {
                SecOTRAppendSignatureMessage(v34, Mutable);
                uint64_t v46 = MEMORY[0x1895F87A8];
                *(_DWORD *)(v34 + 16) = 4;
                *(void *)__int128 buf = v46;
                *(void *)&uint8_t buf[8] = 0x40000000LL;
                *(void *)&uint8_t buf[16] = __SecOTRSProcessRevealSignatureMessage_block_invoke;
                *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_36_10811;
                *(void *)&__int128 v97 = v34;
                if (Mutable)
                {
                  unint64_t v47 = *v8;
                  CFIndex v48 = CFDataGetLength(Mutable);
                  unint64_t v49 = CFStringCreateMutable(v47, 2 * v48);
                  uint64_t v50 = CFDataGetBytePtr(Mutable);
                  CFIndex v51 = CFDataGetLength(Mutable);
                  if (v51 >= 1)
                  {
                    CFIndex v52 = v51;
                    do
                    {
                      unsigned int v53 = *v50++;
                      CFStringAppendFormat(v49, 0LL, @"%02X", v53);
                      --v52;
                    }

                    while (v52);
                  }
                }

                else
                {
                  unint64_t v49 = @"(null)";
                }

                __SecOTRSProcessRevealSignatureMessage_block_invoke((uint64_t)buf, (uint64_t)v49);
                int v10 = 0;
LABEL_123:
                CFRelease(v49);
                goto LABEL_124;
              }
            }

            int v10 = v45;
LABEL_116:
            *(void *)__int128 buf = MEMORY[0x1895F87A8];
            *(void *)&uint8_t buf[8] = 0x40000000LL;
            *(void *)&uint8_t buf[16] = __SecOTRSProcessRevealSignatureMessage_block_invoke_37;
            *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_38_10812;
            *(void *)&__int128 v97 = v34;
            DWORD2(v97) = v10;
            if (v2)
            {
              CFIndex v70 = *v8;
              CFIndex v71 = CFDataGetLength(v2);
              unint64_t v49 = CFStringCreateMutable(v70, 2 * v71);
              unsigned int v72 = CFDataGetBytePtr(v2);
              CFIndex v73 = CFDataGetLength(v2);
              if (v73 >= 1)
              {
                CFIndex v74 = v73;
                do
                {
                  unsigned int v75 = *v72++;
                  CFStringAppendFormat(v49, 0LL, @"%02X", v75);
                  --v74;
                }

                while (v74);
              }
            }

            else
            {
              unint64_t v49 = @"(null)";
            }

            __SecOTRSProcessRevealSignatureMessage_block_invoke_37((uint64_t)buf, (uint64_t)v49);
            goto LABEL_123;
          }

LABEL_113:
          int v10 = -26275;
          goto LABEL_116;
        }
      }
    }

    int v10 = -50;
    goto LABEL_116;
  }

  if (v7 == 2)
  {
    uint64_t v24 = *(void *)(a1 + 48);
    unint64_t v25 = &stru_1896794C8;
    switch(*(_DWORD *)(v24 + 16))
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_35;
      case 1:
        uint64_t v27 = *v8;
        uint64_t v54 = CFDataCreateMutable(*v8, 0LL);
        SecOTRAppendDHMessage(v24, v54);
        GXHash = (unint64_t *)FindGXHash(v54);
        CFIndex v56 = (unint64_t *)FindGXHash(v2);
        BOOL v57 = 0;
        if (GXHash && v56)
        {
          unint64_t v58 = bswap64(*GXHash);
          unint64_t v59 = bswap64(*v56);
          if (v58 == v59
            && (unint64_t v58 = bswap64(GXHash[1]), v59 = bswap64(v56[1]), v58 == v59)
            && (unint64_t v58 = bswap64(GXHash[2]), v59 = bswap64(v56[2]), v58 == v59)
            && (unint64_t v58 = bswap64(GXHash[3]), v59 = bswap64(v56[3]), v58 == v59))
          {
            int v60 = 0;
          }

          else if (v58 < v59)
          {
            int v60 = -1;
          }

          else
          {
            int v60 = 1;
          }

          BOOL v57 = v60 > 0;
          *(void *)__int128 buf = MEMORY[0x1895F87A8];
          *(void *)&uint8_t buf[8] = 0x40000000LL;
          *(void *)&uint8_t buf[16] = __SecOTRMyGXHashIsBigger_block_invoke;
          *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_26_10799;
          *(void *)&__int128 v97 = v56;
          BufferPerformWithHexString_10800((UInt8 *)GXHash, (uint64_t)buf);
        }

        if (v54) {
          CFRelease(v54);
        }
        if (v57)
        {
          int v63 = *(const void **)(v24 + 56);
          if (v63)
          {
            *(void *)(v24 + 56) = 0LL;
            CFRelease(v63);
          }

          SecOTRAppendDHMessage(v24, Mutable);
          unint64_t v25 = @"Our GX is bigger, resending DH";
        }

        else
        {
          unint64_t v25 = @"Our GX is smaller, sending DHKey";
LABEL_35:
          SecOTRInitMyDHKeys(v24);
LABEL_36:
          SecOTRAppendDHKeyMessage(v24, Mutable);
          uint64_t v26 = *(const void **)(v24 + 56);
          if (v26)
          {
            *(void *)(v24 + 56) = 0LL;
            CFRelease(v26);
          }

          uint64_t v27 = *v8;
          *(void *)(v24 + 56) = CFDataCreateCopy(*v8, v2);
          *(_DWORD *)(v24 + 16) = 2;
        }

        *(void *)__int128 buf = MEMORY[0x1895F87A8];
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&uint8_t buf[16] = __SecOTRSProcessDHMessage_block_invoke;
        *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_24_10803;
        *(void *)&__int128 v97 = v24;
        *((void *)&v97 + 1) = v25;
        if (Mutable)
        {
          CFIndex v28 = CFDataGetLength(Mutable);
          uint64_t v29 = CFStringCreateMutable(v27, 2 * v28);
          uint64_t v30 = CFDataGetBytePtr(Mutable);
          CFIndex v31 = CFDataGetLength(Mutable);
          if (v31 >= 1)
          {
            CFIndex v32 = v31;
            do
            {
              unsigned int v33 = *v30++;
              CFStringAppendFormat(v29, 0LL, @"%02X", v33);
              --v32;
            }

            while (v32);
          }
        }

        else
        {
          uint64_t v29 = @"(null)";
        }

        __SecOTRSProcessDHMessage_block_invoke((uint64_t)buf, (uint64_t)v29);
        goto LABEL_106;
      case 2:
        goto LABEL_36;
      default:
        unsigned int v61 = (os_log_s *)secLogObjForScope("otr");
        int v10 = -25308;
        if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_124;
        }
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = -25308;
        goto LABEL_85;
    }
  }

  if (v7 == 10)
  {
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = CFDataGetBytePtr(v2);
    unint64_t v13 = CFDataGetLength(v2);
    if (v13 > 2
      && __rev16(*(unsigned __int16 *)v12) == 2
      && (int v14 = v12[2], v95 = (unsigned int *)(v13 - 3), *(void *)buf = v12 + 3, v14 == 10))
    {
      int v15 = SecOTRSetupTheirKeyFrom(v11, (unsigned int **)buf, (unint64_t *)&v95);
      if (!v15)
      {
        uint64_t v16 = @"Ignoring DHKey message";
        switch(*(_DWORD *)(v11 + 16))
        {
          case 0:
          case 2:
          case 4:
            goto LABEL_99;
          case 1:
            CFIndex v17 = *(const void **)(v11 + 64);
            if (v17)
            {
              *(void *)(v11 + 64) = 0LL;
              CFRelease(v17);
            }

            SecOTRAppendRevealSignatureMessage(v11, Mutable);
            *(_DWORD *)(v11 + 16) = 3;
            *(void *)(v11 + 64) = CFDataCreateCopy(*v8, v2);
            uint64_t v16 = @"Sending reveal signature";
            goto LABEL_99;
          case 3:
            CFIndex v62 = *(const __CFData **)(v11 + 64);
            if (v2 && v62)
            {
              if (CFEqual(v2, v62))
              {
LABEL_81:
                SecOTRAppendRevealSignatureMessage(v11, Mutable);
                uint64_t v16 = @"Resending reveal signature";
                goto LABEL_99;
              }
            }

            else if (v62 == v2)
            {
              goto LABEL_81;
            }

            uint64_t v16 = @"Ignoring new DHKey message";
LABEL_99:
            *(void *)__int128 buf = MEMORY[0x1895F87A8];
            *(void *)&uint8_t buf[8] = 0x40000000LL;
            *(void *)&uint8_t buf[16] = __SecOTRSProcessDHKeyMessage_block_invoke;
            *(void *)&_BYTE buf[24] = &__block_descriptor_tmp_35_10809;
            *(void *)&__int128 v97 = v11;
            *((void *)&v97 + 1) = v16;
            if (Mutable)
            {
              uint64_t v64 = *v8;
              CFIndex v65 = CFDataGetLength(Mutable);
              uint64_t v29 = CFStringCreateMutable(v64, 2 * v65);
              __int128 v66 = CFDataGetBytePtr(Mutable);
              CFIndex v67 = CFDataGetLength(Mutable);
              if (v67 >= 1)
              {
                CFIndex v68 = v67;
                do
                {
                  unsigned int v69 = *v66++;
                  CFStringAppendFormat(v29, 0LL, @"%02X", v69);
                  --v68;
                }

                while (v68);
              }
            }

            else
            {
              uint64_t v29 = @"(null)";
            }

            __SecOTRSProcessDHKeyMessage_block_invoke((uint64_t)buf, (uint64_t)v29);
LABEL_106:
            CFRelease(v29);
            break;
          default:
            int v10 = -25308;
            goto LABEL_83;
        }

        goto LABEL_107;
      }

      int v10 = v15;
    }

    else
    {
      int v10 = -50;
    }

const UInt8 *FindGXHash(const __CFData *a1)
{
  uint64_t BytePtr = CFDataGetBytePtr(a1);
  unint64_t Length = CFDataGetLength(a1);
  if (Length < 2) {
    return 0LL;
  }
  unint64_t v4 = Length;
  uint64_t result = 0LL;
  if (v4 != 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    uint64_t result = 0LL;
    if (v4 - 3 >= 4 && BytePtr[2] == 2)
    {
      unint64_t v6 = bswap32(*(_DWORD *)(BytePtr + 3));
      unint64_t v7 = v4 - 7;
      BOOL v8 = v7 >= v6;
      unint64_t v9 = v7 - v6;
      if (!v8) {
        return 0LL;
      }
      BOOL v8 = v9 >= 4;
      unint64_t v10 = v9 - 4;
      if (!v8) {
        return 0LL;
      }
      uint64_t v11 = &BytePtr[v6];
      unint64_t v12 = bswap32(*(_DWORD *)(v11 + 7));
      unint64_t v13 = v11 + 11;
      if (v10 >= v12 && (_DWORD)v12 == 32) {
        return v13;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

void __SecOTRMyGXHashIsBigger_block_invoke(uint64_t a1)
{
}

void BufferPerformWithHexString_10800(UInt8 *bytes, uint64_t a2)
{
  uint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  unint64_t v4 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  bytes,  32LL,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  if (v4)
  {
    unsigned int v5 = v4;
    CFIndex Length = CFDataGetLength(v4);
    CFMutableDataRef Mutable = CFStringCreateMutable(v3, 2 * Length);
    uint64_t BytePtr = CFDataGetBytePtr(v5);
    CFIndex v9 = CFDataGetLength(v5);
    if (v9 >= 1)
    {
      CFIndex v10 = v9;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v11);
        --v10;
      }

      while (v10);
    }

    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, Mutable);
    CFRelease(Mutable);
  }

  else
  {
    unsigned int v5 = (const __CFData *)@"(null)";
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, @"(null)");
  }

  CFRelease(v5);
}

void __SecOTRSProcessDHMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ %@: %@", (uint8_t *)&v7, 0x20u);
  }

uint64_t SecOTRSetupTheirKeyFrom(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  unint64_t v4 = SecOTRPublicDHKCreateFromSerialization(*MEMORY[0x189604DB0], a2, a3);
  if (!v4) {
    return 4294941021LL;
  }
  SecOTRSetupInitialRemoteKey(a1, (uint64_t)v4);
  return 0LL;
}

void __SecOTRSProcessDHKeyMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ %@: %@", (uint8_t *)&v7, 0x20u);
  }

uint64_t SecVerifySignatureAndMac(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v11 = 0x2000000000LL;
  int v12 = -26275;
  void v7[2] = __SecVerifySignatureAndMac_block_invoke;
  unint64_t v7[3] = &unk_189673480;
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  char v8 = a2;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  UInt8 v7[4] = &v9;
  void v7[5] = a1;
  void v7[6] = a3;
  v7[7] = a4;
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 0x40000000LL;
  void v13[2] = __PerformWithBufferAndClear_block_invoke;
  v13[3] = &unk_189676A80;
  UInt8 v13[4] = v7;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v4;
  v14[1] = v4;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v13, 0x20uLL, v14);
  uint64_t v5 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v5;
}

void __SecOTRSProcessRevealSignatureMessage_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  __int128 v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%@ Sending Signature message: %@", (uint8_t *)&v6, 0x16u);
  }

void __SecOTRSProcessRevealSignatureMessage_block_invoke_37(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  __int128 v4 = (os_log_s *)secLogObjForScope("otr");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = *(_DWORD *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 1024;
    int v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "%@ Failed to process reveal sig message (%d): %@",  (uint8_t *)&v7,  0x1Cu);
  }

void __SecOTRSProcessPacket_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  __int128 v4 = (os_log_s *)secLogObjForScope("session");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    int v7 = *(_DWORD *)(a1 + 48);
    int v8 = *(_DWORD *)(v5 + 16);
    int v9 = *(_DWORD *)(v5 + 72);
    uint64_t v10 = *(void *)(v5 + 80);
    uint64_t v11 = *(void *)(v5 + 88);
    int v12 = *(_DWORD *)(v5 + 96);
    uint64_t v14 = *(void *)(v5 + 104);
    uint64_t v13 = *(void *)(v5 + 112);
    int v15 = 138414850;
    uint64_t v16 = v5;
    __int16 v17 = 1024;
    int v18 = v6;
    __int16 v19 = 1024;
    int v20 = v7;
    __int16 v21 = 1024;
    int v22 = v8;
    __int16 v23 = 1024;
    int v24 = v9;
    __int16 v25 = 2048;
    uint64_t v26 = v10;
    __int16 v27 = 2048;
    uint64_t v28 = v11;
    __int16 v29 = 1024;
    int v30 = v12;
    __int16 v31 = 2048;
    uint64_t v32 = v13;
    __int16 v33 = 2048;
    uint64_t v34 = v14;
    __int16 v35 = 2112;
    uint64_t v36 = a2;
    _os_log_impl( &dword_1804F4000,  v4,  OS_LOG_TYPE_DEFAULT,  "%@ Error %d processing packet type %d, session state %d, keyid %d, myKey %p, myNextKey %p, theirKeyId %d, theirKey %p, theirPreviousKey %p, bytes %@",  (uint8_t *)&v15,  0x5Cu);
  }

void __SecVerifySignatureAndMac_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v13[2] = *MEMORY[0x1895F89C0];
  void v4[2] = __SecVerifySignatureAndMac_block_invoke_3;
  unint64_t v4[3] = &unk_189673430;
  char v11 = *(_BYTE *)(a1 + 80);
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = v3;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  uint64_t v8 = a2;
  uint64_t v9 = a3;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  __int128 v10 = *(_OWORD *)(a1 + 64);
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 0x40000000LL;
  void v12[2] = __PerformWithBufferAndClear_block_invoke;
  v12[3] = &unk_189676A80;
  v12[4] = v4;
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v12, 0x10uLL, v13);
}

void __SecVerifySignatureAndMac_block_invoke_3(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v37 = v6;
  __int128 v38 = v6;
  __int128 v35 = v6;
  __int128 v36 = v6;
  __int128 v33 = v6;
  __int128 v34 = v6;
  __int128 v31 = v6;
  __int128 v32 = v6;
  __int128 v29 = v6;
  __int128 v30 = v6;
  __int128 v27 = v6;
  __int128 v28 = v6;
  ccn_zero();
  *(void *)&__int128 __src = 192LL;
  ccec_compute_key();
  if (*(_BYTE *)(a1 + 96)) {
    UInt8 v7 = 4;
  }
  else {
    UInt8 v7 = 2;
  }
  HashMPIWithPrefix(v7, 24LL, (uint64_t)&v27, *(unsigned __int8 **)(a1 + 56));
  if (*(_BYTE *)(a1 + 96)) {
    UInt8 v8 = 5;
  }
  else {
    UInt8 v8 = 3;
  }
  HashMPIWithPrefix(v8, 24LL, (uint64_t)&v27, *(unsigned __int8 **)(a1 + 72));
  int v9 = *(unsigned __int8 *)(a1 + 96);
  if (*(_BYTE *)(a1 + 96)) {
    __int128 v10 = a3;
  }
  else {
    __int128 v10 = 0LL;
  }
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 __src = v11;
  __int128 v40 = v11;
  HashMPIWithPrefix(1u, 24LL, (uint64_t)&v27, (unsigned __int8 *)&__src);
  if (!v9 && a3)
  {
    if (a2 >= 0x10) {
      size_t v12 = 16LL;
    }
    else {
      size_t v12 = a2;
    }
    memcpy(a3, &__src, v12);
  }

  if (v10)
  {
    if (a2 >= 0x10) {
      size_t v13 = 16LL;
    }
    else {
      size_t v13 = a2;
    }
    memcpy(v10, &__src, v13);
  }

  uint64_t v14 = *(unsigned int ***)(a1 + 80);
  int v15 = *(uint64_t **)(a1 + 88);
  uint64_t v16 = *v14;
  if (v15 && (uint64_t v17 = *v15 - 4, (unint64_t)*v15 >= 4))
  {
    int v18 = 0;
    unsigned int v19 = bswap32(*v16);
    *uint64_t v14 = v16 + 1;
    *int v15 = v17;
  }

  else
  {
    unsigned int v19 = 0;
    int v18 = -50;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v18;
  uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (!*(_DWORD *)(v20 + 24))
  {
    if (v19 > 4 && **(void **)(a1 + 88) >= (unint64_t)v19)
    {
      *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 __src = v21;
      __int128 v40 = v21;
      ccsha256_di();
      cchmac();
      if (**(void **)(a1 + 88) >= (unint64_t)(v19 + 20) && !cc_cmp_safe())
      {
        void v25[2] = __SecVerifySignatureAndMac_block_invoke_4;
        unint64_t v25[3] = &unk_189673408;
        uint64_t v22 = *(void *)(a1 + 48);
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        v25[6] = *(void *)(a1 + 56);
        v25[7] = v23;
        v25[0] = MEMORY[0x1895F87A8];
        v25[1] = 0x40000000LL;
        void v25[8] = a2;
        v25[9] = a3;
        unsigned int v26 = v19;
        v25[10] = *(void *)(a1 + 80);
        v25[4] = v24;
        v25[5] = v22;
        *(void *)&__int128 v27 = MEMORY[0x1895F87A8];
        *((void *)&v27 + 1) = 0x40000000LL;
        *(void *)&__int128 v28 = __PerformWithBufferAndClear_block_invoke;
        *((void *)&v28 + 1) = &unk_189676A80;
        *(void *)&__int128 v29 = v25;
        PerformWithBuffer(v19, (uint64_t)&v27);
        return;
      }

      uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8LL);
    }

    *(_DWORD *)(v20 + 24) = -26275;
  }

void __SecVerifySignatureAndMac_block_invoke_4(uint64_t a1, uint64_t a2, const UInt8 *a3)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  ccsha256_di();
  ccsha256_di();
  uint64_t v5 = ccsha256_di();
  MEMORY[0x1895F8858](v5);
  if (v8 >= 8) {
    memset((char *)&v47 - v7, 170, v6);
  }
  ccsha256_di();
  cchmac_init();
  int v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  AppendECPublicKeyAsDATA(Mutable);
  SecFDHKAppendPublicSerialization(*(void *)(*(void *)(a1 + 56) + 80LL), Mutable);
  ccsha256_di();
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(Mutable);
  cchmac_update();
  if (Mutable) {
    CFRelease(Mutable);
  }
  AES_CTR_Transform( *(void *)(a1 + 64),  *(void *)(a1 + 72),  (uint64_t)&kIVZero,  *(unsigned int *)(a1 + 88),  **(void **)(a1 + 80),  (uint64_t)a3);
  unint64_t v11 = *(unsigned int *)(a1 + 88);
  if (v11 < 2)
  {
    int v12 = -50;
    unsigned int v14 = 43690;
    size_t v13 = a3;
  }

  else
  {
    int v12 = 0;
    size_t v13 = a3 + 2;
    unsigned int v14 = __rev16(*(unsigned __int16 *)a3);
    v11 -= 2LL;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v12;
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_DWORD *)(v15 + 24)) {
    return;
  }
  if (v14 != 61440)
  {
    int v44 = -4;
LABEL_49:
    *(_DWORD *)(v15 + 24) = v44;
    return;
  }

  if (v11 < 4)
  {
    int v16 = -50;
    unsigned int v18 = -1431655766;
  }

  else
  {
    int v16 = 0;
    unsigned int v17 = *(_DWORD *)v13;
    v13 += 4;
    unsigned int v18 = bswap32(v17);
    v11 -= 4LL;
  }

  *(_DWORD *)(v15 + 24) = v16;
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_DWORD *)(v15 + 24)) {
    return;
  }
  if (v11 < v18)
  {
    int v44 = -26275;
    goto LABEL_49;
  }

  CFIndex v19 = v18;
  ccsha256_di();
  cchmac_update();
  *(void *)&__int128 v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[0] = v20;
  v53[1] = v20;
  ccsha256_di();
  cchmac_final();
  uint64_t v21 = *(void *)(*(void *)(a1 + 56) + 32LL);
  CFDataRef v22 = CFDataCreateWithBytesNoCopy(v9, v13, v19, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint64_t v23 = CFDataCreateMutable(v9, 0LL);
  SecOTRPIAppendSerialization(v21, v23, 0LL);
  if (v22 && v23)
  {
    if (CFEqual(v22, v23))
    {
      char v24 = 1;
LABEL_25:
      CFRelease(v22);
      goto LABEL_26;
    }

    CFIndex v47 = MEMORY[0x1895F87A8];
    uint64_t v48 = 0x40000000LL;
    unint64_t v49 = __SecOTRPIEqualToBytes_block_invoke;
    uint64_t v50 = &__block_descriptor_tmp_6_10517;
    CFIndex v51 = v23;
    goto LABEL_21;
  }

  if (v22 != v23)
  {
    CFIndex v47 = MEMORY[0x1895F87A8];
    uint64_t v48 = 0x40000000LL;
    unint64_t v49 = __SecOTRPIEqualToBytes_block_invoke;
    uint64_t v50 = &__block_descriptor_tmp_6_10517;
    CFIndex v51 = v23;
    if (!v22)
    {
      __int16 v25 = @"(null)";
      goto LABEL_24;
    }

void SecOTRCreateError(int a1, CFIndex code, void *a3, CFTypeRef cf, CFErrorRef *a5)
{
  userInfoKeys[2] = *(void **)MEMORY[0x1895F89C0];
  if (a5 && !*a5)
  {
    size_t v6 = (void *)*MEMORY[0x189604F88];
    userInfoKeys[0] = *(void **)MEMORY[0x189604F38];
    userInfoKeys[1] = v6;
    userInfoValues[0] = a3;
    userInfoValues[1] = (void *)cf;
    if (a1) {
      uint64_t v7 = (const __CFString *)*MEMORY[0x189604F50];
    }
    else {
      uint64_t v7 = @"com.apple.security.otr.error";
    }
    if (cf) {
      CFIndex v8 = 2LL;
    }
    else {
      CFIndex v8 = 1LL;
    }
    *a5 = CFErrorCreateWithUserInfoKeysAndValues( (CFAllocatorRef)*MEMORY[0x189604DB0],  v7,  code,  (const void *const *)userInfoKeys,  (const void *const *)userInfoValues,  v8);
  }

  else if (cf)
  {
    CFRelease(cf);
  }

uint64_t appendSizeAndData(const __CFData *a1, __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length >= 0xFFFF) {
    return 4294942005LL;
  }
  *(_WORD *)UInt8 bytes = bswap32(Length) >> 16;
  CFDataAppendBytes(a2, bytes, 2LL);
  uint64_t BytePtr = CFDataGetBytePtr(a1);
  CFIndex v6 = CFDataGetLength(a1);
  CFDataAppendBytes(a2, BytePtr, v6);
  return 0LL;
}

uint64_t appendPublicOctetsAndSize(uint64_t a1, __CFData *a2)
{
  CFTypeRef cf = 0LL;
  if (SecKeyCopyPublicBytes(a1, (uint64_t)&cf))
  {
    uint64_t appended = 4294941021LL;
  }

  else
  {
    if (!cf) {
      return 4294941021LL;
    }
    uint64_t appended = appendSizeAndData((const __CFData *)cf, a2);
  }

  CFTypeRef v4 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v4);
  }

  return appended;
}

void *CreateECPublicKeyFrom(const UInt8 **a1, unint64_t *a2)
{
  uint64_t v3 = 0LL;
  LODWORD(v4) = 0;
  if (a1 && a2)
  {
    unint64_t v5 = *a2 - 2;
    if (*a2 < 2)
    {
      LODWORD(v4) = 0;
LABEL_9:
      uint64_t v3 = 0LL;
      goto LABEL_7;
    }

    uint64_t v3 = *a1 + 2;
    unint64_t v4 = __rev16(*(unsigned __int16 *)*a1);
    *a2 = v5;
    *a1 = v3;
    BOOL v6 = v5 >= v4;
    unint64_t v7 = v5 - v4;
    if (!v6) {
      goto LABEL_9;
    }
    *a2 = v7;
    *a1 = &v3[v4];
  }

uint64_t SecOTRCopyIncomingBytes(const __CFData *a1)
{
  uint64_t v16 = 0LL;
  unsigned int v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"?OTR:",  0x8000100u,  0x3Fu);
  v20.CFIndex length = CFDataGetLength(a1);
  v20.location = 0LL;
  CFRange v4 = CFDataFind(a1, ExternalRepresentation, v20, 0LL);
  if (v4.location == -1)
  {
    unint64_t v11 = v17;
    int v12 = (const __CFData *)v17[3];
    if (v12 != a1)
    {
      if (!a1 || (CFRetain(a1), (int v12 = (const __CFData *)v11[3]) != 0LL)) {
        CFRelease(v12);
      }
      unint64_t v11[3] = (uint64_t)a1;
    }
  }

  else
  {
    unint64_t v5 = CFStringCreateExternalRepresentation(v2, @".", 0x8000100u, 0x3Fu);
    v21.CFIndex length = CFDataGetLength(a1);
    v21.location = 0LL;
    CFIndex v6 = CFDataFind(a1, v5, v21, 0LL).location - v4.length;
    uint64_t BytePtr = CFDataGetBytePtr(a1);
    uint64_t v8 = CFDataCreateWithBytesNoCopy(v2, &BytePtr[v4.length], v6, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    CFDataGetBytePtr(v8);
    unint64_t Length = CFDataGetLength(v8);
    unint64_t v10 = Length >> 2;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 0x40000000LL;
    if ((Length & 3) != 0) {
      ++v10;
    }
    uint64_t v15[2] = __SecOTRCopyIncomingBytes_block_invoke;
    unint64_t v15[3] = &unk_1896734A8;
    void v15[4] = &v16;
    void v15[5] = v8;
    PerformWithBuffer(3 * v10, (uint64_t)v15);
    CFRelease(v8);
    CFRelease(v5);
  }

  CFRelease(ExternalRepresentation);
  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

char *__SecOTRCopyIncomingBytes_block_invoke(uint64_t a1, unint64_t a2, UInt8 *a3)
{
  uint64_t BytePtr = (unsigned __int8 *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  uint64_t result = SecBase64Decode_(BytePtr, Length, a3, a2, 0, &v10, &v9);
  if ((unint64_t)(result - 1) < a2)
  {
    uint64_t result = (char *)CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], a3, (CFIndex)result);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

void SecOTRPrepareOutgoingBytes(const __CFData *a1, __CFData *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  CFRange v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"?OTR:",  0x8000100u,  0x3Fu);
  CFIndex v6 = CFStringCreateExternalRepresentation(v4, @".", 0x8000100u, 0x3Fu);
  CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  size_t v8 = (2 * (((unint64_t)(Length + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  MEMORY[0x1895F8858](Length);
  unint64_t v10 = &v24[-v9];
  if (v8)
  {
    memset(&v24[-v9], 170, v8);
    uint64_t BytePtr = CFDataGetBytePtr(a1);
    CFIndex v12 = CFDataGetLength(a1);
    uint64_t v13 = (unsigned __int8 *)BytePtr;
    unsigned int v14 = (UInt8 *)v10;
    unint64_t v15 = v8;
  }

  else
  {
    uint64_t v16 = CFDataGetBytePtr(a1);
    CFIndex v12 = CFDataGetLength(a1);
    uint64_t v13 = (unsigned __int8 *)v16;
    unsigned int v14 = (UInt8 *)v10;
    unint64_t v15 = 0LL;
  }

  SecBase64Encode_(v13, v12, v14, v15, 0, &v25);
  unsigned int v17 = CFDataCreateWithBytesNoCopy(v4, v10, v8, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  uint64_t v18 = CFDataGetBytePtr(ExternalRepresentation);
  CFIndex v19 = CFDataGetLength(ExternalRepresentation);
  CFDataAppendBytes(a2, v18, v19);
  CFRange v20 = CFDataGetBytePtr(v17);
  CFIndex v21 = CFDataGetLength(v17);
  CFDataAppendBytes(a2, v20, v21);
  CFDataRef v22 = CFDataGetBytePtr(v6);
  CFIndex v23 = CFDataGetLength(v6);
  CFDataAppendBytes(a2, v22, v23);
  CFRelease(ExternalRepresentation);
  CFRelease(v6);
  CFRelease(v17);
}

void hmac_sha1_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 0, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

void hmac_sha256_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 2u, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

uint64_t pbkdf2_hmac_sha1( uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14 = a4 + 60;
  unint64_t v15 = (char *)malloc(a4 + 60);
  if (!v15) {
    return 4294899624LL;
  }
  uint64_t v16 = v15;
  pbkdf2( (void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha1_PRF,  0x14uLL,  a1,  a2,  a3,  a4,  a5,  a6,  a7,  v15);
  bzero(v16, v14);
  return 0LL;
}

uint64_t pbkdf2_hmac_sha256( uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14 = a4 + 96;
  unint64_t v15 = (char *)malloc(a4 + 96);
  if (!v15) {
    return 4294899624LL;
  }
  uint64_t v16 = v15;
  pbkdf2( (void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha256_PRF,  0x20uLL,  a1,  a2,  a3,  a4,  a5,  a6,  a7,  v15);
  bzero(v16, v14);
  return 0LL;
}

uint64_t SecKeyFromPassphraseDataHMACSHA1( const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  uint64_t BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  unint64_t v10 = (UInt8 *)CFDataGetBytePtr(a2);
  CFIndex v11 = CFDataGetLength(a2);
  Mutableuint64_t BytePtr = (char *)CFDataGetMutableBytePtr(a4);
  CFIndex v13 = CFDataGetLength(a4);
  return pbkdf2_hmac_sha1((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t SecKeyFromPassphraseDataHMACSHA256( const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  uint64_t BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  unint64_t v10 = (UInt8 *)CFDataGetBytePtr(a2);
  CFIndex v11 = CFDataGetLength(a2);
  Mutableuint64_t BytePtr = (char *)CFDataGetMutableBytePtr(a4);
  CFIndex v13 = CFDataGetLength(a4);
  return pbkdf2_hmac_sha256((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t CryptoTokenKitLibraryCore()
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v3 = 0LL;
  CFRange v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v0 = CryptoTokenKitLibraryCore_frameworkLibrary;
  uint64_t v6 = CryptoTokenKitLibraryCore_frameworkLibrary;
  if (!CryptoTokenKitLibraryCore_frameworkLibrary)
  {
    __int128 v7 = xmmword_1896734C8;
    __int128 v8 = *(_OWORD *)&off_1896734D8;
    uint64_t v1 = _sl_dlopen();
    unint64_t v4[3] = v1;
    CryptoTokenKitLibraryCore_frameworkLibrary = v1;
    uint64_t v0 = v1;
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1805E5BCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *CryptoTokenKitLibrary()
{
  uint64_t v0 = CryptoTokenKitLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  [MEMORY[0x1896077D8] currentHandler];
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithUTF8String:"void *CryptoTokenKitLibrary(void)"];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend( v1,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  26,  @"%s",  0);

  __break(1u);
  free(v4);
  return v1;
}

id getTKClientTokenClass()
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  uint64_t v0 = (void *)getTKClientTokenClass_softClass;
  uint64_t v7 = getTKClientTokenClass_softClass;
  if (!getTKClientTokenClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getTKClientTokenClass_block_invoke;
    v3[3] = &unk_1896734F0;
    void v3[4] = &v4;
    __getTKClientTokenClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1805E5D34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __getTKClientTokenClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("TKClientToken");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getTKClientTokenClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getTKClientTokenClass(void)_block_invoke"];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  27,  @"Unable to find class %s",  "TKClientToken");

    __break(1u);
  }

id getTKClientTokenSessionClass()
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  uint64_t v0 = (void *)getTKClientTokenSessionClass_softClass;
  uint64_t v7 = getTKClientTokenSessionClass_softClass;
  if (!getTKClientTokenSessionClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getTKClientTokenSessionClass_block_invoke;
    v3[3] = &unk_1896734F0;
    void v3[4] = &v4;
    __getTKClientTokenSessionClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1805E5EB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __getTKClientTokenSessionClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("TKClientTokenSession");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getTKClientTokenSessionClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getTKClientTokenSessionClass(void)_block_invoke"];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  28,  @"Unable to find class %s",  "TKClientTokenSession");

    __break(1u);
  }

void *getTKErrorDomainSymbolLoc()
{
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v0 = (void *)getTKErrorDomainSymbolLoc_ptr;
  uint64_t v6 = getTKErrorDomainSymbolLoc_ptr;
  if (!getTKErrorDomainSymbolLoc_ptr)
  {
    id v1 = CryptoTokenKitLibrary();
    uint64_t v0 = dlsym(v1, "TKErrorDomain");
    unint64_t v4[3] = (uint64_t)v0;
    getTKErrorDomainSymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1805E600C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void getTKErrorDomain()
{
  TKErrorDomainSymbolLoc = (id *)getTKErrorDomainSymbolLoc();
  if (TKErrorDomainSymbolLoc)
  {
    id v1 = *TKErrorDomainSymbolLoc;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"typeof (((typeof (TKErrorDomain) (*)(void))0)()) getTKErrorDomain(void)"];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  29,  @"%s",  dlerror());

    __break(1u);
  }

uint64_t LocalAuthenticationLibraryCore()
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v0 = LocalAuthenticationLibraryCore_frameworkLibrary;
  uint64_t v6 = LocalAuthenticationLibraryCore_frameworkLibrary;
  if (!LocalAuthenticationLibraryCore_frameworkLibrary)
  {
    __int128 v7 = xmmword_189673510;
    __int128 v8 = *(_OWORD *)&off_189673520;
    uint64_t v1 = _sl_dlopen();
    unint64_t v4[3] = v1;
    LocalAuthenticationLibraryCore_frameworkLibrary = v1;
    uint64_t v0 = v1;
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1805E6168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *LocalAuthenticationLibrary()
{
  uint64_t v0 = LocalAuthenticationLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  [MEMORY[0x1896077D8] currentHandler];
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue();
  [NSString stringWithUTF8String:"void *LocalAuthenticationLibrary(void)"];
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend( v1,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  30,  @"%s",  0);

  __break(1u);
  free(v4);
  return v1;
}

id getLAContextClass()
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000LL;
  uint64_t v0 = (void *)getLAContextClass_softClass;
  uint64_t v7 = getLAContextClass_softClass;
  if (!getLAContextClass_softClass)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    void v3[2] = __getLAContextClass_block_invoke;
    v3[3] = &unk_1896734F0;
    void v3[4] = &v4;
    __getLAContextClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }

  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1805E62D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __getLAContextClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = objc_getClass("LAContext");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    getLAContextClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"Class getLAContextClass(void)_block_invoke"];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  31,  @"Unable to find class %s",  "LAContext");

    __break(1u);
  }

void *getLAErrorDomainSymbolLoc()
{
  uint64_t v3 = 0LL;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v0 = (void *)getLAErrorDomainSymbolLoc_ptr;
  uint64_t v6 = getLAErrorDomainSymbolLoc_ptr;
  if (!getLAErrorDomainSymbolLoc_ptr)
  {
    id v1 = LocalAuthenticationLibrary();
    uint64_t v0 = dlsym(v1, "LAErrorDomain");
    unint64_t v4[3] = (uint64_t)v0;
    getLAErrorDomainSymbolLoc_ptr = (uint64_t)v0;
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1805E6428( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void getLAErrorDomain()
{
  LAErrorDomainSymbolLoc = (id *)getLAErrorDomainSymbolLoc();
  if (LAErrorDomainSymbolLoc)
  {
    id v1 = *LAErrorDomainSymbolLoc;
  }

  else
  {
    [MEMORY[0x1896077D8] currentHandler];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"typeof (((typeof (LAErrorDomain) (*)(void))0)()) getLAErrorDomain(void)"];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v2,  "handleFailureInFunction:file:lineNumber:description:",  v3,  @"SecSoftLink.m",  32,  @"%s",  dlerror());

    __break(1u);
  }

CFStringRef SecPasswordCreateWithRandomDigits(int a1, const __CFDictionary **a2)
{
  int v8 = a1;
  int valuePtr = a1;
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberIntType, &v8);
  CFMutableDataRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMinLengthKey, v3);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMaxLengthKey, v4);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordAllowedCharactersKey, @"0123456789");
  uint64_t v6 = SecPasswordGenerate(3, a2, Mutable);
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v6;
}

CFStringRef SecPasswordGenerate(int a1, const __CFDictionary **a2, CFDictionaryRef theDict)
{
  CFTypeRef v168 = 0LL;
  v169 = 0LL;
  CFNumberRef v166 = 0LL;
  CFNumberRef number = 0LL;
  CFIndex range = 0LL;
  unint64_t v165 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v163 = 0xAAAAAAAAAAAAAAAALL;
  value[0] = 0LL;
  CFNumberRef v3 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (!theDict) {
    goto LABEL_121;
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
  {
    if (value[0])
    {
      CFTypeID v6 = CFGetTypeID(value[0]);
      if (v6 == CFStringGetTypeID() && CFStringCompare((CFStringRef)value[0], @"true", 0LL) == kCFCompareEqualTo)
      {
LABEL_111:
        if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, &v168)
          || !v168
          || (CFTypeID v48 = CFGetTypeID(v168), v48 != CFStringGetTypeID())
          || CFStringCompare((CFStringRef)v168, @"true", 0LL))
        {
          alloc = *v3;
          CFMutableDataRef Mutable = CFArrayCreateMutable(*v3, 0LL, MEMORY[0x189605228]);
          v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
          memset(v173, 0, 24);
          memset(v172, 0, sizeof(v172));
          v171[2] = 0LL;
          v171[3] = 0LL;
          uint64_t v50 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMinLengthKey);
          CFIndex v51 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMaxLengthKey);
          CFNumberGetValue(v50, kCFNumberSInt64Type, &v173[3]);
          uint64_t v52 = (uint64_t)v173[3];
          CFNumberGetValue(v51, kCFNumberSInt64Type, &v173[3]);
          CFIndex v53 = (CFIndex)v173[3];
          int v54 = a1;
          if (a1 != 3)
          {
            BOOL v68 = v173[3] != (void *)20;
            if (v52) {
              BOOL v69 = v173[3] == (void *)v52;
            }
            else {
              BOOL v69 = 0;
            }
            if (!v69) {
              BOOL v68 = 0;
            }
            uint64_t v70 = 20LL;
            if (v52 > 20) {
              uint64_t v70 = v52;
            }
            int v71 = v173[3] != 0LL && v68;
            BOOL v69 = v71 == 0;
            int v72 = v71 | (v52 > 20);
            if (v69) {
              CFIndex v53 = v70;
            }
            if (v72) {
              uint64_t v55 = @"false";
            }
            else {
              uint64_t v55 = @"true";
            }
            CFIndex v73 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordAllowedCharactersKey);
            CFIndex v74 = v73;
            if (v73) {
              CFRetain(v73);
            }
            unsigned int v75 = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordRequiredCharactersKey);
            if (v75)
            {
              uint64_t v76 = v75;
              for (CFIndex i = 0LL; i < CFArrayGetCount(v76); ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v76, i);
                if (ValueAtIndex)
                {
                  CFIndex v79 = ValueAtIndex;
                  v175.CFIndex length = CFStringGetLength(v74);
                  v175.location = 0LL;
                  if (CFStringFindCharacterFromSet(v74, (CFCharacterSetRef)v79, v175, 0LL, 0LL)) {
                    CFArrayAppendValue(Mutable, v79);
                  }
                }
              }

LABEL_121:
        CFIndex v56 = *v3;
        BOOL v57 = CFArrayCreateMutable(*v3, 0LL, MEMORY[0x189605228]);
        v173[2] = (void *)0xAAAAAAAAAAAAAAAALL;
        v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
        switch(a1)
        {
          case 1:
            value[0] = (void *)24;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 2:
            v173[3] = (void *)4;
            v173[2] = (void *)3;
            CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[2]);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            value[0] = (void *)12;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 3:
            value[0] = (void *)4;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[2] = (void *)1;
            v173[3] = (void *)4;
            CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[2]);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 4:
            v173[3] = (void *)4;
            v173[2] = (void *)7;
            value[0] = (void *)26;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            value[0] = (void *)2;
            CFNumberRef v84 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            CFDictionaryRef v83 = CFDictionaryCreateForCFTypes( v56,  v86,  v87,  v88,  v89,  v90,  v91,  v92,  (uint64_t)@"UseDefaultPasswordFormat",  (uint64_t)@"true");
            if (!v58) {
              goto LABEL_167;
            }
            goto LABEL_166;
          default:
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[3]);
            CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            value[0] = (void *)20;
            CFNumberRef v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
LABEL_165:
            CFDictionaryRef v83 = CFDictionaryCreateForCFTypes( v56,  v61,  v62,  v63,  v64,  v65,  v66,  v67,  (uint64_t)@"UseDefaultPasswordFormat",  (uint64_t)@"true");
            CFNumberRef v84 = 0LL;
            if (v58) {
LABEL_166:
            }
              CFRelease(v58);
LABEL_167:
            int v54 = a1;
            if (v57) {
              CFRelease(v57);
            }
            if (v59) {
              CFRelease(v59);
            }
            if (v60) {
              CFRelease(v60);
            }
            if (v84) {
              CFRelease(v84);
            }
            uint64_t v85 = v83;
            break;
        }

          uint64_t v5 = 0;
          goto LABEL_122;
        }

        if ((v45 & 0x10) == 0) {
          goto LABEL_121;
        }
        if (!a3) {
          goto LABEL_120;
        }
        std::string::__assign_external(&v83, (const std::string::value_type *)p_str);
        CFTypeID v46 = (os_log_s *)secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          CFNumberRef v60 = &v83;
          if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            CFNumberRef v60 = (std::string *)v83.__r_.__value_.__r.__words[0];
          }
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = (std::string::size_type)v60;
          _os_log_debug_impl( &dword_1804F4000,  v46,  OS_LOG_TYPE_DEBUG,  "entering excluded path: %s",  (uint8_t *)&v84,  0xCu);
        }

        uint64_t v5 = 1;
LABEL_122:
        fts_name = v7->fts_name;
        unint64_t v49 = strlen(fts_name);
        if (v49 >= 6 && !strcasecmp(&fts_name[v49 - 6], ".lproj"))
        {
          int v64 = 0;
          ++GKBIS_Num_localizations;
        }

        else
        {
          int v64 = 0;
        }

LABEL_239:
        if (!v85) {
          return 0LL;
        }
        theDicta = v85;
        __int128 v97 = (const __CFNumber *)CFDictionaryGetValue(v85, @"NumberOfRequiredRandomCharacters");
        if (v97 && (__int128 v98 = v97, v99 = CFGetTypeID(v97), v99 == CFNumberGetTypeID()))
        {
          if (CFNumberGetValue(v98, kCFNumberSInt64Type, &v165)) {
            uint64_t v100 = v165;
          }
          else {
            uint64_t v100 = 0LL;
          }
        }

        else
        {
          uint64_t v100 = 0LL;
        }

        __int128 v101 = (const __CFNumber *)CFDictionaryGetValue(v85, @"NumberOfChecksumCharacters");
        if (v101 && (__int128 v102 = v101, v103 = CFGetTypeID(v101), v103 == CFNumberGetTypeID()))
        {
          int v104 = CFNumberGetValue(v102, kCFNumberSInt64Type, &v165);
          unint64_t v105 = v165;
          if (!v104) {
            unint64_t v105 = 0LL;
          }
          uint64_t v158 = v105;
        }

        else
        {
          uint64_t v158 = 0LL;
        }

        CFDataRef v81 = v85;
        else {
          CFNumberRef number = 0LL;
        }
        if (CFDictionaryGetValueIfPresent(v85, (const void *)kSecPasswordNumberOfGroups, (const void **)&v166))
        {
          CFNumberGetValue(v166, kCFNumberSInt64Type, &v163);
          if (!v100) {
            goto LABEL_358;
          }
        }

        else
        {
          CFNumberRef v166 = 0LL;
          if (!v100) {
            goto LABEL_358;
          }
        }

        alloca = v56;
LABEL_260:
        __int128 v106 = (const __CFString *)CFDictionaryGetValue(v81, @"AllowedCharacters");
        int v107 = (unsigned __int8 *)malloc(v100);
        uint64_t v108 = malloc(v100);
        CFAbsoluteTime v109 = v108;
        if (!v107 || !v108)
        {
          free(v107);
          free(v109);
          CFDataRef v81 = theDicta;
          goto LABEL_358;
        }

        unsigned __int8 v110 = CFStringGetLength(v106);
        getUniformRandomNumbers((uint64_t)v107, v100, v110);
        value[0] = 0LL;
        if (!CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordDisallowedCharacters,  (const void **)value)) {
          value[0] = 0LL;
        }
        if (v100 < 1)
        {
LABEL_276:
          v117 = CFStringCreateWithBytes(alloca, (const UInt8 *)v109, v100, 0x8000100u, 0);
          free(v109);
          free(v107);
          if (!v166 || !number)
          {
            CFDictionaryRef Copy = CFStringCreateCopy(alloca, v117);
            goto LABEL_299;
          }

          CFMutableStringRef v118 = CFStringCreateMutable(alloca, 0LL);
          if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordSeparator, (const void **)&v169)
            || !v169)
          {
            v169 = @"-";
          }

          CFIndex v119 = 0LL;
          v120.CFIndex length = range;
          while (1)
          {
            if (v120.length + v119 >= v100)
            {
              if (v120.length + v119 != v100)
              {
                v178.CFIndex length = v100 - v119;
                v178.location = v119;
                v124 = CFStringCreateWithSubstring(alloca, v117, v178);
                CFStringAppend(v118, v124);
                if (v124) {
                  CFRelease(v124);
                }
LABEL_294:
                if (v158)
                {
                  Checksum = CreateChecksum(v54, v117, v158, v106);
                  CFStringAppend(v118, Checksum);
                  if (Checksum) {
                    CFRelease(Checksum);
                  }
                }

                CFDictionaryRef Copy = CFStringCreateCopy(alloca, v118);
                if (v118) {
                  CFRelease(v118);
                }
LABEL_299:
                if (v117) {
                  CFRelease(v117);
                }
                value[0] = 0LL;
                v172[3] = (void *)0xAAAAAAAAAAAAAAAALL;
                memset(v173, 0, sizeof(v173));
                v126 = (const __CFArray *)CFDictionaryGetValue(theDicta, @"RequiredCharacterSets");
                if (!CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordCantEndWithChars,  (const void **)&v173[3])) {
                  v173[3] = 0LL;
                }
                if (!CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordCantStartWithChars,  (const void **)&v173[2])) {
                  v173[2] = 0LL;
                }
                if (!CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordContainsAtLeastNSpecificCharacters,  (const void **)&v173[1])) {
                  v173[1] = 0LL;
                }
                if (!CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters,  (const void **)v173)) {
                  v173[0] = 0LL;
                }
                if (CFDictionaryGetValueIfPresent( theDicta,  (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters,  (const void **)value))
                {
                  CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt64Type, &v172[3]);
                  v127 = v172[3];
                }

                else
                {
                  v127 = 0LL;
                  value[0] = 0LL;
                }

                v128 = (const __CFString *)v173[3];
                if (v173[3])
                {
                  CFCharacterSetRef v129 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[3]);
                  CFIndex v130 = CFStringGetLength(Copy);
                  CFIndex v131 = v130 - CFStringGetLength(v128);
                  v179.CFIndex length = CFStringGetLength(v128);
                  v179.location = v131;
                  CFComparisonResult v132 = CFStringCompareWithOptions(Copy, v128, v179, 0LL);
                  if (v129) {
                    CFRelease(v129);
                  }
                  if (v132 == kCFCompareEqualTo) {
                    goto LABEL_351;
                  }
                }

                v133 = (const __CFString *)v173[2];
                if (v173[2])
                {
                  CFCharacterSetRef v134 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[2]);
                  v180.CFIndex length = CFStringGetLength(v133);
                  v180.location = 0LL;
                  CFComparisonResult v135 = CFStringCompareWithOptions(Copy, v133, v180, 0LL);
                  if (v134) {
                    CFRelease(v134);
                  }
                  if (v135 == kCFCompareEqualTo) {
                    goto LABEL_351;
                  }
                }

                if (v173[1])
                {
                  v136 = (const __CFNumber *)CFDictionaryGetValue( (CFDictionaryRef)v173[1],  (const void *)kSecPasswordCharacterCount);
                  v137 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)v173[1],  (const void *)kSecPasswordCharacters);
                  CFNumberGetValue(v136, kCFNumberSInt64Type, &v172[3]);
                  v138 = v172[3];
                  v139 = CFCharacterSetCreateWithCharactersInString(alloca, v137);
                  CFIndex v140 = 0LL;
                  uint64_t v141 = 0LL;
                  while (v140 < CFStringGetLength(Copy))
                  {
                    v181.location = v140;
                    v181.CFIndex length = 1LL;
                    if (CFStringFindCharacterFromSet(Copy, v139, v181, 0LL, 0LL)) {
                      ++v141;
                    }
                    ++v140;
                  }

                  if (v139) {
                    CFRelease(v139);
                  }
                }

                if (!v173[0]) {
                  goto LABEL_338;
                }
                v142 = (const __CFNumber *)CFDictionaryGetValue( (CFDictionaryRef)v173[0],  (const void *)kSecPasswordCharacterCount);
                v143 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)v173[0],  (const void *)kSecPasswordCharacters);
                CFNumberGetValue(v142, kCFNumberSInt64Type, &v172[3]);
                v144 = v172[3];
                v145 = CFCharacterSetCreateWithCharactersInString(alloca, v143);
                CFIndex v146 = 0LL;
                uint64_t v147 = 0LL;
                while (v146 < CFStringGetLength(Copy))
                {
                  v182.location = v146;
                  v182.CFIndex length = 1LL;
                  if (CFStringFindCharacterFromSet(Copy, v145, v182, 0LL, 0LL)) {
                    ++v147;
                  }
                  ++v146;
                }

                if (v145) {
                  CFRelease(v145);
                }
                if (v147 > (uint64_t)v144)
                {
LABEL_351:
                  int v54 = a1;
                }

                else
                {
LABEL_338:
                  if (value[0])
                  {
                    LODWORD(v14_Block_object_dispose(&a9, 8) = 0;
                    for (CFIndex j = 0LL; j < CFStringGetLength(Copy); ++j)
                    {
                      char CharacterAtIndex = CFStringGetCharacterAtIndex(Copy, j);
                      uint64_t v151 = 0LL;
                      uint64_t v152 = (int)v148;
                      while (1)
                      {
                        uint64_t v148 = v152 + v151;
                        if (j + v151 >= CFStringGetLength(Copy)) {
                          break;
                        }
                        char v153 = CFStringGetCharacterAtIndex(Copy, j + v151);
                        if (v153 != CharacterAtIndex)
                        {
                          LODWORD(v14_Block_object_dispose(&a9, 8) = 0;
                          break;
                        }

                        ++v151;
                      }
                    }
                  }

                  CFIndex v154 = 0LL;
                  while (v154 < CFArrayGetCount(v126))
                  {
                    v155 = (const __CFCharacterSet *)CFArrayGetValueAtIndex(v126, v154);
                    v183.CFIndex length = CFStringGetLength(Copy);
                    v183.location = 0LL;
                    ++v154;
                    if (!CFStringFindCharacterFromSet(Copy, v155, v183, 0LL, 0LL)) {
                      goto LABEL_351;
                    }
                  }

                  int v54 = a1;
                  if (!SecPasswordIsPasswordWeak2(a1 == 3, Copy))
                  {
                    CFRelease(theDicta);
                    return Copy;
                  }
                }

                CFDataRef v81 = theDicta;
                if (Copy) {
                  CFRelease(Copy);
                }
                goto LABEL_260;
              }

              v120.location = v119;
              v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              v123 = v118;
              v122 = v121;
            }

            else
            {
              v120.location = v119;
              v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              CFStringAppend(v118, v121);
              v122 = (const __CFString *)v169;
              v123 = v118;
            }

            CFStringAppend(v123, v122);
            if (v121) {
              CFRelease(v121);
            }
            v120.CFIndex length = range;
            v119 += range;
            if (v119 == v100) {
              goto LABEL_294;
            }
          }
        }

        uint64_t v111 = 0LL;
        while (1)
        {
          LOWORD(v173[3]) = -21846;
          UniChar v112 = CFStringGetCharacterAtIndex(v106, v107[v111]);
          LOWORD(v173[3]) = v112;
          if (!value[0]) {
            goto LABEL_274;
          }
          CFTypeRef v113 = CFStringCreateWithCharacters(alloca, (const UniChar *)&v173[3], 1LL);
          uint64_t v114 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)value[0]);
          v177.CFIndex length = CFStringGetLength(v113);
          v177.location = 0LL;
          int CharacterFromSet = CFStringFindCharacterFromSet(v113, v114, v177, 0LL, 0LL);
          if (v114) {
            CFRelease(v114);
          }
          if (v113) {
            CFRelease(v113);
          }
          if (!CharacterFromSet) {
            break;
          }
          unsigned __int8 v116 = CFStringGetLength(v106);
          getUniformRandomNumbers((uint64_t)v107, v100, v116);
          --v111;
LABEL_275:
          if (++v111 >= v100) {
            goto LABEL_276;
          }
        }

        LOBYTE(v112) = v173[3];
LABEL_274:
        *((_BYTE *)v109 + v111) = v112;
        goto LABEL_275;
      }
    }
  }

  if (a1 == 3)
  {
    v173[2] = 0LL;
    v173[3] = 0LL;
    v173[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
    {
      if (value[0])
      {
        CFTypeID v7 = CFGetTypeID(value[0]);
        if (v7 == CFStringGetTypeID()
          && CFStringCompare((CFStringRef)value[0], @"true", 0LL) == kCFCompareEqualTo)
        {
          goto LABEL_111;
        }
      }
    }

    if (!v173[2]) {
      goto LABEL_375;
    }
    CFTypeID v8 = CFGetTypeID(v173[2]);
    if (v8 == CFNullGetTypeID())
    {
      CFDataRef v80 = @"To generate a password, need a max length";
      goto LABEL_158;
    }

    if (v173[2] && (CFTypeID v9 = CFGetTypeID(v173[2]), v9 == CFNumberGetTypeID()))
    {
LABEL_388:
      if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[3]))
      {
        if (!v173[3]) {
          goto LABEL_385;
        }
        CFTypeID v10 = CFGetTypeID(v173[3]);
        if (v10 == CFNullGetTypeID())
        {
          CFDataRef v80 = @"To generate a password, need a min length";
          goto LABEL_158;
        }

        if (!v173[3] || (CFTypeID v11 = CFGetTypeID(v173[3]), v11 != CFNumberGetTypeID()))
        {
LABEL_385:
          CFDataRef v80 = @"The password's min length must be a CFNumberRef";
          goto LABEL_158;
        }
      }

      if (v173[2])
      {
        CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, &v173[1]);
        uint64_t v12 = (uint64_t)v173[1];
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      if (v173[3])
      {
        CFNumberGetValue((CFNumberRef)v173[3], kCFNumberSInt64Type, &v173[1]);
        CFDataRef v80 = @"The password's length parameters make no sense(is max < min ?)";
        if (v173[1])
        {
          if (v12)
          {
            if ((uint64_t)v173[1] <= v12)
            {
              CFDataRef v81 = 0LL;
              if ((uint64_t)v173[1] > 3 || v12 > 3)
              {
LABEL_159:
                if (v81) {
                  goto LABEL_160;
                }
                goto LABEL_111;
              }
            }
          }
        }
      }

      else
      {
        CFDataRef v80 = @"The password's length parameters make no sense(is max < min ?)";
      }
    }

    else
    {
LABEL_375:
      CFDataRef v80 = @"The password's max length must be a CFNumberRef";
    }

LABEL_361:
              v157 = @"The dictionary parameter 'Characters' is either null or not a string";
              goto LABEL_381;
            }

LABEL_363:
            v157 = @"The dictionary parameter 'At Least N Characters' is either null or not a string";
            goto LABEL_381;
          }
        }
      }
    }

LABEL_360:
    v157 = @"The dictionary parameter 'characters' is either null or not a number";
    goto LABEL_381;
  }

LABEL_106:
  if (!CFDictionaryGetValueIfPresent( theDict,  (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters,  (const void **)&v170[2])) {
    goto LABEL_111;
  }
  if (v170[2])
  {
    CFTypeID v46 = CFGetTypeID((CFTypeRef)v170[2]);
    if (v46 != CFNullGetTypeID())
    {
      if (v170[2])
      {
        CFTypeID v47 = CFGetTypeID((CFTypeRef)v170[2]);
        if (v47 == CFNumberGetTypeID()) {
          goto LABEL_111;
        }
      }
    }
  }

  v157 = @"The dictionary parameter 'Identical Consecutive Characters' is either null or not a number";
LABEL_381:
  CFDataRef v81 = CFErrorCreate(*v3, v157, -909LL, 0LL);
  if (!v81) {
    goto LABEL_111;
  }
LABEL_160:
  CFRetain(v81);
  CFRelease(v81);
  if (!a2)
  {
LABEL_358:
    CFRelease(v81);
    return 0LL;
  }

  CFDictionaryRef Copy = 0LL;
  *a2 = v81;
  return Copy;
}

uint64_t getUniformRandomNumbers(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v6 = 0LL;
  unsigned int v7 = (0xFF % a3) ^ 0xFF;
  do
  {
    do
      uint64_t result = CCRandomCopyBytes();
    while ((_DWORD)result == -1);
    unint64_t v9 = a2 - v6;
    if (a2 > v6)
    {
      CFTypeID v10 = (unsigned __int8 *)(a1 + v6);
      do
      {
        unsigned int v12 = *v10++;
        unsigned int v11 = v12;
        if (v12 < v7) {
          *(_BYTE *)(a1 + v6++) = v11 % a3;
        }
        --v9;
      }

      while (v9);
    }
  }

  while (a2 > v6);
  return result;
}

__CFString *CreateChecksum(int a1, CFStringRef theString, uint64_t a3, const __CFString *a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1 != 4) {
    return 0LL;
  }
  uint64_t v4 = a3;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v5;
  v16[1] = v5;
  if (a3 > 32) {
    return 0LL;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)SecCFAllocatorZeroize_sAllocator,  theString,  0x8000100u,  0);
  if (!ExternalRepresentation) {
    return 0LL;
  }
  unint64_t v9 = ExternalRepresentation;
  ccsha256_di();
  CFDataGetLength(v9);
  CFDataGetBytePtr(v9);
  ccdigest();
  CFRelease(v9);
  CFIndex Length = CFStringGetLength(a4);
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableDataRef Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  if (v4 >= 1)
  {
    unsigned int v12 = (unsigned __int8 *)v16;
    do
    {
      unsigned int v13 = *v12++;
      UniChar chars = -21846;
      UniChar chars = CFStringGetCharacterAtIndex(a4, v13 % Length);
      CFStringAppendCharacters(Mutable, &chars, 1LL);
      --v4;
    }

    while (v4);
  }

  return Mutable;
}

BOOL SecPasswordIsPasswordWeak2(int a1, const __CFString *a2)
{
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a2) < 4) {
    return 1LL;
  }
  CFIndex v4 = 0LL;
  do
  {
    if (v4 >= CFStringGetLength(a2))
    {
      if (a1)
      {
        if (CFStringGetLength(a2) == 4)
        {
          if (a2)
          {
            CFRetain(a2);
            CFIndex Length = CFStringGetLength(a2);
            CFIndex v11 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            unsigned int v12 = (char *)malloc(v11);
            if (!CFStringGetCString(a2, v12, v11, 0x8000100u)) {
              *unsigned int v12 = 0;
            }
            CFRelease(a2);
          }

          else
          {
            unsigned int v12 = strdup((const char *)&unk_18065A197);
          }

          if (!in_word_set((unsigned __int8 *)v12))
          {
            int v43 = *v12;
            int v44 = v12[1];
            if (((v43 == v44) == v12[2]) != v12[3])
            {
              int v45 = v12[2];
              int v46 = v12[3];
              if ((v43 != v44 || v45 != v46) && (v43 != v45 || v44 != v46))
              {
                uint64_t v47 = 0LL;
                while (strcmp(blacklist[v47], v12))
                {
                  if (++v47 == 7) {
                    goto LABEL_100;
                  }
                }
              }
            }
          }

          goto LABEL_98;
        }

        if (CFStringGetLength(a2) != 6) {
          return 0LL;
        }
        if (a2)
        {
          CFRetain(a2);
          CFIndex v19 = CFStringGetLength(a2);
          CFIndex v20 = CFStringGetMaximumSizeForEncoding(v19, 0x8000100u) + 1;
          unsigned int v12 = (char *)malloc(v20);
          if (!CFStringGetCString(a2, v12, v20, 0x8000100u)) {
            *unsigned int v12 = 0;
          }
          CFRelease(a2);
        }

        else
        {
          unsigned int v12 = strdup((const char *)&unk_18065A197);
        }

        CFIndex v48 = 0LL;
        do
        {
          if (CFStringGetLength(a2) <= v48) {
            break;
          }
          if (v48 == CFStringGetLength(a2) - 1) {
            goto LABEL_98;
          }
          CFIndex v56 = (unsigned __int8 *)&v12[v48];
          int v57 = v12[v48++];
        }

        while (v57 == v56[1]);
        if (isTopTenSixDigitPasscode(a2, v49, v50, v51, v52, v53, v54, v55)
          || SecPasswordIsPalindrome(a2)
          || SecPasswordHasRepeatingGroups(a2))
        {
LABEL_98:
          free(v12);
          return 1LL;
        }
      }

      else
      {
        if (a2)
        {
          CFRetain(a2);
          CFIndex v13 = CFStringGetLength(a2);
          CFIndex v14 = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u) + 1;
          unsigned int v12 = (char *)malloc(v14);
          if (!CFStringGetCString(a2, v12, v14, 0x8000100u)) {
            *unsigned int v12 = 0;
          }
          CFRelease(a2);
        }

        else
        {
          unsigned int v12 = strdup((const char *)&unk_18065A197);
        }

        int valuePtr = 1;
        CFIndex v21 = CFStringGetLength(a2);
        CFTypeID v22 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFMutableDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
        if (v21 > 0)
        {
          if (v21 != 1)
          {
            for (CFIndex i = 1LL; i != v21; ++i)
            {
              int CharacterAtIndex = CFStringGetCharacterAtIndex(a2, i - 1);
              int v26 = CFStringGetCharacterAtIndex(a2, i);
              int v27 = valuePtr;
              if (CharacterAtIndex == v26)
              {
                int v27 = valuePtr + 1;
              }

              else if (valuePtr != 1)
              {
                CFNumberRef v28 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
                CFArrayAppendValue(Mutable, v28);
                if (v28) {
                  CFRelease(v28);
                }
                int v27 = 1;
              }

              int valuePtr = v27;
            }
          }

          CFNumberRef v29 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
          CFArrayAppendValue(Mutable, v29);
          if (v29) {
            CFRelease(v29);
          }
        }

        CFIndex v30 = 0LL;
        CFTypeID v31 = 0LL;
        while (CFArrayGetCount(Mutable) > v30)
        {
          if (v30)
          {
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, v30);
            if (CFNumberCompare(ValueAtIndex, v31, 0LL) == kCFCompareGreaterThan) {
              CFTypeID v31 = ValueAtIndex;
            }
          }

          else
          {
            CFTypeID v31 = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, 0LL);
          }

          ++v30;
        }

        int v58 = 0;
        if (v31) {
          CFNumberGetValue(v31, kCFNumberIntType, &v58);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        uint64_t v33 = v58;
        CFIndex v34 = CFStringGetLength(a2);
        if (v34 >= 0) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = v34 + 1;
        }
        if (v33 >= v35 >> 1
          || SecPasswordIsPalindrome(a2)
          || isTopTenSixDigitPasscode(a2, v36, v37, v38, v39, v40, v41, v42)
          || SecPasswordHasRepeatingGroups(a2) && CFStringGetLength(a2) >= 6)
        {
          goto LABEL_98;
        }
      }

      if (!SecPasswordIsPasscodeIncrementingOrDecrementingDigits(a2)
        && !SecPasswordIsPasswordRepeatingTwoNumbers(a2))
      {
LABEL_100:
        if (v12) {
          free(v12);
        }
        return 0LL;
      }

      goto LABEL_98;
    }

    v60.location = v4;
    v60.CFIndex length = 1LL;
    ++v4;
  }

  while (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v60, 0LL, 0LL));
  if ((a1 & 1) != 0) {
    return 0LL;
  }
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  CFIndex v8 = 0LL;
  int v9 = 0;
  while (v8 < CFStringGetLength(a2))
  {
    v61.location = v8;
    v61.CFIndex length = 1LL;
    if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)uppercaseLetterCharacterSet, v61, 4uLL, 0LL))
    {
      ++v9;
    }

    else
    {
      v62.location = v8;
      v62.CFIndex length = 1LL;
      if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)lowercaseLetterCharacterSet, v62, 4uLL, 0LL))
      {
        ++v5;
      }

      else
      {
        v63.location = v8;
        v63.CFIndex length = 1LL;
        if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v63, 4uLL, 0LL))
        {
          ++v6;
        }

        else
        {
          v64.location = v8;
          v64.CFIndex length = 1LL;
          if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)punctuationCharacterSet, v64, 4uLL, 0LL)) {
            ++v7;
          }
        }
      }
    }

    ++v8;
  }

  if (v9 <= 0) {
    int v15 = 0;
  }
  else {
    int v15 = 26;
  }
  if (v5 > 0) {
    v15 += 26;
  }
  if (v6 > 0) {
    v15 += 10;
  }
  if (v7 <= 0) {
    int v16 = v15;
  }
  else {
    int v16 = v15 + 33;
  }
  double v17 = (double)CFStringGetLength(a2);
  return log2((double)v16) * v17 < 35.0;
}

const char *in_word_set(unsigned __int8 *a1)
{
  int v1 = pinhash_asso_values[a1[3] + 9];
  int v2 = pinhash_asso_values[a1[2]];
  uint64_t v3 = *a1;
  unsigned int v5 = a1[1];
  CFIndex v4 = (const char *)(a1 + 1);
  unsigned int v6 = v1 + v2 + pinhash_asso_values[v5] + pinhash_asso_values[v3 + 3] + 4;
  if (v6 > 0x113) {
    return 0LL;
  }
  int v7 = (const char *)*(&in_word_set_wordlist + v6);
  return v7;
}

BOOL isTopTenSixDigitPasscode( const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  MutableForCFTypesWith = CFArrayCreateMutableForCFTypesWith( (const __CFAllocator *)*MEMORY[0x189604DB0],  a2,  a3,  a4,  a5,  a6,  a7,  a8,  @"030379",  (uint64_t)@"101471");
  for (CFIndex i = 0LL; ; ++i)
  {
    CFIndex Count = CFArrayGetCount(MutableForCFTypesWith);
    if (i >= Count) {
      break;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(MutableForCFTypesWith, i);
    if (a1 && ValueAtIndex)
    {
      if (CFEqual(a1, ValueAtIndex)) {
        break;
      }
    }

    else if (ValueAtIndex == a1)
    {
      break;
    }
  }

  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return i < Count;
}

uint64_t SecPasswordIsPalindrome(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc(v3);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }

  else
  {
    CFIndex v4 = strdup((const char *)&unk_18065A197);
  }

  CFIndex v5 = CFStringGetLength(cf);
  CFIndex v6 = 0LL;
  if (v5 >= 0) {
    CFIndex v7 = v5 & 1;
  }
  else {
    CFIndex v7 = -(v5 & 1);
  }
  CFIndex v8 = v5 - 1;
  while (CFStringGetLength(cf) > v6)
  {
    if (v7 == 1 && v8 == v6) {
      goto LABEL_18;
    }
    int v9 = v4[v6];
    int v10 = v4[v8];
    if (!v7 && v8 - 1 == v6)
    {
      if (v9 == v10)
      {
LABEL_18:
        free(v4);
        return 1LL;
      }

      break;
    }

    ++v6;
    --v8;
    if (v9 != v10) {
      break;
    }
  }

  free(v4);
  return 0LL;
}

uint64_t SecPasswordHasRepeatingGroups(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc(v3);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }

  else
  {
    CFIndex v4 = strdup((const char *)&unk_18065A197);
  }

  for (CFIndex i = 0LL; CFStringGetLength(cf) > i; ++i)
  {
    CFIndex v6 = CFStringGetLength(cf);
    int v7 = v4[i];
    if (v6 == i + 4)
    {
      if (v7 == v4[(i + 3)])
      {
        free(v4);
        return 1LL;
      }

      break;
    }
  }

  free(v4);
  return 0LL;
}

uint64_t SecPasswordIsPasscodeIncrementingOrDecrementingDigits(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc(v3);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }

  else
  {
    CFIndex v4 = strdup((const char *)&unk_18065A197);
  }

  CFIndex v5 = 0LL;
  do
  {
    if (CFStringGetLength(cf) <= v5) {
      break;
    }
    if (v5 == CFStringGetLength(cf) - 1)
    {
LABEL_18:
      uint64_t v9 = 1LL;
      goto LABEL_20;
    }

    CFIndex v6 = &v4[v5];
    int v7 = v4[v5++] + 1;
  }

  while (v7 == v6[1]);
  for (CFIndex i = 0LL; CFStringGetLength(cf) > i; ++i)
  {
    if (i == CFStringGetLength(cf) - 1) {
      goto LABEL_18;
    }
    if (v4[i + 1] + 1 != v4[i])
    {
      uint64_t v9 = 0LL;
      if (i || *v4 != 48 || v4[i + 1] != 57) {
        goto LABEL_20;
      }
    }
  }

  uint64_t v9 = 0LL;
LABEL_20:
  free(v4);
  return v9;
}

uint64_t SecPasswordIsPasswordRepeatingTwoNumbers(const __CFString *cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFIndex Length = CFStringGetLength(cf);
    CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    CFIndex v4 = (char *)malloc(v3);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u)) {
      *CFIndex v4 = 0;
    }
    CFRelease(cf);
  }

  else
  {
    CFIndex v4 = strdup((const char *)&unk_18065A197);
  }

  CFIndex v5 = 0LL;
  while (1)
  {
    if (CFStringGetLength(cf) <= v5)
    {
LABEL_10:
      uint64_t v8 = 0LL;
      goto LABEL_12;
    }

    if (CFStringGetLength(cf) == v5 + 3) {
      break;
    }
    int v6 = v4[v5];
    int v7 = v4[v5++ + 2];
    if (v6 != v7) {
      goto LABEL_10;
    }
  }

  uint64_t v8 = 1LL;
LABEL_12:
  free(v4);
  return v8;
}

__CFArray *CFArrayCreateMutableForCFTypesWith( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10)
{
  int v16 = &a10;
  CFIndex v10 = 0LL;
  CFIndex v11 = a9;
  if (a9)
  {
    do
    {
      unsigned int v12 = v16++;
      ++v10;
    }

    while (*v12);
  }

  CFMutableDataRef Mutable = CFArrayCreateMutable(a1, v10, MEMORY[0x189605228]);
  double v17 = (const void **)&a10;
  if (a9)
  {
    do
    {
      CFArrayAppendValue(Mutable, v11);
      CFIndex v14 = v17++;
      CFIndex v11 = *v14;
    }

    while (*v14);
  }

  return Mutable;
}

BOOL SecPasswordIsPasswordWeak(const __CFString *a1)
{
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a1) < 4) {
    return 1LL;
  }
  for (CFIndex i = 0LL; i < CFStringGetLength(a1); ++i)
  {
    v33.location = i;
    v33.CFIndex length = 1LL;
    if (!CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v33, 0LL, 0LL))
    {
      int v3 = 0;
      int v4 = 0;
      int v5 = 0;
      int v6 = 0;
      for (CFIndex j = 0LL; j < CFStringGetLength(a1); ++j)
      {
        v34.location = j;
        v34.CFIndex length = 1LL;
        if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)uppercaseLetterCharacterSet, v34, 4uLL, 0LL))
        {
          ++v3;
        }

        else
        {
          v35.location = j;
          v35.CFIndex length = 1LL;
          if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)lowercaseLetterCharacterSet, v35, 4uLL, 0LL))
          {
            ++v4;
          }

          else
          {
            v36.location = j;
            v36.CFIndex length = 1LL;
            if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v36, 4uLL, 0LL))
            {
              ++v5;
            }

            else
            {
              v37.location = j;
              v37.CFIndex length = 1LL;
              if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)punctuationCharacterSet, v37, 4uLL, 0LL)) {
                ++v6;
              }
            }
          }
        }
      }

      if (v3 <= 0) {
        int v11 = 0;
      }
      else {
        int v11 = 26;
      }
      if (v4 > 0) {
        v11 += 26;
      }
      if (v5 > 0) {
        v11 += 10;
      }
      if (v6 <= 0) {
        int v12 = v11;
      }
      else {
        int v12 = v11 + 33;
      }
      double Length = (double)CFStringGetLength(a1);
      return log2((double)v12) * Length < 35.0;
    }
  }

  if (CFStringGetLength(a1) == 4)
  {
    if (a1)
    {
      CFRetain(a1);
      CFIndex v8 = CFStringGetLength(a1);
      CFIndex v9 = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u) + 1;
      CFIndex v10 = (char *)malloc(v9);
      if (!CFStringGetCString(a1, v10, v9, 0x8000100u)) {
        *CFIndex v10 = 0;
      }
      CFRelease(a1);
    }

    else
    {
      CFIndex v10 = strdup((const char *)&unk_18065A197);
    }

    if (!in_word_set((unsigned __int8 *)v10))
    {
      int v17 = *v10;
      int v18 = v10[1];
      if (((v17 == v18) == v10[2]) != v10[3])
      {
        int v19 = v10[2];
        int v20 = v10[3];
        if ((v17 != v18 || v19 != v20) && (v17 != v19 || v18 != v20))
        {
          CFIndex v28 = 0LL;
          do
          {
            if (CFStringGetLength(a1) <= v28) {
              break;
            }
            if (v28 == CFStringGetLength(a1) - 1) {
              goto LABEL_43;
            }
            CFNumberRef v29 = (unsigned __int8 *)&v10[v28];
            int v30 = v10[v28++] + 1;
          }

          while (v30 == (char)v29[1]);
          for (CFIndex k = 0LL; CFStringGetLength(a1) > k; ++k)
          {
            if (k == CFStringGetLength(a1) - 1) {
              goto LABEL_43;
            }
            if (v10[k + 1] + 1 != v10[k] && (k || v10[k] != 48 || v10[k + 1] != 57)) {
              break;
            }
          }

          uint64_t v32 = 0LL;
          while (strcmp(blacklist[v32], v10))
          {
            if (++v32 == 7) {
              goto LABEL_77;
            }
          }
        }
      }
    }

LABEL_77:
  if (!v10) {
    return 0LL;
  }
LABEL_78:
  free(v10);
  return 0LL;
}

CFDictionaryRef SecPasswordCopyDefaultPasswordLength(int a1, __CFString **a2)
{
  switch(a1)
  {
    case 0:
      uint64_t valuePtr = 4LL;
      uint64_t v2 = 5LL;
      goto LABEL_8;
    case 1:
      uint64_t valuePtr = 4LL;
      uint64_t v2 = 6LL;
      goto LABEL_8;
    case 2:
      uint64_t valuePtr = 4LL;
      uint64_t v2 = 3LL;
      goto LABEL_8;
    case 3:
      uint64_t valuePtr = 4LL;
      uint64_t v2 = 1LL;
      goto LABEL_8;
    case 4:
      uint64_t valuePtr = 4LL;
      uint64_t v2 = 7LL;
LABEL_8:
      uint64_t v9 = v2;
      int v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
      CFNumberRef v6 = CFNumberCreate(v4, kCFNumberCFIndexType, &v9);
      CFMutableDataRef Mutable = CFDictionaryCreateMutable(v4, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordGroupSize, v5);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordNumberOfGroups, v6);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v4, Mutable);
      if (v5) {
        CFRelease(v5);
      }
      if (v6) {
        CFRelease(v6);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      break;
    default:
      SecError(-909, a2, @"Password type does not exist.");
      CFDictionaryRef Copy = 0LL;
      break;
  }

  return Copy;
}

BOOL SecPasswordValidatePasswordFormat(int a1, CFStringRef theString, __CFString **a3)
{
  switch(a1)
  {
    case 4:
      int v6 = 0;
      uint64_t v7 = 7LL;
      CFIndex range = 2LL;
      CFNumberRef v5 = @"ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      break;
    case 3:
      CFNumberRef v5 = 0LL;
      CFIndex range = 0LL;
      int v6 = 1;
      uint64_t v7 = 1LL;
      break;
    case 1:
      CFNumberRef v5 = 0LL;
      CFIndex range = 0LL;
      int v6 = 1;
      uint64_t v7 = 6LL;
      break;
    default:
      SecError(-909, a3, @"Password type does not exist.");
      return 0LL;
  }

  if (CFStringGetLength(theString) != 5 * v7 - 1) {
    return 0LL;
  }
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0LL);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v9 = Mutable;
  CFTypeID v25 = v5;
  CFIndex v10 = 0LL;
  uint64_t v11 = 4 * v7;
  uint64_t v12 = 5 * v7;
  do
  {
    if (v10)
    {
      CFIndex v13 = v10;
      if (CFStringGetCharacterAtIndex(theString, v10 - 1) != 45) {
        goto LABEL_33;
      }
    }

    else
    {
      CFIndex v13 = 0LL;
    }

    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    v27.location = v13;
    v27.CFIndex length = 4LL;
    CFIndex v14 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, theString, v27);
    CFStringAppend(v9, v14);
    if (v14) {
      CFRelease(v14);
    }
    v10 += 5LL;
  }

  while (v12 != v10);
  if (v6)
  {
    CFRelease(v9);
    return 1LL;
  }

  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  v28.CFIndex length = range;
  CFIndex v16 = v11 - range;
  v28.location = v16;
  CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v28);
  if (!v17)
  {
LABEL_33:
    int v23 = v9;
LABEL_34:
    CFRelease(v23);
    return 0LL;
  }

  CFStringRef v18 = v17;
  if (SecCFAllocatorZeroize_sOnce != -1) {
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
  }
  v29.location = 0LL;
  v29.CFIndex length = v16;
  int v19 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v29);
  if (!v19)
  {
    CFRelease(v9);
    int v23 = (__CFString *)v18;
    goto LABEL_34;
  }

  int v20 = v19;
  ChecksuCFIndex m = CreateChecksum(a1, v19, range, v25);
  if (Checksum)
  {
    int v22 = Checksum;
    BOOL v15 = CFEqual(Checksum, v18) != 0;
    CFRelease(v9);
    uint64_t v9 = v22;
  }

  else
  {
    BOOL v15 = 0LL;
  }

  CFRelease(v9);
  CFRelease(v18);
  CFRelease(v20);
  return v15;
}

uint64_t __SecPolicyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t SecPolicyCompare(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24) && *(void *)(a2 + 24))
  {
    uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
    if (!(_DWORD)result) {
      return result;
    }
    CFNumberRef v5 = *(const void **)(a1 + 24);
    int v6 = *(const void **)(a2 + 24);
  }

  else
  {
    CFNumberRef v5 = *(const void **)(a1 + 16);
    int v6 = *(const void **)(a2 + 16);
  }

  uint64_t result = CFEqual(v5, v6);
  if ((_DWORD)result) {
    return CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a2 + 32)) != 0;
  }
  return result;
}

CFHashCode SecPolicyHash(CFTypeRef *a1)
{
  CFTypeRef v2 = a1[3];
  CFHashCode v3 = CFHash(a1[2]);
  if (v2)
  {
    CFHashCode v4 = CFHash(a1[3]) + v3;
    CFHashCode v3 = CFHash(a1[4]);
  }

  else
  {
    CFHashCode v4 = CFHash(a1[4]);
  }

  return v4 + v3;
}

__CFString *SecPolicyCopyFormatDescription(void *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFTypeID v3 = CFGetTypeID(a1);
  CFStringRef v4 = CFCopyTypeIDDescription(v3);
  CFStringRef v5 = v4;
  int v6 = (const __CFString *)a1[3];
  if (!v6) {
    int v6 = &stru_1896794C8;
  }
  CFStringAppendFormat(Mutable, 0LL, @"<%@: oid: %@ name: %@ options %@", v4, a1[2], v6, a1[4]);
  CFRelease(v5);
  CFStringAppend(Mutable, @" >");
  return Mutable;
}

__CFString *SecPolicyCopyDescription(void *a1)
{
  return SecPolicyCopyFormatDescription(a1);
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  EAP = (__SecPolicy *)policyIdentifier;
  uint64_t v46 = *MEMORY[0x1895F89C0];
  values = 0LL;
  if (!policyIdentifier) {
    return EAP;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(EAP)) {
    return 0LL;
  }
  if (!properties)
  {
    CFIndex v10 = 0LL;
    uint64_t v9 = 0LL;
    CFTypeRef cf = 0LL;
    CFIndex v8 = 0LL;
    BOOL v7 = 0;
    int v6 = 0LL;
    CFStringRef v5 = 0LL;
LABEL_12:
    char v12 = 1;
    goto LABEL_13;
  }

  CFStringRef v5 = (__CFString *)CFDictionaryGetValue(properties, @"SecPolicyName");
  values = v5;
  int v6 = CFDictionaryGetValue(properties, @"SecPolicyTeamIdentifier");
  *(void *)value = 0xAAAAAAAAAAAAAAAALL;
  BOOL v7 = 0;
  CFIndex v8 = CFDictionaryGetValue(properties, @"SecPolicyContext");
  CFTypeRef cf = (const __CFString *)CFDictionaryGetValue(properties, @"SecPolicyPolicyName");
  uint64_t v9 = (const __CFString *)CFDictionaryGetValue(properties, @"SecPolicyIntermediateMarkerOid");
  CFIndex v10 = (__CFString *)CFDictionaryGetValue(properties, @"SecPolicyLeafMarkerOid");
  properties = (CFDictionaryRef)CFDictionaryGetValue(properties, @"SecPolicyRootDigest");
  if (!v5) {
    goto LABEL_12;
  }
  CFTypeID v11 = CFGetTypeID(v5);
  if (v11 != CFStringGetTypeID() && !CFEqual(EAP, @"1.2.840.113635.100.1.9"))
  {
    BOOL v15 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)value = 138412546;
      *(void *)&value[4] = EAP;
      __int16 v44 = 2112;
      int v45 = @"SecPolicyName";
      CFIndex v16 = "policy %@ requires a string value for the %@ key";
      CFStringRef v17 = v15;
      uint32_t v18 = 22;
LABEL_27:
      _os_log_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEFAULT, v16, value, v18);
      return 0LL;
    }

    return 0LL;
  }

  char v12 = 0;
LABEL_13:
  if (!CFEqual(EAP, @"1.2.840.113635.100.1.3"))
  {
    if (CFEqual(EAP, @"1.2.840.113635.100.1.8"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateSMIME(31, v5);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.9"))
    {
      if ((v12 & 1) != 0)
      {
LABEL_24:
        SMIME = SecPolicyCreateEAP(!v7, 0LL);
        goto LABEL_17;
      }

      CFTypeID v19 = CFGetTypeID(v5);
      if (v19 == CFStringGetTypeID())
      {
        CFArrayRef Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605228]);
      }

      else
      {
        CFTypeID v21 = CFGetTypeID(v5);
        if (v21 != CFArrayGetTypeID()) {
          goto LABEL_24;
        }
        CFArrayRef Copy = CFArrayCreateCopy(0LL, (CFArrayRef)v5);
      }

      CFArrayRef v22 = Copy;
      EAP = SecPolicyCreateEAP(!v7, Copy);
      if (v22) {
        CFRelease(v22);
      }
      goto LABEL_18;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.11"))
    {
      SMIME = SecPolicyCreateIPSec(!v7, v5);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.19"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreReceipt();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.21"))
    {
      SMIME = SecPolicyCreateRevocation(3uLL);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.22"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePassbookCardSigner(v5, v6);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.42"))
    {
      if ((v12 & 1) != 0)
      {
        int v23 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0LL;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy %@ requires kSecPolicyName input";
        goto LABEL_90;
      }

      CFIndex v24 = @"1.2.840.113635.100.1.42";
      CFTypeID v25 = @"AST2";
      int v26 = &oidAppleCertExtAST2DiagnosticsServerAuthProd;
      CFRange v27 = &oidAppleCertExtAST2DiagnosticsServerAuthProdQA;
      goto LABEL_67;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.43"))
    {
      if ((v12 & 1) != 0)
      {
        int v23 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0LL;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy %@ requires kSecPolicyName input";
        goto LABEL_90;
      }

      CFIndex v24 = @"1.2.840.113635.100.1.43";
      CFTypeID v25 = @"Escrow";
      int v26 = &oidAppleCertExtEscrowProxyServerAuthProd;
      CFRange v27 = &oidAppleCertExtEscrowProxyServerAuthProdQA;
LABEL_67:
      CFRange v28 = v5;
LABEL_68:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleServerAuthCommon(v28, v24, v25, (uint64_t)v26, (uint64_t)v27);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.44"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.44";
        CFTypeID v25 = @"FMiP";
        int v26 = &oidAppleCertExtFMiPServerAuthProd;
        CFRange v27 = &oidAppleCertExtFMiPServerAuthProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
LABEL_90:
      CFStringRef v17 = v23;
      uint32_t v18 = 12;
      goto LABEL_27;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.45"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.45";
        CFTypeID v25 = @"MMCS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationMMCSProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationMMCSProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.46"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.46";
        CFTypeID v25 = @"GS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationGS;
        CFRange v28 = v5;
        CFRange v27 = 0LL;
        goto LABEL_68;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.47"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.47";
        CFTypeID v25 = @"PPQ";
        int v26 = &oidAppleCertExtAppleServerAuthenticationPPQProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationPPQProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.62"))
    {
      if (!cf)
      {
        int v23 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0LL;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy %@ requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }

      CFRange v29 = cf;
      int v30 = v9;
      CFTypeID v31 = v10;
LABEL_77:
      SMIME = (__SecPolicy *)SecPolicyCreateApplePinned(v29, v30, v31);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.63"))
    {
      if (cf)
      {
        SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLPinned(cf, v5, v9, v10);
        goto LABEL_17;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy %@ requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }

      return 0LL;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.68"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.68";
        CFTypeID v25 = @"IDS";
        int v26 = &oidAppleCertExtAppleServerAuthenticationIDSProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationIDSProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.69"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.69";
        CFTypeID v25 = @"APN";
        int v26 = &oidAppleCertExtAppleServerAuthenticationAPNProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationAPNProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.72"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleUniqueDeviceCertificate(properties);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.77"))
    {
      if ((v12 & 1) == 0)
      {
        CFIndex v24 = @"1.2.840.113635.100.1.77";
        CFTypeID v25 = @"iCloudSetup";
        int v26 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProd;
        CFRange v27 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA;
        goto LABEL_67;
      }

      int v23 = (os_log_s *)secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        return 0LL;
      }
      *(_DWORD *)value = 138412290;
      *(void *)&value[4] = EAP;
      CFIndex v16 = "policy %@ requires kSecPolicyName input";
      goto LABEL_90;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.84"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationSystem(properties);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.85"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationUser(properties);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.92"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleComponentCertificate(properties);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.102"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricTransparency(!v7);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.106"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricEncryption(!v7);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.107"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePayModelSigning(1);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.108"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMDLTerminalAuth(1, 1);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.112"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePPMAggregatorConfigSigning(!v7);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.117"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateiAPAuthV4(1);
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.118"))
    {
      if ((v12 & 1) != 0)
      {
        int v23 = (os_log_s *)secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          return 0LL;
        }
        *(_DWORD *)value = 138412290;
        *(void *)&value[4] = EAP;
        CFIndex v16 = "policy %@ requires kSecPolicyName input";
        goto LABEL_90;
      }

      uint64_t v32 = @"1.2.840.113635.100.1.118";
      CFRange v33 = @"ParakeetService";
      CFRange v34 = v5;
      CFRange v35 = v8;
      goto LABEL_129;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.2"))
    {
      SMIME = SecPolicyCreateBasicX509();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.10"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleSWUpdateSigning();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.16"))
    {
      SMIME = SecPolicyCreateCodeSigning();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.17"))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePackageSigning();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.18"))
    {
LABEL_137:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleIDAuthorityPolicy();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.20"))
    {
      SMIME = SecPolicyCreateAppleTimeStamping();
      goto LABEL_17;
    }

    if (CFEqual(EAP, @"1.2.840.113635.100.1.23"))
    {
      int v36 = 0;
    }

    else
    {
      if (CFEqual(EAP, @"1.2.840.113635.100.1.24"))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceSigner();
        goto LABEL_17;
      }

      if (CFEqual(EAP, @"1.2.840.113635.100.1.25") || CFEqual(EAP, @"1.2.840.113635.100.1.26"))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateConfigurationProfileSigner();
        goto LABEL_17;
      }

      if (!CFEqual(EAP, @"1.2.840.113635.100.1.27"))
      {
        if (CFEqual(EAP, @"1.2.840.113635.100.1.30"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationRecordSigningPolicy();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.30"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationShortcutSigningPolicy();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.31"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSMPEncryption();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.32"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestAppleSMPEncryption();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.33"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLService(v5);
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.34"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceSigner();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.35"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePPQSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.36"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestApplePPQSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.39"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePayIssuerEncryption();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.40"))
        {
          SMIME = SecPolicyCreateOSXProvisioningProfileSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.41"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleATVVPNProfileSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.48"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleHomeKitServerAuth(v5);
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.49"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneActivation();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.50"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneDeviceCertificate();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.51"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateFactoryDeviceCertificate();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.52"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiAP();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.53"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiTunesStoreURLBag();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.54"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneApplicationSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.55"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProfileApplicationSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.56"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProvisioningProfileSigning();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.57"))
        {
          SMIME = SecPolicyCreateLockdownPairing();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.58"))
        {
          SMIME = SecPolicyCreateURLBag();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.59"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateOTATasking();
          goto LABEL_17;
        }

        if (CFEqual(EAP, @"1.2.840.113635.100.1.60"))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateMobileAsset();
          goto LABEL_17;
        }

        if (!CFEqual(EAP, @"1.2.840.113635.100.1.61"))
        {
          if (CFEqual(EAP, @"1.2.840.113635.100.1.64"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleSoftwareSigning();
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.65"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.66"))
          {
            SMIME = SecPolicyCreateOCSPSigner();
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.67"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleIDSService(v5);
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.70"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateApplePushServiceLegacy(v5);
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.71"))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleTVOSApplicationSigning();
            goto LABEL_17;
          }

          if (CFEqual(EAP, @"1.2.840.113635.100.1.73"))
          {
            CFRange v37 = @"1.2.840.113635.100.1.73";
            uint64_t v38 = @"Escrow";
            uint64_t v39 = @"1.2.840.113635.100.6.27.7.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.7.1";
          }

          else if (CFEqual(EAP, @"1.2.840.113635.100.1.74"))
          {
            CFRange v37 = @"1.2.840.113635.100.1.74";
            uint64_t v38 = @"MMCS";
            uint64_t v39 = @"1.2.840.113635.100.6.27.11.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.11.1";
          }

          else
          {
            if (CFEqual(EAP, @"1.2.840.113635.100.1.75"))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleSecureIOStaticAsset();
              goto LABEL_17;
            }

            if (CFEqual(EAP, @"1.2.840.113635.100.1.76"))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleWarsaw();
              goto LABEL_17;
            }

            if (!CFEqual(EAP, @"1.2.840.113635.100.1.78"))
            {
              if (CFEqual(EAP, @"1.2.840.113635.100.1.80"))
              {
                SMIME = SecPolicyCreateAppleAppTransportSecurity();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.81"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacOSProfileApplicationSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.82"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileSoftwareUpdate();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.83"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileAssetDevelopment();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.86"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiPhoneVPNApplicationSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.87"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiAPSWAuthWithExpiration(0);
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.88"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDemoDigitalCatalogSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.89"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAssetReceipt();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.90"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleDeveloperIDPlusTicket();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.91"))
              {
                SMIME = SecPolicyCreateAppleFDRProvisioning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.93"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleKeyTransparency(v5);
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.95"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAlisha();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.96"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMeasuredBootPolicySigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.97"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeEncryption();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.98"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.99"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAccessoryUpdateSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.100"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceIdKeySigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.101"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceIdKeySigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.103"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDeveloperIDInstaller();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.104"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreInstaller();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.105"))
              {
                CFRange v29 = @"MacDistributionInstaller";
                int v30 = @"1.2.840.113635.100.6.2.1";
                CFTypeID v31 = @"1.2.840.113635.100.6.1.8";
                goto LABEL_77;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.109"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleCHIPUpdateSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.110"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateOrderBundleSigner(v5);
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.111"))
              {
                SMIME = SecPolicyCreateQiSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.113"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleXROSApplicationSigning();
                goto LABEL_17;
              }

              if (CFEqual(EAP, @"1.2.840.113635.100.1.114"))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEDPSigning();
                goto LABEL_17;
              }

              if (!CFEqual(EAP, @"1.2.840.113635.100.1.116"))
              {
                if (CFEqual(EAP, @"1.2.840.113635.100.1.119"))
                {
                  SMIME = SecPolicyCreateDCAttestation();
                  goto LABEL_17;
                }

                int v23 = (os_log_s *)secLogObjForScope("SecError");
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)value = 138412290;
                  *(void *)&value[4] = EAP;
                  CFIndex v16 = "ERROR: policy %@ is unsupported";
                  goto LABEL_90;
                }

                return 0LL;
              }

              uint64_t v32 = @"1.2.840.113635.100.1.116";
              CFRange v33 = @"ParakeetSigning";
              CFRange v34 = 0LL;
              CFRange v35 = 0LL;
LABEL_129:
              SMIME = (__SecPolicy *)SecPolicyCreateParakeetCommon(v34, v35, v32, v33);
              goto LABEL_17;
            }

            CFRange v37 = @"1.2.840.113635.100.1.78";
            uint64_t v38 = @"iCloudSetup";
            uint64_t v39 = @"1.2.840.113635.100.6.27.15.2";
            uint64_t v40 = @"1.2.840.113635.100.6.27.15.1";
          }

          SMIME = (__SecPolicy *)SecPolicyCreateAppleGeoTrustServerAuthCommon(v5, v37, v38, v39, v40);
          goto LABEL_17;
        }

        goto LABEL_137;
      }

      int v36 = 1;
    }

    SMIME = (__SecPolicy *)CreateMobileStoreSigner(v36);
    goto LABEL_17;
  }

  SMIME = (__SecPolicy *)SecPolicyCreateSSL_internal(!v7, v5, 0, 0LL);
LABEL_17:
  EAP = SMIME;
LABEL_18:
  if (EAP && cf) {
    SecPolicySetName((uint64_t)EAP, cf);
  }
  return EAP;
}

void *SecPolicyCreateSMIME(char a1, const void *a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFStringRef v5 = Mutable;
  if ((a1 & 0x40) != 0)
  {
    SecPolicyAddBasicCertOptions(Mutable);
    if ((a1 & 1) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  SecPolicyAddBasicX509Options(Mutable);
  if ((a1 & 1) != 0)
  {
LABEL_6:
    add_ku(v5, 0);
    add_ku(v5, 1);
  }

__CFDictionary *SecPolicyCreateEAP(int a1, const void *a2)
{
  uint64_t result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFStringRef v5 = result;
    SecPolicyAddBasicX509Options(result);
    int v6 = (const void *)*MEMORY[0x189604DE8];
    CFDictionaryAddValue(v5, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    if (a2) {
      CFDictionaryAddValue(v5, @"EAPTrustedServerNames", a2);
    }
    if (a1)
    {
      CFDictionaryAddValue(v5, @"SystemTrustedWeakHash", v6);
      CFDictionaryAddValue(v5, @"SystemTrustedWeakKey", v6);
    }

    BOOL v7 = a1 != 0;
    if (a1) {
      CFNumberRef v8 = @"eapServer";
    }
    else {
      CFNumberRef v8 = @"eapClient";
    }
    set_ssl_ekus(v5, v7);
    uint64_t v9 = SecPolicyCreate(@"1.2.840.113635.100.1.9", v8, v5);
    CFRelease(v5);
    return (__CFDictionary *)v9;
  }

  return result;
}

__CFDictionary *SecPolicyCreateIPSec(int a1, const void *a2)
{
  uint64_t result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFStringRef v5 = result;
    SecPolicyAddBasicX509Options(result);
    if (a2) {
      CFDictionaryAddValue(v5, @"SSLHostname", a2);
    }
    if (a1) {
      int v6 = @"ipsecServer";
    }
    else {
      int v6 = @"ipsecClient";
    }
    BOOL v7 = SecPolicyCreate(@"1.2.840.113635.100.1.11", v6, v5);
    CFRelease(v5);
    return (__CFDictionary *)v7;
  }

  return result;
}

void *SecPolicyCreateMacAppStoreReceipt()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  int v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_element(v1, @"CertificatePolicy", @"1.2.840.113635.100.5.6.1");
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.11.1");
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.19", @"MacAppStoreReceipt", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

SecPolicyRef SecPolicyCreateRevocation(CFOptionFlags revocationFlags)
{
  CFOptionFlags v1 = revocationFlags;
  if (!revocationFlags) {
    return (SecPolicyRef)v1;
  }
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  CFStringRef v4 = (const void **)MEMORY[0x189604DE8];
  if ((v1 & 0x40) != 0)
  {
    CFDictionaryAddValue(Mutable, @"RevocationIfTrusted", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  }

  if ((v1 & 0x20) != 0)
  {
    CFDictionaryAddValue(v3, @"RevocationOnline", *v4);
    CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  }

  if ((v1 & 3) == 3)
  {
    CFStringRef v5 = @"AnyRevocationMethod";
  }

  else
  {
    if ((v1 & 1) != 0) {
      CFStringRef v5 = @"OCSP";
    }
    else {
      CFStringRef v5 = @"CRL";
    }
    if ((v1 & 3) == 0) {
      goto LABEL_14;
    }
  }

  CFDictionaryAddValue(v3, @"Revocation", v5);
LABEL_14:
  int v6 = *v4;
  if ((v1 & 8) != 0) {
    CFDictionaryAddValue(v3, @"RevocationResponseRequired", v6);
  }
  if ((v1 & 0x10) != 0) {
    BOOL v7 = v6;
  }
  else {
    BOOL v7 = (const void *)*MEMORY[0x189604DE0];
  }
  CFDictionaryAddValue(v3, @"NoNetworkAccess", v7);
  if (v1 > 0x7F) {
    CFOptionFlags v1 = 0LL;
  }
  else {
    CFOptionFlags v1 = (CFOptionFlags)SecPolicyCreate(@"1.2.840.113635.100.1.21", @"revocation", v3);
  }
  CFRelease(v3);
  return (SecPolicyRef)v1;
}

void *SecPolicyCreatePassbookCardSigner(void *a1, const void *a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFStringRef v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v5))
  {
    BOOL v6 = SecPolicyAddChainLengthOptions(v5, 3LL);
    BOOL v7 = 0LL;
    if (a2 && v6)
    {
      CFDictionaryAddValue(v5, @"SubjectOrganizationalUnit", a2);
      add_leaf_marker_value(v5, (uint64_t)&oidAppleInstallerPackagingSigningExternal, a1);
      add_element(v5, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
      add_eku(v5, oidAppleExtendedKeyUsagePassbook);
      BOOL v7 = SecPolicyCreate(@"1.2.840.113635.100.1.22", @"ApplePassbook", v5);
    }
  }

  else
  {
    BOOL v7 = 0LL;
  }

  CFRelease(v5);
  return v7;
}

void *SecPolicyCreateAppleServerAuthCommon( const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v11 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (!a1) {
    goto LABEL_27;
  }
  CFDictionaryAddValue(v11, @"SSLHostname", a1);
  char v12 = (const void *)*MEMORY[0x189604DE8];
  CFDictionaryAddValue(v11, @"BlackListedLeaf", (const void *)*MEMORY[0x189604DE8]);
  CFDictionaryAddValue(v11, @"GrayListedLeaf", v12);
  add_eku(v11, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  SecPolicyAddAppleAnchorOptions(v11);
  if (a5)
  {
    CFIndex v13 = *(void *)(a4 + 8);
    if ((v13 & 0x8000000000000000LL) == 0 && (*(void *)(a5 + 8) & 0x8000000000000000LL) == 0)
    {
      CFDataRef v14 = CFDataCreate(0LL, *(const UInt8 **)a4, v13);
      CFDataRef v15 = CFDataCreate(0LL, *(const UInt8 **)a5, *(void *)(a5 + 8));
      add_leaf_prod_qa_element(v11, v14, v15);
      if (v14) {
        CFRelease(v14);
      }
      if (v15) {
        CFRelease(v15);
      }
    }

    CFIndex v16 = (__CFString *)SecDERItemCopyOIDDecimalRepresentation(0LL, (unsigned __int8 **)a4);
    CFStringRef v17 = (__CFString *)SecDERItemCopyOIDDecimalRepresentation(0LL, (unsigned __int8 **)a5);
    uint32_t v18 = v17;
    BOOL v19 = v17 != 0LL;
    if (v16 && v17)
    {
      add_leaf_prod_qa_markers_value_string(v11, v16, v17);
      CFRelease(v16);
LABEL_18:
      CFRelease(v18);
      goto LABEL_19;
    }

    if (!v16)
    {
      if (!v17) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }

  else
  {
    add_leaf_marker_value(v11, a4, 0LL);
    CFStringRef v20 = SecDERItemCopyOIDDecimalRepresentation(0LL, (unsigned __int8 **)a4);
    if (!v20) {
      goto LABEL_19;
    }
    CFIndex v16 = (__CFString *)v20;
    uint32_t v18 = 0LL;
    BOOL v19 = 0;
  }

  add_leaf_marker_value_string(v11, @"1.2.840.113635.100.6.48.1", v16);
  CFRelease(v16);
  if (v19) {
    goto LABEL_18;
  }
LABEL_19:
  add_oid(v11, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleServerAuthentication, 10LL);
LABEL_20:
  if (!SecPolicyRemoveWeakHashOptions(v11) || !SecPolicyAddStrongKeySizeOptions(v11))
  {
LABEL_27:
    CFTypeID v21 = 0LL;
    goto LABEL_23;
  }

  CFDictionaryAddValue(v11, @"Revocation", @"AnyRevocationMethod");
  CFTypeID v21 = SecPolicyCreate(a2, a3, v11);
LABEL_23:
  CFRelease(v11);
  return v21;
}

void *SecPolicyCreateApplePinned(const void *a1, const __CFString *a2, const __CFString *a3)
{
  CFTypeID v3 = 0LL;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1 && a2 && a3)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    if (Mutable)
    {
      CFNumberRef v8 = Mutable;
      SecPolicyAddBasicX509Options(Mutable);
      if (!SecPolicyAddAppleAnchorOptions(v8) || !SecPolicyAddChainLengthOptions(v8, 3LL)) {
        goto LABEL_17;
      }
      if ((isAppleOid(a2) & 1) == 0)
      {
        uint64_t v9 = (os_log_s *)secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 138412290;
          CFIndex v13 = a2;
          _os_log_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEFAULT,  "creating an Apple pinning policy with a non-Apple OID: %@",  (uint8_t *)&v12,  0xCu);
        }
      }

      add_element(v8, @"IntermediateMarkerOid", a2);
      if ((isAppleOid(a3) & 1) == 0)
      {
        CFIndex v10 = (os_log_s *)secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 138412290;
          CFIndex v13 = a3;
          _os_log_impl( &dword_1804F4000,  v10,  OS_LOG_TYPE_DEFAULT,  "creating an Apple pinning policy with a non-Apple OID: %@",  (uint8_t *)&v12,  0xCu);
        }
      }

      add_element(v8, @"LeafMarkerOid", a3);
      add_element(v8, @"Revocation", @"AnyRevocationMethod");
      if (SecPolicyAddStrongKeySizeOptions(v8)) {
        CFTypeID v3 = SecPolicyCreate(@"1.2.840.113635.100.1.62", a1, v8);
      }
      else {
LABEL_17:
      }
        CFTypeID v3 = 0LL;
      CFRelease(v8);
    }

    else
    {
      return 0LL;
    }
  }

  return v3;
}

void *SecPolicyCreateAppleSSLPinned( const void *a1, const __CFString *a2, const __CFString *a3, __CFString *a4)
{
  SSL_internal = 0LL;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1 && a2 && a4)
  {
    if (requireUATPinning((uint64_t)a1))
    {
      CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      if (Mutable)
      {
        CFIndex v10 = Mutable;
        SecPolicyAddBasicX509Options(Mutable);
        if (!SecPolicyAddAppleAnchorOptions(v10) || !SecPolicyAddChainLengthOptions(v10, 3LL)) {
          goto LABEL_23;
        }
        if (a3)
        {
          if ((isAppleOid(a3) & 1) == 0)
          {
            CFTypeID v11 = (os_log_s *)secLogObjForScope("SecWarning");
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              int v16 = 138412290;
              CFStringRef v17 = a3;
              _os_log_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEFAULT,  "creating an Apple pinning policy with a non-Apple OID: %@",  (uint8_t *)&v16,  0xCu);
            }
          }

          int v12 = v10;
          CFIndex v13 = a3;
        }

        else
        {
          CFIndex v13 = @"1.2.840.113635.100.6.2.12";
          int v12 = v10;
        }

        add_element(v12, @"IntermediateMarkerOid", v13);
        if ((isAppleOid(a4) & 1) == 0)
        {
          uint64_t v14 = (os_log_s *)secLogObjForScope("SecWarning");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = 138412290;
            CFStringRef v17 = a4;
            _os_log_impl( &dword_1804F4000,  v14,  OS_LOG_TYPE_DEFAULT,  "creating an Apple pinning policy with a non-Apple OID: %@",  (uint8_t *)&v16,  0xCu);
          }
        }

        add_element(v10, @"LeafMarkerOid", a4);
        add_leaf_marker_value_string(v10, @"1.2.840.113635.100.6.48.1", a4);
        add_element(v10, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.1");
        add_element(v10, @"SSLHostname", a2);
        if (SecPolicyAddStrongKeySizeOptions(v10) && SecPolicyRemoveWeakHashOptions(v10))
        {
          add_element(v10, @"Revocation", @"AnyRevocationMethod");
          SSL_internal = SecPolicyCreate(@"1.2.840.113635.100.1.63", a1, v10);
        }

        else
        {
LABEL_23:
          SSL_internal = 0LL;
        }

        CFRelease(v10);
      }

      else
      {
        return 0LL;
      }
    }

    else
    {
      SSL_internal = SecPolicyCreateSSL_internal(1, a2, 0, 0LL);
      SecPolicySetOid((uint64_t)SSL_internal, @"1.2.840.113635.100.1.63");
      SecPolicySetName((uint64_t)SSL_internal, a1);
    }
  }

  return SSL_internal;
}

void *SecPolicyCreateAppleUniqueDeviceCertificate(const void *a1)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  CFTypeRef v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFStringRef v4 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAnchorSHA256Options(v4, SEPRootCA_SHA256)) {
    goto LABEL_16;
  }
  if (!SecPolicyAddChainLengthOptions(v4, 3LL)) {
    goto LABEL_16;
  }
  values = @"ucrt";
  keys[0] = @"1.2.840.113635.100.6.44";
  CFDictionaryRef v5 = CFDictionaryCreate( v2,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  add_element(v4, @"IntermediateMarkerOid", v5);
  if (v5) {
    CFRelease(v5);
  }
  add_element(v4, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.10.1");
  keys[0] = (void *)256;
  CFTypeRef cf = CFNumberCreate(0LL, kCFNumberCFIndexType, keys);
  if (cf
    && (CFDictionaryRef v6 = CFDictionaryCreate( 0LL,  (const void **)&kSecAttrKeyTypeEC,  &cf,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250])) != 0LL)
  {
    BOOL v7 = v6;
    add_element(v4, @"KeySize", v6);
    CFNumberRef v8 = SecPolicyCreate(@"1.2.840.113635.100.1.72", @"UCRT", v4);
    CFRelease(v4);
    CFStringRef v4 = v7;
  }

  else
  {
LABEL_16:
    CFNumberRef v8 = 0LL;
  }

  CFRelease(v4);
  if (cf) {
    CFRelease(cf);
  }
  return v8;
}

void *SecPolicyCreateAppleBasicAttestationSystem(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v3, @"ValidLeaf", (const void *)*MEMORY[0x189604DE8]);
  SecPolicyAddAnchorSHA256Options(v3, BASystemRootCA_SHA256);
  if (SecPolicyAddChainLengthOptions(v3, 3LL)) {
    CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.84", @"BAA-SCRT", v3);
  }
  else {
    CFStringRef v4 = 0LL;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleBasicAttestationUser(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v3, @"ValidLeaf", (const void *)*MEMORY[0x189604DE8]);
  SecPolicyAddAnchorSHA256Options(v3, BAUserRootCA_SHA256);
  if (SecPolicyAddChainLengthOptions(v3, 3LL)) {
    CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.85", @"BAA-UCRT", v3);
  }
  else {
    CFStringRef v4 = 0LL;
  }
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleComponentCertificate(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v3, ComponentRootCA_SHA256);
  if (SecPolicyAddChainLengthOptions(v3, 3LL))
  {
    add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.11.1");
    add_element(v3, @"IntermediateMarkerOidWithoutValueCheck", @"1.2.840.113635.100.11.1");
    CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.92", @"Component", v3);
  }

  else
  {
    CFStringRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAggregateMetricTransparency(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3LL)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFStringRef v4 = @"1.2.840.113635.100.12.18")
      : (CFStringRef v4 = @"1.2.840.113635.100.12.17"),
        add_element(v3, @"LeafMarkerOidWithoutValueCheck", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0LL))
    {
      add_element(v3, @"CTRequired", (const void *)*MEMORY[0x189604DE8]);
    }

    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.102", @"AggregateMetricTransparency", v3);
  }

  else
  {
    CFDictionaryRef v5 = 0LL;
  }

  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateAggregateMetricEncryption(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3LL)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFStringRef v4 = @"1.2.840.113635.100.15.3")
      : (CFStringRef v4 = @"1.2.840.113635.100.15.2"),
        add_element(v3, @"LeafMarkerOid", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0LL))
    {
      add_element(v3, @"NonTlsCTRequired", (const void *)*MEMORY[0x189604DE8]);
    }

    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.106", @"AggregateMetricEncryption", v3);
  }

  else
  {
    CFDictionaryRef v5 = 0LL;
  }

  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateApplePayModelSigning(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3LL)
    && (add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17"),
        add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.12.20"),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.107", @"ApplePayModelSigning", v3);
  }

  else
  {
    CFStringRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateMDLTerminalAuth(int a1, int a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDictionaryRef v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  add_ku(v5, 1);
  if (a1) {
    add_element(v5, @"ExtendedKeyUsage", @"1.0.18013.5.1.6");
  }
  if (a2) {
    add_element(v5, @"BasicConstraintsCA", (const void *)*MEMORY[0x189604DE8]);
  }
  if (SecPolicyAddStrongKeySizeOptions(v5)
    && SecPolicyRemoveWeakHashOptions(v5)
    && (unint64_t Value = (__CFArray *)CFDictionaryGetValue(v5, @"SignatureHashAlgorithms")) != 0LL)
  {
    CFArrayAppendValue(Value, @"SignatureDigestSHA224");
    BOOL v7 = SecPolicyCreate(@"1.2.840.113635.100.1.108", @"MDLTerminalAuth", v5);
  }

  else
  {
    BOOL v7 = 0LL;
  }

  CFRelease(v5);
  return v7;
}

void *SecPolicyCreatePPMAggregatorConfigSigning(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3LL)
    && ((add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.26"), !a1)
      ? (CFStringRef v4 = @"1.2.840.113635.100.14.3")
      : (CFStringRef v4 = @"1.2.840.113635.100.12.44"),
        add_element(v3, @"LeafMarkerOid", v4),
        add_element(v3, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(@"disableAggregateMetricsCTCheck", @"com.apple.security", 0LL))
    {
      add_element(v3, @"NonTlsCTRequired", (const void *)*MEMORY[0x189604DE8]);
    }

    CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.112", @"PPMAggregatorConfigSigning", v3);
  }

  else
  {
    CFDictionaryRef v5 = 0LL;
  }

  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateiAPAuthV4(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  switch(a1)
  {
    case 1:
      CFStringRef v4 = @"Apple Accessories Certification Authority - ";
      break;
    case 3:
      CFDictionaryAddValue(v3, @"IssuerCommonNamePrefix", @"Apple Accessories Provisioning Authority - ");
      goto LABEL_9;
    case 2:
      CFStringRef v4 = @"Apple Accessory Host Attestation Authority - ";
      break;
    default:
      CFDictionaryRef v5 = 0LL;
      goto LABEL_11;
  }

  CFDictionaryAddValue(v3, @"IssuerCommonNamePrefix", v4);
  add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.71.1");
LABEL_9:
  CFDictionaryRef v5 = SecPolicyCreate(@"1.2.840.113635.100.1.117", @"iAPAuthV4", v3);
LABEL_11:
  CFRelease(v3);
  return v5;
}

void *SecPolicyCreateParakeetCommon(const void *a1, const void *a2, const void *a3, const void *a4)
{
  values = 0LL;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v9 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v9, 3LL))
  {
    uint64_t valuePtr = 256LL;
    values = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFDictionaryRef v10 = CFDictionaryCreate( 0LL,  (const void **)&kSecAttrKeyTypeEC,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      if (v10)
      {
        CFDictionaryRef v11 = v10;
        add_element(v9, @"KeySize", v10);
        if (!SecPolicyRemoveWeakHashOptions(v9)
          || (unint64_t Value = (__CFArray *)CFDictionaryGetValue(v9, @"SignatureHashAlgorithms")) == 0LL)
        {
          int v26 = 0LL;
          goto LABEL_30;
        }

        CFRange v29 = a3;
        CFArrayAppendValue(Value, @"SignatureDigestSHA224");
        add_ku(v9, 16);
        CFIndex v13 = (const void *)*MEMORY[0x189604DE8];
        CFDictionarySetValue(v9, @"NotCA", (const void *)*MEMORY[0x189604DE8]);
        uint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x189605228];
        CFDataRef v15 = CFArrayCreateMutable(0LL, 1LL, MEMORY[0x189605228]);
        int v16 = CFArrayCreateMutable(0LL, 2LL, v14);
        uint64_t valuePtr = 0x4158674400000000LL;
        CFDateRef v17 = CFDateCreate(0LL, 0.0);
        CFNumberRef v18 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v16, v17);
        CFArrayAppendValue(v16, v18);
        if (v17) {
          CFRelease(v17);
        }
        if (v18) {
          CFRelease(v18);
        }
        CFArrayAppendValue(v15, v16);
        if (v16) {
          CFRelease(v16);
        }
        CFDictionaryAddValue(v9, @"SystemTrustValidityPeriod", v15);
        CFDictionaryAddValue(v9, @"OtherTrustValidityPeriod", v15);
        if (v15) {
          CFRelease(v15);
        }
        CFDictionaryAddValue(v9, @"NoNetworkAccess", v13);
        if (a1) {
          CFDictionaryAddValue(v9, @"SSLHostname", a1);
        }
        if (a2)
        {
          CFTypeID v19 = CFGetTypeID(a2);
          if (v19 == CFDictionaryGetTypeID())
          {
            double Current = CFAbsoluteTimeGetCurrent();
            CFTypeID v21 = CFDictionaryGetValue((CFDictionaryRef)a2, @"verify");
            if (v21)
            {
              CFArrayRef v22 = v21;
              CFTypeID v23 = CFGetTypeID(v21);
              if (v23 == CFDateGetTypeID()) {
                double Current = MEMORY[0x186DFE188](v22);
              }
            }

            CFIndex v24 = CFDictionaryGetValue((CFDictionaryRef)a2, @"fresh");
            if (v13 && v24)
            {
              if (!CFEqual(v24, v13)) {
                goto LABEL_29;
              }
LABEL_27:
              CFDateRef v25 = CFDateCreate(0LL, Current + -172800.0);
              CFDictionaryAddValue(v9, @"NotValidBefore", v25);
              if (v25) {
                CFRelease(v25);
              }
              goto LABEL_29;
            }

            if (v24 == v13) {
              goto LABEL_27;
            }
          }
        }

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicX509Options(result);
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFTypeRef v2 = (__SecPolicy *)SecPolicyCreate(@"1.2.840.113635.100.1.2", @"basicX509", v1);
    CFRelease(v1);
    return v2;
  }

  return result;
}

void *SecPolicyCreateAppleSWUpdateSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_eku(v1, oidAppleExtendedKeyUsageCodeSigning);
    add_oid(v1, @"IntermediateEKU", _oidAppleExtendedKeyUsageCodeSigning, 9LL);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.10", @"AppleSWUpdateSigning", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateCodeSigning()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_ku(v1, 1);
    add_ku(v1, 2);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.16", @"CodeSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateApplePackageSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.17", @"PackageSigning", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleIDAuthorityPolicy()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleExtendedKeyUsageAppleID, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID, 10LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID2, 10LL);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.61", @"AppleIDAuthority", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleTimeStamping()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageTimeStamping);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.20", @"AppleTimeStamping", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *CreateMobileStoreSigner(int a1)
{
  CFTypeRef v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFStringRef v4 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (a1) {
    CFDictionaryRef v5 = @"AppleTestMobileStore";
  }
  else {
    CFDictionaryRef v5 = @"AppleMobileStore";
  }
  if (SecPolicyAddAppleAnchorOptions(v4) && SecPolicyAddChainLengthOptions(v4, 3LL))
  {
    CFDictionaryAddValue(v4, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
    add_ku(v4, 1);
    CFDictionaryRef v6 = (const UInt8 **)&oidApplePolicyMobileStore;
    BOOL v7 = (CFIndex *)&unk_189664998;
    if (a1) {
      BOOL v7 = (CFIndex *)&unk_1896649A8;
    }
    if ((*v7 & 0x8000000000000000LL) == 0)
    {
      if (a1) {
        CFDictionaryRef v6 = (const UInt8 **)&oidApplePolicyMobileStoreProdQA;
      }
      CFDataRef v8 = CFDataCreate(v2, *v6, *v7);
      if (v8)
      {
        CFDataRef v9 = v8;
        add_element(v4, @"CertificatePolicy", v8);
        CFRelease(v9);
      }
    }

    if (a1) {
      CFDictionaryRef v10 = @"1.2.840.113635.100.1.27";
    }
    else {
      CFDictionaryRef v10 = @"1.2.840.113635.100.1.23";
    }
    CFDictionaryRef v11 = SecPolicyCreate(v10, v5, v4);
  }

  else
  {
    CFDictionaryRef v11 = 0LL;
  }

  CFRelease(v4);
  return v11;
}

void *SecPolicyCreateEscrowServiceSigner()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.23.1");
  if (SecPolicyAddChainLengthOptions(v1, 2LL)) {
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.24", @"AppleEscrowService", v1);
  }
  else {
    CFTypeRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateConfigurationProfileSigner()
{
  uint64_t v0 = (const void *)MGCopyAnswer();
  CFOptionFlags v1 = v0;
  if (v0) {
    CFRelease(v0);
  }
  return SecPolicyCreatePrivacyConfigurationProfileSigner(1, v1 != 0LL);
}

void *SecPolicyCreateAppleIDValidationRecordSigningPolicy()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtensionAppleIDRecordValidationSigning, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleID, 10LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10LL);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.30", @"AppleIDValidationRecordSigningPolicy", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleIDValidationShortcutSigningPolicy()
{
  AppleIDValidationRecordSigningPolicy = SecPolicyCreateAppleIDValidationRecordSigningPolicy();
  CFOptionFlags v1 = AppleIDValidationRecordSigningPolicy;
  if (AppleIDValidationRecordSigningPolicy)
  {
    CFTypeRef v2 = (__CFDictionary *)AppleIDValidationRecordSigningPolicy[4];
    if (v2) {
      CFDictionaryRemoveValue(v2, @"TemporalValidity");
    }
  }

  return v1;
}

void *SecPolicyCreateAppleSMPEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtAppleSMPEncryption, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntgG3, 10LL);
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.31", @"AppleSMPEncryption", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateTestAppleSMPEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v1, kTestAppleRootCA_ECC_SHA256);
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Test Apple System Integration CA - ECC");
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.32", @"AppleTestSMPEncryption", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

const void *SecPolicyCreateAppleSSLService(const __CFString *a1)
{
  SSL_internal = SecPolicyCreateSSL_internal(1, a1, 0, 0LL);
  CFTypeRef v2 = SSL_internal;
  if (SSL_internal)
  {
    CFTypeID v3 = (const __CFDictionary *)SSL_internal[4];
    if (v3)
    {
      if (SecPolicyAddAppleAnchorOptions((const __CFDictionary *)SSL_internal[4]))
      {
        add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtAppleServerAuthentication, 0LL);
        add_oid(v3, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleServerAuthentication, 10LL);
        if (SecPolicyRemoveWeakHashOptions(v3))
        {
          CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
          SecPolicySetOid((uint64_t)v2, @"1.2.840.113635.100.1.33");
          SecPolicySetName((uint64_t)v2, @"AppleSSLService");
          return v2;
        }
      }

      CFRelease(v3);
    }

    CFRelease(v2);
    return 0LL;
  }

  return v2;
}

void *SecPolicyCreatePCSEscrowServiceSigner()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.23.1");
  if (SecPolicyAddChainLengthOptions(v1, 2LL)) {
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.34", @"ApplePCSEscrowService", v1);
  }
  else {
    CFTypeRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePPQSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAppleAnchorOptions(v1);
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProd, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10LL);
    add_ku(v1, 1);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.35", @"ApplePPQSigning", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateTestApplePPQSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAppleAnchorOptions(v1);
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple System Integration 2 Certification Authority");
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProdQA, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10LL);
    add_ku(v1, 1);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.36", @"AppleTestPPQSigning", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePayIssuerEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple Worldwide Developer Relations CA - G2");
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtCryptoServicesExtEncryption, 0LL);
    add_ku(v1, 4);
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.39", @"ApplePayIssuerEncryption", v1);
  }

  else
  {
    CFTypeRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateOSXProvisioningProfileSigning()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicX509Options(result);
    SecPolicyAddAppleAnchorOptions(v1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtOSXProvisioningProfileSigning, 0LL);
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10LL);
    add_ku(v1, 1);
    CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
    CFTypeRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.40", @"AppleOSXProvisioningProfileSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateAppleATVVPNProfileSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (v2)
  {
    CFTypeID v3 = v2;
    add_element(v1, @"AnchorApple", v3);
    if (SecPolicyAddChainLengthOptions(v1, 3LL))
    {
      add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtATVVPNProfileSigning, 0LL);
      add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleSystemIntg2, 10LL);
      CFDictionaryAddValue(v1, @"Revocation", @"OCSP");
      CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.41", @"AppleATVVPNProfileSigning", v1);
    }

    else
    {
      CFStringRef v4 = 0LL;
    }

    CFRelease(v1);
  }

  else
  {
    CFStringRef v4 = 0LL;
    CFTypeID v3 = v1;
  }

  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAppleHomeKitServerAuth(const void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  CFDictionaryAddValue(v3, @"SSLHostname", a1);
  add_eku(v3, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning((uint64_t)@"HomeKit"))
  {
    if (!SecPolicyAddChainLengthOptions(v3, 3LL))
    {
LABEL_10:
      CFStringRef v4 = 0LL;
      goto LABEL_8;
    }

    SecPolicyAddAppleAnchorOptions(v3);
    add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtHomeKitServerAuth, 0LL);
    add_oid(v3, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleHomeKitServerCA, 10LL);
  }

  if (!SecPolicyRemoveWeakHashOptions(v3) || !SecPolicyAddStrongKeySizeOptions(v3)) {
    goto LABEL_10;
  }
  CFDictionaryAddValue(v3, @"Revocation", @"AnyRevocationMethod");
  CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.48", @"HomeKit", v3);
LABEL_8:
  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateiPhoneActivation()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone Activation");
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x189604DE8]);
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.49", @"iPhoneActivation", v1);
  }

  else
  {
    CFMutableDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneDeviceCertificate()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Device CA");
  if (SecPolicyAddChainLengthOptions(v1, 4LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x189604DE8]);
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.50", @"iPhoneDeviceCertificate", v1);
  }

  else
  {
    CFMutableDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateFactoryDeviceCertificate()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAnchorSHA256Options(v1, kFactoryDeviceCASHA256)) {
    CFMutableDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.51", @"FactoryDeviceCertificate", v1);
  }
  else {
    CFMutableDictionaryRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiAP()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"SubjectCommonNamePrefix", @"IPA_");
  CFDateRef v2 = CFDateCreate(0LL, 170726400.0);
  CFDictionaryAddValue(v1, @"NotValidBefore", v2);
  CFDictionaryAddValue(v1, @"RevocationDbIgnored", (const void *)*MEMORY[0x189604DE8]);
  CFTypeID v3 = SecPolicyCreate(@"1.2.840.113635.100.1.52", @"iAP", v1);
  if (v2) {
    CFRelease(v2);
  }
  CFRelease(v1);
  return v3;
}

void *SecPolicyCreateiTunesStoreURLBag()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"SubjectOrganization", @"Apple Inc.");
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"iTunes Store URL Bag");
  if (SecPolicyAddChainLengthOptions(v1, 2LL) && SecPolicyAddAnchorSHA256Options(v1, kITMS_CA_SHA256)) {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.53", @"iTunesStoreURLBag", v1);
  }
  else {
    CFDateRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, @"SubjectCommonNameTEST", @"Apple iPhone OS Application Signing");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.3.1");
  }

  else
  {
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone OS Application Signing");
  }

  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.3");
  add_eku(v1, 0LL);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.54", @"iPhoneApplicationSigning", v1);
  }

  else
  {
LABEL_10:
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneProfileApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.2");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.4");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.25.1");
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.55", @"iPhoneProfileApplicationSigning", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneProvisioningProfileSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  else {
    CFDateRef v2 = @"SubjectCommonName";
  }
  CFDictionaryAddValue(v1, v2, @"Apple iPhone OS Provisioning Profile Signing");
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFTypeID v3 = SecPolicyCreate(@"1.2.840.113635.100.1.56", @"iPhoneProvisioningProfileSigning", v1);
  }

  else
  {
    CFTypeID v3 = 0LL;
  }

  CFRelease(v1);
  return v3;
}

__CFDictionary *SecPolicyCreateLockdownPairing()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    CFDateRef v2 = (const void *)*MEMORY[0x189604DE8];
    CFDictionaryAddValue(result, @"CriticalExtensions", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v1, @"UnparseableExtension", v2);
    CFDictionaryAddValue(v1, @"DuplicateExtension", v2);
    CFDictionaryAddValue(v1, @"IdLinkage", v2);
    CFDictionaryAddValue(v1, @"BasicConstraints", v2);
    CFDictionaryAddValue(v1, @"WeakKeySize", v2);
    CFDictionaryAddValue(v1, @"RevocationDbIgnored", v2);
    CFTypeID v3 = SecPolicyCreate(@"1.2.840.113635.100.1.57", @"LockdownPairing", v1);
    CFRelease(v1);
    return (__CFDictionary *)v3;
  }

  return result;
}

__CFDictionary *SecPolicyCreateURLBag()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicCertOptions(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.58", @"URLBag", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateOTATasking()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"OTA Task Signing");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.59", @"OTATasking", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileAsset()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Asset Manifest Signing");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.60", @"MobileAsset", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleSoftwareSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IssuerCommonName", @"Apple Code Signing Certification Authority"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.22"),
        add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.64", @"SoftwareSigning", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleExternalDeveloperOptionalExpiry(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFTypeID v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (!SecPolicyAddAppleAnchorOptions(v3)) {
    goto LABEL_11;
  }
  if (!SecPolicyAddChainLengthOptions(v3, 3LL)) {
    goto LABEL_11;
  }
  add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
  add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.6");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.2");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.4");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.5");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.7");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.8");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.12");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.13");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.14");
  add_element(v3, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.35");
  add_element(v3, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.8");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.9");
  add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.13");
  add_element(v3, @"Revocation", @"AnyRevocationMethod");
  if (SecPolicyAddStrongKeySizeOptions(v3)) {
    CFStringRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.65", @"Developer", v3);
  }
  else {
LABEL_11:
  }
    CFStringRef v4 = 0LL;
  CFRelease(v3);
  return v4;
}

__CFDictionary *SecPolicyCreateOCSPSigner()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageOCSPSigning);
    add_ku(v1, 1);
    CFDictionarySetValue(v1, @"NotCA", (const void *)*MEMORY[0x189604DE8]);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.66", @"OCSPSigner", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateAppleIDSService(const void *a1)
{
  AppleServerAuthCommon = SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.67",  @"IDSBag",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProdQA);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, (CFDictionaryRef)AppleServerAuthCommon[4]);
  CFDictionaryRemoveValue(MutableCopy, @"Revocation");
  CFTypeID v3 = (const void *)AppleServerAuthCommon[4];
  if (v3) {
    CFRelease(v3);
  }
  AppleServerAuthCommon[4] = MutableCopy;
  return AppleServerAuthCommon;
}

void *SecPolicyCreateApplePushServiceLegacy(const void *a1)
{
  CFDateRef v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v3 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  entrustSPKIL1C,  32LL,  (CFAllocatorRef)*MEMORY[0x189604DC8]);
  if (!v3) {
    return 0LL;
  }
  CFDataRef v4 = v3;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(v2, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    CFDictionaryRef v6 = Mutable;
    SecPolicyAddBasicX509Options(Mutable);
    CFDictionaryAddValue(v6, @"SSLHostname", a1);
    BOOL v7 = (const void *)*MEMORY[0x189604DE8];
    CFDictionaryAddValue(v6, @"BlackListedLeaf", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v6, @"GrayListedLeaf", v7);
    CFDictionaryAddValue(v6, @"IntermediateSPKISHA256", v4);
    add_eku(v6, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
    if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
    {
      CFDictionaryAddValue(v6, @"Revocation", @"AnyRevocationMethod");
      CFDataRef v8 = SecPolicyCreate(@"1.2.840.113635.100.1.70", @"AppleLegacyPushService", v6);
    }

    else
    {
      CFDataRef v8 = 0LL;
    }

    CFRelease(v4);
  }

  else
  {
    CFDataRef v8 = 0LL;
    CFDictionaryRef v6 = v4;
  }

  CFRelease(v6);
  return v8;
}

void *SecPolicyCreateAppleTVOSApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10LL);
    add_ku(v1, 1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProd, 0LL);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProdQA, 0LL);
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.71", @"AppleTVApplicationSigning", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleGeoTrustServerAuthCommon( const void *a1, const void *a2, const void *a3, void *a4, void *a5)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDictionaryRef v11 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (!a1) {
    goto LABEL_13;
  }
  CFDictionaryAddValue(v11, @"SSLHostname", a1);
  add_eku(v11, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning((uint64_t)a3))
  {
    SecPolicyAddAnchorSHA256Options(v11, GeoTrust_Global_CA_sha256);
    add_element(v11, @"IntermediateCountry", @"US");
    add_element(v11, @"IntermediateOrganization", @"Apple Inc.");
    if (!SecPolicyAddChainLengthOptions(v11, 3LL))
    {
LABEL_13:
      int v12 = 0LL;
      goto LABEL_11;
    }

    if (a5)
    {
      add_leaf_prod_qa_element(v11, a4, a5);
      add_leaf_prod_qa_markers_value_string(v11, a4, a5);
    }

    else
    {
      add_element(v11, @"LeafMarkerOid", a4);
      add_leaf_marker_value_string(v11, @"1.2.840.113635.100.6.48.1", a4);
    }
  }

  if (!SecPolicyRemoveWeakHashOptions(v11) || !SecPolicyAddStrongKeySizeOptions(v11)) {
    goto LABEL_13;
  }
  int v12 = SecPolicyCreate(a2, a3, v11);
LABEL_11:
  CFRelease(v11);
  return v12;
}

void *SecPolicyCreateAppleSecureIOStaticAsset()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.10"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.50"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.75", @"SecureIOStaticAsset", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleWarsaw()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.14"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.29"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.76", @"Warsaw", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFArray *SecPolicyCreateAppleAppTransportSecurity()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  if (SecPolicyAddStrongKeySizeOptions(Mutable))
  {
    CFDateRef v2 = CFArrayCreateMutable(0LL, 5LL, MEMORY[0x189605228]);
    CFDataRef v3 = v2;
    if (v2)
    {
      CFArrayAppendValue(v2, @"SignatureDigestMD2");
      CFArrayAppendValue(v3, @"SignatureDigestMD4");
      CFArrayAppendValue(v3, @"SignatureDigestMD5");
      CFArrayAppendValue(v3, @"SignatureDigestSHA1");
      CFArrayAppendValue(v3, @"SignatureDigestSHA224");
      add_element(v1, @"SignatureHashAlgorithms", v3);
      CFDataRef v3 = (__CFArray *)SecPolicyCreate(@"1.2.840.113635.100.1.80", @"ATS", v1);
    }
  }

  else
  {
    CFDataRef v3 = 0LL;
  }

  CFRelease(v1);
  return v3;
}

void *SecPolicyCreateMacOSProfileApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_element(v1, @"ExtendedKeyUsage", @"1.3.6.1.5.5.7.3.3");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.12");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.7");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.13");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.22");
    CFDictionaryAddValue(v1, @"Revocation", @"AnyRevocationMethod");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.81", @"macOSProfileApplicationSigning", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileSoftwareUpdate()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3LL)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.18");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.57.2");
  if (SecPolicyAddStrongKeySizeOptions(v1)) {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.82", @"MobileSoftwareUpdate", v1);
  }
  else {
LABEL_10:
  }
    CFDateRef v2 = 0LL;
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMobileAssetDevelopment()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.18");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.55.1");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.83", @"MobileAsset", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiPhoneVPNApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, @"SubjectCommonNameTEST", @"Apple iPhone OS Application Signing");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.6.1");
  }

  else
  {
    CFDictionaryAddValue(v1, @"SubjectCommonName", @"Apple iPhone OS Application Signing");
  }

  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.6");
  add_eku(v1, 0LL);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, @"IssuerCommonName", @"Apple iPhone Certification Authority");
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.86", @"iPhoneVPNApplicationSigning", v1);
  }

  else
  {
LABEL_10:
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateiAPSWAuthWithExpiration(int a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDataRef v3 = Mutable;
  if (a1) {
    SecPolicyAddBasicX509Options(Mutable);
  }
  else {
    SecPolicyAddBasicCertOptions(Mutable);
  }
  if (SecPolicyAddChainLengthOptions(v3, 2LL))
  {
    add_element(v3, @"LeafMarkerOidWithoutValueCheck", @"1.2.840.113635.100.6.59.1");
    CFDictionaryAddValue(v3, @"RevocationDbIgnored", (const void *)*MEMORY[0x189604DE8]);
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.87", @"iAPSWAuth", v3);
  }

  else
  {
    CFDataRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateDemoDigitalCatalogSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL))
  {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.60");
    add_element(v1, @"IssuerCommonName", @"DemoUnit CA");
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.88", @"DemoCatalog", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleAssetReceipt()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.10"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.61"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.89", @"AssetReceipt", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleDeveloperIDPlusTicket()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.30"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.90", @"DeveloperIDPlusTicket", v1);
  }

  else
  {
    CFDateRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleFDRProvisioning()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFDateRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.91", @"FDRProvisioning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateAppleKeyTransparency(void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDataRef v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3LL)
    && (add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.3"),
        add_leaf_marker_value_string(v3, @"1.2.840.113635.100.12.4", a1),
        SecPolicyAddStrongKeySizeOptions(v3))
    && SecPolicyRemoveWeakHashOptions(v3))
  {
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.93", @"KT", v3);
  }

  else
  {
    CFDataRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

void *SecPolicyCreateAlisha()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  uint64_t valuePtr = 256LL;
  uint64_t valuePtr = (uint64_t)CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
  if (valuePtr
    && (CFDictionaryRef v2 = CFDictionaryCreate( 0LL,  (const void **)&kSecAttrKeyTypeEC,  (const void **)&valuePtr,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250])) != 0LL)
  {
    CFDictionaryRef v3 = v2;
    add_element(v1, @"KeySize", v2);
    if (SecPolicyRemoveWeakHashOptions(v1)) {
      CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.95", @"Alisha", v1);
    }
    else {
      CFDataRef v4 = 0LL;
    }
    CFRelease(v1);
  }

  else
  {
    CFDataRef v4 = 0LL;
    CFDictionaryRef v3 = v1;
  }

  CFRelease(v3);
  CFDictionaryRef v5 = (const void *)valuePtr;
  if (valuePtr)
  {
    uint64_t valuePtr = 0LL;
    CFRelease(v5);
  }

  return v4;
}

void *SecPolicyCreateMeasuredBootPolicySigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.24.17"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.26.6.1"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.96", @"MeasuredBootPolicySigning", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePayQRCodeEncryption()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.22"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.13.3"),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.97", @"ApplePayQRCodeEncryption", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateApplePayQRCodeSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.22"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.12"),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.98", @"ApplePayQRCodeSigning", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleAccessoryUpdateSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3LL) || !SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.9");
  if (CFPreferencesGetAppBooleanValue(@"AllowAccessoryUpdateSigningBeta", @"com.apple.security", 0LL)) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.10");
  }
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.99", @"AccessoryUpdateSigning", v1);
  }

  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateEscrowServiceIdKeySigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Escrow Service ID Key");
  if (SecPolicyAddChainLengthOptions(v1, 2LL)) {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.100", @"AppleEscrowServiceIdKeySigning", v1);
  }
  else {
    CFDictionaryRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreatePCSEscrowServiceIdKeySigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, @"SubjectCommonName", @"Effaceable Service ID Key");
  if (SecPolicyAddChainLengthOptions(v1, 2LL)) {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.101", @"ApplePCSEscrowServiceIdKeySigning", v1);
  }
  else {
    CFDictionaryRef v2 = 0LL;
  }
  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateDeveloperIDInstaller()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.6"),
        add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.14"),
        add_element(v1, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.13"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.103", @"DeveloperIDInstaller", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateMacAppStoreInstaller()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3LL)
    && (add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1"),
        add_leaf_prod_qa_element(v1, @"1.2.840.113635.100.6.1.10", @"1.2.840.113635.100.6.1.10.1"),
        add_element(v1, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.10"),
        add_element(v1, @"Revocation", @"AnyRevocationMethod"),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.104", @"MacAppStoreInstaller", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateAppleCHIPUpdateSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3LL) || !SecPolicyAddAppleAnchorOptions(v1)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.25");
  if (CFPreferencesGetAppBooleanValue(@"AllowCHIPUpdateSigningBeta", @"com.apple.security", 0LL)) {
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.26");
  }
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, @"Revocation", @"AnyRevocationMethod");
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.109", @"CHIPUpdateSigning", v1);
  }

  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateOrderBundleSigner(void *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDictionaryRef v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3) && SecPolicyAddChainLengthOptions(v3, 3LL))
  {
    add_leaf_marker_value_string(v3, @"1.2.840.113635.100.14.2", a1);
    add_element(v3, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.1");
    add_element(v3, @"ExtendedKeyUsage", @"1.2.840.113635.100.4.19");
    add_element(v3, @"Revocation", @"AnyRevocationMethod");
    CFDataRef v4 = SecPolicyCreate(@"1.2.840.113635.100.1.110", @"OrderBundleSigner", v3);
  }

  else
  {
    CFDataRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

__CFDictionary *SecPolicyCreateQiSigning()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.111", @"QiSigning", v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }

  return result;
}

void *SecPolicyCreateAppleXROSApplicationSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3LL) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, @"IntermediateMarkerOid", _oidAppleIntmMarkerAppleWWDR, 10LL);
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.36");
    add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.6.1.36.1");
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.113", @"AppleXROSApplicationSigning", v1);
  }

  else
  {
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void *SecPolicyCreateEDPSigning()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFOptionFlags v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3LL)) {
    goto LABEL_10;
  }
  add_element(v1, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.17");
  add_element(v1, @"LeafMarkerOid", @"1.2.840.113635.100.12.47");
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    CFDictionaryAddValue(v1, @"NoNetworkAccess", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryRef v2 = SecPolicyCreate(@"1.2.840.113635.100.1.114", @"EDPSigning", v1);
  }

  else
  {
LABEL_10:
    CFDictionaryRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateDCAttestation()
{
  SecPolicyRef result = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (result)
  {
    CFOptionFlags v1 = result;
    SecPolicyAddBasicCertOptions(result);
    CFDictionaryRef v2 = (const void *)*MEMORY[0x189604DE8];
    CFDictionaryAddValue(v1, @"ValidLeaf", (const void *)*MEMORY[0x189604DE8]);
    CFDictionaryAddValue(v1, @"NoNetworkAccess", v2);
    CFDictionaryRef v3 = SecPolicyCreate(@"1.2.840.113635.100.1.119", @"DCAttestation", v1);
    CFRelease(v1);
    return (__CFDictionary *)v3;
  }

  return result;
}

BOOL SecPolicyAddAppleAnchorOptions(const __CFDictionary *a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    add_element(a1, @"AnchorApple", Mutable);
    CFRelease(Mutable);
  }

  return Mutable != 0LL;
}

BOOL SecPolicyAddChainLengthOptions(__CFDictionary *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
  if (v3)
  {
    CFDictionaryAddValue(a1, @"ChainLength", v3);
    CFRelease(v3);
  }

  return v3 != 0LL;
}

void add_oid(const __CFDictionary *a1, const void *a2, UInt8 *bytes, CFIndex length)
{
  if ((length & 0x8000000000000000LL) == 0)
  {
    CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, length);
    if (v6)
    {
      CFDataRef v7 = v6;
      add_element(a1, a2, v6);
      CFRelease(v7);
    }
  }

void add_leaf_marker_value_string(const __CFDictionary *a1, void *a2, void *a3)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  if (a3)
  {
    values = a3;
    keys[0] = a2;
    CFDictionaryRef v4 = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    add_element(a1, @"LeafMarkerOid", v4);
    if (v4) {
      CFRelease(v4);
    }
  }

  else
  {
    add_element(a1, @"LeafMarkerOid", a2);
  }

void add_leaf_prod_qa_element(const __CFDictionary *a1, const void *a2, const void *a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  unint64_t Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"LeafMarkersProdAndQA");
  if (Value)
  {
    CFDataRef v8 = Value;
    CFDataRef v9 = (void *)CFDictionaryGetValue(Value, @"ProdMarker");
    CFDictionaryRef v10 = (void *)CFDictionaryGetValue(v8, @"QAMarker");
    if (v9
      && (CFTypeID v11 = CFGetTypeID(v9), v11 == CFArrayGetTypeID())
      && v10
      && (CFTypeID v12 = CFGetTypeID(v10), v12 == CFArrayGetTypeID()))
    {
      CFRetain(v9);
      CFRetain(v10);
    }

    else
    {
      CFIndex v13 = (const CFArrayCallBacks *)MEMORY[0x189605228];
      uint64_t v14 = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
      CFDataRef v15 = CFArrayCreateMutable(0LL, 0LL, v13);
      CFArrayAppendValue(v14, v9);
      CFArrayAppendValue(v15, v10);
      CFDictionaryRef v10 = v15;
      CFDataRef v9 = v14;
    }

    CFArrayAppendValue((CFMutableArrayRef)v9, a2);
    CFArrayAppendValue((CFMutableArrayRef)v10, a3);
    CFDictionaryAddValue(Mutable, @"ProdMarker", v9);
    CFDictionaryAddValue(Mutable, @"QAMarker", v10);
    if (v9) {
      CFRelease(v9);
    }
    if (v10) {
      CFRelease(v10);
    }
  }

  else
  {
    CFDictionaryAddValue(Mutable, @"ProdMarker", a2);
    CFDictionaryAddValue(Mutable, @"QAMarker", a3);
  }

  CFDictionarySetValue(a1, @"LeafMarkersProdAndQA", Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

BOOL SecPolicyAddAnchorSHA256Options(const __CFDictionary *a1, const UInt8 *a2)
{
  CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], a2, 32LL);
  if (v3)
  {
    add_element(a1, @"AnchorSHA256", v3);
    CFRelease(v3);
  }

  return v3 != 0LL;
}

uint64_t requireUATPinning(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!os_variant_allows_internal_security_policies())
  {
    CFDictionaryRef v4 = (os_log_s *)secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      CFDictionaryRef v5 = "could not disable pinning: not an internal release";
LABEL_7:
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
    }

    return 1LL;
  }

  CFDictionaryRef v2 = CFStringCreateWithFormat(0LL, 0LL, @"AppleServerAuthenticationNoPinning%@", a1);
  if (!v2) {
    return 1LL;
  }
  CFDataRef v3 = v2;
  if (!CFPreferencesGetAppBooleanValue(v2, @"com.apple.security", 0LL))
  {
    CFDataRef v7 = (os_log_s *)secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFDataRef v9 = v3;
      _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "could not disable pinning: %@ not true", buf, 0xCu);
    }

    CFRelease(v3);
    if (CFPreferencesGetAppBooleanValue(@"AppleServerAuthenticationNoPinning", @"com.apple.security", 0LL)) {
      return 0LL;
    }
    CFDictionaryRef v4 = (os_log_s *)secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      CFDictionaryRef v5 = "could not disable pinning: AppleServerAuthenticationNoPinning not true";
      goto LABEL_7;
    }

    return 1LL;
  }

  CFRelease(v3);
  return 0LL;
}

void add_leaf_prod_qa_markers_value_string(const __CFDictionary *a1, void *a2, void *a3)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v10 = @"1.2.840.113635.100.6.48.1";
  keys[0] = @"1.2.840.113635.100.6.48.1";
  CFDataRef v8 = a3;
  values = a2;
  CFDictionaryRef v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
  CFDictionaryRef v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
  CFDictionaryRef v6 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFDictionaryRef v7 = CFDictionaryCreate(0LL, (const void **)&v10, (const void **)&v8, 1LL, v4, v5);
  add_leaf_prod_qa_element(a1, v6, v7);
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
}

void add_leaf_marker_value(const __CFDictionary *a1, uint64_t a2, void *a3)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  CFIndex v4 = *(void *)(a2 + 8);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    CFDictionaryRef v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    if (a3)
    {
      CFStringRef v7 = SecDERItemCopyOIDDecimalRepresentation((const __CFAllocator *)*MEMORY[0x189604DB0], (unsigned __int8 **)a2);
      values = a3;
      keys[0] = (void *)v7;
      CFDictionaryRef v8 = CFDictionaryCreate( v6,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      if (v7) {
        CFRelease(v7);
      }
    }

    else
    {
      CFDictionaryRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], *(const UInt8 **)a2, v4);
    }

    add_element(a1, @"LeafMarkerOid", v8);
    if (v8) {
      CFRelease(v8);
    }
  }

void SecPolicySetOid(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf)
  {
    CFIndex v4 = *(const void **)(a1 + 16);
    CFRetain(cf);
    *(void *)(a1 + 16) = cf;
    if (v4) {
      CFRelease(v4);
    }
  }

void *SecPolicyCreatePrivacyConfigurationProfileSigner(int a1, int a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  CFDictionaryRef v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v5))
  {
    BOOL v6 = SecPolicyAddChainLengthOptions(v5, 3LL);
    CFStringRef v7 = 0LL;
    if ((a1 | a2) == 1 && v6)
    {
      if (a1) {
        add_eku(v5, oidAppleExtendedKeyUsageProfileSigning);
      }
      if (a2) {
        add_eku(v5, oidAppleExtendedKeyUsageQAProfileSigning);
      }
      add_element(v5, @"IntermediateMarkerOid", @"1.2.840.113635.100.6.2.3");
      CFStringRef v7 = SecPolicyCreate(@"1.2.840.113635.100.1.25", @"AppleProfileSigner", v5);
    }
  }

  else
  {
    CFStringRef v7 = 0LL;
  }

  CFRelease(v5);
  return v7;
}

CFStringRef isAppleOid(const __CFString *a1)
{
  SecPolicyRef result = SecCertificateIsOidString(a1);
  if ((_DWORD)result) {
    return (const __CFString *)(CFStringHasPrefix(a1, @"1.2.840.113635") != 0);
  }
  return result;
}

void add_ats_options_from_dict(const __CFDictionary *a1, const __CFString *a2, CFDictionaryRef theDict)
{
  if (a2 && theDict)
  {
    unint64_t Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSPinnedDomains");
    if (Value)
    {
      BOOL v6 = Value;
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFDictionaryGetTypeID())
      {
        CFMutableArrayRef v8 = parseNSPinnedDomains(v6, a2, (uint64_t)@"NSPinnedLeafIdentities");
        if (v8) {
          add_element(a1, @"LeafSPKISHA256", v8);
        }
        CFMutableArrayRef v9 = parseNSPinnedDomains(v6, a2, (uint64_t)@"NSPinnedCAIdentities");
        if (v9) {
          add_element(a1, @"CAspkiSHA256", v9);
        }
      }
    }

    SecPolicyReconcilePinningRequiredIfInfoSpecified(a1);
  }

CFMutableArrayRef parseNSPinnedDomains(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  uint64_t v11 = 0LL;
  CFTypeID v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  CFIndex Length = CFStringGetLength(a2);
  CFIndex v8 = Length - 1;
  if (Length >= 1 && CFStringGetCharacterAtIndex(a2, v8) == 46)
  {
    v15.location = 0LL;
    v15.CFIndex length = v8;
    a2 = CFStringCreateWithSubstring(0LL, a2, v15);
    if (!a2) {
      goto LABEL_9;
    }
  }

  else if (a2)
  {
    CFRetain(a2);
  }

  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __parseNSPinnedDomains_block_invoke;
  unint64_t v10[3] = &unk_189674380;
  UInt8 v10[4] = &v11;
  void v10[5] = a2;
  void v10[6] = a3;
  void v10[7] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_11628, v10);
  if (a2) {
    CFRelease(a2);
  }
LABEL_9:
  if (!*((_BYTE *)v12 + 24) && Mutable)
  {
    CFRelease(Mutable);
    CFMutableArrayRef Mutable = 0LL;
  }

  _Block_object_dispose(&v11, 8);
  return Mutable;
}

void __parseNSPinnedDomains_block_invoke(uint64_t a1, const __CFString *cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFDictionaryGetTypeID())
        {
          if (CFStringCompare(cf, *(CFStringRef *)(a1 + 40), 1uLL))
          {
            CFMutableArrayRef v9 = *(const __CFString **)(a1 + 40);
            if (!v9) {
              return;
            }
            CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 40));
            if (!Length) {
              return;
            }
            CFIndex v11 = Length;
            CFIndex location = CFStringFind(v9, @".", 0LL).location;
            if (location == -1) {
              return;
            }
            if (location >= v11 - 1) {
              return;
            }
            v20.CFIndex location = location + 1;
            v20.CFIndex length = v11 + ~location;
            uint64_t v13 = CFStringCreateWithSubstring(0LL, v9, v20);
            if (!v13) {
              return;
            }
            char v14 = v13;
            if (CFStringCompare(cf, v13, 1uLL))
            {
LABEL_19:
              CFRelease(v14);
              return;
            }
          }

          else
          {
            char v14 = 0LL;
          }

          unint64_t Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a3, *(const void **)(a1 + 48));
          if (Value)
          {
            int v16 = Value;
            *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
            CFTypeID v17 = CFGetTypeID(Value);
            if (v17 == CFArrayGetTypeID())
            {
              context[0] = MEMORY[0x1895F87A8];
              context[1] = 0x40000000LL;
              context[2] = __parseNSPinnedDomains_block_invoke_2;
              context[3] = &__block_descriptor_tmp_493;
              void context[4] = *(void *)(a1 + 56);
              v19.CFIndex length = CFArrayGetCount(v16);
              v19.CFIndex location = 0LL;
              CFArrayApplyFunction(v16, v19, (CFArrayApplierFunction)apply_block_1_11630, context);
            }
          }

          if (v14) {
            goto LABEL_19;
          }
        }
      }
    }
  }

uint64_t apply_block_2_11628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __parseNSPinnedDomains_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      unint64_t Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"SPKI-SHA256-BASE64");
      if (Value)
      {
        CFTypeID v6 = Value;
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          CFDataFromBase64CFString = (const void *)CreateCFDataFromBase64CFString(v6);
          if (CFDataFromBase64CFString)
          {
            CFMutableArrayRef v9 = CFDataFromBase64CFString;
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), CFDataFromBase64CFString);
            CFRelease(v9);
          }
        }
      }
    }
  }

uint64_t apply_block_1_11630(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t CreateCFDataFromBase64CFString(const __CFString *a1)
{
  uint64_t v4 = 0LL;
  CFDictionaryRef v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  if (a1)
  {
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 0x40000000LL;
    void v3[2] = __CreateCFDataFromBase64CFString_block_invoke;
    v3[3] = &unk_189674338;
    void v3[4] = &v4;
    CFStringPerformWithCStringAndLength(a1, (uint64_t)v3);
    uint64_t v1 = v5[3];
  }

  else
  {
    uint64_t v1 = 0LL;
  }

  _Block_object_dispose(&v4, 8);
  return v1;
}

void __CreateCFDataFromBase64CFString_block_invoke(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  CFDataRef v3 = 0LL;
  if (a2 && a3)
  {
    unint64_t v5 = a3 >> 2;
    if ((a3 & 3) != 0) {
      ++v5;
    }
    if (!v5)
    {
      free(0LL);
      return;
    }

    unint64_t v8 = 3 * v5;
    CFDataRef v3 = (UInt8 *)malloc(3 * v5);
    if (v3)
    {
      CFMutableArrayRef v9 = SecBase64Decode_(a2, a3, v3, v8, 0, &v11, &v10);
      if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) >= 0x8000000000000002LL) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFDataCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  v3,  (CFIndex)v9);
      }
    }
  }

  free(v3);
}

__CFBundle *__getNSPinnedIdentitiesForHostName_block_invoke()
{
  SecPolicyRef result = CFBundleGetMainBundle();
  if (!result) {
    goto LABEL_7;
  }
  SecPolicyRef result = CFBundleGetInfoDictionary(result);
  if (!result) {
    goto LABEL_7;
  }
  SecPolicyRef result = (__CFBundle *)CFDictionaryGetValue(result, @"NSAppTransportSecurity");
  if (!result
    || (v1 = result, CFTypeID v2 = CFGetTypeID(result),
                     SecPolicyRef result = (__CFBundle *)CFDictionaryGetTypeID(),
                     (__CFBundle *)v2 != result)
    || (SecPolicyRef result = (__CFBundle *)CFDictionaryGetValue(v1, @"NSPinnedDomains"),
        (getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict = (uint64_t)result) == 0)
    || (CFTypeID v3 = CFGetTypeID(result), result = (__CFBundle *)CFDictionaryGetTypeID(), (__CFBundle *)v3 != result))
  {
LABEL_7:
    getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict = 0LL;
  }

  return result;
}

CFTypeID __SecPolicyAddPinningRequiredIfInfoSpecified_block_invoke()
{
  CFTypeID result = (CFTypeID)CFBundleGetMainBundle();
  if (result)
  {
    CFTypeID result = (CFTypeID)CFBundleGetInfoDictionary((CFBundleRef)result);
    if (result)
    {
      CFTypeID result = (CFTypeID)CFDictionaryGetValue((CFDictionaryRef)result, @"SecTrustPinningRequired");
      if (result)
      {
        uint64_t v1 = (const __CFBoolean *)result;
        CFTypeID v2 = CFGetTypeID((CFTypeRef)result);
        CFTypeID result = CFBooleanGetTypeID();
        if (v2 == result)
        {
          CFTypeID result = CFBooleanGetValue(v1);
          if ((_DWORD)result) {
            SecPolicyAddPinningRequiredIfInfoSpecified_hasPinningRequiredKey = 1;
          }
        }
      }

      SecPolicyAddPinningRequiredIfInfoSpecified_CFTypeID result = 1;
    }
  }

  return result;
}

SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef hostname)
{
  return (SecPolicyRef)SecPolicyCreateSSL_internal(server, hostname, 0, 0LL);
}

void *SecPolicyCreateAppleAST2Service(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.42",  @"AST2",  (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProd,  (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProdQA);
}

void *SecPolicyCreateAppleEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.43",  @"Escrow",  (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProd,  (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProdQA);
}

void *SecPolicyCreateAppleFMiPService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.44",  @"FMiP",  (uint64_t)&oidAppleCertExtFMiPServerAuthProd,  (uint64_t)&oidAppleCertExtFMiPServerAuthProdQA);
}

void *SecPolicyCreateAppleMMCSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.45",  @"MMCS",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProdQA);
}

void *SecPolicyCreateAppleGSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.46",  @"GS",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationGS,  0LL);
}

void *SecPolicyCreateApplePPQService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.47",  @"PPQ",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProdQA);
}

void *SecPolicyCreateAppleIDSServiceContext(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.68",  @"IDS",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProdQA);
}

void *SecPolicyCreateApplePushService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.69",  @"APN",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProdQA);
}

void *SecPolicyCreateAppleiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon( a1,  @"1.2.840.113635.100.1.77",  @"iCloudSetup",  (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProd,  (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA);
}

void *SecPolicyCreateParakeetService(const void *a1, const void *a2)
{
  return SecPolicyCreateParakeetCommon(a1, a2, @"1.2.840.113635.100.1.118", @"ParakeetService");
}

void *SecPolicyCreateMobileStoreSigner()
{
  return CreateMobileStoreSigner(0);
}

void *SecPolicyCreateTestMobileStoreSigner()
{
  return CreateMobileStoreSigner(1);
}

void *SecPolicyCreateAppleExternalDeveloper()
{
  return SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
}

void *SecPolicyCreateAppleCompatibilityEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon( a1,  @"1.2.840.113635.100.1.73",  @"Escrow",  @"1.2.840.113635.100.6.27.7.2",  @"1.2.840.113635.100.6.27.7.1");
}

void *SecPolicyCreateAppleCompatibilityMMCSService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon( a1,  @"1.2.840.113635.100.1.74",  @"MMCS",  @"1.2.840.113635.100.6.27.11.2",  @"1.2.840.113635.100.6.27.11.1");
}

void *SecPolicyCreateAppleCompatibilityiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon( a1,  @"1.2.840.113635.100.1.78",  @"iCloudSetup",  @"1.2.840.113635.100.6.27.15.2",  @"1.2.840.113635.100.6.27.15.1");
}

void *SecPolicyCreateiAPSWAuth()
{
  return SecPolicyCreateiAPSWAuthWithExpiration(0);
}

void *SecPolicyCreateMacDistributionInstaller()
{
  return SecPolicyCreateApplePinned( @"MacDistributionInstaller",  @"1.2.840.113635.100.6.2.1",  @"1.2.840.113635.100.6.1.8");
}

void *SecPolicyCreateParakeetSigning()
{
  return SecPolicyCreateParakeetCommon(0LL, 0LL, @"1.2.840.113635.100.1.116", @"ParakeetSigning");
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  if (!policyRef) {
    return 0LL;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    CFTypeRef v3 = CFRetain(*((CFTypeRef *)policyRef + 2));
    uint64_t v4 = (const __CFDictionary *)*((void *)policyRef + 4);
    if (v4)
    {
      unint64_t v5 = @"SSLHostname";
      if (CFDictionaryContainsKey(v4, @"SSLHostname")
        || (unint64_t v5 = @"EAPTrustedServerNames",
            CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), @"EAPTrustedServerNames")))
      {
        CFDictionarySetValue(Mutable, @"SecPolicyOid", v3);
      }

      else
      {
        unint64_t v5 = @"Email";
        int v13 = CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), @"Email");
        CFDictionarySetValue(Mutable, @"SecPolicyOid", v3);
        if (!v13) {
          goto LABEL_13;
        }
      }

      uint64_t v6 = (const __CFDictionary *)*((void *)policyRef + 4);
      if (!v6) {
        goto LABEL_13;
      }
      unint64_t Value = CFDictionaryGetValue(v6, v5);
      if (!Value) {
        goto LABEL_13;
      }
      unint64_t v8 = Value;
      CFMutableArrayRef v9 = @"SecPolicyName";
      int v10 = Mutable;
    }

    else
    {
      CFMutableArrayRef v9 = @"SecPolicyOid";
      int v10 = Mutable;
      unint64_t v8 = v3;
    }

    CFDictionarySetValue(v10, v9, v8);
LABEL_13:
    CFIndex v11 = (const void *)*((void *)policyRef + 3);
    if (v11)
    {
      CFRetain(v11);
      if (CFEqual(v11, @"sslClient") || CFEqual(v11, @"ipsecClient") || CFEqual(v11, @"eapClient")) {
        CFDictionarySetValue(Mutable, @"SecPolicyClient", (const void *)*MEMORY[0x189604DE8]);
      }
      CFRelease(v11);
    }

    CFRelease(v3);
  }

  return Mutable;
}

uint64_t SecPolicyGetOidString(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t SecPolicyGetName(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void SecPolicySetOptionsValue_internal(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    uint64_t v6 = *(const __CFDictionary **)(a1 + 32);
    if (v6)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v6);
    }

    else
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      if (!MutableCopy) {
        return;
      }
    }

    unint64_t v8 = *(const void **)(a1 + 32);
    if (v8)
    {
      *(void *)(a1 + 32) = 0LL;
      CFRelease(v8);
    }

    if (CFEqual(a2, @"TemporalValidity") && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE0])) {
      CFDictionaryRemoveValue(MutableCopy, a2);
    }
    else {
      CFDictionarySetValue(MutableCopy, a2, a3);
    }
    CFMutableArrayRef v9 = *(const void **)(a1 + 32);
    if (v9) {
      CFRelease(v9);
    }
    *(void *)(a1 + 32) = MutableCopy;
  }

CFMutableArrayRef SecPolicyXPCArrayCopyArray(void *a1, __CFString **a2)
{
  if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9220])
  {
    SecError(-50, a2, @"policies xpc value is not an array");
    return 0LL;
  }

  unint64_t count = xpc_array_get_count(a1);
  unint64_t v4 = count;
  if (count >= 0x7FFFFFFFFFFFFFFFLL)
  {
    SecError(-108, a2, @"failed to create CFArray of capacity %zu", count);
    return 0LL;
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], count, MEMORY[0x189605228]);
  if (!Mutable)
  {
    SecError(-108, a2, @"failed to create CFArray of capacity %zu", v4);
    return Mutable;
  }

  if (v4)
  {
    size_t v6 = 0LL;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(a1, v6);
      if (!value)
      {
        CFTypeID v21 = @"policy xpc value is NULL";
        goto LABEL_35;
      }

      unint64_t v8 = value;
      if (MEMORY[0x186E0087C]() != MEMORY[0x1895F9220])
      {
        CFTypeID v21 = @"policy xpc value is not an array";
LABEL_33:
        int v22 = -26275;
        goto LABEL_36;
      }

      if (xpc_array_get_count(v8) <= 1)
      {
        CFTypeID v21 = @"policy xpc array count < 2";
        goto LABEL_33;
      }

      xpc_array_get_value(v8, 0LL);
      CFMutableArrayRef v9 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v9)
      {
        uint64_t v25 = 0LL;
        CFTypeID v21 = @"failed to convert xpc policy[0]=%@ to CFString";
LABEL_35:
        int v22 = -50;
LABEL_36:
        SecError(v22, a2, v21, v25);
        goto LABEL_37;
      }

      int v10 = v9;
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 != CFStringGetTypeID())
      {
        SecError(-50, a2, @"failed to convert xpc policy[0]=%@ to CFString", v10);
        goto LABEL_41;
      }

      xpc_array_get_value(v8, 1uLL);
      CFTypeID v12 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v12)
      {
        SecError(-50, a2, @"failed to convert xpc policy[1]=%@ to CFDictionary", 0LL);
LABEL_41:
        CFIndex v24 = v10;
LABEL_42:
        CFRelease(v24);
LABEL_37:
        CFRelease(Mutable);
        return 0LL;
      }

      int v13 = v12;
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 != CFDictionaryGetTypeID())
      {
        SecError(-50, a2, @"failed to convert xpc policy[1]=%@ to CFDictionary", v13);
        CFRelease(v10);
        CFIndex v24 = v13;
        goto LABEL_42;
      }

      CFRange v15 = CFStringFind(v10, @"++", 0LL);
      if (v15.length != 2) {
        break;
      }
      v27.CFIndex location = 0LL;
      v27.CFIndex length = v15.location;
      CFStringRef v16 = CFStringCreateWithSubstring(0LL, v10, v27);
      CFStringRef v17 = v16;
      if (v16)
      {
        CFRetain(v16);
        CFRelease(v17);
      }

      if (v15.location + 2 >= CFStringGetLength(v10))
      {
        CFStringRef v19 = 0LL;
      }

      else
      {
        v28.CFIndex length = CFStringGetLength(v10) - v15.location - 2;
        v28.CFIndex location = v15.location + 2;
        CFStringRef v18 = CFStringCreateWithSubstring(0LL, v10, v28);
        CFStringRef v19 = v18;
        if (v18)
        {
          CFRetain(v18);
          CFRelease(v19);
        }
      }

      CFRange v20 = SecPolicyCreate(v17, v19, v13);
      if (!v20) {
        SecError(-26275, a2, @"Failed to create policy");
      }
      CFRelease(v10);
      if (v17) {
        CFRelease(v17);
      }
      if (v19) {
        goto LABEL_26;
      }
LABEL_27:
      CFRelease(v13);
      if (!v20) {
        goto LABEL_37;
      }
      CFArraySetValueAtIndex(Mutable, v6, v20);
      CFRelease(v20);
      if (v4 == ++v6) {
        return Mutable;
      }
    }

    SecError(-50, a2, @"failed to convert combined %@ to name and oid", v10);
    CFRange v20 = 0LL;
    CFStringRef v19 = v10;
LABEL_26:
    CFRelease(v19);
    goto LABEL_27;
  }

  return Mutable;
}

void deserializePolicy(const void *a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"SecPolicyOid");
      if (Value)
      {
        size_t v6 = Value;
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          unint64_t v8 = CFDictionaryGetValue((CFDictionaryRef)a1, @"policyOptions");
          if (v8)
          {
            CFMutableArrayRef v9 = v8;
            CFTypeID v10 = CFGetTypeID(v8);
            if (v10 == CFDictionaryGetTypeID())
            {
              CFTypeID v11 = CFDictionaryGetValue((CFDictionaryRef)a1, @"SecPolicyPolicyName");
              CFTypeID v12 = SecPolicyCreate(v6, v11, v9);
              if (v12)
              {
                int v13 = v12;
                CFArrayAppendValue(a2, v12);
                CFRelease(v13);
              }
            }
          }
        }
      }
    }
  }

void SecPolicySetSHA256Pins(uint64_t a1, const void *a2, const void *a3)
{
  if (a1)
  {
    size_t v6 = *(__CFDictionary **)(a1 + 32);
    if (!v6)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      if (!Mutable) {
        return;
      }
      size_t v6 = Mutable;
      *(void *)(a1 + 32) = Mutable;
    }

    CFDictionaryRemoveValue(v6, @"LeafSPKISHA256");
    if (a2) {
      add_element(v6, @"LeafSPKISHA256", a2);
    }
    CFDictionaryRemoveValue(v6, @"CAspkiSHA256");
    if (a3) {
      add_element(v6, @"CAspkiSHA256", a3);
    }
  }

uint64_t SecPolicySetSSLHostname(uint64_t a1, const void *a2)
{
  if (a1) {
    BOOL v2 = a2 == 0LL;
  }
  else {
    BOOL v2 = 1;
  }
  uint64_t v3 = !v2;
  if (!v2) {
    SecPolicySetOptionsValue_internal(a1, @"SSLHostname", a2);
  }
  return v3;
}

uint64_t SecPolicySetATSPinning(uint64_t result, const __CFDictionary *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    unint64_t Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(result + 32), @"SSLHostname");
    CFTypeID result = 0LL;
    if (a2)
    {
      if (Value)
      {
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, *(CFDictionaryRef *)(v3 + 32));
          CFTypeID v7 = *(const void **)(v3 + 32);
          if (v7)
          {
            *(void *)(v3 + 32) = 0LL;
            CFRelease(v7);
          }

          add_ats_options_from_dict(MutableCopy, Value, a2);
          unint64_t v8 = *(const void **)(v3 + 32);
          if (v8) {
            CFRelease(v8);
          }
          *(void *)(v3 + 32) = MutableCopy;
          return 1LL;
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return result;
}

void *SecPolicyCreateVerifiedMark(const void *a1, const __CFData *a2)
{
  if (!a2) {
    return 0LL;
  }
  CFTypeID v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0LL;
  }
  size_t v6 = Mutable;
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(v4, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!v7)
  {
    CFRange v15 = 0LL;
    CFTypeID v14 = v6;
LABEL_14:
    CFRelease(v14);
    return v15;
  }

  unint64_t v8 = v7;
  SecPolicyAddBasicX509Options(v6);
  if (a1) {
    CFDictionaryAddValue(v6, @"SSLHostname", a1);
  }
  if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
  {
    add_element(v6, @"CertificatePolicy", @"1.3.6.1.4.1.53087.1.1");
    CFDictionaryAddValue(v6, @"SinglePurposeChainEKU", @"1.3.6.1.5.5.7.3.31");
    uint64_t BytePtr = CFDataGetBytePtr(a2);
    CFIndex Length = CFDataGetLength(a2);
    CFTypeID v11 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    if (v11)
    {
      CFTypeID v12 = CFDataGetBytePtr(a2);
      CFIndex v13 = CFDataGetLength(a2);
      CFTypeID v14 = SecSHA256DigestCreate(v4, (uint64_t)v12, v13);
      if (v14)
      {
        CFDictionaryAddValue(v8, @"sha1", v11);
        CFDictionaryAddValue(v8, @"sha256", v14);
        add_element(v6, @"MarkRepresentation", v8);
        CFRange v15 = SecPolicyCreate(@"1.2.840.113635.100.1.115", a1, v6);
      }

      else
      {
        CFRange v15 = 0LL;
      }
    }

    else
    {
      CFRange v15 = 0LL;
      CFTypeID v14 = 0LL;
    }
  }

  else
  {
    CFRange v15 = 0LL;
    CFTypeID v14 = 0LL;
    CFTypeID v11 = 0LL;
  }

  CFRelease(v6);
  CFRelease(v8);
  if (v11) {
    CFRelease(v11);
  }
  if (v14) {
    goto LABEL_14;
  }
  return v15;
}

BOOL SecPolicyCheckCertCriticalExtensions(uint64_t a1)
{
  return !a1 || *(_BYTE *)(a1 + 296) == 0;
}

BOOL SecPolicyCheckCertKeyUsage(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 384);
    if (!cf) {
      return 0;
    }
  }

  else
  {
    int v3 = 0;
    if (!cf) {
      return 0;
    }
  }

  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0LL;
      BOOL v8 = 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v7);
        if (keyusage_allows(v3, ValueAtIndex)) {
          break;
        }
        BOOL v8 = ++v7 < v6;
      }

      while (v6 != v7);
      return v8;
    }

    return 0;
  }

  return keyusage_allows(v3, cf);
}

BOOL keyusage_allows(int a1, CFTypeRef cf)
{
  if (!cf) {
    return 0LL;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFNumberGetTypeID()) {
    return 0LL;
  }
  int valuePtr = -1431655766;
  CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr) {
    return (valuePtr & ~a1) == 0;
  }
  else {
    return a1 == 0;
  }
}

BOOL SecPolicyCheckCertExtendedKeyUsageFiltered(uint64_t a1, const __CFString *a2, char a3)
{
  CFTypeID v5 = SecCertificateCopyExtendedKeyUsage(a1);
  if (!a2) {
    goto LABEL_8;
  }
  CFTypeID v6 = CFGetTypeID(a2);
  if (v6 != CFArrayGetTypeID())
  {
    BOOL v10 = isExtendedKeyUsageAllowed(v5, a2, a3);
    if (!v5) {
      return v10;
    }
    goto LABEL_10;
  }

  CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0LL;
    BOOL v10 = 1;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v9);
      if (isExtendedKeyUsageAllowed(v5, ValueAtIndex, a3)) {
        break;
      }
      BOOL v10 = ++v9 < v8;
    }

    while (v8 != v9);
  }

  else
  {
LABEL_8:
    BOOL v10 = 0;
  }

  if (v5) {
LABEL_10:
  }
    CFRelease(v5);
  return v10;
}

BOOL isExtendedKeyUsageAllowed(const __CFArray *a1, const __CFString *cf, char a3)
{
  if (!cf) {
    return 0LL;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID()) {
    return extendedkeyusage_allows(a1, (CFDataRef)cf, a3);
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFStringGetTypeID()) {
    return 0LL;
  }
  OidDataFromString = SecCertificateCreateOidDataFromString(0LL, cf);
  if (!OidDataFromString) {
    return 0LL;
  }
  BOOL v10 = OidDataFromString;
  BOOL v11 = extendedkeyusage_allows(a1, OidDataFromString, a3);
  CFRelease(v10);
  return v11;
}

BOOL extendedkeyusage_allows(CFArrayRef theArray, CFDataRef theData, char a3)
{
  if ((a3 & 1) != 0)
  {
    if (!theArray) {
      return CFDataGetLength(theData) == 0;
    }
    goto LABEL_12;
  }

  CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], _oidAnyExtendedKeyUsage, 4LL);
  if (v6)
  {
    CFDataRef v7 = v6;
    int v8 = CFEqual(theData, v6);
    CFRelease(v7);
    if (v8) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = theArray == 0LL;
    }
    if (!v9) {
      goto LABEL_12;
    }
    return 0LL;
  }

  if (!theArray) {
    return 0LL;
  }
LABEL_12:
  v10.CFIndex length = CFArrayGetCount(theArray);
  v10.CFIndex location = 0LL;
  return CFArrayContainsValue(theArray, v10, theData) != 0;
}

BOOL SecPolicyCheckCertExtendedKeyUsage(uint64_t a1, const __CFString *a2)
{
  return SecPolicyCheckCertExtendedKeyUsageFiltered(a1, a2, 1);
}

uint64_t SecPolicyCheckCertNonEmptySubject(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 192)) {
      return 1LL;
    }
    if ((SecCertificateIsCA(a1) & 1) == 0)
    {
      uint64_t v3 = *(void *)(a1 + 456);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 16)) {
          return 1LL;
        }
      }
    }
  }

  else
  {
    SecCertificateIsCA(0LL);
  }

  return 0LL;
}

uint64_t SecDNSIsTLD(CFStringRef theString)
{
  if (SecDNSIsTLD_onceToken != -1) {
    dispatch_once(&SecDNSIsTLD_onceToken, &__block_literal_global_11635);
  }
  if (!SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(theString);
  if (Length < 3) {
    return 1LL;
  }
  v6.CFIndex length = Length - 2;
  v6.CFIndex location = 2LL;
  uint64_t result = (uint64_t)CFStringCreateWithSubstring(0LL, theString, v6);
  if (result)
  {
    CFTypeID v4 = (const void *)result;
    uint64_t v5 = SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr();
    CFRelease(v4);
    return v5;
  }

  return result;
}

void *__SecDNSIsTLD_block_invoke()
{
  uint64_t result = dlopen("/System/Library/Frameworks/CFNetwork.framework/CFNetwork", 1);
  if (result)
  {
    uint64_t result = dlsym(result, "_CFHostIsDomainTopLevelForCertificatePolicy");
    SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr = result;
  }

  return result;
}

BOOL SecPolicyCheckCertSSLHostname(uint64_t a1, const __CFString *cf)
{
  if (!cf) {
    return 0LL;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()) {
    return 0LL;
  }
  uint64_t v5 = SecCertificateCopyDNSNamesFromSAN(a1);
  if (v5)
  {
    CFRange v6 = v5;
    CFIndex Count = CFArrayGetCount(v5);
    if (Count < 1)
    {
LABEL_8:
      CFRelease(v6);
    }

    else
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0LL;
      BOOL v10 = 1;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9);
        BOOL v10 = ++v9 < v8;
        if (v8 == v9) {
          goto LABEL_8;
        }
      }

      CFRelease(v6);
      if (v10) {
        return 1LL;
      }
    }
  }

  CFTypeRef v21 = 0LL;
  BOOL v12 = 0LL;
  if (convertIPAddress(cf, &v21))
  {
    CFTypeRef v13 = v21;
    if (v21)
    {
      CFTypeID v14 = SecCertificateCopyIPAddressDatas(a1);
      if (v14)
      {
        CFRange v15 = v14;
        CFIndex v16 = CFArrayGetCount(v14);
        if (v16 < 1)
        {
          BOOL v12 = 0LL;
        }

        else
        {
          CFIndex v17 = v16;
          uint64_t v18 = 1LL;
          do
          {
            CFStringRef v19 = CFArrayGetValueAtIndex(v15, v18 - 1);
            if (v19) {
              BOOL v12 = CFEqual(v13, v19) != 0;
            }
            else {
              BOOL v12 = 0LL;
            }
            if (v18 >= v17) {
              break;
            }
            ++v18;
          }

          while (!v12);
        }

        CFRelease(v15);
      }

      else
      {
        BOOL v12 = 0LL;
      }

      CFRelease(v13);
    }
  }

  return v12;
}

uint64_t SecDNSMatch(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = Length - 1;
  if (Length < 1) {
    return 0LL;
  }
  if (CFStringGetCharacterAtIndex(a1, v5) != 46)
  {
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, a1, @".");
    if (ArrayBySeparatingStrings) {
      goto LABEL_8;
    }
    return 0LL;
  }

  v24.CFIndex location = 0LL;
  v24.CFIndex length = v5;
  CFRange v6 = CFStringCreateWithSubstring(0LL, a1, v24);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, v6, @".");
  if (v6) {
    CFRelease(v6);
  }
  if (!ArrayBySeparatingStrings) {
    return 0LL;
  }
LABEL_8:
  CFArrayRef v9 = CFStringCreateArrayBySeparatingStrings(0LL, a2, @".");
  if (v9)
  {
    BOOL v10 = v9;
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    CFIndex v12 = CFArrayGetCount(v10);
    uint64_t v8 = Count == v12;
    if (Count == v12)
    {
      CFIndex v13 = CFArrayGetCount(ArrayBySeparatingStrings);
      if (v13 < 1)
      {
LABEL_19:
        uint64_t v8 = 1LL;
      }

      else
      {
        unint64_t v14 = v13;
        CFIndex v23 = v13 - 1;
        CFIndex v15 = v13;
        while (1)
        {
          CFIndex v16 = v15 - 1;
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v15 - 1);
          if (!ValueAtIndex
            || (v18 = ValueAtIndex, (CFStringRef v19 = (const __CFString *)CFArrayGetValueAtIndex(v10, v15 - 1)) == 0LL))
          {
LABEL_20:
            uint64_t v8 = 0LL;
            goto LABEL_25;
          }

          CFRange v20 = v19;
          if (CFEqual(v19, @"*")) {
            break;
          }
          CFRange v21 = CFStringFind(v20, @"*", 0LL);
          uint64_t v8 = 0LL;
          if (v21.location != -1 || v21.length) {
            goto LABEL_25;
          }
          if (CFStringCompare(v18, v20, 1uLL)) {
            goto LABEL_20;
          }
          --v15;
        }

        uint64_t v8 = 0LL;
        if (v15 == 1 && v14 >= 3 && v23 != 1) {
          uint64_t v8 = SecDNSIsTLD(a2) ^ 1;
        }
      }
    }

BOOL SecPolicyCheckCertEmailSAN(uint64_t a1, const __CFString *cf, int a3)
{
  if (cf
    && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFStringGetTypeID())
    && (!a3 ? (CFDataRef v7 = SecCertificateCopyRFC822Names(a1)) : (CFDataRef v7 = SecCertificateCopyRFC822NamesFromSAN(a1)),
        (uint64_t v8 = v7) != 0LL))
  {
    CFIndex Count = CFArrayGetCount(v7);
    if (Count < 1)
    {
      BOOL v12 = 0;
    }

    else
    {
      CFIndex v10 = Count;
      CFIndex v11 = 0LL;
      BOOL v12 = 1;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v11);
        if (CFStringCompare(cf, ValueAtIndex, 1uLL) == kCFCompareEqualTo) {
          break;
        }
        BOOL v12 = ++v11 < v10;
      }

      while (v10 != v11);
    }

    CFRelease(v8);
  }

  else
  {
    return 0;
  }

  return v12;
}

BOOL SecPolicyCheckCertEmail(uint64_t a1, const __CFString *a2)
{
  return SecPolicyCheckCertEmailSAN(a1, a2, 0);
}

BOOL SecPolicyCheckCertTemporalValidity(uint64_t a1, uint64_t a2)
{
  return a1 && *(double *)(a1 + 168) <= v3 && *(double *)(a1 + 176) >= v3;
}

BOOL SecPolicyCheckCertValidLeaf(uint64_t a1, uint64_t a2)
{
  return a1 && *(double *)(a1 + 168) <= v3 && *(double *)(a1 + 176) >= v3;
}

CFStringRef SecPolicyCheckCertSubjectCommonNamePrefix(uint64_t a1, const __CFString *cf)
{
  BOOL v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFIndex v5 = SecCertificateCopyCommonNames(a1)) != 0LL)
    {
      CFTypeID v6 = v5;
      BOOL v2 = (const __CFString *)(CFArrayGetCount(v5) == 1
                             && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0LL),
                                 CFStringHasPrefix(ValueAtIndex, v2)));
      CFRelease(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

CFTypeRef SecPolicyCheckCertSubjectCommonName(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFIndex v5 = SecCertificateCopyCommonNames(a1)) != 0LL)
    {
      CFTypeID v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

uint64_t SecPolicyCheckCertSubjectCommonNameTEST(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = (uint64_t)cf;
  if (!cf) {
    return v2;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()) {
    return 0LL;
  }
  CFIndex v5 = SecCertificateCopyCommonNames(a1);
  CFTypeID v6 = v5;
  if (v5 && CFArrayGetCount(v5) == 1)
  {
    uint64_t v2 = 1LL;
LABEL_14:
    CFRelease(v6);
    return v2;
  }

  ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL);
  CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"TEST %@ TEST", v2);
  if (!CFEqual((CFTypeRef)v2, ValueAtIndex))
  {
    if (!v8)
    {
      uint64_t v2 = 0LL;
      if (!v6) {
        return v2;
      }
      goto LABEL_14;
    }

    uint64_t v2 = CFEqual(v8, ValueAtIndex) != 0;
    goto LABEL_12;
  }

  uint64_t v2 = 1LL;
  if (v8) {
LABEL_12:
  }
    CFRelease(v8);
  if (v6) {
    goto LABEL_14;
  }
  return v2;
}

BOOL SecPolicyCheckCertNotValidBefore(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 0LL;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  return v4 == CFDateGetTypeID() && *(double *)(a1 + 168) > MEMORY[0x186DFE188](cf);
}

CFTypeRef SecPolicyCheckCertSubjectOrganization(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()
      && (CFIndex v5 = SecCertificateCopyOrganizationFromX501NameContent((unint64_t *)(a1 + 184))) != 0LL)
    {
      CFTypeID v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

CFTypeRef SecPolicyCheckCertSubjectOrganizationalUnit(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFIndex v5 = SecCertificateCopyOrganizationalUnit(a1)) != 0LL)
    {
      CFTypeID v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

CFTypeRef SecPolicyCheckCertSubjectCountry(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (CFIndex v5 = SecCertificateCopyCountry(a1)) != 0LL)
    {
      CFTypeID v6 = v5;
      CFTypeRef v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0LL), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

uint64_t SecPolicyCheckCertEAPTrustedServerNames(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 1LL;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFArrayGetTypeID()) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
  CFTypeID v6 = SecCertificateCopyDNSNames(a1);
  if (!v6) {
    return 0LL;
  }
  CFDataRef v7 = v6;
  CFIndex v8 = CFArrayGetCount(v6);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    CFIndex v10 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v10);
      if (Count >= 1) {
        break;
      }
LABEL_12:
      if (++v10 == v9) {
        goto LABEL_13;
      }
    }

    BOOL v12 = ValueAtIndex;
    CFIndex v13 = 0LL;
    while (1)
    {
      unint64_t v14 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v13);
      if (!v14) {
        break;
      }
      CFIndex v15 = v14;
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 != CFStringGetTypeID()) {
        break;
      }
      if ((SecDNSMatch(v12, v15) & 1) != 0)
      {
        uint64_t v17 = 1LL;
        goto LABEL_17;
      }

      if (Count == ++v13) {
        goto LABEL_12;
      }
    }
  }

BOOL SecPolicyCheckCertLeafMarkerOid(uint64_t a1, const __CFString *a2)
{
  return a2 && (SecCertificateHasMarkerExtension(a1, a2) & 1) != 0;
}

uint64_t SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(uint64_t a1, const __CFString *a2)
{
  CFTypeID v4 = CFGetTypeID(a2);
  if (v4 != CFArrayGetTypeID())
  {
    CFTypeID v11 = CFGetTypeID(a2);
    if (v11 == CFDataGetTypeID()) {
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    }
    CFTypeID v12 = CFGetTypeID(a2);
    if (v12 == CFStringGetTypeID()) {
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    }
    return 0LL;
  }

  CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
  CFIndex v6 = Count - 1;
  if (Count < 1) {
    return 0LL;
  }
  CFIndex v7 = 0LL;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v7);
    uint64_t result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(a1, ValueAtIndex);
    if ((result & 1) != 0) {
      break;
    }
  }

  while (v6 != v7++);
  return result;
}

uint64_t SecPolicyCheckCertLeafMarkersProdAndQA(uint64_t a1, CFDictionaryRef theDict)
{
  unint64_t Value = (const __CFString *)CFDictionaryGetValue(theDict, @"ProdMarker");
  if (Value && (SecCertificateHasMarkerExtension(a1, Value) & 1) != 0) {
    return 1LL;
  }
  uint64_t result = os_variant_allows_internal_security_policies();
  if (!(_DWORD)result) {
    return result;
  }
  CFIndex v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"QAMarker");
  return v6 && (SecCertificateHasMarkerExtension(a1, v6) & 1) != 0;
}

BOOL SecPolicyCheckCertCertificatePolicy(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID()) {
    return checkPolicyOidData(a1, cf);
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID()) {
    return 0LL;
  }
  OidDataFromString = SecCertificateCreateOidDataFromString(0LL, cf);
  if (!OidDataFromString) {
    return 0LL;
  }
  CFIndex v8 = OidDataFromString;
  BOOL v9 = checkPolicyOidData(a1, OidDataFromString);
  CFRelease(v8);
  return v9;
}

BOOL checkPolicyOidData(uint64_t a1, const void *a2)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(0LL, 0LL, MEMORY[0x189605258]);
  if (!Mutable) {
    return 0LL;
  }
  CFIndex v5 = Mutable;
  if (*(_BYTE *)(a1 + 352)) {
    uint64_t v6 = a1 + 352;
  }
  else {
    uint64_t v6 = 0LL;
  }
  if (*(_BYTE *)(a1 + 352))
  {
    uint64_t v7 = *(void *)(v6 + 8);
    if (v7)
    {
      uint64_t v8 = 0LL;
      BOOL v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      do
      {
        uint64_t v10 = *(void *)(v6 + 16) + v8;
        CFIndex v11 = *(void *)(v10 + 8);
        if ((v11 & 0x8000000000000000LL) == 0)
        {
          CFDataRef v12 = CFDataCreate(v9, *(const UInt8 **)v10, v11);
          CFSetAddValue(v5, v12);
          if (v12) {
            CFRelease(v12);
          }
        }

        v8 += 32LL;
        --v7;
      }

      while (v7);
    }
  }

  BOOL v13 = CFSetContainsValue(v5, a2) != 0;
  CFRelease(v5);
  return v13;
}

BOOL SecPolicyCheckCertWeakKeySize(__SecCertificate *a1)
{
  return !a1 || (SecCertificateIsWeakKey(a1) & 1) == 0;
}

uint64_t SecPolicyCheckCertWeakSignature(void *a1)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable(0LL, 3LL, MEMORY[0x189605228]);
  if (!Mutable) {
    return 1LL;
  }
  double v3 = Mutable;
  CFArrayAppendValue(Mutable, @"SignatureDigestMD2");
  CFArrayAppendValue(v3, @"SignatureDigestMD4");
  CFArrayAppendValue(v3, @"SignatureDigestMD5");
  unsigned int v4 = SecCertificateIsCertificate(a1);
  if (v4) {
    BOOL IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a1);
  }
  else {
    BOOL IsSelfSigned = 0;
  }
  BOOL v7 = SecPolicyCheckCertSignatureHashAlgorithms(a1, v3);
  if (IsSelfSigned) {
    unsigned int v8 = v4;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v7) {
    uint64_t v6 = 1LL;
  }
  else {
    uint64_t v6 = v8;
  }
  CFRelease(v3);
  return v6;
}

BOOL SecPolicyCheckCertSignatureHashAlgorithms(void *a1, const __CFArray *a2)
{
  v7[10] = *MEMORY[0x1895F89C0];
  if (a1) {
    CFIndex v5 = a1 + 15;
  }
  else {
    CFIndex v5 = 0LL;
  }
  v7[0] = @"SignatureDigestUnknown";
  v7[1] = @"SignatureDigestMD2";
  void v7[2] = @"SignatureDigestMD4";
  unint64_t v7[3] = @"SignatureDigestMD5";
  UInt8 v7[4] = @"SignatureDigestSHA1";
  void v7[5] = @"SignatureDigestSHA224";
  void v7[6] = @"SignatureDigestSHA256";
  v7[7] = @"SignatureDigestSHA284";
  void v7[8] = @"SignatureDigestSHA512";
  v7[9] = @"SignatureDigestSHAKE256";
  uint64_t v6 = (const void *)v7[SecSignatureHashAlgorithmForAlgorithmOid(v5)];
  v8.CFIndex length = CFArrayGetCount(a2);
  v8.CFIndex location = 0LL;
  return CFArrayContainsValue(a2, v8, v6) == 0;
}

BOOL SecPolicyCheckCertUnparseableExtension(uint64_t a1)
{
  return !a1 || *(void *)(a1 + 528) == -1LL;
}

BOOL SecPolicyCheckCertDuplicateExtension(uint64_t a1)
{
  return !a1 || *(void *)(a1 + 536) == -1LL;
}

uint64_t SecPolicyCheckCertNotCA(uint64_t a1)
{
  return SecCertificateIsCA(a1) ^ 1;
}

void SecLeafPVCValidateKey(void *key, uint64_t a2, CFAbsoluteTime *a3)
{
  if (*((_BYTE *)a3 + 56) || *((void *)a3 + 3))
  {
    unint64_t Value = (uint64_t (*)(void, CFDateRef))CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 5), key);
    if (Value)
    {
      uint64_t v6 = Value;
      if (CFEqual(key, @"TemporalValidity") || CFEqual(key, @"ValidLeaf"))
      {
        CFDateRef v7 = CFDateCreate(0LL, a3[2]);
        if ((v6(*(void *)a3, v7) & 1) == 0) {
          SecLeafPVCSetResult((uint64_t)a3, key, (const void *)*MEMORY[0x189604DE0]);
        }
        if (v7) {
          CFRelease(v7);
        }
      }

      else
      {
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*((CFArrayRef *)a3 + 1), *((void *)a3 + 6));
        if (ValueAtIndex)
        {
          BOOL v9 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex[4], key);
          if ((v6(*(void *)a3, v9) & 1) == 0) {
            SecLeafPVCSetResult((uint64_t)a3, key, (const void *)*MEMORY[0x189604DE0]);
          }
        }

        else
        {
          *((_BYTE *)a3 + 56) = 0;
        }
      }
    }
  }

void SecLeafPVCSetResult(uint64_t a1, const void *a2, const void *a3)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 48));
  if (!ValueAtIndex || CFDictionaryContainsKey(ValueAtIndex[4], a2))
  {
    *(_BYTE *)(a1 + 56) = 0;
    CFDateRef v7 = *(const __CFArray **)(a1 + 24);
    if (v7)
    {
      CFRange v8 = (__CFDictionary *)CFArrayGetValueAtIndex(v7, 0LL);
      CFDictionarySetValue(v8, a2, a3);
    }
  }

uint64_t SecRSAPublicKeyBlockSize()
{
  return ccrsa_block_size();
}

__CFDictionary *SecRSAPublicKeyCopyAttributeDictionary(const void *a1)
{
  uint64_t v1 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)@"42", 0LL);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v1);
  CFDictionarySetValue(MutableCopy, @"decr", (const void *)*MEMORY[0x189604DE8]);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x189604DE0]);
  uint64_t valuePtr = cczp_bitlen();
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(MutableCopy, @"bsiz", v3);
  CFDictionarySetValue(MutableCopy, @"esiz", v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v1) {
    CFRelease(v1);
  }
  return MutableCopy;
}

CFStringRef SecRSAPublicKeyCopyDescription(void *a1)
{
  CFTypeRef v2 = SecKeyCopyModulus(a1);
  CFNumberRef v3 = (void *)a1[3];
  unsigned int v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex Length = CFDataGetLength(v2);
  CFMutableSetRef Mutable = CFStringCreateMutable(v4, 2 * Length);
  uint64_t BytePtr = CFDataGetBytePtr(v2);
  CFIndex v8 = CFDataGetLength(v2);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    do
    {
      unsigned int v10 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0LL, @"%02X", v10);
      --v9;
    }

    while (v9);
  }

  if (Mutable)
  {
    uint64_t AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
    CFDataRef v12 = (unsigned int *)a1[2];
    uint64_t v13 = *((void *)v12 + 1);
    uint64_t v14 = *v12;
    uint64_t v15 = cczp_bitlen();
    _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
    CFTypeID v16 = *(uint64_t (**)(void *))(a1[2] + 80LL);
    if (v16) {
      uint64_t v17 = v16(a1);
    }
    else {
      uint64_t v17 = 0LL;
    }
    CFStringRef v18 = CFStringCreateWithFormat( v4,  0LL,  @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), exponent: {hex: %llx, decimal: %lld}, modulus: %@, addr: %p>",  AlgorithmId,  v13,  v14,  v15,  v17,  v3[2 * *v3 + 4],  v3[2 * *v3 + 4],  Mutable,  a1);
    if (v2) {
      goto LABEL_9;
    }
  }

  else
  {
    CFStringRef v18 = 0LL;
    if (v2) {
LABEL_9:
    }
      CFRelease(v2);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v18) {
    return v18;
  }
  uint64_t v20 = SecKeyGetAlgorithmId((uint64_t)a1);
  CFRange v21 = (unsigned int *)a1[2];
  uint64_t v22 = *((void *)v21 + 1);
  uint64_t v23 = *v21;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  CFRange v24 = *(uint64_t (**)(void *))(a1[2] + 80LL);
  if (v24) {
    CFRange v24 = (uint64_t (*)(void *))(8 * v24(a1));
  }
  return CFStringCreateWithFormat( v4,  0LL,  @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>",  v20,  v22,  v23,  v24,  a1);
}

__CFData *SecRSAPublicKeyCopyExternalRepresentation(const void *a1)
{
  uint64_t v1 = CFGetAllocator(a1);
  return SecRSAPublicKeyCreatePKCS1(v1);
}

__CFData *SecRSAPublicKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  if (!CFEqual(cf1, @"algid:encrypt:RSA:raw-cc")) {
    return (__CFData *)*MEMORY[0x189605018];
  }
  CFMutableSetRef Mutable = (__CFData *)*MEMORY[0x189604DE8];
  if (a2 != 3)
  {
    if (a2 == 2)
    {
      if (!a5)
      {
        CFIndex Length = CFDataGetLength(a6);
        if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8LL))
        {
          CFDataGetLength(a6);
          CFDataGetBytePtr(a6);
          if ((ccn_cmpn() & 0x80000000) == 0)
          {
            SecError(-50, a8, @"RSApubkey wrong size of buffer to encrypt");
            return 0LL;
          }

          uint64_t v15 = 0LL;
          goto LABEL_14;
        }

        goto LABEL_19;
      }

      return Mutable;
    }

    return (__CFData *)*MEMORY[0x189605018];
  }

  if (!a5)
  {
    CFIndex Length = CFDataGetLength(a6);
    if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8LL))
    {
      if (SecCFAllocatorZeroize_sOnce != -1) {
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
      }
      uint64_t v15 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
LABEL_14:
      CFMutableSetRef Mutable = CFDataCreateMutable(v15, 0LL);
      CFDataSetLength(Mutable, Length);
      CFDataGetMutableBytePtr(Mutable);
      CFDataGetBytePtr(a6);
      uint64_t v16 = ccrsa_pub_crypt();
      if (!(_DWORD)v16) {
        return Mutable;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      SecError(-50, a8, @"rsa_pub_crypt failed, ccerr=%d", v16);
      return 0LL;
    }

__CFData *SecKeyCopyModulus(void *a1)
{
  uint64_t v2 = a1[2];
  if ((_UNKNOWN *)v2 == &kSecRSAPublicKeyDescriptor)
  {
    CFIndex v8 = ccn_write_uint_size();
    CFIndex v9 = CFGetAllocator(a1);
    CFMutableSetRef Mutable = CFDataCreateMutable(v9, v8);
    CFDateRef v7 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v8);
      CFDataGetMutableBytePtr(v7);
      ccn_write_uint();
    }
  }

  else
  {
    CFNumberRef v3 = *(uint64_t (**)(void *))(v2 + 88);
    if (v3 && (unsigned int v4 = (const __CFDictionary *)v3(a1)) != 0LL)
    {
      CFIndex v5 = v4;
      unint64_t Value = (__CFData *)CFDictionaryGetValue(v4, @"_rsam");
      CFDateRef v7 = Value;
      if (Value) {
        CFRetain(Value);
      }
      CFRelease(v5);
    }

    else
    {
      return 0LL;
    }
  }

  return v7;
}

uint64_t ccrsa_pub_init(unint64_t *a1, uint64_t a2, _BYTE *a3)
{
  for (uint64_t i = a2; i; --i)
  {
    if (*a3) {
      break;
    }
    ++a3;
  }

  unint64_t v5 = (unint64_t)(i + 7) >> 3;
  if (v5 > *a1) {
    return 0xFFFFFFFFLL;
  }
  *a1 = v5;
  return ccrsa_make_pub();
}

uint64_t SecRSAPrivateKeyInit(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a4 == 7)
  {
LABEL_4:
    uint64_t v6 = ccrsa_import_priv_n();
    if ((unint64_t)(v6 - 129) >= 0xFFFFFFFFFFFFFF80LL)
    {
      uint64_t v7 = v6;
      CFIndex v8 = calloc(1uLL, 7 * ((4 * v6) & 0x7FFFFFFFFFFFFFF8LL) + 32 * v6 + 176);
      *(void *)(a1 + 24) = v8;
      if (v8)
      {
        void *v8 = v7;
        fips186_SecKeyRef key = ccrsa_import_priv();
        goto LABEL_7;
      }

      return 4294967188LL;
    }

    return 4294967246LL;
  }

  if (a4 != 5)
  {
    if (a4 != 1) {
      return 4294967246LL;
    }
    goto LABEL_4;
  }

  unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"bsiz");
  if (Value)
  {
    CFDataRef v12 = Value;
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID())
    {
      *(void *)CFStringRef v19 = 0xAAAAAAAAAAAAAAAALL;
      CFNumberGetValue(v12, kCFNumberCFIndexType, v19);
      uint64_t IntValue = *(void *)v19;
    }

    else
    {
      CFTypeID v15 = CFGetTypeID(v12);
      if (v15 != CFStringGetTypeID()) {
        goto LABEL_17;
      }
      uint64_t IntValue = CFStringGetIntValue((CFStringRef)v12);
    }

    if ((unint64_t)(IntValue - 8193) > 0xFFFFFFFFFFFFE1FELL)
    {
      unint64_t v17 = (unint64_t)(IntValue + 63) >> 6;
      CFStringRef v18 = calloc(1uLL, 7 * (((unint64_t)(IntValue + 63) >> 4) & 0xFFFFFFFFFFFFFF8LL) + 32 * v17 + 176);
      *(void *)(a1 + 24) = v18;
      if (v18)
      {
        void *v18 = v17;
        ccrng();
        ccrng();
        fips186_SecKeyRef key = ccrsa_generate_fips186_key();
LABEL_7:
        if (fips186_key) {
          return 4294967246LL;
        }
        else {
          return 0LL;
        }
      }

      return 4294967188LL;
    }
  }

void SecRSAPrivateKeyDestroy(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    cc_clear();
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
  }

uint64_t SecRSAPrivateKeyBlockSize()
{
  return ccn_write_uint_size();
}

__CFDictionary *SecRSAPrivateKeyCopyAttributeDictionary(const void *a1)
{
  uint64_t v2 = SecRSAPrivateKeyCopyPKCS1(a1);
  if (!v2) {
    return 0LL;
  }
  CFNumberRef v3 = v2;
  unsigned int v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)@"42", v2);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v4);
  CFDictionarySetValue(MutableCopy, @"drve", (const void *)*MEMORY[0x189604DE0]);
  uint64_t valuePtr = cczp_bitlen();
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(MutableCopy, @"bsiz", v6);
  CFDictionarySetValue(MutableCopy, @"esiz", v6);
  if (v6) {
    CFRelease(v6);
  }
  if (v4) {
    CFRelease(v4);
  }
  CFRelease(v3);
  return MutableCopy;
}

CFStringRef SecRSAPrivateKeyCopyDescription(uint64_t a1)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t AlgorithmId = SecKeyGetAlgorithmId(a1);
  unsigned int v4 = *(unsigned int **)(a1 + 16);
  uint64_t v5 = *((void *)v4 + 1);
  uint64_t v6 = *v4;
  uint64_t v7 = cczp_bitlen();
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  CFIndex v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80LL);
  if (v8) {
    uint64_t v9 = v8(a1);
  }
  else {
    uint64_t v9 = 0LL;
  }
  return CFStringCreateWithFormat( v2,  0LL,  @"<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), addr: %p>",  AlgorithmId,  v5,  v6,  v7,  v9,  a1);
}

uint64_t SecRSAPrivateKeyCopyPublicSerialization(const void *a1, __CFData **a2)
{
  CFNumberRef v3 = CFGetAllocator(a1);
  ccrsa_ctx_public();
  PKCS1 = SecRSAPublicKeyCreatePKCS1(v3);
  *a2 = PKCS1;
  if (PKCS1) {
    return 0LL;
  }
  else {
    return 4294941021LL;
  }
}

__CFData *SecRSAPrivateKeyCopyOperationResult( uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  CFMutableSetRef Mutable = (__CFData *)*MEMORY[0x189605018];
  if (a2 == 3)
  {
    if (CFEqual(cf1, @"algid:encrypt:RSA:raw-cc"))
    {
      if (!a5)
      {
        CFIndex Length = CFDataGetLength(a6);
        ccrsa_ctx_public();
        if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8LL))
        {
          if (SecCFAllocatorZeroize_sOnce != -1) {
            dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
          }
          uint64_t v14 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
LABEL_15:
          CFMutableSetRef Mutable = CFDataCreateMutable(v14, 0LL);
          CFDataSetLength(Mutable, Length);
          CFDataGetMutableBytePtr(Mutable);
          CFDataGetBytePtr(a6);
          uint64_t v15 = ccrsa_priv_crypt();
          if (!(_DWORD)v15) {
            return Mutable;
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          SecError(-50, a8, @"rsa_priv_crypt failed, ccerr=%d", v15);
          return 0LL;
        }

__CFData *SecRSAPrivateKeyCopyPKCS1(const void *a1)
{
  uint64_t v1 = CFGetAllocator(a1);
  CFIndex v2 = ccrsa_export_priv_size();
  CFMutableSetRef Mutable = CFDataCreateMutable(v1, v2);
  unsigned int v4 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v2);
    CFDataGetMutableBytePtr(v4);
    if (ccrsa_export_priv())
    {
      CFRelease(v4);
      return 0LL;
    }
  }

  return v4;
}

void *SecKeyCreateRSAPublicKey_ios(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a2, a3, a4);
}

void *SecKeyCreateRSAPublicKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a2, a3, a4);
}

__CFData *SecKeyCopyExponent(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if ((_UNKNOWN *)v1 == &kSecRSAPublicKeyDescriptor)
  {
    CFIndex v7 = ccn_write_uint_size();
    if (SecCFAllocatorZeroize_sOnce != -1) {
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7783);
    }
    CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v7);
    uint64_t v6 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v7);
      CFDataGetMutableBytePtr(v6);
      ccn_write_uint();
    }
  }

  else
  {
    CFIndex v2 = *(uint64_t (**)(void))(v1 + 88);
    if (v2 && (CFNumberRef v3 = (const __CFDictionary *)v2()) != 0LL)
    {
      unsigned int v4 = v3;
      unint64_t Value = (__CFData *)CFDictionaryGetValue(v3, @"_rsae");
      uint64_t v6 = Value;
      if (Value) {
        CFRetain(Value);
      }
      CFRelease(v4);
    }

    else
    {
      return 0LL;
    }
  }

  return v6;
}

void *SecKeyCreateRSAPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPrivateKeyDescriptor, a2, a3, a4);
}

uint64_t SecSCEPCreateTemporaryIdentity(uint64_t a1, __SecKey *a2)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  int valuePtr = 5;
  CFTypeRef cf = 0LL;
  CFTypeRef v17 = 0LL;
  CFNumberRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
  if (!v4)
  {
    CFStringRef v9 = 0LL;
    uint64_t v14 = 0LL;
    goto LABEL_13;
  }

  CFNumberRef v5 = v4;
  values = v4;
  keys[0] = @"keyUsage";
  CFDictionaryRef v6 = CFDictionaryCreate( v3,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!v6)
  {
    CFStringRef v9 = 0LL;
    uint64_t v14 = 0LL;
    CFDataRef v12 = v5;
LABEL_12:
    CFRelease(v12);
    goto LABEL_13;
  }

  CFIndex v7 = v6;
  memset(cStr, 0, 37);
  memset(out, 170, sizeof(out));
  uuid_generate_random(out);
  uuid_unparse(out, cStr);
  CFStringRef v8 = CFStringCreateWithCString(v3, cStr, 0x600u);
  CFStringRef v9 = v8;
  if (!v8
    || (v19[0] = @"CN", v19[1] = (void *)v8, (CFTypeRef v17 = CFArrayCreate(v3, (const void **)v19, 2LL, 0LL)) == 0LL)
    || (CFTypeRef cf = CFArrayCreate(v3, &v17, 1LL, 0LL)) == 0LL)
  {
    CFDataRef v12 = 0LL;
    goto LABEL_21;
  }

  unsigned int v10 = CFArrayCreate(v3, &cf, 1LL, 0LL);
  CFDataRef v12 = v10;
  if (!v10)
  {
LABEL_21:
    uint64_t v14 = 0LL;
    SelfSignedCertificateWithError = 0LL;
    goto LABEL_9;
  }

  SelfSignedCertificateWithError = SecGenerateSelfSignedCertificateWithError(v10, v7, v11, a2, 0LL);
  if (SelfSignedCertificateWithError) {
    uint64_t v14 = SecIdentityCreate((int)v3, SelfSignedCertificateWithError, a2);
  }
  else {
    uint64_t v14 = 0LL;
  }
LABEL_9:
  CFRelease(v5);
  CFRelease(v7);
  if (SelfSignedCertificateWithError) {
    CFRelease(SelfSignedCertificateWithError);
  }
  if (v12) {
    goto LABEL_12;
  }
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v14;
}

CFDictionaryRef SecSCEPGenerateCertificateRequest( const __CFArray *a1, const __CFDictionary *a2, CFMutableDataRef Mutable, __SecKey *a4, void *a5, const void *a6)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  values = 0LL;
  uint64_t v11 = filterRecipients(a6);
  CFTypeID v12 = CFGetTypeID(v11);
  ValueAtIndex = v11;
  if (v12 != SecCertificateGetTypeID())
  {
    CFTypeID v14 = CFGetTypeID(v11);
    if (v14 != CFArrayGetTypeID())
    {
LABEL_38:
      SecKeyRef v16 = 0LL;
      CFDictionaryRef v44 = 0LL;
      CFDataRef CertificateRequest = 0LL;
      SecKeyRef v15 = 0LL;
LABEL_39:
      CFMutableSetRef Mutable = 0LL;
      goto LABEL_54;
    }

    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v11, 0LL);
  }

  if (!ValueAtIndex) {
    goto LABEL_38;
  }
  SecKeyRef v15 = SecCertificateCopyKey(ValueAtIndex);
  if (SecKeyGetAlgorithmId((uint64_t)v15) != 1)
  {
    SecKeyRef v16 = 0LL;
    CFDictionaryRef v44 = 0LL;
    CFDataRef CertificateRequest = 0LL;
    goto LABEL_39;
  }

  SecKeyRef v16 = SecKeyCopyPublicKey(a4);
  if (!v16)
  {
    if (!Mutable)
    {
      SecKeyRef v16 = 0LL;
      CFDictionaryRef v44 = 0LL;
LABEL_53:
      CFDataRef CertificateRequest = 0LL;
      goto LABEL_54;
    }

    CFRetain(Mutable);
    SecKeyRef v16 = Mutable;
  }

  uint64_t v46 = a4;
  CFDataRef CertificateRequest = SecGenerateCertificateRequest(a1, a2, v16, a4);
  if (!CertificateRequest)
  {
    CFDictionaryRef v44 = 0LL;
    goto LABEL_39;
  }

  allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (Mutable && !SecCMSCreateEnvelopedData(ValueAtIndex, a2, CertificateRequest, (uint64_t)Mutable))
  {
    CFRelease(CertificateRequest);
    CFStringRef v18 = CFDictionaryCreateMutable(allocator, 3LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    memset(bytes, 170, 20);
    CFStringRef v19 = SecKeyCopyAttributes(v16);
    uint64_t v50 = v15;
    CFDictionaryRef theDict = a2;
    if (v19)
    {
      uint64_t v20 = v19;
      unint64_t Value = CFDictionaryGetValue(v19, @"kcls");
      if (Value
        && CFEqual(Value, @"0")
        && (uint64_t v22 = (const __CFData *)CFDictionaryGetValue(v20, @"v_Data")) != 0LL
        && (uint64_t v23 = v22, !((unint64_t)CFDataGetLength(v22) >> 32)))
      {
        CFDataGetBytePtr(v23);
        CFDataGetLength(v23);
        CCDigest();
        CFRange v24 = CFDataCreate(allocator, bytes, 20LL);
      }

      else
      {
        CFRange v24 = 0LL;
      }

      CFRelease(v20);
    }

    else
    {
      CFRange v24 = 0LL;
    }

    CFIndex Length = CFDataGetLength(v24);
    uint64_t BytePtr = CFDataGetBytePtr(v24);
    CFRange v27 = (UInt8 *)calloc(1uLL, (2 * Length) | 1);
    CFRange v28 = v27;
    uint64_t v49 = v16;
    if (Length && BytePtr && v27)
    {
      CFIndex v48 = a5;
      CFRange v29 = v18;
      int v30 = Mutable;
      CFTypeID v31 = v11;
      CFIndex v32 = 2 * Length;
      if (Length >= 1)
      {
        CFRange v33 = (char *)v27;
        do
        {
          int v34 = *BytePtr++;
          snprintf(v33, 3uLL, "%02X", v34);
          v33 += 2;
          --Length;
        }

        while (Length);
      }

      CFRange v35 = CFDataCreateWithBytesNoCopy(allocator, v28, v32, (CFAllocatorRef)*MEMORY[0x189604DB8]);
      uint64_t v11 = v31;
      CFMutableSetRef Mutable = v30;
      CFStringRef v18 = v29;
      a5 = v48;
      if (v24) {
LABEL_26:
      }
        CFRelease(v24);
    }

    else
    {
      if (v27) {
        free(v27);
      }
      CFRange v35 = 0LL;
      if (v24) {
        goto LABEL_26;
      }
    }

    *(_WORD *)&UInt8 bytes[8] = 1801;
    CFDataRef v36 = CFDataCreate(allocator, bytes, 10LL);
    CFIndex v37 = CFDataGetLength(v35);
    uint64_t v38 = CFDataGetBytePtr(v35);
    uint64_t v39 = printable_string_data(v37, v38);
    if (v35) {
      CFRelease(v35);
    }
    CFDictionarySetValue(v18, v36, v39);
    if (v36) {
      CFRelease(v36);
    }
    if (v39) {
      CFRelease(v39);
    }
    *(_WORD *)&UInt8 bytes[8] = 521;
    CFDataRef v40 = CFDataCreate(allocator, bytes, 10LL);
    SecKeyRef v16 = v49;
    if (!v40)
    {
      CFDictionaryRef v44 = 0LL;
      SecKeyRef v15 = v50;
      goto LABEL_48;
    }

    uint64_t v41 = printable_string_data(2uLL, &PKCSReq);
    SecKeyRef v15 = v50;
    if (!v41)
    {
      CFDictionaryRef v44 = 0LL;
      goto LABEL_48;
    }

    uint64_t v42 = v41;
    CFDictionarySetValue(v18, v40, v41);
    CFRelease(v40);
    CFRelease(v42);
    uint64_t sender_nonce = generate_sender_nonce(v18);
    if (!(_DWORD)sender_nonce)
    {
      if (a5)
      {
        values = a5;
        CFRetain(a5);
        goto LABEL_46;
      }

      values = (void *)SecSCEPCreateTemporaryIdentity(sender_nonce, v46);
      if (values)
      {
        CFDictionaryRef v44 = CFDictionaryCreate(0LL, (const void **)&kSecValueRef, (const void **)&values, 1LL, 0LL, 0LL);
        if (SecItemAdd(v44, 0LL))
        {
LABEL_69:
          if (!v44) {
            goto LABEL_47;
          }
          CFRelease(v44);
          goto LABEL_45;
        }

        if (v44) {
          CFRelease(v44);
        }
        if (values)
        {
LABEL_46:
          CFDictionaryRef v44 = CFDataCreateMutable(allocator, 0LL);
          goto LABEL_69;
        }
      }
    }

CFArrayRef filterRecipients(const void *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    CFTypeID TypeID = SecCertificateGetTypeID();
    if (TypeID != CFGetTypeID(v1))
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 != CFArrayGetTypeID()) {
        return 0LL;
      }
      CFMutableSetRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
      context[0] = MEMORY[0x1895F87A8];
      context[1] = 0x40000000LL;
      context[2] = __filterRecipients_block_invoke;
      context[3] = &__block_descriptor_tmp_11683;
      void context[4] = Mutable;
      v7.CFIndex length = CFArrayGetCount((CFArrayRef)v1);
      v7.CFIndex location = 0LL;
      CFArrayApplyFunction((CFArrayRef)v1, v7, (CFArrayApplierFunction)apply_block_1_11684, context);
      if (CFArrayGetCount(Mutable)) {
        return Mutable;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    CFRetain(v1);
  }

  return (const __CFArray *)v1;
}

__CFData *printable_string_data(unint64_t a1, const void *a2)
{
  uint64_t v9 = DERLengthOfLength(a1);
  CFIndex v4 = a1 + v9 + 1;
  CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], v4);
  CFDataSetLength(Mutable, v4);
  uint64_t BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
  UInt8 *BytePtr = 19;
  CFRange v7 = BytePtr + 1;
  DEREncodeLength(a1, (unint64_t)(BytePtr + 1), (unint64_t *)&v9);
  memcpy(&v7[v9], a2, a1);
  return Mutable;
}

uint64_t generate_sender_nonce(__CFDictionary *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  WORD4(v9) = 1289;
  CFIndex v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)&v9, 10LL);
  __int128 v9 = xmmword_180657B3F;
  __int16 v10 = 0;
  uint64_t v4 = CCRandomCopyBytes();
  CFDataRef v5 = CFDataCreate(v2, (const UInt8 *)&v9, 18LL);
  CFDataRef v6 = v5;
  if (v3) {
    BOOL v7 = v5 == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    CFDictionarySetValue(a1, v3, v5);
    goto LABEL_10;
  }

  if (v3)
  {
LABEL_10:
    CFRelease(v3);
    if (!v6) {
      return v4;
    }
    goto LABEL_8;
  }

  if (v5) {
LABEL_8:
  }
    CFRelease(v6);
  return v4;
}

void __filterRecipients_block_invoke(uint64_t a1, _DWORD *a2)
{
  CFTypeID TypeID = SecCertificateGetTypeID();
  if (TypeID == CFGetTypeID(a2) && (!a2 || (int v5 = a2[96]) == 0 || (v5 & 4) != 0)) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
  }
}

uint64_t apply_block_1_11684(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableDataRef SecSCEPCertifyRequest(const __CFData *a1, uint64_t a2, const __CFData *a3, char a4)
{
  return SecSCEPCertifyRequestWithAlgorithms(a1, a2, a3, a4, 0LL, 0LL);
}

CFMutableDataRef SecSCEPCertifyRequestWithAlgorithms( const __CFData *a1, uint64_t a2, const __CFData *a3, char a4, const void *a5, void *a6)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  CFTypeRef v47 = 0LL;
  values = a6;
  CFTypeRef v45 = 0LL;
  CFTypeRef v46 = 0LL;
  CFTypeRef v43 = 0LL;
  CFTypeRef v44 = 0LL;
  CFTypeRef v41 = 0LL;
  CFTypeRef cf = 0LL;
  CFTypeRef v40 = 0LL;
  __int16 v10 = *(void **)(a2 + 16);
  CFRetain(v10);
  CFTypeRef v34 = v10;
  uint64_t v11 = SecCertificateCopyKey((SecCertificateRef)v10);
  SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
  CFIndex v37 = v11;
  if (SecCMSVerifySignedData_internal( a1,  0LL,  BasicX509,  (SecTrustRef *)&v47,  0LL,  (uint64_t *)&v46,  (const __CFDictionary **)&v45)
    || (int v39 = -1431655766, SecTrustEvaluateInternal((__SecTrust *)v47, &v39)))
  {
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFTypeID v31 = 0LL;
    CFDataRef v36 = 0LL;
    CFDataRef v16 = 0LL;
    CFTypeID v13 = 0LL;
LABEL_89:
    uint64_t v22 = 0LL;
    CFTypeRef v17 = 0LL;
    goto LABEL_44;
  }

  CFTypeID v12 = copySignerCert((__SecTrust *)v47);
  CFTypeID v13 = v12;
  if (!v12
    || (int IsSignedBy = SecCertificateIsSignedBy(v12, v11),
        !scep_attr_has_val((const __CFDictionary *)v45, "19")))
  {
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFTypeID v31 = 0LL;
    CFDataRef v36 = 0LL;
    CFDataRef v16 = 0LL;
    goto LABEL_89;
  }

  __int16 v52 = 1801;
  SecKeyRef v15 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 10LL);
  if (!v16) {
    goto LABEL_90;
  }
  CFTypeRef v17 = (void *)dictionary_array_value_1((const __CFDictionary *)v45, v16);
  if (!v17)
  {
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFTypeID v31 = 0LL;
    CFDataRef v36 = 0LL;
    uint64_t v22 = 0LL;
    goto LABEL_44;
  }

  __int16 v52 = 1289;
  CFDataRef v18 = CFDataCreate(v15, bytes, 10LL);
  if (!v18)
  {
LABEL_90:
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFTypeID v31 = 0LL;
    CFDataRef v36 = 0LL;
LABEL_96:
    uint64_t v22 = 0LL;
LABEL_104:
    CFTypeRef v17 = 0LL;
    goto LABEL_44;
  }

  CFDataRef v36 = v18;
  if (!dictionary_array_value_1((const __CFDictionary *)v45, v18)) {
    goto LABEL_86;
  }
  CFMutableSetRef Mutable = CFDataCreateMutable(v15, 0LL);
  CFMutableDataRef v20 = 0LL;
  if (SecCMSDecryptEnvelopedData((const __CFData *)v46, Mutable, &v40) || !v40)
  {
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFTypeID v31 = 0LL;
    uint64_t v22 = 0LL;
    CFTypeRef v17 = 0LL;
    goto LABEL_44;
  }

  if (!SecVerifyCertificateRequest( Mutable,  (__SecKey **)&v41,  (CFStringRef *)&cf,  (CFDataRef *)&v44,  (CFDataRef *)&v43))
  {
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    goto LABEL_95;
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  if (IsSignedBy)
  {
    if (!cf || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(cf)) || !CFEqual(@"magic", cf))
    {
LABEL_86:
      CFMutableDataRef v20 = 0LL;
      uint64_t v25 = 0LL;
      CFRange v24 = 0LL;
      CFMutableSetRef Mutable = 0LL;
LABEL_95:
      CFTypeID v31 = 0LL;
      goto LABEL_96;
    }
  }

  uint64_t v22 = CFDataCreateMutable(v15, 0LL);
  if (!v22) {
    goto LABEL_92;
  }
  if ((a4 & 1) != 0)
  {
    uint64_t v23 = &PKIStatusPENDING;
    goto LABEL_32;
  }

  if (SecKeyGetAlgorithmId((uint64_t)v41) != 1)
  {
LABEL_92:
    CFMutableDataRef v20 = 0LL;
    uint64_t v25 = 0LL;
LABEL_102:
    CFRange v24 = 0LL;
    goto LABEL_103;
  }

  CFRange v24 = SecIdentitySignCertificateWithAlgorithm(a2, a3, (__SecKey *)v41, v44, v43, a5);
  uint64_t v25 = SecCMSCreateCertificatesOnlyMessage(v24);
  if (!v25)
  {
    CFMutableDataRef v20 = 0LL;
LABEL_103:
    CFMutableSetRef Mutable = 0LL;
    CFTypeID v31 = 0LL;
    goto LABEL_104;
  }

  if (v24) {
    CFRelease(v24);
  }
  if (values) {
    int v26 = CFDictionaryCreate( 0LL,  (const void **)&kSecCMSBulkEncryptionAlgorithm,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  }
  else {
    int v26 = 0LL;
  }
  if (SecCMSCreateEnvelopedData(v13, v26, v25, (uint64_t)v22))
  {
    CFMutableDataRef v20 = 0LL;
    goto LABEL_102;
  }

  CFRelease(v25);
  if (v26) {
    CFRelease(v26);
  }
  uint64_t v23 = &PKIStatusSUCCESS;
LABEL_32:
  __int16 v52 = 777;
  CFDataRef v27 = CFDataCreate(v15, bytes, 10LL);
  CFRange v28 = printable_string_data(1uLL, v23);
  __int16 v52 = 521;
  CFDataRef v29 = CFDataCreate(v15, bytes, 10LL);
  int v30 = printable_string_data(1uLL, &CertRep);
  keys[0] = v16;
  keys[1] = v27;
  keys[2] = v29;
  v49[0] = v17;
  v49[1] = v28;
  v49[2] = v30;
  CFTypeRef v17 = CFDictionaryCreate(v15, (const void **)keys, (const void **)v49, 3LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (v27) {
    CFRelease(v27);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v30) {
    CFRelease(v30);
  }
  CFMutableDataRef v20 = CFDataCreateMutable(v15, 0LL);
  CFTypeID v31 = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFDictionaryAddValue(v31, (const void *)kSecCMSCertChainMode, (const void *)kSecCMSCertChainModeNone);
  if (a5) {
    CFDictionaryAddValue(v31, (const void *)kSecCMSSignHashAlgorithm, a5);
  }
  if (!SecCMSCreateSignedData(a2, v22, v31, (const __CFDictionary *)v17, (uint64_t)v20))
  {
    uint64_t v25 = 0LL;
    CFRange v24 = 0LL;
    CFMutableSetRef Mutable = 0LL;
LABEL_44:
    SecPolicyRef v32 = BasicX509;
    goto LABEL_45;
  }

  SecPolicyRef v32 = BasicX509;
  if (v20)
  {
    CFRelease(v20);
    CFMutableDataRef v20 = 0LL;
  }

  uint64_t v25 = 0LL;
  CFRange v24 = 0LL;
  CFMutableSetRef Mutable = 0LL;
LABEL_45:
  if (v34) {
    CFRelease(v34);
  }
  if (v37) {
    CFRelease(v37);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v47) {
    CFRelease(v47);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v45) {
    CFRelease(v45);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v41) {
    CFRelease(v41);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v40) {
    CFRelease(v40);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v20;
}

const void *copySignerCert(__SecTrust *a1)
{
  uint64_t v1 = SecTrustCopyCertificateChain(a1);
  if (!v1) {
    return 0LL;
  }
  CFIndex v2 = v1;
  ValueAtIndex = CFArrayGetValueAtIndex(v1, 0LL);
  uint64_t v4 = ValueAtIndex;
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  CFRelease(v2);
  return v4;
}

unint64_t scep_attr_has_val(const __CFDictionary *a1, char *__s)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  size_t v4 = strlen(__s);
  CFTypeRef cf = printable_string_data(v4, __s);
  int v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFArrayRef v6 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], &cf, 1LL, MEMORY[0x189605228]);
  CFRelease(cf);
  __int16 v12 = 521;
  CFDataRef v7 = CFDataCreate(v5, bytes, 10LL);
  unint64_t Value = (unint64_t)CFDictionaryGetValue(a1, v7);
  CFRelease(v7);
  if (Value) {
    unint64_t Value = CFEqual(v6, (CFTypeRef)Value) != 0;
  }
  CFRelease(v6);
  return Value;
}

const void *dictionary_array_value_1(const __CFDictionary *a1, const void *a2)
{
  unint64_t Value = (const __CFArray *)CFDictionaryGetValue(a1, a2);
  if (Value && (CFDataRef v3 = Value, CFArrayGetCount(Value) == 1)) {
    return CFArrayGetValueAtIndex(v3, 0LL);
  }
  else {
    return 0LL;
  }
}

BOOL SecSCEPVerifyGetCertInitial(const __CFData *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  CFTypeRef v14 = 0LL;
  CFTypeRef cf = 0LL;
  CFTypeRef v12 = 0LL;
  CFTypeRef v13 = 0LL;
  CFDataRef v3 = *(void **)(a2 + 16);
  CFRetain(v3);
  SecKeyRef v4 = SecCertificateCopyKey((SecCertificateRef)v3);
  SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
  if (SecCMSVerifySignedData_internal( a1,  0LL,  BasicX509,  (SecTrustRef *)&cf,  0LL,  (uint64_t *)&v14,  (const __CFDictionary **)&v13)
    || !scep_attr_has_val((const __CFDictionary *)v13, "20"))
  {
    BOOL v10 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFDataRef v8 = 0LL;
    CFDataRef v7 = 0LL;
  }

  else
  {
    __int16 v17 = 1801;
    CFArrayRef v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFDataRef v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 10LL);
    if (v7 && dictionary_array_value_1((const __CFDictionary *)v13, v7))
    {
      __int16 v17 = 1289;
      CFDataRef v8 = CFDataCreate(v6, bytes, 10LL);
      if (v8 && dictionary_array_value_1((const __CFDictionary *)v13, v8))
      {
        CFMutableSetRef Mutable = CFDataCreateMutable(v6, 0LL);
        BOOL v10 = 0LL;
      }

      else
      {
        BOOL v10 = 0LL;
        CFMutableSetRef Mutable = 0LL;
      }
    }

    else
    {
      BOOL v10 = 0LL;
      CFMutableSetRef Mutable = 0LL;
      CFDataRef v8 = 0LL;
    }
  }

  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (BasicX509) {
    CFRelease(BasicX509);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v10;
}

CFArrayRef SecSCEPVerifyReply(int a1, const __CFData *a2, CFTypeRef cf, CFErrorRef *a4)
{
  ValueAtIndex = (void *)cf;
  uint64_t v33 = *MEMORY[0x1895F89C0];
  CFTypeRef v29 = 0LL;
  CFTypeRef cfa = 0LL;
  CFTypeRef v27 = 0LL;
  CFDictionaryRef theDict = 0LL;
  values = 0LL;
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == SecCertificateGetTypeID())
  {
    values = ValueAtIndex;
    if (!ValueAtIndex) {
      goto LABEL_61;
    }
    goto LABEL_10;
  }

  CFTypeID v8 = CFGetTypeID(ValueAtIndex);
  if (v8 != CFArrayGetTypeID()) {
    goto LABEL_15;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)ValueAtIndex);
  if (Count >= 2)
  {
    BOOL v10 = (const __CFArray *)ValueAtIndex;
    CFIndex v11 = 1LL;
    goto LABEL_9;
  }

  if (Count != 1)
  {
LABEL_15:
    SecKeyRef v15 = 0LL;
    CFDataRef v16 = 0LL;
    __int16 v17 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFStringRef v19 = 0LL;
    ValueAtIndex = 0LL;
    goto LABEL_42;
  }

  BOOL v10 = (const __CFArray *)ValueAtIndex;
  CFIndex v11 = 0LL;
LABEL_9:
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v11);
  values = ValueAtIndex;
  if (!ValueAtIndex)
  {
LABEL_61:
    SecKeyRef v15 = 0LL;
    CFDataRef v16 = 0LL;
    __int16 v17 = 0LL;
    CFMutableSetRef Mutable = 0LL;
    CFStringRef v19 = 0LL;
    goto LABEL_42;
  }

LABEL_42:
  if (cfa) {
    CFRelease(cfa);
  }
  if (ValueAtIndex) {
    CFRelease(ValueAtIndex);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (v19) {
    CFRelease(v19);
  }
  return v17;
}

          int v26 = 0;
        }

CFArrayRef copy_signed_attr_printable_string_value(const __CFDictionary *a1, UInt8 a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  UInt8 bytes[9] = a2;
  CFDataRef v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 10LL);
  if (!v4) {
    return 0LL;
  }
  CFDataRef v5 = v4;
  unint64_t Value = (const __CFArray *)CFDictionaryGetValue(a1, v4);
  CFTypeID v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID()
      && CFArrayGetCount(v7) == 1
      && (ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v7, 0LL),
          uint64_t BytePtr = CFDataGetBytePtr(ValueAtIndex),
          unint64_t Length = CFDataGetLength(ValueAtIndex),
          Length >= 2)
      && *BytePtr == 19)
    {
      CFTypeID v7 = 0LL;
    }

    else
    {
      CFTypeID v7 = 0LL;
    }
  }

  CFRelease(v5);
  return v7;
}

uint64_t SecSCEPValidateCACertMessage( CFArrayRef theArray, CFDataRef theData, __CFData **a3, void *a4, void *a5)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  if (!theData)
  {
    ValueAtIndex = 0LL;
    goto LABEL_54;
  }

  CFIndex v7 = 0LL;
  CFArrayRef theArraya = (CFArrayRef)CFDataGetLength(theData);
  *((void *)&v9 + 1) = theArraya;
  *(void *)&__int128 v9 = (char *)theArraya - 16;
  uint64_t v8 = v9 >> 2;
  while (2)
  {
    if (v7 >= CFArrayGetCount(theArray))
    {
      uint64_t v35 = 4294899453LL;
LABEL_49:
      CFDataRef v36 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 md = 138412290;
        *(void *)&md[4] = theData;
        _os_log_impl( &dword_1804F4000,  v36,  OS_LOG_TYPE_DEFAULT,  "SCEP failed to find certificate matching CA fingerprint: %@",  md,  0xCu);
      }

      return v35;
    }

    ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(theArray, v7);
    switch(v8)
    {
      case 0LL:
        CFIndex v11 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v11, OS_LOG_TYPE_DEBUG, "MD5 fingerprint digest", md, 2u);
        }

        memset(md, 170, 16);
        CFTypeRef v12 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v13 = *((void *)ValueAtIndex + 3);
        CC_MD5(v12, v13, md);
        CFIndex v15 = 16LL;
        goto LABEL_40;
      case 1LL:
        CFDataRef v16 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEBUG, "SHA1 fingerprint digest", md, 2u);
        }

        SHA1Digest = SecCertificateGetSHA1Digest(ValueAtIndex);
        if (!SHA1Digest) {
          goto LABEL_45;
        }
        uint64_t v18 = SHA1Digest;
        CFRetain(SHA1Digest);
        goto LABEL_43;
      case 3LL:
        CFStringRef v19 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v19, OS_LOG_TYPE_DEBUG, "SHA224 fingerprint digest", md, 2u);
        }

        memset(md, 170, 28);
        CFDataRef v20 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v21 = *((void *)ValueAtIndex + 3);
        CC_SHA224(v20, v21, md);
        CFIndex v15 = 28LL;
        goto LABEL_40;
      case 4LL:
        uint64_t v23 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v23, OS_LOG_TYPE_DEBUG, "SHA256 fingerprint digest", md, 2u);
        }

        CFRange v24 = SecCertificateCopySHA256Digest(ValueAtIndex);
        goto LABEL_41;
      case 8LL:
        int v25 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v25, OS_LOG_TYPE_DEBUG, "SHA384 fingerprint digest", md, 2u);
        }

        int v26 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v27 = *((void *)ValueAtIndex + 3);
        *(void *)&__int128 v29 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&md[16] = v29;
        __int128 v81 = v29;
        *(_OWORD *)__int128 md = v29;
        CC_SHA384(v26, v27, md);
        CFIndex v15 = 48LL;
        goto LABEL_40;
      case 12LL:
        int v30 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl(&dword_1804F4000, v30, OS_LOG_TYPE_DEBUG, "SHA512 fingerprint digest", md, 2u);
        }

        CFTypeID v31 = (const void *)*((void *)ValueAtIndex + 2);
        uint64_t v32 = *((void *)ValueAtIndex + 3);
        if ((unint64_t)(v32 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002LL || v31 == 0LL)
        {
LABEL_46:
          uint64_t v18 = 0LL;
        }

        else
        {
          *(void *)&__int128 v34 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __int128 v81 = v34;
          __int128 v82 = v34;
          *(_OWORD *)__int128 md = v34;
          *(_OWORD *)&md[16] = v34;
          CC_SHA512(v31, v32, md);
          CFIndex v15 = 64LL;
LABEL_40:
          CFRange v24 = CFDataCreate(0LL, md, v15);
LABEL_41:
          uint64_t v18 = v24;
        }

        if (!v18) {
          goto LABEL_45;
        }
LABEL_43:
        if (!CFEqual(v18, theData))
        {
          CFRelease(v18);
LABEL_45:
          ++v7;
          continue;
        }

        if (ValueAtIndex) {
          CFRetain(ValueAtIndex);
        }
        CFRelease(v18);
LABEL_54:
        CFIndex Count = CFArrayGetCount(theArray);
        uint64_t v38 = (const CFArrayCallBacks *)MEMORY[0x189605228];
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
        CFIndex v40 = CFArrayGetCount(theArray);
        CFMutableArrayRef v41 = CFArrayCreateMutable(0LL, v40, v38);
        CFIndex v42 = CFArrayGetCount(theArray);
        CFMutableArrayRef v43 = CFArrayCreateMutable(0LL, v42, v38);
        CFTypeRef v44 = v43;
        if (Mutable) {
          BOOL v45 = v41 == 0LL;
        }
        else {
          BOOL v45 = 1;
        }
        if (v45 || v43 == 0LL)
        {
          uint64_t v35 = 4294899624LL;
          goto LABEL_63;
        }

        CFIndex v49 = 0LL;
        while (2)
        {
          if (v49 < CFArrayGetCount(theArray))
          {
            uint64_t v50 = CFArrayGetValueAtIndex(theArray, v49);
            if (v50)
            {
              uint64_t v51 = v50;
              int v52 = *((_DWORD *)v50 + 96) & 5;
              if (v52 == 1)
              {
                uint64_t v53 = v41;
              }

              else
              {
                uint64_t v53 = Mutable;
                if (v52 != 5)
                {
                  uint64_t v53 = v44;
                  if (v52 != 4) {
                    goto LABEL_81;
                  }
                }
              }

              CFArrayAppendValue(v53, v51);
            }

LABEL_81:
            ++v49;
            continue;
          }

          break;
        }

        if (!CFArrayGetCount(Mutable))
        {
          uint64_t v35 = 4294899565LL;
          if (!CFArrayGetCount(v41) || !CFArrayGetCount(v44))
          {
LABEL_63:
            CFTypeRef v47 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 md = 0;
              _os_log_impl( &dword_1804F4000,  v47,  OS_LOG_TYPE_DEFAULT,  "SCEP failed to find candidate RA certificates",  md,  2u);
            }

            if (ValueAtIndex) {
              CFRelease(ValueAtIndex);
            }
            if (Mutable) {
              CFRelease(Mutable);
            }
            if (v41) {
              CFRelease(v41);
            }
            if (v44)
            {
              CFIndex v48 = v44;
              goto LABEL_150;
            }

            return v35;
          }
        }

        ra_chain = scep_find_ra_chain(v41, theArray, ValueAtIndex);
        uint64_t v55 = scep_find_ra_chain(v44, theArray, ValueAtIndex);
        CFIndex v56 = 0LL;
        uint64_t v35 = 4294941020LL;
        theArrayb = v55;
        if (!ra_chain)
        {
          int v58 = 0LL;
          goto LABEL_105;
        }

        int v57 = v55;
        int v58 = 0LL;
        if (!v55) {
          goto LABEL_105;
        }
        CFNumberRef v59 = CFArrayGetValueAtIndex(ra_chain, 0LL);
        int v58 = v59;
        if (v59) {
          CFRetain(v59);
        }
        CFRange v60 = CFArrayGetValueAtIndex(v57, 0LL);
        CFIndex v56 = v60;
        if (v60) {
          CFRetain(v60);
        }
        if (ValueAtIndex)
        {
          CFRange v61 = ValueAtIndex;
          goto LABEL_127;
        }

        CFIndex v63 = CFArrayGetCount(ra_chain);
        CFRange v61 = (void *)CFArrayGetValueAtIndex(ra_chain, v63 - 1);
        CFIndex v64 = CFArrayGetCount(theArrayb);
        int v65 = (void *)CFArrayGetValueAtIndex(theArrayb, v64 - 1);
        if (!v61 || !v65)
        {
          if (v61 != v65) {
            goto LABEL_102;
          }
          if (!v61)
          {
            if (!a3) {
              goto LABEL_130;
            }
            goto LABEL_129;
          }

LABEL_126:
          CFRetain(v61);
LABEL_127:
          if (!a3) {
            goto LABEL_130;
          }
          CFRetain(v61);
LABEL_129:
          *a3 = (__CFData *)v61;
LABEL_130:
          if (a4)
          {
            if (v58) {
              CFRetain(v58);
            }
            *a4 = v58;
          }

          if (a5)
          {
            if (v56) {
              CFRetain(v56);
            }
            uint64_t v35 = 0LL;
            CFIndex v73 = 0LL;
            *a5 = v56;
          }

          else
          {
            uint64_t v35 = 0LL;
            CFIndex v73 = 0LL;
          }

LABEL_139:
          CFRelease(ra_chain);
          ValueAtIndex = (__CFData *)v61;
          goto LABEL_140;
        }

        if (CFEqual(v61, v65)) {
          goto LABEL_126;
        }
LABEL_102:
        int v66 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_impl(&dword_1804F4000, v66, OS_LOG_TYPE_DEFAULT, "signing/encryption CAs do not match", md, 2u);
        }

        uint64_t v35 = 4294899453LL;
LABEL_105:
        int v67 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 md = 0;
          _os_log_debug_impl( &dword_1804F4000,  v67,  OS_LOG_TYPE_DEBUG,  "SCEP did not find different RA certificates for signing/encryption; looking for one cert",
            md,
            2u);
        }

        BOOL v68 = scep_find_ra_chain(Mutable, theArray, ValueAtIndex);
        if (v68)
        {
          BOOL v69 = v68;
          if (!ValueAtIndex)
          {
            CFIndex v70 = CFArrayGetCount(v68);
            int v71 = (__CFData *)CFArrayGetValueAtIndex(v69, v70 - 1);
            ValueAtIndex = v71;
            if (v71) {
              CFRetain(v71);
            }
          }

          int v72 = CFArrayGetValueAtIndex(v69, 0LL);
          CFIndex v73 = v72;
          if (v72) {
            CFRetain(v72);
          }
          CFRelease(v69);
          if (a3)
          {
            if (ValueAtIndex) {
              CFRetain(ValueAtIndex);
            }
            *a3 = ValueAtIndex;
          }

          if (a4)
          {
            if (v73) {
              CFRetain(v73);
            }
            uint64_t v35 = 0LL;
            *a4 = v73;
          }

          else
          {
            uint64_t v35 = 0LL;
          }
        }

        else
        {
          CFIndex v73 = 0LL;
        }

        CFRange v61 = ValueAtIndex;
        if (ra_chain) {
          goto LABEL_139;
        }
LABEL_140:
        if (theArrayb) {
          CFRelease(theArrayb);
        }
        CFRelease(Mutable);
        CFRelease(v41);
        CFRelease(v44);
        if (ValueAtIndex) {
          CFRelease(ValueAtIndex);
        }
        if (v73) {
          CFRelease(v73);
        }
        if (v58) {
          CFRelease(v58);
        }
        if (v56)
        {
          CFIndex v48 = (const __CFArray *)v56;
LABEL_150:
          CFRelease(v48);
        }

        return v35;
      default:
        CFRange v62 = (os_log_s *)secLogObjForScope("SecError");
        uint64_t v35 = 4294899481LL;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 md = 134217984;
          *(void *)&md[4] = theArraya;
          _os_log_impl( &dword_1804F4000,  v62,  OS_LOG_TYPE_DEFAULT,  "SCEP failed to find algorithm to match CA fingerprint length: %ld",  md,  0xCu);
        }

        goto LABEL_49;
    }
  }

__CFArray *scep_find_ra_chain(CFArrayRef theArray, const __CFArray *a2, void *a3)
{
  CFIndex v5 = 0LL;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  CFArrayRef v6 = (const CFArrayCallBacks *)MEMORY[0x189605228];
  values = a3;
  while (v5 < CFArrayGetCount(theArray))
  {
    CFIndex Count = CFArrayGetCount(a2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, Count + 1, v6);
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
    CFArrayAppendValue(Mutable, ValueAtIndex);
    v26.CFIndex length = CFArrayGetCount(a2);
    v26.CFIndex location = 0LL;
    CFArrayAppendArray(Mutable, a2, v26);
    SecTrustRef trust = 0LL;
    if (SecTrustCreateWithCertificates(Mutable, 0LL, &trust))
    {
      BOOL v10 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v22 = ValueAtIndex;
        _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, "SCEP failed to create trust for %@", buf, 0xCu);
      }

      if (Mutable) {
        goto LABEL_19;
      }
    }

    else
    {
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (values)
      {
        CFIndex v11 = CFArrayCreate(0LL, (const void **)&values, 1LL, v6);
        SecTrustSetAnchorCertificates(trust, v11);
        if (v11) {
          CFRelease(v11);
        }
      }

      CFTypeRef v12 = SecTrustCopyCertificateChain(trust);
      if (v12)
      {
        CFMutableArrayRef Mutable = v12;
        uint64_t v13 = values;
        if (!values) {
          return Mutable;
        }
        CFIndex v14 = CFArrayGetCount(v12);
        CFIndex v15 = CFArrayGetValueAtIndex(Mutable, v14 - 1);
        if (v15)
        {
          if (CFEqual(v13, v15)) {
            return Mutable;
          }
        }

        CFDataRef v16 = (os_log_s *)secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v22 = ValueAtIndex;
          __int16 v23 = 2112;
          CFRange v24 = values;
          _os_log_impl( &dword_1804F4000,  v16,  OS_LOG_TYPE_DEFAULT,  "failed to create chain from %@ to ca cert %@",  buf,  0x16u);
        }

CFMutableDataRef SecSCEPGetCertInitial( uint64_t a1, const __CFArray *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5, const void *a6)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a4) {
    return 0LL;
  }
  CertificateRequestSubject = SecGenerateCertificateRequestSubject(a1, a2);
  if (!CertificateRequestSubject) {
    return 0LL;
  }
  CFIndex v11 = CertificateRequestSubject;
  CFTypeRef v12 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (!Mutable)
  {
    CFRelease(v11);
    return 0LL;
  }

  CFIndex v14 = Mutable;
  CFIndex v15 = filterRecipients(a6);
  if (SecCMSCreateEnvelopedData(v15, a3, v11, (uint64_t)v14))
  {
    CFMutableDataRef v20 = 0LL;
    CFDataRef v17 = 0LL;
  }

  else
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v12, 3LL, a4);
    __int16 v23 = 521;
    CFDataRef v17 = CFDataCreate(v12, bytes, 10LL);
    if (v17 && (uint64_t v18 = printable_string_data(2uLL, "20")) != 0LL)
    {
      CFStringRef v19 = v18;
      CFDictionarySetValue(MutableCopy, v17, v18);
      CFRelease(v17);
      CFRelease(v19);
      generate_sender_nonce(MutableCopy);
      CFMutableDataRef v20 = CFDataCreateMutable(v12, 0LL);
      if (SecCMSCreateSignedData(a5, v14, a3, MutableCopy, (uint64_t)v20) && v20)
      {
        CFRelease(v20);
        CFMutableDataRef v20 = 0LL;
      }

      CFDataRef v17 = 0LL;
      if (!MutableCopy) {
        goto LABEL_10;
      }
    }

    else
    {
      CFMutableDataRef v20 = 0LL;
      if (!MutableCopy) {
        goto LABEL_10;
      }
    }

    CFRelease(MutableCopy);
  }

uint64_t SecCopyEncryptedToServerKey(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = 0LL;
  CFIndex v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecCopyEncryptedToServerKey_block_invoke;
  v5[3] = &unk_1896744F0;
  void v5[5] = a2;
  void v5[6] = a3;
  void v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPublicKeyDescriptor) {
    __SecCopyEncryptedToServerKey_block_invoke((uint64_t)v5);
  }
  else {
    SecError(-50, a3, @"Not an EC Public Key object, sorry can't do.");
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecCopyEncryptedToServerKey_block_invoke(uint64_t a1)
{
  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v21 = v2;
  __int128 v22 = v2;
  ccaes_gcm_encrypt_mode();
  InitServerECIES();
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFIndex v20 = ccecies_encrypt_gcm_ciphertext_size();
  CFDataRef v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFDataSetLength(Mutable, v20);
  if (!Mutable)
  {
    SecError(-108, *(__CFString ***)(a1 + 48), @"failed to create data");
    return;
  }

  Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
  CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  uint64_t v7 = ccecies_encrypt_gcm();
  size_t v8 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  uint64_t v9 = *(__CFString ***)(a1 + 48);
  if (Length + v8 + 16 == v20)
  {
    ccder_sizeof();
    ccder_sizeof();
    ccder_sizeof();
    CFIndex v10 = ccder_sizeof();
    CFIndex v11 = CFDataCreateMutable(v4, 0LL);
    CFDataSetLength(v11, v10);
    if (v11)
    {
      uint64_t v18 = v7;
      CFTypeRef cf = Mutable;
      CFDataGetMutableBytePtr(v11);
      CFDataGetLength(v11);
      CFTypeRef v12 = (_OWORD *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      uint64_t v13 = (void *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      CFIndex v14 = (void *)ccder_encode_body_nocopy();
      ccder_encode_tl();
      if (ccder_encode_constructed_tl())
      {
        CFRetain(v11);
        CFRelease(v11);
        memcpy(v14, MutableBytePtr, v8);
        memcpy(v13, &MutableBytePtr[v8], Length);
        *CFTypeRef v12 = *(_OWORD *)&MutableBytePtr[v8 + Length];
        if ((_DWORD)v18)
        {
          SecError(-909, *(__CFString ***)(a1 + 48), @"ccecies_encrypt_gcm failed %d", v18);
        }

        else
        {
          uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
          if (*(__CFData **)(v15 + 24) != v11)
          {
            CFRetain(v11);
            CFDataRef v16 = *(const void **)(v15 + 24);
            if (v16) {
              CFRelease(v16);
            }
            *(void *)(v15 + 24) = v11;
          }
        }

        CFRelease(cf);
        CFDataRef v17 = v11;
        goto LABEL_11;
      }

      SecError(-50, v9, @"Encoding failed");
      CFRelease(v11);
    }

    else
    {
      SecError(-108, v9, @"failed to create data", &v20, MutableBytePtr);
    }
  }

  else
  {
    SecError(-26276, v9, @"Allocation mismatch", &v20, MutableBytePtr);
  }

  CFDataRef v17 = Mutable;
LABEL_11:
  CFRelease(v17);
}

uint64_t InitServerECIES()
{
  return ccecies_encrypt_gcm_setup();
}

uint64_t SecCopyDecryptedForServer(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecCopyDecryptedForServer_block_invoke;
  v5[3] = &unk_189674518;
  void v5[5] = a2;
  void v5[6] = a3;
  void v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPrivateKeyDescriptor) {
    __SecCopyDecryptedForServer_block_invoke((uint64_t)v5);
  }
  else {
    SecError(-50, a3, @"Not an EC Full Key object, sorry can't do.");
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void __SecCopyDecryptedForServer_block_invoke(uint64_t a1)
{
  CFIndex v25 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v22 = v2;
  __int128 v23 = v2;
  ccaes_gcm_decrypt_mode();
  InitServerECIES();
  memset(v21, 170, sizeof(v21));
  CFDataRef v4 = *(const __CFData **)(a1 + 40);
  uint64_t v3 = *(__CFString ***)(a1 + 48);
  uint64_t BytePtr = CFDataGetBytePtr(v4);
  uint64_t v6 = &BytePtr[CFDataGetLength(v4)];
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  ccder_decode_sequence_tl();
  uint64_t v7 = (const void *)ccder_decode_tl();
  uint64_t v8 = (const void *)ccder_decode_tl();
  uint64_t v9 = ccder_decode_tl();
  size_t v10 = v9 + v21[0];
  if (!v9) {
    size_t v10 = 0LL;
  }
  if ((const UInt8 *)v10 != v6)
  {
    SecError(-50, v3, @"Blob failed to decode");
    return;
  }

  if (v7)
  {
    CFIndex v11 = (const void *)v9;
    if (v8 && v9 != 0)
    {
      uint64_t v13 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
      CFDataSetLength(Mutable, v21[1] + v21[2] + v21[0]);
      if (!Mutable)
      {
        SecError(-108, *(__CFString ***)(a1 + 48), @"failed to create data");
        return;
      }

      Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
      memcpy(MutableBytePtr, v7, v21[2]);
      memcpy(&MutableBytePtr[v21[2]], v8, v21[1]);
      memcpy(&MutableBytePtr[v21[2] + v21[1]], v11, v21[0]);
      CFIndex v25 = ccecies_decrypt_gcm_plaintext_size();
      CFDataRef v16 = CFDataCreateMutable(v13, 0LL);
      CFDataSetLength(v16, v25);
      CFIndex v20 = CFDataGetMutableBytePtr(v16);
      uint64_t v17 = ccecies_decrypt_gcm();
      if ((_DWORD)v17)
      {
        SecError(-909, *(__CFString ***)(a1 + 48), @"ccecies_decrypt_gcm failed %d", v17, v20);
        if (!v16) {
          goto LABEL_18;
        }
      }

      else
      {
        uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 8LL);
        CFStringRef v19 = *(__CFData **)(v18 + 24);
        if (v19 != v16)
        {
          if (!v16 || (CFRetain(v16), (CFStringRef v19 = *(__CFData **)(v18 + 24)) != 0LL)) {
            CFRelease(v19);
          }
          *(void *)(v18 + 24) = v16;
        }

        if (!v16) {
          goto LABEL_18;
        }
      }

      CFRelease(v16);
LABEL_18:
      CFRelease(Mutable);
    }
  }

uint64_t SecCopyEncryptedToServer(__SecTrust *a1, uint64_t a2, __CFString **a3)
{
  SecKeyRef v5 = SecTrustCopyKey(a1);
  if (v5)
  {
    SecKeyRef v6 = v5;
    uint64_t v7 = SecCopyEncryptedToServerKey((uint64_t)v5, a2, a3);
    CFRelease(v6);
    return v7;
  }

  else
  {
    SecError(-25308, a3, @"Failed to get key out of trust ref, was it evaluated?");
    return 0LL;
  }

void SecAddSharedWebCredential( CFStringRef fqdn, CFStringRef account, CFStringRef password, void *completionHandler)
{
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  uint64_t v8 = 0LL;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  SecError(-50, &v8, @"SharedWebCredentials not supported on this platform");
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __SecAddSharedWebCredential_block_invoke;
  unint64_t v6[3] = &unk_189674540;
  void v6[4] = completionHandler;
  void v6[5] = v7;
  dispatch_async(global_queue, v6);
  _Block_object_dispose(v7, 8);
}

void __SecAddSharedWebCredential_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  }
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v3) {
    CFRelease(v3);
  }
}

void SecRequestSharedWebCredential(CFStringRef fqdn, CFStringRef account, void *completionHandler)
{
  v6[0] = 0LL;
  v6[1] = v6;
  v6[2] = 0x2000000000LL;
  uint64_t v7 = 0LL;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  SecError(-50, &v7, @"SharedWebCredentials not supported on this platform");
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __SecRequestSharedWebCredential_block_invoke;
  v5[3] = &unk_189674568;
  void v5[4] = completionHandler;
  void v5[5] = v6;
  dispatch_async(global_queue, v5);
  _Block_object_dispose(v6, 8);
}

void __SecRequestSharedWebCredential_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t, void, void))(v2 + 16))( v2,  0LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  }
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v3) {
    CFRelease(v3);
  }
}

CFStringRef SecCreateSharedWebCredentialPassword(void)
{
  uint64_t v15 = 0LL;
  CFCharacterSetRef v0 = CFCharacterSetCreateWithCharactersInString(0LL, @"abcdefghkmnopqrstuvwxyz");
  CFCharacterSetRef v1 = CFCharacterSetCreateWithCharactersInString(0LL, @"ABCDEFGHJKLMNPQRSTUVWXYZ");
  CFCharacterSetRef v2 = CFCharacterSetCreateWithCharactersInString(0LL, @"3456789");
  int v13 = 4;
  int valuePtr = 3;
  int v12 = 12;
  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberIntType, &v13);
  CFNumberRef v5 = CFNumberCreate(0LL, kCFNumberIntType, &v12);
  CFMutableDataRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, v0);
  CFArrayAppendValue(Mutable, v1);
  CFArrayAppendValue(Mutable, v2);
  uint64_t v7 = CFDictionaryCreateMutable(0LL, 0LL, 0LL, 0LL);
  CFDictionaryAddValue( v7,  (const void *)kSecPasswordAllowedCharactersKey,  @"abcdefghkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789");
  CFDictionaryAddValue(v7, (const void *)kSecPasswordRequiredCharactersKey, Mutable);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordGroupSize, v3);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordNumberOfGroups, v4);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordSeparator, @"-");
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMaxLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMinLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordDefaultForType, @"false");
  CFRelease(v0);
  CFRelease(v1);
  CFRelease(v2);
  CFRelease(v3);
  CFRelease(v4);
  CFRelease(v5);
  uint64_t v8 = SecPasswordGenerate(0, &v15, v7);
  CFRelease(Mutable);
  CFRelease(v7);
  if (v15 || !v8)
  {
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFIndex v11 = 0;
      _os_log_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEFAULT,  "SecPasswordGenerate failed to generate a password for SecCreateSharedWebCredentialPassword.",  v11,  2u);
    }

    return 0LL;
  }

  return v8;
}

__CFData *SecRecreateSignatureWithDERAlgorithmId(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  CFMutableDataRef Mutable = 0LL;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1 && a2)
  {
    if (SecKeyGetAlgorithmId(a1) == 3)
    {
      uint64_t v7 = (uint64_t *)MEMORY[0x186DFEF8C]();
      uint64_t v8 = *v7;
      size_t v9 = 8 * *v7;
      MEMORY[0x1895F8858](v7);
      unint64_t v10 = (v9 + 15) & 0xFFFFFFFFFFFFFFF0LL;
      if (v8)
      {
        CFIndex v11 = memset((char *)&v18 - v10, 170, v9);
        MEMORY[0x1895F8858](v11);
        memset((char *)&v18 - v10, 170, v9);
      }

      uint64_t v19 = a3 + a4;
      ccder_decode_sequence_tl();
      mp_decode_forced_uint();
      uint64_t v12 = mp_decode_forced_uint();
      if (v12) {
        BOOL v13 = v19 == v12;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13) {
        return 0LL;
      }
      ccder_sizeof_integer();
      ccder_sizeof_integer();
      unint64_t v14 = ccder_sizeof();
      if (v14 < a4 || v14 > a4 + 5) {
        return 0LL;
      }
      CFIndex v17 = v14;
      CFMutableDataRef Mutable = CFDataCreateMutable(0LL, v14);
      CFDataSetLength(Mutable, v17);
      CFDataGetMutableBytePtr(Mutable);
      ccder_encode_integer();
      ccder_encode_integer();
      if (!ccder_encode_constructed_tl() && Mutable)
      {
        CFRelease(Mutable);
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return Mutable;
}

uint64_t __SecTrustGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecTrustCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SecTrustRef: %p>", a1);
}

CFStringRef SecTrustCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<SecTrustRef: %p>", a1);
}

uint64_t SecTrustCopyInputCertificates(uint64_t a1, void *a2)
{
  uint64_t v2 = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v8 = 0LL;
    size_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = 0LL;
    CFNumberRef v4 = *(dispatch_queue_s **)(a1 + 136);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustCopyInputCertificates_block_invoke;
    void v7[3] = &unk_189674750;
    UInt8 v7[4] = &v8;
    void v7[5] = a1;
    dispatch_sync(v4, v7);
    uint64_t v5 = v9[3];
    if (v5)
    {
      uint64_t v2 = 0LL;
      *a2 = v5;
    }

    else
    {
      uint64_t v2 = 4294967188LL;
    }

    _Block_object_dispose(&v8, 8);
  }

  return v2;
}

CFArrayRef __SecTrustCopyInputCertificates_block_invoke(uint64_t a1)
{
  CFArrayRef result = CFArrayCreateCopy(0LL, *(CFArrayRef *)(*(void *)(a1 + 40) + 16LL));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t SecTrustAddToInputCertificates(uint64_t a1, const void *a2)
{
  uint64_t v2 = 4294967246LL;
  if (a1 && a2)
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2000000000LL;
    uint64_t v22 = 0LL;
    uint64_t v5 = *(dispatch_queue_s **)(a1 + 136);
    uint64_t v6 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustAddToInputCertificates_block_invoke;
    block[3] = &unk_189674778;
    block[4] = &v19;
    void block[5] = a1;
    dispatch_sync(v5, block);
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)v20[3]);
      context[0] = v6;
      context[1] = 0x40000000LL;
      context[2] = __SecTrustAddToInputCertificates_block_invoke_2;
      context[3] = &unk_1896747A0;
      void context[4] = &v19;
      v28.CFIndex length = CFArrayGetCount((CFArrayRef)a2);
      v28.CFIndex location = 0LL;
      CFArrayApplyFunction((CFArrayRef)a2, v28, (CFArrayApplierFunction)apply_block_1_11979, context);
      CFIndex v9 = CFArrayGetCount((CFArrayRef)v20[3]);
      if (v9 != CFArrayGetCount((CFArrayRef)a2) + Count)
      {
LABEL_11:
        unint64_t v14 = (const void *)v20[3];
        if (v14)
        {
          v20[3] = 0LL;
          CFRelease(v14);
        }

        uint64_t v2 = 4294967246LL;
        goto LABEL_14;
      }
    }

    else
    {
      CFTypeID v10 = CFGetTypeID(a2);
      if (v10 != SecCertificateGetTypeID())
      {
        BOOL v13 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: certificates contains unsupported value type",  buf,  2u);
        }

        goto LABEL_11;
      }

      CFArrayAppendValue((CFMutableArrayRef)v20[3], a2);
    }

    uint64_t v11 = *(dispatch_queue_s **)(a1 + 136);
    v16[0] = v6;
    v16[1] = 0x40000000LL;
    _OWORD v16[2] = __SecTrustAddToInputCertificates_block_invoke_47;
    unint64_t v16[3] = &unk_1896747C8;
    void v16[4] = &v19;
    void v16[5] = a1;
    dispatch_sync(v11, v16);
    uint64_t v12 = *(dispatch_queue_s **)(a1 + 136);
    *(void *)__int128 buf = v6;
    uint64_t v24 = 0x40000000LL;
    CFIndex v25 = __SecTrustSetNeedsEvaluation_block_invoke;
    unint64_t v26 = &__block_descriptor_tmp_49_11982;
    uint64_t v27 = a1;
    dispatch_sync(v12, buf);
    uint64_t v2 = 0LL;
LABEL_14:
    _Block_object_dispose(&v19, 8);
  }

  return v2;
}

CFMutableArrayRef __SecTrustAddToInputCertificates_block_invoke(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutableCopy(0LL, 0LL, *(CFArrayRef *)(*(void *)(a1 + 40) + 16LL));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void __SecTrustAddToInputCertificates_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == SecCertificateGetTypeID())
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), cf);
  }

  else
  {
    uint64_t v5 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: certificates array contains non-certificate value",  v6,  2u);
    }
  }

uint64_t apply_block_1_11979(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __SecTrustAddToInputCertificates_block_invoke_47(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 16);
  if (v3)
  {
    *(void *)(v2 + 16) = 0LL;
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }

  *(void *)(v2 + 16) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void SecTrustSetNeedsEvaluation(uint64_t a1)
{
  if (a1)
  {
    CFCharacterSetRef v1 = *(dispatch_queue_s **)(a1 + 136);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    block[3] = &__block_descriptor_tmp_49_11982;
    block[4] = a1;
    dispatch_sync(v1, block);
  }

OSStatus SecTrustSetAnchorCertificatesOnly(SecTrustRef trust, Boolean anchorCertificatesOnly)
{
  if (!trust) {
    return -50;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  uint64_t v5 = (dispatch_queue_s *)*((void *)trust + 17);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = trust;
  dispatch_sync(v5, block);
  uint64_t v6 = (dispatch_queue_s *)*((void *)trust + 17);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustSetAnchorCertificatesOnly_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_50_11987;
  void v8[4] = trust;
  Boolean v9 = anchorCertificatesOnly;
  dispatch_sync(v6, v8);
  return 0;
}

uint64_t __SecTrustSetAnchorCertificatesOnly_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 116LL) = *(_BYTE *)(result + 40) != 0;
  return result;
}

OSStatus SecTrustSetAnchorCertificates(SecTrustRef trust, CFArrayRef anchorCertificates)
{
  if (trust)
  {
    uint64_t v4 = MEMORY[0x1895F87A8];
    uint64_t v5 = (dispatch_queue_s *)*((void *)trust + 17);
    blocCFIndex k = MEMORY[0x1895F87A8];
    p_blocCFIndex k = 0x40000000LL;
    uint64_t v22 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    __int128 v23 = &__block_descriptor_tmp_49_11982;
    SecTrustRef v24 = trust;
    dispatch_sync(v5, &block);
    blocCFIndex k = 0LL;
    p_blocCFIndex k = (uint64_t)&block;
    uint64_t v22 = 0x2000000000LL;
    __int128 v23 = 0LL;
    if (!anchorCertificates) {
      goto LABEL_15;
    }
    CFTypeID v6 = CFGetTypeID(anchorCertificates);
    if (v6 == CFArrayGetTypeID())
    {
      uint64_t Count = CFArrayGetCount(anchorCertificates);
      CFMutableDataRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]);
      *(void *)(p_block + 24) = Mutable;
      if (!Mutable)
      {
        OSStatus v15 = -108;
        goto LABEL_21;
      }

      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(anchorCertificates, i);
          if (ValueAtIndex && (v11 = ValueAtIndex, CFTypeID v12 = CFGetTypeID(ValueAtIndex), v12 == SecCertificateGetTypeID()))
          {
            CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v11);
          }

          else
          {
            BOOL v13 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( &dword_1804F4000,  v13,  OS_LOG_TYPE_DEFAULT,  "BUG IN SECURITY CLIENT: anchorCertificates array contains non-certificate value",  buf,  2u);
            }
          }
        }

        CFMutableDataRef Mutable = *(const __CFArray **)(p_block + 24);
        uint64_t v4 = MEMORY[0x1895F87A8];
      }

      if (Count == CFArrayGetCount(Mutable))
      {
LABEL_15:
        unint64_t v14 = (dispatch_queue_s *)*((void *)trust + 17);
        v18[0] = v4;
        v18[1] = 0x40000000LL;
        void v18[2] = __SecTrustSetAnchorCertificates_block_invoke;
        void v18[3] = &unk_189674830;
        v18[4] = &block;
        void v18[5] = trust;
        v18[6] = anchorCertificates;
        dispatch_sync(v14, v18);
        OSStatus v15 = 0;
LABEL_21:
        _Block_object_dispose(&block, 8);
        return v15;
      }

      CFDataRef v16 = *(const void **)(p_block + 24);
      if (v16) {
        CFRelease(v16);
      }
    }

    OSStatus v15 = -50;
    goto LABEL_21;
  }

  return -50;
}

void __SecTrustSetAnchorCertificates_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  CFNumberRef v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = a1[5];
  }

  *(void *)(v2 + 24) = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  *(_BYTE *)(a1[5] + 116LL) = a1[6] != 0LL;
}

OSStatus SecTrustCopyCustomAnchorCertificates(SecTrustRef trust, CFArrayRef *anchors)
{
  OSStatus v2 = -50;
  if (trust && anchors)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    uint64_t v10 = 0LL;
    uint64_t v4 = (dispatch_queue_s *)*((void *)trust + 17);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __SecTrustCopyCustomAnchorCertificates_block_invoke;
    void v6[3] = &unk_189674858;
    void v6[4] = &v7;
    void v6[5] = trust;
    dispatch_sync(v4, v6);
    *anchors = (CFArrayRef)v8[3];
    _Block_object_dispose(&v7, 8);
    return 0;
  }

  return v2;
}

CFArrayRef __SecTrustCopyCustomAnchorCertificates_block_invoke(CFArrayRef result)
{
  CFCharacterSetRef v1 = *(const __CFArray **)(*((void *)result + 5) + 24LL);
  if (v1)
  {
    CFArrayRef v2 = result;
    CFMutableArrayRef result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v1);
    *(void *)(*(void *)(*((void *)v2 + 4) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t SecTrustFlushResponseCache(CFTypeRef *a1)
{
  return SecTrustResetSettings(10LL, a1);
}

uint64_t SecTrustResetSettings(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0LL;
  uint64_t v4 = _os_activity_create(&dword_1804F4000, "SecTrustResetSettings", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (gTrustd && (uint64_t v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 240)) != 0LL)
  {
    uint64_t v6 = v5(a1, &cf);
  }

  else
  {
    uint64_t v13 = 0LL;
    unint64_t v14 = &v13;
    uint64_t v15 = 0x2000000000LL;
    char v16 = 0;
    UInt8 v10[4] = &v13;
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = __int_to_BOOL_error_request_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_453;
    int v12 = a1;
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 0x40000000LL;
    _OWORD v10[2] = __int_to_BOOL_error_request_block_invoke_2;
    unint64_t v10[3] = &unk_189675D80;
    securityd_send_sync_and_do(0x82u, &cf, (uint64_t)v11, (uint64_t)v10);
    uint64_t v6 = *((_BYTE *)v14 + 24) != 0;
    _Block_object_dispose(&v13, 8);
  }

  os_release(v4);
  if (a2)
  {
    *a2 = cf;
  }

  else if (cf)
  {
    CFRelease(cf);
  }

  os_activity_scope_leave(&state);
  return v6;
}

OSStatus SecTrustSetSignedCertificateTimestamps(SecTrustRef trust, CFArrayRef sctArray)
{
  if (!trust) {
    return -50;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  uint64_t v5 = (dispatch_queue_s *)*((void *)trust + 17);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = trust;
  dispatch_sync(v5, block);
  uint64_t v6 = (dispatch_queue_s *)*((void *)trust + 17);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustSetSignedCertificateTimestamps_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_54_11997;
  void v8[4] = trust;
  void v8[5] = sctArray;
  dispatch_sync(v6, v8);
  return 0;
}

void __SecTrustSetSignedCertificateTimestamps_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFCharacterSetRef v1 = *(const void **)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 48);
  if (v3 != v1)
  {
    *(void *)(v2 + 4_Block_object_dispose(&a9, 8) = v1;
  }

uint64_t SecTrustSetTrustedLogs(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  uint64_t v5 = *(dispatch_queue_s **)(a1 + 136);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = a1;
  dispatch_sync(v5, block);
  uint64_t v6 = *(dispatch_queue_s **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustSetTrustedLogs_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_55_11998;
  void v8[4] = a1;
  void v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0LL;
}

void __SecTrustSetTrustedLogs_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFCharacterSetRef v1 = *(const void **)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 56);
  if (v3 != v1)
  {
    *(void *)(v2 + 56) = v1;
  }

OSStatus SecTrustSetVerifyDate(SecTrustRef trust, CFDateRef verifyDate)
{
  OSStatus result = -50;
  if (trust && verifyDate)
  {
    CFTypeID v5 = CFGetTypeID(verifyDate);
    if (v5 == CFDateGetTypeID())
    {
      uint64_t v6 = MEMORY[0x1895F87A8];
      uint64_t v7 = (dispatch_queue_s *)*((void *)trust + 17);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
      block[3] = &__block_descriptor_tmp_49_11982;
      block[4] = trust;
      dispatch_sync(v7, block);
      uint64_t v8 = (dispatch_queue_s *)*((void *)trust + 17);
      v9[0] = v6;
      v9[1] = 0x40000000LL;
      _OWORD v9[2] = __SecTrustSetVerifyDate_block_invoke;
      v9[3] = &__block_descriptor_tmp_56_12001;
      void v9[4] = trust;
      void v9[5] = verifyDate;
      dispatch_sync(v8, v9);
      return 0;
    }

    else
    {
      return -50;
    }
  }

  return result;
}

void __SecTrustSetVerifyDate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFCharacterSetRef v1 = *(const void **)(a1 + 40);
  CFNumberRef v3 = *(const void **)(v2 + 64);
  if (v3 != v1)
  {
    *(void *)(v2 + 64) = v1;
  }

uint64_t SecTrustSetKeychainsAllowed(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  CFTypeID v5 = *(dispatch_queue_s **)(a1 + 136);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = a1;
  dispatch_sync(v5, block);
  uint64_t v6 = *(dispatch_queue_s **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustSetKeychainsAllowed_block_invoke;
  unint64_t v8[3] = &__block_descriptor_tmp_61_12009;
  void v8[4] = a1;
  char v9 = a2;
  dispatch_sync(v6, v8);
  return 0LL;
}

uint64_t __SecTrustSetKeychainsAllowed_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 117LL) = *(_BYTE *)(result + 40) != 0;
  return result;
}

uint64_t SecTrustGetKeychainsAllowed(uint64_t a1, _BYTE *a2)
{
  uint64_t result = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a2 = *(_BYTE *)(a1 + 117);
    }
  }

  return result;
}

OSStatus SecTrustCopyPolicies(SecTrustRef trust, CFArrayRef *policies)
{
  OSStatus v2 = -50;
  if (trust && policies)
  {
    uint64_t v8 = 0LL;
    char v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    uint64_t v11 = 0LL;
    uint64_t v4 = (dispatch_queue_s *)*((void *)trust + 17);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustCopyPolicies_block_invoke;
    void v7[3] = &unk_189674990;
    UInt8 v7[4] = &v8;
    void v7[5] = trust;
    dispatch_sync(v4, v7);
    CFTypeID v5 = (const __CFArray *)v9[3];
    if (v5)
    {
      OSStatus v2 = 0;
      *CFArrayRef policies = v5;
    }

    else
    {
      OSStatus v2 = -108;
    }

    _Block_object_dispose(&v8, 8);
  }

  return v2;
}

CFArrayRef __SecTrustCopyPolicies_block_invoke(uint64_t a1)
{
  CFArrayRef result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], *(CFArrayRef *)(*(void *)(a1 + 40) + 32LL));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

OSStatus SecTrustSetNetworkFetchAllowed(SecTrustRef trust, Boolean allowFetch)
{
  if (!trust) {
    return -50;
  }
  int v2 = allowFetch;
  uint64_t v15 = 0LL;
  char v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  int v18 = 0;
  uint64_t v11 = 0LL;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 1;
  uint64_t v4 = (dispatch_queue_s *)*((void *)trust + 17);
  uint64_t v5 = MEMORY[0x1895F87A8];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNetworkFetchAllowed_block_invoke;
  block[3] = &unk_1896749C0;
  void block[5] = &v15;
  void block[6] = trust;
  Boolean v10 = allowFetch;
  block[4] = &v11;
  dispatch_sync(v4, block);
  if (v2 && !*((_BYTE *)v12 + 24))
  {
    uint64_t v6 = (dispatch_queue_s *)*((void *)trust + 17);
    v19[0] = v5;
    v19[1] = 0x40000000LL;
    uint64_t v19[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    unint64_t v19[3] = &__block_descriptor_tmp_49_11982;
    void v19[4] = trust;
    dispatch_sync(v6, v19);
  }

  OSStatus v7 = *((_DWORD *)v16 + 6);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v7;
}

uint64_t __SecTrustSetNetworkFetchAllowed_block_invoke(uint64_t a1)
{
  int v2 = SecTrustCopyOptionsFromPolicies(*(const __CFArray **)(*(void *)(a1 + 48) + 32LL));
  if (v2)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    CFRelease(v2);
  }

  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(const __CFArray **)(v3 + 32);
  if (*(_BYTE *)(a1 + 56))
  {
    uint64_t result = SecTrustRemoveOptionInPolicies(*(const void **)(v3 + 32), @"NoNetworkAccess");
  }

  else if (v4 && (CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(v3 + 32)), v6 == CFArrayGetTypeID()))
  {
    CFIndex v7 = 0LL;
    uint64_t v8 = (const void *)*MEMORY[0x189604DE8];
    while (1)
    {
      if (CFArrayGetCount(v4) <= v7)
      {
        uint64_t result = 0LL;
        goto LABEL_15;
      }

      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v4, v7);
      if (!ValueAtIndex) {
        goto LABEL_16;
      }
      Boolean v10 = ValueAtIndex;
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, ValueAtIndex[4]);
      if (!MutableCopy) {
        break;
      }
      int v12 = MutableCopy;
      CFDictionarySetValue(MutableCopy, @"NoNetworkAccess", v8);
      CFDictionaryRef v13 = v10[4];
      if (v13)
      {
        UInt8 v10[4] = 0LL;
        CFRelease(v13);
      }

      UInt8 v10[4] = v12;
      ++v7;
    }

    uint64_t result = 4294967188LL;
  }

  else
  {
LABEL_16:
    uint64_t result = 4294941020LL;
  }

__CFArray *SecTrustCopyOptionsFromPolicies(const __CFArray *a1)
{
  CFMutableDataRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  for (CFIndex i = 0LL; CFArrayGetCount(a1) > i; ++i)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, i);
    unint64_t Value = CFDictionaryGetValue(ValueAtIndex[4], @"NoNetworkAccess");
    if (Value) {
      CFArrayAppendValue(Mutable, Value);
    }
  }

  if (!CFArrayGetCount(Mutable) && Mutable)
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t SecTrustRemoveOptionInPolicies(const void *a1, const void *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 != CFArrayGetTypeID()) {
      return 4294941020LL;
    }
    for (CFIndex i = 0LL; ; ++i)
    {
      if (CFArrayGetCount((CFArrayRef)a1) <= i) {
        return 0LL;
      }
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
      if (!ValueAtIndex) {
        return 4294941020LL;
      }
      CFIndex v7 = ValueAtIndex;
      if (CFDictionaryGetValue(ValueAtIndex[4], a2))
      {
        CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v7[4]);
        if (!MutableCopy) {
          return 4294967188LL;
        }
        char v9 = MutableCopy;
        CFDictionaryRemoveValue(MutableCopy, a2);
        CFDictionaryRef v10 = v7[4];
        if (v10)
        {
          UInt8 v7[4] = 0LL;
          CFRelease(v10);
        }

        UInt8 v7[4] = v9;
      }
    }
  }

  return 4294941020LL;
}

OSStatus SecTrustGetNetworkFetchAllowed(SecTrustRef trust, Boolean *allowFetch)
{
  OSStatus v2 = -50;
  if (trust && allowFetch)
  {
    uint64_t v12 = 0LL;
    CFDictionaryRef v13 = &v12;
    uint64_t v14 = 0x2000000000LL;
    uint64_t v15 = 0LL;
    CFTypeID v4 = (dispatch_queue_s *)*((void *)trust + 17);
    uint64_t v5 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustGetNetworkFetchAllowed_block_invoke;
    block[3] = &unk_1896749E8;
    block[4] = &v12;
    void block[5] = trust;
    dispatch_sync(v4, block);
    CFTypeID v6 = v13;
    CFIndex v7 = (const __CFArray *)v13[3];
    if (v7)
    {
      context[0] = v5;
      context[1] = 0x40000000LL;
      context[2] = __SecTrustGetNetworkFetchAllowed_block_invoke_2;
      context[3] = &__block_descriptor_tmp_66_12015;
      void context[4] = allowFetch;
      v16.CFIndex length = CFArrayGetCount(v7);
      v16.CFIndex location = 0LL;
      CFArrayApplyFunction(v7, v16, (CFArrayApplierFunction)apply_block_1_11979, context);
      CFTypeID v6 = v13;
    }

    else
    {
      *allowFetch = 1;
    }

    uint64_t v8 = (const void *)v6[3];
    if (v8)
    {
      void v6[3] = 0LL;
      CFRelease(v8);
    }

    _Block_object_dispose(&v12, 8);
    return 0;
  }

  return v2;
}

uint64_t __SecTrustGetNetworkFetchAllowed_block_invoke_2(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = CFBooleanGetTypeID();
    if (v4 == result)
    {
      uint64_t result = CFBooleanGetValue((CFBooleanRef)cf);
      **(_BYTE **)(v3 + 32) = (_DWORD)result == 0;
    }
  }

  return result;
}

uint64_t SecTrustSetPinningException(uint64_t a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v5 = 0LL;
  CFTypeID v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  CFCharacterSetRef v1 = *(dispatch_queue_s **)(a1 + 136);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecTrustSetPinningException_block_invoke;
  unint64_t v4[3] = &unk_189674A38;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecTrustSetPinningException_block_invoke(uint64_t a1)
{
  uint64_t result = SecTrustRemoveOptionInPolicies(*(const void **)(*(void *)(a1 + 40) + 32LL), @"PinningRequired");
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

__SecTrust *SecTrustGetDetails(__SecTrust *result)
{
  if (result)
  {
    CFCharacterSetRef v1 = result;
    SecTrustEvaluateIfNecessary(result);
    return (__SecTrust *)*((void *)v1 + 11);
  }

  return result;
}

uint64_t SecTrustEvaluateIfNecessary(__SecTrust *a1)
{
  uint64_t v8 = 0LL;
  char v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = -1431655766;
  if (pthread_main_np() == 1)
  {
    if (SecTrustEvaluateThreadRuntimeCheck_queueToken != -1) {
      dispatch_once(&SecTrustEvaluateThreadRuntimeCheck_queueToken, &__block_literal_global_329);
    }
    dispatch_async((dispatch_queue_t)SecTrustEvaluateThreadRuntimeCheck_runtimeLogQueue, &__block_literal_global_332);
  }

  v6[0] = 0LL;
  v6[1] = v6;
  v6[2] = 0x2000000000LL;
  CFAbsoluteTime VerifyTime = NAN;
  CFAbsoluteTime VerifyTime = SecTrustGetVerifyTime(a1);
  SecTrustAddPolicyAnchors((uint64_t)a1);
  uint64_t v2 = (dispatch_queue_s *)*((void *)a1 + 17);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustEvaluateIfNecessary_block_invoke;
  block[3] = &unk_1896758C0;
  void block[5] = &v8;
  void block[6] = a1;
  block[4] = v6;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

void __SecTrustEvaluateIfNecessary_block_invoke(int8x16_t *a1)
{
  if (SecTrustIsTrustResultValid(a1[3].i64[0], *(double *)(*(void *)(a1[2].i64[0] + 8) + 24LL)))
  {
    *(_DWORD *)(*(void *)(a1[2].i64[1] + 8) + 24LL) = 0;
  }

  else
  {
    uint64_t v2 = a1[3].i64[0];
    *(_DWORD *)(v2 + 112) = 7;
    uint64_t v3 = *(const void **)(v2 + 72);
    if (v3)
    {
      *(void *)(v2 + 72) = 0LL;
      CFRelease(v3);
      uint64_t v2 = a1[3].i64[0];
    }

    CFTypeID v4 = *(const void **)(v2 + 88);
    if (v4)
    {
      *(void *)(v2 + 8_Block_object_dispose(&a9, 8) = 0LL;
      CFRelease(v4);
      uint64_t v2 = a1[3].i64[0];
    }

    uint64_t v5 = *(const void **)(v2 + 96);
    if (v5)
    {
      *(void *)(v2 + 96) = 0LL;
      CFRelease(v5);
      uint64_t v2 = a1[3].i64[0];
    }

    CFTypeID v6 = *(void **)(v2 + 120);
    if (v6)
    {
      free(v6);
      *(void *)(a1[3].i64[0] + 120) = 0LL;
      uint64_t v2 = a1[3].i64[0];
    }

    uint64_t v7 = *(void **)(v2 + 128);
    if (v7)
    {
      free(v7);
      *(void *)(a1[3].i64[0] + 12_Block_object_dispose(&a9, 8) = 0LL;
      uint64_t v2 = a1[3].i64[0];
    }

    activity_block[0] = MEMORY[0x1895F87A8];
    activity_block[1] = 0x40000000LL;
    activity_block[2] = __SecTrustEvaluateIfNecessary_block_invoke_2;
    activity_block[3] = &unk_189675898;
    uint64_t v10 = v2;
    int8x16_t v9 = vextq_s8(a1[2], a1[2], 8uLL);
    _os_activity_initiate(&dword_1804F4000, "SecTrustEvaluateIfNecessary", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  }

uint64_t __SecTrustEvaluateIfNecessary_block_invoke_2(uint64_t a1)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecTrustEvaluateIfNecessary_block_invoke_3;
  v3[3] = &unk_189675870;
  __int128 v4 = *(_OWORD *)(a1 + 40);
  uint64_t result = SecOSStatusWith((uint64_t)v3);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t __SecTrustEvaluateIfNecessary_block_invoke_3(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v2 = a2;
  if (gTrustd
    && (__int128 v4 = *(uint64_t (**)(uint64_t, uint64_t, BOOL, BOOL, uint64_t, uint64_t, uint64_t, uint64_t, double, uint64_t, void, void, void, void *, void *, void *, CFTypeRef *))(gTrustd + 40)) != 0LL)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(v5 + 16);
    uint64_t v7 = *(void *)(v5 + 24);
    int v8 = *(unsigned __int8 *)(v5 + 116);
    int v9 = *(unsigned __int8 *)(v5 + 117);
    uint64_t v10 = *(void *)(v5 + 32);
    uint64_t v11 = *(void *)(v5 + 40);
    uint64_t v12 = *(void *)(v5 + 48);
    uint64_t v13 = *(void *)(v5 + 56);
    double v14 = *(double *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (SecTrustGetCurrentAccessGroups_onceToken != -1) {
      dispatch_once(&SecTrustGetCurrentAccessGroups_onceToken, &__block_literal_global_344);
    }
    BOOL v15 = v9 != 0;
    CFRange v16 = *(void **)(a1 + 40);
    uint64_t v2 = a2;
    int v17 = v4( v6,  v7,  v8 != 0,  v15,  v10,  v11,  v12,  v13,  v14,  SecTrustGetCurrentAccessGroups_accessGroups,  v16[13],  v16[18],  v16[19],  v16 + 11,  v16 + 12,  v16 + 9,  a2);
  }

  else
  {
    uint64_t v18 = *(void *)(a1 + 40);
    char v19 = *(_BYTE *)(v18 + 116);
    char v20 = *(_BYTE *)(v18 + 117);
    __int128 v21 = *(_OWORD *)(v18 + 16);
    __int128 v22 = *(_OWORD *)(v18 + 32);
    __int128 v23 = *(_OWORD *)(v18 + 48);
    uint64_t v24 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (SecTrustGetCurrentAccessGroups_onceToken != -1)
    {
      __int128 v38 = *(_OWORD *)(v18 + 16);
      __int128 v40 = *(_OWORD *)(v18 + 48);
      __int128 v37 = *(_OWORD *)(v18 + 32);
      dispatch_once(&SecTrustGetCurrentAccessGroups_onceToken, &__block_literal_global_344);
      __int128 v22 = v37;
      __int128 v21 = v38;
      __int128 v23 = v40;
    }

    CFIndex v25 = *(void **)(a1 + 40);
    uint64_t v26 = v25[13];
    uint64_t v27 = v25[18];
    uint64_t v28 = v25[19];
    uint64_t v52 = 0LL;
    uint64_t v53 = &v52;
    uint64_t v54 = 0x2000000000LL;
    int v55 = 0;
    values[0] = (void *)MEMORY[0x1895F87A8];
    values[1] = (void *)0x40000000;
    values[2] = __handle_trust_evaluate_xpc_block_invoke;
    values[3] = &__block_descriptor_tmp_361;
    char v50 = v19;
    char v51 = v20;
    __int128 v43 = v21;
    __int128 v44 = v22;
    __int128 v45 = v23;
    uint64_t v46 = v24;
    uint64_t v47 = v26;
    uint64_t v48 = v27;
    uint64_t v49 = v28;
    v41[0] = MEMORY[0x1895F87A8];
    v41[1] = 0x40000000LL;
    v41[2] = __handle_trust_evaluate_xpc_block_invoke_2;
    unint64_t v41[3] = &unk_189675A60;
    v41[6] = v25 + 12;
    void v41[7] = v25 + 9;
    v41[4] = &v52;
    v41[5] = v25 + 11;
    securityd_send_sync_and_do(8u, v2, (uint64_t)values, (uint64_t)v41);
    int v17 = *((_DWORD *)v53 + 6);
    _Block_object_dispose(&v52, 8);
  }

  uint64_t v29 = *(void *)(a1 + 40);
  *(_DWORD *)(v29 + 112) = v17;
  if (v17) {
    return *(_DWORD *)(v29 + 112) != 0;
  }
  int OSStatus = SecErrorGetOSStatus((uint64_t)*v2);
  uint64_t v29 = *(void *)(a1 + 40);
  if (OSStatus != -25291) {
    return *(_DWORD *)(v29 + 112) != 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v29 + 16));
  uint64_t v29 = *(void *)(a1 + 40);
  if (!Count) {
    return *(_DWORD *)(v29 + 112) != 0;
  }
  values[0] = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v29 + 16), 0LL);
  CFArrayRef v32 = CFArrayCreate(0LL, (const void **)values, 1LL, MEMORY[0x189605228]);
  uint64_t v33 = *(void *)(a1 + 40);
  __int128 v34 = *(const void **)(v33 + 72);
  if (v34)
  {
    *(void *)(v33 + 72) = 0LL;
    CFRelease(v34);
    uint64_t v33 = *(void *)(a1 + 40);
  }

  *(void *)(v33 + 72) = v32;
  CFTypeRef v35 = *v2;
  if (*v2)
  {
    *uint64_t v2 = 0LL;
    CFRelease(v35);
  }

  return 1LL;
}

size_t __handle_trust_evaluate_xpc_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result = SecXPCDictionarySetCertificates(a2, "certificates", *(const __CFArray **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    uint64_t v7 = *(const __CFArray **)(a1 + 40);
    if (!v7 || (size_t result = SecXPCDictionarySetCertificates(a2, "anchors", v7, a3), (_DWORD)result))
    {
      if (*(_BYTE *)(a1 + 112)) {
        xpc_dictionary_set_BOOL(a2, "anchorsOnly", 1);
      }
      xpc_dictionary_set_BOOL(a2, "keychainsAllowed", *(_BYTE *)(a1 + 113));
      size_t result = SecXPCDictionarySetPolicies(a2, *(const __CFArray **)(a1 + 48), a3);
      if ((_DWORD)result)
      {
        uint64_t v12 = *(const __CFArray **)(a1 + 56);
        if (!v12 || (size_t result = SecXPCDictionarySetDataArray(a2, "responses", v12, a3), (_DWORD)result))
        {
          uint64_t v13 = *(const __CFArray **)(a1 + 64);
          if (!v13 || (size_t result = SecXPCDictionarySetDataArray(a2, "scts", v13, a3), (_DWORD)result))
          {
            double v14 = *(const __CFString **)(a1 + 72);
            if (!v14
              || (size_t result = SecXPCDictionarySetPListWithRepair(a2, "trustedLogs", v14, a3, v8, v9, v10, v11),
                  (_DWORD)result))
            {
              xpc_dictionary_set_double(a2, "verifyDate", *(double *)(a1 + 80));
              char v19 = *(const __CFString **)(a1 + 88);
              if (!v19
                || (size_t result = SecXPCDictionarySetPListWithRepair(a2, "exceptions", v19, a3, v15, v16, v17, v18),
                    (_DWORD)result))
              {
                char v20 = *(const __CFData **)(a1 + 96);
                if (!v20 || (size_t result = SecXPCDictionarySetData(a2, "auditToken", v20, a3), (_DWORD)result))
                {
                  xpc_dictionary_set_uint64(a2, "attribution", *(void *)(a1 + 104));
                  return 1LL;
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t __handle_trust_evaluate_xpc_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v6 = *(const void ***)(a1 + 40);
  uint64_t v7 = *v6;
  if (*v6)
  {
    *uint64_t v6 = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = *(const void ***)(a1 + 48);
  uint64_t v9 = *v8;
  if (*v8)
  {
    const void *v8 = 0LL;
    CFRelease(v9);
  }

  uint64_t v10 = *(const void ***)(a1 + 56);
  uint64_t v11 = *v10;
  if (*v10)
  {
    *uint64_t v10 = 0LL;
    CFRelease(v11);
  }

  uint64_t result = SecXPCDictionaryCopyArrayOptional(a2, "details", *(void **)(a1 + 40), a3);
  if ((_DWORD)result)
  {
    uint64_t result = SecXPCDictionaryCopyDictionaryOptional(a2, "info", *(void **)(a1 + 48), a3);
    if ((_DWORD)result)
    {
      uint64_t result = SecXPCDictionaryCopyChainOptional(a2, *(CFMutableArrayRef **)(a1 + 56), a3);
      if ((_DWORD)result)
      {
        int NonZeroInteger = SecXPCDictionaryGetNonZeroInteger(a2, a3);
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = NonZeroInteger;
        return NonZeroInteger != 0;
      }
    }
  }

  return result;
}

CFArrayRef __SecTrustGetCurrentAccessGroups_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef result = CFArrayCreateForCFTypes( (CFAllocatorRef)*MEMORY[0x189604DB0],  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"com.apple.trustd");
  SecTrustGetCurrentAccessGroups_accessGroups = (uint64_t)result;
  return result;
}

void __SecTrustAddPolicyAnchors_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 40);
  }

  *(void *)(v2 + 24) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void __SecTrustEvaluateThreadRuntimeCheck_block_invoke_2()
{
  Mainuint64_t Bundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFCharacterSetRef v1 = MainBundle;
    uint64_t v2 = CFBundleCopyBundleURL(MainBundle);
    if (v2)
    {
      uint64_t v3 = v2;
      __int128 v4 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle);
      if (v4)
      {
        uint64_t v5 = v4;
        if (CFStringHasSuffix(v4, @".app"))
        {
          Identifier = CFBundleGetIdentifier(v1);
          if (Identifier)
          {
            if (!CFStringHasPrefix(Identifier, @"com.apple."))
            {
              uint64_t propertyValueTypeRefPtr = 0LL;
              if (CFURLCopyResourcePropertyForKey(v3, (CFStringRef)*MEMORY[0x189605370], &propertyValueTypeRefPtr, 0LL))
              {
                if (propertyValueTypeRefPtr == *MEMORY[0x189604DE8])
                {
                  if (checkmap_block_invoke_2_onceToken != -1) {
                    dispatch_once(&checkmap_block_invoke_2_onceToken, &__block_literal_global_338);
                  }
                  double Current = CFAbsoluteTimeGetCurrent();
                  if (Current >= *(double *)&checkmap_block_invoke_2_startTime)
                  {
                    uint64_t v8 = (os_log_s *)checkmap_block_invoke_2_runtimeLog;
                    if (os_log_type_enabled((os_log_t)checkmap_block_invoke_2_runtimeLog, OS_LOG_TYPE_FAULT))
                    {
                      *(_WORD *)uint64_t v9 = 0;
                      _os_log_fault_impl( &dword_1804F4000,  v8,  OS_LOG_TYPE_FAULT,  "__delegate_identifier__:Performance Diagnostics__:::____message__:This method should not be call ed on the main thread as it may lead to UI unresponsiveness.",  v9,  2u);
                    }

                    ++checkmap_block_invoke_2_faultsSinceStartTime;
                    if (SecFrameworkIsRunningInXcode_envCheckOnce != -1) {
                      dispatch_once(&SecFrameworkIsRunningInXcode_envCheckOnce, &__block_literal_global_728);
                    }
                    if ((SecFrameworkIsRunningInXcode_runningInXcode & 1) != 0
                      || (unint64_t)checkmap_block_invoke_2_faultsSinceStartTime < 0xB)
                    {
                      if (Current - *(double *)&checkmap_block_invoke_2_startTime > 60.0)
                      {
                        checkmap_block_invoke_2_startTime = *(void *)&Current;
                        checkmap_block_invoke_2_faultsSinceStartTime = 0LL;
                      }
                    }

                    else
                    {
                      *(double *)&checkmap_block_invoke_2_startTime = Current + 300.0;
                    }
                  }

                  else
                  {
                    checkmap_block_invoke_2_faultsSinceStartTime = 0LL;
                  }
                }
              }
            }
          }
        }

        CFRelease(v5);
      }

      CFRelease(v3);
    }
  }

os_log_t __SecTrustEvaluateThreadRuntimeCheck_block_invoke_3()
{
  os_log_t result = os_log_create("com.apple.runtime-issues", "Security");
  checkmap_block_invoke_2_runtimeLog = (uint64_t)result;
  return result;
}

dispatch_queue_t __SecTrustEvaluateThreadRuntimeCheck_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("Runtime Issue Logging", 0LL);
  SecTrustEvaluateThreadRuntimeCheck_runtimeLogQueue = (uint64_t)result;
  return result;
}

OSStatus SecTrustGetTrustResult(SecTrustRef trust, SecTrustResultType *result)
{
  OSStatus v3 = -50;
  if (trust)
  {
    if (result)
    {
      SecTrustEvaluateIfNecessary(trust);
      uint64_t v5 = (dispatch_queue_s *)*((void *)trust + 17);
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 0x40000000LL;
      v6[2] = __SecTrustGetTrustResult_block_invoke;
      void v6[3] = &__block_descriptor_tmp_69_12082;
      void v6[4] = result;
      void v6[5] = trust;
      dispatch_sync(v5, v6);
      return 0;
    }
  }

  return v3;
}

uint64_t __SecTrustGetTrustResult_block_invoke(uint64_t result)
{
  **(_DWORD **)(result + 32) = *(_DWORD *)(*(void *)(result + 40) + 112LL);
  return result;
}

__SecTrust *SecTrustCopyFilteredDetails(__SecTrust *a1)
{
  CFCharacterSetRef v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    uint64_t v5 = 0LL;
    uint64_t v6 = &v5;
    uint64_t v7 = 0x2000000000LL;
    uint64_t v8 = 0LL;
    uint64_t v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __SecTrustCopyFilteredDetails_block_invoke;
    unint64_t v4[3] = &unk_189674AA8;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    CFCharacterSetRef v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }

  return v1;
}

void *__SecTrustCopyFilteredDetails_block_invoke(void *result)
{
  CFCharacterSetRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    dispatch_queue_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  return result;
}

uint64_t SecTrustIsExpiredOnly(__SecTrust *a1)
{
  CFCharacterSetRef v1 = SecTrustCopyFilteredDetails(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    CFIndex Count = CFArrayGetCount(v1);
    if (Count >= 1)
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0LL;
      unsigned __int8 v6 = 0;
      uint64_t v7 = (const void *)*MEMORY[0x189604DE0];
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v5);
        if (ValueAtIndex)
        {
          uint64_t v9 = ValueAtIndex;
          CFIndex v10 = CFDictionaryGetCount(ValueAtIndex);
          if (v10 > 1) {
            break;
          }
          if (v10)
          {
            unint64_t Value = CFDictionaryGetValue(v9, @"TemporalValidity");
            if (!Value) {
              break;
            }
            uint64_t v12 = Value;
            CFTypeID v13 = CFGetTypeID(Value);
            if (v13 != CFBooleanGetTypeID() || !CFEqual(v12, v7)) {
              break;
            }
            unsigned __int8 v6 = 1;
          }
        }

        if (v4 == ++v5) {
          goto LABEL_14;
        }
      }
    }

    unsigned __int8 v6 = 0;
LABEL_14:
    CFRelease(v2);
  }

  else
  {
    return 0;
  }

  return v6;
}

uint64_t SecTrustEvaluateInternal(__SecTrust *a1, _DWORD *a2)
{
  if (a2) {
    *a2 = 0;
  }
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = SecTrustEvaluateIfNecessary(a1);
  if (!(_DWORD)result)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = &v7;
    uint64_t v9 = 0x2000000000LL;
    int v10 = 0;
    CFIndex v5 = (dispatch_queue_s *)*((void *)a1 + 17);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __SecTrustEvaluateInternal_block_invoke;
    void v6[3] = &unk_189675520;
    void v6[4] = &v7;
    void v6[5] = a1;
    dispatch_sync(v5, v6);
    SecTrustLogFailureDescription(a1, *((_DWORD *)v8 + 6));
    if (a2) {
      *a2 = *((_DWORD *)v8 + 6);
    }
    _Block_object_dispose(&v7, 8);
    return 0LL;
  }

  return result;
}

uint64_t __SecTrustEvaluateInternal_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 112LL);
  return result;
}

__CFString *SecTrustCopyFailureDescription(__SecTrust *a1)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  CFMutableDataRef Mutable = CFStringCreateMutable(0LL, 0LL);
  SecTrustEvaluateIfNecessary(a1);
  uint64_t v25 = 0LL;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000LL;
  uint64_t v28 = 0LL;
  uint64_t v3 = (dispatch_queue_s *)*((void *)a1 + 17);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustCopyFailureDescription_block_invoke;
  block[3] = &unk_189675060;
  block[4] = &v25;
  void block[5] = a1;
  dispatch_sync(v3, block);
  CFIndex v4 = (const __CFArray *)v26[3];
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    CFIndex v21 = Count - 1;
    CFIndex v22 = Count;
    if (Count >= 1)
    {
      CFIndex v6 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v26[3], v6);
        CFIndex v8 = CFDictionaryGetCount(ValueAtIndex);
        if (v8 >= 1) {
          break;
        }
LABEL_18:
        if (++v6 == v22) {
          goto LABEL_19;
        }
      }

      size_t v9 = v8;
      if (v6)
      {
        if (v6 != v21)
        {
          CFStringAppendFormat(Mutable, 0LL, @" [ca%ld", v6);
LABEL_12:
          __int128 v23 = &v21;
          MEMORY[0x1895F8858]();
          CFTypeID v13 = (const void **)((char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
          memset(v13, 170, v12);
          CFDictionaryGetKeysAndValues(ValueAtIndex, v13, 0LL);
          qsort(v13, v9, 8uLL, (int (__cdecl *)(const void *, const void *))compare_strings);
          do
          {
            uint64_t v15 = *v13++;
            double v14 = v15;
            unint64_t Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v15);
            CFTypeID v17 = CFGetTypeID(Value);
            if (v17 == CFBooleanGetTypeID()) {
              uint64_t v18 = &stru_1896794C8;
            }
            else {
              uint64_t v18 = Value;
            }
            CFStringAppendFormat(Mutable, 0LL, @" %@%@", v14, v18);
            --v9;
          }

          while (v9);
          CFStringAppend(Mutable, @"]");
          goto LABEL_18;
        }

        int v10 = Mutable;
        uint64_t v11 = @" [root";
      }

      else
      {
        int v10 = Mutable;
        uint64_t v11 = @" [leaf";
      }

      CFStringAppend(v10, v11);
      goto LABEL_12;
    }
  }

void *__SecTrustCopyFailureDescription_block_invoke(void *result)
{
  CFCharacterSetRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  return result;
}

CFComparisonResult compare_strings(CFStringRef *a1, CFStringRef *a2)
{
  return CFStringCompare(*a1, *a2, 0x200uLL);
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  int v9 = 0;
  int v4 = SecTrustEvaluateInternal(trust, &v9);
  if (v4)
  {
    if (error)
    {
      CFIndex v5 = (__CFError *)SecCopyLastError(v4);
LABEL_4:
      CFIndex v6 = v5;
      BOOL result = 0;
LABEL_12:
      *CFErrorRef error = v6;
      return result;
    }
  }

  else
  {
    if (v9 == 4 || v9 == 1)
    {
      BOOL result = 1;
      if (!error) {
        return result;
      }
      CFIndex v6 = 0LL;
      goto LABEL_12;
    }

    if (error)
    {
      CFIndex v5 = SecTrustCopyError((uint64_t)trust);
      goto LABEL_4;
    }
  }

  return 0;
}

CFErrorRef SecTrustCopyError(uint64_t a1)
{
  uint64_t v106 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v47 = 0LL;
    uint64_t v48 = &v47;
    uint64_t v49 = 0x2000000000LL;
    int v50 = 0;
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 136);
    uint64_t v3 = (void *)MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustCopyError_block_invoke;
    block[3] = &unk_189675548;
    block[4] = &v47;
    void block[5] = a1;
    dispatch_sync(v2, block);
    CFErrorRef v4 = 0LL;
    int v5 = *((_DWORD *)v48 + 6);
    if (v5 == 1 || v5 == 4)
    {
LABEL_71:
      _Block_object_dispose(&v47, 8);
      return v4;
    }

    values = 0LL;
    uint64_t v75 = 0LL;
    uint64_t v76 = &v75;
    uint64_t v77 = 0x2000000000LL;
    uint64_t v78 = 0LL;
    uint64_t v71 = 0LL;
    int v72 = &v71;
    uint64_t v73 = 0x2000000000LL;
    uint64_t v74 = 0LL;
    uint64_t v7 = *(dispatch_queue_s **)(a1 + 136);
    CFTypeID v99 = v3;
    uint64_t v100 = 0x40000000LL;
    __int128 v101 = __SecTrustCopyErrorStrings_block_invoke;
    __int128 v102 = &unk_189675570;
    int v104 = &v71;
    uint64_t v105 = a1;
    CFTypeID v103 = &v75;
    dispatch_sync(v7, &v99);
    if (v76[3])
    {
      if (SecTrustCopyErrorStrings_onceToken != -1) {
        dispatch_once(&SecTrustCopyErrorStrings_onceToken, &__block_literal_global_283);
      }
      uint64_t v67 = 0LL;
      BOOL v68 = &v67;
      uint64_t v69 = 0x2000000000LL;
      CFMutableStringRef Mutable = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
      CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
      uint64_t v63 = 0LL;
      CFIndex v64 = &v63;
      uint64_t v65 = 0x2000000000LL;
      int v66 = 11;
      uint64_t v59 = 0LL;
      CFRange v60 = &v59;
      uint64_t v61 = 0x2000000000LL;
      int v62 = -67671;
      uint64_t v55 = 0LL;
      CFIndex v56 = &v55;
      uint64_t v57 = 0x2000000000LL;
      uint64_t v58 = -1LL;
      uint64_t v51 = 0LL;
      uint64_t v52 = &v51;
      uint64_t v53 = 0x2000000000LL;
      unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v76[3]);
      v52[3] = 0LL;
      if (Count >= 1)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0LL; i < v9; v52[3] = i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v76[3], i);
          if (CFDictionaryGetCount(ValueAtIndex))
          {
            size_t v12 = v3;
            CFTypeID v13 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v72[3], v52[3]);
            CFStringRef v14 = SecCertificateCopySubjectSummary(v13);
            uint64_t v15 = SecFrameworkCopyLocalizedString(@"Certificate %ld “%@” has errors: ", @"Trust");
            CFStringAppendFormat((CFMutableStringRef)v68[3], 0LL, v15, v52[3], v14);
            if (v14) {
              CFRelease(v14);
            }
            if (v15) {
              CFRelease(v15);
            }
            CFIndex v79 = 0LL;
            uint64_t v80 = (uint64_t)&v79;
            uint64_t v81 = 0x2000000000LL;
            LOBYTE(v82) = 1;
            uint64_t v3 = v12;
            __int128 context = v12;
            uint64_t v90 = 0x40000000LL;
            int v91 = __SecTrustCopyErrorStrings_block_invoke_3;
            int v92 = &unk_189675820;
            BOOL v93 = &v63;
            uint64_t v94 = &v55;
            v95 = &v51;
            CFNumberRef v96 = &v59;
            __int128 v97 = &v79;
            __int128 v98 = &v67;
            CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)apply_block_2_12095, &context);
            CFStringAppend((CFMutableStringRef)v68[3], @";");
            _Block_object_dispose(&v79, 8);
          }

          CFIndex i = v52[3] + 1;
        }
      }

      uint64_t v16 = (const void *)v76[3];
      if (v16)
      {
        v76[3] = 0LL;
        CFRelease(v16);
      }

      CFIndex v17 = v56[3];
      if (v17 == -1)
      {
        CFIndex v17 = 0LL;
        v56[3] = 0LL;
      }

      uint64_t v18 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v72[3], v17);
      CFStringRef v19 = SecCertificateCopySubjectSummary(v18);
      switch(*((_DWORD *)v64 + 6))
      {
        case 0:
          char v20 = @"“%@” certificate is blocked";
          goto LABEL_48;
        case 1:
          char v20 = @"“%@” certificate is revoked";
          goto LABEL_48;
        case 2:
          char v20 = @"“%@” certificate is using a broken key size";
          goto LABEL_48;
        case 3:
          char v20 = @"“%@” certificate is using a broken signature algorithm";
          goto LABEL_48;
        case 4:
          char v20 = @"User or administrator set “%@” certificate as distrusted";
          goto LABEL_48;
        case 5:
          char v20 = @"“%@” certificate is not standards compliant";
          goto LABEL_48;
        case 6:
          uint64_t v25 = SecFrameworkCopyLocalizedString( @"%@ certificates do not meet pinning requirements",  @"Trust");
          uint64_t v26 = CFStringCreateMutable(0LL, 0LL);
          uint64_t v85 = 0LL;
          int v86 = &v85;
          uint64_t v87 = 0x2000000000LL;
          uint64_t v88 = 0LL;
          uint64_t v27 = *(dispatch_queue_s **)(a1 + 136);
          CFIndex v79 = v3;
          uint64_t v80 = 0x40000000LL;
          uint64_t v81 = (uint64_t)__SecTrustCopyChainSummary_block_invoke;
          __int128 v82 = &unk_189675848;
          uint64_t v83 = &v85;
          uint64_t v84 = a1;
          dispatch_sync(v27, &v79);
          CFIndex v28 = CFArrayGetCount((CFArrayRef)v86[3]);
          if (v28 >= 1)
          {
            CFIndex v29 = v28;
            for (CFIndex j = 0LL; j != v29; ++j)
            {
              if (j) {
                CFStringAppend(v26, @",");
              }
              CFTypeID v31 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v86[3], j);
              CFStringRef v32 = SecCertificateCopySubjectSummary(v31);
              CFStringAppendFormat(v26, 0LL, @"%@", v32);
              if (v32) {
                CFRelease(v32);
              }
            }
          }

          _Block_object_dispose(&v85, 8);
          if (v19) {
            CFRelease(v19);
          }
          CFStringRef v19 = v26;
          goto LABEL_49;
        case 7:
          char v20 = @"“%@” certificate is not trusted";
          goto LABEL_48;
        case 8:
          char v20 = @"“%@” certificate is not permitted for this usage";
          goto LABEL_48;
        case 9:
          char v20 = @"“%@” certificate name does not match input";
          goto LABEL_48;
        case 0xA:
          char v20 = @"“%@” certificate is expired";
          goto LABEL_48;
        default:
          char v20 = @"Unknown trust error for “%@” certificate";
LABEL_48:
          uint64_t v25 = SecFrameworkCopyLocalizedString(v20, @"Trust");
LABEL_49:
          if (v25 && v19)
          {
            CFStringRef v33 = CFStringCreateWithFormat(0LL, 0LL, v25, v19);
          }

          else
          {
            CFStringRef v33 = 0LL;
            __int128 v23 = 0LL;
            if (!v25) {
              goto LABEL_54;
            }
          }

          CFRelease(v25);
          __int128 v23 = (__CFString *)v33;
LABEL_54:
          if (v19) {
            CFRelease(v19);
          }
          __int128 v34 = (const void *)v72[3];
          if (v34)
          {
            v72[3] = 0LL;
            CFRelease(v34);
          }

          CFIndex v22 = (void *)v68[3];
          values = v22;
          OSStatus v24 = *((_DWORD *)v60 + 6);
          _Block_object_dispose(&v51, 8);
          _Block_object_dispose(&v55, 8);
          _Block_object_dispose(&v59, 8);
          _Block_object_dispose(&v63, 8);
          _Block_object_dispose(&v67, 8);
          break;
      }
    }

    else
    {
      CFIndex v21 = (const void *)v72[3];
      if (v21)
      {
        v72[3] = 0LL;
        CFRelease(v21);
      }

      CFIndex v22 = 0LL;
      __int128 v23 = 0LL;
      OSStatus v24 = -26276;
    }

    _Block_object_dispose(&v71, 8);
    _Block_object_dispose(&v75, 8);
    if (v23)
    {
      if (v22)
      {
LABEL_61:
        CFDataRef v36 = (const void **)MEMORY[0x189604F68];
        __int128 v37 = CFDictionaryCreate( 0LL,  MEMORY[0x189604F68],  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
        __int128 v38 = (const __CFString *)*MEMORY[0x189604F50];
        CFIndex v39 = v24;
        CFErrorRef v40 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v24, v37);
        if (v37) {
          CFRelease(v37);
        }
        CFMutableArrayRef v41 = values;
        if (values)
        {
          values = 0LL;
          CFRelease(v41);
        }

        uint64_t v42 = *MEMORY[0x189604F88];
        __int128 context = *v36;
        uint64_t v90 = v42;
        CFTypeID v99 = v23;
        uint64_t v100 = (uint64_t)v40;
        __int128 v43 = CFDictionaryCreate(0LL, &context, (const void **)&v99, 2LL, MEMORY[0x189605240], MEMORY[0x189605250]);
        CFErrorRef v4 = CFErrorCreate(0LL, v38, v39, v43);
        if (v43) {
          CFRelease(v43);
        }
        if (v23) {
          CFRelease(v23);
        }
        if (v40) {
          CFRelease(v40);
        }
        goto LABEL_71;
      }
    }

    else
    {
      __int128 v23 = (__CFString *)SecCopyErrorMessageString(v24, v35);
      if (v22) {
        goto LABEL_61;
      }
    }

    values = (void *)SecCopyErrorMessageString(v24, v35);
    goto LABEL_61;
  }

  return 0LL;
}

uint64_t __SecTrustCopyError_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 112LL);
  return result;
}

void *__SecTrustCopyErrorStrings_block_invoke(void *result)
{
  CFCharacterSetRef v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    BOOL result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    BOOL result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8LL) + 24LL) = v5;
  return result;
}

void __SecTrustCopyErrorStrings_block_invoke_3(void *a1, const void *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (const __CFArray *)SecTrustCopyErrorStrings_policyChecks;
  v14.CFIndex length = CFArrayGetCount((CFArrayRef)SecTrustCopyErrorStrings_policyChecks);
  v14.CFIndex location = 0LL;
  FirstIndexOfunint64_t Value = CFArrayGetFirstIndexOfValue(v4, v14, a2);
  if (FirstIndexOfValue < 0x4C)
  {
    unint64_t v7 = FirstIndexOfValue;
    uint64_t v8 = *(void *)(a1[4] + 8LL);
    unsigned int v9 = *((_DWORD *)&checkmap + 4 * FirstIndexOfValue);
    if (*(_DWORD *)(v8 + 24) > v9)
    {
      *(_DWORD *)(v8 + 24) = v9;
      *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = *(void *)(*(void *)(a1[6] + 8LL) + 24LL);
      *(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL) = *((_DWORD *)&checkmap + 4 * FirstIndexOfValue + 1);
    }

    if (!*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL)) {
      CFStringAppend(*(CFMutableStringRef *)(*(void *)(a1[9] + 8LL) + 24LL), @", ");
    }
    int v10 = SecFrameworkCopyLocalizedString(*((const __CFString **)&checkmap + 2 * v7 + 1), @"Trust");
    CFStringAppend(*(CFMutableStringRef *)(*(void *)(a1[9] + 8LL) + 24LL), v10);
    if (v10) {
      CFRelease(v10);
    }
    *(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL) = 0;
  }

  else
  {
    CFIndex v6 = (os_log_s *)secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      size_t v12 = a2;
      _os_log_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_DEFAULT,  "unknown failure key in details dictionary: %@",  (uint8_t *)&v11,  0xCu);
    }
  }

uint64_t apply_block_2_12095(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __SecTrustCopyChainSummary_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(*(void *)(result + 40) + 72LL);
  return result;
}

void __SecTrustCopyErrorStrings_block_invoke_2()
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  CFArrayAppendValue(Mutable, @"SSLHostname");
  CFArrayAppendValue(Mutable, @"Email");
  CFArrayAppendValue(Mutable, @"TemporalValidity");
  CFArrayAppendValue(Mutable, @"ValidLeaf");
  CFArrayAppendValue(Mutable, @"WeakKeySize");
  CFArrayAppendValue(Mutable, @"WeakSignature");
  CFArrayAppendValue(Mutable, @"KeyUsage");
  CFArrayAppendValue(Mutable, @"ExtendedKeyUsage");
  CFArrayAppendValue(Mutable, @"SubjectCommonName");
  CFArrayAppendValue(Mutable, @"SubjectCommonNamePrefix");
  CFArrayAppendValue(Mutable, @"SubjectCommonNameTEST");
  CFArrayAppendValue(Mutable, @"SubjectOrganization");
  CFArrayAppendValue(Mutable, @"SubjectOrganizationalUnit");
  CFArrayAppendValue(Mutable, @"NotValidBefore");
  CFArrayAppendValue(Mutable, @"EAPTrustedServerNames");
  CFArrayAppendValue(Mutable, @"LeafMarkerOid");
  CFArrayAppendValue(Mutable, @"LeafMarkerOidWithoutValueCheck");
  CFArrayAppendValue(Mutable, @"LeafMarkersProdAndQA");
  CFArrayAppendValue(Mutable, @"BlackListedLeaf");
  CFArrayAppendValue(Mutable, @"GrayListedLeaf");
  CFArrayAppendValue(Mutable, @"LeafSPKISHA256");
  CFArrayAppendValue(Mutable, @"NotCA");
  CFArrayAppendValue(Mutable, @"MarkRepresentation");
  CFArrayAppendValue(Mutable, @"IssuerCommonName");
  CFArrayAppendValue(Mutable, @"IssuerCommonNamePrefix");
  CFArrayAppendValue(Mutable, @"BasicConstraints");
  CFArrayAppendValue(Mutable, @"BasicConstraintsCA");
  CFArrayAppendValue(Mutable, @"BasicConstraintsPathLen");
  CFArrayAppendValue(Mutable, @"IntermediateSPKISHA256");
  CFArrayAppendValue(Mutable, @"IntermediateEKU");
  CFArrayAppendValue(Mutable, @"IntermediateMarkerOid");
  CFArrayAppendValue(Mutable, @"IntermediateMarkerOidWithoutValueCheck");
  CFArrayAppendValue(Mutable, @"IntermediateOrganization");
  CFArrayAppendValue(Mutable, @"IntermediateCountry");
  CFArrayAppendValue(Mutable, @"AnchorSHA256");
  CFArrayAppendValue(Mutable, @"AnchorTrusted");
  CFArrayAppendValue(Mutable, @"MissingIntermediate");
  CFArrayAppendValue(Mutable, @"AnchorApple");
  CFArrayAppendValue(Mutable, @"CAspkiSHA256");
  CFArrayAppendValue(Mutable, @"NonEmptySubject");
  CFArrayAppendValue(Mutable, @"IdLinkage");
  CFArrayAppendValue(Mutable, @"KeySize");
  CFArrayAppendValue(Mutable, @"SignatureHashAlgorithms");
  CFArrayAppendValue(Mutable, @"CertificatePolicy");
  CFArrayAppendValue(Mutable, @"ValidRoot");
  CFArrayAppendValue(Mutable, @"CriticalExtensions");
  CFArrayAppendValue(Mutable, @"ChainLength");
  CFArrayAppendValue(Mutable, @"BasicCertificateProcessing");
  CFArrayAppendValue(Mutable, @"NameConstraints");
  CFArrayAppendValue(Mutable, @"PolicyConstraints");
  CFArrayAppendValue(Mutable, @"GrayListedKey");
  CFArrayAppendValue(Mutable, @"BlackListedKey");
  CFArrayAppendValue(Mutable, @"UsageConstraints");
  CFArrayAppendValue(Mutable, @"SystemTrustedWeakHash");
  CFArrayAppendValue(Mutable, @"SystemTrustedWeakKey");
  CFArrayAppendValue(Mutable, @"PinningRequired");
  CFArrayAppendValue(Mutable, @"Revocation");
  CFArrayAppendValue(Mutable, @"RevocationResponseRequired");
  CFArrayAppendValue(Mutable, @"CTRequired");
  CFArrayAppendValue(Mutable, @"SystemTrustedCTRequired");
  CFArrayAppendValue(Mutable, @"IssuerPolicyConstraints");
  CFArrayAppendValue(Mutable, @"IssuerNameConstraints");
  CFArrayAppendValue(Mutable, @"ValidityPeriodMaximums");
  CFArrayAppendValue(Mutable, @"SystemTrustValidityPeriod");
  CFArrayAppendValue(Mutable, @"OtherTrustValidityPeriod");
  CFArrayAppendValue(Mutable, @"ServerAuthEKU");
  CFArrayAppendValue(Mutable, @"EmailProtectionEKU");
  CFArrayAppendValue(Mutable, @"SinglePurposeChainEKU");
  CFArrayAppendValue(Mutable, @"UnparseableExtension");
  CFArrayAppendValue(Mutable, @"NonTlsCTRequired");
  CFArrayAppendValue(Mutable, @"DuplicateExtension");
  CFArrayAppendValue(Mutable, @"NoNetworkAccess");
  CFArrayAppendValue(Mutable, @"ExtendedValidation");
  CFArrayAppendValue(Mutable, @"RevocationOnline");
  CFArrayAppendValue(Mutable, @"RevocationIfTrusted");
  CFArrayAppendValue(Mutable, @"RevocationDbIgnored");
  SecTrustCopyErrorStrings_policyChecks = (uint64_t)Mutable;
}

OSStatus SecTrustEvaluateAsync(SecTrustRef trust, dispatch_queue_t queue, SecTrustCallback result)
{
  if (trust) {
    CFRetain(trust);
  }
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  void v7[2] = __SecTrustEvaluateAsync_block_invoke;
  void v7[3] = &unk_189674F98;
  UInt8 v7[4] = result;
  void v7[5] = trust;
  dispatch_async(queue, v7);
  return 0;
}

void __SecTrustEvaluateAsync_block_invoke(uint64_t a1)
{
  int v3 = -1431655766;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_405(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(*(void *)(a1 + 40) + 160LL))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v2 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      int v5 = 134217984;
      uint64_t v6 = v3;
      _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "(Trust %p) No pending evals, starting",  (uint8_t *)&v5,  0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 40);
    *(_BYTE *)(v4 + 160) = 1;
    dispatch_group_enter(*(dispatch_group_t *)(v4 + 168));
  }

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_385(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_debug_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEBUG,  "(Trust %p) Calling completion block",  (uint8_t *)&v5,  0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_387(uint64_t a1)
{
  uint64_t v17 = 0LL;
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, BOOL, BOOL, uint64_t, uint64_t, uint64_t, uint64_t, double, uint64_t, void, void, void, void, uint64_t, uint64_t, uint64_t *))(gTrustd + 40);
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24);
  int v6 = *(unsigned __int8 *)(v3 + 116);
  int v7 = *(unsigned __int8 *)(v3 + 117);
  uint64_t v8 = *(void *)(v3 + 32);
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(void *)(v3 + 48);
  uint64_t v11 = *(void *)(v3 + 56);
  double v12 = *(double *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (SecTrustGetCurrentAccessGroups_onceToken != -1) {
    dispatch_once(&SecTrustGetCurrentAccessGroups_onceToken, &__block_literal_global_344);
  }
  int v13 = v2( v4,  v5,  v6 != 0,  v7 != 0,  v8,  v9,  v10,  v11,  v12,  SecTrustGetCurrentAccessGroups_accessGroups,  *(void *)(*(void *)(a1 + 56) + 104LL),  *(void *)(*(void *)(a1 + 56) + 144LL),  *(void *)(*(void *)(a1 + 56) + 152LL),  *(void *)(a1 + 64),  *(void *)(a1 + 64) + 8LL,  *(void *)(a1 + 64) + 16LL,  &v17);
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 0x40000000LL;
  _OWORD v14[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2;
  unint64_t v14[3] = &unk_189675AF8;
  uint64_t v16 = *(void *)(a1 + 64);
  __int128 v15 = *(_OWORD *)(a1 + 48);
  UInt8 v14[4] = *(void *)(a1 + 32);
  __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2(v14, v13, v17);
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_395(void *a1, int a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v6 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a1[6];
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "(Trust %p) trustd returned %d", buf, 0x12u);
  }

  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2000000000LL;
  int v19 = -67671;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_397;
  block[3] = &unk_189675B68;
  int v15 = a2;
  __int128 v13 = *((_OWORD *)a1 + 3);
  uint64_t v8 = *(dispatch_queue_s **)(v13 + 136);
  uint64_t v14 = a3;
  block[4] = buf;
  dispatch_sync(v8, block);
  uint64_t v9 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = a1[6];
    *(_DWORD *)uint64_t v16 = 134217984;
    uint64_t v17 = v11;
    _os_log_debug_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEBUG,  "(Trust %p) Calling completion block after async xpc",  v16,  0xCu);
  }

  os_activity_scope_leave((os_activity_scope_state_t)(*(void *)(a1[5] + 8LL) + 24LL));
  (*(void (**)(void))(a1[4] + 16LL))();
  uint64_t v10 = (const void *)a1[6];
  if (v10) {
    CFRelease(v10);
  }
  _Block_object_dispose(buf, 8);
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_397(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  *(_DWORD *)(v2 + 112) = *(_DWORD *)(a1 + 64);
  uint64_t v3 = **(void **)(a1 + 48);
  uint64_t v4 = *(const void **)(v2 + 88);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(v2 + 8_Block_object_dispose(&a9, 8) = v3;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v7 = *(const void **)(v5 + 96);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v5 + 96) = v6;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 16LL);
  uint64_t v10 = *(const void **)(v8 + 72);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(v8 + 72) = v9;
  free(*(void **)(a1 + 48));
  uint64_t v11 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v11 + 112)
    && (OSStatus = SecErrorGetOSStatus(*(void *)(a1 + 56)), uint64_t v11 = *(void *)(a1 + 40), OSStatus == -25291)
    && (Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 16)), uint64_t v11 = *(void *)(a1 + 40), Count))
  {
    *(void *)values = CFArrayGetValueAtIndex(*(CFArrayRef *)(v11 + 16), 0LL);
    CFArrayRef v14 = CFArrayCreate(0LL, (const void **)values, 1LL, MEMORY[0x189605228]);
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(const void **)(v15 + 72);
    if (v16)
    {
      *(void *)(v15 + 72) = 0LL;
      CFRelease(v16);
      uint64_t v15 = *(void *)(a1 + 40);
    }

    *(void *)(v15 + 72) = v14;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }

  else
  {
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 0x40000000LL;
    uint64_t v19[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_398;
    unint64_t v19[3] = &__block_descriptor_tmp_399;
    void v19[4] = *(void *)(a1 + 56);
    void v19[5] = v11;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SecOSStatusWith((uint64_t)v19);
    uint64_t v17 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a1 + 40);
      *(_DWORD *)values = 134217984;
      *(void *)&values[4] = v18;
      _os_log_debug_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEBUG, "(Trust %p) Kick off pending evals", values, 0xCu);
    }

    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 40) + 168LL));
    *(_BYTE *)(*(void *)(a1 + 40) + 160LL) = 0;
  }

BOOL __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_398(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  return *(_DWORD *)(*(void *)(a1 + 40) + 112LL) != 0;
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2(void *a1, int a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a1[6];
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "(Trust %p) trustd returned %d", buf, 0x12u);
  }

  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2000000000LL;
  int v19 = -67671;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_388;
  block[3] = &unk_189675AD0;
  int v15 = a2;
  __int128 v13 = *((_OWORD *)a1 + 3);
  uint64_t v8 = *(dispatch_queue_s **)(v13 + 136);
  uint64_t v14 = a3;
  block[4] = buf;
  dispatch_sync(v8, block);
  uint64_t v9 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = a1[6];
    *(_DWORD *)uint64_t v16 = 134217984;
    uint64_t v17 = v11;
    _os_log_debug_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEBUG,  "(Trust %p) Calling completion block after async xpc",  v16,  0xCu);
  }

  os_activity_scope_leave((os_activity_scope_state_t)(*(void *)(a1[5] + 8LL) + 24LL));
  (*(void (**)(void))(a1[4] + 16LL))();
  uint64_t v10 = (const void *)a1[6];
  if (v10) {
    CFRelease(v10);
  }
  _Block_object_dispose(buf, 8);
}

void __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_388(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  *(_DWORD *)(v2 + 112) = *(_DWORD *)(a1 + 64);
  uint64_t v3 = **(void **)(a1 + 48);
  uint64_t v4 = *(const void **)(v2 + 88);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(v2 + 8_Block_object_dispose(&a9, 8) = v3;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v7 = *(const void **)(v5 + 96);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v5 + 96) = v6;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 16LL);
  uint64_t v10 = *(const void **)(v8 + 72);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(v8 + 72) = v9;
  free(*(void **)(a1 + 48));
  uint64_t v11 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v11 + 112)
    && (OSStatus = SecErrorGetOSStatus(*(void *)(a1 + 56)), uint64_t v11 = *(void *)(a1 + 40), OSStatus == -25291)
    && (Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 16)), uint64_t v11 = *(void *)(a1 + 40), Count))
  {
    *(void *)values = CFArrayGetValueAtIndex(*(CFArrayRef *)(v11 + 16), 0LL);
    CFArrayRef v14 = CFArrayCreate(0LL, (const void **)values, 1LL, MEMORY[0x189605228]);
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(const void **)(v15 + 72);
    if (v16)
    {
      *(void *)(v15 + 72) = 0LL;
      CFRelease(v16);
      uint64_t v15 = *(void *)(a1 + 40);
    }

    *(void *)(v15 + 72) = v14;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }

  else
  {
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 0x40000000LL;
    uint64_t v19[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_389;
    unint64_t v19[3] = &__block_descriptor_tmp_390;
    void v19[4] = *(void *)(a1 + 56);
    void v19[5] = v11;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SecOSStatusWith((uint64_t)v19);
    uint64_t v17 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a1 + 40);
      *(_DWORD *)values = 134217984;
      *(void *)&values[4] = v18;
      _os_log_debug_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEBUG, "(Trust %p) Kick off pending evals", values, 0xCu);
    }

    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 40) + 168LL));
    *(_BYTE *)(*(void *)(a1 + 40) + 160LL) = 0;
  }

BOOL __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_2_389(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  return *(_DWORD *)(*(void *)(a1 + 40) + 112LL) != 0;
}

OSStatus SecTrustEvaluateAsyncWithError( SecTrustRef trust, dispatch_queue_t queue, SecTrustWithErrorCallback result)
{
  OSStatus v4 = -50;
  if (trust && queue)
  {
    if (result)
    {
      dispatch_assert_queue_V2(queue);
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 0x40000000LL;
      void v7[2] = __SecTrustEvaluateAsyncWithError_block_invoke;
      void v7[3] = &unk_189675038;
      UInt8 v7[4] = result;
      void v7[5] = trust;
      SecTrustEvaluateIfNecessaryFastAsync((uint64_t)trust, queue, (uint64_t)v7);
      return 0;
    }
  }

  return v4;
}

void __SecTrustEvaluateAsyncWithError_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    Error = SecCopyLastError(a2);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    if (Error) {
      CFRelease(Error);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2000000000LL;
    int v11 = 0;
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(dispatch_queue_s **)(v4 + 136);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustEvaluateAsyncWithError_block_invoke_2;
    void v7[3] = &unk_189675010;
    UInt8 v7[4] = &v8;
    void v7[5] = v4;
    dispatch_sync(v5, v7);
    SecTrustLogFailureDescription(*(__SecTrust **)(a1 + 40), *((_DWORD *)v9 + 6));
    CFErrorRef v6 = SecTrustCopyError(*(void *)(a1 + 40));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    if (v6) {
      CFRelease(v6);
    }
    _Block_object_dispose(&v8, 8);
  }

uint64_t __SecTrustEvaluateAsyncWithError_block_invoke_2(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 112LL);
  return result;
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  if (!trust) {
    return 0LL;
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  uint64_t v2 = (dispatch_queue_s *)*((void *)trust + 17);
  uint64_t v3 = MEMORY[0x1895F87A8];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustCopyKey_block_invoke;
  block[3] = &unk_189675088;
  block[4] = &v9;
  void block[5] = trust;
  dispatch_sync(v2, block);
  uint64_t v4 = (__SecKey *)v10[3];
  if (!v4)
  {
    SecTrustEvaluateIfNecessary(trust);
    uint64_t v5 = (dispatch_queue_s *)*((void *)trust + 17);
    v7[0] = v3;
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustCopyKey_block_invoke_2;
    void v7[3] = &unk_1896750B0;
    UInt8 v7[4] = &v9;
    void v7[5] = trust;
    dispatch_sync(v5, v7);
    uint64_t v4 = (__SecKey *)v10[3];
  }

  _Block_object_dispose(&v9, 8);
  return v4;
}

void *__SecTrustCopyKey_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(const void **)(v2 + 80);
  if (v3
    || (ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 16), 0LL),
        BOOL result = SecCertificateCopyKey(ValueAtIndex),
        *(void *)(*(void *)(a1 + 40) + 80LL) = result,
        (uint64_t v3 = *(const void **)(*(void *)(a1 + 40) + 80LL)) != 0LL))
  {
    BOOL result = (void *)CFRetain(v3);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
  }

  return result;
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    uint64_t v5 = 0LL;
    CFErrorRef v6 = &v5;
    uint64_t v7 = 0x2000000000LL;
    uint64_t v8 = 1LL;
    uint64_t v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __SecTrustGetCertificateCount_block_invoke;
    unint64_t v4[3] = &unk_1896750D8;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    SecTrustRef v1 = (SecTrustRef)v6[3];
    _Block_object_dispose(&v5, 8);
  }

  return (CFIndex)v1;
}

SecCertificateRef SecTrustGetCertificateAtIndex(SecTrustRef trust, CFIndex ix)
{
  SecTrustRef v2 = trust;
  if (trust)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    uint64_t v12 = 0LL;
    if (ix)
    {
      SecTrustEvaluateIfNecessary(trust);
      uint64_t v4 = (dispatch_queue_s *)*((void *)v2 + 17);
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 0x40000000LL;
      void v7[2] = __SecTrustGetCertificateAtIndex_block_invoke_2;
      void v7[3] = &unk_189675128;
      UInt8 v7[4] = &v9;
      void v7[5] = v2;
      void v7[6] = ix;
      uint64_t v5 = v7;
    }

    else
    {
      uint64_t v4 = (dispatch_queue_s *)*((void *)trust + 17);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 0x40000000LL;
      block[2] = __SecTrustGetCertificateAtIndex_block_invoke;
      block[3] = &unk_189675100;
      block[4] = &v9;
      void block[5] = v2;
      uint64_t v5 = block;
    }

    dispatch_sync(v4, v5);
    SecTrustRef v2 = (SecTrustRef)v10[3];
    _Block_object_dispose(&v9, 8);
  }

  return v2;
}

const void *__SecTrustGetCertificateAtIndex_block_invoke(uint64_t a1)
{
  BOOL result = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 40) + 16LL), 0LL);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

CFArrayRef SecTrustCopyCertificateChain(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    uint64_t v5 = 0LL;
    CFErrorRef v6 = &v5;
    uint64_t v7 = 0x2000000000LL;
    uint64_t v8 = 0LL;
    SecTrustEvaluateIfNecessary(trust);
    SecTrustRef v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __SecTrustCopyCertificateChain_block_invoke;
    unint64_t v4[3] = &unk_189675150;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    SecTrustRef v1 = (SecTrustRef)v6[3];
    _Block_object_dispose(&v5, 8);
  }

  return v1;
}

uint64_t __SecTrustCopyCertificateChain_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 40) + 72LL);
  if (result)
  {
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t result = (uint64_t)CFArrayCreateCopy(0LL, *(CFArrayRef *)(*(void *)(a1 + 40) + 72LL));
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
    }
  }

  return result;
}

__SecTrust *SecTrustCopyInfo(__SecTrust *a1)
{
  SecTrustRef v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    uint64_t v5 = 0LL;
    CFErrorRef v6 = &v5;
    uint64_t v7 = 0x2000000000LL;
    uint64_t v8 = 0LL;
    SecTrustRef v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __SecTrustCopyInfo_block_invoke;
    unint64_t v4[3] = &unk_189675178;
    void v4[4] = &v5;
    void v4[5] = v1;
    dispatch_sync(v2, v4);
    SecTrustRef v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }

  return v1;
}

void *__SecTrustCopyInfo_block_invoke(void *result)
{
  SecTrustRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v2 + 96));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  return result;
}

uint64_t SecTrustGetTrustExceptionsArray(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  CFErrorRef v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  SecTrustRef v1 = *(dispatch_queue_s **)(a1 + 136);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __SecTrustGetTrustExceptionsArray_block_invoke;
  unint64_t v4[3] = &unk_1896751A0;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecTrustGetTrustExceptionsArray_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(*(void *)(result + 40) + 104LL);
  return result;
}

CFDataRef SecTrustCopyExceptions(SecTrustRef trust)
{
  SecTrustRef Data = trust;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (trust)
  {
    uint64_t v44 = 0LL;
    __int128 v45 = &v44;
    uint64_t v46 = 0x2000000000LL;
    uint64_t v47 = 0LL;
    uint64_t v2 = (dispatch_queue_s *)*((void *)trust + 17);
    uint64_t v3 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustCopyExceptions_block_invoke;
    block[3] = &unk_1896751C8;
    block[4] = &v44;
    void block[5] = Data;
    dispatch_sync(v2, block);
    if (v45[3])
    {
      uint64_t v4 = (dispatch_queue_s *)*((void *)Data + 17);
      *(void *)__int128 buf = v3;
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      uint64_t v49 = &__block_descriptor_tmp_49_11982;
      SecTrustRef v50 = Data;
      dispatch_sync(v4, buf);
    }

    uint64_t v39 = 0LL;
    CFErrorRef v40 = &v39;
    uint64_t v41 = 0x2000000000LL;
    uint64_t v42 = 0LL;
    uint64_t v35 = 0LL;
    CFDataRef v36 = &v35;
    uint64_t v37 = 0x2000000000LL;
    uint64_t v38 = 0LL;
    SecTrustEvaluateIfNecessary(Data);
    uint64_t v5 = (dispatch_queue_s *)*((void *)Data + 17);
    v34[0] = v3;
    v34[1] = 0x40000000LL;
    v34[2] = __SecTrustCopyExceptions_block_invoke_2;
    void v34[3] = &unk_1896751F0;
    void v34[5] = &v35;
    v34[6] = Data;
    v34[4] = &v39;
    dispatch_sync(v5, v34);
    CFErrorRef v6 = (const __CFArray *)v40[3];
    if (v6) {
      uint64_t Count = CFArrayGetCount(v6);
    }
    else {
      uint64_t Count = 0LL;
    }
    uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count, MEMORY[0x189605228]);
    CFTypeRef cf = 0LL;
    ExceptionResetuint64_t Count = SecTrustGetExceptionResetCount(&cf);
    uint64_t valuePtr = ExceptionResetCount;
    uint64_t v11 = (os_log_s *)secLogObjForScope("trust");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      int v30 = "Error";
      if (!cf) {
        int v30 = "OK";
      }
      *(_DWORD *)__int128 buf = 134218242;
      *(void *)&uint8_t buf[4] = ExceptionResetCount;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v30;
      _os_log_debug_impl( &dword_1804F4000,  v11,  OS_LOG_TYPE_DEBUG,  "The current exceptions epoch is %llu. (%{public}s)",  buf,  0x16u);
    }

    CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
    if (Count >= 1)
    {
      CFIndex v13 = 0LL;
      CFArrayRef v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
      uint64_t v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v40[3], v13);
        CFIndex v17 = CFDictionaryGetCount(ValueAtIndex);
        if (v13 && v17 < 1)
        {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreate(v8, 0LL, 0LL, 0LL, v14, v15);
        }

        else
        {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v8, 0LL, ValueAtIndex);
          int v19 = (__CFData *)CFArrayGetValueAtIndex((CFArrayRef)v36[3], v13);
          SHA1Digest = SecCertificateGetSHA1Digest(v19);
          if (SHA1Digest)
          {
            CFDictionaryAddValue(MutableCopy, @"SHA1Digest", SHA1Digest);
          }

          else
          {
            uint64_t v21 = (os_log_s *)secLogObjForScope("SecError");
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 134217984;
              *(void *)&uint8_t buf[4] = v13;
              _os_log_impl( &dword_1804F4000,  v21,  OS_LOG_TYPE_DEFAULT,  "Unable to get digest of certificate at index %lld",  buf,  0xCu);
            }
          }

          if (valuePtr && !cf && v12) {
            CFDictionaryAddValue(MutableCopy, @"ExceptionResetCount", v12);
          }
        }

        CFArrayAppendValue(Mutable, MutableCopy);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        ++v13;
      }

      while (Count != v13);
    }

    if (v45[3])
    {
      CFIndex v22 = (dispatch_queue_s *)*((void *)Data + 17);
      uint64_t v23 = MEMORY[0x1895F87A8];
      v31[0] = MEMORY[0x1895F87A8];
      v31[1] = 0x40000000LL;
      int v31[2] = __SecTrustCopyExceptions_block_invoke_218;
      v31[3] = &unk_189675218;
      unint64_t v31[4] = &v44;
      void v31[5] = Data;
      dispatch_sync(v22, v31);
      OSStatus v24 = (dispatch_queue_s *)*((void *)Data + 17);
      *(void *)__int128 buf = v23;
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      uint64_t v49 = &__block_descriptor_tmp_49_11982;
      SecTrustRef v50 = Data;
      dispatch_sync(v24, buf);
    }

    if (Count >= 2)
    {
      unint64_t v25 = Count + 1;
      do
      {
        uint64_t v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v25 - 2);
        if (CFDictionaryGetCount(v26)) {
          break;
        }
        CFArrayRemoveValueAtIndex(Mutable, v25 - 2);
        --v25;
      }

      while (v25 > 2);
    }

    SecTrustRef Data = CFPropertyListCreateData(v8, Mutable, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
    CFRelease(Mutable);
    uint64_t v27 = (const void *)v40[3];
    if (v27) {
      CFRelease(v27);
    }
    CFIndex v28 = (const void *)v36[3];
    if (v28) {
      CFRelease(v28);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (cf) {
      CFRelease(cf);
    }
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(&v39, 8);
    _Block_object_dispose(&v44, 8);
  }

  return Data;
}

uint64_t __SecTrustCopyExceptions_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 104LL);
  if (v1)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v1;
    *(void *)(*(void *)(result + 40) + 104LL) = 0LL;
  }

  return result;
}

void *__SecTrustCopyExceptions_block_invoke_2(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8LL) + 24LL) = v5;
  return result;
}

uint64_t SecTrustGetExceptionResetCount(CFTypeRef *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = _os_activity_create( &dword_1804F4000,  "SecTrustExceptionGetResetCount",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v8.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v8);
  if (gTrustd && (uint64_t v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 176)) != 0LL)
  {
    uint64_t v4 = v3(a1);
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    uint64_t v12 = 0LL;
    *(void *)&__int128 buf = MEMORY[0x1895F87A8];
    *((void *)&buf + 1) = 0x40000000LL;
    CFArrayRef v14 = __to_uint_error_request_block_invoke;
    uint64_t v15 = &unk_189675D10;
    uint64_t v16 = &v9;
    CFIndex v17 = a1;
    securityd_send_sync_and_do(0x78u, a1, 0LL, (uint64_t)&buf);
    uint64_t v4 = v10[3];
    _Block_object_dispose(&v9, 8);
  }

  os_release(v2);
  if (a1)
  {
    if (*a1)
    {
      uint64_t v5 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "Failed to get the exceptions epoch.",  (uint8_t *)&buf,  2u);
      }
    }
  }

  CFErrorRef v6 = (os_log_s *)secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_debug_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEBUG, "The exceptions epoch is %lld.", (uint8_t *)&buf, 0xCu);
  }

  os_activity_scope_leave(&v8);
  return v4;
}

uint64_t __SecTrustCopyExceptions_block_invoke_218(uint64_t result)
{
  *(void *)(*(void *)(result + 40) + 104LL) = *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL);
  return result;
}

BOOL __to_uint_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, void *a3)
{
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, "status");
  if ((uint64 & 0x8000000000000000LL) != 0)
  {
    CFErrorRef v6 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEFAULT, "Invalid exceptions epoch.", v9, 2u);
    }

    if (*(void *)(a1 + 40)) {
      **(void **)(a1 + 40) = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F58], 34LL, 0LL);
    }
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = uint64;
  }

  if (a3)
  {
    uint64_t v7 = *(void **)(a1 + 40);
    if (v7)
    {
      if (*a3) {
        *uint64_t v7 = *a3;
      }
    }
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

BOOL SecTrustSetExceptions(SecTrustRef trust, CFDataRef exceptions)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (trust)
  {
    SecTrustRef v2 = trust;
    if (exceptions)
    {
      CFPropertyListRef v3 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x189604DB0], exceptions, 0LL, 0LL, 0LL);
      uint64_t v4 = v3;
      if (!v3 || (CFTypeID v5 = CFGetTypeID(v3), v5 == CFArrayGetTypeID()))
      {
LABEL_7:
        CFErrorRef v6 = (dispatch_queue_s *)*((void *)v2 + 17);
        uint64_t v7 = MEMORY[0x1895F87A8];
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 0x40000000LL;
        block[2] = __SecTrustSetExceptions_block_invoke;
        block[3] = &__block_descriptor_tmp_220;
        block[4] = v2;
        void block[5] = v4;
        dispatch_sync(v6, block);
        os_activity_scope_state_s v8 = (dispatch_queue_s *)*((void *)v2 + 17);
        *(void *)__int128 buf = v7;
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&uint8_t buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
        uint64_t v53 = &__block_descriptor_tmp_49_11982;
        unint64_t v54 = (CFTypeRef *)v2;
        dispatch_sync(v8, buf);
        CFTypeRef cf = 0LL;
        p_CFTypeRef cf = &cf;
        uint64_t v50 = 0x2000000000LL;
        uint64_t v51 = 0LL;
        unint64_t valuePtr = 0LL;
        p_unint64_t valuePtr = &valuePtr;
        uint64_t v46 = 0x2000000000LL;
        uint64_t v47 = 0LL;
        uint64_t v9 = (dispatch_queue_s *)*((void *)v2 + 17);
        *(void *)__int128 buf = v7;
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&uint8_t buf[16] = __SecTrustGetExceptionForCertificateAtIndex_block_invoke;
        uint64_t v53 = &unk_189675C50;
        uint64_t v55 = &valuePtr;
        SecTrustRef v56 = v2;
        unint64_t v54 = &cf;
        dispatch_sync(v9, buf);
        uint64_t v10 = (const __CFArray *)p_cf[3];
        if (!v10 || CFArrayGetCount(v10) < 1) {
          goto LABEL_18;
        }
        uint64_t v11 = (const __CFArray *)p_valuePtr[3];
        if (!v11)
        {
          int v19 = SecTrustCopyCertificateChain(v2);
          p_valuePtr[3] = (unint64_t)v19;
          if (!v19 || CFArrayGetCount(v19) < 1) {
            goto LABEL_18;
          }
          uint64_t v11 = (const __CFArray *)p_valuePtr[3];
        }

        ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(v11, 0LL);
        if (ValueAtIndex)
        {
          CFIndex v13 = ValueAtIndex;
          CFArrayRef v14 = CFArrayGetValueAtIndex((CFArrayRef)p_cf[3], 0LL);
          CFTypeID v15 = CFGetTypeID(v14);
          uint64_t v16 = 0LL;
          if (v15 != CFDictionaryGetTypeID()
            || (SHA1Digest = SecCertificateGetSHA1Digest(v13),
                (uint64_t v18 = CFDictionaryGetValue((CFDictionaryRef)v14, @"SHA1Digest")) != 0LL)
            && (uint64_t v16 = v14, CFEqual(SHA1Digest, v18)))
          {
LABEL_19:
            CFTypeRef v20 = p_cf[3];
            if (v20) {
              CFRelease(v20);
            }
            uint64_t v21 = (const void *)p_valuePtr[3];
            if (v21) {
              CFRelease(v21);
            }
            _Block_object_dispose(&valuePtr, 8);
            _Block_object_dispose(&cf, 8);
            if (v16)
            {
              if (v4)
              {
                CFTypeID v22 = CFGetTypeID(v4);
                if (v22 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)v4) < 1) {
                  goto LABEL_36;
                }
                uint64_t v23 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v4, 0LL);
                if (v23 && (OSStatus v24 = v23, v25 = CFGetTypeID(v23), v25 == CFDictionaryGetTypeID()))
                {
                  CFTypeRef cf = 0LL;
                  ExceptionResetuint64_t Count = SecTrustGetExceptionResetCount(&cf);
                  uint64_t v27 = (os_log_s *)secLogObjForScope("trust");
                  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v39 = "Error";
                    if (!cf) {
                      uint64_t v39 = "OK";
                    }
                    *(_DWORD *)__int128 buf = 134218242;
                    *(void *)&uint8_t buf[4] = ExceptionResetCount;
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v39;
                    _os_log_debug_impl( &dword_1804F4000,  v27,  OS_LOG_TYPE_DEBUG,  "The current exceptions epoch is %llu. (%{public}s)",  buf,  0x16u);
                  }

                  if (cf)
                  {
                    CFIndex v28 = (os_log_s *)secLogObjForScope("SecError");
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( &dword_1804F4000,  v28,  OS_LOG_TYPE_DEFAULT,  "Failed to get the current exceptions epoch.",  buf,  2u);
                    }

                    CFTypeRef v29 = cf;
                    if (cf)
                    {
                      CFTypeRef cf = 0LL;
                      CFRelease(v29);
                    }

                    goto LABEL_36;
                  }

                  if (!ExceptionResetCount) {
                    goto LABEL_50;
                  }
                  unint64_t Value = (const __CFNumber *)CFDictionaryGetValue(v24, @"ExceptionResetCount");
                  if (Value && (CFDataRef v36 = Value, v37 = CFGetTypeID(Value), v37 == CFNumberGetTypeID()))
                  {
                    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
                    if (CFNumberGetValue(v36, kCFNumberSInt64Type, &valuePtr))
                    {
                      if (valuePtr == ExceptionResetCount)
                      {
                        uint64_t v38 = (os_log_s *)secLogObjForScope("trust");
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)__int128 buf = 134217984;
                          *(void *)&uint8_t buf[4] = ExceptionResetCount;
                          _os_log_debug_impl( &dword_1804F4000,  v38,  OS_LOG_TYPE_DEBUG,  "Exceptions are valid for the current exceptions epoch. (%llu)",  buf,  0xCu);
                        }

CFTypeRef __SecTrustSetExceptions_block_invoke(uint64_t a1)
{
  SecTrustRef v2 = *(const void **)(*(void *)(a1 + 32) + 104LL);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 40);
  if (result)
  {
    CFTypeRef result = CFRetain(result);
    uint64_t v4 = *(void *)(a1 + 40);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *(void *)(*(void *)(a1 + 32) + 104LL) = v4;
  return result;
}

void *__SecTrustGetExceptionForCertificateAtIndex_block_invoke(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[6];
  uint64_t v3 = *(void *)(v2 + 104);
  if (v3) {
    CFTypeRef result = CFRetain(*(CFTypeRef *)(v2 + 104));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  uint64_t v4 = v1[6];
  uint64_t v5 = *(void *)(v4 + 72);
  if (v5) {
    CFTypeRef result = CFRetain(*(CFTypeRef *)(v4 + 72));
  }
  *(void *)(*(void *)(v1[5] + 8LL) + 24LL) = v5;
  return result;
}

void __SecTrustSetExceptions_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(const void **)(v1 + 104);
  if (v2)
  {
    *(void *)(v1 + 104) = 0LL;
    CFRelease(v2);
  }

CFArrayRef SecTrustCopySummaryPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  CFTypeRef result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    uint64_t v5 = result;
    ValueAtIndex = (double *)CFArrayGetValueAtIndex(result, a2);
    double VerifyTime = SecTrustGetVerifyTime(a1);
    CFMutableArrayRef v8 = SecCertificateCopySummaryProperties(ValueAtIndex, VerifyTime);
    CFRelease(v5);
    return v8;
  }

  return result;
}

CFArrayRef SecTrustCopyDetailedPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  CFTypeRef result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    uint64_t v4 = result;
    ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(result, a2);
    uint64_t v6 = CopyProperties(ValueAtIndex, 1);
    CFRelease(v4);
    return (const __CFArray *)v6;
  }

  return result;
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    uint64_t v15 = 0LL;
    uint64_t v16 = &v15;
    uint64_t v17 = 0x2000000000LL;
    uint64_t v18 = 0LL;
    uint64_t v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustCopyProperties_block_invoke;
    block[3] = &unk_189675280;
    block[4] = &v15;
    void block[5] = v1;
    dispatch_sync(v2, block);
    uint64_t v3 = (const __CFArray *)v16[3];
    if (!v3)
    {
      SecTrustRef v1 = 0LL;
LABEL_34:
      _Block_object_dispose(&v15, 8);
      return v1;
    }

    __int16 context = 0;
    CFIndex Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0LL; i != v5; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v16[3], i);
        CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)applyDetailProperty, &context);
      }
    }

    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
    SecTrustRef v1 = Mutable;
    __int16 v9 = context;
    if ((context & 1) != 0)
    {
      uint64_t v10 = @"Invalid certificate chain linkage.";
    }

    else
    {
      if ((context & 2) == 0)
      {
        if ((context & 4) != 0)
        {
          appendError(Mutable, @"Root certificate is not trusted.");
          __int16 v9 = context;
          if ((context & 8) == 0)
          {
LABEL_10:
            if ((v9 & 0x10) == 0) {
              goto LABEL_11;
            }
            goto LABEL_22;
          }
        }

        else if ((context & 8) == 0)
        {
          goto LABEL_10;
        }

        appendError(v1, @"Unable to build chain to root certificate.");
        __int16 v9 = context;
        if ((context & 0x10) == 0)
        {
LABEL_11:
          if ((v9 & 0x20) == 0) {
            goto LABEL_12;
          }
          goto LABEL_23;
        }

void *__SecTrustCopyProperties_block_invoke(void *result)
{
  SecTrustRef v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3) {
    CFTypeRef result = CFRetain(*(CFTypeRef *)(v2 + 88));
  }
  *(void *)(*(void *)(v1[4] + 8LL) + 24LL) = v3;
  return result;
}

CFNumberRef applyDetailProperty(void *key, uint64_t a2, _WORD *a3)
{
  if (applyDetailProperty_onceToken != -1) {
    dispatch_once(&applyDetailProperty_onceToken, &__block_literal_global_412);
  }
  CFTypeRef result = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)applyDetailProperty_policyChecks, key);
  __int16 valuePtr = 0;
  if (result)
  {
    CFTypeRef result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt16Type, &valuePtr);
    if (a3)
    {
      if ((_DWORD)result) {
        *a3 |= valuePtr;
      }
    }
  }

  return result;
}

void appendError(void *a1, const __CFString *a2)
{
  if (a2)
  {
    uint64_t v3 = SecFrameworkCopyLocalizedString(a2, @"SecCertificate");
    appendProperty(a1, @"error", 0LL, 0LL, v3, 1);
    if (v3) {
      CFRelease(v3);
    }
  }

void __applyDetailProperty_block_invoke()
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  __int16 valuePtr = 16;
  CFNumberRef v1 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SSLHostname", v1);
  if (v1) {
    CFRelease(v1);
  }
  __int16 valuePtr = 16;
  CFNumberRef v2 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"Email", v2);
  if (v2) {
    CFRelease(v2);
  }
  __int16 valuePtr = 64;
  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"TemporalValidity", v3);
  if (v3) {
    CFRelease(v3);
  }
  __int16 valuePtr = 64;
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidLeaf", v4);
  if (v4) {
    CFRelease(v4);
  }
  __int16 valuePtr = 128;
  CFNumberRef v5 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"WeakKeySize", v5);
  if (v5) {
    CFRelease(v5);
  }
  __int16 valuePtr = 256;
  CFNumberRef v6 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"WeakSignature", v6);
  if (v6) {
    CFRelease(v6);
  }
  __int16 valuePtr = 32;
  CFNumberRef v7 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"KeyUsage", v7);
  if (v7) {
    CFRelease(v7);
  }
  __int16 valuePtr = 32;
  CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ExtendedKeyUsage", v8);
  if (v8) {
    CFRelease(v8);
  }
  __int16 valuePtr = 32;
  CFNumberRef v9 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonName", v9);
  if (v9) {
    CFRelease(v9);
  }
  __int16 valuePtr = 32;
  CFNumberRef v10 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonNamePrefix", v10);
  if (v10) {
    CFRelease(v10);
  }
  __int16 valuePtr = 32;
  CFNumberRef v11 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectCommonNameTEST", v11);
  if (v11) {
    CFRelease(v11);
  }
  __int16 valuePtr = 32;
  CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectOrganization", v12);
  if (v12) {
    CFRelease(v12);
  }
  __int16 valuePtr = 32;
  CFNumberRef v13 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SubjectOrganizationalUnit", v13);
  if (v13) {
    CFRelease(v13);
  }
  __int16 valuePtr = 32;
  CFNumberRef v14 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NotValidBefore", v14);
  if (v14) {
    CFRelease(v14);
  }
  __int16 valuePtr = 16;
  CFNumberRef v15 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"EAPTrustedServerNames", v15);
  if (v15) {
    CFRelease(v15);
  }
  __int16 valuePtr = 32;
  CFNumberRef v16 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkerOid", v16);
  if (v16) {
    CFRelease(v16);
  }
  __int16 valuePtr = 32;
  CFNumberRef v17 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkerOidWithoutValueCheck", v17);
  if (v17) {
    CFRelease(v17);
  }
  __int16 valuePtr = 32;
  CFNumberRef v18 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafMarkersProdAndQA", v18);
  if (v18) {
    CFRelease(v18);
  }
  __int16 valuePtr = 512;
  CFNumberRef v19 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BlackListedLeaf", v19);
  if (v19) {
    CFRelease(v19);
  }
  __int16 valuePtr = 512;
  CFNumberRef v20 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"GrayListedLeaf", v20);
  if (v20) {
    CFRelease(v20);
  }
  __int16 valuePtr = 32;
  CFNumberRef v21 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"LeafSPKISHA256", v21);
  if (v21) {
    CFRelease(v21);
  }
  __int16 valuePtr = 32;
  CFNumberRef v22 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NotCA", v22);
  if (v22) {
    CFRelease(v22);
  }
  __int16 valuePtr = 32;
  CFNumberRef v23 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"MarkRepresentation", v23);
  if (v23) {
    CFRelease(v23);
  }
  __int16 valuePtr = 32;
  CFNumberRef v24 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerCommonName", v24);
  if (v24) {
    CFRelease(v24);
  }
  __int16 valuePtr = 32;
  CFNumberRef v25 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerCommonNamePrefix", v25);
  if (v25) {
    CFRelease(v25);
  }
  __int16 valuePtr = 64;
  CFNumberRef v26 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraints", v26);
  if (v26) {
    CFRelease(v26);
  }
  __int16 valuePtr = 64;
  CFNumberRef v27 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraintsCA", v27);
  if (v27) {
    CFRelease(v27);
  }
  __int16 valuePtr = 64;
  CFNumberRef v28 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicConstraintsPathLen", v28);
  if (v28) {
    CFRelease(v28);
  }
  __int16 valuePtr = 32;
  CFNumberRef v29 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateSPKISHA256", v29);
  if (v29) {
    CFRelease(v29);
  }
  __int16 valuePtr = 32;
  CFNumberRef v30 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateEKU", v30);
  if (v30) {
    CFRelease(v30);
  }
  __int16 valuePtr = 32;
  CFNumberRef v31 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateMarkerOid", v31);
  if (v31) {
    CFRelease(v31);
  }
  __int16 valuePtr = 32;
  CFNumberRef v32 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateMarkerOidWithoutValueCheck", v32);
  if (v32) {
    CFRelease(v32);
  }
  __int16 valuePtr = 32;
  CFNumberRef v33 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateOrganization", v33);
  if (v33) {
    CFRelease(v33);
  }
  __int16 valuePtr = 32;
  CFNumberRef v34 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IntermediateCountry", v34);
  if (v34) {
    CFRelease(v34);
  }
  __int16 valuePtr = 4;
  CFNumberRef v35 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorSHA256", v35);
  if (v35) {
    CFRelease(v35);
  }
  __int16 valuePtr = 4;
  CFNumberRef v36 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorTrusted", v36);
  if (v36) {
    CFRelease(v36);
  }
  __int16 valuePtr = 8;
  CFNumberRef v37 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"MissingIntermediate", v37);
  if (v37) {
    CFRelease(v37);
  }
  __int16 valuePtr = 4;
  CFNumberRef v38 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"AnchorApple", v38);
  if (v38) {
    CFRelease(v38);
  }
  __int16 valuePtr = 32;
  CFNumberRef v39 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CAspkiSHA256", v39);
  if (v39) {
    CFRelease(v39);
  }
  __int16 valuePtr = 64;
  CFNumberRef v40 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NonEmptySubject", v40);
  if (v40) {
    CFRelease(v40);
  }
  __int16 valuePtr = 1;
  CFNumberRef v41 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IdLinkage", v41);
  if (v41) {
    CFRelease(v41);
  }
  __int16 valuePtr = 128;
  CFNumberRef v42 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"KeySize", v42);
  if (v42) {
    CFRelease(v42);
  }
  __int16 valuePtr = 256;
  CFNumberRef v43 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SignatureHashAlgorithms", v43);
  if (v43) {
    CFRelease(v43);
  }
  __int16 valuePtr = 32;
  CFNumberRef v44 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CertificatePolicy", v44);
  if (v44) {
    CFRelease(v44);
  }
  __int16 valuePtr = 64;
  CFNumberRef v45 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidRoot", v45);
  if (v45) {
    CFRelease(v45);
  }
  __int16 valuePtr = 2;
  CFNumberRef v46 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CriticalExtensions", v46);
  if (v46) {
    CFRelease(v46);
  }
  __int16 valuePtr = 32;
  CFNumberRef v47 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ChainLength", v47);
  if (v47) {
    CFRelease(v47);
  }
  __int16 valuePtr = 64;
  CFNumberRef v48 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BasicCertificateProcessing", v48);
  if (v48) {
    CFRelease(v48);
  }
  __int16 valuePtr = 64;
  CFNumberRef v49 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NameConstraints", v49);
  if (v49) {
    CFRelease(v49);
  }
  __int16 valuePtr = 64;
  CFNumberRef v50 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"PolicyConstraints", v50);
  if (v50) {
    CFRelease(v50);
  }
  __int16 valuePtr = 512;
  CFNumberRef v51 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"GrayListedKey", v51);
  if (v51) {
    CFRelease(v51);
  }
  __int16 valuePtr = 512;
  CFNumberRef v52 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"BlackListedKey", v52);
  if (v52) {
    CFRelease(v52);
  }
  __int16 valuePtr = 4;
  CFNumberRef v53 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"UsageConstraints", v53);
  if (v53) {
    CFRelease(v53);
  }
  __int16 valuePtr = 256;
  CFNumberRef v54 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedWeakHash", v54);
  if (v54) {
    CFRelease(v54);
  }
  __int16 valuePtr = 128;
  CFNumberRef v55 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedWeakKey", v55);
  if (v55) {
    CFRelease(v55);
  }
  __int16 valuePtr = 32;
  CFNumberRef v56 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"PinningRequired", v56);
  if (v56) {
    CFRelease(v56);
  }
  __int16 valuePtr = 512;
  CFNumberRef v57 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"Revocation", v57);
  if (v57) {
    CFRelease(v57);
  }
  __int16 valuePtr = 32;
  CFNumberRef v58 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationResponseRequired", v58);
  if (v58) {
    CFRelease(v58);
  }
  __int16 valuePtr = 32;
  CFNumberRef v59 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"CTRequired", v59);
  if (v59) {
    CFRelease(v59);
  }
  __int16 valuePtr = 32;
  CFNumberRef v60 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustedCTRequired", v60);
  if (v60) {
    CFRelease(v60);
  }
  __int16 valuePtr = 512;
  CFNumberRef v61 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerPolicyConstraints", v61);
  if (v61) {
    CFRelease(v61);
  }
  __int16 valuePtr = 512;
  CFNumberRef v62 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"IssuerNameConstraints", v62);
  if (v62) {
    CFRelease(v62);
  }
  __int16 valuePtr = 32;
  CFNumberRef v63 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ValidityPeriodMaximums", v63);
  if (v63) {
    CFRelease(v63);
  }
  __int16 valuePtr = 32;
  CFNumberRef v64 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SystemTrustValidityPeriod", v64);
  if (v64) {
    CFRelease(v64);
  }
  __int16 valuePtr = 32;
  CFNumberRef v65 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"OtherTrustValidityPeriod", v65);
  if (v65) {
    CFRelease(v65);
  }
  __int16 valuePtr = 32;
  CFNumberRef v66 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ServerAuthEKU", v66);
  if (v66) {
    CFRelease(v66);
  }
  __int16 valuePtr = 32;
  CFNumberRef v67 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"EmailProtectionEKU", v67);
  if (v67) {
    CFRelease(v67);
  }
  __int16 valuePtr = 32;
  CFNumberRef v68 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"SinglePurposeChainEKU", v68);
  if (v68) {
    CFRelease(v68);
  }
  __int16 valuePtr = 64;
  CFNumberRef v69 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"UnparseableExtension", v69);
  if (v69) {
    CFRelease(v69);
  }
  __int16 valuePtr = 32;
  CFNumberRef v70 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NonTlsCTRequired", v70);
  if (v70) {
    CFRelease(v70);
  }
  __int16 valuePtr = 64;
  CFNumberRef v71 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"DuplicateExtension", v71);
  if (v71) {
    CFRelease(v71);
  }
  __int16 valuePtr = 32;
  CFNumberRef v72 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"NoNetworkAccess", v72);
  if (v72) {
    CFRelease(v72);
  }
  __int16 valuePtr = 32;
  CFNumberRef v73 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"ExtendedValidation", v73);
  if (v73) {
    CFRelease(v73);
  }
  __int16 valuePtr = 32;
  CFNumberRef v74 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationOnline", v74);
  if (v74) {
    CFRelease(v74);
  }
  __int16 valuePtr = 32;
  CFNumberRef v75 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationIfTrusted", v75);
  if (v75) {
    CFRelease(v75);
  }
  __int16 valuePtr = 32;
  CFNumberRef v76 = CFNumberCreate(0LL, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, @"RevocationDbIgnored", v76);
  if (v76) {
    CFRelease(v76);
  }
  applyDetailProperty_policyChecks = (uint64_t)Mutable;
}

CFDictionaryRef SecTrustCopyResult(SecTrustRef trust)
{
  SecTrustRef v1 = trust;
  if (trust)
  {
    uint64_t v10 = 0LL;
    CFNumberRef v11 = &v10;
    uint64_t v12 = 0x2000000000LL;
    CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    SecTrustEvaluateIfNecessary(v1);
    v8[0] = 0LL;
    v8[1] = v8;
    _DWORD v8[2] = 0x2000000000LL;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v15 = 0LL;
    CFNumberRef v16 = &v15;
    uint64_t v17 = 0x2000000000LL;
    uint64_t v18 = 0LL;
    CFNumberRef v2 = (dispatch_queue_s *)*((void *)v1 + 17);
    uint64_t v3 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = ___SecTrustCopyDetails_block_invoke;
    block[3] = &unk_189675CC0;
    block[4] = &v15;
    void block[5] = v1;
    dispatch_sync(v2, block);
    unint64_t v4 = v16[3];
    _Block_object_dispose(&v15, 8);
    unint64_t v9 = v4;
    CFNumberRef v5 = (dispatch_queue_s *)*((void *)v1 + 17);
    v7[0] = v3;
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustCopyResult_block_invoke;
    void v7[3] = &unk_1896752A8;
    UInt8 v7[4] = v8;
    void v7[5] = &v10;
    void v7[6] = v1;
    dispatch_sync(v5, v7);
    SecTrustRef v1 = (SecTrustRef)v11[3];
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(&v10, 8);
  }

  return v1;
}

void __SecTrustCopyResult_block_invoke(void *a1)
{
  CFNumberRef v2 = *(const void **)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v2)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL), @"TrustResultDetails", v2);
    CFRelease(*(CFTypeRef *)(*(void *)(a1[4] + 8LL) + 24LL));
  }

  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberSInt32Type, (const void *)(a1[6] + 112LL));
  if (v3)
  {
    CFNumberRef v4 = v3;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL), @"TrustResultValue", v3);
    CFRelease(v4);
  }

  uint64_t v5 = a1[6];
  CFNumberRef v6 = *(const __CFDictionary **)(v5 + 96);
  if (*(_DWORD *)(v5 + 112)) {
    BOOL v7 = v6 == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    CFNumberRef v8 = *(const void **)(v5 + 64);
    if (v8) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustEvaluationDate",  v8);
    }
    xpc_object_t value = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"CertificateTransparency", (const void **)&value)) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustCertificateTransparency",  value);
    }
    CFNumberRef v13 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"ExtendedValidation", (const void **)&v13)) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustExtendedValidation",  v13);
    }
    uint64_t v12 = (void *)0xAAAAAAAAAAAAAAAALL;
    CFNumberRef v11 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustRevocationChecked", (const void **)&v11)) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustRevocationChecked",  v11);
    }
    uint64_t v10 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustRevocationReason", (const void **)&v10)) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustRevocationReason",  v10);
    }
    unint64_t v9 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v6, @"TrustExpirationDate", (const void **)&v9)) {
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(a1[5] + 8LL) + 24LL),  @"TrustExpirationDate",  v9);
    }
  }

uint64_t SecTrustCopyTrustStoreContentDigest(CFTypeRef *a1)
{
  uint64_t v8 = 0LL;
  unint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 56)) != 0LL)
  {
    uint64_t v3 = v2(a1);
  }

  else
  {
    CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustCopyTrustStoreContentDigest",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __SecTrustCopyTrustStoreContentDigest_block_invoke_2;
    void v6[3] = &unk_189675310;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0x86u, a1, (uint64_t)&__block_literal_global_12182, (uint64_t)v6);
    os_release(v4);
    uint64_t v3 = v9[3];
    os_activity_scope_leave(&state);
  }

  _Block_object_dispose(&v8, 8);
  return v3;
}

BOOL __SecTrustCopyTrustStoreContentDigest_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (!xdict || !xpc_dictionary_get_value(xdict, "status") || MEMORY[0x186E0087C]() != MEMORY[0x1895F92E8]) {
    return SecError(-26276, a3, @"Unable to get trust store content digest");
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t __SecTrustCopyTrustStoreContentDigest_block_invoke()
{
  return 1LL;
}

uint64_t SecTrustCopyTrustStoreAssetVersion(CFTypeRef *a1)
{
  uint64_t v8 = 0LL;
  unint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  if (gTrustd && (CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 48)) != 0LL)
  {
    uint64_t v3 = v2(a1);
  }

  else
  {
    CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustCopyTrustStoreAssetVersion",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __SecTrustCopyTrustStoreAssetVersion_block_invoke_2;
    void v6[3] = &unk_189675378;
    void v6[4] = &v8;
    securityd_send_sync_and_do(0x87u, a1, (uint64_t)&__block_literal_global_250, (uint64_t)v6);
    os_release(v4);
    uint64_t v3 = v9[3];
    os_activity_scope_leave(&state);
  }

  _Block_object_dispose(&v8, 8);
  return v3;
}

BOOL __SecTrustCopyTrustStoreAssetVersion_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (!xdict || !xpc_dictionary_get_value(xdict, "status") || MEMORY[0x186E0087C]() != MEMORY[0x1895F92E8]) {
    return SecError(-26276, a3, @"Unable to get trust store asset version");
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t __SecTrustCopyTrustStoreAssetVersion_block_invoke()
{
  return 1LL;
}

uint64_t SecTrustGetTrustStoreVersionNumber(CFTypeRef *a1)
{
  if (gTrustd)
  {
    CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 64);
    if (v2) {
      return v2(a1);
    }
  }

  CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustGetTrustStoreVersionNumber",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  uint64_t v5 = do_ota_pki_op(0x13u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t do_ota_pki_op(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message = securityd_create_message(a1, a2);
  if (message)
  {
    CFNumberRef v4 = message;
    uint64_t v5 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a2);
    if (!v5)
    {
      uint64_t int64 = 0LL;
      os_activity_scope_state_s v6 = v4;
LABEL_15:
      xpc_release(v6);
      return uint64;
    }

    os_activity_scope_state_s v6 = v5;
    if (xpc_dictionary_get_value(v5, "status") && MEMORY[0x186E0087C]() == MEMORY[0x1895F92F0])
    {
      uint64_t int64 = xpc_dictionary_get_uint64(v6, "status");
      if (!a2)
      {
LABEL_14:
        xpc_release(v4);
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t int64 = 0LL;
      if (!a2) {
        goto LABEL_14;
      }
    }

    if (xpc_dictionary_get_value(v6, "error"))
    {
      if (MEMORY[0x186E0087C]() == MEMORY[0x1895F9250])
      {
        xpc_object_t value = xpc_dictionary_get_value(v6, "error");
        if (value) {
          *a2 = SecCreateCFErrorWithXPCObject(value);
        }
      }
    }

    goto LABEL_14;
  }

  return 0LL;
}

uint64_t SecTrustGetAssetVersionNumber(CFTypeRef *a1)
{
  if (gTrustd)
  {
    CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 72);
    if (v2) {
      return v2(a1);
    }
  }

  CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustGetAssetVersionNumber",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  uint64_t v5 = do_ota_pki_op(0x14u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTAPKIGetUpdatedAsset(CFTypeRef *a1)
{
  if (gTrustd)
  {
    CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 80);
    if (v2) {
      return v2(a1);
    }
  }

  CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustOTAPKIGetUpdatedAsset",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  uint64_t v5 = do_ota_pki_op(0x17u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTASecExperimentGetUpdatedAsset(CFTypeRef *a1)
{
  if (gTrustd)
  {
    CFNumberRef v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 88);
    if (v2) {
      return v2(a1);
    }
  }

  CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustOTASecExperimentGetUpdatedAsset",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  uint64_t v5 = do_ota_pki_op(0x77u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTASecExperimentCopyAsset(CFTypeRef *a1)
{
  uint64_t v5 = 0LL;
  os_activity_scope_state_s v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  if (gTrustd && (SecTrustRef v1 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 96)) != 0LL)
  {
    uint64_t v2 = v1(a1);
  }

  else
  {
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    void v4[2] = __SecTrustOTASecExperimentCopyAsset_block_invoke_2;
    unint64_t v4[3] = &unk_1896753E0;
    void v4[4] = &v5;
    securityd_send_sync_and_do(0x76u, a1, (uint64_t)&__block_literal_global_255, (uint64_t)v4);
    uint64_t v2 = v6[3];
  }

  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __SecTrustOTASecExperimentCopyAsset_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  if (!xdict || !xpc_dictionary_get_value(xdict, "status") || MEMORY[0x186E0087C]() != MEMORY[0x1895F9250]) {
    return SecError(-26276, a3, @"Unable to get SecExperiment Assets");
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = _CFXPCCreateCFObjectFromXPCObject();
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t __SecTrustOTASecExperimentCopyAsset_block_invoke()
{
  return 1LL;
}

uint64_t SecTrustTriggerValidUpdate(CFTypeRef *a1)
{
  if (gTrustd)
  {
    uint64_t v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 200);
    if (v2) {
      return v2(a1);
    }
  }

  CFNumberRef v4 = _os_activity_create( &dword_1804F4000,  "SecTrustTriggerValidUpdate",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  uint64_t v5 = do_ota_pki_op(0x7Cu, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5 != 0;
}

uint64_t SecTrustReportTLSAnalytics(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  BOOL v3 = 0LL;
  if (a1 && a2)
  {
    if (gTrustd)
    {
      uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gTrustd + 144);
      if (v7) {
        return v7(a1, a2, a3);
      }
    }

    unint64_t v9 = _os_activity_create( &dword_1804F4000,  "SecTrustReportTLSAnalytics",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v9, &state);
    uint64_t v12 = 0LL;
    CFNumberRef v13 = &v12;
    uint64_t v14 = 0x2000000000LL;
    char v15 = 0;
    UInt8 v10[4] = &v12;
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = __SecTrustReportTLSAnalytics_block_invoke;
    unint64_t v11[3] = &__block_descriptor_tmp_261;
    void v11[4] = a1;
    void v11[5] = a2;
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 0x40000000LL;
    _OWORD v10[2] = __SecTrustReportTLSAnalytics_block_invoke_2;
    unint64_t v10[3] = &unk_189675428;
    securityd_send_sync_and_do(0x73u, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v9);
    BOOL v3 = *((_BYTE *)v13 + 24) != 0;
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
  }

  return v3;
}

BOOL __SecTrustReportTLSAnalytics_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL v5 = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"eventName", *(const __CFString **)(a1 + 32), a3);
  if (v5) {
    xpc_dictionary_set_value(a2, "eventAttributes", *(xpc_object_t *)(a1 + 40));
  }
  return v5;
}

uint64_t __SecTrustReportTLSAnalytics_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

uint64_t SecTrustEvaluateLeafOnly(__SecTrust *a1, int *a2)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t result = SecTrustValidateInput(a1);
  if (!(_DWORD)result)
  {
    __int128 context = xmmword_180657B60;
    __int128 v53 = unk_180657B70;
    memset(v54, 170, sizeof(v54));
    uint64_t v48 = 0LL;
    CFNumberRef v49 = &v48;
    uint64_t v50 = 0x2000000000LL;
    uint64_t v51 = 0LL;
    uint64_t v44 = 0LL;
    CFNumberRef v45 = &v44;
    uint64_t v46 = 0x2000000000LL;
    uint64_t v47 = 0LL;
    BOOL v5 = (dispatch_queue_s *)*((void *)a1 + 17);
    uint64_t v6 = MEMORY[0x1895F87A8];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __SecTrustEvaluateLeafOnly_block_invoke;
    block[3] = &unk_189675498;
    void block[5] = &v44;
    void block[6] = a1;
    block[4] = &v48;
    dispatch_sync(v5, block);
    uint64_t v7 = (const void *)v49[3];
    uint64_t v8 = (const void *)v45[3];
    CFAbsoluteTime VerifyTime = SecTrustGetVerifyTime(a1);
    if (v7) {
      CFRetain(v7);
    }
    *(void *)&__int128 context = v7;
    if (v8) {
      CFRetain(v8);
    }
    *((void *)&context + 1) = v8;
    *(CFAbsoluteTime *)&__int128 v53 = VerifyTime;
    uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t v11 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], 0LL);
    CFDictionaryAddValue(Mutable, @"SSLHostname", SecPolicyCheckCertSSLHostname);
    CFDictionaryAddValue(Mutable, @"Email", SecPolicyCheckCertEmail);
    CFDictionaryAddValue(Mutable, @"TemporalValidity", SecPolicyCheckCertTemporalValidity);
    CFDictionaryAddValue(Mutable, @"ValidLeaf", SecPolicyCheckCertValidLeaf);
    CFDictionaryAddValue(Mutable, @"WeakKeySize", SecPolicyCheckCertWeakKeySize);
    CFDictionaryAddValue(Mutable, @"WeakSignature", SecPolicyCheckCertWeakSignature);
    CFDictionaryAddValue(Mutable, @"KeyUsage", SecPolicyCheckCertKeyUsage);
    CFDictionaryAddValue(Mutable, @"ExtendedKeyUsage", SecPolicyCheckCertExtendedKeyUsage);
    CFDictionaryAddValue(Mutable, @"SubjectCommonName", SecPolicyCheckCertSubjectCommonName);
    CFDictionaryAddValue(Mutable, @"SubjectCommonNamePrefix", SecPolicyCheckCertSubjectCommonNamePrefix);
    CFDictionaryAddValue(Mutable, @"SubjectCommonNameTEST", SecPolicyCheckCertSubjectCommonNameTEST);
    CFDictionaryAddValue(Mutable, @"SubjectOrganization", SecPolicyCheckCertSubjectOrganization);
    CFDictionaryAddValue(Mutable, @"SubjectOrganizationalUnit", SecPolicyCheckCertSubjectOrganizationalUnit);
    CFDictionaryAddValue(Mutable, @"NotValidBefore", SecPolicyCheckCertNotValidBefore);
    CFDictionaryAddValue(Mutable, @"EAPTrustedServerNames", SecPolicyCheckCertEAPTrustedServerNames);
    CFDictionaryAddValue(Mutable, @"LeafMarkerOid", SecPolicyCheckCertLeafMarkerOid);
    CFDictionaryAddValue( Mutable,  @"LeafMarkerOidWithoutValueCheck",  SecPolicyCheckCertLeafMarkerOidWithoutValueCheck);
    CFDictionaryAddValue(Mutable, @"LeafMarkersProdAndQA", SecPolicyCheckCertLeafMarkersProdAndQA);
    CFDictionaryAddValue(Mutable, @"NotCA", SecPolicyCheckCertNotCA);
    CFDictionaryAddValue(Mutable, @"NonEmptySubject", SecPolicyCheckCertNonEmptySubject);
    CFDictionaryAddValue(Mutable, @"KeySize", SecPolicyCheckCertKeySize);
    CFDictionaryAddValue(Mutable, @"SignatureHashAlgorithms", SecPolicyCheckCertSignatureHashAlgorithms);
    CFDictionaryAddValue(Mutable, @"CertificatePolicy", SecPolicyCheckCertCertificatePolicy);
    CFDictionaryAddValue(Mutable, @"CriticalExtensions", SecPolicyCheckCertCriticalExtensions);
    CFDictionaryAddValue(Mutable, @"UnparseableExtension", SecPolicyCheckCertUnparseableExtension);
    CFDictionaryAddValue(Mutable, @"DuplicateExtension", SecPolicyCheckCertDuplicateExtension);
    *((void *)&v54[0] + 1) = Mutable;
    *(void *)&v54[1] = 0LL;
    *(void *)values = CFDictionaryCreateMutable(v10, 0LL, v11, MEMORY[0x189605250]);
    BOOL v13 = 1;
    *((void *)&v53 + 1) = CFArrayCreate(v10, (const void **)values, 1LL, MEMORY[0x189605228]);
    CFRelease(*(CFTypeRef *)values);
    BYTE8(v54[1]) = 1;
    CFIndex Count = CFArrayGetCount((CFArrayRef)v8);
    if (Count < 1)
    {
      int v19 = 4;
    }

    else
    {
      CFIndex v15 = Count;
      for (CFIndex i = 0LL; i != v15; ++i)
      {
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)v8, i);
        *(void *)&v54[1] = i;
        CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)SecLeafPVCValidateKey, &context);
        if (BYTE8(v54[1])) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = *((void *)&v53 + 1) == 0LL;
        }
        if (v18)
        {
          BOOL v13 = 0;
          int v19 = 5;
          goto LABEL_20;
        }
      }

      BOOL v13 = BYTE8(v54[1]) != 0;
      if (BYTE8(v54[1])) {
        int v19 = 4;
      }
      else {
        int v19 = 5;
      }
    }

const void *__SecTrustEvaluateLeafOnly_block_invoke(void *a1)
{
  uint64_t result = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1[6] + 16LL), 0LL);
  BOOL v3 = result;
  if (result) {
    uint64_t result = CFRetain(result);
  }
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v3;
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void *)(v4 + 32);
  if (v5) {
    uint64_t result = CFRetain(*(CFTypeRef *)(v4 + 32));
  }
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = v5;
  return result;
}

void __SecTrustEvaluateLeafOnly_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_DWORD *)(v2 + 112) = *(_DWORD *)(a1 + 120);
  BOOL v3 = *(const void **)(v2 + 88);
  if (v3)
  {
    *(void *)(v2 + 8_Block_object_dispose(&a9, 8) = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    CFRetain(*(CFTypeRef *)(a1 + 64));
  }
  *(void *)(*(void *)(a1 + 32) + 88LL) = v4;
  CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0LL, 1LL, *(CFArrayRef *)(*(void *)(a1 + 32) + 16LL));
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(const void **)(v6 + 72);
  if (v7)
  {
    *(void *)(v6 + 72) = 0LL;
    CFRelease(v7);
    uint64_t v6 = *(void *)(a1 + 32);
  }

  *(void *)(v6 + 72) = MutableCopy;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  unint64_t v9 = Mutable;
  uint64_t v10 = *(const void **)(a1 + 104);
  if (v10) {
    CFDictionarySetValue(Mutable, @"TrustResultNotBefore", v10);
  }
  uint64_t v11 = *(const void **)(a1 + 112);
  if (v11) {
    CFDictionarySetValue(v9, @"TrustResultNotAfter", v11);
  }
  uint64_t v12 = *(void *)(a1 + 32);
  BOOL v13 = *(const void **)(v12 + 96);
  if (v13)
  {
    *(void *)(v12 + 96) = 0LL;
    CFRelease(v13);
    uint64_t v12 = *(void *)(a1 + 32);
  }

  *(void *)(v12 + 96) = v9;
}

SecTrustRef SecTrustDeserialize(const __CFData *a1, __CFString **a2, uint64_t a3)
{
  if (!a1)
  {
    SecError(-50, a2, @"null serialized trust input");
    return 0LL;
  }

  CFTypeRef v4 = CFPropertyListCreateWithDERData(0LL, a1, a3, 0LL, (CFTypeRef *)a2);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  SecTrustRef trust = 0LL;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5)) {
    goto LABEL_57;
  }
  unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"certificates");
  if (!Value) {
    goto LABEL_57;
  }
  CFMutableArrayRef v8 = SecCertificateArrayDeserialize(Value);
  if (!v8) {
    goto LABEL_57;
  }
  CFMutableArrayRef v9 = v8;
  uint64_t v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v5, @"policies");
  if (!v10
    || (v11 = v10, CFTypeID v12 = CFGetTypeID(v10), v12 != CFArrayGetTypeID())
    || (CFIndex Count = CFArrayGetCount(v11),
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count, MEMORY[0x189605228]),
        v57.CFIndex location = 0LL,
        v57.CFIndex length = Count,
        CFArrayApplyFunction(v11, v57, (CFArrayApplierFunction)deserializePolicy, Mutable),
        !Mutable))
  {
    CFRelease(v9);
LABEL_57:
    SecTrustRef v53 = 0LL;
    int v49 = -50;
    goto LABEL_58;
  }

  OSStatus v15 = SecTrustCreateWithCertificates(v9, Mutable, &trust);
  if (v15)
  {
    int v49 = v15;
    SecTrustRef v53 = 0LL;
    goto LABEL_53;
  }

  CFNumberRef v16 = CFDictionaryGetValue((CFDictionaryRef)v5, @"anchors");
  if (v16)
  {
    uint64_t v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFArrayGetTypeID())
    {
      CFMutableArrayRef v19 = SecCertificateArrayDeserialize(v17);
      *((void *)trust + 3) = v19;
    }
  }

  double v20 = CFDictionaryGetValue((CFDictionaryRef)v5, @"responses");
  if (v20)
  {
    double v21 = v20;
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 == CFArrayGetTypeID())
    {
      CFRetain(v21);
      *((void *)trust + 5) = v21;
    }
  }

  CFNumberRef v23 = CFDictionaryGetValue((CFDictionaryRef)v5, @"scts");
  if (v23)
  {
    CFDateRef v24 = v23;
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CFArrayGetTypeID())
    {
      CFRetain(v24);
      *((void *)trust + 6) = v24;
    }
  }

  CFNumberRef v26 = CFDictionaryGetValue((CFDictionaryRef)v5, @"trustedLogs");
  if (v26)
  {
    CFNumberRef v27 = v26;
    CFTypeID v28 = CFGetTypeID(v26);
    if (v28 == CFArrayGetTypeID())
    {
      CFRetain(v27);
      *((void *)trust + 7) = v27;
    }
  }

  CFNumberRef v29 = CFDictionaryGetValue((CFDictionaryRef)v5, @"verifyDate");
  if (v29)
  {
    CFNumberRef v30 = v29;
    CFTypeID v31 = CFGetTypeID(v29);
    if (v31 == CFDateGetTypeID())
    {
      CFRetain(v30);
      *((void *)trust + _Block_object_dispose(&a9, 8) = v30;
    }
  }

  CFNumberRef v32 = CFDictionaryGetValue((CFDictionaryRef)v5, @"chain");
  if (v32)
  {
    CFNumberRef v33 = v32;
    CFTypeID v34 = CFGetTypeID(v32);
    if (v34 == CFArrayGetTypeID())
    {
      CFMutableArrayRef v35 = SecCertificateArrayDeserialize(v33);
      *((void *)trust + 9) = v35;
    }
  }

  __int128 v36 = CFDictionaryGetValue((CFDictionaryRef)v5, @"details");
  if (v36)
  {
    __int128 v37 = v36;
    CFTypeID v38 = CFGetTypeID(v36);
    if (v38 == CFArrayGetTypeID())
    {
      CFRetain(v37);
      *((void *)trust + 11) = v37;
    }
  }

  __int128 v39 = CFDictionaryGetValue((CFDictionaryRef)v5, @"info");
  if (v39)
  {
    CFDateRef v40 = v39;
    CFTypeID v41 = CFGetTypeID(v39);
    if (v41 == CFDictionaryGetTypeID())
    {
      CFRetain(v40);
      *((void *)trust + 12) = v40;
    }
  }

  int v42 = CFDictionaryGetValue((CFDictionaryRef)v5, @"exceptions");
  if (v42)
  {
    CFNumberRef v43 = v42;
    CFTypeID v44 = CFGetTypeID(v42);
    if (v44 == CFArrayGetTypeID())
    {
      CFRetain(v43);
      *((void *)trust + 13) = v43;
    }
  }

  int valuePtr = -1;
  CFNumberRef v45 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v5, @"result");
  uint64_t v46 = v45;
  if (v45)
  {
    CFTypeID v47 = CFGetTypeID(v45);
    if (v47 == CFNumberGetTypeID())
    {
      int v48 = CFNumberGetValue(v46, kCFNumberSInt32Type, &valuePtr);
      LODWORD(v46) = 0;
      int v49 = -50;
      if (v48 && (valuePtr & 0x80000000) == 0)
      {
        int v49 = 0;
        *((_DWORD *)trust + 2_Block_object_dispose(&a9, 8) = valuePtr;
        LODWORD(v46) = 1;
      }

      goto LABEL_44;
    }

    LODWORD(v46) = 0;
  }

  int v49 = -50;
LABEL_44:
  uint64_t v50 = CFDictionaryGetValue((CFDictionaryRef)v5, @"keychainsAllowed");
  SecTrustRef v51 = trust;
  BOOL v52 = (_DWORD)v46 == 0;
  if ((_DWORD)v46) {
    SecTrustRef v53 = v51;
  }
  else {
    SecTrustRef v53 = 0LL;
  }
  if (!v52) {
    int v49 = 0;
  }
LABEL_53:
  CFRelease(Mutable);
  CFRelease(v9);
  if (v49) {
LABEL_58:
  }
    SecError(v49, a2, @"unable to create trust ref");
  CFRelease(v5);
  return v53;
}

CFMutableArrayRef SecCertificateArrayDeserialize(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID()) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count, MEMORY[0x189605228]);
  v6.CFIndex location = 0LL;
  v6.CFIndex length = Count;
  CFArrayApplyFunction((CFArrayRef)a1, v6, (CFArrayApplierFunction)deserializeCert, Mutable);
  return Mutable;
}

void deserializeCert(const void *a1, __CFArray *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      SecCertificateRef v5 = SecCertificateCreateWithData(0LL, (CFDataRef)a1);
      if (v5)
      {
        SecCertificateRef v6 = v5;
        CFArrayAppendValue(a2, v5);
        CFRelease(v6);
      }
    }
  }

uint64_t SecTrustIncrementExceptionResetCount(CFTypeRef *a1)
{
  CFTypeID v2 = _os_activity_create( &dword_1804F4000,  "SecTrustIncrementExceptionResetCount",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v9);
  if (gTrustd && (BOOL v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 168)) != 0LL)
  {
    char v4 = v3(a1);
  }

  else
  {
    uint64_t v15 = 0LL;
    CFNumberRef v16 = &v15;
    uint64_t v17 = 0x2000000000LL;
    char v18 = 0;
    *(void *)__int128 buf = MEMORY[0x1895F87A8];
    uint64_t v11 = 0x40000000LL;
    CFTypeID v12 = __to_BOOL_error_request_block_invoke;
    BOOL v13 = &unk_189675D38;
    uint64_t v14 = &v15;
    securityd_send_sync_and_do(0x79u, a1, 0LL, (uint64_t)buf);
    char v4 = *((_BYTE *)v16 + 24) != 0;
    _Block_object_dispose(&v15, 8);
  }

  os_release(v2);
  if (a1)
  {
    if (*a1) {
      char v5 = 0;
    }
    else {
      char v5 = v4;
    }
    if ((v5 & 1) != 0) {
      goto LABEL_10;
    }
  }

  else if ((v4 & 1) != 0)
  {
LABEL_10:
    uint64_t v6 = 0LL;
    goto LABEL_15;
  }

  uint64_t v7 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "Failed to increment the exceptions epoch.", buf, 2u);
  }

  uint64_t v6 = 4294941020LL;
LABEL_15:
  os_activity_scope_leave(&v9);
  return v6;
}

uint64_t SecTrustSetClientAuditToken(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967246LL;
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  char v5 = *(dispatch_queue_s **)(a1 + 136);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11982;
  block[4] = a1;
  dispatch_sync(v5, block);
  uint64_t v6 = *(dispatch_queue_s **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustSetClientAuditToken_block_invoke;
  void v8[3] = &__block_descriptor_tmp_275;
  void v8[4] = a1;
  void v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0LL;
}

void __SecTrustSetClientAuditToken_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  SecTrustRef v1 = *(const void **)(a1 + 40);
  BOOL v3 = *(const void **)(v2 + 144);
  if (v3 != v1)
  {
    *(void *)(v2 + 144) = v1;
  }

uint64_t SecTrustGetAppleAnchors()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecGetAppleTrustAnchors_block_invoke;
  block[3] = &__block_descriptor_tmp_1_13585;
  char v2 = 0;
  if (SecGetAppleTrustAnchors_onceToken != -1) {
    dispatch_once(&SecGetAppleTrustAnchors_onceToken, block);
  }
  return SecGetAppleTrustAnchors_anchors;
}

__CFString *SecTrustStoreForDomain(int a1)
{
  uint64_t result = off_189676200[a1 - 1];
  if (gTrustd) {
    return (__CFString *)(*(uint64_t (**)(__CFString *, void))gTrustd)(result, 0LL);
  }
  return result;
}

CFStringRef SecTrustStoreDomainName(CFTypeRef cf)
{
  CFTypeRef v1 = cf;
  if (cf)
  {
    if (gTrustd)
    {
      char v2 = @"user";
      char v2 = @"admin";
      char v2 = @"system";
    }

    else
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFStringGetTypeID()) {
        return (const __CFString *)v1;
      }
    }

    return 0LL;
  }

  return (const __CFString *)v1;
}

__CFString *SecTrustSettingsDomainName(unsigned int a1)
{
  if (a1 > 2) {
    return 0LL;
  }
  else {
    return off_189676218[a1];
  }
}

uint64_t SecTrustSettingsDomainForName(CFTypeRef cf2)
{
  if (!cf2) {
    return 0xFFFFFFFFLL;
  }
  if (CFEqual(@"user", cf2)) {
    return 0LL;
  }
  if (CFEqual(@"admin", cf2)) {
    return 1LL;
  }
  if (CFEqual(@"system", cf2)) {
    return 2LL;
  }
  return 0xFFFFFFFFLL;
}

BOOL SecTrustStoreContains(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = 0;
  if (!a1) {
    goto LABEL_5;
  }
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustStoreContains_block_invoke;
  void v8[3] = &unk_189675DA8;
  void v8[5] = a1;
  void v8[6] = a2;
  void v8[4] = &v9;
  if (SecOSStatusWith((uint64_t)v8))
  {
    CFTypeID v3 = (os_log_s *)secLogObjForScope("SecError");
    BOOL v4 = 0LL;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 141558274;
      uint64_t v14 = 1752392040LL;
      __int16 v15 = 2112;
      uint64_t v16 = a2;
      _os_log_impl( &dword_1804F4000,  v3,  OS_LOG_TYPE_DEFAULT,  "Failed to read trust settings for %{mask.hash}@",  buf,  0x16u);
LABEL_5:
      BOOL v4 = 0LL;
    }
  }

  else
  {
    if (!gTrustd)
    {
      char v5 = (os_log_s *)secLogObjForScope("truststore");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((_BYTE *)v10 + 24)) {
          uint64_t v6 = (const char *)&unk_18065A197;
        }
        else {
          uint64_t v6 = "do not ";
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v14 = (uint64_t)v6;
        __int16 v15 = 2160;
        uint64_t v16 = 1752392040LL;
        __int16 v17 = 2112;
        uint64_t v18 = a2;
        _os_log_impl( &dword_1804F4000,  v5,  OS_LOG_TYPE_DEFAULT,  "Trust settings %{public}s exist for %{mask.hash}@",  buf,  0x20u);
      }
    }

    BOOL v4 = *((_BYTE *)v10 + 24) != 0;
  }

  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t __SecTrustStoreContains_block_invoke(void *a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    CFTypeID v3 = *(uint64_t (**)(void, void, uint64_t, CFTypeRef *))(gTrustd + 8);
    if (v3) {
      return v3(a1[5], a1[6], *(void *)(a1[4] + 8LL) + 24LL, a2);
    }
  }

  uint64_t v5 = *(void *)(a1[4] + 8LL) + 24LL;
  __int128 v8 = *(_OWORD *)(a1 + 5);
  uint64_t v6 = _os_activity_create(&dword_1804F4000, "SecTrustStoreContains", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  void v9[4] = v5;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __string_cert_to_BOOL_BOOL_error_block_invoke;
  unint64_t v10[3] = &__block_descriptor_tmp_46_12242;
  __int128 v11 = v8;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __string_cert_to_BOOL_BOOL_error_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_47_12243;
  uint64_t v7 = securityd_send_sync_and_do(4u, a2, (uint64_t)v10, (uint64_t)v9);
  os_release(v6);
  os_activity_scope_leave(&state);
  return v7;
}

BOOL SecXPCDictionarySetCertificate(void *a1, uint64_t a2, __CFString **a3)
{
  if (!a2) {
    return SecError(-50, a3, @"NULL certificate");
  }
  int64_t v3 = *(void *)(a2 + 24);
  if (v3 < 1) {
    return SecError(-50, a3, @"NULL certificate");
  }
  xpc_dictionary_set_data(a1, "cert", *(const void **)(a2 + 16), v3);
  return 1LL;
}

uint64_t SecTrustStoreSetTrustSettings(uint64_t a1, void *a2, const __CFArray *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v22 = 0LL;
  CFNumberRef v23 = &v22;
  uint64_t v24 = 0x2000000000LL;
  int v25 = -1431655766;
  uint64_t v18 = 0LL;
  uint64_t v19 = (__CFArray **)&v18;
  uint64_t v20 = 0x2000000000LL;
  uint64_t v21 = 0LL;
  if ((SecCertificateIsCertificate(a2) & 1) != 0)
  {
    BOOL IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a2);
    *((_DWORD *)v23 + 6) = 0;
    int v7 = validateTrustSettings(IsSelfSigned, a3, v19 + 3);
    *((_DWORD *)v23 + 6) = v7;
    if (!v7)
    {
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 0x40000000LL;
      size_t v17[2] = __SecTrustStoreSetTrustSettings_block_invoke;
      unint64_t v17[3] = &unk_189675DF8;
      v17[6] = a1;
      v17[7] = a2;
      v17[4] = &v22;
      v17[5] = &v18;
      _os_activity_initiate(&dword_1804F4000, "SecTrustStoreSetTrustSettings", OS_ACTIVITY_FLAG_DEFAULT, v17);
      if (!*((_DWORD *)v23 + 6))
      {
        __int128 v8 = (os_log_s *)secLogObjForScope("truststore");
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_10;
        }
        *(_DWORD *)__int128 buf = 141558274;
        uint64_t v27 = 1752392040LL;
        __int16 v28 = 2112;
        CFNumberRef v29 = a2;
        uint64_t v9 = "Set TrustSettings for %{mask.hash}@";
        uint64_t v10 = v8;
        uint32_t v11 = 22;
        goto LABEL_9;
      }
    }
  }

  else
  {
    *((_DWORD *)v23 + 6) = -26275;
  }

  char v12 = (os_log_s *)secLogObjForScope("SecError");
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_10;
  }
  int v13 = *((_DWORD *)v23 + 6);
  *(_DWORD *)__int128 buf = 141558530;
  uint64_t v27 = 1752392040LL;
  __int16 v28 = 2112;
  CFNumberRef v29 = a2;
  __int16 v30 = 1024;
  int v31 = v13;
  uint64_t v9 = "Failed set trust settings for %{mask.hash}@, %d";
  uint64_t v10 = v12;
  uint32_t v11 = 28;
LABEL_9:
  _os_log_impl(&dword_1804F4000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_10:
  uint64_t v14 = v19[3];
  if (v14)
  {
    unint64_t v19[3] = 0LL;
    CFRelease(v14);
  }

  uint64_t v15 = *((unsigned int *)v23 + 6);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v15;
}

uint64_t validateTrustSettings(uint64_t a1, const __CFArray *a2, __CFArray **a3)
{
  if ((_DWORD)a1 && !a2) {
    return 0LL;
  }
  if (!(_DWORD)a1 && !a2) {
    return 4294967246LL;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    CFTypeID v14 = CFArrayGetTypeID();
    if (v14 == CFGetTypeID(a2))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
      if (!Mutable) {
        return 4294967188LL;
      }
      CFMutableArrayRef MutableCopy = Mutable;
      CFIndex Count = CFArrayGetCount(a2);
      if (Count < 1)
      {
        uint64_t v6 = 4294967246LL;
      }

      else
      {
        CFIndex v17 = Count;
        CFIndex v18 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, v18);
          xpc_object_t value = 0LL;
          uint64_t v20 = validateTrustSettings(a1, ValueAtIndex, &value);
          if ((_DWORD)v20) {
            break;
          }
          CFArrayAppendValue(MutableCopy, value);
          uint64_t v21 = value;
          if (value)
          {
            xpc_object_t value = 0LL;
            CFRelease(v21);
          }

          if (v17 == ++v18) {
            goto LABEL_31;
          }
        }

        uint64_t v6 = v20;
      }

      goto LABEL_38;
    }

    return 4294967246LL;
  }

  CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, a2);
  uint64_t v9 = CFDictionaryGetValue(MutableCopy, @"kSecTrustSettingsResult");
  int valuePtr = 0;
  if (v9)
  {
    uint64_t v10 = v9;
    CFTypeID v11 = CFGetTypeID(v9);
    CFTypeID v12 = CFNumberGetTypeID();
    if (!(_DWORD)a1 && v11 != v12) {
      goto LABEL_16;
    }
    CFTypeID v13 = CFGetTypeID(v10);
    if (v13 == CFNumberGetTypeID()
      && CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt32Type, &valuePtr)
      && ((_DWORD)a1 && valuePtr == 2 || !(_DWORD)a1 && valuePtr == 1))
    {
      goto LABEL_16;
    }
  }

  else if (!(_DWORD)a1)
  {
LABEL_16:
    uint64_t v6 = 4294967246LL;
    goto LABEL_32;
  }

  uint64_t v22 = CFDictionaryGetValue(MutableCopy, @"kSecTrustSettingsPolicy");
  if (v22)
  {
    CFNumberRef v23 = (const void *)*((void *)v22 + 3);
    CFDictionarySetValue(MutableCopy, @"kSecTrustSettingsPolicy", *((const void **)v22 + 2));
    if (v23) {
      CFDictionaryAddValue(MutableCopy, @"kSecTrustSettingsPolicyName", v23);
    }
  }

uint64_t __SecTrustStoreSetTrustSettings_block_invoke(uint64_t a1)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecTrustStoreSetTrustSettings_block_invoke_2;
  v3[3] = &unk_189675DD0;
  uint64_t v5 = *(void *)(a1 + 56);
  __int128 v4 = *(_OWORD *)(a1 + 40);
  uint64_t result = SecOSStatusWith((uint64_t)v3);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t __SecTrustStoreSetTrustSettings_block_invoke_2(void *a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    char v2 = *(uint64_t (**)(void, void, void, CFTypeRef *))(gTrustd + 16);
    if (v2) {
      return v2(a1[5], a1[6], *(void *)(*(void *)(a1[4] + 8LL) + 24LL), a2);
    }
  }

  uint64_t v4 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __string_cert_cftype_to_error_block_invoke;
  v5[3] = &__block_descriptor_tmp_56_12253;
  __int128 v6 = *(_OWORD *)(a1 + 5);
  uint64_t v7 = v4;
  return securityd_send_sync_and_do(5u, a2, (uint64_t)v5, 0LL);
}

size_t __string_cert_cftype_to_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    size_t result = SecXPCDictionarySetCertificate(a2, *(void *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      CFTypeID v11 = *(const __CFString **)(a1 + 48);
      if (v11) {
        return SecXPCDictionarySetPListWithRepair(a2, "settings", v11, a3, v7, v8, v9, v10);
      }
      else {
        return 1LL;
      }
    }
  }

  return result;
}

uint64_t SecTrustStoreRemoveCertificate(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreRemoveCertificate",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (!a1)
  {
    uint64_t v5 = 4294967246LL;
LABEL_3:
    __int128 v6 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 141558530;
      uint64_t v12 = 1752392040LL;
      __int16 v13 = 2112;
      uint64_t v14 = a2;
      __int16 v15 = 1024;
      int v16 = v5;
      _os_log_impl( &dword_1804F4000,  v6,  OS_LOG_TYPE_DEFAULT,  "Failed to remove trust settings for %{mask.hash}@, %d",  buf,  0x1Cu);
    }

    goto LABEL_7;
  }

  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __SecTrustStoreRemoveCertificate_block_invoke;
  v9[3] = &__block_descriptor_tmp_8_12261;
  void v9[4] = a1;
  void v9[5] = a2;
  uint64_t v5 = SecOSStatusWith((uint64_t)v9);
  if ((_DWORD)v5) {
    goto LABEL_3;
  }
  uint64_t v7 = (os_log_s *)secLogObjForScope("truststore");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 141558274;
    uint64_t v12 = 1752392040LL;
    __int16 v13 = 2112;
    uint64_t v14 = a2;
    _os_log_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEFAULT, "Removed TrustSettings for %{mask.hash}@", buf, 0x16u);
    uint64_t v5 = 0LL;
  }

uint64_t __SecTrustStoreRemoveCertificate_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    char v2 = *(uint64_t (**)(void, void, CFTypeRef *))(gTrustd + 24);
    if (v2) {
      return v2(*(void *)(a1 + 32), *(void *)(a1 + 40), a2);
    }
  }

  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __string_cert_to_BOOL_error_block_invoke;
  unint64_t v4[3] = &__block_descriptor_tmp_57_12264;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  return securityd_send_sync_and_do(6u, a2, (uint64_t)v4, 0LL);
}

uint64_t SecTrustStoreGetSettingsVersionNumber(_DWORD *a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  CFErrorRef err = 0LL;
  *a1 = SecTrustGetTrustStoreVersionNumber((CFTypeRef *)&err);
  if (!err) {
    return 0LL;
  }
  CFIndex Code = CFErrorGetCode(err);
  if (err) {
    CFRelease(err);
  }
  return Code;
}

uint64_t SecTrustStoreGetSettingsAssetVersionNumber(_DWORD *a1)
{
  if (!a1) {
    return 4294967246LL;
  }
  CFErrorRef err = 0LL;
  *a1 = SecTrustGetAssetVersionNumber((CFTypeRef *)&err);
  if (!err) {
    return 0LL;
  }
  CFIndex Code = CFErrorGetCode(err);
  if (err) {
    CFRelease(err);
  }
  return Code;
}

uint64_t SecTrustStoreCopyAll(uint64_t a1, void *a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  uint64_t v4 = _os_activity_create(&dword_1804F4000, "SecTrustStoreCopyAll", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (a1)
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __SecTrustStoreCopyAll_block_invoke;
    void v7[3] = &unk_189675E40;
    UInt8 v7[4] = &v9;
    void v7[5] = a1;
    uint64_t v5 = SecOSStatusWith((uint64_t)v7);
    *a2 = v10[3];
  }

  else
  {
    uint64_t v5 = 4294967246LL;
  }

  os_release(v4);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t __SecTrustStoreCopyAll_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    char v2 = *(uint64_t (**)(void, uint64_t, CFTypeRef *))(gTrustd + 120);
    if (v2) {
      return v2(*(void *)(a1 + 40), *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, a2);
    }
  }

  uint64_t v4 = *(void *)(a1 + 40);
  void v5[4] = *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = __string_to_array_error_block_invoke;
  void v6[3] = &__block_descriptor_tmp_58_12267;
  void v6[4] = v4;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __string_to_array_error_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_59_12268;
  return securityd_send_sync_and_do(0x64u, a2, (uint64_t)v6, (uint64_t)v5);
}

BOOL __string_to_array_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_array_error_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL result = 1;
  if (*(void *)(a1 + 32))
  {
    **(void **)(a1 + 32) = SecXPCDictionaryCopyArray(a2, "status", a3);
    if (!**(void **)(a1 + 32)) {
      return 0;
    }
  }

  return result;
}

uint64_t SecTrustStoreCopyUsageConstraints(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v20 = 0LL;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000LL;
  uint64_t v23 = 0LL;
  __int128 v6 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreCopyUsageConstraints",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  uint64_t v7 = 4294967246LL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v18[0] = MEMORY[0x1895F87A8];
        v18[1] = 0x40000000LL;
        void v18[2] = __SecTrustStoreCopyUsageConstraints_block_invoke;
        void v18[3] = &unk_189675E68;
        void v18[5] = a1;
        v18[6] = a2;
        v18[4] = &v20;
        uint64_t v7 = SecOSStatusWith((uint64_t)v18);
        uint64_t v8 = v21;
        *a3 = v21[3];
        if (!(_DWORD)v7)
        {
          uint64_t v10 = (const __CFArray *)v8[3];
          if (!v10)
          {
            __int16 v15 = (os_log_s *)secLogObjForScope("truststore");
            uint64_t v7 = 0LL;
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_18;
            }
            *(_DWORD *)__int128 buf = 141558274;
            uint64_t v25 = 1752392040LL;
            __int16 v26 = 2112;
            uint64_t v27 = a2;
            uint64_t v14 = "Found no trust settings for %{mask.hash}@";
            int v16 = v15;
            goto LABEL_16;
          }

          CFIndex Count = CFArrayGetCount(v10);
          uint64_t v12 = (os_log_s *)secLogObjForScope("truststore");
          BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
          if (Count)
          {
            if (v13)
            {
              *(_DWORD *)__int128 buf = 141558274;
              uint64_t v25 = 1752392040LL;
              __int16 v26 = 2112;
              uint64_t v27 = a2;
              uint64_t v14 = "Found usage constraints for %{mask.hash}@";
LABEL_15:
              int v16 = v12;
LABEL_16:
              _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, v14, buf, 0x16u);
            }
          }

          else if (v13)
          {
            *(_DWORD *)__int128 buf = 141558274;
            uint64_t v25 = 1752392040LL;
            __int16 v26 = 2112;
            uint64_t v27 = a2;
            uint64_t v14 = "Found no usage constraints for %{mask.hash}@";
            goto LABEL_15;
          }

          uint64_t v7 = 0LL;
          goto LABEL_18;
        }
      }
    }
  }

  uint64_t v9 = (os_log_s *)secLogObjForScope("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 141558530;
    uint64_t v25 = 1752392040LL;
    __int16 v26 = 2112;
    uint64_t v27 = a2;
    __int16 v28 = 1024;
    int v29 = v7;
    _os_log_impl( &dword_1804F4000,  v9,  OS_LOG_TYPE_DEFAULT,  "Failed to get usage contraints for %{mask.hash}@, %d",  buf,  0x1Cu);
  }

uint64_t __SecTrustStoreCopyUsageConstraints_block_invoke(void *a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    char v2 = *(uint64_t (**)(void, void, uint64_t, CFTypeRef *))(gTrustd + 128);
    if (v2) {
      return v2(a1[5], a1[6], *(void *)(a1[4] + 8LL) + 24LL, a2);
    }
  }

  void v4[4] = *(void *)(a1[4] + 8LL) + 24LL;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __string_cert_to_array_error_block_invoke;
  v5[3] = &__block_descriptor_tmp_60_12275;
  __int128 v6 = *(_OWORD *)(a1 + 5);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  void v4[2] = __string_cert_to_array_error_block_invoke_2;
  unint64_t v4[3] = &__block_descriptor_tmp_61_12276;
  return securityd_send_sync_and_do(0x65u, a2, (uint64_t)v5, (uint64_t)v4);
}

BOOL __string_cert_to_array_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  BOOL result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if ((_DWORD)result) {
    return SecXPCDictionarySetCertificate(a2, *(void *)(a1 + 40), a3);
  }
  return result;
}

BOOL __string_cert_to_array_error_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", *(void **)(a1 + 32), a3);
}

uint64_t SecTrustStoreRemoveAll(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  char v2 = _os_activity_create(&dword_1804F4000, "SecTrustStoreRemoveAll", MEMORY[0x1895F8D48], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  if (!a1)
  {
    uint64_t v3 = 4294967246LL;
LABEL_3:
    uint64_t v4 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v10 = v3;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Failed to remove all trust settings, %d", buf, 8u);
    }

    goto LABEL_7;
  }

  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  void v7[2] = __SecTrustStoreRemoveAll_block_invoke;
  void v7[3] = &__block_descriptor_tmp_11_12278;
  UInt8 v7[4] = a1;
  uint64_t v3 = SecOSStatusWith((uint64_t)v7);
  if ((_DWORD)v3) {
    goto LABEL_3;
  }
  uint64_t v5 = (os_log_s *)secLogObjForScope("truststore");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEFAULT, "Removed all trust settings", buf, 2u);
    uint64_t v3 = 0LL;
  }

uint64_t __SecTrustStoreRemoveAll_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    char v2 = *(uint64_t (**)(void))(gTrustd + 32);
    if (v2) {
      return v2(*(void *)(a1 + 32));
    }
  }

  uint64_t v4 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  _DWORD v5[2] = __string_to_error_block_invoke;
  v5[3] = &__block_descriptor_tmp_62_12281;
  void v5[4] = v4;
  return securityd_send_sync_and_do(0x81u, a2, (uint64_t)v5, (uint64_t)&__block_literal_global_12282);
}

BOOL __string_to_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_error_block_invoke_2()
{
  return 1LL;
}

uint64_t SecTrustStoreSetCTExceptions(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 152);
    if (v6) {
      return v6(a1, a2, a3);
    }
  }

  else if (gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 152);
    if (v6)
    {
      a1 = @"com.apple.trusttests";
      return v6(a1, a2, a3);
    }
  }

  uint64_t v8 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreSetCTExceptions",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  uint64_t v12 = 0LL;
  BOOL v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 0;
  void v10[4] = &v12;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = __SecTrustStoreSetCTExceptions_block_invoke;
  unint64_t v11[3] = &__block_descriptor_tmp_24_12286;
  void v11[4] = a2;
  void v11[5] = v5;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __SecTrustStoreSetCTExceptions_block_invoke_2;
  unint64_t v10[3] = &unk_189675F00;
  securityd_send_sync_and_do(0x74u, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  uint64_t v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t __SecTrustStoreSetCTExceptions_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "exceptions", v11, a3, a5, a6, a7, a8);
  }
  uint64_t v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreSetCTExceptions_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

uint64_t SecTrustStoreCopyCTExceptions(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 160);
    if (v4) {
      return v4(a1, a2);
    }
  }

  __int128 v6 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreCopyCTExceptions",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  void v8[4] = &v10;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __SecTrustStoreCopyCTExceptions_block_invoke;
  v9[3] = &__block_descriptor_tmp_26_12292;
  void v9[4] = a1;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustStoreCopyCTExceptions_block_invoke_2;
  void v8[3] = &unk_189675F48;
  securityd_send_sync_and_do(0x75u, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  uint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

uint64_t __SecTrustStoreCopyCTExceptions_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreCopyCTExceptions_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1LL;
}

uint64_t SecTrustStoreSetCARevocationAdditions(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 184);
    if (v6) {
      return v6(a1, a2, a3);
    }
  }

  else if (gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 184);
    if (v6)
    {
      a1 = @"com.apple.trusttests";
      return v6(a1, a2, a3);
    }
  }

  uint64_t v8 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreSetCARevocationAdditions",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 0;
  void v10[4] = &v12;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke;
  unint64_t v11[3] = &__block_descriptor_tmp_31_12295;
  void v11[4] = a2;
  void v11[5] = v5;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke_2;
  unint64_t v10[3] = &unk_189675FA8;
  securityd_send_sync_and_do(0x7Au, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  uint64_t v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t __SecTrustStoreSetCARevocationAdditions_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "revocationCheck", v11, a3, a5, a6, a7, a8);
  }
  uint64_t v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreSetCARevocationAdditions_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

uint64_t SecTrustStoreCopyCARevocationAdditions(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 192);
    if (v4) {
      return v4(a1, a2);
    }
  }

  __int128 v6 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreCopyCARevocationAdditions",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  void v8[4] = &v10;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke;
  v9[3] = &__block_descriptor_tmp_33_12299;
  void v9[4] = a1;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke_2;
  void v8[3] = &unk_189675FF0;
  securityd_send_sync_and_do(0x7Bu, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  uint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

uint64_t __SecTrustStoreCopyCARevocationAdditions_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreCopyCARevocationAdditions_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1LL;
}

uint64_t SecTrustStoreSetTransparentConnectionPins(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5 = a1;
  if (a1 && gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 208);
    if (v6) {
      return v6(a1, a2, a3);
    }
  }

  else if (gTrustd)
  {
    __int128 v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 208);
    if (v6)
    {
      a1 = @"com.apple.trusttests";
      return v6(a1, a2, a3);
    }
  }

  uint64_t v8 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreSetTransparentConnectionPins",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  char v15 = 0;
  void v10[4] = &v12;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 0x40000000LL;
  _OWORD v11[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke;
  unint64_t v11[3] = &__block_descriptor_tmp_36_12302;
  void v11[4] = a2;
  void v11[5] = v5;
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke_2;
  unint64_t v10[3] = &unk_189676038;
  securityd_send_sync_and_do(0x7Du, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  uint64_t v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t __SecTrustStoreSetTransparentConnectionPins_block_invoke( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(const __CFString **)(a1 + 32);
  if (v11) {
    SecXPCDictionarySetPListWithRepair(a2, "anchors", v11, a3, a5, a6, a7, a8);
  }
  uint64_t v12 = *(const __CFString **)(a1 + 40);
  if (v12) {
    SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"appID", v12, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreSetTransparentConnectionPins_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1LL;
}

uint64_t SecTrustStoreCopyTransparentConnectionPins(uint64_t a1, CFTypeRef *a2)
{
  if (gTrustd)
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 216);
    if (v4) {
      return v4(a1, a2);
    }
  }

  __int128 v6 = _os_activity_create( &dword_1804F4000,  "SecTrustStoreCopyTransparentConnectionPins",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  void v8[4] = &v10;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 0x40000000LL;
  _OWORD v9[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke;
  v9[3] = &__block_descriptor_tmp_38_12306;
  void v9[4] = a1;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke_2;
  void v8[3] = &unk_189676080;
  securityd_send_sync_and_do(0x7Eu, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  uint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

uint64_t __SecTrustStoreCopyTransparentConnectionPins_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4 = *(const __CFString **)(a1 + 32);
  if (v4) {
    SecXPCDictionarySetString(a2, (uint64_t)"appID", v4, a3);
  }
  return 1LL;
}

uint64_t __SecTrustStoreCopyTransparentConnectionPins_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return 1LL;
}

BOOL SecXPCDictionarySetData(void *a1, const char *a2, CFDataRef theData, __CFString **a4)
{
  if (!theData) {
    return SecError(-50, a4, @"data for key %s is NULL", a2);
  }
  if (CFDataGetLength(theData) < 0) {
    return SecError(-50, a4, @"no data for key %s", a2);
  }
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  xpc_dictionary_set_data(a1, a2, BytePtr, Length);
  return 1LL;
}

CFDataRef SecXPCDictionaryCopyData(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0LL;
  uint64_t data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000LL) != 0)
    {
      SecError(-50, a3, @"too large data for key %s", a2);
    }

    else
    {
      CFDataRef result = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], data, length);
      if (result) {
        return result;
      }
      SecError(-50, a3, @"failed to create data for key %s", a2);
    }
  }

  else
  {
    SecError(-50, a3, @"no data for key %s", a2);
  }

  return 0LL;
}

CFStringRef SecXPCDictionaryCopyString(void *a1, __CFString **a2)
{
  string = xpc_dictionary_get_string(a1, "status");
  if (string)
  {
    uint64_t v4 = string;
    CFStringRef result = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], string, 0x8000100u);
    if (result) {
      return result;
    }
    SecError(-108, a2, @"object for key %s failed to convert %s to CFString", "status", v4);
  }

  else
  {
    SecError(-50, a2, @"object for key %s not string", "status");
  }

  return 0LL;
}

uint64_t safeContentsParse(uint64_t **a1, unint64_t a2, char *a3)
{
  uint64_t v22 = 0LL;
  if (*a1) {
    BOOL v3 = a3 == 0LL;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v22) {
    return 0LL;
  }
  if (!*v22) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  while (v22[++v5])
    ;
  if (!(_DWORD)v5) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v9 = (const __CFAllocator *)*MEMORY[0x189604DC8];
  uint64_t v10 = 8LL * v5;
  while (2)
  {
    uint64_t v11 = v22[v7 / 8];
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
    switch(*(_DWORD *)(v11 + 16))
    {
      case 1:
      case 4:
      case 5:
      case 6:
        goto LABEL_14;
      case 2:
        __int128 v29 = 0uLL;
        p12Decrypt((uint64_t)a1, (void *)v12, v12 + 32, &v29);
        if (v13) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v28 = 0LL;
        __int128 v26 = 0u;
        __int128 v27 = 0u;
        __int128 v24 = 0u;
        __int128 v25 = 0u;
        if (!*a1) {
          return 0xFFFFFFFFLL;
        }
        if (!*((void *)&v29 + 1)) {
          return 0xFFFFFFFFLL;
        }
        if (SEC_ASN1Decode( **a1,  (uint64_t)&v24,  (uint64_t)&kSecAsn1PrivateKeyInfoTemplate,  *((char **)&v29 + 1),  v29)) {
          return 0xFFFFFFFFLL;
        }
        v23[0] = *((void *)&v25 + 1);
        v23[1] = v25;
        BOOL v14 = DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v23);
        char v15 = &oidEcPubKey;
        if (!v14)
        {
          BOOL v16 = DEROidCompare((uint64_t)&oidRsa, (uint64_t)v23);
          char v15 = &oidRsa;
          if (!v16) {
            return 0xFFFFFFFFLL;
          }
        }

        CFDataRef v17 = CFDataCreateWithBytesNoCopy(v8, v15->data, v15->length, v9);
        if (emit_item((uint64_t)a1, *(void **)(v11 + 32), @"algid", v17))
        {
          if (!v17) {
            return 0xFFFFFFFFLL;
          }
          int v18 = -1;
LABEL_29:
          CFRelease(v17);
          goto LABEL_30;
        }

        if (v17) {
          CFRelease(v17);
        }
        CFDataRef v17 = CFDataCreate(v8, *((const UInt8 **)&v27 + 1), v27);
        else {
          int v18 = 0;
        }
        if (v17) {
          goto LABEL_29;
        }
LABEL_30:
        if (v18) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_14;
      case 3:
        int v19 = *(_DWORD *)(v12 + 16);
        if (v19 == 2) {
          goto LABEL_14;
        }
        if (v19 != 1) {
          return 0xFFFFFFFFLL;
        }
        CFDataRef v20 = CFDataCreate(v8, *(const UInt8 **)(v12 + 32), *(void *)(v12 + 24));
        if (!emit_item((uint64_t)a1, *(void **)(v11 + 32), @"cert", v20))
        {
          CFRelease(v20);
LABEL_14:
          v7 += 8LL;
          if (v10 == v7) {
            return 0LL;
          }
          continue;
        }

        if (v20) {
          CFRelease(v20);
        }
        return 0xFFFFFFFFLL;
      default:
        return 0xFFFFFFFFLL;
    }
  }

double p12Decrypt(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  unint64_t v8 = a2[2];
  if (v8)
  {
    __int128 v62 = 0uLL;
    __int128 v63 = 0uLL;
    __int128 v60 = 0uLL;
    __int128 v61 = 0uLL;
    __int128 v58 = 0uLL;
    __int128 v59 = 0uLL;
    __int128 v56 = 0uLL;
    __int128 v57 = 0uLL;
    __int128 v54 = 0uLL;
    __int128 v55 = 0uLL;
    uint64_t v9 = *(uint64_t **)a1;
    uint64_t v10 = (char *)a2[3];
    if (*(void *)a1 && v10)
    {
      uint64_t v9 = *(uint64_t **)a1;
      uint64_t v10 = (char *)a2[3];
    }

    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v54 = 0u;
    __int128 v55 = 0u;
    if (v9
      && v10
      && !SEC_ASN1Decode(*v9, (uint64_t)&v54, (uint64_t)&NSS_P12_PBE2_ParamsTemplate, v10, a2[2]))
    {
      __int128 v54 = v57;
      __int128 v55 = v58;
    }
  }

uint64_t __p12Decrypt_block_invoke(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  uint64_t result = CCKeyDerivationPBKDF( 2u,  __s,  v4,  *(const uint8_t **)(a1 + 48),  *(void *)(a1 + 40),  3u,  *(_DWORD *)(a1 + 216),  *(uint8_t **)(a1 + 208),  *(void *)(a1 + 200));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t emit_item(uint64_t a1, void *a2, void *a3, const void *a4)
{
  unint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = Mutable;
  SecKeyRef key = a3;
  if (a2)
  {
    if (*a2)
    {
      uint64_t v11 = 0LL;
      while (a2[++v11])
        ;
      if ((_DWORD)v11)
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = v11;
        do
        {
          char v15 = (unint64_t *)a2[v13];
          CCAlgorithm v16 = (void *)v15[2];
          if (v16 && *v16)
          {
            uint64_t v17 = 0LL;
            CCOptions v18 = v16 + 1;
            while (v18[v17++])
              ;
          }

          else
          {
            LODWORD(v17) = 0;
          }

          unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v39 = v15[1];
          unint64_t v40 = *v15;
          if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidFriendlyName))
          {
            if ((_DWORD)v17 != 1) {
              goto LABEL_41;
            }
            CFIndex v37 = 0xAAAAAAAAAAAAAAAALL;
            __int128 v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
            if (!*(void *)a1) {
              goto LABEL_41;
            }
            unsigned int v20 = *(unint64_t **)v15[2];
            uint64_t v21 = (char *)v20[1];
            if (!v21
              || SEC_ASN1Decode( **(void **)a1,  (uint64_t)&v37,  (uint64_t)kSecAsn1BMPStringTemplate,  v21,  *v20))
            {
              goto LABEL_41;
            }

            CFStringRef v22 = CFStringCreateWithBytes(v8, v38, v37, 0x100u, 1u);
            if (v22)
            {
              unsigned int v23 = v22;
              int v24 = v10;
              unint64_t v25 = @"label";
LABEL_28:
              CFDictionarySetValue(v24, v25, v23);
              CFRelease(v23);
            }
          }

          else if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidLocalKeyId))
          {
            if ((_DWORD)v17 != 1
              || (CFIndex v37 = 0xAAAAAAAAAAAAAAAALL, v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL, !*(void *)a1)
              || (__int128 v26 = *(unint64_t **)v15[2], (v27 = (char *)v26[1]) == 0LL)
              || SEC_ASN1Decode( **(void **)a1,  (uint64_t)&v37,  (uint64_t)kSecAsn1OctetStringTemplate,  v27,  *v26))
            {
LABEL_41:
              uint64_t v34 = 0xFFFFFFFFLL;
              goto LABEL_39;
            }

            CFDataRef v28 = CFDataCreate(v8, v38, v37);
            if (v28)
            {
              unsigned int v23 = v28;
              int v24 = v10;
              unint64_t v25 = @"keyid";
              goto LABEL_28;
            }
          }

          ++v13;
        }

        while (v13 != v14);
      }
    }
  }

  unint64_t Value = CFDictionaryGetValue(v10, @"keyid");
  if (!Value) {
    unint64_t Value = CFDictionaryGetValue(v10, @"label");
  }
  if (Value) {
    size_t v30 = Value;
  }
  else {
    size_t v30 = a4;
  }
  int v31 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v30);
  uint64_t v32 = key;
  if (v31)
  {
    CFNumberRef v33 = (const __CFDictionary *)a4;
  }

  else
  {
    CFDictionarySetValue(v10, key, a4);
    int v31 = *(__CFDictionary **)(a1 + 16);
    uint64_t v32 = v30;
    CFNumberRef v33 = v10;
  }

  CFDictionarySetValue(v31, v32, v33);
  uint64_t v34 = 0LL;
LABEL_39:
  CFRelease(v10);
  return v34;
}

void sub_180604F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_180605010( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1806050CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1806051AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18060595C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t __Block_byref_object_copy__13053(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__13054(uint64_t a1)
{
}

void _getAppAttestInternalSymbol(void *a1, char *__symbol)
{
  if (_initAppAttestInternal_onceToken == -1)
  {
    if (!a1) {
      return;
    }
  }

  else
  {
    dispatch_once(&_initAppAttestInternal_onceToken, &__block_literal_global_489);
    if (!a1) {
      return;
    }
  }

  if (!*a1)
  {
    size_t v4 = dlsym((void *)appAttestInternal, __symbol);
    *a1 = v4;
    if (!v4)
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "symbol %s is missing", __symbol);
      abort();
    }
  }

void *___initAppAttestInternal_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/AppAttestInternal.framework/AppAttestInternal", 5);
  appAttestInternal = (uint64_t)result;
  return result;
}

LABEL_86:
  objc_msgSend( NSString,  "stringWithFormat:",  @"SecRequestClientIdentity parameters dictionary has missing value or wrong type for %s key",  v11);
  __int128 v59 = (void *)objc_claimAutoreleasedReturnValue();
  __int128 v60 = (void *)MEMORY[0x189607870];
  __int128 v61 = *MEMORY[0x189607670];
  uint64_t v84 = *MEMORY[0x1896075E0];
  uint64_t v85 = v59;
  [MEMORY[0x189603F68] dictionaryWithObjects:&v85 forKeys:&v84 count:1];
  __int128 v62 = (void *)objc_claimAutoreleasedReturnValue();
  __int128 v63 = [v60 errorWithDomain:v61 code:-50 userInfo:v62];
  uint64_t v64 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v65 = *(void **)(v64 + 40);
  *(void *)(v64 + 40) = v63;

LABEL_87:
}

  __int128 v55 = v38 + 16;
  __int128 v56 = bswap32(v38 + 16);
  if (v7) {
    __int128 v55 = v56;
  }
  __int128 v57 = bswap32(v15 + 1);
  if (!v7) {
    __int128 v57 = v15 + 1;
  }
  v36[4] = v57;
  void v36[5] = v55;
  if (v7) {
    __int128 v58 = 486539264;
  }
  else {
    __int128 v58 = 29;
  }
  if (v7) {
    __int128 v59 = 0x10000000;
  }
  else {
    __int128 v59 = 16;
  }
  *CFStringRef v22 = v58;
  v22[1] = v59;
  __int128 v60 = (v37 + 15) & 0xFFFFFFF0;
  __int128 v61 = bswap32(v60);
  if (!v7) {
    __int128 v61 = (v37 + 15) & 0xFFFFFFF0;
  }
  __int128 v62 = bswap32(v35);
  if (!v7) {
    __int128 v62 = v35;
  }
  void v22[2] = v61;
  v22[3] = v62;
  uint64_t v32 = __CFADD__(v60, v35);
  __int128 v63 = v60 + v35;
  *uint64_t v34 = v63;
  if (v32)
  {
    log_error(a5, "sigSpace + appendOffset overflows\n");
    return 0LL;
  }

void SecRequestClientIdentity(const void *a1, const void *a2, void *a3, void *a4)
{
  v28[1] = *MEMORY[0x1895F89C0];
  unint64_t v7 = a3;
  id v8 = a4;
  uint64_t v9 = (void (**)(void, void, void))v8;
  uint64_t v10 = "subject";
  if (a1) {
    uint64_t v10 = 0LL;
  }
  if (!a2) {
    uint64_t v10 = "parameters";
  }
  if (!v7) {
    uint64_t v10 = "queue";
  }
  if (!v8) {
    uint64_t v10 = "result block";
  }
  if (v10)
  {
    uint64_t v11 = objc_msgSend( NSString,  "stringWithFormat:",  @"SecRequestClientIdentity was called with NULL %s",  v10);
    uint64_t v12 = (void *)v11;
    if (v9)
    {
      uint64_t v13 = (void *)MEMORY[0x189607870];
      uint64_t v14 = *MEMORY[0x189607670];
      uint64_t v27 = *MEMORY[0x1896075E0];
      v28[0] = v11;
      [MEMORY[0x189603F68] dictionaryWithObjects:v28 forKeys:&v27 count:1];
      char v15 = (void *)objc_claimAutoreleasedReturnValue();
      [v13 errorWithDomain:v14 code:-50 userInfo:v15];
      CCAlgorithm v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();

      ((void (**)(void, void, os_log_s *))v9)[2](v9, 0LL, v16);
    }

    else
    {
      secLogObjForScope("SecError");
      CCAlgorithm v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_impl(&dword_1804F4000, v16, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
      }
    }
  }

  else
  {
    if (a1) {
      CFRetain(a1);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v23 = 0x3032000000LL;
    int v24 = __Block_byref_object_copy__13053;
    unint64_t v25 = __Block_byref_object_dispose__13054;
    id v26 = (id)0xAAAAAAAAAAAAAAAALL;
    id v26 = (id)os_transaction_create();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __SecRequestClientIdentity_block_invoke;
    block[3] = &unk_189676678;
    unsigned int v20 = a1;
    uint64_t v21 = a2;
    CCOptions v18 = v9;
    p___int128 buf = &buf;
    dispatch_async(v7, block);

    _Block_object_dispose(&buf, 8);
  }
}

void __SecRequestClientIdentity_block_invoke(void *a1)
{
  char v2 = (void *)MEMORY[0x186DFF9D0]();
  BOOL v3 = -[AcmeCertRequest initWithSubject:parameters:]( objc_alloc(&OBJC_CLASS___AcmeCertRequest),  "initWithSubject:parameters:",  a1[6],  a1[7]);
  uint64_t v4 = -[AcmeCertRequest sanitizeParameters](v3, "sanitizeParameters");
  if (v4)
  {
    id v5 = (id)v4;
  }

  else
  {
    id v10 = 0LL;
    -[AcmeCertRequest identityWithError:](v3, "identityWithError:", &v10);
    id v5 = v10;
  }

  (*(void (**)(void))(a1[4] + 16LL))();
  __int128 v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  unint64_t v7 = (const void *)a1[6];
  if (v7) {
    CFRelease(v7);
  }

  uint64_t v8 = *(void *)(a1[5] + 8LL);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0LL;

  objc_autoreleasePoolPop(v2);
}

uint64_t SecAreQARootCertificatesEnabled()
{
  if (SecAreQARootCertificatesEnabled_onceToken != -1) {
    dispatch_once(&SecAreQARootCertificatesEnabled_onceToken, &__block_literal_global_13141);
  }
  return SecAreQARootCertificatesEnabled_sQACertsEnabled;
}

void __SecAreQARootCertificatesEnabled_block_invoke()
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v4 = 0;
  size_t v3 = 4LL;
  int v0 = sysctlbyname("security.mac.amfi.qa_root_certs_allowed", &v4, &v3, 0LL, 0LL);
  if (v0)
  {
    int v1 = v0;
    char v2 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v6 = v1;
      _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "Unable to check QA certificate status: %d", buf, 8u);
    }
  }

  else
  {
    SecAreQARootCertificatesEnabled_sQACertsEnabled = v4 == 1;
  }

uint64_t SecIsInternalRelease()
{
  return os_variant_allows_internal_security_policies();
}

uint64_t p12_pbe_gen( const __CFString *a1, const void *a2, size_t a3, unsigned int a4, uint64_t a5, void *a6, size_t a7, CC_LONG a8, unsigned int a9)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  size_t v16 = a8;
  MEMORY[0x1895F8858](a1);
  memset((char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0LL), v17, v16);
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation( (CFAllocatorRef)*MEMORY[0x189604DB0],  a1,  0x10000100u,  0);
  if (!ExternalRepresentation) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v19 = ExternalRepresentation;
  CFNumberRef v67 = (char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0LL);
  __int16 bytes = 0;
  CFMutableArrayRef MutableCopy = CFDataCreateMutableCopy(0LL, 0LL, ExternalRepresentation);
  CFRelease(v19);
  if (!MutableCopy) {
    return 0xFFFFFFFFLL;
  }
  CFDataAppendBytes(MutableCopy, (const UInt8 *)&bytes, 2LL);
  int64_t v70 = 0LL;
  CFIndex Length = CFDataGetLength(MutableCopy);
  uint64_t BytePtr = CFDataGetBytePtr(MutableCopy);
  uint64_t v23 = concatenate_to_blocksize(BytePtr, Length, v16, &v70);
  CFRelease(MutableCopy);
  if (!v23) {
    return 0xFFFFFFFFLL;
  }
  size_t v69 = 0LL;
  if (!a3) {
    goto LABEL_36;
  }
  int v24 = concatenate_to_blocksize(a2, a3, v16, (int64_t *)&v69);
  if (!v24) {
    goto LABEL_36;
  }
  unint64_t v25 = v24;
  unsigned int v66 = a4;
  size_t v26 = v69;
  int64_t v27 = v70;
  unint64_t v28 = v70 + v69;
  __int128 v29 = (char *)malloc(v70 + v69);
  if (!v29)
  {
    free(v25);
LABEL_36:
    __int128 v54 = v23;
LABEL_37:
    free(v54);
    return 0xFFFFFFFFLL;
  }

  size_t v65 = a9;
  size_t v64 = v27;
  size_t v30 = v29;
  memcpy(v29, v25, v26);
  CFNumberRef v68 = v30;
  int v31 = &v30[v26];
  size_t v32 = v65;
  memcpy(v31, v23, v64);
  free(v25);
  free(v23);
  int64_t v33 = (a7 + v32 - 1) / v32 * v32;
  __int128 v60 = (char *)malloc(v33);
  if (!v60)
  {
    __int128 v54 = v68;
    goto LABEL_37;
  }

  __int128 v57 = a6;
  size_t v58 = a7;
  __int128 v59 = &v56;
  if (v33 < 1)
  {
LABEL_33:
    uint64_t v52 = v60;
    memcpy(v57, v60, v58);
    free(v52);
    free(v68);
    return 0LL;
  }

  else
  {
    uint64_t v34 = (unsigned __int8 *)v60;
    __int128 v63 = (unsigned __int8 *)&v60[v33];
    HIDWORD(v36) = v32;
    LODWORD(v36) = v32 - 20;
    unsigned int v35 = v36 >> 2;
    size_t v64 = (v16 + 7) >> 3;
    unsigned int v61 = v66 - 1;
    uint64_t v62 = v35;
    while (1)
    {
      CFIndex v37 = v67;
      switch(v35)
      {
        case 0u:
          *(void *)&__int128 v38 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v38;
          *(_OWORD *)c.w__int128 buf = v38;
          *(_OWORD *)&c.hash[4] = v38;
          *(_OWORD *)&c.hash[2] = v38;
          *(_OWORD *)c.hash = v38;
          *(_OWORD *)c.unint64_t count = v38;
          CC_SHA1_Init((CC_SHA1_CTX *)&c);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v37, a8);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v68, v28);
          CC_SHA1_Final(v34, (CC_SHA1_CTX *)&c);
          break;
        case 2u:
          c.wuint8_t buf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v39;
          *(_OWORD *)c.w__int128 buf = v39;
          *(_OWORD *)&c.hash[4] = v39;
          *(_OWORD *)&c.hash[2] = v39;
          *(_OWORD *)c.hash = v39;
          *(_OWORD *)c.unint64_t count = v39;
          CC_SHA224_Init((CC_SHA256_CTX *)&c);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA224_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 3u:
          c.wuint8_t buf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__int128 v40 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v40;
          *(_OWORD *)c.w__int128 buf = v40;
          *(_OWORD *)&c.hash[4] = v40;
          *(_OWORD *)&c.hash[2] = v40;
          *(_OWORD *)c.hash = v40;
          *(_OWORD *)c.unint64_t count = v40;
          CC_SHA256_Init((CC_SHA256_CTX *)&c);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA256_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 7u:
          *(void *)&__int128 v41 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.w_BYTE buf[12] = v41;
          *(_OWORD *)&c.wbuf[14] = v41;
          *(_OWORD *)&c.wuint8_t buf[8] = v41;
          *(_OWORD *)&c.wbuf[10] = v41;
          *(_OWORD *)&c.wuint8_t buf[4] = v41;
          *(_OWORD *)&c.wbuf[6] = v41;
          *(_OWORD *)c.w__int128 buf = v41;
          *(_OWORD *)&c.wuint8_t buf[2] = v41;
          *(_OWORD *)&c.hash[6] = v41;
          *(_OWORD *)&c.hash[4] = v41;
          *(_OWORD *)&c.hash[2] = v41;
          *(_OWORD *)c.hash = v41;
          *(_OWORD *)c.unint64_t count = v41;
          CC_SHA384_Init(&c);
          CC_SHA384_Update(&c, v37, a8);
          CC_SHA384_Update(&c, v68, v28);
          CC_SHA384_Final(v34, &c);
          break;
        case 0xBu:
          *(void *)&__int128 v42 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.w_BYTE buf[12] = v42;
          *(_OWORD *)&c.wbuf[14] = v42;
          *(_OWORD *)&c.wuint8_t buf[8] = v42;
          *(_OWORD *)&c.wbuf[10] = v42;
          *(_OWORD *)&c.wuint8_t buf[4] = v42;
          *(_OWORD *)&c.wbuf[6] = v42;
          *(_OWORD *)c.w__int128 buf = v42;
          *(_OWORD *)&c.wuint8_t buf[2] = v42;
          *(_OWORD *)&c.hash[6] = v42;
          *(_OWORD *)&c.hash[4] = v42;
          *(_OWORD *)&c.hash[2] = v42;
          *(_OWORD *)c.hash = v42;
          *(_OWORD *)c.unint64_t count = v42;
          CC_SHA512_Init(&c);
          CC_SHA512_Update(&c, v37, a8);
          CC_SHA512_Update(&c, v68, v28);
          CC_SHA512_Final(v34, &c);
          break;
        default:
          break;
      }

      if (v66 >= 2)
      {
        unsigned int v43 = v61;
        do
        {
          CCDigest();
          --v43;
        }

        while (v43);
      }

      c.count[0] = 0LL;
      __int128 v44 = concatenate_to_blocksize(v34, v32, v16, (int64_t *)&c);
      if (!v44) {
        goto LABEL_41;
      }
      __int128 v45 = v44;
      if ((c.count[0] + 8) >> 3 <= v64) {
        CC_LONG64 v46 = v64;
      }
      else {
        CC_LONG64 v46 = (c.count[0] + 8) >> 3;
      }
      unint64_t v47 = malloc(8 * v46);
      if (!v47)
      {
        free(v45);
LABEL_41:
        free(v68);
        __int128 v55 = v60;
        goto LABEL_43;
      }

      int v48 = v47;
      ccn_read_uint();
      ccn_add1();
      free(v45);
      unsigned int v49 = malloc(8 * v46);
      if (!v49) {
        break;
      }
      uint64_t v50 = v49;
      if (v28)
      {
        for (unsigned int i = 0; i < v28; i += a8)
        {
          ccn_read_uint();
          ccn_add();
          ccn_write_uint_padded();
        }
      }

      size_t v32 = v65;
      v34 += v65;
      free(v48);
      free(v50);
      unsigned int v35 = v62;
      if (v34 >= v63) {
        goto LABEL_33;
      }
    }

    free(v68);
    free(v60);
    __int128 v55 = v48;
LABEL_43:
    free(v55);
    return 0xFFFFFFFFLL;
  }

char *concatenate_to_blocksize(const void *a1, size_t a2, unint64_t a3, int64_t *a4)
{
  int64_t v7 = (a2 + a3 - 1) / a3 * a3;
  uint64_t v8 = (char *)malloc(v7);
  uint64_t v9 = v8;
  if (v8)
  {
    if (v7 >= 1)
    {
      id v10 = &v8[v7];
      uint64_t v11 = v8;
      do
      {
        if (v10 - v11 >= a2) {
          size_t v12 = a2;
        }
        else {
          size_t v12 = v10 - v11;
        }
        memcpy(v11, a1, v12);
        v11 += a2;
      }

      while (v11 < v10);
    }

    *a4 = v7;
  }

  return v9;
}

void (*pbkdf2( void (*result)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, char *a8, unint64_t a9, char *a10))(uint64_t, uint64_t, char *, size_t, char *)
{
  unint64_t v16 = a9 / a2;
  unint64_t v20 = a9 / a2 * a2;
  if ((a9 / a2))
  {
    uint64_t v21 = &a10[a2];
    unsigned int v17 = 1;
    do
    {
      CCOptions v18 = result;
      unint64_t v19 = a7;
      F(result, a2, a3, a4, __src, __n, a7, v17, a8, v21);
      uint64_t result = v18;
      a7 = v19;
      a8 += a2;
      ++v17;
    }

    while (v17 <= v16);
  }

  else
  {
    unsigned int v17 = 1;
  }

  if (a9 != v20)
  {
    F(result, a2, a3, a4, __src, __n, a7, v17, a10, &a10[a2]);
    return (void (*)(uint64_t, uint64_t, char *, size_t, char *))memcpy(a8, a10, a9 - v20);
  }

  return result;
}

void *F( void (*a1)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, unsigned int a8, void *a9, char *a10)
{
  unsigned int v17 = a10;
  CCOptions v18 = &a10[a2];
  memcpy(&a10[a2], __src, __n);
  *(_DWORD *)&v18[__n] = bswap32(a8);
  a1(a3, a4, v18, __n + 4, a10);
  uint64_t result = memcpy(a9, a10, a2);
  if (a7 >= 2)
  {
    unint64_t v20 = 2LL;
    do
    {
      uint64_t v21 = v18;
      uint64_t result = (void *)((uint64_t (*)(uint64_t, uint64_t, char *, size_t, char *))a1)(a3, a4, v17, a2, v18);
      if (a2)
      {
        uint64_t v22 = 0LL;
        do
        {
          *((_BYTE *)a9 + v22) ^= v18[v22];
          ++v22;
        }

        while (a2 > v22);
      }

      ++v20;
      CCOptions v18 = v17;
      unsigned int v17 = v21;
    }

    while (v20 <= a7);
  }

  return result;
}

void __secLogObjForCFScope_block_invoke(uint64_t a1, const char *a2)
{
  char v2 = (__CFDictionary *)secLogObjForCFScope_scopeMap;
  size_t v3 = *(const void **)(a1 + 32);
  os_log_t v4 = os_log_create("com.apple.securityd", a2);
  CFDictionaryAddValue(v2, v3, v4);
}

__CFString *SecLogAPICreate( uint64_t a1, const char *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFStringAppend(Mutable, @"SecAPITrace ");
  CFStringAppendCString(Mutable, a2, 0x600u);
  CFStringAppendCString(Mutable, "ENTER", 0x600u);
  if (a3)
  {
    uint64_t v13 = CFStringCreateWithFormatAndArguments(v11, 0LL, a3, &a9);
    CFStringAppend(Mutable, v13);
    if (v13) {
      CFRelease(v13);
    }
  }

  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v19 = v14;
  __int128 v20 = v14;
  __int128 v17 = v14;
  __int128 v18 = v14;
  *(_OWORD *)__str = v14;
  snprintf(__str, 0x50uLL, "C%p F%p", vars0[1], *vars0);
  CFStringAppend(Mutable, @"CALLER ");
  CFStringAppendCString(Mutable, __str, 0x600u);
  return Mutable;
}

uint64_t SecGetDebugDescriptionFormatOptions()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __SecGetDebugDescriptionFormatOptions_block_invoke;
  block[3] = &__block_descriptor_tmp_13249;
  void block[4] = &SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
  if (SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce != -1) {
    dispatch_once(&SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce, block);
  }
  return SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
}

CFDictionaryRef __SecGetDebugDescriptionFormatOptions_block_invoke(uint64_t a1)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  values = (void *)*MEMORY[0x189604DE8];
  keys[0] = @"debug";
  CFDictionaryRef result = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  **(void **)(a1 + 32) = result;
  return result;
}

void __CFStringArrayPerformWithDelimiterWithDescription_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = @", ";
}

uint64_t apply_block_1_13256(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void CFStringSetPerformWithDescription(const __CFSet *a1, uint64_t a2)
{
  if (a1
    && (CFIndex Count = CFSetGetCount(a1),
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, Count, MEMORY[0x189605228]),
        CFSetApplyFunction(a1, (CFSetApplierFunction)appendDescriptionToArray, Mutable),
        v13.size_t length = CFArrayGetCount(Mutable),
        v13.CFIndex location = 0LL,
        CFArraySortValues(Mutable, v13, (CFComparatorFunction)MEMORY[0x1896033C0], 0LL),
        Mutable))
  {
    uint64_t v9 = 0LL;
    id v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    CFMutableStringRef MutableCopy = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"{(");
    v8[0] = 0LL;
    v8[1] = v8;
    _DWORD v8[2] = 0x2000000000LL;
    void v8[3] = &stru_1896794C8;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 0x40000000LL;
    void v7[2] = __CFStringArrayPerformWithDelimiterWithDescription_block_invoke;
    void v7[3] = &unk_189676870;
    UInt8 v7[4] = &v9;
    void v7[5] = v8;
    v14.size_t length = CFArrayGetCount(Mutable);
    v14.CFIndex location = 0LL;
    CFArrayApplyFunction(Mutable, v14, (CFArrayApplierFunction)apply_block_1_13256, v7);
    CFStringAppend((CFMutableStringRef)v10[3], @"}"));
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v10[3]);
    int v6 = (const void *)v10[3];
    if (v6)
    {
      unint64_t v10[3] = 0LL;
      CFRelease(v6);
    }

    _Block_object_dispose(v8, 8);
    _Block_object_dispose(&v9, 8);
    CFRelease(Mutable);
  }

  else
  {
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, @"null");
  }

void appendDescriptionToArray(const __CFString *a1, __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    id v5 = a2;
    int v6 = a1;
  }

  else
  {
    CFStringRef v7 = CFCopyDescription(a1);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFArrayAppendValue(a2, v7);
      CFRelease(v8);
      return;
    }

    int v6 = @"null";
    id v5 = a2;
  }

  CFArrayAppendValue(v5, v6);
}

void __SecCFCalendarGetZulu_block_invoke()
{
  int v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  sZuluCalendar = (uint64_t)CFCalendarCreateWithIdentifier( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFCalendarIdentifier)*MEMORY[0x189604F90]);
  int v1 = CFTimeZoneCreateWithTimeIntervalFromGMT(v0, 0.0);
  CFCalendarSetTimeZone((CFCalendarRef)sZuluCalendar, v1);
  if (v1) {
    CFRelease(v1);
  }
}

dispatch_queue_t __SecCFCalendarGetZuluQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("ZuluCalendar", 0LL);
  fqueue_CFTypeRef cf = (uint64_t)result;
  return result;
}

uint64_t __CFStringPerformWithCStringAndLength_block_invoke(uint64_t result, int a2, UInt8 *buffer)
{
  if (buffer)
  {
    uint64_t v4 = result;
    id v5 = *(const __CFString **)(result + 40);
    CFRange v8 = *(CFRange *)(v4 + 48);
    CFIndex v6 = *(void *)(v4 + 64);
    CFIndex usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    CFStringGetBytes(v5, v8, 0x8000100u, 0, 0, buffer, v6, &usedBufLen);
    buffer[usedBufLen] = 0;
    return (*(uint64_t (**)(void))(*(void *)(v4 + 32) + 16LL))();
  }

  return result;
}

uint64_t apply_block_2_13291(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __CFDictionaryCopySuperCompactDescription_block_invoke( uint64_t a1, const __CFString *a2, const __CFString *cf)
{
  if (!cf) {
    goto LABEL_12;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"0x");
    uint64_t BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    CFIndex Length = CFDataGetLength((CFDataRef)cf);
    if (Length >= 1)
    {
      CFIndex v10 = Length;
      do
      {
        unsigned int v11 = *BytePtr++;
        CFStringAppendFormat(MutableCopy, 0LL, @"%02X", v11);
        --v10;
      }

      while (v10);
    }

    v20.CFIndex location = 0LL;
    v20.size_t length = 5LL;
    CFStringDelete(MutableCopy, v20);
    goto LABEL_16;
  }

  CFTypeID v12 = CFGetTypeID(cf);
  if (v12 != CFStringGetTypeID())
  {
    CFTypeID v16 = CFGetTypeID(cf);
    if (v16 == CFNumberGetTypeID())
    {
      CFRange v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFArrayRef Copy = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%@", cf);
      goto LABEL_14;
    }

uint64_t CFDataCreateWithRandomBytes(size_t a1)
{
  uint64_t v4 = 0LL;
  id v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __CFDataCreateWithRandomBytes_block_invoke;
  v3[3] = &unk_1896767E0;
  void v3[4] = &v4;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  _DWORD v8[2] = __PerformWithBufferAndClear_block_invoke;
  void v8[3] = &unk_189676A80;
  void v8[4] = v3;
  PerformWithBuffer(a1, (uint64_t)v8);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

CFDataRef __CFDataCreateWithRandomBytes_block_invoke(uint64_t a1, size_t a2, void *bytes)
{
  CFDataRef result = CFDataCreate(0LL, (const UInt8 *)bytes, a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void __GetShortDateFormatter_block_invoke(uint64_t a1)
{
  char v2 = CFLocaleCopyCurrent();
  **(void **)(a1 + 32) = CFDateFormatterCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  v2,  kCFDateFormatterNoStyle,  kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat(**(CFDateFormatterRef **)(a1 + 32), @"yyyy-MM-dd HH:mm");
  if (v2) {
    CFRelease(v2);
  }
}

dispatch_queue_t __GetShortDateFormatterQueue_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("Date Formatting", 0LL);
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef __withStringOfAbsoluteTime_block_invoke(uint64_t a1, __CFDateFormatter *a2)
{
  CFStringRef result = CFDateFormatterCreateStringWithAbsoluteTime( (CFAllocatorRef)*MEMORY[0x189604DB0],  a2,  *(CFAbsoluteTime *)(a1 + 40));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t __withShortDateFormatter_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __GetShortDateFormatter_block_invoke;
  block[3] = &__block_descriptor_tmp_39_13312;
  void block[4] = &GetShortDateFormatter_sGetShortDateFormatterSingleton;
  if (GetShortDateFormatter_sGetShortDateFormatterOnce != -1) {
    dispatch_once(&GetShortDateFormatter_sGetShortDateFormatterOnce, block);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))( v1,  GetShortDateFormatter_sGetShortDateFormatterSingleton);
}

void der_encode_date( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  double v11 = MEMORY[0x186DFE188]();
  der_encode_generalizedtime_body_repair(0LL, 0, a2, a3, v11);
  if (!ccder_encode_constructed_tl()) {
    SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  0LL,  v12,  @"ccder failed to encode",  v13,  v14,  a9);
  }
}

void __getAnchors_block_invoke()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  addAnchor(Mutable, AppleRootCAHash, 1);
  addAnchor(Mutable, AppleRootG2Hash, 1);
  addAnchor(Mutable, AppleRootG3Hash, 1);
  addAnchor(Mutable, TestAppleRootCAHash, 0);
  addAnchor(Mutable, TestAppleRootG2Hash, 0);
  addAnchor(Mutable, TestAppleRootG3Hash, 0);
  getAnchors_anchors = (uint64_t)Mutable;
}

void addAnchor(const __CFDictionary *a1, const UInt8 *a2, int a3)
{
  CFDataRef v5 = CFDataCreateWithBytesNoCopy(0LL, a2, 32LL, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  if (CFDictionaryGetValue(a1, v5)) {
    abort();
  }
  uint64_t v6 = (const void **)MEMORY[0x189604DE8];
  if (!a3) {
    uint64_t v6 = (const void **)MEMORY[0x189604DE0];
  }
  CFDictionarySetValue(a1, v5, *v6);
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t SecIsAppleTrustAnchor(void *a1, char a2)
{
  size_t v3 = SecCertificateCopySHA256Digest(a1);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  if (getAnchors_onceToken != -1) {
    dispatch_once(&getAnchors_onceToken, &__block_literal_global_3_13578);
  }
  if (!getAnchors_anchors)
  {
LABEL_13:
    uint64_t v6 = 0LL;
    goto LABEL_11;
  }

  unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)getAnchors_anchors, v4);
  uint64_t v6 = (uint64_t)Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID())
    {
      int v8 = CFBooleanGetValue((CFBooleanRef)v6);
      uint64_t v6 = v8 != 0;
      if ((a2 & 1) != 0)
      {
        int v9 = v8;
        unsigned int v10 = os_variant_allows_internal_security_policies() | ((a2 & 2) >> 1);
        if (v9) {
          uint64_t v6 = 1LL;
        }
        else {
          uint64_t v6 = v10;
        }
      }

      goto LABEL_11;
    }

    goto LABEL_13;
  }

void __SecGetAppleTrustAnchors_block_invoke(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 3LL, MEMORY[0x189605228]);
  addCertificate(Mutable, &AppleRootCA, 1215LL);
  addCertificate(Mutable, &AppleRootG2, 1430LL);
  addCertificate(Mutable, &AppleRootG3, 583LL);
  if ((os_variant_allows_internal_security_policies() & 1) != 0 || *(_BYTE *)(a1 + 32))
  {
    addCertificate(Mutable, &TestAppleRootCA, 1232LL);
    addCertificate(Mutable, &TestAppleRootG2, 630LL);
    addCertificate(Mutable, &TestAppleRootG3, 592LL);
  }

  SecGetAppleTrustAnchors_anchors = (uint64_t)Mutable;
}

void addCertificate(const __CFArray *a1, const void *a2, int64_t a3)
{
  uint64_t v4 = SecCertificateCreateWithBytes(0LL, a2, a3);
  v5.size_t length = CFArrayGetCount(a1);
  v5.CFIndex location = 0LL;
  if (CFArrayContainsValue(a1, v5, v4)) {
    abort();
  }
  CFArrayAppendValue(a1, v4);
  if (v4) {
    CFRelease(v4);
  }
}

BOOL SecKernError(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  if (a1 && a2)
  {
    CFRange v5 = (__CFString *)*a2;
    *a2 = 0LL;
    SecCFCreateErrorWithFormatAndArguments(a1, (const __CFString *)*MEMORY[0x189604F48], v5, a2, 0LL, format, va);
  }

  return a1 == 0;
}

void SecCFCreateErrorWithFormatAndArguments( CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  if (!a4) {
    return;
  }
  if (*a4)
  {
    if (cf)
    {
      if (*a4 != cf) {
        CFRelease(cf);
      }
    }

    return;
  }

  double v11 = CFStringCreateWithFormatAndArguments(0LL, formatOptions, format, arguments);
  uint64_t v30 = 0LL;
  uint64_t v12 = (const void **)MEMORY[0x189604F38];
  if (!cf) {
    goto LABEL_28;
  }
  uint64_t v13 = CFErrorCopyUserInfo((CFErrorRef)cf);
  unint64_t Value = (const __CFString *)CFDictionaryGetValue(v13, *v12);
  if (Value)
  {
    BOOL v15 = CFStringCompare(v11, Value, 0LL) == kCFCompareEqualTo;
    if (!v13) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  BOOL v15 = 0;
  if (v13) {
LABEL_9:
  }
    CFRelease(v13);
LABEL_10:
  CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
  CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)cf);
  CFComparisonResult v18 = CFStringCompare(a2, Domain, 0LL);
  BOOL v20 = Code == a1 && v18 == kCFCompareEqualTo && v15;
  CFRange v21 = cf;
  if (v20) {
    goto LABEL_17;
  }
  uint64_t v23 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v23)
  {
    int v24 = v23;
    if (CFDictionaryContainsKey(v23, @"numberOfErrorsDeep") == 1)
    {
      unint64_t v25 = (const __CFNumber *)CFDictionaryGetValue(v24, @"numberOfErrorsDeep");
      if (v25)
      {
        uint64_t valuePtr = 0LL;
        CFNumberGetValue(v25, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v24);
          CFRange v21 = cf;
LABEL_17:
          CFRetain(v21);
          *a4 = cf;
          CFRelease(cf);
          if (!v11) {
            return;
          }
          uint64_t v22 = v11;
          goto LABEL_42;
        }

        uint64_t v30 = valuePtr + 1;
      }
    }

    CFRelease(v24);
  }

void SecCheckErrno( uint64_t a1, CFTypeRef *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2)
  {
    CFIndex v11 = *__error();
    uint64_t v12 = (__CFString *)*a2;
    *a2 = 0LL;
    CFStringRef v13 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, a3, &a9);
    uint64_t v14 = (const __CFString *)*MEMORY[0x189604F58];
    strerror(v11);
    SecCFCreateErrorWithFormat(v11, v14, v12, a2, v15, @"%@: [%d] %s", v16, v17, (char)v13);
    if (v13) {
      CFRelease(v13);
    }
  }

void SecCFCreateErrorWithFormat( CFIndex a1, const __CFString *a2, __CFString *a3, CFTypeRef *a4, uint64_t a5, const __CFString *a6, uint64_t a7, uint64_t a8, char a9)
{
}

BOOL SecError(int a1, __CFString **a2, CFStringRef format, ...)
{
  if (a1)
  {
    CFTypeRef cf = 0LL;
    CFRange v5 = (const __CFString *)*MEMORY[0x189604F50];
    if (a2)
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, *a2, &cf, 0LL, format, va);
      *a2 = (__CFString *)cf;
    }

    else
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, 0LL, &cf, 0LL, format, va);
      CFTypeRef v6 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v6);
      }
    }
  }

  return a1 == 0;
}

uint64_t SecRequirementError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  if (a2 && (a1 & 1) == 0)
  {
    CFRange v5 = (__CFString *)*a2;
    *a2 = 0LL;
    SecCFCreateErrorWithFormatAndArguments(-50LL, (const __CFString *)*MEMORY[0x189604F50], v5, a2, 0LL, format, va);
  }

  return a1;
}

BOOL SecAllocationError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  if (!a1 && a2)
  {
    CFRange v5 = (__CFString *)*a2;
    *a2 = 0LL;
    SecCFCreateErrorWithFormatAndArguments(-108LL, (const __CFString *)*MEMORY[0x189604F50], v5, a2, 0LL, format, va);
  }

  return a1 != 0;
}

uint64_t der_encode_plist( const __CFString *a1, CFTypeRef *a2, UInt8 *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return der_encode_plist_repair(a1, a2, 0LL, a3, a4, a6, a7, a8);
}

CFTypeRef CFPropertyListCreateWithDERData( uint64_t a1, CFDataRef theData, uint64_t a3, void *a4, CFTypeRef *a5)
{
  CFTypeRef cf = 0LL;
  uint64_t BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFIndex v11 = &BytePtr[Length];
  uint64_t v15 = der_decode_plist(a1, (uint64_t)&cf, a5, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v12, v13, v14);
  if (!v15 || (const UInt8 *)v15 == v11)
  {
    if (a4) {
      *a4 = 400LL;
    }
  }

  else
  {
    SecCFCreateErrorWithFormat( -1LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a5,  v16,  @"trailing garbage after plist item",  v17,  v18,  v21);
    CFTypeRef v19 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v19);
    }
  }

  return cf;
}

uint64_t der_encode_null(CFTypeRef *a1)
{
  uint64_t v5 = ccder_encode_tl();
  if (!v5) {
    SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a1,  v2,  @"ccder failed to encode",  v3,  v4,  v7);
  }
  return v5;
}

uint64_t der_sizeof_set(const __CFSet *a1, uint64_t a2)
{
  __int128 v3 = xmmword_18065A240;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_value_size, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0LL;
  }
}

uint64_t add_value_size(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)a2)
  {
    CFStringRef result = der_sizeof_plist(result, *(void *)(a2 + 16));
    if (result) {
      *(void *)(a2 + 8) += result;
    }
    else {
      *(_BYTE *)a2 = 0;
    }
  }

  return result;
}

uint64_t der_encode_set_repair(const __CFSet *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
  v14[0] = 0xAAAAAAAAAAAAAA01LL;
  v14[1] = a2;
  BYTE1(v14[0]) = a3;
  _OWORD v14[2] = Mutable;
  unint64_t v14[3] = 0LL;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_sequence_to_array_13736, v14);
  if (!LOBYTE(v14[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0LL;
  }

  v15.size_t length = CFArrayGetCount(Mutable);
  v15.CFIndex location = 0LL;
  CFArraySortValues(Mutable, v15, (CFComparatorFunction)cfdata_compare_der_contents_13737, 0LL);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }

    while (v8 > 1);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    SecCFCreateErrorWithFormat( -7LL,  (const __CFString *)sSecDERErrorDomain,  0LL,  a2,  v11,  @"ccder failed to encode",  v12,  v13,  v14[0]);
    return 0LL;
  }

  return result;
}

void add_sequence_to_array_13736( const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)a2)
  {
    CFIndex v10 = der_sizeof_plist(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5, a6, a7, a8);
    if (!v10)
    {
      *(_BYTE *)a2 = 0;
      return;
    }

    CFIndex v11 = v10;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v10);
    CFDataSetLength(Mutable, v11);
    Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v14 = der_encode_plist_repair( a1,  *(void *)(a2 + 8),  *(unsigned __int8 *)(a2 + 1),  MutableBytePtr,  &MutableBytePtr[v11]);
    if (v14)
    {
      v15.size_t length = v14 - (void)MutableBytePtr;
      v15.CFIndex location = 0LL;
      CFDataDeleteBytes(Mutable, v15);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }

    else
    {
      *(_BYTE *)a2 = 0;
      if (!Mutable) {
        return;
      }
    }

    CFRelease(Mutable);
  }

uint64_t cfdata_compare_der_contents_13737(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = -1LL;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    uint64_t BytePtr = CFDataGetBytePtr(a1);
    int v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1LL;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }

    else
    {
      return 1LL;
    }
  }

uint64_t GetKeybagAssertionQueue()
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 0x40000000LL;
  block[2] = __GetKeybagAssertionQueue_block_invoke;
  block[3] = &__block_descriptor_tmp_13741;
  void block[4] = &GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
  if (GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce != -1) {
    dispatch_once(&GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce, block);
  }
  return GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
}

dispatch_queue_t __GetKeybagAssertionQueue_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("AKS Lock Assertion Queue", 0LL);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t __SecAKSKeybagHoldLockAssertion_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!count)
  {
    uint64_t v2 = (os_log_s *)secLogObjForScope("lockassertions");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(v1 + 40);
      int v4 = 134217984;
      uint64_t v5 = v3;
      _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "Requesting lock assertion for %lld seconds",  (uint8_t *)&v4,  0xCu);
    }

    dispatch_queue_t result = aks_assert_hold(*(_DWORD *)(v1 + 48), 0, *(void *)(v1 + 40));
    *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8LL) + 24LL) = result;
  }

  if (!*(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8LL) + 24LL)) {
    ++count;
  }
  return result;
}

uint64_t __SecAKSKeybagDropLockAssertion_block_invoke(uint64_t result)
{
  int v1 = count;
  if (count)
  {
    --count;
    if (v1 == 1)
    {
      uint64_t v2 = result;
      uint64_t v3 = (os_log_s *)secLogObjForScope("lockassertions");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v4 = 0;
        _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "Dropping lock assertion", v4, 2u);
      }

      dispatch_queue_t result = aks_assert_drop(*(_DWORD *)(v2 + 40), 0);
      *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8LL) + 24LL) = result;
    }
  }

  return result;
}

CFURLRef SecCopyURLForFileInBaseDirectory(const __CFString *a1, uint64_t a2)
{
  int v4 = SecCopyBaseFilesURL(1);
  if (a2)
  {
    uint64_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFArrayRef Copy = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%@/%@", a1, a2);
  }

  else
  {
    if (!a1) {
      goto LABEL_10;
    }
    uint64_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    CFArrayRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a1);
  }

  size_t v7 = Copy;
  if (v4 && Copy)
  {
    CFURLRef v8 = CFURLCreateCopyAppendingPathComponent(v5, v4, Copy, a2 == 0);
    CFRelease(v7);
LABEL_11:
    CFRelease(v4);
    return v8;
  }

  if (Copy) {
    CFRelease(Copy);
  }
LABEL_10:
  CFURLRef v8 = 0LL;
  if (v4) {
    goto LABEL_11;
  }
  return v8;
}

void WithPathInDirectory(const __CFURL *a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(a1, 0, __b, 1024LL);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(a1);
  }

void WithPathInKeychainDirectory(uint64_t a1, uint64_t a2)
{
  int v4 = SecCopyURLForFileInBaseDirectory(@"Library/Keychains", a1);
  WithPathInDirectory(v4, a2);
}

void __security_simulatecrash(void *a1, unsigned int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  secLogObjForScope("SecError");
  int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  int v5 = __simulate_crash_counter;
  if (__simulate_crash_counter != -1) {
    goto LABEL_4;
  }
  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    *(_OWORD *)__int128 buf = xmmword_189676A60;
    *(void *)&uint8_t buf[16] = 0LL;
    CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  }

  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    int v5 = __simulate_crash_counter;
LABEL_4:
    __simulate_crash_counter = v5 + 1;
    return;
  }

  uint64_t v6 = getpid();
  id v7 = a1;
  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000LL;
  CFURLRef v8 = getSimulateCrashSymbolLoc_ptr;
  uint64_t v13 = getSimulateCrashSymbolLoc_ptr;
  if (!getSimulateCrashSymbolLoc_ptr)
  {
    int v9 = CrashReporterSupportLibrary();
    CFURLRef v8 = dlsym(v9, "SimulateCrash");
    *(void *)(*(void *)&buf[8] + 24LL) = v8;
    getSimulateCrashSymbolLoc_ptr = v8;
  }

  _Block_object_dispose(buf, 8);
  if (!v8)
  {
    [MEMORY[0x1896077D8] currentHandler];
    int v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( NSString,  "stringWithUTF8String:",  "BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)");
    CFIndex v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v10,  "handleFailureInFunction:file:lineNumber:description:",  v11,  @"simulate_crash.m",  22,  @"%s",  dlerror());

    __break(1u);
  }

  ((void (*)(uint64_t, void, id))v8)(v6, a2, v7);
}

void sub_18060C614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *CrashReporterSupportLibrary()
{
  if (!CrashReporterSupportLibraryCore_frameworkLibrary) {
    CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  int v0 = (void *)CrashReporterSupportLibraryCore_frameworkLibrary;
  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    [MEMORY[0x1896077D8] currentHandler];
    int v0 = (void *)objc_claimAutoreleasedReturnValue();
    [NSString stringWithUTF8String:"void *CrashReporterSupportLibrary(void)"];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend( v0,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"simulate_crash.m",  18,  @"%s",  0);

    __break(1u);
    free(v3);
  }

  return v0;
}

void PerformWithBuffer(size_t __size, uint64_t a2)
{
  v5[1] = *MEMORY[0x1895F89C0];
  if (__size)
  {
    if (__size > 0x800)
    {
      int v4 = malloc(__size);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, __size, v4);
      if (v4) {
        free(v4);
      }
    }

    else
    {
      MEMORY[0x1895F8858]();
      memset((char *)v5 - ((__size + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, __size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))( a2,  __size,  (char *)v5 - ((__size + 15) & 0xFFFFFFFFFFFFFFF0LL));
    }
  }

  else
  {
    (*(void (**)(uint64_t, void, void))(a2 + 16))(a2, 0LL, 0LL);
  }

void __PerformWithBufferAndClear_block_invoke(uint64_t a1, size_t a2, void *a3)
{
}

xpc_object_t SecCreateXPCObjectWithCFError(__CFError *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  CFErrorDomain Domain = CFErrorGetDomain(a1);
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 0x40000000LL;
  void v21[2] = __SecXPCDictionarySetCFString_block_invoke;
  size_t v21[3] = &__block_descriptor_tmp_13830;
  void v21[4] = v2;
  void v21[5] = "domain";
  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 0x40000000LL;
  void v22[2] = __CFStringPerformWithCString_block_invoke;
  v22[3] = &unk_189676790;
  void v22[4] = v21;
  CFStringPerformWithCStringAndLength(Domain, (uint64_t)v22);
  int64_t Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  int v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  size_t v12 = der_sizeof_plist(v5, 0LL, v6, v7, v8, v9, v10, v11);
  if (v12)
  {
    size_t v13 = v12;
    uint64_t v14 = (UInt8 *)malloc(v12);
    unint64_t v15 = (unint64_t)&v14[v13];
    CFTypeRef v19 = (const void *)der_encode_plist_repair(v5, 0LL, 0LL, v14, v15, v16, v17, v18);
    if (v19) {
      xpc_dictionary_set_data(v2, "userinfo", v19, v15 - (void)v19);
    }
    free(v14);
  }

  CFRelease(v5);
  return v2;
}

void __SecXPCDictionarySetCFString_block_invoke(uint64_t a1, char *string)
{
}

uint64_t SecGetCurrentServerLoggingInfo(uint64_t a1)
{
  uint64_t v4 = 0LL;
  int v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  void v3[2] = __SecGetCurrentServerLoggingInfo_block_invoke;
  v3[3] = &unk_189676AC8;
  void v3[4] = &v4;
  void v3[5] = a1;
  _os_activity_initiate(&dword_1804F4000, "SecGetCurrentServerLoggingInfo", OS_ACTIVITY_FLAG_DEFAULT, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void __SecGetCurrentServerLoggingInfo_block_invoke(uint64_t a1)
{
  if (gSecurityd && (xpc_object_t v2 = *(uint64_t (**)(void))(gSecurityd + 512)) != 0LL)
  {
    uint64_t v3 = v2(*(void *)(a1 + 40));
  }

  else
  {
    uint64_t v4 = *(CFTypeRef **)(a1 + 40);
    uint64_t v6 = 0LL;
    unint64_t v7 = &v6;
    uint64_t v8 = 0x2000000000LL;
    uint64_t v9 = 0LL;
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 0x40000000LL;
    void v5[2] = __void_to_dict_error_request_block_invoke;
    v5[3] = &unk_189676B40;
    void v5[4] = &v6;
    securityd_send_sync_and_do(0x1Fu, v4, 0LL, (uint64_t)v5);
    uint64_t v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
}

BOOL __void_to_dict_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v4 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a2, "status", a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  return v4 != 0LL;
}

uint64_t SecSetLoggingInfoForXPCScope(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = -86;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecSetLoggingInfoForXPCScope_block_invoke;
  activity_block[3] = &unk_189676AF0;
  void activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_1804F4000, "SecSetLoggingInfoForXPCScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecSetLoggingInfoForXPCScope_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 520)) != 0LL)
  {
    uint64_t result = v2(a1[5], a1[6]);
  }

  else
  {
    uint64_t v5 = a1[5];
    CFTypeRef v4 = (CFTypeRef *)a1[6];
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __dict_to_error_request_block_invoke_13841;
    void v6[3] = &__block_descriptor_tmp_5_13842;
    void v6[4] = v5;
    uint64_t result = securityd_send_sync_and_do(0x20u, v4, (uint64_t)v6, 0LL);
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

size_t __dict_to_error_request_block_invoke_13841( uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t SecSetLoggingInfoForCircleScope(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = -86;
  activity_block[0] = MEMORY[0x1895F87A8];
  activity_block[1] = 0x40000000LL;
  activity_block[2] = __SecSetLoggingInfoForCircleScope_block_invoke;
  activity_block[3] = &unk_189676B18;
  void activity_block[4] = &v5;
  activity_void block[5] = a1;
  void activity_block[6] = a2;
  _os_activity_initiate(&dword_1804F4000, "SecSetLoggingInfoForCircleScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t __SecSetLoggingInfoForCircleScope_block_invoke(void *a1)
{
  if (gSecurityd && (uint64_t v2 = *(uint64_t (**)(void, void))(gSecurityd + 528)) != 0LL)
  {
    uint64_t result = v2(a1[5], a1[6]);
  }

  else
  {
    uint64_t v5 = a1[5];
    CFTypeRef v4 = (CFTypeRef *)a1[6];
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 0x40000000LL;
    v6[2] = __dict_to_error_request_block_invoke_13841;
    void v6[3] = &__block_descriptor_tmp_5_13842;
    void v6[4] = v5;
    uint64_t result = securityd_send_sync_and_do(0x21u, v4, (uint64_t)v6, 0LL);
  }

  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

void Security::CCHashInstance::~CCHashInstance(Security::CCHashInstance *this)
{
}

{
  *(void *)this = off_189676B90;
  CCDigestDestroy();
}

uint64_t Security::CCHashInstance::digestLength(Security::CCHashInstance *this)
{
  if (*((void *)this + 3)) {
    return *((void *)this + 3);
  }
  else {
    return CCDigestOutputSize();
  }
}

uint64_t Security::CCHashInstance::update(Security::CCHashInstance *this, const void *a2)
{
  return CCDigestUpdate();
}

void *Security::CCHashInstance::finish(Security::CCHashInstance *this, unsigned __int8 *a2)
{
  v9[1] = *MEMORY[0x1895F89C0];
  if (!*((void *)this + 3)) {
    return (void *)CCDigestFinal();
  }
  uint64_t v4 = CCDigestOutputSize();
  uint64_t v5 = MEMORY[0x1895F8858](v4);
  uint64_t v7 = (char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v5) {
    memset((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v6);
  }
  CCDigestFinal();
  return memcpy(a2, v7, *((void *)this + 3));
}

Security::CCHashInstance *Security::CCHashInstance::CCHashInstance( Security::CCHashInstance *this, unsigned int a2, uint64_t a3)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = off_189676B90;
  uint64_t v5 = CCDigestCreate();
  *((void *)this + 2) = v5;
  if (!v5) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  *((void *)this + 3) = a3;
  return this;
}

uint64_t Security::CFMunge::next(Security::CFMunge *this)
{
  uint64_t v1 = *(unsigned __int8 **)this;
  LOBYTE(v2) = **(_BYTE **)this;
  if ((_BYTE)v2)
  {
    uint64_t v4 = MEMORY[0x1895F8770];
    do
    {
      if ((v2 & 0x80) != 0)
      {
        int v5 = __maskrune((char)v2, 0x4000uLL);
        uint64_t v1 = *(unsigned __int8 **)this;
        if (!v5)
        {
LABEL_7:
          int v2 = *v1;
          if (v2 != 44) {
            return (char)v2;
          }
        }
      }

      else if ((*(_DWORD *)(v4 + 4LL * (char)v2 + 60) & 0x4000) == 0)
      {
        goto LABEL_7;
      }

      *(void *)this = v1 + 1;
      int v2 = *++v1;
    }

    while (v2);
  }

  return (char)v2;
}

CFDataRef Security::CFMake::make(Security::CFMake *this)
{
  while (Security::CFMunge::next(this) == 64)
  {
    uint64_t v2 = (*(void *)this)++;
    int v3 = *(char *)(v2 + 1);
    if (v3 == 69)
    {
      *(void *)this = v2 + 2;
      size_t v6 = (_DWORD **)*((void *)this + 1);
      uint64_t v7 = *v6;
      *v6 += 2;
      *((_DWORD *)this + 6) = *v7;
    }

    else if (v3 == 65)
    {
      *(void *)this = v2 + 2;
      uint64_t v4 = (void **)*((void *)this + 1);
      int v5 = (*v4)++;
      *((void *)this + 2) = *v5;
    }
  }

  int v8 = Security::CFMunge::next(this);
  CFMutableStringRef MutableCopy = 0LL;
  if (v8 > 90)
  {
    if (v8 <= 122)
    {
      if (v8 != 91)
      {
        if (v8 == 93) {
          return MutableCopy;
        }
        goto LABEL_43;
      }

      ++*(void *)this;
      unint64_t v15 = (Security *)Security::CFMunge::next(this);
      if ((_DWORD)v15 == 43)
      {
        ++*(void *)this;
        ++*(void *)this;
        uint64_t v17 = (CFArrayRef **)*((void *)this + 1);
        ++*(void *)this;
        uint64_t v18 = (*v17)++;
        CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0LL, *v18);
      }

      else
      {
        CFMutableStringRef MutableCopy = Security::makeCFMutableArray(v15, v16);
LABEL_50:
        while (Security::CFMunge::next(this) != 93)
        {
          int v31 = (const void *)Security::CFMake::make(this);
          if (!v31) {
            goto LABEL_60;
          }
          size_t v32 = v31;
          CFArrayAppendValue(MutableCopy, v31);
          CFRelease(v32);
        }
      }

char *Security::CFMake::makestring(CFAllocatorRef *this)
{
  CFAllocatorRef v2 = *this;
  if (*(_BYTE *)*this == 39)
  {
    CFAllocatorRef v2 = (CFAllocatorRef)((char *)v2 + 1);
    *this = v2;
    uint64_t result = strchr((const char *)v2, 39);
    if (!result) {
      return result;
    }
    uint64_t v4 = result + 1;
  }

  else
  {
    uint64_t v5 = MEMORY[0x1895F8770];
    uint64_t v4 = (char *)*this;
    do
    {
      while (1)
      {
        unsigned int v7 = *++v4;
        unsigned int v6 = v7;
        if ((v7 & 0x80000000) != 0) {
          break;
        }
        if ((*(_DWORD *)(v5 + 4LL * v6 + 60) & 0x500) == 0) {
          goto LABEL_9;
        }
      }
    }

    while (__maskrune(v6, 0x500uLL));
LABEL_9:
    uint64_t result = v4;
  }

  *this = (CFAllocatorRef)v4;
  return (char *)CFStringCreateWithBytes(this[2], (const UInt8 *)v2, result - (char *)v2, 0x8000100u, 0);
}

__CFDictionary *Security::CFMake::add(Security::CFMake *this, __CFDictionary *a2)
{
  while (Security::CFMunge::next(this) != 125)
  {
    uint64_t v4 = Security::CFMake::make(this);
    if (!v4) {
      return 0LL;
    }
    uint64_t v5 = (const void *)v4;
    if (Security::CFMunge::next(this) != 61
      || (++*(void *)this, (unsigned int v6 = (const void *)Security::CFMake::make(this)) == 0LL))
    {
      CFRelease(v5);
      return 0LL;
    }

    unsigned int v7 = v6;
    CFDictionaryAddValue(a2, v5, v6);
    CFRelease(v5);
    CFRelease(v7);
  }

  ++*(void *)this;
  return a2;
}

uint64_t Security::CFScan::scan(Security::CFScan *this, const __CFString *a2)
{
  while (Security::CFMunge::next(this) == 64)
  {
    uint64_t v4 = (*(void *)this)++;
    int v5 = *(char *)(v4 + 1);
    if (v5 == 69)
    {
      *(void *)this = v4 + 2;
      int v8 = (_DWORD **)*((void *)this + 1);
      uint64_t v9 = *v8;
      *v8 += 2;
      *((_DWORD *)this + 6) = *v9;
    }

    else if (v5 == 65)
    {
      *(void *)this = v4 + 2;
      unsigned int v6 = (void **)*((void *)this + 1);
      unsigned int v7 = (*v6)++;
      *((void *)this + 2) = *v7;
    }
  }

  int v10 = Security::CFMunge::next(this);
  if (v10 > 90)
  {
    if (v10 > 122)
    {
      if (v10 == 123)
      {
        if (!a2) {
          return (uint64_t)Security::CFScan::scandictionary(this, 0LL);
        }
        CFTypeID v13 = CFGetTypeID(a2);
        if (v13 == CFDictionaryGetTypeID()) {
          return (uint64_t)Security::CFScan::scandictionary(this, (const __CFDictionary *)a2);
        }
      }
    }

    else if (v10 == 91)
    {
      if (!a2) {
        return Security::CFScan::scanarray(this, 0LL);
      }
      CFTypeID v15 = CFGetTypeID(a2);
      if (v15 == CFArrayGetTypeID()) {
        return Security::CFScan::scanarray(this, (CFArrayRef)a2);
      }
    }

    return 0LL;
  }

  if (!v10) {
    return 1LL;
  }
  if (v10 == 37)
  {
    BOOL v12 = 0LL;
    uint64_t v16 = (*(void *)this)++;
    int v17 = *(char *)(v16 + 1);
    if (v17 <= 82)
    {
      if (v17 <= 67)
      {
        if (v17 != 65)
        {
          if (v17 != 66) {
            return v12;
          }
          CFTypeID TypeID = CFBooleanGetTypeID();
          int v23 = Security::CFScan::typescan(this, a2, TypeID);
          BOOL v12 = v23 == 1;
          if (v23) {
            return v12;
          }
          if (**(_BYTE **)this == 102)
          {
            int v24 = (int **)*((void *)this + 1);
            unint64_t v25 = *v24;
            *v24 += 2;
            int v26 = *v25;
            unsigned int v27 = (_DWORD ***)*((void *)this + 1);
            unint64_t v28 = (*v27)++;
            if ((const __CFString *)*MEMORY[0x189604DE8] != a2 || *((_BYTE *)this + 28)) {
              return 1LL;
            }
            __int128 v29 = *v28;
            int v30 = *v29 | v26;
          }

          else
          {
            if (*((_BYTE *)this + 28)) {
              return 1LL;
            }
            int v30 = *MEMORY[0x189604DE8] == (void)a2;
            __int128 v39 = (int ***)*((void *)this + 1);
            __int128 v40 = (*v39)++;
            __int128 v29 = *v40;
          }

          int *v29 = v30;
          return 1LL;
        }

        CFTypeID v31 = CFArrayGetTypeID();
      }

      else
      {
        switch(v17)
        {
          case 'D':
            CFTypeID v31 = CFDictionaryGetTypeID();
            break;
          case 'N':
            CFTypeID v31 = CFNumberGetTypeID();
            break;
          case 'O':
            if (!*((_BYTE *)this + 28))
            {
              uint64_t v18 = (void ***)*((void *)this + 1);
              uint64_t v19 = (const __CFString ***)(*v18)++;
              **uint64_t v19 = a2;
            }

            return 1LL;
          default:
            return v12;
        }
      }

      return Security::CFScan::typescan(this, a2, v31) == 1;
    }

    if (v17 <= 99)
    {
      if (v17 != 83)
      {
        if (v17 != 88) {
          return v12;
        }
        CFTypeID v31 = CFDataGetTypeID();
        return Security::CFScan::typescan(this, a2, v31) == 1;
      }
    }

    else
    {
      if (v17 == 100)
      {
        *(void *)this = v16 + 2;
        if (!a2) {
          return 1LL;
        }
        CFTypeID v36 = CFGetTypeID(a2);
        if (v36 != CFNumberGetTypeID()) {
          return 0LL;
        }
        int v21 = Security::cfNumber<int>((const __CFNumber *)a2);
        goto LABEL_57;
      }

      if (v17 != 115)
      {
        if (v17 != 117) {
          return v12;
        }
        *(void *)this = v16 + 2;
        if (!a2) {
          return 1LL;
        }
        CFTypeID v20 = CFGetTypeID(a2);
        if (v20 != CFNumberGetTypeID()) {
          return 0LL;
        }
        int v21 = Security::cfNumber<unsigned int>((const __CFNumber *)a2);
LABEL_57:
        if (!*((_BYTE *)this + 28))
        {
          CFIndex v37 = (_DWORD ***)*((void *)this + 1);
          __int128 v38 = (*v37)++;
          *const UInt8 *v38 = v21;
        }

        return 1LL;
      }
    }

    CFTypeID v32 = CFStringGetTypeID();
    int v33 = Security::CFScan::typescan(this, a2, v32);
    BOOL v12 = v33 == 1;
    if (v33) {
      return v12;
    }
    Security::cfString(&__str, a2);
    if (!*((_BYTE *)this + 28))
    {
      uint64_t v34 = (std::string ***)*((void *)this + 1);
      int v35 = (*v34)++;
      std::string::operator=(*v35, &__str);
    }

    return 1LL;
  }

  if (v10 != 61) {
    return 0LL;
  }
  ++*(void *)this;
  CFDataRef v11 = Security::CFMake::make(this);
  BOOL v12 = CFEqual(a2, v11) != 0;
  CFRelease(v11);
  return v12;
}

void sub_18060DB70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef Security::CFScan::scandictionary(Security::CFScan *this, const __CFDictionary *a2)
{
  while (1)
  {
    BOOL v4 = Security::CFMunge::next(this) == 125;
    CFDataRef result = (CFDataRef)v4;
    if (v4) {
      break;
    }
    int v6 = Security::CFMunge::next(this);
    if (v6 == 63) {
      ++*(void *)this;
    }
    CFDataRef result = Security::CFMake::make(this);
    if (!result) {
      break;
    }
    CFDataRef v7 = result;
    char v8 = *((_BYTE *)this + 28);
    if (a2) {
      unint64_t Value = CFDictionaryGetValue(a2, result);
    }
    else {
      unint64_t Value = 0LL;
    }
    if (v6 != 63 && !Value
      || (*((_BYTE *)this + 28) |= Value == 0LL, Security::CFMunge::next(this) != 61)
      || (++*(void *)this, (Security::CFScan::scan(this, Value) & 1) == 0))
    {
      CFRelease(v7);
      return 0LL;
    }

    *((_BYTE *)this + 2_Block_object_dispose(va, 8) = v8;
    CFRelease(v7);
  }

  return result;
}

uint64_t Security::CFScan::scanarray(Security::CFScan *this, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    char v10 = 0;
  }

  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0LL;
    BOOL v7 = 1;
    while (1)
    {
      if (Security::CFMunge::next(this) == 93)
      {
        char v9 = 1;
        goto LABEL_10;
      }

      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
      if ((Security::CFScan::scan(this, ValueAtIndex) & 1) == 0) {
        break;
      }
      BOOL v7 = v5 > ++v6;
      if (v5 == v6) {
        goto LABEL_10;
      }
    }

    char v9 = 0;
LABEL_10:
    char v10 = v7 & v9;
  }

  return v10 & 1;
}

uint64_t Security::CFScan::typescan(Security::CFScan *this, CFTypeRef cf, uint64_t a3)
{
  if (cf && CFGetTypeID(cf) != a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = (*(void *)this)++;
  int v6 = *(char *)(v5 + 1);
  if (v6 == 110)
  {
    *(void ++*(void *)this = v5 + 2;
    return 1LL;
  }

  if (v6 == 79)
  {
    *(void ++*(void *)this = v5 + 2;
    if (!*((_BYTE *)this + 28))
    {
      BOOL v7 = (void ***)*((void *)this + 1);
      char v8 = (*v7)++;
      *void *v8 = cf;
    }

    return 1LL;
  }

  return 0LL;
}

uint64_t Security::cfNumber<unsigned int>(const __CFNumber *a1)
{
  unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  unint64_t Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
  if (!(_DWORD)Value) {
    Security::CFError::throwMe(Value);
  }
  return valuePtr;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t Security::cfNumber<int>(const __CFNumber *a1)
{
  unsigned int valuePtr = -1431655766;
  unint64_t Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
  if (!(_DWORD)Value) {
    Security::CFError::throwMe(Value);
  }
  return valuePtr;
}

__CFDictionary *Security::cfadd(Security *this, __CFDictionary *a2, const char *a3, ...)
{
  v5[0] = a2;
  v5[1] = &v7;
  void v5[2] = 0LL;
  int v6 = 0;
  CFDataRef result = (__CFDictionary *)Security::CFMunge::next((Security::CFMunge *)v5);
  if ((_DWORD)result == 123)
  {
    ++v5[0];
    return Security::CFMake::add((Security::CFMake *)v5, this);
  }

  return result;
}

uint64_t Security::cfscan(const __CFString *this, const void *a2, const char *a3, ...)
{
  v5[0] = a2;
  v5[1] = &v4;
  void v5[2] = 0LL;
  int v6 = 0;
  char v7 = 0;
  return Security::CFScan::scan((Security::CFScan *)v5, this);
}

uint64_t Security::SecCFObject::operator void const*(uint64_t a1)
{
  return a1 - 24;
}

BOOL Security::SecCFObject::equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t Security::SecCFObject::copyFormattingDesc(Security::SecCFObject *this, const __CFDictionary *a2)
{
  return 0LL;
}

uint64_t Security::SecCFObject::copyDebugDesc(Security::SecCFObject *this)
{
  return 0LL;
}

uint64_t Security::SecCFObject::getMutexForObject(Security::SecCFObject *this)
{
  return 0LL;
}

uint64_t Security::SecCFObject::mayDelete(Security::SecCFObject *this)
{
  return 1LL;
}

void Security::SecCFObject::operator delete(char *a1)
{
  uint64_t v1 = a1 - 24;
  CFAllocatorRef v2 = CFGetAllocator(a1 - 24);
  CFAllocatorDeallocate(v2, v1);
}

void Security::SecPointerBase::~SecPointerBase(Security::SecPointerBase *this)
{
  uint64_t v1 = *(void *)this;
  if (v1)
  {
    CFAllocatorRef v2 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
    CFRelease(v2);
  }

void Security::SecPointerBase::assign(Security::SecPointerBase *this, Security::SecCFObject *a2)
{
  if (a2)
  {
    va_list v4 = (unsigned __int8 *)a2 - 8;
    do
      unsigned __int8 v5 = __ldaxr(v4);
    while (__stlxr(1u, v4));
    if ((v5 & 1) != 0)
    {
      int v6 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(void *)a2 + 16LL))(a2);
      CFRetain(v6);
    }
  }

  if (*(void *)this)
  {
    char v7 = (const void *)(*(uint64_t (**)(void))(**(void **)this + 16LL))(*(void *)this);
    CFRelease(v7);
  }

  *(void ++*(void *)this = a2;
}

uint64_t Security::SecCFObject::allocate( Security::SecCFObject *this, unint64_t a2, const Security::CFClass *a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    int v6 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v6, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  atomic_store(0, (unsigned __int8 *)(Instance + 16));
  return Instance + 24;
}

const void *Security::SecCFObject::handle(Security::SecCFObject *this, int a2)
{
  va_list v4 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(void *)this + 16LL))(this);
  unsigned __int8 v5 = v4;
  if (a2)
  {
    int v6 = (unsigned __int8 *)this - 8;
    do
      unsigned __int8 v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0) {
      CFRetain(v4);
    }
  }

  return v5;
}

void DYLDCache::~DYLDCache(DYLDCache *this)
{
}

{
  *(void ++*(void *)this = off_189676C28;
  munmap(*((void **)this + 2), *((void *)this + 3));
  Security::UnixPlusPlus::FileDesc::closeAndLog((DYLDCache *)((char *)this + 8));
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000LL;
    *a1 = v6;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v4;
    int v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }

  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

const char *DYLDCache::matchArchitecture(char *__s1)
{
  CFAllocatorRef v2 = "\a";
  while (1)
  {
    int v3 = strcmp(__s1, v2 + 8);
    if (!v3) {
      break;
    }
    int v4 = *((_DWORD *)v2 + 9);
    v2 += 36;
    if (!v4)
    {
      CFAllocatorRef v2 = (const char *)&unk_180659720;
      break;
    }
  }

  if (*(void *)__s1 == 0x2031765F646C7964LL) {
    size_t v5 = &DYLDCache::defaultArchitecture;
  }
  else {
    size_t v5 = 0LL;
  }
  if (v3) {
    return (const char *)v5;
  }
  else {
    return v2;
  }
}

void Security::Syslog::warning(Security::Syslog *this, const char *a2, ...)
{
}

void Security::Syslog::notice(Security::Syslog *this, const char *a2, ...)
{
}

pthread_mutex_t *Security::Mutex::Mutex(pthread_mutex_t *this)
{
  CFAllocatorRef v2 = (Security::UnixError *)pthread_mutex_init(this, 0LL);
  if ((_DWORD)v2) {
    Security::UnixError::throwMe(v2);
  }
  return this;
}

void Security::Mutex::~Mutex(pthread_mutex_t *this)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  int v1 = pthread_mutex_destroy(this);
  if (v1)
  {
    unsigned int v3 = v1;
    CFAllocatorRef v2 = (os_log_s *)secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v4) = 67109120;
      HIDWORD(v4) = v3;
      _os_log_impl( &dword_1804F4000,  v2,  OS_LOG_TYPE_DEFAULT,  "Probable bug: error destroying Mutex: %d",  (uint8_t *)&v4,  8u);
    }

    Security::UnixError::throwMe((Security::UnixError *)v3);
  }

void sub_18060E3B8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

Security::UnixError *Security::Mutex::lock(pthread_mutex_t *this)
{
  CFDataRef result = (Security::UnixError *)pthread_mutex_lock(this);
  if ((_DWORD)result) {
    Security::UnixError::throwMe(result);
  }
  return result;
}

CFURLRef Security::makeCFURL(Security *this, const char *a2, uint64_t a3, const __CFURL *a4)
{
  if (a3)
  {
    Security::CFTempString::CFTempString<char const*>(&filePath, (const char *)this);
    CFURLRef v6 = (CFURLRef)MEMORY[0x186DFE668](0LL, filePath, 0LL, a2, a3);
  }

  else
  {
    Security::CFTempString::CFTempString<char const*>(&filePath, (const char *)this);
    CFURLRef v6 = CFURLCreateWithFileSystemPath(0LL, filePath, kCFURLPOSIXPathStyle, (Boolean)a2);
  }

  CFURLRef v7 = v6;
  Security::CFRef<__CFString const*>::~CFRef((const void **)&filePath);
  return v7;
}

void sub_18060E460(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CFStringRef *Security::CFTempString::CFTempString<char const*>(CFStringRef *a1, const char *a2)
{
  if (a2)
  {
    CFStringRef v4 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
    if (!v4)
    {
      CFStringRef v4 = CFStringCreateWithCString(0LL, a2, 0x600u);
      if (!v4) {
        Security::CFError::throwMe(0LL);
      }
    }
  }

  else
  {
    CFStringRef v4 = 0LL;
  }

  *a1 = v4;
  return a1;
}

const void **Security::CFRef<__CFString const*>::~CFRef(const void **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFDataRef Security::CFMallocData::operator __CFData const*(uint64_t a1)
{
  CFDataRef result = CFDataCreateWithBytesNoCopy( 0LL,  *(const UInt8 **)a1,  *(void *)(a1 + 8),  (CFAllocatorRef)*MEMORY[0x189604DB8]);
  if (!result) {
    Security::CFError::throwMe(0LL);
  }
  *(void *)a1 = 0LL;
  return result;
}

CFMutableDictionaryRef Security::makeCFMutableDictionary(Security *this)
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (!result) {
    Security::CFError::throwMe(0LL);
  }
  return result;
}

__CFDictionary *Security::makeCFMutableDictionary(Security *this, void *key, const void *a3, ...)
{
  CFMutableDictionary = Security::makeCFMutableDictionary(this);
  CFDictionaryAddValue(CFMutableDictionary, key, a3);
  return CFMutableDictionary;
}

CFPropertyListRef Security::makeCFDictionaryFrom(CFDataRef xmlData, const __CFData *a2)
{
  if (!xmlData) {
    return 0LL;
  }
  CFPropertyListRef v2 = CFPropertyListCreateFromXMLData(0LL, xmlData, 0LL, 0LL);
  CFPropertyListRef v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    CFTypeID TypeID = (Security::CFError *)CFDictionaryGetTypeID();
    if ((Security::CFError *)v4 != TypeID) {
      Security::CFError::throwMe(TypeID);
    }
  }

  return v3;
}

const void **Security::CFRef<__CFData const*>::~CFRef(const void **a1)
{
  CFPropertyListRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t Security::cfarrayApplyBlock_func( Security *this, uint64_t (**a2)(void, void), const void *a3)
{
  return ((uint64_t (**)(void, Security *))a2)[2](a2, this);
}

void Security::cfString(std::string *this, CFStringRef theString)
{
  if (!theString)
  {
    uint64_t v5 = (char *)&unk_18065A197;
    goto LABEL_5;
  }

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
  {
    uint64_t v5 = (char *)CStringPtr;
LABEL_5:
    std::string::basic_string[abi:ne180100]<0>(this, v5);
    return;
  }

  this->__r_.__value_.__r.__words[0] = 0LL;
  this->__r_.__value_.__l.__size_ = 0LL;
  this->__r_.__value_.__l.__cap_ = 0LL;
  CFIndex Length = CFStringGetLength(theString);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding <= -2) {
    std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = MaximumSizeForEncoding + 1;
  char v9 = operator new(MaximumSizeForEncoding + 1);
  bzero(v9, v8);
  operator delete(v9);
}

void sub_18060E734(_Unwind_Exception *a1)
{
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external( std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = (char)this->__r_.__value_.__s.__size_;
  if ((v6 & 0x80000000) != 0)
  {
    std::string::size_type cap = this->__r_.__value_.__l.__cap_;
    unint64_t v9 = (cap & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }

    std::string::size_type v6 = HIBYTE(cap);
    CFURLRef v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }

  else
  {
    CFURLRef v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = this->__r_.__value_.__s.__size_;
      unint64_t v9 = 22LL;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0LL, size, __n, __s);
      return this;
    }
  }

  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = this->__r_.__value_.__s.__size_;
  }

  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    this->__r_.__value_.__s.__size_ = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

void *Security::cfString(Security *this, const __CFURL *a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (!a2
    || (CFPropertyListRef v3 = this,
        memset(__b, 170, sizeof(__b)),
        this = (Security *)CFURLGetFileSystemRepresentation(a2, 1u, __b, 1025LL),
        !(_DWORD)this))
  {
    Security::CFError::throwMe(this);
  }

  return std::string::basic_string[abi:ne180100]<0>(v3, (char *)__b);
}

const void **Security::cfStringRelease(Security *this, const __CFURL *a2)
{
  CFPropertyListRef v3 = a2;
  Security::cfString(this, a2);
  return Security::CFRef<__CFURL const*>::~CFRef(&v3);
}

void sub_18060E91C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void **Security::CFRef<__CFURL const*>::~CFRef(const void **a1)
{
  CFPropertyListRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **Security::CFRef<__CFBundle *>::~CFRef(const void **a1)
{
  CFPropertyListRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::cfString(std::string *this, __CFString *cf)
{
  if (!cf) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13LL);
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    Security::cfString(this, cf);
  }

  else if (v4 == CFURLGetTypeID())
  {
    Security::cfString((Security *)this, (const __CFURL *)cf);
  }

  else if (v4 == CFBundleGetTypeID())
  {
    uint64_t v5 = CFBundleCopyBundleURL((CFBundleRef)cf);
    Security::cfStringRelease((Security *)this, v5);
  }

  else
  {
    uint64_t v6 = CFCopyDescription(cf);
    Security::cfString(this, v6);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&v6);
  }

void sub_18060EA7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CFArrayRef Security::makeCFArray(Security *this, const void *a2, ...)
{
  v3[0] = a2;
  return CFArrayCreate(0LL, v3, 1LL, MEMORY[0x189605228]);
}

CFMutableArrayRef Security::makeCFMutableArray(Security *this, uint64_t a2, ...)
{
  return CFArrayCreateMutable(0LL, 0LL, MEMORY[0x189605228]);
}

CFDataRef Security::cfMapFile(Security *this, size_t a2)
{
  int v3 = (int)this;
  off_t v4 = lseek((int)this, 0LL, 1);
  uint64_t v5 = (UInt8 *)mmap(0LL, a2, 1, 2, v3, v4);
  if (v5 == (UInt8 *)-1LL) {
    return 0LL;
  }
  uint64_t v6 = v5;
  *(void *)__int16 bytes = a2;
  CFDataRef v11 = CFDataCreate(0LL, bytes, 8LL);
  context.version = 0LL;
  *(_OWORD *)&context.retain = unk_189676C88;
  *(_OWORD *)&context.copyDescription = xmmword_189676C98;
  *(_OWORD *)&context.reallocate = unk_189676CA8;
  context.preferreduint64_t Size = (CFAllocatorPreferredSizeCallBack)Security::mmapPreferredSize;
  context.unint64_t info = v11;
  unint64_t v9 = CFAllocatorCreate(0LL, &context);
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(0LL, v6, *(CFIndex *)bytes, v9);
  if (!v7) {
    munmap(v6, a2);
  }
  Security::CFRef<__CFAllocator const*>::~CFRef((const void **)&v9);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
  return v7;
}

void sub_18060EBDC(_Unwind_Exception *a1)
{
}

const void **Security::CFRef<__CFAllocator const*>::~CFRef(const void **a1)
{
  CFPropertyListRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t Security::mmapDeallocatorAllocate(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return 0LL;
}

uint64_t Security::mmapDeallocatorDeallocate(Security *this, CFDataRef theData, void *a3)
{
  size_t v4 = *(void *)CFDataGetBytePtr(theData);
  return munmap(this, v4);
}

uint64_t Security::mmapPreferredSize(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return (uint64_t)this + 8;
}

CFDataRef Security::cfLoadFile(Security *this, const __CFURL *a2)
{
  *(_OWORD *)__p = *(_OWORD *)&v12.st_dev;
  uint64_t v11 = *(void *)&v12.st_uid;
  if ((v12.st_gid & 0x80000000) == 0) {
    CFPropertyListRef v2 = __p;
  }
  else {
    CFPropertyListRef v2 = (void **)__p[0];
  }
  *(void *)unint64_t v9 = 0xAAAAAAAAFFFFFFFFLL;
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v9, (const char *)v2, 0, 4534);
  v3.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v8.st_blkstd::string::size_type size = v3;
  *(timespec *)v8.st_qspare = v3;
  v8.st_birthtimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v8.st_std::string::size_type size = v3;
  v8.st_mtimespeCC_SHA512_CTX c = v3;
  v8.st_ctimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v8.st_uid = v3;
  v8.st_atimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v8.st_dev = v3;
  size_t v4 = (Security::UnixPlusPlus::FileDesc *)v9[0];
  if (v9[0] == -1)
  {
    CFDataRef v5 = 0LL;
  }

  else
  {
    CFDataRef v5 = 0LL;
    if (!fstat(v9[0], &v8) && (v8.st_size & 0x8000000000000000LL) == 0)
    {
      v6.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
      v6.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v12.st_blkstd::string::size_type size = v6;
      *(timespec *)v12.st_qspare = v6;
      v12.st_birthtimespeCC_SHA512_CTX c = v6;
      *(timespec *)&v12.st_std::string::size_type size = v6;
      v12.st_mtimespeCC_SHA512_CTX c = v6;
      v12.st_ctimespeCC_SHA512_CTX c = v6;
      *(timespec *)&v12.st_uid = v6;
      v12.st_atimespeCC_SHA512_CTX c = v6;
      *(timespec *)&v12.st_dev = v6;
      Security::UnixPlusPlus::FileDesc::fstat(v4, &v12);
      CFDataRef v5 = Security::cfMapFile(v4, v12.st_size);
    }
  }

  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v9);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_18060ED84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
  {
    CFPropertyListRef v2 = (Security::UnixError *)pthread_mutex_unlock(*(pthread_mutex_t **)a1);
    if ((_DWORD)v2) {
      Security::UnixError::throwMe(v2);
    }
  }

  return a1;
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    timespec v6 = operator new(v4 + 1);
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000LL;
    *(void *)a1 = v6;
  }

  else
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)a1 = 0LL;
    *(_BYTE *)(a1 + 23) = a2;
  }

  return a1;
}

void Security::Dispatch::Queue::~Queue(Security::Dispatch::Queue *this)
{
}

{
  *(void ++*(void *)this = off_189676CF8;
  dispatch_barrier_sync(*((dispatch_queue_t *)this + 11), &__block_literal_global_13886);
  dispatch_release(*((dispatch_object_t *)this + 11));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)this + 10);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 8));
}

void Security::Dispatch::Group::~Group(Security::Dispatch::Group *this)
{
}

{
  *(void ++*(void *)this = off_189676D58;
  dispatch_group_wait(*((dispatch_group_t *)this + 11), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*((dispatch_object_t *)this + 11));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)this + 10);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 8));
}

void Security::Dispatch::Semaphore::~Semaphore(dispatch_object_t *this)
{
  *this = (dispatch_object_t)off_189676D78;
  dispatch_release(this[1]);
}

{
  *this = (dispatch_object_t)off_189676D78;
  dispatch_release(this[1]);
  operator delete(this);
}

void Security::Dispatch::SemaphoreWait::~SemaphoreWait(Security::Dispatch::SemaphoreWait *this)
{
  *(void ++*(void *)this = off_189676D98;
  if (*((_BYTE *)this + 16)) {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)this + 1) + 8LL));
  }
}

{
  *(void ++*(void *)this = off_189676D98;
  if (*((_BYTE *)this + 16)) {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)this + 1) + 8LL));
  }
  operator delete(this);
}

uint64_t ___ZN8Security8Dispatch23ExceptionAwareEnqueuing21enqueueWithDispatcherEU13block_pointerFvU13block_pointerFvvEES3__block_invoke( uint64_t result)
{
  if (!*(_BYTE *)(*(void *)(result + 40) + 64LL)) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
  }
  return result;
}

void sub_18060F088( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, uint64_t a11, uint64_t a12)
{
  a11 = v12;
  a12 = 0xAAAAAAAAAAAAAA01LL;
  Security::Mutex::lock((pthread_mutex_t *)v12);
  *(_BYTE *)(v12 + 64) = 1;
  std::current_exception();
  std::exception_ptr::operator=((std::exception_ptr *)(v12 + 72), &a10);
  std::exception_ptr::~exception_ptr(&a10);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a11);
  __cxa_end_catch();
  JUMPOUT(0x18060F078LL);
}

void sub_18060F0D4(_Unwind_Exception *a1)
{
}

void Security::Dispatch::Group::wait(Security::Dispatch::Group *this)
{
  if (*((_BYTE *)this + 72))
  {
    *((_BYTE *)this + 72) = 0;
    std::exception_ptr::exception_ptr(&v3, (const std::exception_ptr *)this + 10);
    v2.__ptr_ = &v3;
    std::rethrow_exception(v2);
    __break(1u);
  }

void sub_18060F13C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

void *Security::BlobCore::readBlob(Security::BlobCore *this, off_t a2, int a3, size_t a4)
{
  int v7 = (int)this;
  ____int128 buf = 0LL;
  size_t v8 = bswap32(HIDWORD(__buf));
  if (a4 && v8 > a4)
  {
    int v10 = 12;
    goto LABEL_11;
  }

  CFTypeID v13 = malloc(v8);
  uint64_t v11 = v13;
  if (v13)
  {
    *CFTypeID v13 = __buf;
    if (pread(v7, v13 + 1, v8 - 8, a2 + 8) != v8 - 8)
    {
      free(v11);
LABEL_6:
      int v10 = 22;
LABEL_11:
      uint64_t v11 = 0LL;
      *__error() = v10;
    }
  }

  return v11;
}

_DWORD *Security::BlobWrapper::alloc(Security::BlobWrapper *this, unint64_t a2)
{
  if (a2 > 0xFFFFFFFFFFFFFFF7LL) {
    return 0LL;
  }
  unsigned int v4 = a2 + 8;
  uint64_t v5 = malloc(a2 + 8);
  std::exception_ptr v2 = v5;
  if (v5)
  {
    *uint64_t v5 = 17555194;
    v5[1] = bswap32(v4);
    memcpy(v5 + 2, this, v4 - 8LL);
  }

  return v2;
}

void Security::UnixError::~UnixError(std::exception *this)
{
}

uint64_t Security::UnixError::what(Security::UnixError *this)
{
  return (uint64_t)this + 8;
}

uint64_t Security::UnixError::osStatus(Security::UnixError *this)
{
  return (*((_DWORD *)this + 36) + 100000);
}

uint64_t Security::UnixError::unixError(Security::UnixError *this)
{
  return *((unsigned int *)this + 36);
}

void Security::MacOSError::~MacOSError(std::exception *this)
{
}

uint64_t Security::MacOSError::what(Security::MacOSError *this)
{
  return (uint64_t)this + 8;
}

uint64_t Security::MacOSError::osStatus(Security::MacOSError *this)
{
  return *((unsigned int *)this + 36);
}

uint64_t Security::MacOSError::unixError(Security::MacOSError *this)
{
  unsigned int v1 = *((_DWORD *)this + 36) - 100000;
  if (v1 >= 0x100) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v1;
  }
}

void Security::CFError::~CFError(std::exception *this)
{
}

const char *Security::CFError::what(Security::CFError *this)
{
  return "CoreFoundation error";
}

uint64_t Security::CFError::osStatus(Security::CFError *this)
{
  return 4294962336LL;
}

uint64_t Security::CFError::unixError(Security::CFError *this)
{
  return 14LL;
}

void Security::ModuleNexusError::~ModuleNexusError(std::exception *this)
{
}

uint64_t Security::ModuleNexusError::osStatus(Security::ModuleNexusError *this)
{
  return 4294967246LL;
}

uint64_t Security::ModuleNexusError::unixError(Security::ModuleNexusError *this)
{
  return 22LL;
}

void Security::CommonError::LogBacktrace(Security::CommonError *this)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  unsigned int v1 = (os_log_s *)secLogObjForScope("security_exception");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(void *)&__int128 v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v35 = v2;
    __int128 v36 = v2;
    __int128 v33 = v2;
    __int128 v34 = v2;
    __int128 v31 = v2;
    __int128 v32 = v2;
    __int128 v29 = v2;
    __int128 v30 = v2;
    __int128 v27 = v2;
    __int128 v28 = v2;
    __int128 v25 = v2;
    __int128 v26 = v2;
    __int128 v23 = v2;
    __int128 v24 = v2;
    *(_OWORD *)int v21 = v2;
    __int128 v22 = v2;
    int v3 = backtrace(v21, 32);
    unsigned int v4 = backtrace_symbols(v21, v3);
    uint64_t v5 = v4;
    memset(&v18, 0, sizeof(v18));
    if (v3 < 1)
    {
      free(v4);
    }

    else
    {
      for (uint64_t i = 0LL; i != v3; ++i)
      {
        if ((char)v18.__r_.__value_.__s.__size_ < 0)
        {
          v18.__r_.__value_.__l.__size_ = 0LL;
          int v7 = (std::string *)v18.__r_.__value_.__r.__words[0];
        }

        else
        {
          v18.__r_.__value_.__s.__size_ = 0;
          int v7 = &v18;
        }

        v7->__r_.__value_.__s.__data_[0] = 0;
        __stringp = v5[i];
        while (1)
        {
          size_t v8 = strsep(&__stringp, " ");
          unint64_t v9 = v8;
          if (!v8) {
            break;
          }
          if (*v8)
          {
            int status = 0;
            int v10 = __cxa_demangle(v8, 0LL, 0LL, &status);
            uint64_t v11 = v10;
            if (status)
            {
              std::string::size_type v12 = strlen(v9);
              std::string::append(&v18, v9, v12);
            }

            else
            {
              std::string::size_type v13 = strlen(v10);
              std::string::append(&v18, v11, v13);
            }

            std::string::append(&v18, " ", 1uLL);
            if (v11) {
              free(v11);
            }
          }

          else
          {
            std::string::append(&v18, " ", 1uLL);
          }
        }

        uint64_t v14 = (os_log_s *)secLogObjForScope("security_exception");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            CFTypeID v15 = &v18;
          }
          else {
            CFTypeID v15 = (std::string *)v18.__r_.__value_.__r.__words[0];
          }
          int status = 136315138;
          CFTypeID v20 = v15;
          _os_log_debug_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&status, 0xCu);
        }
      }

      int size = (char)v18.__r_.__value_.__s.__size_;
      free(v5);
      if (size < 0) {
        operator delete(v18.__r_.__value_.__l.__data_);
      }
    }
  }

void sub_18060F5E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

Security::UnixError *Security::UnixError::UnixError(Security::UnixError *this, int a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  *(_OWORD *)((char *)this + 72) = xmmword_18065986E;
  *(_OWORD *)((char *)this + 8_Block_object_dispose(va, 8) = unk_18065987E;
  *(_OWORD *)((char *)this + 104) = xmmword_18065988E;
  *(_OWORD *)((char *)this + 12syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = unk_18065989E;
  *(_OWORD *)((char *)this + _Block_object_dispose(va, 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18065983E;
  *(_OWORD *)((char *)this + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = xmmword_18065984E;
  *(_OWORD *)((char *)this + 56) = unk_18065985E;
  *((void *)this + 17) = 128LL;
  *(void ++*(void *)this = off_189676DF8;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((void *)this + 17), "UNIX error exception: %d", *((_DWORD *)this + 36));
  int v3 = (os_log_s *)secLogObjForScope("security_exception");
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(Security::UnixError *))(*(void *)this + 16LL))(this);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v8 = v5;
    _os_log_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
  }

  Security::CommonError::LogBacktrace((Security::CommonError *)v4);
  return this;
}

void sub_18060F734(_Unwind_Exception *a1)
{
}

void Security::UnixError::throwMe(Security::UnixError *this)
{
  int v1 = (int)this;
  exception = (Security::UnixError *)__cxa_allocate_exception(0x98uLL);
  Security::UnixError::UnixError(exception, v1);
}

void sub_18060F784(_Unwind_Exception *a1)
{
}

Security::MacOSError *Security::MacOSError::MacOSError(Security::MacOSError *this, int a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  *(_OWORD *)((char *)this + 72) = xmmword_18065986E;
  *(_OWORD *)((char *)this + 8_Block_object_dispose(va, 8) = unk_18065987E;
  *(_OWORD *)((char *)this + 104) = xmmword_18065988E;
  *(_OWORD *)((char *)this + 12syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = unk_18065989E;
  *(_OWORD *)((char *)this + _Block_object_dispose(va, 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18065983E;
  *(_OWORD *)((char *)this + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = xmmword_18065984E;
  *(_OWORD *)((char *)this + 56) = unk_18065985E;
  *((void *)this + 17) = 128LL;
  *(void ++*(void *)this = off_189676E30;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((void *)this + 17), "MacOS error: %d", *((_DWORD *)this + 36));
  if (a2 != -67050)
  {
    BOOL v4 = (os_log_s *)secLogObjForScope("security_exception");
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      uint64_t v6 = (*(uint64_t (**)(Security::MacOSError *))(*(void *)this + 16LL))(this);
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v9 = v6;
      _os_log_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }

    Security::CommonError::LogBacktrace((Security::CommonError *)v5);
  }

  return this;
}

void sub_18060F8D4(_Unwind_Exception *a1)
{
}

void Security::MacOSError::throwMe(Security::MacOSError *this)
{
  int v1 = (int)this;
  exception = (Security::MacOSError *)__cxa_allocate_exception(0x98uLL);
  Security::MacOSError::MacOSError(exception, v1);
}

void sub_18060F928(_Unwind_Exception *a1)
{
}

void Security::MacOSError::throwMe(Security::MacOSError *this, uint64_t a2, const char *a3, ...)
{
  int v3 = (int)this;
  exception = (Security::MacOSError *)__cxa_allocate_exception(0x98uLL);
  Security::MacOSError::MacOSError(exception, v3);
}

void sub_18060F978(_Unwind_Exception *a1)
{
}

Security::CFError *Security::CFError::CFError(Security::CFError *this)
{
  *(_OWORD *)((char *)this + 72) = xmmword_18065986E;
  *(_OWORD *)((char *)this + 8_Block_object_dispose(va, 8) = unk_18065987E;
  *(_OWORD *)((char *)this + 104) = xmmword_18065988E;
  *(_OWORD *)((char *)this + 12syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = unk_18065989E;
  *(_OWORD *)((char *)this + _Block_object_dispose(va, 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18065983E;
  *(_OWORD *)((char *)this + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = xmmword_18065984E;
  *(_OWORD *)((char *)this + 56) = unk_18065985E;
  *((void *)this + 17) = 128LL;
  *(void ++*(void *)this = off_189676E68;
  __int128 v2 = (os_log_s *)secLogObjForScope("security_exception");
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)BOOL v5 = 0;
    _os_log_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEFAULT, "CFError", v5, 2u);
  }

  Security::CommonError::LogBacktrace((Security::CommonError *)v3);
  return this;
}

void sub_18060FA4C(_Unwind_Exception *a1)
{
}

void Security::CFError::throwMe(Security::CFError *this)
{
  exception = (Security::CFError *)__cxa_allocate_exception(0x90uLL);
  Security::CFError::CFError(exception);
}

void sub_18060FA94(_Unwind_Exception *a1)
{
}

void Security::ModuleNexusError::throwMe(Security::ModuleNexusError *this)
{
  exception = (char *)__cxa_allocate_exception(0x90uLL);
  *(_OWORD *)(exception + 72) = xmmword_18065986E;
  *(_OWORD *)(exception + 8_Block_object_dispose(va, 8) = unk_18065987E;
  *(_OWORD *)(exception + 104) = xmmword_18065988E;
  *(_OWORD *)(exception + 12syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = unk_18065989E;
  *(_OWORD *)(exception + _Block_object_dispose(va, 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)(exception + 24) = unk_18065983E;
  *(_OWORD *)(exception + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = xmmword_18065984E;
  *(_OWORD *)(exception + 56) = unk_18065985E;
  *((void *)exception + 17) = 128LL;
  *(void *)exception = off_189676EB8;
}

void Security::UnixPlusPlus::FileDesc::open( Security::UnixPlusPlus::FileDesc *this, const char *a2, int a3, int a4)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v8 = open(a2, a3, a4 & 0xFFF);
  *(_DWORD ++*(void *)this = v8;
  if (v8 == -1)
  {
    uint64_t v11 = __error();
    if ((a4 & 0xF000) != 0x1000 || *v11 != 2)
    {
      std::string::size_type v12 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v12);
    }
  }

  else
  {
    *((_BYTE *)this + 4) = 0;
    uint64_t v9 = (os_log_s *)secLogObjForScope("unixio");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)this;
      *(_DWORD *)__int128 buf = 136315906;
      uint64_t v14 = a2;
      __int16 v15 = 1024;
      int v16 = a3;
      __int16 v17 = 1024;
      int v18 = a4;
      __int16 v19 = 1024;
      int v20 = v10;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "open(%s,0x%x,0x%x) = %d", buf, 0x1Eu);
    }
  }

void Security::UnixPlusPlus::FileDesc::close(Security::UnixPlusPlus::FileDesc *this)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)this;
  if ((v2 & 0x80000000) == 0)
  {
    if (close(v2) == -1)
    {
      BOOL v5 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v5);
    }

    BOOL v3 = (os_log_s *)secLogObjForScope("unixio");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)this;
      v6[0] = 67109120;
      v6[1] = v4;
      _os_log_debug_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEBUG, "close(%d)", (uint8_t *)v6, 8u);
    }

    *(_DWORD ++*(void *)this = -1;
  }

void Security::UnixPlusPlus::FileDesc::closeAndLog(Security::UnixPlusPlus::FileDesc *this)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)this;
  if ((v2 & 0x80000000) == 0)
  {
    int v3 = 0;
    int v4 = 2;
    while (close(v2) == -1 && v4)
    {
      int v3 = *__error();
      if ((v3 & 0xFFFFFFFE) == 4)
      {
        --v4;
      }

      else
      {
        BOOL v5 = (os_log_s *)secLogObjForScope("unixio");
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          int v6 = *(_DWORD *)this;
          *(_DWORD *)__int128 buf = 67109376;
          int v10 = v6;
          __int16 v11 = 1024;
          int v12 = v3;
          _os_log_debug_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEBUG, "close(%d) error %d", buf, 0xEu);
        }

        int v4 = 0;
      }

      int v2 = *(_DWORD *)this;
    }

    uint64_t v7 = (os_log_s *)secLogObjForScope("unixio");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *(_DWORD *)this;
      *(_DWORD *)__int128 buf = 67109376;
      int v10 = v8;
      __int16 v11 = 1024;
      int v12 = v3;
      _os_log_debug_impl(&dword_1804F4000, v7, OS_LOG_TYPE_DEBUG, "close(%d) err: %d", buf, 0xEu);
    }

    *(_DWORD ++*(void *)this = -1;
  }

ssize_t Security::UnixPlusPlus::FileDesc::read( Security::UnixPlusPlus::FileDesc *this, void *a2, size_t a3, off_t a4)
{
  ssize_t result = pread((int)this, a2, a3, a4);
  if (result == -1)
  {
    BOOL v5 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v5);
  }

  return result;
}

void *std::string::basic_string[abi:ne180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000LL;
    *__dst = v6;
  }

  else
  {
    *((_BYTE *)__dst + 23) = __len;
    int v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

ssize_t Security::UnixPlusPlus::FileDesc::writeAll(ssize_t this, char *__buf, size_t __nbyte)
{
  if (__nbyte)
  {
    size_t v3 = __nbyte;
    BOOL v5 = (int *)this;
    do
    {
      this = write(*v5, __buf, v3);
      if (this == -1)
      {
        if (*__error() != 35)
        {
          int v6 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v6);
        }

        this = 0LL;
      }

      __buf += this;
      v3 -= this;
    }

    while (v3);
  }

  return this;
}

off_t Security::UnixPlusPlus::FileDesc::seek(Security::UnixPlusPlus::FileDesc *this, off_t a2)
{
  off_t result = lseek((int)this, a2, 0);
  if (result == -1)
  {
    size_t v3 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v3);
  }

  return result;
}

uint64_t Security::UnixPlusPlus::FileDesc::fstat(Security::UnixPlusPlus::FileDesc *this, stat *a2)
{
  uint64_t result = fstat((int)this, a2);
  if ((_DWORD)result)
  {
    size_t v3 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v3);
  }

  return result;
}

float Security::UnixPlusPlus::FileDesc::fcntl(Security::UnixPlusPlus::FileDesc *this, int a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v4 = fcntl(*(_DWORD *)this, 48, a3, 1LL);
  BOOL v5 = (os_log_s *)secLogObjForScope("unixio");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(_DWORD *)this;
    *(_DWORD *)__int128 buf = 67109888;
    int v10 = v7;
    __int16 v11 = 1024;
    int v12 = 48;
    __int16 v13 = 2048;
    uint64_t v14 = 1LL;
    __int16 v15 = 1024;
    int v16 = v4;
    _os_log_debug_impl(&dword_1804F4000, v5, OS_LOG_TYPE_DEBUG, "%d fcntl(%d,%p) = %d", buf, 0x1Eu);
  }

  if (v4 == -1)
  {
    size_t v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }

  return result;
}

int *Security::UnixPlusPlus::FileDesc::removeAttr(Security::UnixPlusPlus::FileDesc *this, const char *a2)
{
  float result = (int *)fremovexattr((int)this, a2, 0);
  if ((_DWORD)result)
  {
    float result = __error();
    if (*result != 93)
    {
      size_t v3 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v3);
    }
  }

  return result;
}

ssize_t Security::UnixPlusPlus::FileDesc::listAttr( Security::UnixPlusPlus::FileDesc *this, char *a2, size_t a3)
{
  ssize_t result = flistxattr((int)this, a2, a3, 0);
  if (result == -1)
  {
    int v4 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v4);
  }

  return result;
}

BOOL Security::UnixPlusPlus::FileDesc::hasExtendedAttribute( Security::UnixPlusPlus::FileDesc *this, const char *a2)
{
  ssize_t v2 = fgetxattr((int)this, a2, 0LL, 0LL, 0, 0);
  if (v2 != -1) {
    return v2 != 0;
  }
  int v4 = __error();
  BOOL result = 0LL;
  int v5 = *v4;
  if (v5 != 1 && v5 != 93)
  {
    int v6 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v6);
  }

  return result;
}

const void **Security::UnixPlusPlus::FileDesc::mediumType( std::string *this, Security::UnixPlusPlus::FileDesc *a2)
{
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v19.st_blkint size = v3;
  *(timespec *)v19.st_qspare = v3;
  v19.st_birthtimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_int size = v3;
  v19.st_mtimespeCC_SHA512_CTX c = v3;
  v19.st_ctimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_uid = v3;
  v19.st_atimespeCC_SHA512_CTX c = v3;
  *(timespec *)&v19.st_dev = v3;
  Security::UnixPlusPlus::FileDesc::fstat(a2, &v19);
  CFDictionaryRef matching = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  Security::CFTemp<__CFDictionary const*>::CFTemp( (CFTypeRef *)&matching,  (uint64_t)"{%s=%d,%s=%d}",  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"BSD Major");
  mach_port_t v10 = *MEMORY[0x1896086A8];
  __int16 v11 = matching;
  CFDictionaryRef matching = 0LL;
  io_service_t MatchingService = IOServiceGetMatchingService(v10, v11);
  io_object_t v13 = MatchingService;
  if (!MatchingService)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
    unint64_t v17 = 0LL;
LABEL_6:
    this->__r_.__value_.__r.__words[0] = 0LL;
    this->__r_.__value_.__l.__size_ = 0LL;
    this->__r_.__value_.__l.__cap_ = 0LL;
    return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
  }

  uint64_t v14 = (const __CFDictionary *)IORegistryEntrySearchCFProperty( MatchingService,  "IOService",  @"Device Characteristics",  0LL,  3u);
  IOObjectRelease(v13);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
  unint64_t v17 = (unint64_t)v14;
  if (!v14) {
    goto LABEL_6;
  }
  unint64_t Value = (const __CFString *)CFDictionaryGetValue(v14, @"Medium Type");
  if (!Value) {
    goto LABEL_6;
  }
  Security::cfString(this, Value);
  return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
}

void sub_18061032C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

CFTypeRef *Security::CFTemp<__CFDictionary const*>::CFTemp( CFTypeRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *a1 = 0LL;
  int v12 = &a9;
  v13[0] = a2;
  v13[1] = &v12;
  void v13[2] = 0LL;
  int v14 = 0;
  CFDataRef v10 = Security::CFMake::make((Security::CFMake *)v13);
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = v10;
  return a1;
}

void sub_1806103AC(_Unwind_Exception *a1)
{
}

const void **Security::CFRef<__CFDictionary const*>::~CFRef(const void **a1)
{
  ssize_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

BOOL Security::Allocator::operator==(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void *DefaultAllocator::malloc(DefaultAllocator *this, size_t __size)
{
  BOOL result = malloc(__size);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v4 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v4, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  return result;
}

void DefaultAllocator::free(DefaultAllocator *this, void *a2)
{
}

void *DefaultAllocator::realloc(DefaultAllocator *this, void *__ptr, size_t __size)
{
  BOOL result = realloc(__ptr, __size);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x189614708], MEMORY[0x189614690]);
  }

  return result;
}

void SensitiveAllocator::free(SensitiveAllocator *this, void *ptr)
{
  size_t v3 = malloc_size(ptr);
  memset_s(ptr, v3, 0, v3);
  free(ptr);
}

void *SensitiveAllocator::realloc(SensitiveAllocator *this, char *ptr, size_t a3)
{
  size_t v5 = malloc_size(ptr);
  if (v5 > a3) {
    size_t v5 = memset_s(&ptr[a3], v5 - a3, 0, v5 - a3);
  }
  return DefaultAllocator::realloc((DefaultAllocator *)v5, ptr, a3);
}

uint64_t Security::Allocator::standard(Security::Allocator *this)
{
  if (!defaultAllocators) {
    defaultAllocators = Security::ModuleNexusCommon::create( (Security::ModuleNexusCommon *)&defaultAllocators,  (void *(*)(void))Security::ModuleNexus<DefaultAllocators>::make);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C533938);
  return defaultAllocators;
}

void sub_180610574(void *a1)
{
}

void sub_18061058C(_Unwind_Exception *a1)
{
}

void *Security::ModuleNexus<DefaultAllocators>::make()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = off_189676F18;
  result[1] = off_189676F70;
  return result;
}

uint64_t Security::CFClass::finalizeType(Security::CFClass *this, const void *a2)
{
  if (this) {
    ssize_t v2 = (char *)this + 24;
  }
  else {
    ssize_t v2 = 0LL;
  }
  size_t v3 = (pthread_mutex_t *)(*(uint64_t (**)(char *, const void *))(*(void *)v2 + 64LL))(v2, a2);
  if (!v3) {
    return (*(uint64_t (**)(char *))(*(void *)v2 + 56LL))(v2);
  }
  v7[0] = v3;
  v7[1] = 0xAAAAAAAAAAAAAA01LL;
  uint64_t v4 = (Security::UnixError *)pthread_mutex_lock(v3);
  if ((_DWORD)v4) {
    Security::UnixError::throwMe(v4);
  }
  size_t v5 = (unsigned __int8 *)(v2 - 8);
  do
    __ldaxr(v5);
  while (__stlxr(1u, v5));
  (*(void (**)(char *))(*(void *)v2 + 56LL))(v2);
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v7);
}

void sub_180610668( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Security::CFClass::equalType(Security::CFClass *this, char *a2, const void *a3)
{
  if (this) {
    size_t v3 = (char *)this + 24;
  }
  else {
    size_t v3 = 0LL;
  }
  if (a2) {
    uint64_t v4 = a2 + 24;
  }
  else {
    uint64_t v4 = 0LL;
  }
  return (*(uint64_t (**)(char *, char *, const void *))(*(void *)v3 + 24LL))(v3, v4, a3);
}

void sub_1806106C8(void *a1)
{
}

uint64_t Security::CFClass::hashType(Security::CFClass *this, const void *a2)
{
  if (this) {
    ssize_t v2 = (char *)this + 24;
  }
  else {
    ssize_t v2 = 0LL;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v2 + 32LL))(v2, a2);
}

void sub_180610704(void *a1)
{
}

uint64_t Security::CFClass::copyFormattingDescType( Security::CFClass *this, const void *a2, const __CFDictionary *a3)
{
  if (this) {
    size_t v3 = (char *)this + 24;
  }
  else {
    size_t v3 = 0LL;
  }
  return (*(uint64_t (**)(char *, const void *, const __CFDictionary *))(*(void *)v3 + 40LL))(v3, a2, a3);
}

void sub_180610740(void *a1)
{
}

uint64_t Security::CFClass::copyDebugDescType(Security::CFClass *this, const void *a2)
{
  if (this) {
    ssize_t v2 = (char *)this + 24;
  }
  else {
    ssize_t v2 = 0LL;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v2 + 48LL))(v2, a2);
}

void sub_180610780(void *a1)
{
}

uint64_t Security::CFClass::refCountForType(Security::CFClass *this, Security::CFClass *a2, const void *a3)
{
  char v13 = 0;
  if (a2) {
    size_t v5 = (char *)a2 + 24;
  }
  else {
    size_t v5 = 0LL;
  }
  uint64_t v6 = (pthread_mutex_t *)(*(uint64_t (**)(char *))(*(void *)v5 + 64LL))(v5);
  if (v6)
  {
    v12[0] = v6;
    v12[1] = 0xAAAAAAAAAAAAAA01LL;
    uint64_t v8 = (Security::UnixError *)pthread_mutex_lock(v6);
    if ((_DWORD)v8) {
      Security::UnixError::throwMe(v8);
    }
    uint64_t v10 = Security::CFClass::cleanupObject(this, a2, &v13, v9);
    Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v12);
  }

  else
  {
    uint64_t v10 = Security::CFClass::cleanupObject(this, a2, &v13, v7);
  }

  if (v13) {
    (*(void (**)(char *))(*(void *)v5 + 8LL))(v5);
  }
  return v10;
}

void sub_180610858(void *a1, uint64_t a2, ...)
{
}

uint64_t Security::CFClass::cleanupObject( Security::CFClass *this, Security::CFClass *a2, _BYTE *a3, BOOL *a4)
{
  *a3 = 0;
  if (a2) {
    uint64_t v7 = (os_unfair_lock_s *)((char *)a2 + 24);
  }
  else {
    uint64_t v7 = 0LL;
  }
  os_unfair_lock_lock(v7 + 3);
  uint32_t os_unfair_lock_opaque = v7[2]._os_unfair_lock_opaque;
  if (this == (Security::CFClass *)-1LL)
  {
    if (!os_unfair_lock_opaque)
    {
      os_unfair_lock_unlock(v7 + 3);
      goto LABEL_14;
    }

void Security::MachO::~MachO(void **this)
{
  *this = off_189676FC8;
  free(this[12]);
}

{
  *this = off_189676FC8;
  free(this[12]);
  operator delete(this);
}

Security::MainMachOImage *Security::MainMachOImage::MainMachOImage(Security::MainMachOImage *this)
{
  image_header = _dyld_get_image_header(0);
  *(void ++*(void *)this = off_189676FE8;
  Security::MachOBase::initHeader((uint64_t)this, image_header);
  uint64_t v3 = 32LL;
  if (!*((_BYTE *)this + 32)) {
    uint64_t v3 = 28LL;
  }
  Security::MachOBase::initCommands((uint64_t)this, (const load_command *)((char *)image_header + v3));
  *(void ++*(void *)this = off_189677008;
  return this;
}

uint64_t Security::MachOBase::initHeader(uint64_t this, const mach_header *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  *(void *)(this + _Block_object_dispose(va, 8) = a2;
  magiCC_SHA512_CTX c = a2->magic;
  if ((int)a2->magic > -17958195)
  {
    if (magic == -17958194)
    {
      char v3 = 0;
      char v4 = 0;
      goto LABEL_11;
    }

    if (magic == -17958193)
    {
      char v3 = 0;
      goto LABEL_8;
    }

uint64_t Security::MachOBase::initCommands(uint64_t this, const load_command *a2)
{
  LODWORD(v2) = *(_DWORD *)(*(void *)(this + 8) + 20LL);
  unsigned int v3 = bswap32(v2);
  if (*(_BYTE *)(this + 33)) {
    uint64_t v2 = v3;
  }
  else {
    uint64_t v2 = v2;
  }
  char v4 = (const load_command *)((char *)a2 + v2);
  *(void *)(this + 16) = a2;
  *(void *)(this + 24) = v4;
  if (&a2[1] > v4) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  return this;
}

void *Security::Architecture::displayName(Security::Architecture *this, cpu_type_t *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  char v4 = NXGetArchInfoFromCpuType(*a2, a2[1] & 0xFFFFFF);
  if (v4 && v4->name) {
    return std::string::basic_string[abi:ne180100]<0>(this, (char *)v4->name);
  }
  memset(__str, 170, 20);
  snprintf(__str, 0x14uLL, "(%d:%d)", *a2, a2[1] & 0xFFFFFF);
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

uint64_t Security::MachO::MachO(uint64_t a1, unsigned int *a2, off_t a3, uint64_t a4)
{
  off_t v4 = a3;
  uint64_t v50 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(a1 + 36) = *a2;
  *(_BYTE *)(a1 + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = *((_BYTE *)a2 + 4);
  *(void *)a1 = off_189676FC8;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a3;
  *(void *)(a1 + 56) = a4;
  *(_BYTE *)(a1 + 104) = 0;
  if (!a3)
  {
    v7.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
    v7.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v49.st_blkint size = v7;
    *(timespec *)v49.st_qspare = v7;
    v49.st_birthtimespeCC_SHA512_CTX c = v7;
    *(timespec *)&v49.st_int size = v7;
    v49.st_mtimespeCC_SHA512_CTX c = v7;
    v49.st_ctimespeCC_SHA512_CTX c = v7;
    *(timespec *)&v49.st_uid = v7;
    v49.st_atimespeCC_SHA512_CTX c = v7;
    *(timespec *)&v49.st_dev = v7;
    Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &v49);
    *(void *)(a1 + 56) = v49.st_size;
    off_t v4 = *(void *)(a1 + 48);
  }

  Security::MachOBase::initHeader(a1, (const mach_header *)(a1 + 64));
  unsigned int v8 = *(_DWORD *)(*(void *)(a1 + 8) + 20LL);
  unsigned int v9 = bswap32(v8);
  if (*(_BYTE *)(a1 + 33)) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = v8;
  }
  int v11 = malloc(v10);
  *(void *)(a1 + 96) = v11;
  if (!v11)
  {
    int v48 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v48);
  }

  uint64_t v12 = 32LL;
  if (!*(_BYTE *)(a1 + 32)) {
    uint64_t v12 = 28LL;
  }
  if (Security::UnixPlusPlus::FileDesc::read( (Security::UnixPlusPlus::FileDesc *)*a2,  v11,  v10,  v12 + *(void *)(a1 + 48)) != v10) {
    goto LABEL_65;
  }
  Security::MachOBase::initCommands(a1, *(const load_command **)(a1 + 96));
  if (!*(void *)(a1 + 56)) {
    return a1;
  }
  unint64_t Command = *(void *)(a1 + 16);
  if (!Command) {
    goto LABEL_57;
  }
  while (1)
  {
    unsigned int v14 = *(_DWORD *)Command;
    int v15 = *(unsigned __int8 *)(a1 + 33);
    unsigned int v16 = bswap32(*(_DWORD *)Command);
    if (*(_BYTE *)(a1 + 33)) {
      unsigned int v14 = v16;
    }
    if (v14 == 1) {
      break;
    }
    if (v14 == 25)
    {
      unsigned int v19 = *(_DWORD *)(Command + 4);
      unsigned int v20 = bswap32(v19);
      if (*(_BYTE *)(a1 + 33)) {
        unsigned int v19 = v20;
      }
      if (v19 <= 0x47) {
        goto LABEL_65;
      }
      unint64_t v38 = *(void *)(Command + 40);
      unint64_t v39 = *(void *)(Command + 48);
      unint64_t v40 = bswap64(v38);
      if (v15) {
        unint64_t v38 = v40;
      }
      unint64_t v41 = bswap64(v39);
      if (v15) {
        unint64_t v39 = v41;
      }
      unint64_t v42 = v39 + v38;
      uint64_t v43 = *(void *)(a1 + 56);
      BOOL v29 = v39 + v38 == v43;
      __int128 v44 = (os_log_s *)secLogObjForScope("macho");
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_56;
      }
      unint64_t v47 = " NOT";
      if (v42 == v43) {
        unint64_t v47 = (const char *)&unk_18065A197;
      }
      v49.st_dev = 136315138;
      *(void *)&v49.st_mode = v47;
      _os_log_debug_impl(&dword_1804F4000, v44, OS_LOG_TYPE_DEBUG, "64-bit linkedit is%s valid", (uint8_t *)&v49, 0xCu);
      if (v42 == v43) {
        return a1;
      }
      goto LABEL_57;
    }

    if (v14 == 2)
    {
      unsigned int v21 = *(_DWORD *)(Command + 4);
      unsigned int v22 = bswap32(v21);
      if (*(_BYTE *)(a1 + 33)) {
        unsigned int v21 = v22;
      }
      if (v21 > 0x17)
      {
        unsigned int v23 = *(_DWORD *)(Command + 16);
        unsigned int v24 = *(_DWORD *)(Command + 20);
        unsigned int v25 = bswap32(v23);
        if (*(_BYTE *)(a1 + 33)) {
          unsigned int v23 = v25;
        }
        unsigned int v26 = bswap32(v24);
        if (*(_BYTE *)(a1 + 33)) {
          unsigned int v24 = v26;
        }
        uint64_t v27 = v24 + v23;
        uint64_t v28 = *(void *)(a1 + 56);
        BOOL v29 = v28 == v27;
        __int128 v30 = (os_log_s *)secLogObjForScope("macho");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          __int128 v31 = " NOT";
          if (v28 == v27) {
            __int128 v31 = (const char *)&unk_18065A197;
          }
          v49.st_dev = 136315138;
          *(void *)&v49.st_mode = v31;
          __int128 v32 = "symtab is%s valid";
          goto LABEL_49;
        }

LABEL_65:
      Security::UnixError::throwMe((Security::UnixError *)8);
    }

unint64_t Security::MachOBase::nextCommand(Security::MachOBase *this, const load_command *a2)
{
  cmdint size = a2->cmdsize;
  int v3 = *((unsigned __int8 *)this + 33);
  unsigned int v4 = bswap32(cmdsize);
  if (*((_BYTE *)this + 33)) {
    cmdint size = v4;
  }
  if (!cmdsize) {
LABEL_10:
  }
    Security::UnixError::throwMe((Security::UnixError *)8);
  unint64_t result = (unint64_t)a2 + cmdsize;
  unint64_t v7 = *((void *)this + 3);
  if (v7 <= result) {
    return 0LL;
  }
  if (v7 < result + 8) {
    goto LABEL_10;
  }
  unsigned int v8 = *(_DWORD *)(result + 4);
  unsigned int v9 = bswap32(v8);
  uint64_t v10 = v3 ? v9 : v8;
  if (v7 < result + v10) {
    goto LABEL_10;
  }
  return result;
}

const load_command *Security::MachOBase::findCommand(Security::MachOBase *this, int a2)
{
  for (uint64_t i = (const load_command *)*((void *)this + 2);
        i;
        uint64_t i = (const load_command *)Security::MachOBase::nextCommand(this, i))
  {
    c__int128 md = i->cmd;
    unsigned int v6 = bswap32(i->cmd);
    if (*((_BYTE *)this + 33)) {
      c__int128 md = v6;
    }
    if (cmd == a2) {
      break;
    }
  }

  return i;
}

unint64_t Security::MachOBase::findSegment(Security::MachOBase *this, const char *a2)
{
  for (unint64_t i = *((void *)this + 2); i; unint64_t i = Security::MachOBase::nextCommand(this, (const load_command *)i))
  {
    unsigned int v4 = *(_DWORD *)i;
    unsigned int v5 = bswap32(*(_DWORD *)i);
    if (*((_BYTE *)this + 33)) {
      unsigned int v4 = v5;
    }
    if (v4 == 25 || v4 == 1)
    {
      unsigned int v7 = bswap32(*(_DWORD *)(i + 4));
      unsigned int v8 = *((_BYTE *)this + 33) ? v7 : *(_DWORD *)(i + 4);
      if (v8 <= 0x37) {
        Security::UnixError::throwMe((Security::UnixError *)8);
      }
    }
  }

  return i;
}

const load_command *Security::MachOBase::findCodeSignature(Security::MachOBase *this)
{
  unint64_t result = Security::MachOBase::findCommand(this, 29);
  if (result)
  {
    cmdint size = result->cmdsize;
    unsigned int v4 = bswap32(cmdsize);
    if (*((_BYTE *)this + 33)) {
      cmdint size = v4;
    }
    if (cmdsize <= 0xF) {
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
  }

  return result;
}

unint64_t Security::MachOBase::version( Security::MachOBase *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  unint64_t Command = (const load_command *)*((void *)this + 2);
  if (Command)
  {
    do
    {
      c__int128 md = Command->cmd;
      int v10 = *((unsigned __int8 *)this + 33);
      unsigned int v11 = bswap32(Command->cmd);
      if (*((_BYTE *)this + 33)) {
        c__int128 md = v11;
      }
      if (cmd == 50)
      {
        cmdint size = Command->cmdsize;
        unsigned int v18 = bswap32(cmdsize);
        if (*((_BYTE *)this + 33)) {
          cmdint size = v18;
        }
        if (cmdsize <= 0x17) {
          goto LABEL_56;
        }
        if (a2)
        {
          unsigned int v19 = Command[1].cmd;
          unsigned int v20 = bswap32(v19);
          if (*((_BYTE *)this + 33)) {
            unsigned int v19 = v20;
          }
          *a2 = v19;
        }

        if (a3)
        {
          unsigned int v21 = Command[1].cmdsize;
          unsigned int v22 = bswap32(v21);
          if (v10) {
            unsigned int v21 = v22;
          }
          *a3 = v21;
        }

        if (a4)
        {
          unsigned int v23 = Command[2].cmd;
          goto LABEL_51;
        }

        return 1LL;
      }

      unint64_t Command = (const load_command *)Security::MachOBase::nextCommand(this, Command);
    }

    while (Command);
    uint64_t v12 = (const load_command *)*((void *)this + 2);
    if (v12)
    {
      while (1)
      {
        int v13 = v12->cmd;
        int v10 = *((unsigned __int8 *)this + 33);
        unsigned int v14 = bswap32(v12->cmd);
        if (*((_BYTE *)this + 33)) {
          int v13 = v14;
        }
        unint64_t result = Security::MachOBase::nextCommand(this, v12);
        uint64_t v12 = (const load_command *)result;
        if (!result) {
          return result;
        }
      }

      unsigned int v24 = v12->cmdsize;
      unsigned int v25 = bswap32(v24);
      if (*((_BYTE *)this + 33)) {
        unsigned int v24 = v25;
      }
      if (v24 > 0xF)
      {
        if (v13 > 46)
        {
          if (v13 == 47)
          {
            unsigned int v26 = 3;
          }

          else
          {
            if (v13 != 48) {
              goto LABEL_42;
            }
            unsigned int v26 = 4;
          }
        }

        else if (v13 == 36)
        {
          unsigned int v26 = 1;
        }

        else
        {
          if (v13 == 37)
          {
            unsigned int v26 = 2;
            goto LABEL_43;
          }

uint64_t Security::MachO::signingExtent(Security::MachO *this)
{
  CodeCFDataRef Signature = Security::MachOBase::findCodeSignature(this);
  if (!CodeSignature) {
    return *((void *)this + 7);
  }
  c__int128 md = CodeSignature[1].cmd;
  unsigned int v4 = bswap32(cmd);
  uint64_t result = *((_BYTE *)this + 33) ? v4 : cmd;
  if (!(_DWORD)result) {
    return *((void *)this + 7);
  }
  return result;
}

CFDataRef Security::MachO::dataAt(Security::MachO *this, uint64_t a2, size_t __size)
{
  v9[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  v9[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  Security::CFMallocData::CFMallocData((Security::CFMallocData *)v9, __size);
  if (Security::UnixPlusPlus::FileDesc::read( (Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 9),  v9[0],  __size,  *((void *)this + 6) + a2) != __size)
  {
    unsigned int v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }

  CFDataRef v6 = Security::CFMallocData::operator __CFData const*((uint64_t)v9);
  if (v9[0]) {
    free(v9[0]);
  }
  return v6;
}

void sub_180611534( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  if (a9) {
    free(a9);
  }
  _Unwind_Resume(exception_object);
}

Security::CFMallocData *Security::CFMallocData::CFMallocData(Security::CFMallocData *this, size_t __size)
{
  unsigned int v4 = malloc(__size);
  *(void ++*(void *)this = v4;
  *((void *)this + 1) = __size;
  if (!v4)
  {
    CFDataRef v6 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v6);
  }

  return this;
}

uint64_t *std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>( uint64_t **a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  unsigned int v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      unsigned int v7 = *a2;
      if ((*(unsigned int (**)(void))(*(void *)a4 + 16LL))())
      {
        uint64_t v8 = *v7;
        *(void *)(v8 + _Block_object_dispose(va, 8) = v7[1];
        *(void *)v7[1] = v8;
        unsigned int v9 = *v4;
        v9[1] = (uint64_t)v7;
        *unsigned int v7 = (uint64_t)v9;
        *unsigned int v4 = v7;
        v7[1] = (uint64_t)v4;
        return v7;
      }
    }

    else
    {
      unint64_t v11 = a3 >> 1;
      unint64_t v12 = (a3 >> 1) + 1;
      int v13 = a1;
      do
      {
        int v13 = (uint64_t **)v13[1];
        --v12;
      }

      while (v12 > 1);
      unsigned int v14 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>( a1,  v13,  a3 >> 1,  a4);
      unsigned int v4 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>( v13,  a2,  a3 - v11,  a4);
      if ((*(unsigned int (**)(void))(*(void *)a4 + 16LL))())
      {
        for (unint64_t i = v4[1]; i != (uint64_t *)a2; unint64_t i = (uint64_t *)i[1])
        {
        }

        unint64_t i = (uint64_t *)a2;
LABEL_14:
        uint64_t v17 = *i;
        unsigned int v18 = *v4;
        v18[1] = *(void *)(*i + 8);
        **(void **)(v17 + _Block_object_dispose(va, 8) = v18;
        unsigned int v19 = *v14;
        unsigned int v16 = v14[1];
        v19[1] = (uint64_t)v4;
        *unsigned int v4 = v19;
        *unsigned int v14 = (uint64_t *)v17;
        *(void *)(v17 + _Block_object_dispose(va, 8) = v14;
      }

      else
      {
        unsigned int v16 = v14[1];
        unint64_t i = (uint64_t *)v4;
        unsigned int v4 = v14;
      }

      if (v16 != i && i != (uint64_t *)a2)
      {
        unsigned int v20 = i;
        do
        {
          if ((*(unsigned int (**)(void))(*(void *)a4 + 16LL))())
          {
            for (CFIndex j = (uint64_t *)i[1]; j != (uint64_t *)a2; CFIndex j = (uint64_t *)j[1])
            {
            }

            CFIndex j = (uint64_t *)a2;
LABEL_25:
            uint64_t v23 = *j;
            uint64_t v24 = *i;
            *(void *)(v24 + _Block_object_dispose(va, 8) = *(void *)(*j + 8);
            **(void **)(v23 + _Block_object_dispose(va, 8) = v24;
            if (v20 == i) {
              unsigned int v20 = j;
            }
            uint64_t v25 = *v16;
            unsigned int v22 = (uint64_t *)v16[1];
            *(void *)(v25 + _Block_object_dispose(va, 8) = i;
            *unint64_t i = v25;
            *unsigned int v16 = v23;
            *(void *)(v23 + _Block_object_dispose(va, 8) = v16;
            unint64_t i = j;
          }

          else
          {
            unsigned int v22 = (uint64_t *)v16[1];
          }

          BOOL v26 = v22 == v20 || i == (uint64_t *)a2;
          unsigned int v16 = v22;
        }

        while (!v26);
      }
    }
  }

  return (uint64_t *)v4;
}

void *std::__list_imp<fat_arch *>::clear(void *result)
{
  if (result[2])
  {
    int v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + _Block_object_dispose(va, 8) = *(void *)(*v1 + 8LL);
    **(void **)(v2 + _Block_object_dispose(va, 8) = v3;
    v1[2] = 0LL;
    if (result != v1)
    {
      do
      {
        unsigned int v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }

      while (v4 != v1);
    }
  }

  return result;
}

void std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy( void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a1[1]);
    operator delete(a1);
  }

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>( uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      unsigned int v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), unsigned int v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unsigned int v9 = (uint64_t **)a2[2];
          }

          else
          {
            unsigned int v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              _OWORD v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }

            int v9[2] = v3;
            *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = v9;
            uint64_t *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }

      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), unsigned int v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }

          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        void v3[2] = (uint64_t)v2;
        return result;
      }

      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *unsigned int v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

BOOL ___ZN8Security9UniversalC2ENS_12UnixPlusPlus8FileDescEmm_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8);
}

uint64_t Security::Universal::Universal(uint64_t a1, unsigned int *a2, off_t a3, uint64_t a4)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  *(_DWORD *)a1 = *a2;
  *(_BYTE *)(a1 + 4) = *((_BYTE *)a2 + 4);
  *(_DWORD *)(a1 + 2syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = a4;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  int64_t v70 = (void *)(a1 + 56);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a1 + 56;
  *(_DWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 76) = 0;
  memset(v75, 170, 28);
  if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v75, 0x1CuLL, a3) != 28) {
    goto LABEL_87;
  }
  if (v75[0].i32[0] <= -805638659)
  {
    if (v75[0].i32[0] != -1095041334 && v75[0].i32[0] != -889275714)
    {
      int v6 = -822415874;
      goto LABEL_24;
    }

    unsigned int v10 = bswap32(v75[0].u32[1]);
    *(_DWORD *)(a1 + 16) = v10;
    if (v10 > 0x64) {
      goto LABEL_87;
    }
    size_t v11 = 20LL * (v10 + 1);
    uint64_t v12 = malloc(v11);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v12;
    if (v12)
    {
      ssize_t v13 = Security::UnixPlusPlus::FileDesc::read( (Security::UnixPlusPlus::FileDesc *)*a2,  v12,  v11,  *(void *)(a1 + 32) + 8LL);
      unsigned int v14 = *(char **)(a1 + 8);
      if (v13 == v11)
      {
        int v15 = *(int8x16_t **)(a1 + 8);
        do
        {
          *int v15 = vrev32q_s8(*v15);
          v15[1].i32[0] = bswap32(v15[1].u32[0]);
          int v16 = *(_DWORD *)(a1 + 16);
          uint64_t v17 = (int8x16_t *)&v14[20 * v16];
          int v15 = (int8x16_t *)((char *)v15 + 20);
        }

        while (v15 <= v17);
        if (v17->i32[0] == 16777228) {
          *(_DWORD *)(a1 + 16) = v16 + 1;
        }
        unsigned int v18 = (os_log_s *)secLogObjForScope("macho");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          int v66 = *(_DWORD *)(a1 + 16);
          buf.st_dev = 134218240;
          *(void *)&buf.st_mode = a1;
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = v66;
          _os_log_debug_impl( &dword_1804F4000,  v18,  OS_LOG_TYPE_DEBUG,  "%p is a fat file with %d architectures",  (uint8_t *)&buf,  0x12u);
        }

        unsigned int v19 = &v72;
        CFNumberRef v72 = (uint64_t *)&v72;
        uint64_t v73 = &v72;
        unint64_t v74 = 0LL;
        uint64_t v20 = *(unsigned int *)(a1 + 16);
        if ((_DWORD)v20)
        {
          unint64_t v21 = 0LL;
          uint64_t v22 = *(void *)(a1 + 8);
          uint64_t v23 = &v72;
          do
          {
            uint64_t v24 = (uint64_t *)operator new(0x18uLL);
            v24[1] = (uint64_t)&v72;
            v24[2] = v22;
            uint64_t *v24 = (uint64_t)v23;
            v23[1] = v24;
            ++v21;
            v22 += 20LL;
            uint64_t v23 = (uint64_t **)v24;
            CFNumberRef v72 = v24;
            unint64_t v74 = v21;
          }

          while (v20 != v21);
          unsigned int v19 = v73;
        }

        else
        {
          unint64_t v21 = 0LL;
        }

        *(void *)&buf.st_dev = &__block_literal_global_13970;
        std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>( v19,  &v72,  v21,  (uint64_t)&buf);
        BOOL v26 = v73;
        if (v73 == &v72)
        {
          uint64_t v28 = 0LL;
          uint64_t v27 = 0LL;
LABEL_71:
          if (!*(_BYTE *)(a1 + 76))
          {
            v57.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
            v57.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&buf.st_blkint size = v57;
            *(timespec *)buf.st_qspare = v57;
            buf.st_birthtimespeCC_SHA512_CTX c = v57;
            *(timespec *)&buf.st_int size = v57;
            buf.st_mtimespeCC_SHA512_CTX c = v57;
            buf.st_ctimespeCC_SHA512_CTX c = v57;
            *(timespec *)&buf.st_uid = v57;
            buf.st_atimespeCC_SHA512_CTX c = v57;
            *(timespec *)&buf.st_dev = v57;
            Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &buf);
            if (v27 + v28 != buf.st_size)
            {
              size_t v58 = (os_log_s *)secLogObjForScope("SecError");
              if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
              {
                v59.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
                v59.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
                *(timespec *)&buf.st_blkint size = v59;
                *(timespec *)buf.st_qspare = v59;
                buf.st_birthtimespeCC_SHA512_CTX c = v59;
                *(timespec *)&buf.st_int size = v59;
                buf.st_mtimespeCC_SHA512_CTX c = v59;
                buf.st_ctimespeCC_SHA512_CTX c = v59;
                *(timespec *)&buf.st_uid = v59;
                buf.st_atimespeCC_SHA512_CTX c = v59;
                *(timespec *)&buf.st_dev = v59;
                Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &buf);
                int v76 = 134218240;
                uint64_t v77 = v27 + v28;
                __int16 v78 = 2048;
                st_int size = buf.st_size;
                __int128 v60 = "STRICT VALIDATION ERROR: Extra data after the last slice in a universal file (expected %zu found %zu)";
                p_stat buf = (stat *)&v76;
                uint64_t v62 = v58;
                uint32_t v63 = 22;
                goto LABEL_77;
              }

LABEL_78:
              *(_BYTE *)(a1 + 76) = 1;
            }
          }

          std::__list_imp<fat_arch *>::clear(&v72);
          return a1;
        }

        uint64_t v27 = 0LL;
        uint64_t v28 = 0LL;
        uint64_t v29 = *(void *)(a1 + 32) + 20LL * *(unsigned int *)(a1 + 16) + 8;
        uint64_t v69 = v29;
        while (1)
        {
          uint64_t v30 = v26[2][1];
          *(void *)&__int128 v31 = v30;
          *((void *)&v31 + 1) = HIDWORD(v30);
          __int128 v71 = v31;
          __int128 v32 = v70;
          unsigned int v33 = (void *)*v70;
          unsigned int v34 = v70;
          if (*v70)
          {
            do
            {
              while (1)
              {
                __int128 v32 = v33;
                unint64_t v35 = v33[4];
                unsigned int v33 = (void *)*v32;
                unsigned int v34 = v32;
                if (!*v32) {
                  goto LABEL_38;
                }
              }

              if (v35 >= (unint64_t)v71)
              {
                free(*(void **)(a1 + 8));
                CFNumberRef v67 = (os_log_s *)secLogObjForScope("SecError");
                if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.st_dev) = 0;
                  _os_log_impl( &dword_1804F4000,  v67,  OS_LOG_TYPE_DEFAULT,  "Error processing fat file: Two architectures have the same size",  (uint8_t *)&buf,  2u);
                }

                Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9LL);
              }

              unsigned int v33 = (void *)v32[1];
            }

            while (v33);
            unsigned int v34 = v32 + 1;
          }

void sub_18061222C(_Unwind_Exception *a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void *Security::Universal::architecture(off_t *this)
{
  if (this[1])
  {
    uint64_t v2 = (const Security::Architecture *)Security::Universal::bestNativeArch((Security::Universal *)this);
    return Security::Universal::findImage((Security::Universal **)this, v2, SHIDWORD(v2));
  }

  else
  {
    unsigned int v4 = operator new(0x70uLL);
    unsigned int v5 = *(_DWORD *)this;
    char v6 = *((_BYTE *)this + 4);
    Security::MachO::MachO((uint64_t)v4, &v5, this[4], this[5]);
    return v4;
  }

void sub_180612310(_Unwind_Exception *a1)
{
}

unint64_t Security::Universal::bestNativeArch(Security::Universal *this)
{
  if (*((void *)this + 1))
  {
    Security::MainMachOImage::MainMachOImage((Security::MainMachOImage *)v11);
    unsigned int v2 = *(_DWORD *)(v12 + 8);
    unsigned int v3 = bswap32(*(_DWORD *)(v12 + 4));
    if (v13) {
      cpu_type_t v4 = v3;
    }
    else {
      cpu_type_t v4 = *(_DWORD *)(v12 + 4);
    }
    unsigned int v5 = bswap32(v2);
    if (v13) {
      unsigned int v2 = v5;
    }
    char v6 = NXFindBestFatArch(v4, v2 & 0xFFFFFF, *((fat_arch **)this + 1), *((_DWORD *)this + 4));
    if (v6)
    {
      unsigned int cputype = v6->cputype;
      uint64_t cpusubtype = v6->cpusubtype;
    }

    else
    {
      unsigned int v9 = (unsigned int *)*((void *)this + 1);
      unsigned int cputype = *v9;
      uint64_t cpusubtype = v9[1];
    }
  }

  else
  {
    unsigned int cputype = *((_DWORD *)this + 5);
    uint64_t cpusubtype = *((unsigned int *)this + 6);
  }

  return cputype | (unint64_t)(cpusubtype << 32);
}

void *Security::Universal::findImage(Security::Universal **this, const Security::Architecture *a2, int a3)
{
  Arch = Security::Universal::findArch( this[1],  (const Security::Architecture *)*((unsigned int *)this + 4),  (int)a2,  a3);
  unsigned int v5 = operator new(0x70uLL);
  unsigned int v10 = *(_DWORD *)this;
  char v11 = *((_BYTE *)this + 4);
  Security::MachO::MachO((uint64_t)v5, &v10, (off_t)this[4] + *((unsigned int *)Arch + 2), *((unsigned int *)Arch + 3));
  unsigned int v6 = *(_DWORD *)(v5[1] + 12LL);
  unsigned int v7 = bswap32(v6);
  if (*((_BYTE *)v5 + 33)) {
    unsigned int v6 = v7;
  }
  if (!v6 || (int v8 = *((_DWORD *)this + 18)) != 0 && v8 != v6) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  *((_DWORD *)this + 1_Block_object_dispose(va, 8) = v6;
  return v5;
}

void sub_180612460(_Unwind_Exception *a1)
{
}

Security::Universal *Security::Universal::findArch( Security::Universal *this, const Security::Architecture *a2, int a3, int a4)
{
  if (!(_DWORD)a2) {
LABEL_19:
  }
    Security::UnixError::throwMe((Security::UnixError *)8);
  cpu_type_t v4 = (Security::Universal *)((char *)this + 20 * a2);
  unsigned int v5 = this;
  while (*(_DWORD *)v5 != a3 || *((_DWORD *)v5 + 1) != a4)
  {
    unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
    if (v5 >= v4)
    {
      unsigned int v5 = this;
      while (*(_DWORD *)v5 != a3 || ((*((_DWORD *)v5 + 1) ^ a4) & 0xFFFFFF) != 0)
      {
        unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
        if (v5 >= v4)
        {
          unsigned int v5 = this;
          while (*(_DWORD *)v5 != a3 || (*((_DWORD *)v5 + 1) & 0xFFFFFF) != 0)
          {
            unsigned int v5 = (Security::Universal *)((char *)v5 + 20);
            if (v5 >= v4)
            {
              while (*(_DWORD *)this != a3)
              {
                this = (Security::Universal *)((char *)this + 20);
                if (this >= v4) {
                  goto LABEL_19;
                }
              }

              return this;
            }
          }

          return v5;
        }
      }

      return v5;
    }
  }

  return v5;
}

uint64_t Security::Universal::archOffset(Security::Universal *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (*((void *)this + 1))
  {
    unint64_t v3 = Security::Universal::bestNativeArch(this);
    v1 += *((unsigned int *)Security::Universal::findArch( *((Security::Universal **)this + 1),  (const Security::Architecture *)*((unsigned int *)this + 4),  v3,  SHIDWORD(v3))
          + 2);
  }

  return v1;
}

void *Security::Universal::architecture( Security::Universal *this, const Security::Architecture *a2, int a3)
{
  if (*((void *)this + 1)) {
    return Security::Universal::findImage((Security::Universal **)this, a2, a3);
  }
  if (*((_DWORD *)this + 5) != (_DWORD)a2 || a3 != -1 && ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) != 0) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  unsigned int v5 = operator new(0x70uLL);
  unsigned int v6 = *(_DWORD *)this;
  char v7 = *((_BYTE *)this + 4);
  Security::MachO::MachO((uint64_t)v5, &v6, *((void *)this + 4), *((void *)this + 5));
  return v5;
}

void sub_180612634(_Unwind_Exception *a1)
{
}

uint64_t Security::Universal::archOffset(Security::Universal *this, const Security::Architecture *a2, int a3)
{
  if (*((void *)this + 1))
  {
    uint64_t v3 = *((void *)this + 4);
    return v3
         + *((unsigned int *)Security::Universal::findArch( *((Security::Universal **)this + 1),  (const Security::Architecture *)*((unsigned int *)this + 4),  (int)a2,  a3)
           + 2);
  }

  else
  {
    if (*((_DWORD *)this + 5) != (_DWORD)a2 || a3 != -1 && ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) != 0) {
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
    return 0LL;
  }

uint64_t *Security::Universal::architectures(uint64_t *this, uint64_t *a2)
{
  uint64_t v3 = this;
  if (this[1])
  {
    if (*((_DWORD *)this + 4))
    {
      uint64_t v4 = 0LL;
      unint64_t v5 = 0LL;
      do
      {
        this = std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>( a2,  *(void *)(v3[1] + v4),  *(void *)(v3[1] + v4));
        ++v5;
        v4 += 20LL;
      }

      while (v5 < *((unsigned int *)v3 + 4));
    }
  }

  else
  {
    unsigned int v6 = Security::Universal::architecture(this);
    uint64_t v7 = v6[1];
    unsigned int v8 = *(_DWORD *)(v7 + 4);
    LODWORD(v7) = *(_DWORD *)(v7 + 8);
    unsigned int v9 = bswap32(v8);
    if (*((_BYTE *)v6 + 33)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v8;
    }
    unsigned int v11 = bswap32(v7);
    if (*((_BYTE *)v6 + 33)) {
      uint64_t v7 = v11;
    }
    else {
      uint64_t v7 = v7;
    }
    std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>( a2,  v10 | (v7 << 32),  v10 | (v7 << 32));
    return (uint64_t *)(*(uint64_t (**)(void *))(*v6 + 8LL))(v6);
  }

  return this;
}

void sub_18061277C(_Unwind_Exception *a1)
{
}

uint64_t *std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>( uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  unsigned int v6 = result + 1;
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v6 = (uint64_t *)v5;
        int v7 = *(_DWORD *)(v5 + 28);
        int v8 = *((_DWORD *)v6 + 8);
        BOOL v9 = SHIDWORD(a2) < v8;
        if ((_DWORD)a2 != v7) {
          BOOL v9 = (int)a2 < v7;
        }
        if (!v9) {
          break;
        }
        uint64_t v5 = *v6;
        uint64_t v10 = (uint64_t **)v6;
        if (!*v6) {
          goto LABEL_14;
        }
      }

      BOOL v11 = v8 < SHIDWORD(a2);
      int v12 = (_DWORD)a2 == v7 ? v11 : v7 < (int)a2;
      if (v12 != 1) {
        break;
      }
      uint64_t v10 = (uint64_t **)(v6 + 1);
      uint64_t v5 = v6[1];
      if (!v5) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    uint64_t v10 = (uint64_t **)(result + 1);
LABEL_14:
    char v13 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v13 + 2_Block_object_dispose(va, 8) = a3;
    *char v13 = 0LL;
    v13[1] = 0LL;
    void v13[2] = (uint64_t)v6;
    *uint64_t v10 = v13;
    uint64_t v14 = *(void *)*v4;
    if (v14)
    {
      *uint64_t v4 = v14;
      int v15 = *v10;
    }

    else
    {
      int v15 = v13;
    }

    uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v15);
    ++v4[2];
  }

  return result;
}

void Security::Bundle::~Bundle(Security::Bundle *this)
{
}

{
  const void *v2;
  *(void ++*(void *)this = off_1896770F0;
  unsigned int v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
}

void Security::Bundle::canonicalPath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 39) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 2), *((void *)this + 3));
  }

  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 1);
    a2->__r_.__value_.__l.__cap_ = *((void *)this + 4);
  }

void Security::Bundle::executablePath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = (char *)this + 40;
  if (*((char *)this + 63) < 0)
  {
    std::string::size_type v5 = *((void *)this + 6);
    if (v5)
    {
      std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v4, v5);
      return;
    }
  }

  else if (*((_BYTE *)this + 63))
  {
LABEL_9:
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v4;
    a2->__r_.__value_.__l.__cap_ = *((void *)v4 + 2);
    return;
  }

  unsigned int v6 = (__CFBundle *)Security::Bundle::cfBundle(this);
  int v7 = CFBundleCopyExecutableURL(v6);
  Security::cfStringRelease((Security *)__p, v7);
  *((void *)v4 + 2) = v9;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)__p;
  HIBYTE(v9) = 0;
  LOBYTE(__p[0]) = 0;
  std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 5), *((void *)this + 6));
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1806129A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

SecStaticCodeRef Security::OSXCode::codeRef(Security::OSXCode *this)
{
  staticint64_t Code = (SecStaticCodeRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(*(void *)this + 16LL))(__p);
  if (v6 >= 0) {
    unsigned int v2 = __p;
  }
  else {
    unsigned int v2 = (void **)__p[0];
  }
  CFURL = Security::makeCFURL((Security *)v2, 0LL, 0LL, v1);
  uint64_t v3 = (Security::MacOSError *)SecStaticCodeCreateWithPath(CFURL, 0, &staticCode);
  if ((_DWORD)v3) {
    Security::MacOSError::throwMe(v3);
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return staticCode;
}

void sub_180612A54( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Security::Bundle::lookupSymbol(Security::Bundle *this, const char *a2)
{
  CFStringRef functionName = CFStringCreateWithCString(0LL, a2, 0);
  if (!functionName) {
    Security::UnixError::throwMe((Security::UnixError *)0x55);
  }
  uint64_t v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  FunctionPointerForName = CFBundleGetFunctionPointerForName(v3, functionName);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&functionName);
  return FunctionPointerForName;
}

void sub_180612AF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t Security::Bundle::cfBundle(Security::Bundle *this)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t result = *((void *)this + 8);
  if (!result)
  {
    uint64_t v3 = (os_log_s *)secLogObjForScope("bundle");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v7 = (void *)((char *)this + 16);
      *(_DWORD *)int v8 = 136315138;
      *(void *)&void v8[4] = v7;
      _os_log_debug_impl(&dword_1804F4000, v3, OS_LOG_TYPE_DEBUG, "instantiating CFBundle for %s", v8, 0xCu);
    }

    if (*((char *)this + 39) < 0)
    {
      uint64_t v4 = (const UInt8 *)*((void *)this + 2);
      CFIndex v5 = *((void *)this + 3);
    }

    else
    {
      uint64_t v4 = (const UInt8 *)this + 16;
      CFIndex v5 = *((unsigned __int8 *)this + 39);
    }

    char v6 = CFURLCreateFromFileSystemRepresentation(0LL, v4, v5, 1u);
    *(void *)int v8 = v6;
    if (!v6 || (char v6 = CFBundleCreate(0LL, v6), (*((void *)this + 8) = v6) == 0LL)) {
      Security::CFError::throwMe(v6);
    }
    Security::CFRef<__CFURL const*>::~CFRef((const void **)v8);
    return *((void *)this + 8);
  }

  return result;
}

void sub_180612C1C(_Unwind_Exception *exception_object)
{
}

void std::string::__init_copy_ctor_external( std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  CFIndex v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8LL) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__l.__cap_ = v7 | 0x8000000000000000LL;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    CFIndex v5 = v8;
  }

  else
  {
    this->__r_.__value_.__s.__size_ = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void Security::LoadableBundle::~LoadableBundle(Security::LoadableBundle *this)
{
}

BOOL Security::LoadableBundle::isLoaded(Security::LoadableBundle *this)
{
  uint64_t v1 = (__CFBundle *)Security::Bundle::cfBundle(this);
  return CFBundleIsExecutableLoaded(v1) != 0;
}

void Security::LoadableBundle::load(Security::LoadableBundle *this)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  unsigned int v2 = (__CFBundle *)Security::Bundle::cfBundle(this);
  Executable = (Security::CFError *)CFBundleLoadExecutable(v2);
  if (!(_DWORD)Executable) {
    Security::CFError::throwMe(Executable);
  }
  uint64_t v4 = (os_log_s *)secLogObjForScope("bundle");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    else {
      std::string __p = *(std::string *)((char *)this + 16);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)stat buf = 134218242;
    int v8 = this;
    __int16 v9 = 2080;
    uint64_t v10 = p_p;
    _os_log_debug_impl(&dword_1804F4000, v4, OS_LOG_TYPE_DEBUG, "%p (%s) loaded", buf, 0x16u);
  }

void Security::LoadableBundle::unload(Security::LoadableBundle *this)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  unsigned int v2 = (os_log_s *)secLogObjForScope("bundle");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    else {
      std::string __p = *(std::string *)((char *)this + 16);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)stat buf = 134218242;
    std::string::size_type v7 = this;
    __int16 v8 = 2080;
    __int16 v9 = p_p;
    _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "%p (%s) unloaded", buf, 0x16u);
  }

  uint64_t v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  CFBundleUnloadExecutable(v3);
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_189661D38, (void (*)(void *))MEMORY[0x189614200]);
}

void sub_180612FC8(_Unwind_Exception *a1)
{
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x189614780] + 16LL);
  return result;
}

const void **Security::CFRef<__CFArray const*>::~CFRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t Security::ModuleNexusCommon::create(Security::ModuleNexusCommon *this, void *(*a2)(void))
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v3 = (dispatch_once_t *)((char *)this + 8);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  _DWORD v6[2] = ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke;
  void v6[3] = &__block_descriptor_tmp_13993;
  void v6[4] = this;
  void v6[5] = a2;
  if (v4 != -1) {
    dispatch_once(v3, v6);
  }
  uint64_t result = *(void *)this;
  if (!*(void *)this) {
    Security::ModuleNexusError::throwMe(0LL);
  }
  return result;
}

uint64_t ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t result = (*(uint64_t (**)(void))(a1 + 40))();
  *uint64_t v1 = result;
  return result;
}

void sub_1806130CC(void *a1)
{
  *uint64_t v1 = 0LL;
  __cxa_end_catch();
}

void Security::CodeSigning::DetachedRep::~DetachedRep(Security::CodeSigning::DetachedRep *this)
{
  *(void ++*(void *)this = off_1896771A8;
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(void ++*(void *)this = off_1896772D8;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((void *)this + 2);
  Security::CodeSigning::DiskRep::~DiskRep(this);
}

{
  void *v2;
  *(void ++*(void *)this = off_1896771A8;
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(void ++*(void *)this = off_1896772D8;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((void *)this + 2);
  Security::CodeSigning::DiskRep::~DiskRep(this);
  operator delete(v2);
}

uint64_t Security::CodeSigning::FilterRep::base(Security::CodeSigning::FilterRep *this)
{
  return *((void *)this + 2);
}

CFDataRef Security::CodeSigning::DetachedRep::component( Security::CodeSigning::EmbeddedSignatureBlob **this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  CFDataRef result = Security::CodeSigning::EmbeddedSignatureBlob::component(this[14], a2, a3);
  if (!result)
  {
    std::string::size_type v7 = this[15];
    if (!v7 || (CFDataRef result = Security::CodeSigning::EmbeddedSignatureBlob::component(v7, a2, v6)) == 0LL)
    {
      uint64_t v8 = (*((uint64_t (**)(Security::CodeSigning::EmbeddedSignatureBlob **))*this + 2))(this);
      return (CFDataRef)(*(uint64_t (**)(uint64_t, Security::CodeSigning::EmbeddedSignatureBlob *))(*(void *)v8 + 24LL))( v8,  a2);
    }
  }

  return result;
}

uint64_t Security::CodeSigning::FilterRep::identification(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 32LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::mainExecutablePath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 40LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::copyCanonicalPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 48LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::resourcesRootPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 56LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::adjustResources(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 64LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::mainExecutableImage(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 80LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::signingBase(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 88LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::signingLimit(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 96LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 104LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 112LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::DiskRep::platformType()
{
  return 0LL;
}

uint64_t Security::CodeSigning::FilterRep::format(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 128LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::modifiedFiles(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 136LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::fd(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 144LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::flush(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 152LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::recommendedIdentifier(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 184LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::defaultResourceRules(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 200LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 208LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 216LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::strictValidate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 224LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::strictValidateStructure(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 232LL))(*(void *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::allowedResourceOmissions(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 240LL))(*((void *)this + 2));
}

uint64_t Security::CodeSigning::DiskRep::appleInternalForcePlatform(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

void *Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(void *a1)
{
  unsigned int v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01LL;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    uint64_t v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1 = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void *Security::CFCopyRef<__CFData const*>::CFCopyRef(void *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

void sub_180613444(_Unwind_Exception *a1)
{
}

_DWORD *Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(_DWORD *result)
{
  if (result)
  {
    if (*result == -1072898310
      && (v1 = bswap32(result[2]), unint64_t v2 = 8LL * v1 + 12, v3 = bswap32(result[1]), v2 <= v3))
    {
      unint64_t v5 = (unint64_t)&result[2 * v1 + 3];
      while (1)
      {
        v5 -= 8LL;
        unsigned int v6 = *(_DWORD *)(v5 + 4);
        if (v6)
        {
          unint64_t v7 = bswap32(v6);
          BOOL v8 = v2 > v7 || v7 + 8 > v3;
        }
      }
    }

    else
    {
      uint64_t v4 = __error();
      CFDataRef result = 0LL;
      *uint64_t v4 = 22;
    }
  }

  return result;
}

uint64_t Security::SuperBlobCore<Security::SuperBlob<4208856257u,unsigned int>,4208856257u,unsigned int>::find( uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  LODWORD(v4) = bswap32(v2);
  uint64_t v4 = v4 <= 1 ? 1LL : v4;
  unint64_t v5 = (unsigned int *)(a1 + 12);
  while (1)
  {
    unsigned int v6 = *v5;
    v5 += 2;
    if (bswap32(v6) == a2) {
      break;
    }
    if (v4 == ++v3) {
      return 0LL;
    }
  }

  unsigned int v7 = *(_DWORD *)(a1 + 8 * v3 + 16);
  if (v7) {
    return bswap32(v7) + a1;
  }
  else {
    return 0LL;
  }
}

void Security::CodeSigning::DYLDCacheRep::~DYLDCacheRep(void **this)
{
  *this = off_1896773F0;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

{
  void *v2;
  *this = off_1896773F0;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
  operator delete(v2);
}

Security::CodeSigning::EmbeddedSignatureBlob *Security::CodeSigning::DYLDCacheRep::component( Security::CodeSigning::DYLDCacheRep *this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  CFDataRef result = (Security::CodeSigning::EmbeddedSignatureBlob *)*((void *)this + 15);
  if (result) {
    return Security::CodeSigning::EmbeddedSignatureBlob::component(result, a2, a3);
  }
  return result;
}

uint64_t Security::CodeSigning::DYLDCacheRep::signingLimit(Security::CodeSigning::DYLDCacheRep *this)
{
  return *((void *)this + 13);
}

void *Security::CodeSigning::DYLDCacheRep::format@<X0>( Security::CodeSigning::DYLDCacheRep *this@<X0>, void *a2@<X8>)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = NXGetArchInfoFromCpuType(**((_DWORD **)this + 11), *(_DWORD *)(*((void *)this + 11) + 4LL) & 0xFFFFFF);
  if (!v4) {
    return std::string::basic_string[abi:ne180100]<0>(a2, "OS X Shared Library Cache (unknown type)");
  }
  __darwin_ino64_t name = v4->name;
  if (!v4->name) {
    return std::string::basic_string[abi:ne180100]<0>(a2, "OS X Shared Library Cache (unknown type)");
  }
  int v16 = -1431655766;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v14 = v6;
  __int128 v15 = v6;
  __int128 v12 = v6;
  __int128 v13 = v6;
  *(_OWORD *)std::string __str = v6;
  __int128 v11 = v6;
  unint64_t v7 = *(void *)(*((void *)this + 10) + 32LL);
  unint64_t v8 = bswap64(v7);
  if (*((_BYTE *)this + 96)) {
    unint64_t v7 = v8;
  }
  snprintf(__str, 0x64uLL, "OS X Shared Library Cache (%s @ 0x%llx)", name, v7);
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

uint64_t Security::CodeSigning::DYLDCacheRep::pageSize()
{
  return 4096LL;
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::DYLDCacheRep::writer( Security::CodeSigning::DYLDCacheRep *this)
{
  unsigned int v2 = (Security::CodeSigning::SingleDiskRep::Writer *)operator new(0x90uLL);
  Security::CodeSigning::SingleDiskRep::Writer::Writer(v2, this, 2);
  *((void *)v2 + 14) = 0LL;
  *((void *)v2 + 13) = (char *)v2 + 112;
  *(void *)unsigned int v2 = off_189677508;
  *((void *)v2 + 15) = 0LL;
  *((void *)v2 + 16) = this;
  *((void *)v2 + 17) = 0LL;
  return v2;
}

void sub_180613784(_Unwind_Exception *a1)
{
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::SingleDiskRep::Writer::Writer( Security::CodeSigning::SingleDiskRep::Writer *this, Security::CodeSigning::SingleDiskRep *a2, int a3)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)((char *)this + 12) = -1LL;
  *((_DWORD *)this + 5) = a3;
  *(void ++*(void *)this = off_189678DC8;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 32));
  if (a2)
  {
    unint64_t v5 = (unsigned int *)((char *)a2 + 8);
    do
      unsigned int v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  *((void *)this + 3) = a2;
  *((_DWORD *)this + 24) = -1;
  *((_BYTE *)this + 10syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0;
  return this;
}

void Security::CodeSigning::DYLDCacheRep::Writer::~Writer(Security::CodeSigning::DYLDCacheRep::Writer *this)
{
  *(void ++*(void *)this = off_189678DC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);
}

{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104);
  *(void ++*(void *)this = off_189678DC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);
  operator delete(this);
}

void Security::CodeSigning::DYLDCacheRep::Writer::component( uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
}

void Security::CodeSigning::DYLDCacheRep::Writer::addDiscretionary(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 128);
  unsigned int v5 = *(_DWORD *)(*(void *)(v4 + 80) + 20LL);
  unsigned int v6 = bswap32(v5);
  if (*(_BYTE *)(v4 + 96)) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  size_t v8 = 24LL * (v7 + 1);
  *(void *)(a2 + 16syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = v8;
  __int16 v9 = (char *)realloc(*(void **)(a2 + 152), v8);
  *(void *)(a2 + 152) = v9;
  if (!v9) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  uint64_t v10 = v9;
  bzero(v9, *(void *)(a2 + 160));
  if ((_DWORD)v7)
  {
    uint64_t v11 = *(void *)(a1 + 128);
    unint64_t v12 = *(void *)(v11 + 72);
    int v13 = *(unsigned __int8 *)(v11 + 96);
    unsigned int v14 = bswap32(*(_DWORD *)(*(void *)(v11 + 80) + 16LL));
    if (!*(_BYTE *)(v11 + 96)) {
      unsigned int v14 = *(_DWORD *)(*(void *)(v11 + 80) + 16LL);
    }
    int32x2_t v15 = vdup_n_s32(*(_BYTE *)(v11 + 96) == 0);
    int v16 = v10 + 8;
    v17.i64[0] = v15.u32[0];
    v17.i64[1] = v15.u32[1];
    int8x16_t v18 = (int8x16_t)vcltzq_s64(vshlq_n_s64(v17, 0x3FuLL));
    do
    {
      uint64_t v19 = *(void *)(v11 + 64) + v14;
      unint64_t v20 = *(void *)v19;
      unint64_t v21 = bswap64(*(void *)v19);
      if (v13) {
        unint64_t v20 = v21;
      }
      *int v16 = bswap64(v20);
      int64x2_t v22 = (int64x2_t)vbslq_s8(v18, *(int8x16_t *)(v19 + 8), vrev64q_s8(*(int8x16_t *)(v19 + 8)));
      *(v16 - 1) = vrev32_s8((int8x8_t)vshrn_n_s64(v22, 0xCuLL));
      int v23 = *(_DWORD *)(v19 + 24);
      if (v13) {
        LOBYTE(v23) = HIBYTE(v23);
      }
      if ((v23 & 4) != 0)
      {
        *(int8x16_t *)(a2 + 16_Block_object_dispose(va, 8) = vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL);
        *(void *)(a2 + 184) = 0LL;
      }

      v16 += 3;
      v14 += 32;
      --v7;
    }

    while (v7);
  }

ssize_t Security::CodeSigning::DYLDCacheRep::Writer::flush( Security::CodeSigning::DYLDCacheRep::Writer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9 = (void *)*((void *)this + 17);
  if (v9) {
    operator delete(v9);
  }
  *((void *)this + 17) = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make( (uint64_t)this + 104,  a2,  a3,  a4,  a5,  a6,  a7,  a8);
  uint64_t v10 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::seek( (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v10,  *(void *)(*((void *)this + 16) + 104LL));
  uint64_t v11 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  return Security::UnixPlusPlus::FileDesc::writeAll( (ssize_t)v11,  *((char **)this + 17),  bswap32(*(_DWORD *)(*((void *)this + 17) + 4LL)));
}

_DWORD *Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  int v9 = *(_DWORD *)(a1 + 16);
  __int128 v33 = 0uLL;
  *(void *)&__int128 v34 = 0LL;
  unsigned int v10 = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size( (void *)a1,  (uint64_t **)&v33,  0LL,  a4,  a5,  a6,  a7,  a8,  v30);
  uint64_t v11 = malloc(v10);
  if (!v11) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  unint64_t v12 = v11;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  _DWORD *v11 = -1072898310;
  v11[1] = bswap32(v10);
  _OWORD v11[2] = bswap32(v13);
  unsigned int v14 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    int v15 = 0;
    unsigned int v16 = 8 * v9 + 12;
    do
    {
      int64x2_t v17 = &v12[2 * v15];
      unint64_t v17[3] = bswap32(*((_DWORD *)v14 + 8));
      v17[4] = bswap32(v16);
      memcpy((char *)v12 + v16, (const void *)v14[5], bswap32(*(_DWORD *)(v14[5] + 4LL)));
      int8x16_t v18 = (void *)v14[1];
      uint64_t v19 = v14;
      if (v18)
      {
        do
        {
          unint64_t v20 = v18;
          int8x16_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          unint64_t v20 = (void *)v19[2];
          BOOL v21 = *v20 == (void)v19;
          uint64_t v19 = v20;
        }

        while (!v21);
      }

      v16 += bswap32(*(_DWORD *)(v14[5] + 4LL));
      ++v15;
      unsigned int v14 = v20;
    }

    while (v20 != (void *)(a1 + 8));
  }

  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v22;
  v40[8] = v22;
  v40[5] = v22;
  v40[6] = v22;
  v40[3] = v22;
  v40[4] = v22;
  v40[1] = v22;
  v40[2] = v22;
  v40[0] = v22;
  __int128 v38 = v22;
  __int128 v39 = v22;
  __int128 v36 = v22;
  *(_OWORD *)std::string __p = v22;
  __int128 v34 = v22;
  __int128 v35 = v22;
  __int128 v33 = v22;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v33);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, (uint64_t)"Maker ", 6LL);
  int v23 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" assembles ", 11LL);
  uint64_t v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" blob(s) into ", 14LL);
  uint64_t v25 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" (size=", 7LL);
  BOOL v26 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)")", 1LL);
  uint64_t v27 = (os_log_s *)secLogObjForScope("superblob");
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&v33 + 8);
    uint64_t v29 = v32 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)stat buf = 136315138;
    uint64_t v43 = v29;
    _os_log_debug_impl(&dword_1804F4000, v27, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v32 < 0) {
      operator delete(__dst[0]);
    }
  }

  *(void *)&__int128 v33 = *MEMORY[0x189614738];
  *(void *)((char *)&v33 + *(void *)(v33 - 24)) = *(void *)(MEMORY[0x189614738] + 24LL);
  *((void *)&v33 + 1) = MEMORY[0x189614750] + 16LL;
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](v40);
  return v12;
}

void sub_180613D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size( void *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = (void *)*a1;
  if ((void *)*a1 == a1 + 1)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = 0LL;
    do
    {
      uint64_t v11 = (void *)v9[1];
      unint64_t v12 = v9;
      if (v11)
      {
        do
        {
          unsigned int v13 = v11;
          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unint64_t v12 = v13;
        }

        while (!v14);
      }

      v10 += bswap32(*(_DWORD *)(v9[5] + 4LL));
      int v9 = v13;
    }

    while (v13 != a1 + 1);
  }

  int v15 = a2[1];
  if (*a2 != v15)
  {
    unsigned int v16 = *a2;
    do
    {
      uint64_t v17 = *v16++;
      v10 += v17;
    }

    while (v16 != v15);
  }

  uint64_t v18 = a1[2] + v15 - *a2;
  if (a3)
  {
    BOOL v21 = &a9;
    do
    {
      ++v18;
      v10 += a3;
      uint64_t v19 = (uint64_t *)v21;
      v21 += 8;
      a3 = *v19;
    }

    while (*v19);
  }

  return v10 + 8 * v18 + 12;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x189614768];
  uint64_t v3 = MEMORY[0x189614768] + 64LL;
  *(void *)(a1 + 112) = MEMORY[0x189614768] + 64LL;
  uint64_t v4 = *(void *)(MEMORY[0x189614738] + 8LL);
  uint64_t v5 = *(void *)(MEMORY[0x189614738] + 16LL);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v5;
  unsigned int v6 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0LL;
  v6[1].__fmtflags_ = -1;
  *(void *)a1 = v2 + 24;
  *(void *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + _Block_object_dispose(va, 8) = MEMORY[0x189614750] + 16LL;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104) = 16;
  return a1;
}

void sub_180613ED0(_Unwind_Exception *a1)
{
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( void *a1, uint64_t a2, uint64_t a3)
{
  v23[0] = 0xAAAAAAAAAAAAAAAALL;
  v23[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x186DFE980](v23, a1);
  if (LOBYTE(v23[0]))
  {
    unsigned int v6 = (char *)a1 + *(void *)(*a1 - 24LL);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      uint64_t v10 = std::locale::use_facet(__b, MEMORY[0x189614558]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32LL);
      std::locale::~locale(__b);
      *((_DWORD *)v6 + 36) = v9;
    }

    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_29;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    size_t v16 = v14 ? 0LL : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96LL))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }

    if ((uint64_t)v16 >= 1)
    {
      memset(__b, 170, sizeof(__b));
      if (v16 >= 0x7FFFFFFFFFFFFFF8LL) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v16 >= 0x17)
      {
        uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v16 | 7) != 0x17) {
          uint64_t v18 = v16 | 7;
        }
        uint64_t v19 = v18 + 1;
        uint64_t v17 = (std::locale::__imp *)operator new(v18 + 1);
        __b[1].__locale_ = (std::locale::__imp *)v16;
        __b[2].__locale_ = (std::locale::__imp *)(v19 | 0x8000000000000000LL);
        __b[0].__locale_ = v17;
      }

      else
      {
        HIBYTE(__b[2].__locale_) = v16;
        uint64_t v17 = (std::locale::__imp *)__b;
      }

      memset(v17, v9, v16);
      *((_BYTE *)v17 + v16) = 0;
      unint64_t v20 = SHIBYTE(__b[2].__locale_) >= 0 ? __b : (std::locale *)__b[0].__locale_;
      uint64_t v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(void *)v7 + 96LL))(v7, v20, v16);
      if (SHIBYTE(__b[2].__locale_) < 0) {
        operator delete(__b[0].__locale_);
      }
      if (v21 != v16) {
        goto LABEL_29;
      }
    }

    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96LL))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((void *)v6 + 3) = 0LL;
    }

    else
    {
LABEL_29:
      std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | 5);
    }
  }

  MEMORY[0x186DFE98C](v23);
  return a1;
}

void sub_18061412C( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x186DFE98C](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24LL)));
  __cxa_end_catch();
  JUMPOUT(0x180614100LL);
}

void sub_18061418C(_Unwind_Exception *a1)
{
}

void *std::stringbuf::str[abi:ne180100]<std::allocator<char>>(void *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 88);
    unint64_t v6 = *(void *)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 8_Block_object_dispose(va, 8) = v6;
      unint64_t v5 = v6;
    }

    uint64_t v7 = (const void **)(a2 + 40);
  }

  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0LL;
      *((_BYTE *)__dst + 23) = 0;
      goto LABEL_16;
    }

    uint64_t v7 = (const void **)(a2 + 16);
    unint64_t v5 = *(void *)(a2 + 32);
  }

  int v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000LL;
    *uint64_t v2 = v11;
    uint64_t v2 = v11;
  }

  else
  {
    *((_BYTE *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }

  __dst = memmove(v2, v8, v4);
LABEL_16:
  *((_BYTE *)v2 + v4) = 0;
  return __dst;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)a1 = *MEMORY[0x189614738];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + _Block_object_dispose(va, 8) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](a1 + 112);
  return a1;
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker( uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      free((void *)v3[5]);
      size_t v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          unint64_t v5 = v4;
          size_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          unint64_t v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }

        while (!v6);
      }

      uint64_t v3 = v5;
    }

    while (v5 != v2);
  }

  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)(a1 + 8));
  return a1;
}

void *Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(void *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01LL;
  uint64_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    size_t v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1 = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::CodeSigning::DirScanner::DirScanner(uint64_t a1, const std::string *a2)
{
  *(_BYTE *)(a1 + 108syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::string::operator=((std::string *)a1, a2);
  if (*(void *)(a1 + 24)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9LL);
  }
  *__error() = 0;
  uint64_t v3 = (const char *)a1;
  size_t v4 = opendir(v3);
  *(void *)(a1 + 24) = v4;
  if (v4)
  {
    char v5 = 1;
  }

  else
  {
    if (*__error() != 2)
    {
      uint64_t v7 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v7);
    }

    char v5 = 0;
  }

  *(_BYTE *)(a1 + 108syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = v5;
  return a1;
}

void sub_1806144B4(_Unwind_Exception *exception_object)
{
}

void Security::CodeSigning::DirScanner::~DirScanner(Security::CodeSigning::DirScanner *this)
{
  uint64_t v2 = (DIR *)*((void *)this + 3);
  if (v2) {
    closedir(v2);
  }
}

dirent *Security::CodeSigning::DirScanner::getNext(DIR **this)
{
  unsigned int v6 = (dirent *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = (dirent *)(this + 4);
  do
  {
    uint64_t v3 = (Security::UnixError *)readdir_r(this[3], v2, &v6);
    if ((_DWORD)v3) {
      Security::UnixError::throwMe(v3);
    }
    size_t v4 = v6;
  }

  while (v6 && (!strcmp(v6->d_name, ".") || !strcmp(v4->d_name, "..")));
  return v4;
}

BOOL Security::CodeSigning::DirScanner::isRegularFile(Security::CodeSigning::DirScanner *this, dirent *a2)
{
  if (a2->d_type) {
    return a2->d_type == 8;
  }
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v18.st_blkint size = v5;
  *(timespec *)v18.st_qspare = v5;
  v18.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_int size = v5;
  v18.st_mtimespeCC_SHA512_CTX c = v5;
  v18.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_uid = v5;
  v18.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v18.st_dev = v5;
  else {
    size_t v6 = *((void *)this + 1);
  }
  memset(&v15, 170, sizeof(v15));
  uint64_t v7 = &v15;
  std::string::basic_string[abi:ne180100]((uint64_t)&v15, v6 + 1);
  if ((v15.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    uint64_t v7 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    else {
      int v8 = *(Security::CodeSigning::DirScanner **)this;
    }
    memmove(v7, v8, v6);
  }

  *(_WORD *)((char *)&v7->__r_.__value_.__l.__data_ + v6) = 47;
  d___darwin_ino64_t name = a2->d_name;
  std::string::size_type v10 = strlen(d_name);
  uint64_t v11 = std::string::append(&v15, d_name, v10);
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t cap = v11->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = (void **)__p[0];
  }
  BOOL v14 = (Security::MacOSError *)stat((const char *)v13, &v18);
  if ((_DWORD)v14) {
    Security::MacOSError::throwMe(v14);
  }
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return (v18.st_mode & 0xF000) == 0x8000;
}

void sub_180614708( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::DirValidator::~DirValidator(uint64_t **this)
{
  uint64_t v3 = *this;
  uint64_t v2 = this[1];
  if (*this != v2)
  {
    do
    {
      uint64_t v4 = *v3;
      if (*v3)
      {
        timespec v5 = *(const void **)(v4 + 64);
        if (v5) {
          _Block_release(v5);
        }
        Security::CodeSigning::ResourceBuilder::Rule::~Rule((void **)v4);
        operator delete(v6);
        uint64_t v2 = this[1];
      }

      ++v3;
    }

    while (v3 != v2);
    uint64_t v3 = *this;
  }

  if (v3)
  {
    this[1] = v3;
    operator delete(v3);
  }

void Security::CodeSigning::DirValidator::validate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __b[129] = *(char **)MEMORY[0x1895F89C0];
  __int128 v55 = 0LL;
  uint64_t v56 = 0LL;
  __int128 v54 = &v55;
  else {
    timespec v5 = *(char **)a2;
  }
  __b[0] = v5;
  __b[1] = 0LL;
  size_t v6 = fts_open(__b, 21, 0LL);
  if (!v6)
  {
    stat v49 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v49);
  }

  while (1)
  {
    uint64_t v7 = fts_read(v6);
    int v8 = v7;
    if (!v7) {
      break;
    }
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    if ((v9 & 0x80u) != 0LL) {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    std::string::size_type v10 = &v7->fts_path[v9 + 1];
    int v11 = v7->fts_statp->st_mode & 0x49;
    fts_unint64_t info = v7->fts_info;
    if (fts_info > 7)
    {
      if (fts_info == 12)
      {
        uint64_t v29 = (os_log_s *)secLogObjForScope("dirval");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          fts_path = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = fts_path;
          _os_log_debug_impl(&dword_1804F4000, v29, OS_LOG_TYPE_DEBUG, "symlink %s", (uint8_t *)__b, 0xCu);
        }

        memset(__b, 170, 0x400uLL);
        ssize_t v30 = readlink(v8->fts_accpath, (char *)__b, 0x3FFuLL);
        if (v30 < 0)
        {
          uint64_t v44 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v44);
        }

        *((_BYTE *)__b + v3syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0;
        stat v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 4, v11 != 0, (char *)__b);
      }

      else
      {
        if (fts_info != 8)
        {
LABEL_64:
          uint64_t v45 = (os_log_s *)secLogObjForScope("dirval");
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            int v46 = v8->fts_info;
            int fts_errno = v8->fts_errno;
            ssize_t v48 = v8->fts_path;
            LODWORD(__b[0]) = 67109634;
            HIDWORD(__b[0]) = v46;
            LOWORD(__b[1]) = 1024;
            *(_DWORD *)((char *)&__b[1] + 2) = fts_errno;
            HIWORD(__b[1]) = 2080;
            __b[2] = v48;
            _os_log_debug_impl( &dword_1804F4000,  v45,  OS_LOG_TYPE_DEBUG,  "type %d (errno %d): %s",  (uint8_t *)__b,  0x18u);
          }

          Security::MacOSError::throwMe((Security::MacOSError *)a3);
        }

        uint64_t v17 = (os_log_s *)secLogObjForScope("dirval");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          __int128 v36 = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = v36;
          _os_log_debug_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEBUG, "file %s", (uint8_t *)__b, 0xCu);
        }

        stat v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 1, v11 != 0, 0LL);
      }

      __int128 v22 = v18;
      if (v18) {
        goto LABEL_24;
      }
LABEL_41:
      if (v8->fts_info != 8
        || (*(char *)(a2 + 23) >= 0 ? (__int128 v31 = (Security::CodeSigning *)a2) : (__int128 v31 = *(Security::CodeSigning **)a2),
            !Security::CodeSigning::pathFileSystemUsesXattrFiles(v31, v19)))
      {
LABEL_62:
        Security::MacOSError::throwMe((Security::MacOSError *)a3);
      }

      std::string::basic_string[abi:ne180100]<0>(&__p, v8->fts_path);
      int IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile(&__p, "csutilities");
      char v33 = IsValidXattrFile;
      if ((char)__p.__r_.__value_.__s.__size_ < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((v33 & 1) == 0) {
          goto LABEL_62;
        }
      }

      else if (!IsValidXattrFile)
      {
        goto LABEL_62;
      }

      __int128 v34 = (os_log_s *)secLogObjForScope("dirval");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        __int128 v35 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v35;
        std::string v15 = v34;
        size_t v16 = "skipping file due to xattr: %s";
LABEL_52:
        _os_log_debug_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEBUG, v16, (uint8_t *)__b, 0xCu);
      }
    }

    else if (fts_info == 1)
    {
      unint64_t v20 = (os_log_s *)secLogObjForScope("dirval");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v37 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v37;
        _os_log_debug_impl(&dword_1804F4000, v20, OS_LOG_TYPE_DEBUG, "entering %s", (uint8_t *)__b, 0xCu);
      }

      if (v8->fts_level)
      {
        uint64_t v21 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 2, v11 != 0, 0LL);
        __int128 v22 = v21;
        if (v21)
        {
          int v23 = *(&v21[1].re_magic + 1);
          if ((v23 & 0x20) != 0) {
            goto LABEL_25;
          }
        }

        fts_set(v6, v8, 4);
        if (!v22) {
          goto LABEL_41;
        }
LABEL_24:
        int v23 = *(&v22[1].re_magic + 1);
LABEL_25:
        if ((v23 & 0x10) != 0)
        {
          uint64_t v24 = v55;
          uint64_t v25 = &v55;
          BOOL v26 = &v55;
          if (v55)
          {
            while (1)
            {
              while (1)
              {
                BOOL v26 = (uint64_t **)v24;
                unint64_t v27 = v24[4];
                uint64_t v24 = *v26;
                uint64_t v25 = v26;
                if (!*v26) {
                  goto LABEL_33;
                }
              }

              uint64_t v24 = v26[1];
              if (!v24)
              {
                uint64_t v25 = v26 + 1;
                goto LABEL_33;
              }
            }
          }

          else
          {
LABEL_33:
            uint64_t v28 = (uint64_t *)operator new(0x28uLL);
            v28[4] = (uint64_t)v22;
            uint64_t *v28 = 0LL;
            v28[1] = 0LL;
            void v28[2] = (uint64_t)v26;
            void *v25 = v28;
            if (*v54)
            {
              __int128 v54 = (uint64_t **)*v54;
              uint64_t v28 = *v25;
            }

            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v55, v28);
            ++v56;
          }
        }
      }
    }

    else
    {
      if (fts_info != 6) {
        goto LABEL_64;
      }
      uint64_t v13 = (os_log_s *)secLogObjForScope("dirval");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        BOOL v14 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v14;
        std::string v15 = v13;
        size_t v16 = "leaving %s";
        goto LABEL_52;
      }
    }
  }

  if (v56 != *(_DWORD *)(a1 + 24))
  {
    __b[32] = (char *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__b[28] = v39;
    *(_OWORD *)&__b[30] = v39;
    *(_OWORD *)&__b[24] = v39;
    *(_OWORD *)&__b[26] = v39;
    *(_OWORD *)&__b[20] = v39;
    *(_OWORD *)&__b[22] = v39;
    *(_OWORD *)&__b[16] = v39;
    *(_OWORD *)&__b[18] = v39;
    *(_OWORD *)&__b[12] = v39;
    *(_OWORD *)&__b[14] = v39;
    *(_OWORD *)&__b[8] = v39;
    *(_OWORD *)&__b[10] = v39;
    *(_OWORD *)&__b[6] = v39;
    *(_OWORD *)&__b[2] = v39;
    *(_OWORD *)&__b[4] = v39;
    *(_OWORD *)__b = v39;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__b);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__b, (uint64_t)"matched ", 8LL);
    unint64_t v40 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" of ", 4LL);
    unint64_t v41 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" required rules", 15LL);
    unint64_t v42 = (os_log_s *)secLogObjForScope("dirval");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&__b[1]);
      uint64_t v43 = v52 >= 0 ? __dst : (void **)__dst[0];
      *(_DWORD *)stat buf = 136315138;
      size_t v58 = v43;
      _os_log_debug_impl(&dword_1804F4000, v42, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      if (v52 < 0) {
        operator delete(__dst[0]);
      }
    }

    Security::MacOSError::throwMe((Security::MacOSError *)a3);
  }

  fts_close(v6);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v55);
}

void sub_180614DFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, void *__p, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, uint64_t a44, uint64_t a45)
{
  a28 = *MEMORY[0x189614738];
  *(uint64_t *)((char *)&a28 + *(void *)(a28 - 24)) = *(void *)(MEMORY[0x189614738] + 24LL);
  a29 = MEMORY[0x189614750] + 16LL;
  if (a42 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](&a45);
  fts_close(v45);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a24);
  _Unwind_Resume(a1);
}

const regex_t *Security::CodeSigning::DirValidator::match( const regex_t ***this, char *a2, int a3, char a4, char *a5)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  timespec v5 = *this;
  if (*this != this[1])
  {
    while (1)
    {
      int v11 = *v5;
      int v12 = *(&(*v5)[1].re_magic + 1);
      if ((v12 & a3) != 0 && ((v12 & 8) == 0 || (a4 & 1) == 0))
      {
      }

void sub_180615184( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::DirValidator::Rule::Rule(uint64_t a1, __int128 *a2, int a3, const void *a4)
{
  *(void *)&Security::CodeSigning::ResourceBuilder::Rule::Rule((regex_t *)a1, a2, 0, a3)[2].re_magiCC_SHA512_CTX c = 0LL;
  if (a4) {
    *(void *)(a1 + 64) = _Block_copy(a4);
  }
  return a1;
}

void sub_180615224(_Unwind_Exception *a1)
{
}

void Security::CodeSigning::registerStapledTicketWithSystem(Security::CodeSigning *this, const __CFData *a2)
{
  if (this)
  {
    uint64_t v2 = (os_log_s *)secLogObjForScope("notarization");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_debug_impl(&dword_1804F4000, v2, OS_LOG_TYPE_DEBUG, "Registering stapled ticket with system", v3, 2u);
    }
  }

const void **Security::CFRef<__CFError *>::~CFRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t SecCodeSignerGetTypeID()
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 408);
}

void sub_1806152EC(void *a1)
{
}

uint64_t Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()()
{
  if (!Security::CodeSigning::gCFObjects) {
    Security::CodeSigning::gCFObjects = Security::ModuleNexusCommon::create( (Security::ModuleNexusCommon *)&Security::CodeSigning::gCFObjects,  (void *(*)(void))Security::ModuleNexus<Security::CodeSigning::CFObjects>::make);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C533298);
  return Security::CodeSigning::gCFObjects;
}

void sub_180615358(void *a1)
{
}

void sub_180615370(_Unwind_Exception *a1)
{
}

void *Security::ModuleNexus<Security::CodeSigning::CFObjects>::make()
{
  int v0 = operator new(0x210uLL);
  v0[2] = 0LL;
  v0[3] = 0LL;
  v0[4] = Security::CFClass::finalizeType;
  v0[5] = Security::CFClass::equalType;
  v0[6] = Security::CFClass::hashType;
  v0[7] = Security::CFClass::copyFormattingDescType;
  v0[8] = Security::CFClass::copyDebugDescType;
  void *v0 = 8LL;
  v0[1] = "SecCode";
  v0[10] = Security::CFClass::refCountForType;
  uint64_t v1 = _CFRuntimeRegisterClass();
  v0[13] = 8LL;
  v0[12] = v1;
  v0[14] = "SecStaticCode";
  v0[15] = 0LL;
  v0[16] = 0LL;
  v0[17] = Security::CFClass::finalizeType;
  v0[18] = Security::CFClass::equalType;
  v0[19] = Security::CFClass::hashType;
  v0[20] = Security::CFClass::copyFormattingDescType;
  v0[21] = Security::CFClass::copyDebugDescType;
  v0[23] = Security::CFClass::refCountForType;
  uint64_t v2 = _CFRuntimeRegisterClass();
  v0[26] = 8LL;
  v0[25] = v2;
  v0[27] = "SecRequirements";
  v0[28] = 0LL;
  v0[29] = 0LL;
  v0[30] = Security::CFClass::finalizeType;
  v0[31] = Security::CFClass::equalType;
  v0[32] = Security::CFClass::hashType;
  v0[33] = Security::CFClass::copyFormattingDescType;
  v0[34] = Security::CFClass::copyDebugDescType;
  v0[36] = Security::CFClass::refCountForType;
  uint64_t v3 = _CFRuntimeRegisterClass();
  v0[40] = "SecCodeSigner";
  v0[41] = 0LL;
  v0[42] = 0LL;
  v0[43] = Security::CFClass::finalizeType;
  v0[44] = Security::CFClass::equalType;
  v0[45] = Security::CFClass::hashType;
  v0[46] = Security::CFClass::copyFormattingDescType;
  v0[47] = Security::CFClass::copyDebugDescType;
  v0[38] = v3;
  v0[39] = 8LL;
  v0[49] = Security::CFClass::refCountForType;
  uint64_t v4 = _CFRuntimeRegisterClass();
  v0[53] = "SecCodeSignerRemote";
  v0[54] = 0LL;
  v0[55] = 0LL;
  v0[56] = Security::CFClass::finalizeType;
  v0[57] = Security::CFClass::equalType;
  v0[58] = Security::CFClass::hashType;
  v0[59] = Security::CFClass::copyFormattingDescType;
  v0[60] = Security::CFClass::copyDebugDescType;
  v0[51] = v4;
  v0[52] = 8LL;
  v0[62] = Security::CFClass::refCountForType;
  v0[64] = _CFRuntimeRegisterClass();
  timespec v5 = (Security::UnixError *)pthread_key_create( v0 + 65,  (void (__cdecl *)(void *))Security::PerThreadPointer<Security::CodeSigning::PerThread>::destructor);
  if ((_DWORD)v5) {
    Security::UnixError::throwMe(v5);
  }
  return v0;
}

void sub_180615504(_Unwind_Exception *a1)
{
}

uint64_t SecCodeSignerCreate(const __CFDictionary *a1, int a2, void *a3)
{
  if ((a2 & 0xFEFFF000) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  std::string v15 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  uint64_t v8 = Security::SecCFObject::allocate((Security::SecCFObject *)0x140, *(void *)(v6 + 408), v7);
  uint64_t v9 = (Security::SecCFObject *)v8;
  *(void *)(v8 + _Block_object_dispose(va, 8) = 1LL;
  *(void *)uint64_t v8 = off_189677EC8;
  *(_DWORD *)(v8 + 16) = a2;
  *(void *)(v8 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v8 + 16syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0LL;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 8syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(void *)(v8 + 152) = v8 + 160;
  *(void *)(v8 + 28_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(v8 + 296) = 0;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 224) = 0u;
  *(void *)(v8 + 24syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0LL;
  *(void *)(v8 + 256) = 0LL;
  *(void *)(v8 + 264) = 0LL;
  *(void *)(v8 + 272) = 0LL;
  std::string::size_type v10 = (unsigned __int8 *)(v8 - 8);
  *(void *)(v8 + 304) = 0LL;
  *(void *)(v8 + 312) = 0LL;
  do
    unsigned __int8 v11 = __ldaxr(v10);
  while (__stlxr(1u, v10));
  if ((v11 & 1) != 0)
  {
    int v12 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 16LL))(v8);
    CFRetain(v12);
  }

  std::string v15 = v9;
  Security::CodeSigning::SecCodeSigner::parameters(v9, a1);
  uint64_t v13 = Security::SecCFObject::handle(v9, 1);
  if (!a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *a3 = v13;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v15);
  return 0LL;
}

void sub_18061565C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      unsigned __int8 v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24LL))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      unsigned __int8 v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      int v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24LL))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180615624LL);
}

void sub_180615790(_Unwind_Exception *a1)
{
}

uint64_t SecCodeSignerAddSignature(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  return SecCodeSignerAddSignatureWithErrors(a1, a2, a3);
}

uint64_t SecCodeSignerAddSignatureWithErrors(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  if ((a3 & 0xEFFFFFFF) != 0)
  {
    uint64_t v3 = 4294900226LL;
    goto LABEL_6;
  }

  uint64_t v3 = 4294900225LL;
  if (!a1
  {
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v3);
  }

  uint64_t v8 = v6;
  uint64_t v9 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::required(a2, v7);
  Security::CodeSigning::SecCodeSigner::sign(v8, v9, a3);
  return 0LL;
}

void *Security::CodeSigning::SecStaticCode::required( Security::CodeSigning::SecStaticCode *this, const __SecCode *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
  }

  return result;
}

CFDateRef Security::CodeSigning::copyCutOffDate( const __CFString *this, const __CFString *a2, CFAbsoluteTime a3)
{
  CFDateRef v4 = CFDateCreate(0LL, a3);
  timespec v5 = (const __CFDate *)CFPreferencesCopyValue( this,  @"com.apple.security.syspolicy",  (CFStringRef)*MEMORY[0x189605198],  (CFStringRef)*MEMORY[0x189605178]);
  if (!v5)
  {
    CFRetain(v4);
    CFDateRef v8 = v4;
    if (!v4) {
      return v8;
    }
    goto LABEL_7;
  }

  uint64_t v6 = v5;
  CFTypeID v7 = CFGetTypeID(v5);
  CFDateRef v8 = v4;
  if (v7 == CFDateGetTypeID())
  {
    if (CFDateCompare(v4, v6, 0LL) <= kCFCompareEqualTo) {
      CFDateRef v8 = v4;
    }
    else {
      CFDateRef v8 = v6;
    }
  }

  CFRetain(v8);
  CFRelease(v6);
  if (v4) {
LABEL_7:
  }
    CFRelease(v4);
  return v8;
}

const void **Security::CFRef<__CFDate const*>::~CFRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::SecCode::checkValidity(Security::CodeSigning::SecCode *this, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!*((void *)this + 2)) {
    return;
  }
  Security::CodeSigning::SecCode::checkValidity(*((Security::CodeSigning::SecCode **)this + 2), a2);
  if (!*((_BYTE *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80LL))(this);
    *((_BYTE *)this + 24) = 1;
  }

  uint64_t v4 = *((void *)this + 4);
  *(_DWORD *)(v4 + 20_Block_object_dispose(va, 8) = a2;
  uint64_t v5 = *((void *)this + 2);
  if (!*(_BYTE *)(v5 + 24))
  {
    (*(void (**)(void))(*(void *)v5 + 80LL))(*((void *)this + 2));
    *(_BYTE *)(v5 + 24) = 1;
  }

  uint64_t v6 = *(Security::CodeSigning::SecStaticCode **)(v5 + 32);
  Security::CodeSigning::SecStaticCode::validateNonResourceComponents((UInt8 *)v4);
  if ((a2 & 0x10) != 0)
  {
    uint64_t v9 = *(void *)(v4 + 32);
    std::string::size_type v10 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(void *)&__p[8] = 0LL;
    *(void *)&__p[16] = 0LL;
    *(void *)std::string __p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, _BYTE *, uint64_t))(*(void *)v9 + 224LL))(v9, v10, __p, a2);
  }

  else
  {
    if ((a2 & 0x2000) == 0) {
      goto LABEL_12;
    }
    uint64_t v7 = *(void *)(v4 + 32);
    CFDateRef v8 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(void *)&__p[8] = 0LL;
    *(void *)&__p[16] = 0LL;
    *(void *)std::string __p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, _BYTE *, uint64_t))(*(void *)v7 + 232LL))(v7, v8, __p, a2);
  }

  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)&__p[8]);
LABEL_12:
  int v11 = (*(uint64_t (**)(void, Security::CodeSigning::SecCode *))(**((void **)this + 2) + 104LL))( *((void *)this + 2),  this);
  if ((v11 & 1) == 0)
  {
    char v12 = os_variant_allows_internal_security_policies();
    char v13 = (v11 & 0x4000000) != 0 ? v12 : 1;
    if ((v11 & 0x10000000) == 0 || (v13 & 1) == 0) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA09LL);
    }
  }

  if (!*((_BYTE *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80LL))(this);
    *((_BYTE *)this + 24) = 1;
  }

  int v14 = (const void *)*((void *)this + 5);
  if (v14)
  {
    CFDataRef v15 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v4);
    if (!CFEqual(v14, v15))
    {
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v4 + 32) + 48LL))(*(void *)(v4 + 32));
      __int128 v17 = (os_log_s *)secLogObjForScope("SecCode");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((_BYTE *)this + 24))
        {
          (*(void (**)(Security::CodeSigning::SecCode *))(*(void *)this + 80LL))(this);
          *((_BYTE *)this + 24) = 1;
        }

        uint64_t v18 = *((void *)this + 5);
        CFDataRef v19 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v4);
        *(_DWORD *)std::string __p = 138412802;
        *(void *)&__p[4] = v16;
        *(_WORD *)&__p[12] = 2112;
        *(void *)&__p[14] = v18;
        *(_WORD *)&__p[22] = 2112;
        CFDataRef v21 = v19;
        _os_log_impl(&dword_1804F4000, v17, OS_LOG_TYPE_DEFAULT, "cdhash mismatch: %@, %@, %@", __p, 0x20u);
      }

      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA26LL);
    }
  }

  if (*(void *)(*((void *)this + 2) + 16LL))
  {
    Security::CodeSigning::SecStaticCode::validateRequirements( (Security::CodeSigning::SecStaticCode *)v4,  1,  v6,  4294900249LL);
    Security::CodeSigning::SecStaticCode::validateRequirements(v6, 2, (Security::CodeSigning::SecStaticCode *)v4, 0LL);
  }

  Security::CodeSigning::SecCode::checkValidity::_DTFrameCODESIGN_EVAL_DYNAMIC::~_DTFrameCODESIGN_EVAL_DYNAMIC();
}

void sub_180615F5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

  ;
}

void Security::CodeSigning::SecCode::autoLocateGuest( Security::CodeSigning::SecCode *this, const __CFDictionary *a2)
{
}

void Security::CodeSigning::BundleDiskRep::~BundleDiskRep(Security::CodeSigning::BundleDiskRep *this)
{
}

{
  *(void ++*(void *)this = off_1896775A0;
  *((void *)this + 2) = &unk_1896776C0;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 27));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 24));
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((void *)this + 13);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 8);
  Security::CFRef<__CFBundle *>::~CFRef((const void **)this + 3);
  Security::CodeSigning::DiskRep::~DiskRep(this);
}

CFDataRef Security::CodeSigning::BundleDiskRep::component( Security::CodeSigning::BundleDiskRep *this, Security::CodeSigning::CodeDirectory *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if ((_DWORD)a2 == 3)
  {
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)this + 23, 3u, 3);
    std::string::size_type v10 = Security::CodeSigning::CodeDirectory::canonicalSlotName((Security::CodeSigning::CodeDirectory *)3);
    if (v10) {
      return Security::CodeSigning::BundleDiskRep::metaData(this, v10);
    }
  }

  else
  {
    if ((_DWORD)a2 == 1)
    {
      uint64_t v4 = (const void *)_CFBundleCopyInfoPlistURL();
      uint64_t v16 = v4;
      if (v4)
      {
        uint64_t v5 = (const __CFURL *)v4;
        memset(__p, 170, sizeof(__p));
        Security::cfString((Security *)__p, (const __CFURL *)v4);
        __int128 v17 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
        if (SHIBYTE(__p[2]) >= 0) {
          uint64_t v6 = __p;
        }
        else {
          uint64_t v6 = (void **)__p[0];
        }
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v17, (const char *)v6, 0, 438);
        uint64_t v7 = (Security::UnixPlusPlus::FileDesc *)v17;
        Security::CodeSigning::BundleDiskRep::checkPlainFile( (uint64_t)this,  (Security::UnixPlusPlus::FileDesc *)v17,  (uint64_t)__p);
        v8.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        v8.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v19.st_blkint size = v8;
        *(timespec *)v19.st_qspare = v8;
        *(timespec *)&v19.st_int size = v8;
        v19.st_ctimespeCC_SHA512_CTX c = v8;
        v19.st_birthtimespeCC_SHA512_CTX c = v8;
        v19.st_atimespeCC_SHA512_CTX c = v8;
        v19.st_mtimespeCC_SHA512_CTX c = v8;
        *(timespec *)&v19.st_dev = v8;
        *(timespec *)&v19.st_uid = v8;
        Security::UnixPlusPlus::FileDesc::fstat(v7, &v19);
        CFDataRef v9 = Security::cfMapFile(v7, v19.st_size);
        if (!v9)
        {
          int v14 = (os_log_s *)secLogObjForScope("bundlediskrep");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            Security::cfString((Security *)&v19, v5);
            if ((v19.st_gid & 0x80000000) == 0) {
              CFDataRef v15 = &v19;
            }
            else {
              CFDataRef v15 = *(stat **)&v19.st_dev;
            }
            *(_DWORD *)stat buf = 136315138;
            CFDataRef v21 = v15;
            _os_log_debug_impl(&dword_1804F4000, v14, OS_LOG_TYPE_DEBUG, "failed to load %s", buf, 0xCu);
            if (SHIBYTE(v19.st_gid) < 0) {
              operator delete(*(void **)&v19.st_dev);
            }
          }

          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA45LL);
        }

        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v17);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        CFDataRef v9 = 0LL;
      }

      Security::CFRef<__CFURL const*>::~CFRef(&v16);
      return v9;
    }

    uint64_t v12 = (*(uint64_t (**)(void, Security::CodeSigning::CodeDirectory *))(**((void **)this + 13) + 24LL))( *((void *)this + 13),  a2);
    *(void *)&v19.st_dev = v12;
    if (v12)
    {
      CFDataRef v9 = (CFDataRef)v12;
      if (*((_BYTE *)this + 177))
      {
        if (!*((_BYTE *)this + 176)) {
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
        }
      }

      else
      {
        *((_WORD *)this + 8_Block_object_dispose(va, 8) = 257;
      }

void sub_180616330( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
}

uint64_t Security::CodeSigning::BundleDiskRep::identification(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 32LL))(*((void *)this + 13));
}

void *Security::CodeSigning::BundleDiskRep::mainExecutablePath@<X0>( const __CFURL **this@<X0>, Security *a2@<X8>)
{
  return Security::cfString(a2, this[8]);
}

CFURLRef Security::CodeSigning::BundleDiskRep::copyCanonicalPath(CFBundleRef *this)
{
  CFURLRef result = CFBundleCopyBundleURL(this[3]);
  if (!result) {
    Security::CFError::throwMe(0LL);
  }
  return result;
}

const void **Security::CodeSigning::BundleDiskRep::resourcesRootPath@<X0>( CFBundleRef *this@<X0>, Security *a2@<X8>)
{
  uint64_t v3 = CFBundleCopySupportFilesDirectoryURL(this[3]);
  return Security::cfStringRelease(a2, v3);
}

void Security::CodeSigning::BundleDiskRep::adjustResources( Security::CodeSigning::BundleDiskRep *this, Security::CodeSigning::ResourceBuilder *a2)
{
  (*(void (**)(std::string *__return_ptr, Security::CodeSigning::BundleDiskRep *))(*(void *)this + 56LL))( &__str,  this);
  std::string::size_type size = __str.__r_.__value_.__s.__size_;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (!std::string::compare(&__str, size - 2, 2uLL, "/."))
  {
    std::string::size_type v5 = __str.__r_.__value_.__s.__size_;
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v5 = __str.__r_.__value_.__l.__size_;
    }
    std::string::basic_string(&v22, &__str, 0LL, v5 - 2, (std::allocator<char> *)&v20);
    std::string __str = v22;
  }

  memset(&v22, 170, sizeof(v22));
  (*(void (**)(std::string *__return_ptr, Security::CodeSigning::BundleDiskRep *))(*(void *)this + 40LL))( &v22,  this);
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v6 = __str.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v6 = __str.__r_.__value_.__l.__size_;
  }
  if (!std::string::compare(&v22, 0LL, v6, &__str, 0LL, v6))
  {
    std::string::size_type v7 = __str.__r_.__value_.__s.__size_;
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v7 = __str.__r_.__value_.__l.__size_;
    }
    timespec v8 = &v22;
    if ((v22.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      timespec v8 = (std::string *)v22.__r_.__value_.__r.__words[0];
    }
    if (v8->__r_.__value_.__s.__data_[v7] == 47)
    {
      std::string::basic_string[abi:ne180100]<0>(&v18, "^");
      std::string::size_type v9 = __str.__r_.__value_.__s.__size_;
      if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string::size_type v9 = __str.__r_.__value_.__l.__size_;
      }
      std::string::basic_string(&v16, &v22, v9 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v24);
      Security::CodeSigning::ResourceBuilder::escapeRE(&__p, (std::string::value_type *)&v16);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v11 = __p.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v11 = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v12 = std::string::append(&v18, (const std::string::value_type *)p_p, v11);
      __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v19.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0LL;
      v12->__r_.__value_.__l.__cap_ = 0LL;
      v12->__r_.__value_.__r.__words[0] = 0LL;
      int v14 = std::string::append(&v19, "$", 1uLL);
      __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      std::string::size_type cap = v14->__r_.__value_.__l.__cap_;
      __int128 v20 = v15;
      v14->__r_.__value_.__l.__size_ = 0LL;
      v14->__r_.__value_.__l.__cap_ = 0LL;
      v14->__r_.__value_.__r.__words[0] = 0LL;
      Security::CodeSigning::ResourceBuilder::addExclusion(a2, &v20, 32);
      if (SHIBYTE(cap) < 0) {
        operator delete((void *)v20);
      }
    }
  }

void sub_180616714( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::BundleDiskRep::prepareForSigning(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 72LL))(*(void *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::mainExecutableImage( Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 80LL))(*((void *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::signingBase(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 88LL))(*((void *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::signingLimit(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 96LL))(*((void *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 104LL))(*(void *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 112LL))(*(void *)(a1 + 104));
}

void Security::CodeSigning::BundleDiskRep::format( Security::CodeSigning::BundleDiskRep *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 103) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 10), *((void *)this + 11));
  }

  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 5);
    a2->__r_.__value_.__l.__cap_ = *((void *)this + 12);
  }

__CFArray *Security::CodeSigning::BundleDiskRep::modifiedFiles(Security::CodeSigning::BundleDiskRep *this)
{
  std::string::size_type v6 = (const __CFArray *)(*(uint64_t (**)(void))(**((void **)this + 13) + 136LL))(*((void *)this + 13));
  CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(0LL, 0LL, v6);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, 0LL);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile( this,  MutableCopy,  (Security::CodeSigning::CodeDirectory *)0x10000);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)3);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)4);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)5);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)7);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)6);
  uint64_t v2 = 4096LL;
  do
  {
    Security::CodeSigning::BundleDiskRep::checkModifiedFile( this,  MutableCopy,  (Security::CodeSigning::CodeDirectory *)v2);
    uint64_t v2 = (v2 + 1);
  }

  while ((_DWORD)v2 != 4101);
  uint64_t v3 = MutableCopy;
  CFMutableStringRef MutableCopy = 0LL;
  Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)&v6);
  return v3;
}

void sub_180616968(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t Security::CodeSigning::BundleDiskRep::fd(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 144LL))(*((void *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::flush(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 152LL))(*((void *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::copyDiskRepInformation( Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 160LL))(*((void *)this + 13));
}

const void **Security::CodeSigning::BundleDiskRep::registerStapledTicket( Security::CodeSigning::BundleDiskRep *this)
{
  uint64_t v3 = (Security::CodeSigning *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(void *)this
                                                                                                  + 176LL))(this);
  Security::CodeSigning::registerStapledTicketWithSystem(v3, v1);
  return Security::CFRef<__CFData const*>::~CFRef((const void **)&v3);
}

CFTypeRef Security::CodeSigning::BundleDiskRep::copyStapledTicket( Security::CodeSigning::BundleDiskRep *this)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  memset(v26, 170, sizeof(v26));
  uint64_t v1 = (const __CFURL *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(void *)this + 48LL))(this);
  Security::cfStringRelease((Security *)v26, v1);
  v2.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v30.st_blkstd::string::size_type size = v2;
  *(timespec *)v30.st_qspare = v2;
  v30.st_birthtimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v30.st_std::string::size_type size = v2;
  v30.st_mtimespeCC_SHA512_CTX c = v2;
  v30.st_ctimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v30.st_uid = v2;
  v30.st_atimespeCC_SHA512_CTX c = v2;
  *(timespec *)&v30.st_dev = v2;
  int64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  CFTypeRef cf = 0LL;
  if (SHIBYTE(v26[2]) >= 0) {
    size_t v3 = HIBYTE(v26[2]);
  }
  else {
    size_t v3 = (size_t)v26[1];
  }
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v3 + 23);
  if (v28 < 0) {
    uint64_t v4 = (void **)__p[0];
  }
  if (v3)
  {
    if (SHIBYTE(v26[2]) >= 0) {
      std::string::size_type v5 = v26;
    }
    else {
      std::string::size_type v5 = (void **)v26[0];
    }
    memmove(v4, v5, v3);
  }

  strcpy((char *)v4 + v3, "/Contents/CodeResources");
  std::string::size_type v6 = (os_log_s *)secLogObjForScope("notarization");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    char v24 = v26;
    if (SHIBYTE(v26[2]) < 0) {
      char v24 = (void **)v26[0];
    }
    *(_DWORD *)stat buf = 136315138;
    off_t v32 = (off_t)v24;
    _os_log_debug_impl(&dword_1804F4000, v6, OS_LOG_TYPE_DEBUG, "Extracting ticket from bundle: %s", buf, 0xCu);
  }

  if (v28 >= 0) {
    std::string::size_type v7 = __p;
  }
  else {
    std::string::size_type v7 = (void **)__p[0];
  }
  int v8 = open((const char *)v7, 0);
  int v9 = v8;
  if (v8 > 0)
  {
    if (fstat(v8, &v30))
    {
      std::string::size_type v10 = (os_log_s *)secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *__error();
        *(_DWORD *)stat buf = 67109120;
        LODWORD(v32) = v11;
        uint64_t v12 = "unable to stat stapling file: %d";
        __int128 v13 = v10;
        uint32_t v14 = 8;
LABEL_28:
        _os_log_impl(&dword_1804F4000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      }

void sub_180616E54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, const void *a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  Security::CFRef<__CFData const*>::~CFRef(&a22);
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void Security::CodeSigning::BundleDiskRep::recommendedIdentifier(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 192LL))(v7);
  uint64_t v4 = (void *)HIBYTE(v7[2]);
  if (SHIBYTE(v7[2]) < 0) {
    uint64_t v4 = v7[1];
  }
  if (v4)
  {
    *(_OWORD *)a2 = *(_OWORD *)v7;
    *(void **)(a2 + 16) = v7[2];
  }

  else
  {
    std::string::size_type v5 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
    Security::cfStringRelease((Security *)&__p, v5);
    Security::CodeSigning::DiskRep::canonicalIdentifier((std::string *)a2, &__p);
    if (SHIBYTE(v7[2]) < 0) {
      operator delete(v7[0]);
    }
  }

void sub_180616F58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::BundleDiskRep::explicitIdentifier(CFBundleRef *this@<X0>, std::string *a2@<X8>)
{
  Identifier = CFBundleGetIdentifier(this[3]);
  if (Identifier
    || (InfoDictionary = CFBundleGetInfoDictionary(this[3])) != 0LL
    && (Identifier = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x189604E10])) != 0LL)
  {
    Security::cfString(a2, Identifier);
  }

  else
  {
    std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_18065A197);
  }

CFDataRef Security::CodeSigning::BundleDiskRep::defaultResourceRules(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 72))
  {
    uint64_t v4 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v138, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v5 = (const std::string::value_type *)v143;
    }
    else {
      std::string::size_type v5 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v6 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v6 = (std::string::size_type)v143[1];
    }
    std::string::size_type v7 = std::string::append(v4, v5, v6);
    __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v7->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0LL;
    v7->__r_.__value_.__l.__cap_ = 0LL;
    v7->__r_.__value_.__r.__words[0] = 0LL;
    int v9 = std::string::append(&v140, ".*\\.lproj/", 0xAuLL);
    __int128 v17 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    __int128 v141 = v17;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    CFTypeRef v18 = &v141;
    if (cap < 0) {
      CFTypeRef v18 = (__int128 *)v141;
    }
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>( (uint64_t)"{rules={'^.*' = #T%s = {optional=#T, weight=1000}'^.*/.*\\.pkg/' = {omit=#T, weight=10000}}}",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)v18);
    if (SHIBYTE(cap) < 0) {
      operator delete((void *)v141);
    }
    if (SHIBYTE(v139) < 0)
    {
      __int128 v20 = (void *)v138;
LABEL_138:
      operator delete(v20);
      goto LABEL_142;
    }

    goto LABEL_142;
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2) & 0x10) != 0)
  {
    uint64_t v83 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      uint64_t v84 = (const std::string::value_type *)v143;
    }
    else {
      uint64_t v84 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v85 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v85 = (std::string::size_type)v143[1];
    }
    int v86 = std::string::append(v83, v84, v85);
    __int128 v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
    int64_t cap = v86->__r_.__value_.__l.__cap_;
    __int128 v141 = v87;
    v86->__r_.__value_.__l.__size_ = 0LL;
    v86->__r_.__value_.__l.__cap_ = 0LL;
    v86->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      uint64_t v88 = &v141;
    }
    else {
      uint64_t v88 = (__int128 *)v141;
    }
    int v89 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      uint64_t v90 = (const std::string::value_type *)v143;
    }
    else {
      uint64_t v90 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v91 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v91 = (std::string::size_type)v143[1];
    }
    int v92 = std::string::append(v89, v90, v91);
    __int128 v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v92->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v93;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v94 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
    __int128 v95 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
    std::string::size_type v139 = v94->__r_.__value_.__l.__cap_;
    __int128 v138 = v95;
    v94->__r_.__value_.__l.__size_ = 0LL;
    v94->__r_.__value_.__l.__cap_ = 0LL;
    v94->__r_.__value_.__r.__words[0] = 0LL;
    std::string::basic_string[abi:ne180100]<0>(&v131, "^");
    if (SHIBYTE(v143[2]) >= 0) {
      CFNumberRef v96 = (const std::string::value_type *)v143;
    }
    else {
      CFNumberRef v96 = (const std::string::value_type *)v143[0];
    }
    if (SHIBYTE(v143[2]) >= 0) {
      std::string::size_type v97 = HIBYTE(v143[2]);
    }
    else {
      std::string::size_type v97 = (std::string::size_type)v143[1];
    }
    __int128 v98 = std::string::append(&v131, v96, v97);
    __int128 v99 = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
    v132.__r_.__value_.__l.__cap_ = v98->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v99;
    v98->__r_.__value_.__l.__size_ = 0LL;
    v98->__r_.__value_.__l.__cap_ = 0LL;
    v98->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v100 = std::string::append(&v132, ".*\\.lproj/locversion.plist$", 0x1BuLL);
    __int128 v101 = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
    std::string::size_type v134 = v100->__r_.__value_.__l.__cap_;
    __int128 v133 = v101;
    v100->__r_.__value_.__l.__size_ = 0LL;
    v100->__r_.__value_.__l.__cap_ = 0LL;
    v100->__r_.__value_.__r.__words[0] = 0LL;
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>( (uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {omit=#T, weight=1100}}}",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  (uint64_t)v88);
    goto LABEL_122;
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2) & 8) != 0)
  {
    CFAbsoluteTime v109 = "{rules={'^.*' = #T'^Info\\.plist$' = {omit=#T,weight=10}}}";
LABEL_141:
    CFDataRef v19 = Security::cfmake<__CFDictionary const*>((uint64_t)v109, v21, v22, v23, v24, v25, v26, v27, v111);
    goto LABEL_142;
  }

  int64_t v28 = (void *)HIBYTE(v143[2]);
  if (SHIBYTE(v143[2]) < 0) {
    int64_t v28 = v143[1];
  }
  if (!v28)
  {
    CFAbsoluteTime v109 = "{rules={'^version.plist$' = #T'^.*' = #T'^.*\\.lproj/' = {optional=#T, weight=1000}'^Base\\.lproj/' = {weight"
           "=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}},rules2={'^.*' = #T'.*\\.dSYM($|/)' = {weight="
           "11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = {omit=#T, weight=20}'^version\\.plist$' = "
           "{weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^PkgInfo$' = {omit=#T, weight=20}'^.*\\.lproj/' = {o"
           "ptional=#T, weight=1000}'^Base\\.lproj/' = {weight=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}}}";
    goto LABEL_141;
  }

  uint64_t v29 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    stat v30 = (const std::string::value_type *)v143;
  }
  else {
    stat v30 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v31 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v31 = (std::string::size_type)v143[1];
  }
  off_t v32 = std::string::append(v29, v30, v31);
  __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  int64_t cap = v32->__r_.__value_.__l.__cap_;
  __int128 v141 = v33;
  v32->__r_.__value_.__l.__size_ = 0LL;
  v32->__r_.__value_.__l.__cap_ = 0LL;
  v32->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v34 = &v141;
  }
  else {
    __int128 v34 = (__int128 *)v141;
  }
  __int128 v35 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    __int128 v36 = (const std::string::value_type *)v143;
  }
  else {
    __int128 v36 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v37 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v37 = (std::string::size_type)v143[1];
  }
  __int128 v38 = std::string::append(v35, v36, v37);
  __int128 v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v137.__r_.__value_.__l.__cap_ = v38->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0LL;
  v38->__r_.__value_.__l.__cap_ = 0LL;
  v38->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v40 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
  __int128 v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  std::string::size_type v139 = v40->__r_.__value_.__l.__cap_;
  __int128 v138 = v41;
  v40->__r_.__value_.__l.__size_ = 0LL;
  v40->__r_.__value_.__l.__cap_ = 0LL;
  v40->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v131, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    unint64_t v42 = (const std::string::value_type *)v143;
  }
  else {
    unint64_t v42 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v43 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v43 = (std::string::size_type)v143[1];
  }
  uint64_t v44 = std::string::append(&v131, v42, v43);
  __int128 v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  v132.__r_.__value_.__l.__cap_ = v44->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0LL;
  v44->__r_.__value_.__l.__cap_ = 0LL;
  v44->__r_.__value_.__r.__words[0] = 0LL;
  int v46 = std::string::append(&v132, "Base\\.lproj/", 0xCuLL);
  __int128 v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
  std::string::size_type v134 = v46->__r_.__value_.__l.__cap_;
  __int128 v133 = v47;
  v46->__r_.__value_.__l.__size_ = 0LL;
  v46->__r_.__value_.__l.__cap_ = 0LL;
  v46->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v127, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    ssize_t v48 = (const std::string::value_type *)v143;
  }
  else {
    ssize_t v48 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v49 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v49 = (std::string::size_type)v143[1];
  }
  int v50 = std::string::append(&v127, v48, v49);
  __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  v128.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v128.__r_.__value_.__l.__data_ = v51;
  v50->__r_.__value_.__l.__size_ = 0LL;
  v50->__r_.__value_.__l.__cap_ = 0LL;
  v50->__r_.__value_.__r.__words[0] = 0LL;
  char v52 = std::string::append(&v128, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  std::string::size_type v130 = v52->__r_.__value_.__l.__cap_;
  __int128 v129 = v53;
  v52->__r_.__value_.__l.__size_ = 0LL;
  v52->__r_.__value_.__l.__cap_ = 0LL;
  v52->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v124, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    __int128 v54 = (const std::string::value_type *)v143;
  }
  else {
    __int128 v54 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v55 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v55 = (std::string::size_type)v143[1];
  }
  uint64_t v56 = std::string::append(&v124, v54, v55);
  __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
  std::string::size_type v126 = v56->__r_.__value_.__l.__cap_;
  __int128 v125 = v57;
  v56->__r_.__value_.__l.__size_ = 0LL;
  v56->__r_.__value_.__l.__cap_ = 0LL;
  v56->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v120, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    size_t v58 = (const std::string::value_type *)v143;
  }
  else {
    size_t v58 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v59 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v59 = (std::string::size_type)v143[1];
  }
  __int128 v60 = std::string::append(&v120, v58, v59);
  __int128 v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
  v121.__r_.__value_.__l.__cap_ = v60->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v121.__r_.__value_.__l.__data_ = v61;
  v60->__r_.__value_.__l.__size_ = 0LL;
  v60->__r_.__value_.__l.__cap_ = 0LL;
  v60->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v62 = std::string::append(&v121, ".*\\.lproj/", 0xAuLL);
  __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
  std::string::size_type v123 = v62->__r_.__value_.__l.__cap_;
  __int128 v122 = v63;
  v62->__r_.__value_.__l.__size_ = 0LL;
  v62->__r_.__value_.__l.__cap_ = 0LL;
  v62->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v116, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    size_t v64 = (const std::string::value_type *)v143;
  }
  else {
    size_t v64 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v65 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v65 = (std::string::size_type)v143[1];
  }
  int v66 = std::string::append(&v116, v64, v65);
  __int128 v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v117.__r_.__value_.__l.__cap_ = v66->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v117.__r_.__value_.__l.__data_ = v67;
  v66->__r_.__value_.__l.__size_ = 0LL;
  v66->__r_.__value_.__l.__cap_ = 0LL;
  v66->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v68 = std::string::append(&v117, "Base\\.lproj/", 0xCuLL);
  __int128 v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
  std::string::size_type v119 = v68->__r_.__value_.__l.__cap_;
  __int128 v118 = v69;
  v68->__r_.__value_.__l.__size_ = 0LL;
  v68->__r_.__value_.__l.__cap_ = 0LL;
  v68->__r_.__value_.__r.__words[0] = 0LL;
  std::string::basic_string[abi:ne180100]<0>(&v112, "^");
  if (SHIBYTE(v143[2]) >= 0) {
    int64_t v70 = (const std::string::value_type *)v143;
  }
  else {
    int64_t v70 = (const std::string::value_type *)v143[0];
  }
  if (SHIBYTE(v143[2]) >= 0) {
    std::string::size_type v71 = HIBYTE(v143[2]);
  }
  else {
    std::string::size_type v71 = (std::string::size_type)v143[1];
  }
  CFNumberRef v72 = std::string::append(&v112, v70, v71);
  __int128 v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
  v113.__r_.__value_.__l.__cap_ = v72->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v113.__r_.__value_.__l.__data_ = v73;
  v72->__r_.__value_.__l.__size_ = 0LL;
  v72->__r_.__value_.__l.__cap_ = 0LL;
  v72->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v74 = std::string::append(&v113, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  __int128 v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
  std::string::size_type v115 = v74->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v75;
  v74->__r_.__value_.__l.__size_ = 0LL;
  v74->__r_.__value_.__l.__cap_ = 0LL;
  v74->__r_.__value_.__r.__words[0] = 0LL;
  CFDataRef v19 = Security::cfmake<__CFDictionary const*>( (uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {weight=1010}%s = {omit=#T, weight=1100}},rules2={'^.*' = #T'^[^/]+$' = {nested=#T, weight=10}'^(Frameworks|SharedFrameworks|Plug Ins|Plug-ins|XPCServices|Helpers|MacOS|Library/(Automator|Spotlight|LoginItems))/' = {nested=#T, weig ht=10}'.*\\.dSYM($|/)' = {weight=11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = { omit=#T, weight=20}'^version\\.plist$' = {weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^Pk gInfo$' = {omit=#T, weight=20}%s = {weight=20}%s = {optional=#T, weight=1000}%s = {weight=1010}%s = { omit=#T, weight=1100}}}",  v76,  v77,  v78,  v79,  v80,  v81,  v82,  (uint64_t)v34);
  if (SHIBYTE(v115) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v119) < 0) {
    operator delete((void *)v118);
  }
  if (SHIBYTE(v123) < 0) {
    operator delete((void *)v122);
  }
  if (SHIBYTE(v126) < 0) {
    operator delete((void *)v125);
  }
  if (SHIBYTE(v130) < 0) {
    operator delete((void *)v129);
  }
LABEL_122:
  if (SHIBYTE(v134) < 0) {
    operator delete((void *)v133);
  }
  if (SHIBYTE(v139) < 0) {
    operator delete((void *)v138);
  }
  if (v136 < 0) {
    operator delete(v135[0]);
  }
  if (SHIBYTE(cap) < 0) {
    operator delete((void *)v141);
  }
  if ((char)v140.__r_.__value_.__s.__size_ < 0)
  {
    __int128 v20 = (void *)v140.__r_.__value_.__r.__words[0];
    goto LABEL_138;
  }

LABEL_142:
  if (SHIBYTE(v143[2]) < 0) {
    operator delete(v143[0]);
  }
  return v19;
}

void sub_1806178A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, void *a43, uint64_t a44, int a45, __int16 a46, char a47, char a48, uint64_t a49, void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  if (a67 < 0) {
    operator delete(a62);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  if (a76 < 0) {
    operator delete(a75);
  }
  if (a74 < 0) {
    operator delete(a73);
  }
  if (a82 < 0) {
    operator delete(a81);
  }
  if (a80 < 0) {
    operator delete(a79);
  }
  if (a78 < 0) {
    operator delete(a77);
  }
  if (a86 < 0) {
    operator delete(a85);
  }
  if (a84 < 0) {
    operator delete(a83);
  }
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::BundleDiskRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 208LL))(*(void *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 216LL))(*(void *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::strictValidate(void **a1, uint64_t a2, uint64_t a3, int a4)
{
  return (*(uint64_t (**)(void *, uint64_t, uint64_t, void))(*a1[13] + 224LL))( a1[13],  a2,  a3,  a4 & 0xFFFFFEFF);
}

void Security::CodeSigning::BundleDiskRep::strictValidateStructure( uint64_t a1, Security::CodeSigning::CodeDirectory *this, void *a3, int a4)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  if ((a4 & 0x4000000) == 0)
  {
    if (Security::CodeSigning::CodeDirectory::slotIsPresent(this, -3)) {
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)(a1 + 184), 3u, 3);
    }
    v69[0] = 0LL;
    v69[1] = 0LL;
    uint64_t v68 = v69;
    __int128 v8 = *(void **)(a1 + 184);
    if (v8 != (void *)(a1 + 192))
    {
      do
      {
        int v9 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v8 + 7);
        if ((_DWORD)v9 != 1)
        {
          uint64_t v10 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(v9);
          if (v10)
          {
            std::string::basic_string[abi:ne180100]<0>(__p, v10);
            std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>( (uint64_t **)&v68,  __p,  (uint64_t)__p);
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
          }
        }

        uint64_t v11 = (void *)v8[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            uint64_t v11 = (void *)*v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            uint64_t v12 = (void *)v8[2];
            BOOL v13 = *v12 == (void)v8;
            __int128 v8 = v12;
          }

          while (!v13);
        }

        __int128 v8 = v12;
      }

      while (v12 != (void *)(a1 + 192));
    }

    uint64_t v14 = (Security::CodeSigning **)(a1 + 32);
    uint64_t v15 = (Security::CodeSigning *)(a1 + 32);
    BOOL v16 = Security::CodeSigning::pathFileSystemUsesXattrFiles(v15, v7);
    memset(__p, 170, sizeof(__p));
    if (*(char *)(a1 + 55) < 0)
    {
      std::string::__init_copy_ctor_external(&v67, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
    }

    else
    {
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)v14;
      v67.__r_.__value_.__l.__cap_ = *(void *)(a1 + 48);
    }

    Security::CodeSigning::DirScanner::DirScanner((uint64_t)__p, &v67);
    if (LOBYTE(__p[135]))
    {
      while (1)
      {
        while (1)
        {
          do
          {
            Next = Security::CodeSigning::DirScanner::getNext((DIR **)__p);
            if (!Next) {
              goto LABEL_57;
            }
            if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__p, Next)) {
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
            }
            d___darwin_ino64_t name = Next->d_name;
            std::string::basic_string[abi:ne180100]<0>(&v71, Next->d_name);
            CFDataRef v19 = (char **)std::__tree<std::string>::find<std::string>((uint64_t)&v68, &v71);
            if (SHIBYTE(v71.st_gid) < 0) {
              operator delete(*(void **)&v71.st_dev);
            }
          }

          while (v69 != v19);
          if (!strcmp(d_name, "CodeSignature")) {
            break;
          }
          if (!v16) {
            goto LABEL_56;
          }
          else {
            size_t v20 = *(void *)(a1 + 40);
          }
          memset(&v71, 170, 24);
          std::string::basic_string[abi:ne180100]((uint64_t)&v71, v20 + 1);
          if ((v71.st_gid & 0x80000000) == 0) {
            uint64_t v21 = &v71;
          }
          else {
            uint64_t v21 = *(stat **)&v71.st_dev;
          }
          if (v20)
          {
            else {
              uint64_t v22 = *(const void **)(a1 + 32);
            }
            memmove(v21, v22, v20);
          }

          *(_WORD *)((char *)&v21->st_dev + v2syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 47;
          std::string::size_type v23 = strlen(d_name);
          uint64_t v24 = std::string::append((std::string *)&v71, d_name, v23);
          __int128 v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
          v65.__r_.__value_.__l.__cap_ = v24->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v25;
          v24->__r_.__value_.__l.__size_ = 0LL;
          v24->__r_.__value_.__l.__cap_ = 0LL;
          v24->__r_.__value_.__r.__words[0] = 0LL;
          int IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile(&v65, "bundlediskrep");
          if (SHIBYTE(v71.st_gid) < 0)
          {
            operator delete(*(void **)&v71.st_dev);
            if (!IsValidXattrFile) {
              goto LABEL_56;
            }
          }

          else if (!IsValidXattrFile)
          {
            goto LABEL_56;
          }

          stat v30 = (os_log_s *)secLogObjForScope("bundlediskrep");
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v71.st_dev = 136315138;
            *(void *)&v71.st_mode = d_name;
            _os_log_debug_impl( &dword_1804F4000,  v30,  OS_LOG_TYPE_DEBUG,  "meta directory validation on xattr file skipped: %s",  (uint8_t *)&v71,  0xCu);
          }
        }

        int v66 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
        Security::CodeSigning::BundleDiskRep::metaPath((std::string *)&v71, (const char *)a1, "CodeSignature");
        if ((v71.st_gid & 0x80000000) == 0) {
          uint64_t v27 = &v71;
        }
        else {
          uint64_t v27 = *(stat **)&v71.st_dev;
        }
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v66, (const char *)v27, 0, 438);
        if (SHIBYTE(v71.st_gid) < 0) {
          operator delete(*(void **)&v71.st_dev);
        }
        v28.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        v28.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v71.st_blkstd::string::size_type size = v28;
        *(timespec *)v71.st_qspare = v28;
        v71.st_birthtimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v71.st_std::string::size_type size = v28;
        v71.st_mtimespeCC_SHA512_CTX c = v28;
        v71.st_ctimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v71.st_uid = v28;
        v71.st_atimespeCC_SHA512_CTX c = v28;
        *(timespec *)&v71.st_dev = v28;
        Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)v66, &v71);
        st_std::string::size_type size = v71.st_size;
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v66);
        if (st_size) {
LABEL_56:
        }
          std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)(a1 + 208), -67014, -67014);
      }
    }

LABEL_57:
    Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__p);
    std::__tree<std::string>::destroy(v69[0]);
  }

  memset(__p, 170, 24);
  std::string::size_type v31 = (const __CFURL *)(*(uint64_t (**)(uint64_t, Security::CodeSigning::CodeDirectory *))(*(void *)a1 + 48LL))( a1,  this);
  Security::cfStringRelease((Security *)__p, v31);
  v65.__r_.__value_.__r.__words[0] = 0xAAAAAAAAFFFFFFFFLL;
  if (SHIBYTE(__p[2]) >= 0) {
    off_t v32 = __p;
  }
  else {
    off_t v32 = (void **)__p[0];
  }
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v65, (const char *)v32, 0, 438);
  if ((a4 & 0x1000000) != 0)
  {
    data_low = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65.__r_.__value_.__l.__data_);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute( (Security::UnixPlusPlus::FileDesc *)LODWORD(v65.__r_.__value_.__l.__data_),  "com.apple.ResourceFork"))
    {
      Security::UnixPlusPlus::FileDesc::removeAttr(data_low, "com.apple.ResourceFork");
    }

    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(data_low, "com.apple.FinderInfo")) {
      Security::UnixPlusPlus::FileDesc::removeAttr(data_low, "com.apple.FinderInfo");
    }
  }

  if ((a4 & 0x200) != 0)
  {
    __int128 v34 = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65.__r_.__value_.__l.__data_);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute( (Security::UnixPlusPlus::FileDesc *)LODWORD(v65.__r_.__value_.__l.__data_),  "com.apple.ResourceFork"))
    {
      std::string::size_type v59 = __p;
      if (SHIBYTE(__p[2]) < 0) {
        std::string::size_type v59 = (void **)__p[0];
      }
      __int128 v60 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"Disallowed xattr %s found on %s",  "com.apple.ResourceFork",  v59);
      Security::CodeSigning::CSError::throwMe( (Security::CodeSigning::CSError *)0xFFFEFA49LL,  (uint64_t)@"SecCSResourceHasSidebandData",  v60,  v61);
    }

    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(v34, "com.apple.FinderInfo"))
    {
      uint64_t v62 = __p;
      if (SHIBYTE(__p[2]) < 0) {
        uint64_t v62 = (void **)__p[0];
      }
      __int128 v63 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"Disallowed xattr %s found on %s",  "com.apple.FinderInfo",  v62);
      Security::CodeSigning::CSError::throwMe( (Security::CodeSigning::CSError *)0xFFFEFA49LL,  (uint64_t)@"SecCSResourceHasSidebandData",  v63,  v64);
    }
  }

  memset(&v71, 0, 24);
  __int128 v35 = *(void **)(a1 + 208);
  __int128 v36 = (void *)(a1 + 216);
  __int128 v39 = (int *)*a3;
  std::string::size_type v37 = (int *)(a3 + 1);
  __int128 v38 = v39;
  unint64_t v40 = (uint64_t *)&v71;
  v67.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
  if (v35 != (void *)(a1 + 216))
  {
    if (v38 == v37)
    {
LABEL_96:
      uint64_t v68 = (char **)v40;
      if (v35 != v36)
      {
        do
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v68, *((_DWORD *)v35 + 7));
          __int128 v51 = (void *)v35[1];
          if (v51)
          {
            do
            {
              char v52 = v51;
              __int128 v51 = (void *)*v51;
            }

            while (v51);
          }

          else
          {
            do
            {
              char v52 = (void *)v35[2];
              BOOL v13 = *v52 == (void)v35;
              __int128 v35 = v52;
            }

            while (!v13);
          }

          __int128 v35 = v52;
        }

        while (v52 != v36);
      }
    }

    else
    {
      while (1)
      {
        int v41 = *((_DWORD *)v35 + 7);
        int v42 = v38[7];
        if (v41 >= v42)
        {
          if (v42 >= v41)
          {
            __int128 v47 = (void *)v35[1];
            if (v47)
            {
              do
              {
                ssize_t v48 = v47;
                __int128 v47 = (void *)*v47;
              }

              while (v47);
            }

            else
            {
              do
              {
                ssize_t v48 = (void *)v35[2];
                BOOL v13 = *v48 == (void)v35;
                __int128 v35 = v48;
              }

              while (!v13);
            }

            std::string::size_type v49 = (int *)*((void *)v38 + 1);
            if (v49)
            {
              do
              {
                __int128 v38 = v49;
                std::string::size_type v49 = *(int **)v49;
              }

              while (v49);
            }

            else
            {
              do
              {
                int v50 = v38;
                __int128 v38 = (int *)*((void *)v38 + 2);
              }

              while (*(int **)v38 != v50);
            }

            __int128 v35 = v48;
          }

          else
          {
            __int128 v45 = (int *)*((void *)v38 + 1);
            if (v45)
            {
              do
              {
                __int128 v38 = v45;
                __int128 v45 = *(int **)v45;
              }

              while (v45);
            }

            else
            {
              do
              {
                int v46 = v38;
                __int128 v38 = (int *)*((void *)v38 + 2);
              }

              while (*(int **)v38 != v46);
            }
          }
        }

        else
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v67, v41);
          std::string::size_type v43 = (void *)v35[1];
          if (v43)
          {
            do
            {
              __int128 v35 = v43;
              std::string::size_type v43 = (void *)*v43;
            }

            while (v43);
          }

          else
          {
            do
            {
              uint64_t v44 = v35;
              __int128 v35 = (void *)v35[2];
            }

            while ((void *)*v35 != v44);
          }
        }

        if (v35 == v36) {
          break;
        }
        if (v38 == v37)
        {
          unint64_t v40 = (uint64_t *)v67.__r_.__value_.__r.__words[0];
          goto LABEL_96;
        }
      }
    }
  }

  if (*(void *)&v71.st_dev != v71.st_ino)
  {
    uint64_t v53 = **(unsigned int **)&v71.st_dev;
    goto LABEL_123;
  }

  if ((a4 & 0x100) != 0 && !*(_BYTE *)(a1 + 73))
  {
    uint64_t v53 = 4294900294LL;
    uint64_t v54 = *(void *)v37;
    if (!*(void *)v37) {
      goto LABEL_123;
    }
    std::string::size_type v55 = v37;
    do
    {
      int v56 = *(_DWORD *)(v54 + 28);
      BOOL v57 = v56 < 256;
      if (v56 >= 256) {
        size_t v58 = (uint64_t *)v54;
      }
      else {
        size_t v58 = (uint64_t *)(v54 + 8);
      }
      if (!v57) {
        std::string::size_type v55 = (int *)v54;
      }
      uint64_t v54 = *v58;
    }

    while (*v58);
    if (v55 == v37 || v55[7] >= 257) {
LABEL_123:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)v53);
  }

  if (*(void *)&v71.st_dev)
  {
    v71.st_ino = *(void *)&v71.st_dev;
    operator delete(*(void **)&v71.st_dev);
  }

  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v65);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
}

void sub_18061835C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, char *a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
}

CFDataRef Security::CodeSigning::BundleDiskRep::allowedResourceOmissions(CFBundleRef *this)
{
  if ((v19 & 0x80u) == 0) {
    timespec v2 = __p;
  }
  else {
    timespec v2 = (void **)__p[0];
  }
  if ((v19 & 0x80u) == 0) {
    std::string::size_type v3 = v19;
  }
  else {
    std::string::size_type v3 = (std::string::size_type)__p[1];
  }
  uint64_t v4 = std::string::append(&v20, (const std::string::value_type *)v2, v3);
  __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__l.__cap_ = v4->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0LL;
  v4->__r_.__value_.__l.__cap_ = 0LL;
  v4->__r_.__value_.__r.__words[0] = 0LL;
  std::string::size_type v6 = std::string::append(&v21, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  __int128 v14 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  int64_t cap = v6->__r_.__value_.__l.__cap_;
  __int128 v22 = v14;
  v6->__r_.__value_.__l.__size_ = 0LL;
  v6->__r_.__value_.__l.__cap_ = 0LL;
  v6->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v15 = &v22;
  if (cap < 0) {
    uint64_t v15 = (__int128 *)v22;
  }
  CFDataRef v16 = Security::cfmake<__CFArray const*>((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, (uint64_t)v15);
  if (SHIBYTE(cap) < 0) {
    operator delete((void *)v22);
  }
  return v16;
}

void sub_180618588( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::BundleDiskRep::appleInternalForcePlatform( Security::CodeSigning::BundleDiskRep *this)
{
  return *((unsigned __int8 *)this + 232);
}

char *Security::CodeSigning::BundleDiskRep::writer(Security::CodeSigning::BundleDiskRep *this)
{
  timespec v2 = (char *)operator new(0xC8uLL);
  *((_DWORD *)v2 + 2) = 0;
  *(void *)(v2 + 12) = -1LL;
  *((_DWORD *)v2 + 5) = 0;
  *(void *)timespec v2 = off_189677708;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 32));
  if (this)
  {
    std::string::size_type v3 = (unsigned int *)((char *)this + 8);
    do
      unsigned int v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  *((void *)v2 + 12) = 0LL;
  __int128 v5 = v2 + 96;
  *((void *)v2 + 3) = this;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 104));
  *((void *)v2 + 23) = 0LL;
  v2[168] = 0;
  *((void *)v2 + 24) = 0LL;
  *((void *)v2 + 22) = v2 + 184;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(*((void *)v2 + 3) + 104LL) + 256LL))(*(void *)(*((void *)v2 + 3) + 104LL));
  v14[0] = v2 + 104;
  v14[1] = 0xAAAAAAAAAAAAAA01LL;
  uint64_t v7 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(v2 + 104));
  if ((_DWORD)v7) {
    Security::UnixError::throwMe(v7);
  }
  if (v6)
  {
    uint64_t v8 = (unsigned int *)(v6 + 8);
    do
      unsigned int v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  if (*v5)
  {
    uint64_t v10 = (unsigned int *)(*v5 + 8LL);
    do
    {
      unsigned int v11 = __ldxr(v10);
      unsigned int v12 = v11 - 1;
    }

    while (__stxr(v12, v10));
    if (!v12 && *v5) {
      (*(void (**)(void))(*(void *)*v5 + 8LL))(*v5);
    }
  }

  *((void *)v2 + 12) = v6;
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v14);
  return v2;
}

void sub_18061872C(_Unwind_Exception *a1)
{
}

const void **Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>( Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = a2 + 8;
  int v12 = 0;
  do
  {
    CFDataRef v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    __int128 v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v4);
    if (v5)
    {
      CFDataRef v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v5);
      if (v11)
      {
        uint64_t v6 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>( (uint64_t **)a2,  (int)v4,  &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v6 + 5, (CFTypeRef *)&v11);
      }
    }

    else
    {
      CFDataRef v11 = 0LL;
    }

    Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    unsigned int v4 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v4 + 1);
    int v12 = (int)v4;
  }

  while ((_DWORD)v4 != 11);
  uint64_t v7 = 4096LL;
  int v12 = 4096;
  do
  {
    CFDataRef v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    uint64_t v8 = Security::CodeSigning::CodeDirectory::canonicalSlotName((Security::CodeSigning::CodeDirectory *)v7);
    if (v8)
    {
      CFDataRef v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v8);
      if (v11)
      {
        unsigned int v9 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>( (uint64_t **)a2,  v7,  &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v9 + 5, (CFTypeRef *)&v11);
      }
    }

    else
    {
      CFDataRef v11 = 0LL;
    }

    CFURLRef result = Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    uint64_t v7 = (v7 + 1);
    int v12 = v7;
  }

  while ((_DWORD)v7 != 4101);
  return result;
}

void sub_18061888C(_Unwind_Exception *a1)
{
}

const void **non-virtual thunk to'Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>( Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  return Security::CodeSigning::BundleDiskRep::createRawComponents( (Security::CodeSigning::BundleDiskRep *)((char *)this - 16),  a2);
}

CFDataRef Security::CodeSigning::BundleDiskRep::metaData( Security::CodeSigning::BundleDiskRep *this, const char *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  Security::CodeSigning::BundleDiskRep::metaPath(&__p, (const char *)this, a2);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = (Security *)&__p;
  }
  else {
    p_p = (Security *)__p.__r_.__value_.__r.__words[0];
  }
  CFURLRef CFURL = Security::makeCFURL(p_p, 0LL, 0LL, v3);
  uint64_t v7 = CFURL;
  CFURLRef v11 = CFURL;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v7) {
      goto LABEL_6;
    }
  }

  else if (CFURL)
  {
LABEL_6:
    CFDataRef File = Security::cfLoadFile(v7, v6);
    goto LABEL_11;
  }

  unsigned int v9 = (os_log_s *)secLogObjForScope("bundlediskrep");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEFAULT, "no metapath for %s", (uint8_t *)&__p, 0xCu);
  }

  CFDataRef File = 0LL;
LABEL_11:
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v11);
  return File;
}

void sub_1806189D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t **std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>( uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  __int128 v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        __int128 v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }

      if (v9 >= a2) {
        break;
      }
      __int128 v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }

  else
  {
LABEL_8:
    void v12[2] = 0xAAAAAAAAAAAAAA01LL;
    uint64_t v10 = operator new(0x30uLL);
    v12[1] = v6;
    void v10[8] = *a3;
    *((void *)v10 + 5) = 0LL;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( a1,  (uint64_t)v8,  v7,  (uint64_t *)v10);
    v12[0] = 0LL;
    std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }

  return v8;
}

CFTypeRef *Security::CFRef<__CFData const*>::operator=(CFTypeRef *a1, CFTypeRef *a2)
{
  if (*a2)
  {
    CFRetain(*a2);
    CFTypeRef v4 = *a2;
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = v4;
  return a1;
}

void std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy( const void **a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*a1);
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(a1[1]);
    Security::CFRef<__CFData const*>::~CFRef(a1 + 5);
    operator delete(a1);
  }

uint64_t *std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = a2;
  *a3 = a4;
  __int128 v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }

  CFURLRef result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]( uint64_t a1)
{
  uint64_t v1 = *(const void ***)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      Security::CFRef<__CFData const*>::~CFRef(v1 + 5);
    }
    operator delete(v1);
  }

void Security::CodeSigning::BundleDiskRep::metaPath(std::string *this, const char *a2, const char *a3)
{
  uint64_t v6 = (char *)(a2 + 32);
  if (a2[55] < 0)
  {
    if (*((void *)a2 + 5)) {
      goto LABEL_20;
    }
  }

  else if (a2[55])
  {
    goto LABEL_20;
  }

  memset(&v18, 170, sizeof(v18));
  uint64_t v7 = CFBundleCopySupportFilesDirectoryURL(*((CFBundleRef *)a2 + 3));
  Security::cfStringRelease((Security *)&v18, v7);
  if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t size = v18.__r_.__value_.__s.__size_;
  }
  else {
    size_t size = v18.__r_.__value_.__l.__size_;
  }
  memset(v17, 170, sizeof(v17));
  int v9 = v17;
  std::string::basic_string[abi:ne180100]((uint64_t)v17, size + 15);
  if (v17[23] < 0) {
    int v9 = *(_BYTE **)v17;
  }
  if (size)
  {
    if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v10 = &v18;
    }
    else {
      uint64_t v10 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    memmove(v9, v10, size);
  }

  strcpy(&v9[size], "/_CodeSignature");
  if (a2[55] < 0) {
    operator delete(*(void **)v6);
  }
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v17;
  *((void *)v6 + 2) = *(void *)&v17[16];
  CFURLRef v11 = v6;
  if (a2[55] < 0) {
    CFURLRef v11 = *(char **)v6;
  }
  *((_BYTE *)a2 + 56) = access(v11, 0) == 0;
  if ((char)v18.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (a3) {
      goto LABEL_21;
    }
LABEL_34:
    if (a2[55] < 0)
    {
      std::string::__init_copy_ctor_external(this, *((const std::string::value_type **)a2 + 4), *((void *)a2 + 5));
    }

    else
    {
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = *(_OWORD *)v6;
      this->__r_.__value_.__l.__cap_ = *((void *)v6 + 2);
    }

    return;
  }

void sub_180618E20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(void *)a1);
    std::__tree<std::string>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }

void *Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(void *a1)
{
  timespec v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01LL;
  std::string::size_type v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    CFTypeRef v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1 = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void *Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(void *a1)
{
  timespec v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01LL;
  std::string::size_type v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    CFTypeRef v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1 = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void Security::CodeSigning::BundleDiskRep::Writer::~Writer(char **this)
{
  *this = (char *)off_189677708;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(this + 12);
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);
}

{
  *this = (char *)off_189677708;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(this + 12);
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);
  operator delete(this);
}

void Security::CodeSigning::BundleDiskRep::Writer::component( Security::CodeSigning::BundleDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  if ((_DWORD)a2 == 3)
  {
    unsigned int v5 = "CodeResources";
  }

  else
  {
    unsigned int v6 = (_BYTE *)*((void *)this + 12);
    if ((v6[20] & 1) == 0)
    {
      (*(void (**)(_BYTE *))(*(void *)v6 + 16LL))(v6);
      return;
    }

    unsigned int v5 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
    if (!v5) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    }
  }

  uint64_t v7 = *((void *)this + 3);
  memset(&__str, 170, sizeof(__str));
  Security::CodeSigning::BundleDiskRep::metaPath(&__str, (const char *)v7, 0LL);
  if (!*(_BYTE *)(v7 + 56))
  {
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (mkdir((const char *)p_str, 0x1EDu))
    {
      if (*__error() != 17)
      {
        int v9 = __error();
        Security::UnixError::throwMe((Security::UnixError *)*v9);
      }
    }

    else
    {
      uint64_t v10 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 48LL))(v7);
      Security::cfStringRelease((Security *)__p, v10);
      if (v18 >= 0) {
        CFURLRef v11 = __p;
      }
      else {
        CFURLRef v11 = (void **)__p[0];
      }
      if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v12 = &__str;
      }
      else {
        size_t v12 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      copyfile((const char *)v11, (const char *)v12, 0LL, 3u);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      std::string::operator=((std::string *)(v7 + 32), &__str);
      *(_BYTE *)(v7 + 56) = 1;
    }
  }

  memset(&__str, 170, sizeof(__str));
  Security::CodeSigning::BundleDiskRep::metaPath(&__str, *((const char **)this + 3), v5);
  unint64_t v16 = 0xAAAAAAAAFFFFFFFFLL;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v13 = &__str;
  }
  else {
    uint64_t v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v16, (const char *)v13, 1537, 420);
  uint64_t BytePtr = (char *)CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)&v16, BytePtr, Length);
  Security::UnixPlusPlus::FileDesc::close((Security::UnixPlusPlus::FileDesc *)&v16);
  std::string::basic_string[abi:ne180100]<0>(__p, v5);
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)this + 22, __p, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v16);
}

void sub_180619280( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::BundleDiskRep::Writer::remove( Security::CodeSigning::BundleDiskRep::Writer *this)
{
  timespec v2 = 0LL;
  do
  {
    Security::CodeSigning::BundleDiskRep::Writer::remove((const char **)this, v2);
    timespec v2 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v2 + 1);
  }

  while ((_DWORD)v2 != 12);
  Security::CodeSigning::BundleDiskRep::Writer::remove( (const char **)this,  (Security::CodeSigning::CodeDirectory *)0x10000);
}

void Security::CodeSigning::BundleDiskRep::Writer::flush(Security::CodeSigning::BundleDiskRep::Writer *this)
{
  __b[136] = *(DIR **)MEMORY[0x1895F89C0];
  (*(void (**)(void))(**((void **)this + 12) + 48LL))(*((void *)this + 12));
  memset(__b, 170, 0x440uLL);
  uint64_t v2 = *((void *)this + 3);
  else {
    std::string v12 = *(std::string *)(v2 + 32);
  }
  Security::CodeSigning::DirScanner::DirScanner((uint64_t)__b, &v12);
  if (LOBYTE(__b[135]))
  {
    std::string::size_type v3 = (char *)this + 176;
    CFTypeRef v4 = (char *)this + 184;
    while (1)
    {
      Next = Security::CodeSigning::DirScanner::getNext(__b);
      if (!Next) {
        break;
      }
      if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__b, Next)) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
      }
      d___darwin_ino64_t name = Next->d_name;
      std::string::basic_string[abi:ne180100]<0>(__p, d_name);
      uint64_t v7 = (char *)std::__tree<std::string>::find<std::string>((uint64_t)v3, __p);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
      if (v4 == v7)
      {
        int v8 = dirfd(__b[3]);
        if (unlinkat(v8, d_name, 0) == -1)
        {
          int v9 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v9);
        }
      }
    }
  }

  Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__b);
}

void sub_1806194B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
}

void *std::__tree<std::string>::find<std::string>(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  std::string::size_type v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unsigned int v5 = (void *)(a1 + 8);
  do
  {
    char v6 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6 >= 0) {
      unsigned int v5 = v3;
    }
    std::string::size_type v3 = (void *)*v7;
  }

  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }

  return v5;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>( void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }

  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }

  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }

  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }

  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1LL;
    }
  }

  else
  {
    if (v3 == v5) {
      return 0LL;
    }
    if (v3 >= v5) {
      return 1LL;
    }
  }

  return 255LL;
}

void Security::CodeSigning::BundleDiskRep::Writer::remove( const char **this, Security::CodeSigning::CodeDirectory *a2)
{
  size_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (v3)
  {
    Security::CodeSigning::BundleDiskRep::metaPath(&v10, this[3], v3);
    int size = (char)v10.__r_.__value_.__s.__size_;
    size_t v5 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v6 = &v10;
    }
    else {
      size_t v6 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    int v7 = unlink((const char *)v6);
    int v8 = v7;
    if (size < 0)
    {
      operator delete(v5);
      if (!v8) {
        return;
      }
    }

    else if (!v7)
    {
      return;
    }

    if (*__error() != 2)
    {
      int v9 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v9);
    }
  }

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>( uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  CFURLRef result = std::__tree<std::string>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  if (!*result)
  {
    size_t v6 = (uint64_t **)result;
    int v7 = operator new(0x38uLL);
    void v7[2] = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( a1,  v8,  v6,  (uint64_t *)v7);
  }

  return result;
}

void *std::__tree<std::string>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  size_t v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v7 = v4;
        uint64_t v8 = v4 + 4;
        size_t v4 = (void *)*v7;
        size_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      size_t v5 = v7 + 1;
      size_t v4 = (void *)v7[1];
    }

    while (v4);
  }

  else
  {
    int v7 = (void *)(a1 + 8);
  }

void Security::CodeSigning::BundleDiskRep::resourcesRelativePath( Security::CodeSigning::BundleDiskRep *this, CFBundleRef *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  p_str = &__str;
  memset(&__str, 170, sizeof(__str));
  (*((void (**)(std::string *__return_ptr, CFBundleRef *))*a2 + 7))(&__str, a2);
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __str.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (size >= 3)
  {
    size_t v6 = (char *)p_str + size;
    uint64_t v7 = size;
    uint64_t v8 = p_str;
    do
    {
      int v9 = (char *)memchr(v8, 47, v7 - 2);
      if (!v9) {
        break;
      }
      if (*(_WORD *)v9 == 11823 && v9[2] == 47)
      {
        if (v9 != v6)
        {
          std::string::size_type v11 = v9 - (char *)p_str;
          if (v9 - (char *)p_str != -1)
          {
LABEL_17:
            std::string v12 = std::string::replace(&__str, v11, 2uLL, (const std::string::value_type *)&unk_18065A197, 0LL);
            std::string::operator=(&__str, v12);
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t size = __str.__r_.__value_.__s.__size_;
            }
            else {
              uint64_t size = __str.__r_.__value_.__l.__size_;
            }
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v13 = &__str;
            }
            else {
              uint64_t v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if (size >= 3)
            {
              __int128 v14 = (char *)v13 + size;
              uint64_t v15 = size;
              unint64_t v16 = v13;
              while (1)
              {
                __int128 v17 = (char *)memchr(v16, 47, v15 - 2);
                if (!v17) {
                  break;
                }
                if (*(_WORD *)v17 == 11823 && v17[2] == 47)
                {
                  if (v17 != v14)
                  {
                    std::string::size_type v11 = v17 - (char *)v13;
                  }

                  goto LABEL_34;
                }

                unint64_t v16 = (std::string *)(v17 + 1);
                uint64_t v15 = v14 - (char *)v16;
              }
            }
          }
        }

        break;
      }

      uint64_t v8 = (std::string *)(v9 + 1);
      uint64_t v7 = v6 - (char *)v8;
    }

    while (v6 - (char *)v8 >= 3);
  }

void sub_180619BC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef Security::cfmake<__CFArray const*>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::string v10 = &a9;
  v11[0] = "['^(.*/)?\\.DS_Store$''^Info\\.plist$''^PkgInfo$'%s]";
  v11[1] = &v10;
  _OWORD v11[2] = 0LL;
  int v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

uint64_t *std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100](uint64_t *a1, int a2)
{
  uint64_t v4 = *a1;
  size_t v6 = *(_DWORD **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v13 = (char *)operator new(4 * v12);
    }

    else
    {
      uint64_t v13 = 0LL;
    }

    __int128 v14 = &v13[4 * v9];
    *(_DWORD *)__int128 v14 = a2;
    uint64_t v7 = v14 + 4;
    while (v6 != v8)
    {
      int v15 = *--v6;
      *((_DWORD *)v14 - 1) = v15;
      v14 -= 4;
    }

    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + _Block_object_dispose(va, 8) = v7;
    *(void *)(v4 + 16) = &v13[4 * v12];
    if (v8) {
      operator delete(v8);
    }
  }

  else
  {
    *size_t v6 = a2;
    uint64_t v7 = v6 + 1;
  }

  *(void *)(v4 + _Block_object_dispose(va, 8) = v7;
  return a1;
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>( uint64_t *result, unsigned int a2, int a3)
{
  uint64_t v4 = (uint64_t **)result;
  size_t v6 = (uint64_t **)(result + 1);
  unint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        size_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        size_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( v4,  (uint64_t)v7,  v6,  v9);
  }

  return result;
}

uint64_t *std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t *result, int a2, int a3)
{
  uint64_t v4 = (uint64_t **)result;
  size_t v6 = (uint64_t **)(result + 1);
  unint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        size_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        size_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( v4,  (uint64_t)v7,  v6,  v9);
  }

  return result;
}

CFDataRef Security::cfmake<__CFDictionary const*>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v10 = &a9;
  v11[0] = a1;
  v11[1] = &v10;
  _OWORD v11[2] = 0LL;
  int v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

void Security::CodeSigning::BundleDiskRep::checkModifiedFile( Security::CodeSigning::BundleDiskRep *this, __CFArray *a2, Security::CodeSigning::CodeDirectory *a3)
{
  size_t v6 = (const void *)(*(uint64_t (**)(void, Security::CodeSigning::CodeDirectory *))(**((void **)this + 13)
                                                                                               + 24LL))( *((void *)this + 13),  a3);
  if (v6)
  {
    CFRelease(v6);
  }

  else
  {
    uint64_t v7 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a3);
    if (v7)
    {
      memset(&__sz, 170, sizeof(__sz));
      Security::CodeSigning::BundleDiskRep::metaPath(&__sz, (const char *)this, v7);
      int size = (char)__sz.__r_.__value_.__s.__size_;
      uint64_t v9 = (std::string::value_type *)__sz.__r_.__value_.__r.__words[0];
      if ((__sz.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_sz = &__sz;
      }
      else {
        p_sz = (std::string *)__sz.__r_.__value_.__r.__words[0];
      }
      if (!access((const char *)p_sz, 0))
      {
        if (size < 0) {
          std::string::__init_copy_ctor_external(&__p, v9, __sz.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = __sz;
        }
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = (Security *)&__p;
        }
        else {
          p_p = (Security *)__p.__r_.__value_.__r.__words[0];
        }
        CFURLRef CFURL = Security::makeCFURL(p_p, 0LL, 0LL, v11);
        CFArrayAppendValue(a2, CFURL);
        Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
      }

      if (size < 0) {
        operator delete(v9);
      }
    }
  }

void sub_180619FDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

const void **Security::CFRef<__CFArray *>::~CFRef(const void **a1)
{
  size_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::ResourceBuilder::addExclusion(void *a1, __int128 *a2, int a3)
{
  size_t v6 = (regex_t **)a1[8];
  uint64_t v7 = (regex_t *)operator new(0x40uLL);
  Security::CodeSigning::ResourceBuilder::Rule::Rule(v7, a2, 0, a3 | 0x10);
  int v8 = (char *)a1[9];
  unint64_t v9 = a1[10];
  if ((unint64_t)v8 >= v9)
  {
    __int128 v14 = (char *)a1[8];
    unint64_t v15 = ((v8 - v14) >> 3) + 1;
    if (v15 >> 61) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = (char *)v6 - v14;
    uint64_t v17 = ((char *)v6 - v14) >> 3;
    uint64_t v18 = v9 - (void)v14;
    if (v18 >> 2 > v15) {
      unint64_t v15 = v18 >> 2;
    }
    else {
      unint64_t v19 = v15;
    }
    if (v19)
    {
      BOOL v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v19);
    }

    else
    {
      BOOL v21 = 0LL;
      uint64_t v20 = 0LL;
    }

    std::string::size_type v22 = (regex_t **)&v21[8 * v17];
    std::string::size_type v23 = &v21[8 * v20];
    if (v17 == v20)
    {
      if (v16 < 1)
      {
        if (v6 == (regex_t **)v14) {
          unint64_t v25 = 1LL;
        }
        else {
          unint64_t v25 = v16 >> 2;
        }
        uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v25);
        std::string::size_type v22 = (regex_t **)&v26[8 * (v25 >> 2)];
        std::string::size_type v23 = &v26[8 * v27];
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        unint64_t v24 = v17 + 2;
        if (v17 >= -1) {
          unint64_t v24 = v17 + 1;
        }
        v22 -= v24 >> 1;
      }
    }

    *std::string::size_type v22 = v7;
    uint64_t v28 = (char *)(v22 + 1);
    uint64_t v29 = (regex_t **)a1[8];
    if (v29 != v6)
    {
      stat v30 = v6;
      do
      {
        std::string::size_type v31 = *--v30;
        *--std::string::size_type v22 = v31;
      }

      while (v30 != v29);
    }

    off_t v32 = (char *)a1[9];
    int64_t v33 = v32 - (char *)v6;
    unsigned __int8 v34 = (void *)a1[8];
    a1[8] = v22;
    a1[9] = &v28[v33];
    a1[10] = v23;
    if (v34) {
      operator delete(v34);
    }
  }

  else if (v6 == (regex_t **)v8)
  {
    *size_t v6 = v7;
    a1[9] = v6 + 1;
  }

  else
  {
    unint64_t v10 = (char *)(v6 + 1);
    uint64_t v11 = v8 - 8;
    int v12 = (void *)a1[9];
    while (v11 < v8)
    {
      uint64_t v13 = *(void *)v11;
      v11 += 8;
      *v12++ = v13;
    }

    a1[9] = v12;
    if (v8 != v10) {
      memmove(&v8[-8 * ((v8 - v10) >> 3)], v6, v8 - v10);
    }
    *size_t v6 = v7;
  }

void sub_18061A244(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>( unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a1);
}

uint64_t *Security::CodeSigning::BundleDiskRep::checkPlainFile( uint64_t a1, Security::UnixPlusPlus::FileDesc *this, uint64_t a3)
{
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blkint size = v5;
  *(timespec *)v10.st_qspare = v5;
  v10.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v10.st_int size = v5;
  v10.st_mtimespeCC_SHA512_CTX c = v5;
  v10.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v10.st_uid = v5;
  v10.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)v9.st_qspare = v5;
  *(timespec *)&v10.st_dev = v5;
  *(timespec *)&v9.st_int size = v5;
  *(timespec *)&v9.st_blkint size = v5;
  v9.st_ctimespeCC_SHA512_CTX c = v5;
  v9.st_birthtimespeCC_SHA512_CTX c = v5;
  v9.st_atimespeCC_SHA512_CTX c = v5;
  v9.st_mtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v9.st_dev = v5;
  *(timespec *)&v9.st_uid = v5;
  Security::UnixPlusPlus::FileDesc::fstat(this, &v10);
  else {
    size_t v6 = *(const char **)a3;
  }
  CFURLRef result = (uint64_t *)lstat(v6, &v9);
  if ((_DWORD)result)
  {
    int v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }

  if (v10.st_ino != v9.st_ino || (v9.st_mode & 0xF000) != 0x8000) {
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)(a1 + 208), -67015, -67015);
  }
  return result;
}

const void **Security::CodeSigning::BundleDiskRep::setup(uint64_t a1, uint64_t a2)
{
  uint64_t v121 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(a1 + 177) = 0;
  *(_WORD *)(a1 + 72) = 0;
  uint64_t v104 = CFBundleCopyExecutableURL(*(CFBundleRef *)(a1 + 24));
  uint64_t v103 = (__CFURL *)_CFBundleCopyInfoPlistURL();
  memset(&v102, 170, sizeof(v102));
  uint64_t v4 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
  Security::cfStringRelease((Security *)&v102, v4);
  if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t size = v102.__r_.__value_.__s.__size_;
  }
  else {
    size_t size = v102.__r_.__value_.__l.__size_;
  }
  memset(v101, 170, sizeof(v101));
  size_t v6 = v101;
  std::string::basic_string[abi:ne180100]((uint64_t)v101, size + 9);
  if (SHIBYTE(v101[2]) < 0) {
    size_t v6 = (void **)v101[0];
  }
  if (size)
  {
    if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v7 = &v102;
    }
    else {
      uint64_t v7 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    memmove(v6, v7, size);
  }

  strcpy((char *)v6 + size, "/Contents");
  if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t v8 = v102.__r_.__value_.__s.__size_;
  }
  else {
    size_t v8 = v102.__r_.__value_.__l.__size_;
  }
  memset(v100, 170, sizeof(v100));
  stat v9 = v100;
  std::string::basic_string[abi:ne180100]((uint64_t)v100, v8 + 14);
  if (SHIBYTE(v100[2]) < 0) {
    stat v9 = (void **)v100[0];
  }
  if (v8)
  {
    if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      stat v10 = &v102;
    }
    else {
      stat v10 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    memmove(v9, v10, v8);
  }

  strcpy((char *)v9 + v8, "/Support Files");
  if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t v11 = v102.__r_.__value_.__s.__size_;
  }
  else {
    size_t v11 = v102.__r_.__value_.__l.__size_;
  }
  memset(&v118, 170, sizeof(v118));
  int v12 = &v118;
  std::string::basic_string[abi:ne180100]((uint64_t)&v118, v11 + 10);
  if ((v118.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    int v12 = (std::string *)v118.__r_.__value_.__r.__words[0];
  }
  if (v11)
  {
    if ((v102.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v13 = &v102;
    }
    else {
      uint64_t v13 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    memmove(v12, v13, v11);
  }

  strcpy((char *)v12 + v11, "/Versions/");
  __int128 v14 = "Current";
  if (a2 && *(void *)(a2 + 8)) {
    __int128 v14 = *(const char **)(a2 + 8);
  }
  std::string::size_type v15 = strlen(v14);
  uint64_t v16 = std::string::append(&v118, v14, v15);
  __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  *(void *)&__b[16] = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)__b = v17;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v18 = std::string::append((std::string *)__b, "/.", 2uLL);
  std::string __sz = *v18;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  if ((__b[23] & 0x80000000) != 0) {
    operator delete(*(void **)__b);
  }
  if (SHIBYTE(v101[2]) >= 0) {
    unint64_t v19 = v101;
  }
  else {
    unint64_t v19 = (void **)v101[0];
  }
  if (access((const char *)v19, 0))
  {
    if (SHIBYTE(v100[2]) >= 0) {
      uint64_t v20 = v100;
    }
    else {
      uint64_t v20 = (void **)v100[0];
    }
    if (!access((const char *)v20, 0))
    {
LABEL_149:
      char v22 = 0;
      goto LABEL_150;
    }

    if (a2 && *(_BYTE *)(a2 + 48)) {
      goto LABEL_272;
    }
    if ((char)__sz.__r_.__value_.__s.__size_ < 0)
    {
      if (!access(__sz.__r_.__value_.__l.__data_, 0))
      {
        std::string::__init_copy_ctor_external(&v98, __sz.__r_.__value_.__l.__data_, __sz.__r_.__value_.__l.__size_);
        goto LABEL_61;
      }
    }

    else if (!access((const char *)&__sz, 0))
    {
      std::string v98 = __sz;
LABEL_61:
      if ((v98.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v23 = &v98;
      }
      else {
        std::string::size_type v23 = (std::string *)v98.__r_.__value_.__r.__words[0];
      }
      *(void *)__b = Security::makeCFURL((Security *)v23, 0LL, 0LL, v21);
      uint64_t Unique = _CFBundleCreateUnique();
      Security::CFRef<__CFURL const*>::~CFRef((const void **)__b);
      if (!Unique) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA04LL);
      }
      unint64_t v25 = *(const void **)(a1 + 24);
      if (v25) {
        CFRelease(v25);
      }
      *(void *)(a1 + 24) = Unique;
      else {
        std::string v97 = v102;
      }
      memset(&__p, 170, sizeof(__p));
      std::string::basic_string[abi:ne180100]<0>(&__p, "Current");
      memset(__b, 170, sizeof(__b));
      if ((v97.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v26 = v97.__r_.__value_.__s.__size_;
      }
      else {
        size_t v26 = v97.__r_.__value_.__l.__size_;
      }
      memset(&v118, 170, sizeof(v118));
      uint64_t v27 = &v118;
      std::string::basic_string[abi:ne180100]((uint64_t)&v118, v26 + 17);
      if ((v118.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v27 = (std::string *)v118.__r_.__value_.__r.__words[0];
      }
      if (v26)
      {
        if ((v97.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v28 = &v97;
        }
        else {
          uint64_t v28 = (std::string *)v97.__r_.__value_.__r.__words[0];
        }
        memmove(v27, v28, v26);
      }

      strcpy((char *)v27 + v26, "/Versions/Current");
      if ((v118.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v29 = &v118;
      }
      else {
        uint64_t v29 = (std::string *)v118.__r_.__value_.__r.__words[0];
      }
      ssize_t v30 = readlink((const char *)v29, __b, 0x3FFuLL);
      if (v30 >= 1)
      {
        __b[v30] = 0;
        std::string::basic_string[abi:ne180100]<0>(&v114, "(Current|");
        std::string::basic_string[abi:ne180100]<0>(&v110, __b);
        Security::CodeSigning::ResourceBuilder::escapeRE(&v108, (std::string::value_type *)&v110);
        if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v31 = &v108;
        }
        else {
          std::string::size_type v31 = (std::string *)v108.__r_.__value_.__r.__words[0];
        }
        if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v32 = v108.__r_.__value_.__s.__size_;
        }
        else {
          std::string::size_type v32 = v108.__r_.__value_.__l.__size_;
        }
        int64_t v33 = std::string::append(&v114, (const std::string::value_type *)v31, v32);
        __int128 v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
        v118.__r_.__value_.__l.__cap_ = v33->__r_.__value_.__l.__cap_;
        *(_OWORD *)&v118.__r_.__value_.__l.__data_ = v34;
        v33->__r_.__value_.__l.__size_ = 0LL;
        v33->__r_.__value_.__l.__cap_ = 0LL;
        v33->__r_.__value_.__r.__words[0] = 0LL;
        std::string v35 = std::string::append(&v118, ")", 1uLL);
        std::string::size_type v36 = v35->__r_.__value_.__r.__words[0];
        v112[0] = (void *)v35->__r_.__value_.__l.__size_;
        *(void **)((char *)v112 + 7) = *(void **)((char *)&v35->__r_.__value_.__r.__words[1] + 7);
        unsigned __int8 v37 = v35->__r_.__value_.__s.__size_;
        v35->__r_.__value_.__l.__size_ = 0LL;
        v35->__r_.__value_.__l.__cap_ = 0LL;
        v35->__r_.__value_.__r.__words[0] = 0LL;
        __p.__r_.__value_.__r.__words[0] = v36;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v112[0];
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v112 + 7);
        __p.__r_.__value_.__s.__size_ = v37;
      }

      memset(&v108, 0, sizeof(v108));
      unint64_t v109 = 0xAAAAAAAA00000000LL;
      std::string::basic_string[abi:ne180100]<0>(&v118, "^Versions$");
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v118, 34, 0LL);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^Versions/[^/]+$");
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v118, 2, 0LL);
      std::string::basic_string[abi:ne180100]<0>(&v114, "^Versions/Current$");
      std::string::basic_string[abi:ne180100]<0>(&v110, "^(\\./)?(\\.\\.[^/]+|\\.?[^\\./][^/]*)$");
      std::string::size_type v38 = MEMORY[0x1895F87A8];
      v118.__r_.__value_.__r.__words[0] = MEMORY[0x1895F87A8];
      v118.__r_.__value_.__l.__size_ = 1174405120LL;
      v118.__r_.__value_.__l.__cap_ = (std::string::size_type)___ZN8Security11CodeSigning12DirValidator7requireERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke;
      std::string::size_type v119 = &__block_descriptor_tmp_60_14214;
      else {
        std::string v120 = v110;
      }
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v114, 4, &v118);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^(Versions/)?\\.DS_Store$");
      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)&v118, 9, 0LL);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^[^/]+$");
      v114.__r_.__value_.__r.__words[0] = v38;
      v114.__r_.__value_.__l.__size_ = 1174405120LL;
      v114.__r_.__value_.__l.__cap_ = (std::string::size_type)___ZN8Security11CodeSigning13BundleDiskRep21validateFrameworkRootENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke;
      std::string::size_type v115 = &__block_descriptor_tmp_14208;
      else {
        std::string v116 = __p;
      }
      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)&v118, 4, &v114);
      std::string::basic_string[abi:ne180100]<0>(v112, "^module\\.map$");
      std::string::basic_string[abi:ne180100]<0>(&v105, "^(\\./)?Versions/");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v40 = __p.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v40 = __p.__r_.__value_.__l.__size_;
      }
      int v41 = std::string::append(&v105, (const std::string::value_type *)p_p, v40);
      __int128 v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
      v106.__r_.__value_.__l.__cap_ = v41->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v42;
      v41->__r_.__value_.__l.__size_ = 0LL;
      v41->__r_.__value_.__l.__cap_ = 0LL;
      v41->__r_.__value_.__r.__words[0] = 0LL;
      std::string::size_type v43 = std::string::append(&v106, "/module\\.map$", 0xDuLL);
      __int128 v45 = (std::string::value_type *)v43->__r_.__value_.__r.__words[0];
      std::string::size_type v44 = v43->__r_.__value_.__l.__size_;
      v107[0] = v43->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v107 + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = *(_DWORD *)((char *)&v43->__r_.__value_.__r.__words[2] + 3);
      int v46 = (char)v43->__r_.__value_.__s.__size_;
      v43->__r_.__value_.__l.__size_ = 0LL;
      v43->__r_.__value_.__l.__cap_ = 0LL;
      v43->__r_.__value_.__r.__words[0] = 0LL;
      v118.__r_.__value_.__r.__words[0] = v38;
      v118.__r_.__value_.__l.__size_ = 1174405120LL;
      v118.__r_.__value_.__l.__cap_ = (std::string::size_type)___ZN8Security11CodeSigning12DirValidator5allowERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke;
      std::string::size_type v119 = &__block_descriptor_tmp_61_14212;
      if (v46 < 0)
      {
        std::string::__init_copy_ctor_external(&v120, v45, v44);
      }

      else
      {
        v120.__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
        v120.__r_.__value_.__l.__size_ = v44;
        LODWORD(v120.__r_.__value_.__r.__words[2]) = v107[0];
        *(_DWORD *)((char *)&v120.__r_.__value_.__r.__words[2] + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = *(_DWORD *)((char *)v107 + 3);
        v120.__r_.__value_.__s.__size_ = v46;
      }

      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)v112, 13, &v118);
      if (v46 < 0) {
        operator delete(v45);
      }
      if (v113 < 0) {
        operator delete(v112[0]);
      }
      Security::CodeSigning::DirValidator::validate((uint64_t)&v108, (uint64_t)&v97, 0xFFFEFA40);
      Security::CodeSigning::DirValidator::~DirValidator((uint64_t **)&v108);
      goto LABEL_149;
    }

    if (a2)
    {
LABEL_272:
      if (*(void *)(a2 + 8)) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA04LL);
      }
    }
  }

  else
  {
    memset(__b, 0, 24);
    *(void *)&__b[24] = 0xAAAAAAAA00000000LL;
    std::string::basic_string[abi:ne180100]<0>(&v118, "^Contents$");
    Security::CodeSigning::DirValidator::require((uint64_t)__b, (__int128 *)&v118, 2, 0LL);
    std::string::basic_string[abi:ne180100]<0>( &v118,  "^(\\.LSOverride|\\.DS_Store|Icon\r|\\.SoftwareDepot\\.tracking)$");
    Security::CodeSigning::DirValidator::allow((char **)__b, (__int128 *)&v118, 9, 0LL);
    Security::CodeSigning::DirValidator::validate((uint64_t)__b, (uint64_t)&v102, 0xFFFEFA3A);
    Security::CodeSigning::DirValidator::~DirValidator((uint64_t **)__b);
  }

  char v22 = 1;
LABEL_150:
  InfoDictionary = CFBundleGetInfoDictionary(*(CFBundleRef *)(a1 + 24));
  unint64_t Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"MainHTML");
  std::string::size_type v49 = CFDictionaryGetValue(InfoDictionary, @"IFMajorVersion");
  v114.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  int v50 = CFBundleCopyExecutableURL(*(CFBundleRef *)(a1 + 24));
  v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
  if (v50 && !Value)
  {
    if (!a2 || !*(void *)(a2 + 8))
    {
      if (v104) {
        Security::CodeSigning::BundleDiskRep::checkMoved((Security::CodeSigning::BundleDiskRep *)a1, v104, v50);
      }
      if (v103)
      {
        *(void *)__b = 0xAAAAAAAAAAAAAAAALL;
        __int128 v51 = (const __CFURL *)_CFBundleCopyInfoPlistURL();
        *(void *)__b = v51;
        if (v51) {
          Security::CodeSigning::BundleDiskRep::checkMoved((Security::CodeSigning::BundleDiskRep *)a1, v103, v51);
        }
        Security::CFRef<__CFURL const*>::~CFRef((const void **)__b);
      }
    }

    Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(a1 + 64), (CFTypeRef *)&v114.__r_.__value_.__l.__data_);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
    if (__b[23] >= 0) {
      char v52 = __b;
    }
    else {
      char v52 = *(char **)__b;
    }
    uint64_t v53 = Security::CodeSigning::DiskRep::bestFileGuess(v52);
    uint64_t v54 = (void *)(a1 + 104);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((void *)(a1 + 104), v53);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
    std::string::size_type v55 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(void))(*(void *)*v54
                                                                                                 + 144LL))(*v54);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v55, (uint64_t)__b);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
    int v56 = CFBundleGetInfoDictionary(*(CFBundleRef *)(a1 + 24));
    BOOL v58 = v56
       && (BOOL v57 = CFDictionaryGetValue(v56, @"CFBundlePackageType")) != 0LL
       && CFEqual(v57, @"APPL") != 0;
    (*(void (**)(_BYTE *__return_ptr))(*(void *)*v54 + 128LL))(__b);
    __int128 v69 = std::string::insert((std::string *)__b, 0LL, "bundle with ", 0xCuLL);
    std::string::size_type v70 = v69->__r_.__value_.__r.__words[0];
    v118.__r_.__value_.__r.__words[0] = v69->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v69->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v71 = v69->__r_.__value_.__s.__size_;
    v69->__r_.__value_.__l.__size_ = 0LL;
    v69->__r_.__value_.__l.__cap_ = 0LL;
    v69->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v72 = (void **)(a1 + 80);
    std::string::size_type v73 = v118.__r_.__value_.__r.__words[0];
    *(void *)(a1 + 8syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = v70;
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v73;
    *(void *)(a1 + 95) = *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7);
    *(_BYTE *)(a1 + 10Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v71;
    if ((__b[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__b);
      if (!v58)
      {
LABEL_209:
        *(_BYTE *)(a1 + 7Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v22 & v58;
        uint64_t v77 = &v114;
LABEL_210:
        Security::CFRef<__CFURL const*>::~CFRef((const void **)&v77->__r_.__value_.__l.__data_);
        goto LABEL_213;
      }
    }

    else if (!v58)
    {
      goto LABEL_209;
    }

    std::operator+<char>();
    *(_OWORD *)uint64_t v72 = *(_OWORD *)__b;
    *(void *)(a1 + 96) = *(void *)&__b[16];
    goto LABEL_209;
  }

  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v114.__r_.__value_.__l.__data_);
  if (Value)
  {
    CFTypeID v59 = CFGetTypeID(Value);
    if (v59 != CFStringGetTypeID()) {
      goto LABEL_265;
    }
    Security::cfString((std::string *)__b, Value);
    CFURLRef v60 = CFBundleCopySupportFilesDirectoryURL(*(CFBundleRef *)(a1 + 24));
    v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
    if (__b[23] >= 0) {
      uint64_t v62 = (Security *)__b;
    }
    else {
      uint64_t v62 = *(Security **)__b;
    }
    CFURLRef CFURL = Security::makeCFURL(v62, 0LL, (uint64_t)v60, v61);
    size_t v64 = *(const void **)(a1 + 64);
    if (v64) {
      CFRelease(v64);
    }
    *(void *)(a1 + 64) = CFURL;
    Security::CFRef<__CFURL const*>::~CFRef((const void **)&v118.__r_.__value_.__l.__data_);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
    if (!*(void *)(a1 + 64)) {
LABEL_265:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    std::string v65 = (Security::CodeSigning::FileDiskRep *)operator new(0x30uLL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
    if (__b[23] >= 0) {
      int v66 = __b;
    }
    else {
      int v66 = *(char **)__b;
    }
    Security::CodeSigning::FileDiskRep::FileDiskRep(v65, v66);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((void *)(a1 + 104), (uint64_t)v65);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v67, (uint64_t)__b);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
    if (*(char *)(a1 + 103) < 0)
    {
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = 13LL;
      uint64_t v68 = *(char **)(a1 + 80);
    }

    else
    {
      uint64_t v68 = (char *)(a1 + 80);
      *(_BYTE *)(a1 + 10Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 13;
    }

    strcpy(v68, "widget bundle");
    *(_BYTE *)(a1 + 7Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 1;
  }

  else
  {
    v118.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    v118.__r_.__value_.__r.__words[0] = _CFBundleCopyInfoPlistURL();
    if (v118.__r_.__value_.__r.__words[0])
    {
      Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(a1 + 64), (CFTypeRef *)&v118.__r_.__value_.__l.__data_);
      unint64_t v74 = (Security::CodeSigning::FileDiskRep *)operator new(0x30uLL);
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
      if (__b[23] >= 0) {
        __int128 v75 = __b;
      }
      else {
        __int128 v75 = *(char **)__b;
      }
      Security::CodeSigning::FileDiskRep::FileDiskRep(v74, v75);
      Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((void *)(a1 + 104), (uint64_t)v74);
      if ((__b[23] & 0x80000000) != 0) {
        operator delete(*(void **)__b);
      }
      uint64_t v76 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(void))(**(void **)(a1 + 104) + 144LL))(*(void *)(a1 + 104));
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(__b, a1);
      Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v76, (uint64_t)__b);
      if ((__b[23] & 0x80000000) != 0) {
        operator delete(*(void **)__b);
      }
      if (v49)
      {
        *(_BYTE *)(a1 + 72) = 1;
        std::string::__assign_external((std::string *)(a1 + 80), "installer package bundle", 0x18uLL);
      }

      else
      {
        if (*(char *)(a1 + 103) < 0)
        {
          *(void *)(a1 + 8_Block_object_dispose(va, 8) = 6LL;
          CFNumberRef v96 = *(char **)(a1 + 80);
        }

        else
        {
          CFNumberRef v96 = (char *)(a1 + 80);
          *(_BYTE *)(a1 + 10Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 6;
        }

        strcpy(v96, "bundle");
      }

      uint64_t v77 = &v118;
      goto LABEL_210;
    }

    Security::CFRef<__CFURL const*>::~CFRef((const void **)&v118.__r_.__value_.__l.__data_);
    memset(__b, 170, 24);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 56LL))(&v118, a1);
    memset(__b, 0, 24);
    if ((v118.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v79 = &v118;
    }
    else {
      uint64_t v79 = (std::string *)v118.__r_.__value_.__r.__words[0];
    }
    *(_OWORD *)&v114.__r_.__value_.__l.__data_ = (unint64_t)v79;
    uint64_t v80 = fts_open(&v114.__r_.__value_.__l.__data_, 28, 0LL);
    char v81 = 1;
LABEL_226:
    char v82 = v81;
    while (1)
    {
      uint64_t v83 = fts_read(v80);
      if (!v83) {
        break;
      }
      fts_unint64_t info = v83->fts_info;
      if (fts_info == 8 || fts_info == 11)
      {
        fts_path = v83->fts_path;
        if (!strcmp(&fts_path[v83->fts_pathlen - 5], ".dist"))
        {
          uint64_t v87 = __b[23];
          if (__b[23] < 0) {
            uint64_t v87 = *(void *)&__b[8];
          }
          if (v87) {
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
          }
          std::string::__assign_external((std::string *)__b, fts_path);
        }
      }

      else if (fts_info == 1)
      {
        char v81 = 0;
        if ((v82 & 1) == 0)
        {
          fts_set(v80, v83, 4);
          char v81 = 0;
        }

        goto LABEL_226;
      }
    }

    fts_close(v80);
    uint64_t v89 = __b[23];
    if (__b[23] < 0) {
      uint64_t v89 = *(void *)&__b[8];
    }
    if (!v89) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    }
    if (__b[23] >= 0) {
      uint64_t v90 = (Security *)__b;
    }
    else {
      uint64_t v90 = *(Security **)__b;
    }
    CFURLRef v91 = Security::makeCFURL(v90, 0LL, 0LL, v88);
    int v92 = *(const void **)(a1 + 64);
    if (v92) {
      CFRelease(v92);
    }
    *(void *)(a1 + 64) = v91;
    __int128 v93 = (Security::CodeSigning::FileDiskRep *)operator new(0x30uLL);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(&v118, a1);
    if ((v118.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v94 = &v118;
    }
    else {
      uint64_t v94 = (std::string *)v118.__r_.__value_.__r.__words[0];
    }
    Security::CodeSigning::FileDiskRep::FileDiskRep(v93, (char *)v94);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((void *)(a1 + 104), (uint64_t)v93);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 40LL))(&v118, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v95, (uint64_t)&v118);
    *(_BYTE *)(a1 + 72) = 1;
    std::string::__assign_external((std::string *)(a1 + 80), "installer package bundle", 0x18uLL);
    if ((__b[23] & 0x80000000) != 0) {
      operator delete(*(void **)__b);
    }
  }

LABEL_213:
  if (SHIBYTE(v100[2]) < 0) {
    operator delete(v100[0]);
  }
  if (SHIBYTE(v101[2]) < 0) {
    operator delete(v101[0]);
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v103);
  return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v104);
}

void sub_18061B5C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, const void *a42, const void *a43, void *a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a72 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  Security::CFRef<__CFURL const*>::~CFRef(&a42);
  Security::CFRef<__CFURL const*>::~CFRef(&a43);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::DirValidator::require(uint64_t a1, __int128 *a2, int a3, const void *a4)
{
  size_t v8 = operator new(0x48uLL);
  Security::CodeSigning::DirValidator::Rule::Rule((uint64_t)v8, a2, a3 | 0x10, a4);
  Security::CodeSigning::DirValidator::addRule((char **)a1, (uint64_t)v8);
  ++*(_DWORD *)(a1 + 24);
}

void sub_18061BB38(_Unwind_Exception *a1)
{
}

void Security::CodeSigning::DirValidator::allow(char **a1, __int128 *a2, int a3, const void *a4)
{
  size_t v8 = operator new(0x48uLL);
  Security::CodeSigning::DirValidator::Rule::Rule((uint64_t)v8, a2, a3, a4);
  Security::CodeSigning::DirValidator::addRule(a1, (uint64_t)v8);
}

void sub_18061BBA8(_Unwind_Exception *a1)
{
}

uint64_t *Security::CodeSigning::BundleDiskRep::checkMoved( Security::CodeSigning::BundleDiskRep *this, const __CFURL *a2, const __CFURL *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  memset(__b, 170, sizeof(__b));
  memset(__s2, 170, sizeof(__s2));
  Security::cfString((Security *)v12, a2);
  if (v13 >= 0) {
    size_t v6 = v12;
  }
  else {
    size_t v6 = (void **)v12[0];
  }
  if (realpath_DARWIN_EXTSN((const char *)v6, __b))
  {
    Security::cfString((Security *)__p, a3);
    if (v11 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    BOOL v8 = realpath_DARWIN_EXTSN((const char *)v7, __s2) == 0LL;
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    BOOL v8 = 1;
  }

  if (v13 < 0) {
    operator delete(v12[0]);
  }
  if (v8) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3DLL);
  }
  CFURLRef result = (uint64_t *)strcmp(__b, __s2);
  if ((_DWORD)result) {
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)this + 26, -67011, -67011);
  }
  return result;
}

void sub_18061BD04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer(void *a1, uint64_t a2)
{
  v11[0] = a1 + 1;
  v11[1] = 0xAAAAAAAAAAAAAA01LL;
  uint64_t v4 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v4) {
    Security::UnixError::throwMe(v4);
  }
  if (a2)
  {
    timespec v5 = (unsigned int *)(a2 + 8);
    do
      unsigned int v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  if (*a1)
  {
    uint64_t v7 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v8 = __ldxr(v7);
      unsigned int v9 = v8 - 1;
    }

    while (__stxr(v9, v7));
    if (!v9 && *a1) {
      (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
    }
  }

  *a1 = a2;
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v11);
}

void ___ZN8Security11CodeSigning13BundleDiskRep21validateFrameworkRootENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke( uint64_t a1@<X0>, std::string::value_type *a2@<X1>, std::string *a3@<X8>)
{
  unsigned int v8 = *(const std::string::value_type **)(a1 + 32);
  uint64_t v7 = a1 + 32;
  unsigned int v6 = v8;
  int v9 = *(char *)(v7 + 23);
  if (v9 >= 0) {
    stat v10 = (const std::string::value_type *)v7;
  }
  else {
    stat v10 = v6;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(v7 + 8);
  }
  int v12 = std::string::append(&v22, v10, v11);
  __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v14 = std::string::append(&v23, "/", 1uLL);
  __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0LL;
  v14->__r_.__value_.__l.__cap_ = 0LL;
  v14->__r_.__value_.__r.__words[0] = 0LL;
  Security::CodeSigning::ResourceBuilder::escapeRE(&__p, a2);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = __p.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v18 = std::string::append(&v24, (const std::string::value_type *)p_p, size);
  __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v20 = std::string::append(&v25, "$", 1uLL);
  *a3 = *v20;
  v20->__r_.__value_.__l.__size_ = 0LL;
  v20->__r_.__value_.__l.__cap_ = 0LL;
  v20->__r_.__value_.__r.__words[0] = 0LL;
}

void sub_18061BF50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN8Security11CodeSigning12DirValidator5allowERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke( uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__l.__cap_ = *(void *)(a1 + 48);
  }

void __copy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE( uint64_t a1, uint64_t a2)
{
  size_t v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
  }

  else
  {
    __int128 v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__l.__cap_ = *(void *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }

void __destroy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE( uint64_t a1)
{
}

void ___ZN8Security11CodeSigning12DirValidator7requireERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke( uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__l.__cap_ = *(void *)(a1 + 48);
  }

void Security::CodeSigning::DirValidator::addRule(char **a1, uint64_t a2)
{
  timespec v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 3;
    unint64_t v9 = v8 + 1;
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v12 = (char *)operator new(8 * v11);
    }

    else
    {
      int v12 = 0LL;
    }

    __int128 v13 = &v12[8 * v8];
    *(void *)__int128 v13 = a2;
    unsigned int v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }

      while (v5 != v7);
      timespec v5 = *a1;
    }

    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }

  else
  {
    *(void *)timespec v5 = a2;
    unsigned int v6 = v5 + 8;
  }

  a1[1] = v6;
}

void *Security::RefPointer<Security::DynamicHash>::~RefPointer(void *a1)
{
  size_t v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01LL;
  __int128 v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    unint64_t v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1 = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

Security::CodeSigning::CodeDirectory::Builder *Security::CodeSigning::CodeDirectory::Builder::Builder( Security::CodeSigning::CodeDirectory::Builder *this, Security::CodeSigning::CodeDirectory *a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  *(_DWORD ++*(void *)this = 0;
  *((void *)this + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  *((void *)this + 2) = (char *)this + 24;
  *((_DWORD *)this + 1syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = -1;
  *((_BYTE *)this + 44) = 0;
  *((_DWORD *)this + 1_Block_object_dispose(va, 8) = 0;
  *((_DWORD *)this + 19) = (_DWORD)a2;
  *((_BYTE *)this + 8syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0;
  *(_OWORD *)((char *)this + 8_Block_object_dispose(va, 8) = 0u;
  *((void *)this + 27) = 0LL;
  *((void *)this + 26) = 0LL;
  *(_OWORD *)((char *)this + Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104) = 0u;
  *(_OWORD *)((char *)this + 12syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)this + 177) = 0u;
  *((void *)this + 25) = (char *)this + 208;
  *((_DWORD *)this + 56) = 0;
  *((void *)this + 29) = 0LL;
  __int128 v3 = Security::CodeSigning::CodeDirectory::hashFor(a2);
  Security::Mutex::Mutex(&v8);
  unint64_t v4 = (unsigned int *)((char *)v3 + 8);
  do
    unsigned int v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  uint64_t v7 = v3;
  *((_DWORD *)this + 21) = (*(uint64_t (**)(Security::CCHashInstance *))(*(void *)v3 + 16LL))(v3);
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&v7);
  *((void *)this + 1) = calloc(0xBuLL, *((unsigned int *)this + 21));
  return this;
}

void sub_18061C310(_Unwind_Exception *a1)
{
}

void Security::CodeSigning::CodeDirectory::Builder::~Builder( Security::CodeSigning::CodeDirectory::Builder *this)
{
}

void *Security::CodeSigning::CodeDirectory::Builder::specialSlot( Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2, const __CFData *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v13[2] = v6;
  void v13[3] = v6;
  v13[0] = v6;
  v13[1] = v6;
  uint64_t v7 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this + 19));
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)v13 + 8));
  pthread_mutex_t v8 = (unsigned int *)((char *)v7 + 8);
  do
    unsigned int v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  *(void *)&v13[0] = v7;
  uint64_t BytePtr = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  (*(void (**)(Security::CCHashInstance *, const UInt8 *, CFIndex))(*(void *)v7 + 24LL))( v7,  BytePtr,  Length);
  (*(void (**)(void, void))(**(void **)&v13[0] + 32LL))( *(void *)&v13[0],  *((void *)this + 1) + *((_DWORD *)this + 21) * (a2 - 1));
  std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)this + 2, a2, a2);
  return Security::RefPointer<Security::DynamicHash>::~RefPointer(v13);
}

void sub_18061C510( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t Security::CodeSigning::CodeDirectory::Builder::size( Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2)
{
  unint64_t v4 = *((void *)this + 7);
  if (v4) {
    goto LABEL_3;
  }
  v5.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blkstd::string::size_type size = v5;
  *(timespec *)v15.st_qspare = v5;
  v15.st_birthtimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_std::string::size_type size = v5;
  v15.st_mtimespeCC_SHA512_CTX c = v5;
  v15.st_ctimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_uid = v5;
  v15.st_atimespeCC_SHA512_CTX c = v5;
  *(timespec *)&v15.st_dev = v5;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), &v15);
  uint64_t v6 = *((void *)this + 6);
  unint64_t v4 = v15.st_size - v6;
  BOOL v7 = v15.st_size == v6;
  *((void *)this + 7) = v15.st_size - v6;
  if (!v7) {
LABEL_3:
  }
    unint64_t v4 = (v4 - 1) / *((void *)this + 8) + 1;
  *((void *)this + 1_Block_object_dispose(va, 8) = v4;
  uint64_t v8 = 96LL;
  if (a2 < 0x20500) {
    uint64_t v8 = 88LL;
  }
  if (a2 < 0x20400) {
    v8 -= 24LL;
  }
  if (a2 >= 0x20300) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = v8 - 12;
  }
  if (a2 >> 9 < 0x101) {
    v9 -= 4LL;
  }
  else {
    uint64_t v10 = *((unsigned __int8 *)this + 111);
  }
  uint64_t v11 = v9 + *((void *)this + 20) + v10 + 1;
  if (*((char *)this + 135) < 0)
  {
    uint64_t v12 = *((void *)this + 15);
    if (!v12) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  uint64_t v12 = *((unsigned __int8 *)this + 135);
  if (*((_BYTE *)this + 135)) {
LABEL_18:
  }
    v11 += v12 + 1;
LABEL_19:
  uint64_t v13 = *((unsigned int *)this + 21);
  unint64_t result = v11 + (*((void *)this + 17) + v4) * v13;
  if (*((_BYTE *)this + 192) || *((void *)this + 27)) {
    result += v4 * v13;
  }
  if (result <= v9) {
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  return result;
}

uint64_t Security::CodeSigning::CodeDirectory::Builder::build( Security::CodeSigning::CodeDirectory::Builder *this)
{
  uint64_t v105 = *MEMORY[0x1895F89C0];
  else {
    uint64_t v2 = *((unsigned __int8 *)this + 111);
  }
  uint64_t v3 = *((unsigned __int8 *)this + 135);
  else {
    uint64_t v4 = *((unsigned __int8 *)this + 135);
  }
  if (*((_BYTE *)this + 192) || *((void *)this + 27))
  {
    unsigned int v5 = 132352;
  }

  else
  {
    unsigned int v5 = 132352;
    if (!*((_DWORD *)this + 56))
    {
      if (*((void *)this + 22))
      {
        unsigned int v5 = 132096;
      }

      else if (*((_DWORD *)this + 15))
      {
        unsigned int v5 = 131840;
      }

      else
      {
        if ((v3 & 0x80) != 0) {
          uint64_t v3 = *((void *)this + 15);
        }
        if (v3) {
          unsigned int v5 = 131584;
        }
        else {
          unsigned int v5 = 131328;
        }
      }
    }
  }

  if (*((_DWORD *)this + 37)) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA44LL);
  }
  size_t v6 = Security::CodeSigning::CodeDirectory::Builder::size(this, v5);
  unsigned int v7 = v6;
  uint64_t v8 = (int8x8_t *)calloc(1uLL, v6);
  *((void *)this + 29) = v8;
  if (!v8) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  unint64_t v9 = (int8x16_t *)v8;
  v8->i32[0] = 34397946;
  v8->i32[1] = bswap32(v7);
  v8[1].i32[0] = bswap32(v5);
  v8[1].i32[1] = bswap32(*((_DWORD *)this + 18));
  void v8[3] = vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)((char *)this + 136)));
  unint64_t v10 = *((void *)this + 7);
  if (HIDWORD(v10))
  {
    void v8[7] = (int8x8_t)bswap64(v10);
    unsigned int v11 = -1;
  }

  else
  {
    unsigned int v11 = bswap32(v10);
  }

  size_t v12 = v2 + 1;
  v8[4].i32[0] = v11;
  v8[4].i8[5] = *((_DWORD *)this + 19);
  v8[4].i8[6] = *((_BYTE *)this + 80);
  v8[4].i8[4] = *((_DWORD *)this + 21);
  unint64_t v13 = *((void *)this + 8);
  frexp((double)v13, &v99);
  __int8 v14 = v99 - 1;
  if (!v13) {
    __int8 v14 = 0;
  }
  v9[2].i8[7] = v14;
  void v9[4] = vrev64q_s8(*(int8x16_t *)((char *)this + 168));
  v9[5].i64[0] = bswap64(*((void *)this + 23));
  v9[5].i32[2] = bswap32(*((_DWORD *)this + 56));
  uint64_t v15 = 96LL;
  if (v5 < 0x20500) {
    uint64_t v15 = 88LL;
  }
  if (v5 < 0x20400) {
    v15 -= 24LL;
  }
  if (v5 < 0x20300) {
    v15 -= 12LL;
  }
  if (v5 >= 0x20200) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = v15 - 4;
  }
  __int128 v17 = (const void *)*((void *)this + 19);
  if (v17)
  {
    v9[2].i32[3] = bswap32(v16);
    memcpy(&v9->i8[v16], v17, *((void *)this + 20));
    v16 += *((void *)this + 20);
  }

  uint64_t v18 = (void *)((char *)this + 88);
  uint64_t v19 = *((void *)this + 29);
  *(_DWORD *)(v19 + 2syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = bswap32(v16);
  memcpy((void *)(v19 + v16), v18, v12);
  size_t v20 = v16 + v12;
  if (*((char *)this + 135) < 0)
  {
    if (!*((void *)this + 15)) {
      goto LABEL_43;
    }
  }

  else if (!*((_BYTE *)this + 135))
  {
    goto LABEL_43;
  }

  BOOL v21 = (void *)((char *)this + 112);
  uint64_t v22 = *((void *)this + 29);
  *(_DWORD *)(v22 + 4_Block_object_dispose(va, 8) = bswap32(v20);
  unsigned int v23 = bswap32(*(_DWORD *)(v22 + 8));
  if ((_DWORD)v20) {
    BOOL v24 = v23 >= 0x20200;
  }
  else {
    BOOL v24 = 0;
  }
  std::string v25 = (void *)(v22 + v20);
  if (v24) {
    size_t v26 = v25;
  }
  else {
    size_t v26 = 0LL;
  }
  memcpy(v26, v21, v4 + 1);
  v20 += v4 + 1;
LABEL_43:
  if (*((_BYTE *)this + 192) || *((void *)this + 27))
  {
    uint64_t v27 = *((void *)this + 29);
    *(_DWORD *)(v27 + 92) = bswap32(v20);
    uint64_t v28 = *((unsigned int *)this + 21);
    v20 += *((void *)this + 18) * v28;
  }

  else
  {
    uint64_t v28 = *((unsigned int *)this + 21);
    uint64_t v27 = *((void *)this + 29);
  }

  uint64_t v29 = *((void *)this + 17);
  size_t v30 = v29 * v28;
  unsigned int v31 = v29 * v28 + v20;
  *(_DWORD *)(v27 + 16) = bswap32(v31);
  bzero((void *)(v27 + v31 + -((_DWORD)v29 * *(unsigned __int8 *)(v27 + 36))), v30);
  if (*((void *)this + 17))
  {
    unint64_t v32 = 1LL;
    unint64_t v33 = 0xFFFFFFFF00000000LL;
    do
    {
      memcpy( (void *)(bswap32(*(_DWORD *)(*((void *)this + 29) + 16LL))
               + *((void *)this + 29)
               + ((uint64_t)(v33 * *(unsigned __int8 *)(*((void *)this + 29) + 36LL)) >> 32)),
        (const void *)(*((void *)this + 1) + (*((_DWORD *)this + 21) * (v32++ - 1))),
        *((unsigned int *)this + 21));
      v33 -= 0x100000000LL;
    }

    while (v32 <= *((void *)this + 17));
  }

  Security::UnixPlusPlus::FileDesc::seek( (Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10),  *((void *)this + 6));
  if (*((void *)this + 18))
  {
    LODWORD(v34) = 0;
    size_t v35 = *((void *)this + 7);
    do
    {
      size_t v36 = *((void *)this + 8);
      if (v36 >= v35) {
        size_t v37 = v35;
      }
      else {
        size_t v37 = *((void *)this + 8);
      }
      if (v36) {
        size_t v38 = v37;
      }
      else {
        size_t v38 = v35;
      }
      unint64_t v104 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v39 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v103[2] = v39;
      v103[3] = v39;
      v103[0] = v39;
      v103[1] = v39;
      std::string::size_type v40 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this
                                                                                                  + 19));
      Security::Mutex::Mutex((pthread_mutex_t *)((char *)v103 + 8));
      int v41 = (unsigned int *)((char *)v40 + 8);
      do
        unsigned int v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
      *(void *)&v103[0] = v40;
      char v43 = *((_BYTE *)this + 44);
      uint64_t v44 = *((void *)this + 29);
      unsigned int v45 = *(_DWORD *)(v44 + 16);
      int v46 = *(unsigned __int8 *)(v44 + 36);
      int v101 = *((_DWORD *)this + 10);
      char v102 = v43;
      v100[0] = MEMORY[0x1895F87A8];
      v100[1] = 0x40000000LL;
      v100[2] = ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke;
      v100[3] = &__block_descriptor_tmp_36_14252;
      v100[4] = v40;
      Security::CodeSigning::scanFileData(&v101, v38, (uint64_t)v100);
      (*(void (**)(Security::CCHashInstance *, uint64_t))(*(void *)v40 + 32LL))( v40,  bswap32(v45) + v44 + v46 * (uint64_t)(int)v34);
      if (*((_BYTE *)this + 192) && !*((void *)this + 27))
      {
        uint64_t v47 = *((void *)this + 29);
        if (bswap32(*(_DWORD *)(v47 + 8)) > 0x204FF && (unsigned int v48 = *(_DWORD *)(v47 + 92)) != 0) {
          std::string::size_type v49 = (void *)(bswap32(v48) + v47 + *(unsigned __int8 *)(v47 + 36) * (uint64_t)(int)v34);
        }
        else {
          std::string::size_type v49 = 0LL;
        }
        memcpy( v49,  (const void *)(bswap32(*(_DWORD *)(v47 + 16)) + v47 + *(unsigned __int8 *)(v47 + 36) * (uint64_t)(int)v34),  *(unsigned __int8 *)(v47 + 36));
      }

      v35 -= v38;
      Security::RefPointer<Security::DynamicHash>::~RefPointer(v103);
      unint64_t v34 = (v34 + 1);
    }

    while (*((void *)this + 18) > v34);
  }

  __int128 v51 = (char *)this + 208;
  int v50 = (char *)*((void *)this + 26);
  if (!v50) {
    return *((void *)this + 29);
  }
  unsigned int v52 = *((_DWORD *)this + 19);
  uint64_t v53 = (char *)this + 208;
  do
  {
    unsigned int v54 = *((_DWORD *)v50 + 8);
    BOOL v55 = v54 >= v52;
    if (v54 >= v52) {
      int v56 = (char **)v50;
    }
    else {
      int v56 = (char **)(v50 + 8);
    }
    if (v55) {
      uint64_t v53 = v50;
    }
    int v50 = *v56;
  }

  while (*v56);
  if (v53 == v51 || v52 < *((_DWORD *)v53 + 8)) {
    return *((void *)this + 29);
  }
  uint64_t v57 = *((void *)this + 29);
  if (bswap32(*(_DWORD *)(v57 + 8)) <= 0x204FF)
  {
    CFURLRef v60 = 0LL;
  }

  else
  {
    unsigned int v58 = *(_DWORD *)(v57 + 92);
    uint64_t v59 = bswap32(v58) + v57;
    CFURLRef v60 = v58 ? (void *)v59 : 0LL;
  }

  uint64_t BytePtr = CFDataGetBytePtr(*((CFDataRef *)v53 + 5));
  memcpy(v60, BytePtr, *((void *)this + 18) * *((unsigned int *)this + 21));
  uint64_t v62 = (char *)*((void *)this + 26);
  if (!v62) {
    return *((void *)this + 29);
  }
  unsigned int v63 = *((_DWORD *)v53 + 8);
  size_t v64 = (char *)this + 208;
  std::string v65 = (char *)*((void *)this + 26);
  do
  {
    unsigned int v66 = *((_DWORD *)v65 + 8);
    BOOL v67 = v66 >= v63;
    if (v66 >= v63) {
      uint64_t v68 = (char **)v65;
    }
    else {
      uint64_t v68 = (char **)(v65 + 8);
    }
    if (v67) {
      size_t v64 = v65;
    }
    std::string v65 = *v68;
  }

  while (*v68);
  if (v64 == v51 || v63 < *((_DWORD *)v64 + 8)) {
    return *((void *)this + 29);
  }
  __int128 v69 = (char *)*((void *)v64 + 1);
  if (v69)
  {
    do
    {
      std::string::size_type v70 = v69;
      __int128 v69 = *(char **)v69;
    }

    while (v69);
  }

  else
  {
    unsigned __int8 v71 = v64;
    do
    {
      std::string::size_type v70 = (char *)*((void *)v71 + 2);
      BOOL v91 = *(void *)v70 == (void)v71;
      unsigned __int8 v71 = v70;
    }

    while (!v91);
  }

  --*((void *)this + 27);
  uint64_t v72 = *(void *)v64;
  std::string::size_type v73 = v64;
  if (*(void *)v64)
  {
    unint64_t v74 = (char *)*((void *)v64 + 1);
    if (!v74)
    {
      std::string::size_type v73 = v64;
      goto LABEL_119;
    }

    do
    {
      std::string::size_type v73 = v74;
      unint64_t v74 = *(char **)v74;
    }

    while (v74);
  }

  uint64_t v72 = *((void *)v73 + 1);
  if (v72)
  {
LABEL_119:
    int v75 = 0;
    *(void *)(v72 + 16) = *((void *)v73 + 2);
    goto LABEL_120;
  }

  int v75 = 1;
LABEL_120:
  uint64_t v76 = (char **)*((void *)v73 + 2);
  uint64_t v77 = *v76;
  if (*v76 == v73)
  {
    Security::UnixPlusPlus::FileDesc *v76 = (char *)v72;
    if (v73 == v62)
    {
      uint64_t v77 = 0LL;
      uint64_t v62 = (char *)v72;
    }

    else
    {
      uint64_t v77 = v76[1];
    }
  }

  else
  {
    v76[1] = (char *)v72;
  }

  int v78 = v73[24];
  if (v73 != v64)
  {
    uint64_t v79 = *((void *)v64 + 2);
    *((void *)v73 + 2) = v79;
    *(void *)(v79 + 8LL * (**((void **)v64 + 2) != (void)v64)) = v73;
    uint64_t v80 = *(void *)v64;
    *(void *)std::string::size_type v73 = *(void *)v64;
    *(void *)(v80 + 16) = v73;
    uint64_t v81 = *((void *)v64 + 1);
    *((void *)v73 + 1) = v81;
    if (v81) {
      *(void *)(v81 + 16) = v73;
    }
    v73[24] = v64[24];
    if (v62 == v64) {
      uint64_t v62 = v73;
    }
  }

  if (!v78 || !v62) {
    goto LABEL_184;
  }
  if (!v75)
  {
    *(_BYTE *)(v72 + 24) = 1;
    goto LABEL_184;
  }

  while (1)
  {
    uint64_t v82 = *((void *)v77 + 2);
    if (!v77[24])
    {
      v77[24] = 1;
      *(_BYTE *)(v82 + 24) = 0;
      uint64_t v88 = *((void *)v77 + 1);
      *(void *)uint64_t v82 = v88;
      if (v88) {
        *(void *)(v88 + 16) = v82;
      }
      *((void *)v77 + 2) = *(void *)(v82 + 16);
      *(void *)(*(void *)(v82 + 16) + 8LL * (**(void **)(v82 + 16) != v82)) = v77;
      *((void *)v77 + 1) = v82;
      *(void *)(v82 + 16) = v77;
      uint64_t v77 = *(char **)v82;
    }

    uint64_t v89 = *(char **)v77;
    if (*(void *)v77 && !v89[24]) {
      goto LABEL_179;
    }
    uint64_t v90 = (char *)*((void *)v77 + 1);
    if (v90 && !v90[24])
    {
      if (v89 && !v89[24])
      {
LABEL_179:
        uint64_t v90 = v77;
      }

      else
      {
        v90[24] = 1;
        v77[24] = 0;
        uint64_t v96 = *(void *)v90;
        *((void *)v77 + 1) = *(void *)v90;
        if (v96) {
          *(void *)(v96 + 16) = v77;
        }
        *((void *)v90 + 2) = *((void *)v77 + 2);
        *(void *)(*((void *)v77 + 2) + 8LL * (**((void **)v77 + 2) != (void)v77)) = v90;
        *(void *)uint64_t v90 = v77;
        *((void *)v77 + 2) = v90;
        uint64_t v89 = v77;
      }

      uint64_t v93 = *((void *)v90 + 2);
      v90[24] = *(_BYTE *)(v93 + 24);
      *(_BYTE *)(v93 + 24) = 1;
      v89[24] = 1;
      uint64_t v94 = *(uint64_t **)v93;
      uint64_t v97 = *(void *)(*(void *)v93 + 8LL);
      *(void *)uint64_t v93 = v97;
      if (v97) {
        *(void *)(v97 + 16) = v93;
      }
      v94[2] = *(void *)(v93 + 16);
      *(void *)(*(void *)(v93 + 16) + 8LL * (**(void **)(v93 + 16) != v9std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 3)) = v94;
      v94[1] = v93;
      goto LABEL_183;
    }

    v77[24] = 0;
    uint64_t v87 = (char *)*((void *)v77 + 2);
    if (v87[24]) {
      BOOL v91 = v87 == v62;
    }
    else {
      BOOL v91 = 1;
    }
    if (v91) {
      goto LABEL_164;
    }
LABEL_161:
    uint64_t v77 = *(char **)(*((void *)v87 + 2) + 8LL * (**((void **)v87 + 2) == (void)v87));
  }

  if (!v77[24])
  {
    v77[24] = 1;
    *(_BYTE *)(v82 + 24) = 0;
    uint64_t v83 = *(uint64_t **)(v82 + 8);
    uint64_t v84 = *v83;
    *(void *)(v82 + _Block_object_dispose(va, 8) = *v83;
    if (v84) {
      *(void *)(v84 + 16) = v82;
    }
    v83[2] = *(void *)(v82 + 16);
    *(void *)(*(void *)(v82 + 16) + 8LL * (**(void **)(v82 + 16) != v82)) = v83;
    uint64_t *v83 = v82;
    *(void *)(v82 + 16) = v83;
    uint64_t v77 = *(char **)(*(void *)v77 + 8LL);
  }

  std::string::size_type v85 = *(char **)v77;
  if (!*(void *)v77 || v85[24])
  {
    uint64_t v86 = (char *)*((void *)v77 + 1);
    if (v86 && !v86[24]) {
      goto LABEL_170;
    }
    v77[24] = 0;
    uint64_t v87 = (char *)*((void *)v77 + 2);
    if (v87 == v62)
    {
      uint64_t v87 = v62;
LABEL_164:
      v87[24] = 1;
      goto LABEL_184;
    }

    if (!v87[24]) {
      goto LABEL_164;
    }
    goto LABEL_161;
  }

  uint64_t v86 = (char *)*((void *)v77 + 1);
  if (v86 && !v86[24])
  {
LABEL_170:
    std::string::size_type v85 = v77;
  }

  else
  {
    v85[24] = 1;
    v77[24] = 0;
    uint64_t v92 = *((void *)v85 + 1);
    *(void *)uint64_t v77 = v92;
    if (v92) {
      *(void *)(v92 + 16) = v77;
    }
    *((void *)v85 + 2) = *((void *)v77 + 2);
    *(void *)(*((void *)v77 + 2) + 8LL * (**((void **)v77 + 2) != (void)v77)) = v85;
    *((void *)v85 + 1) = v77;
    *((void *)v77 + 2) = v85;
    uint64_t v86 = v77;
  }

  uint64_t v93 = *((void *)v85 + 2);
  v85[24] = *(_BYTE *)(v93 + 24);
  *(_BYTE *)(v93 + 24) = 1;
  v86[24] = 1;
  uint64_t v94 = *(uint64_t **)(v93 + 8);
  uint64_t v95 = *v94;
  *(void *)(v93 + _Block_object_dispose(va, 8) = *v94;
  if (v95) {
    *(void *)(v95 + 16) = v93;
  }
  v94[2] = *(void *)(v93 + 16);
  *(void *)(*(void *)(v93 + 16) + 8LL * (**(void **)(v93 + 16) != v9std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 3)) = v94;
  uint64_t *v94 = v93;
LABEL_183:
  *(void *)(v93 + 16) = v94;
LABEL_184:
  Security::CFRef<__CFData const*>::~CFRef((const void **)v64 + 5);
  operator delete(v64);
  return *((void *)this + 29);
}

void sub_18061D084( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

const char *Security::CodeSigning::CodeDirectory::canonicalSlotName( Security::CodeSigning::CodeDirectory *this)
{
  int v1 = (int)this;
  int v2 = (int)this;
  unint64_t result = "CodeRequirements";
  switch(v2)
  {
    case 0:
      unint64_t result = "CodeDirectory";
      break;
    case 1:
LABEL_7:
      unint64_t result = 0LL;
      break;
    case 2:
      return result;
    case 3:
      unint64_t result = "CodeResources";
      break;
    case 4:
      unint64_t result = "CodeTopDirectory";
      break;
    case 5:
      unint64_t result = "CodeEntitlements";
      break;
    case 6:
      unint64_t result = "CodeRepSpecific";
      break;
    case 7:
      unint64_t result = "CodeEntitlementDER";
      break;
    case 8:
      unint64_t result = "LaunchConstraintSelf";
      break;
    case 9:
      unint64_t result = "LaunchConstraintParent";
      break;
    case 10:
      unint64_t result = "LaunchConstraintResponsible";
      break;
    case 11:
      unint64_t result = "LibraryConstraint";
      break;
    default:
      switch(v1)
      {
        case 4096:
          unint64_t result = "CodeRequirements-1";
          break;
        case 4097:
          unint64_t result = "CodeRequirements-2";
          break;
        case 4098:
          unint64_t result = "CodeRequirements-3";
          break;
        case 4099:
          unint64_t result = "CodeRequirements-4";
          break;
        case 4100:
          unint64_t result = "CodeRequirements-5";
          break;
        default:
          if (v1 != 0x10000) {
            goto LABEL_7;
          }
          unint64_t result = "CodeSignature";
          break;
      }

      break;
  }

  return result;
}

uint64_t Security::CodeSigning::CodeDirectory::slotAttributes(Security::CodeSigning::CodeDirectory *this)
{
  if ((int)this <= 4095)
  {
    if ((_DWORD)this) {
      return 0LL;
    }
    return 3LL;
  }

  if ((int)this < 0x10000)
  {
    return 0LL;
  }

  return (_DWORD)this == 0x10000 || (_DWORD)this == 65537;
}

BOOL Security::CodeSigning::CodeDirectory::validateSlot( Security::CodeSigning::CodeDirectory *this, const void *a2, uint64_t a3, int a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (os_log_s *)secLogObjForScope("codedir");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)stat buf = 134218240;
    *(void *)&uint8_t buf[4] = this;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    _os_log_debug_impl(&dword_1804F4000, v8, OS_LOG_TYPE_DEBUG, "%p validating slot %d", buf, 0x12u);
  }

  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v23 = v9;
  __int128 v24 = v9;
  *(_OWORD *)stat buf = v9;
  *(_OWORD *)&uint8_t buf[16] = v9;
  unint64_t v10 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned __int8 *)this
                                                                                              + 37));
  Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
  unsigned int v11 = (unsigned int *)((char *)v10 + 8);
  do
    unsigned int v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  *(void *)stat buf = v10;
  memset(__p, 170, sizeof(__p));
  size_t v13 = (*(uint64_t (**)(Security::CCHashInstance *))(*(void *)v10 + 16LL))(v10);
  std::vector<unsigned char>::vector(__p, v13);
  uint64_t v14 = *(void *)buf;
  uint64_t v15 = __p[0];
  (*(void (**)(void, const void *, uint64_t))(**(void **)buf + 24LL))(*(void *)buf, a2, a3);
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 32LL))(v14, v15);
  uint64_t v16 = __p[0];
  LODWORD(v14) = *((_DWORD *)this + 4);
  int v17 = *((unsigned __int8 *)this + 36);
  size_t v18 = (*(uint64_t (**)(void))(**(void **)buf + 16LL))(*(void *)buf);
  int v19 = memcmp(v16, (char *)this + bswap32(v14) + v17 * (uint64_t)a4, v18);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  Security::RefPointer<Security::DynamicHash>::~RefPointer(buf);
  return v19 == 0;
}

void sub_18061D404( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

Security::CCHashInstance *Security::CodeSigning::CodeDirectory::hashFor( Security::CodeSigning::CodeDirectory *this)
{
  switch((int)this)
  {
    case 1:
      int v1 = (Security::CCHashInstance *)operator new(0x20uLL);
      Security::CCHashInstance::CCHashInstance(v1, 8u, 0LL);
      break;
    case 2:
      int v1 = (Security::CCHashInstance *)operator new(0x20uLL);
      Security::CCHashInstance::CCHashInstance(v1, 0xAu, 0LL);
      break;
    case 3:
      int v1 = (Security::CCHashInstance *)operator new(0x20uLL);
      Security::CCHashInstance::CCHashInstance(v1, 0xAu, 20LL);
      break;
    case 4:
      int v1 = (Security::CCHashInstance *)operator new(0x20uLL);
      Security::CCHashInstance::CCHashInstance(v1, 0xBu, 0LL);
      break;
    default:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0DLL);
  }

  return v1;
}

void sub_18061D4F0(_Unwind_Exception *a1)
{
}

void *std::vector<unsigned char>::vector(void *a1, size_t __sz)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (__sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v4 = (char *)operator new(__sz);
    *a1 = v4;
    unsigned int v5 = &v4[__sz];
    a1[2] = &v4[__sz];
    bzero(v4, __sz);
    a1[1] = v5;
  }

  return a1;
}

void sub_18061D574(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24LL))(*(void *)(a1 + 32));
}

void Security::CodeSigning::scanFileData(int *a1, size_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  v6.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v18.st_blkstd::string::size_type size = v6;
  *(timespec *)v18.st_qspare = v6;
  v18.st_birthtimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v18.st_std::string::size_type size = v6;
  v18.st_mtimespeCC_SHA512_CTX c = v6;
  v18.st_ctimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v18.st_uid = v6;
  v18.st_atimespeCC_SHA512_CTX c = v6;
  *(timespec *)&v18.st_dev = v6;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a1, &v18);
  if (v18.st_blksize <= 0x10000) {
    st_blkstd::string::size_type size = 0x10000LL;
  }
  else {
    st_blkstd::string::size_type size = v18.st_blksize;
  }
  uint64_t v8 = valloc(st_blksize);
  if (v8)
  {
    __int128 v9 = v8;
    while (1)
    {
      size_t v10 = a2;
      if (a2 >= st_blksize || a2 == 0) {
        size_t v12 = st_blksize;
      }
      else {
        size_t v12 = a2;
      }
      ssize_t v13 = read(*a1, v9, v12);
      ssize_t v14 = v13;
      if (v13 == -1)
      {
        if (*__error() != 35)
        {
          int v17 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v17);
        }
      }

      else
      {
        if (v13) {
          goto LABEL_18;
        }
        *((_BYTE *)a1 + 4) = 1;
        uint64_t v15 = (os_log_s *)secLogObjForScope("unixio");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          int v16 = *a1;
          *(_DWORD *)stat buf = 67109120;
          int v20 = v16;
          _os_log_debug_impl(&dword_1804F4000, v15, OS_LOG_TYPE_DEBUG, "%d end of data", buf, 8u);
        }
      }

      ssize_t v14 = 0LL;
LABEL_18:
      if (!*((_BYTE *)a1 + 4))
      {
        (*(void (**)(uint64_t, void *, ssize_t))(a3 + 16))(a3, v9, v14);
        a2 = 0LL;
        if (!v10) {
          continue;
        }
        a2 = v10 - v14;
        if (v10 != v14) {
          continue;
        }
      }

      free(v9);
      return;
    }
  }

void sub_18061D750(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }

  _Unwind_Resume(exception_object);
}

void sub_18061D788(_Unwind_Exception *a1)
{
}

void sub_18061D794(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18061D79CLL);
  }
  __clang_call_terminate(a1);
}

BOOL Security::CodeSigning::CodeDirectory::slotIsPresent( Security::CodeSigning::CodeDirectory *this, signed int a2)
{
  BOOL result = 0LL;
  if ((signed int)-bswap32(*((_DWORD *)this + 6)) <= a2)
  {
    if ((int)bswap32(*((_DWORD *)this + 7)) > a2 && (uint64_t v4 = *((unsigned __int8 *)this + 36), *((_BYTE *)this + 36)))
    {
      unsigned int v5 = (unsigned __int8 *)this + bswap32(*((_DWORD *)this + 4)) + (int)v4 * a2;
      uint64_t v6 = v4 - 1;
      do
      {
        int v7 = *v5++;
        BOOL result = v7 != 0;
        if (v7) {
          BOOL v8 = 1;
        }
        else {
          BOOL v8 = v6 == 0;
        }
        --v6;
      }

      while (!v8);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void Security::CodeSigning::CodeDirectory::multipleHashFileData( uint64_t a1, size_t a2, void *a3, uint64_t a4)
{
  std::string::size_type v40 = 0LL;
  uint64_t v41 = 0LL;
  __int128 v39 = &v40;
  uint64_t v6 = a3 + 1;
  unsigned int v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      int v7 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v5 + 7);
      BOOL v8 = &Security::CodeSigning::hashPriorities;
      do
      {
        int v10 = *v8++;
        int v9 = v10;
        BOOL v11 = v10 == (_DWORD)v7 || v9 == 0;
      }

      while (!v11);
      if (v9)
      {
        size_t v12 = Security::CodeSigning::CodeDirectory::hashFor(v7);
        ssize_t v13 = v40;
        ssize_t v14 = &v40;
        uint64_t v15 = &v40;
        if (v40)
        {
          unsigned int v16 = *((_DWORD *)v5 + 7);
          while (1)
          {
            while (1)
            {
              uint64_t v15 = (uint64_t **)v13;
              unsigned int v17 = *((_DWORD *)v13 + 8);
              if (v16 >= v17) {
                break;
              }
              ssize_t v13 = *v15;
              ssize_t v14 = v15;
              if (!*v15) {
                goto LABEL_17;
              }
            }

            if (v17 >= v16) {
              break;
            }
            ssize_t v13 = v15[1];
            if (!v13)
            {
              ssize_t v14 = v15 + 1;
              goto LABEL_17;
            }
          }
        }

        else
        {
LABEL_17:
          unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
          stat v18 = operator new(0x70uLL);
          CFMutableDictionaryRef CFMutableDictionary = (CFMutableDictionaryRef)v18;
          char v43 = &v40;
          LOBYTE(v44) = 0;
          *((_DWORD *)v18 + _Block_object_dispose(va, 8) = *((_DWORD *)v5 + 7);
          void v18[5] = 0LL;
          Security::Mutex::Mutex((pthread_mutex_t *)(v18 + 6));
          LOBYTE(v44) = 1;
          void *v18 = 0LL;
          v18[1] = 0LL;
          void v18[2] = v15;
          *ssize_t v14 = v18;
          if (*v39)
          {
            __int128 v39 = (uint64_t **)*v39;
            stat v18 = *v14;
          }

          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v40, v18);
          uint64_t v15 = (uint64_t **)CFMutableDictionary;
          ++v41;
          CFMutableDictionaryRef CFMutableDictionary = 0LL;
          std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)&CFMutableDictionary);
        }

        CFMutableDictionaryRef CFMutableDictionary = (CFMutableDictionaryRef)(v15 + 6);
        char v43 = (uint64_t **)0xAAAAAAAAAAAAAAAALL;
        int v19 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(v15 + 6));
        if ((_DWORD)v19) {
          Security::UnixError::throwMe(v19);
        }
        LOBYTE(v4Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 1;
        int v20 = (unsigned int *)((char *)v12 + 8);
        do
          unsigned int v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
        uint64_t v22 = v15[5];
        if (v22)
        {
          __int128 v23 = (unsigned int *)(v22 + 1);
          do
          {
            unsigned int v24 = __ldxr(v23);
            unsigned int v25 = v24 - 1;
          }

          while (__stxr(v25, v23));
          if (!v25)
          {
            uint64_t v26 = v15[5];
            if (v26) {
              (*(void (**)(uint64_t *))(*v26 + 8))(v26);
            }
          }
        }

        void v15[5] = (uint64_t *)v12;
        Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&CFMutableDictionary);
      }

      uint64_t v27 = (void *)v5[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          uint64_t v27 = (void *)*v27;
        }

        while (v27);
      }

      else
      {
        do
        {
          uint64_t v28 = (void *)v5[2];
          BOOL v11 = *v28 == (void)v5;
          unsigned int v5 = v28;
        }

        while (!v11);
      }

      unsigned int v5 = v28;
    }

    while (v28 != v6);
  }

  int v37 = *(_DWORD *)a1;
  char v38 = *(_BYTE *)(a1 + 4);
  v35[0] = MEMORY[0x1895F87A8];
  v35[1] = 1174405120LL;
  v35[2] = ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke;
  v35[3] = &__block_descriptor_tmp_14258;
  std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100]((uint64_t)v36, &v39);
  Security::CodeSigning::scanFileData(&v37, a2, (uint64_t)v35);
  CFMutableDictionaryRef CFMutableDictionary = Security::makeCFMutableDictionary(v29);
  size_t v30 = v39;
  if (v39 != &v40)
  {
    do
    {
      (*(void (**)(uint64_t, void, uint64_t *))(a4 + 16))(a4, *((unsigned int *)v30 + 8), v30[5]);
      unsigned int v31 = v30[1];
      if (v31)
      {
        do
        {
          unint64_t v32 = (uint64_t **)v31;
          unsigned int v31 = (uint64_t *)*v31;
        }

        while (v31);
      }

      else
      {
        do
        {
          unint64_t v32 = (uint64_t **)v30[2];
          BOOL v11 = *v32 == (uint64_t *)v30;
          size_t v30 = v32;
        }

        while (!v11);
      }

      size_t v30 = v32;
    }

    while (v32 != &v40);
  }

  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&CFMutableDictionary);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v36[1]);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v40);
}

void sub_18061DAF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
}

uint64_t ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(result + 32);
  uint64_t v4 = (void *)(result + 40);
  if (v3 != (void *)(result + 40))
  {
    do
    {
      BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v3[5] + 24LL))(v3[5], a2, a3);
      int v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          int v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          BOOL v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }

        while (!v9);
      }

      uint64_t v3 = v8;
    }

    while (v8 != v4);
  }

  return result;
}

uint64_t std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100]( uint64_t a1, void *a2)
{
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  unsigned int v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = *(uint64_t **)(a1 + 8);
      int v7 = v3;
      uint64_t v8 = *(void *)(a1 + 8);
      BOOL v9 = v3;
      if (v6)
      {
        do
        {
          int v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }

        while (v8);
      }

      else
      {
        do
        {
          int v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          BOOL v9 = v7;
        }

        while (v10);
      }

      unsigned int v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6) {
          size_t v12 = v7;
        }
        else {
          size_t v12 = v3;
        }
        if (v6) {
          ssize_t v13 = v7 + 1;
        }
        else {
          ssize_t v13 = v3;
        }
      }

      else
      {
        size_t v12 = v3;
        ssize_t v13 = v3;
        if (v6)
        {
          ssize_t v13 = v3;
          while (1)
          {
            while (1)
            {
              size_t v12 = (uint64_t **)v6;
              unsigned int v20 = *((_DWORD *)v6 + 8);
              if (v11 >= v20) {
                break;
              }
              uint64_t v6 = *v12;
              ssize_t v13 = v12;
              if (!*v12) {
                goto LABEL_15;
              }
            }

            if (v20 >= v11) {
              break;
            }
            ssize_t v13 = v12 + 1;
            uint64_t v6 = v12[1];
            if (!v6) {
              goto LABEL_15;
            }
          }
        }
      }

      if (!*v13)
      {
LABEL_15:
        unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
        ssize_t v14 = (char *)operator new(0x70uLL);
        v22[0] = v14;
        v22[1] = v3;
        LOBYTE(v2Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 0;
        *((_DWORD *)v14 + _Block_object_dispose(va, 8) = *((_DWORD *)v5 + 8);
        Security::Mutex::Mutex((pthread_mutex_t *)(v14 + 48));
        uint64_t v15 = v5[5];
        if (v15)
        {
          unsigned int v16 = (unsigned int *)(v15 + 8);
          do
            unsigned int v17 = __ldxr(v16);
          while (__stxr(v17 + 1, v16));
          uint64_t v15 = v5[5];
        }

        *((void *)v14 + 5) = v15;
        LOBYTE(v2Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 1;
        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( (uint64_t **)a1,  (uint64_t)v12,  v13,  (uint64_t *)v14);
        v22[0] = 0LL;
        std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)v22);
      }

      stat v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          int v19 = v18;
          stat v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          int v19 = (void *)v5[2];
          BOOL v10 = *v19 == (void)v5;
          unsigned int v5 = v19;
        }

        while (!v10);
      }

      unsigned int v5 = v19;
    }

    while (v19 != v4);
  }

  return a1;
}

void sub_18061DD94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void **Security::CFRef<__CFDictionary *>::~CFRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy( void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(a1[1]);
    Security::RefPointer<Security::DynamicHash>::~RefPointer(a1 + 5);
    operator delete(a1);
  }

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      Security::RefPointer<Security::DynamicHash>::~RefPointer(v1 + 5);
    }
    operator delete(v1);
  }

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE( uint64_t a1, uint64_t a2)
{
  return std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100]( a1 + 32,  (void *)(a2 + 32));
}

void __destroy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE( uint64_t a1)
{
}

BOOL Security::DynamicHash::verify(Security::DynamicHash *this, const unsigned __int8 *a2)
{
  v11[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = (*(uint64_t (**)(Security::DynamicHash *))(*(void *)this + 16LL))(this);
  uint64_t v5 = MEMORY[0x1895F8858](v4);
  uint64_t v8 = (char *)v11 - v7;
  if (v5) {
    memset((char *)v11 - v7, 170, v6);
  }
  (*(void (**)(Security::DynamicHash *, char *))(*(void *)this + 32LL))(this, v8);
  size_t v9 = (*(uint64_t (**)(Security::DynamicHash *))(*(void *)this + 16LL))(this);
  return memcmp(v8, a2, v9) == 0;
}

CFDataRef Security::CodeSigning::CodeDirectory::cdhash(Security::CodeSigning::CodeDirectory *this, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v16[2] = v4;
  unint64_t v16[3] = v4;
  v16[0] = v4;
  v16[1] = v4;
  uint64_t v5 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned __int8 *)this
                                                                                             + 37));
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)v16 + 8));
  size_t v6 = (unsigned int *)((char *)v5 + 8);
  do
    unsigned int v7 = __ldxr(v6);
  while (__stxr(v7 + 1, v6));
  *(void *)&v16[0] = v5;
  memset(__p, 170, sizeof(__p));
  size_t v8 = (*(uint64_t (**)(Security::CCHashInstance *))(*(void *)v5 + 16LL))(v5);
  std::vector<unsigned char>::vector(__p, v8);
  (*(void (**)(void, Security::CodeSigning::CodeDirectory *, void))(**(void **)&v16[0] + 24LL))( *(void *)&v16[0],  this,  bswap32(*((_DWORD *)this + 1)));
  (*(void (**)(void, void *))(**(void **)&v16[0] + 32LL))(*(void *)&v16[0], __p[0]);
  size_t v9 = (const UInt8 *)__p[0];
  BOOL v10 = *(uint64_t (**)(void))(**(void **)&v16[0] + 16LL);
  if (a2)
  {
    unint64_t v11 = v10();
    if (v11 >= 0x14) {
      CFIndex v12 = 20LL;
    }
    else {
      CFIndex v12 = v11;
    }
  }

  else
  {
    CFIndex v12 = v10();
  }

  CFDataRef v13 = CFDataCreate(0LL, v9, v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  Security::RefPointer<Security::DynamicHash>::~RefPointer(v16);
  return v13;
}

void sub_18061E0AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&a13);
  _Unwind_Resume(a1);
}

uint64_t __SecTaskGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef SecTaskCopyDebugDescription(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  pid_t pidp = -1431655766;
  __int128 v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)atoken = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&atoken[16] = v2;
  audit_token_to_au32((audit_token_t *)atoken, 0LL, 0LL, 0LL, 0LL, 0LL, &pidp, 0LL, 0LL);
  *(void *)ssize_t v14 = 0xE00000001LL;
  int v15 = 1;
  pid_t v16 = pidp;
  memset(atoken, 170, sizeof(atoken));
  size_t v11 = 648LL;
  if (sysctl(v14, 4u, atoken, &v11, 0LL, 0LL) == -1 || !v11)
  {
    __int128 v4 = __error();
    uint64_t v3 = strerror(*v4);
  }

  else
  {
    uint64_t v3 = &atoken[243];
  }

  uint64_t v5 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v6 = pidp;
  uint64_t v7 = *(unsigned __int8 *)(a1 + 48);
  size_t v8 = *(const __CFDictionary **)(a1 + 56);
  if (v8) {
    CFIndex Count = CFDictionaryGetCount(v8);
  }
  else {
    CFIndex Count = 0xFFFFFFFFLL;
  }
  return CFStringCreateWithFormat(v5, 0LL, @"%s[%d]/%d#%d LF=%d", v3, v6, v7, Count, *(unsigned int *)(a1 + 64));
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  SecTaskRef result = (SecTaskRef)_CFRuntimeCreateInstance();
  if (result)
  {
    __int128 v4 = *(_OWORD *)&token->val[4];
    *((_OWORD *)result + 1) = *(_OWORD *)token->val;
    *((_OWORD *)result + 2) = v4;
    *((_BYTE *)result + 4_Block_object_dispose(va, 8) = 0;
    *((void *)result + 7) = 0LL;
  }

  return result;
}

SecTaskRef SecTaskCreateWithXPCMessage(SecTaskRef result)
{
  *(void *)&__int128 v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v3.val = v1;
  *(_OWORD *)&v3.val[4] = v1;
  if (result)
  {
    if (MEMORY[0x186E0087C]() == MEMORY[0x1895F9250])
    {
      xpc_dictionary_get_audit_token();
      audit_token_t v2 = v3;
      return SecTaskCreateWithAuditToken(0LL, &v2);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return SecTaskCopyIdentifier((uint64_t)task, 11LL, error);
}

CFStringRef SecTaskCopyIdentifier(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t v5 = bswap32(0xAAAAAAAA);
  if ((v5 - 1048577) >= 0xFFF00007)
  {
    size_t v9 = (char *)malloc((v5 + 1));
    if (v9)
    {
      BOOL v10 = v9;
      if (csops_task(a1))
      {
        CFStringRef v6 = 0LL;
        int v7 = *__error();
      }

      else
      {
        v10[v5] = 0;
        CFStringRef v6 = CFStringCreateWithCString(0LL, v10 + 8, 0x8000100u);
        int v7 = 0;
      }

      free(v10);
    }

    else
    {
      CFStringRef v6 = 0LL;
      int v7 = 12;
    }
  }

  else
  {
    CFStringRef v6 = 0LL;
    int v7 = 22;
  }

  if (a3 && v7) {
    *a3 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F58], v7, 0LL);
  }
  return v6;
}

CFStringRef SecTaskCopyTeamIdentifier(uint64_t a1, CFErrorRef *a2)
{
  return SecTaskCopyIdentifier(a1, 14LL, a2);
}

uint32_t SecTaskGetCodeSignStatus(SecTaskRef task)
{
  else {
    return 0;
  }
}

CFDictionaryRef SecTaskCopyValuesForEntitlements(SecTaskRef task, CFArrayRef entitlements, CFErrorRef *error)
{
  CFTypeID TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(task)) {
    return 0LL;
  }
  int v7 = *((unsigned __int8 *)task + 48);
  if (!*((_BYTE *)task + 48))
  {
    SecTaskLoadEntitlements((uint64_t)task, error);
    int v7 = *((unsigned __int8 *)task + 48);
  }

  if (v7 != 1) {
    return 0LL;
  }
  uint64_t Count = CFArrayGetCount(entitlements);
  size_t v9 = CFGetAllocator(task);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v9, Count, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (*((void *)task + 7) && Count >= 1)
  {
    for (CFIndex i = 0LL; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(entitlements, i);
      unint64_t Value = CFDictionaryGetValue(*((CFDictionaryRef *)task + 7), ValueAtIndex);
      if (Value) {
        CFDictionarySetValue(Mutable, ValueAtIndex, Value);
      }
    }
  }

  return Mutable;
}

uint64_t SecTaskEntitlementsValidated(uint64_t a1)
{
  else {
    return 0LL;
  }
}

uint64_t SecTaskValidateForLightweightCodeRequirementData(_OWORD *a1, const __CFData *a2, CFErrorRef *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  CFTypeID TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(a1))
  {
    if (a3)
    {
      CFDataRef v13 = (const __CFString *)*MEMORY[0x189604F50];
      ssize_t v14 = @"Invalid task reference";
      int v15 = -67675;
LABEL_13:
      uint64_t v11 = 0LL;
      *a3 = createError(v13, v15, v14);
      return v11;
    }

    return 0LL;
  }

  if (!a2 || !CFDataGetLength(a2))
  {
    if (a3)
    {
      CFDataRef v13 = (const __CFString *)*MEMORY[0x189604F50];
      ssize_t v14 = @"Invalid requirement";
      int v15 = -50;
      goto LABEL_13;
    }

    return 0LL;
  }

  bzero(&v18, 0x404uLL);
  uint64_t BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  __int128 v9 = a1[2];
  v17[0] = a1[1];
  v17[1] = v9;
  uint64_t v10 = amfi_launch_constraint_matches_process((uint64_t)v17, (uint64_t)BytePtr, Length, (uint64_t)&v18);
  uint64_t v11 = v10;
  if (a3 && (v10 & 1) == 0)
  {
    CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v19, 0x8000100u);
    if (v18 <= 5) {
      *a3 = createError(**((const __CFString ***)&unk_189677888 + v18), dword_180659B54[v18], v12);
    }
    CFRelease(v12);
  }

  return v11;
}

CFErrorRef createError(const __CFString *a1, int a2, const void *a3)
{
  CFStringRef v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x189604F38], a3);
  return CFErrorCreate(v6, a1, a2, Mutable);
}

void Security::PerThreadPointer<Security::CodeSigning::PerThread>::destructor(void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

CFTypeID SecCodeGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 96);
}

void sub_18061E83C(void *a1)
{
}

OSStatus SecCodeCopySelf(SecCSFlags flags, SecCodeRef *self)
{
  if (!flags)
  {
    LODWORD(valuePtr) = getpid();
    audit_token_t v2 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
    unsigned int valuePtr = Security::makeCFMutableDictionary(v2, v3, v4, @"pid", v2, v2);
    uint64_t v5 = Security::CFRef<__CFNumber const*>::~CFRef(&v7);
    Security::CodeSigning::SecCode::autoLocateGuest((Security::CodeSigning::SecCode *)v5, v6);
  }

  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
}

uint64_t sub_18061E8B0(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      __int128 v4 = __cxa_begin_catch(a1);
      if (v4[36] == 8)
      {
        uint64_t v5 = 4294900247LL;
        goto LABEL_8;
      }

      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      __int128 v4 = __cxa_begin_catch(a1);
      unsigned int v9 = v4[36];
      if (v9 <= 0x1A)
      {
        uint64_t v5 = 4294900263LL;
        int v10 = 1 << v9;
        if ((v10 & 0x800108) != 0) {
          goto LABEL_8;
        }
        if ((v10 & 0x4014000) != 0)
        {
          uint64_t v5 = 4294900264LL;
          goto LABEL_8;
        }
      }

void sub_18061EA00(_Unwind_Exception *a1)
{
}

const void **Security::CFRef<__CFNumber const*>::~CFRef(const void **a1)
{
  audit_token_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t SecCodeGetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, int *a3)
{
  if ((_DWORD)a2)
  {
    uint64_t v7 = 4294900226LL;
LABEL_8:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }

  uint64_t v4 = *((void *)Security::CodeSigning::SecCode::required(a1, a2) + 2);
  if (!v4)
  {
    int v5 = 1;
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_6;
  }

  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 104LL))(v4);
  if (!a3)
  {
LABEL_6:
    uint64_t v7 = 4294900227LL;
    goto LABEL_8;
  }

void *Security::CodeSigning::SecCode::required(Security::CodeSigning::SecCode *this, __SecCode *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
  }

  return result;
}

uint64_t SecCodeSetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    uint64_t v9 = 4294900226LL;
    goto LABEL_6;
  }

  CFStringRef v6 = Security::CodeSigning::SecCode::required(a1, a2);
  uint64_t v7 = v6[2];
  if (!v7)
  {
    uint64_t v9 = 4294900256LL;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v9);
  }

  (*(void (**)(uint64_t, void *, __SecCode *, uint64_t))(*(void *)v7 + 112LL))(v7, v6, a2, a3);
  return 0LL;
}

OSStatus SecCodeCopyStaticCode(SecCodeRef code, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (flags >= 2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  int v5 = Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  CFStringRef v6 = v5;
  if (!v5[24])
  {
    (*(void (**)(_BYTE *))(*(void *)v5 + 80LL))(v5);
    v6[24] = 1;
  }

  uint64_t v7 = (Security::SecCFObject *)*((void *)v6 + 4);
  if (v7)
  {
    size_t v8 = (unsigned __int8 *)v7 - 8;
    do
      unsigned __int8 v9 = __ldaxr(v8);
    while (__stlxr(1u, v8));
    if ((v9 & 1) != 0)
    {
      int v10 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(void *)v7 + 16LL))(v7);
      CFRetain(v10);
    }
  }

  unint64_t v24 = (unint64_t)v7;
  if (flags)
  {
    uint64_t v11 = (*(uint64_t (**)(void))(**((void **)v7 + 4) + 80LL))(*((void *)v7 + 4));
    if (v11 && *(void *)(v11 + 32))
    {
      unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v27 = v12;
      __int128 v28 = v12;
      *(_OWORD *)unsigned int v25 = v12;
      __int128 v26 = v12;
      (*(void (**)(void **__return_ptr))(**(void **)(v24 + 32) + 40LL))(__p);
      if (v23 >= 0) {
        CFDataRef v13 = (char *)__p;
      }
      else {
        CFDataRef v13 = (char *)__p[0];
      }
      ssize_t v14 = Security::CodeSigning::DiskRep::bestGuess(v13, 0LL);
      Security::Mutex::Mutex((pthread_mutex_t *)&v25[1]);
      if (v14)
      {
        int v15 = (unsigned int *)(v14 + 8);
        do
          unsigned int v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }

      v25[0] = (Security::CodeSigning::DiskRep *)v14;
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v17 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
      int v19 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x288,  *(void *)(v17 + 200),  v18);
      Security::CodeSigning::SecStaticCode::SecStaticCode(v19, v25[0], 0);
      Security::SecPointerBase::assign((Security::SecPointerBase *)&v24, v19);
      Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v25);
    }

    uint64_t v7 = (Security::SecCFObject *)v24;
  }

  if (!v7)
  {
    uint64_t v20 = 0LL;
    if (staticCode) {
      goto LABEL_24;
    }
LABEL_26:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }

  uint64_t v20 = (const __SecCode *)Security::SecCFObject::handle(v7, 1);
  if (!staticCode) {
    goto LABEL_26;
  }
LABEL_24:
  *staticint64_t Code = v20;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v24);
  return 0;
}

void sub_18061F008( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  Security::SecCFObject::operator delete(v17);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(&a17);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  if (a2 == 6)
  {
    uint64_t v20 = __cxa_begin_catch(exception_object);
    if (v20[36] == 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  if (a2 != 5)
  {
    if (a2 == 4)
    {
      uint64_t v20 = __cxa_begin_catch(exception_object);
      unsigned int v22 = v20[36];
      if (v22 <= 0x1A)
      {
        int v23 = 1 << v22;
        if ((v23 & 0x800108) != 0 || (v23 & 0x4014000) != 0) {
          goto LABEL_17;
        }
      }

OSStatus SecCodeCopyHost(SecCodeRef guest, SecCSFlags flags, SecCodeRef *host)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = (Security::SecCFObject *)*((void *)Security::CodeSigning::SecCode::required(guest, *(__SecCode **)&flags) + 2);
  if (!v4)
  {
    size_t v8 = 0LL;
    unint64_t v10 = 0LL;
    if (host) {
      goto LABEL_8;
    }
LABEL_10:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }

  int v5 = (unsigned __int8 *)v4 - 8;
  do
    unsigned __int8 v6 = __ldaxr(v5);
  while (__stlxr(1u, v5));
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(void *)v4 + 16LL))(v4);
    CFRetain(v7);
  }

  unint64_t v10 = (unint64_t)v4;
  size_t v8 = (__SecCode *)Security::SecCFObject::handle(v4, 1);
  if (!host) {
    goto LABEL_10;
  }
LABEL_8:
  *host = v8;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0;
}

void sub_18061F2E0(void *a1, int a2, uint64_t a3, ...)
{
  switch(a2)
  {
    case 6:
      int v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24LL))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      int v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      unsigned __int8 v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24LL))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x18061F2A4LL);
}

void sub_18061F418(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCheckValidity(SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecCodeCheckValidityWithErrors(code, flags, requirement, 0LL);
}

OSStatus SecCodeCheckValidityWithErrors( SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  if ((flags & 0x1F7EDDEF) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t v5 = *(void *)&flags;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int8 v6 = (Security::CodeSigning::SecCode *)Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  unsigned int v7 = v6;
  if (v6)
  {
    int v8 = (unsigned __int8 *)v6 - 8;
    do
      unsigned __int8 v9 = __ldaxr(v8);
    while (__stlxr(1u, v8));
    if ((v9 & 1) != 0)
    {
      unint64_t v10 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecCode *))(*(void *)v6 + 16LL))(v6);
      CFRetain(v10);
    }
  }

  unint64_t v15 = (unint64_t)v7;
  Security::CodeSigning::SecCode::checkValidity(v7, v5);
  __int128 v12 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v11);
  if (v12)
  {
    unint64_t v13 = v15;
    if ((v5 & 0x800000) != 0)
    {
      (*(void (**)(void, unint64_t, void))(**(void **)(v15 + 16) + 120LL))( *(void *)(v15 + 16),  v15,  *((void *)v12 + 2));
    }

    else
    {
      if (!*(_BYTE *)(v15 + 24))
      {
        (*(void (**)(unint64_t))(*(void *)v15 + 80LL))(v15);
        *(_BYTE *)(v15 + 24) = 1;
      }

      if (!Security::CodeSigning::SecStaticCode::satisfiesRequirement( *(void *)(v13 + 32),  *((Security::CodeSigning::Requirement **)v12 + 2))) {
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA16LL);
      }
    }
  }

  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v15);
  return 0;
}

void sub_18061F590(void *a1, int a2, uint64_t a3, ...)
{
  switch(a2)
  {
    case 7:
      unsigned __int8 v6 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v6, v3);
      goto LABEL_32;
    case 6:
      unsigned int v7 = __cxa_begin_catch(a1);
      if (v7[36] == 8) {
        int v8 = -67049;
      }
      else {
        int v8 = (*(uint64_t (**)(_DWORD *))(*(void *)v7 + 24LL))(v7);
      }
      if (v3)
      {
LABEL_30:
        CFErrorRef v11 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v8, 0LL);
        goto LABEL_31;
      }

void sub_18061F7D0(_Unwind_Exception *a1)
{
}

char *Security::CodeSigning::SecRequirement::optional(char *this, __SecRequirement *a2)
{
  if (this)
  {
    if (!this) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
    }
  }

  return this;
}

OSStatus SecCodeCopySigningInformation(SecStaticCodeRef code, SecCSFlags flags, CFDictionaryRef *information)
{
  uint64_t v163 = *MEMORY[0x1895F89C0];
  char v144 = flags;
  if (flags >= 0x80) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v146 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = (char *)Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  unsigned __int8 v6 = v5;
  if (v5)
  {
    unsigned int v7 = (unsigned __int8 *)(v5 - 8);
    do
      unsigned __int8 v8 = __ldaxr(v7);
    while (__stlxr(1u, v7));
    if ((v8 & 1) != 0)
    {
      unsigned __int8 v9 = (const void *)(*(uint64_t (**)(char *))(*(void *)v5 + 16LL))(v5);
      CFRetain(v9);
    }
  }

  CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  unint64_t v146 = (unint64_t)v6;
  CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(**((void **)v6 + 4) + 40LL))(__p);
  if (v153 >= 0) {
    CFErrorRef v11 = __p;
  }
  else {
    CFErrorRef v11 = (void **)__p[0];
  }
  *(void *)unsigned int valuePtr = Security::makeCFURL((Security *)v11, 0LL, 0LL, v10);
  CFMutableDictionaryRef theDict = Security::makeCFMutableDictionary( *(Security **)valuePtr,  v12,  v13,  @"main-executable",  *(void *)valuePtr);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)valuePtr);
  if (v153 < 0) {
    operator delete(__p[0]);
  }
  int v14 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0);
  unint64_t v15 = theDict;
  if (!v14)
  {
    CFMutableDictionaryRef theDict = 0LL;
    goto LABEL_163;
  }

  int v16 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1);
  std::string::basic_string[abi:ne180100]<0>(v150, (char *)&v16[bswap32(*((_DWORD *)v16 + 5))]);
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)v150);
  CFDictionaryAddValue(v15, @"identifier", *(const void **)valuePtr);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  if (v151 < 0) {
    operator delete(v150[0]);
  }
  uint64_t v17 = theDict;
  *(void *)unsigned int valuePtr = bswap32(*((_DWORD *)Security::CodeSigning::SecStaticCode::codeDirectory( (Security::CodeSigning::SecStaticCode *)v6,  0)
                                + 3));
  v148[0] = CFNumberCreate(0LL, kCFNumberLongLongType, valuePtr);
  CFDictionaryAddValue(v17, @"flags", v148[0]);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)v148);
  unsigned int v18 = theDict;
  (*(void (**)(void **__return_ptr))(**((void **)v6 + 4) + 128LL))(v148);
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)v148);
  CFDictionaryAddValue(v18, @"format", *(const void **)valuePtr);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  if (v149 < 0) {
    operator delete(v148[0]);
  }
  int v19 = theDict;
  if (Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0))
  {
    uint64_t v20 = (const void *)*((void *)v6 + 4);
    if (v20)
    {
      if (v21)
      {
        if (v21[151] < 0) {
          std::string::__init_copy_ctor_external( &v147,  *((const std::string::value_type **)v21 + 16),  *((void *)v21 + 17));
        }
        else {
          std::string v147 = *(std::string *)(v21 + 128);
        }
        goto LABEL_26;
      }
    }

    unsigned int v22 = "embedded";
  }

  else
  {
    unsigned int v22 = "unsigned";
  }

  std::string::basic_string[abi:ne180100]<0>(&v147, v22);
LABEL_26:
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)&v147);
  CFDictionaryAddValue(v19, @"source", *(const void **)valuePtr);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  int v23 = theDict;
  CFDataRef v24 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v6);
  CFDictionaryAddValue(v23, @"unique", v24);
  unsigned int v25 = theDict;
  CFTypeRef v27 = Security::CodeSigning::SecStaticCode::cdHashes((Security::CodeSigning::SecStaticCode *)v6, v26);
  CFDictionaryAddValue(v25, @"cdhashes", v27);
  unint64_t v29 = theDict;
  uint64_t v30 = (const void *)*((void *)v6 + 67);
  if (!v30)
  {
    CFMutableDictionaryRef CFMutableDictionary = Security::makeCFMutableDictionary(v28);
    unint64_t v32 = information;
    unint64_t v158 = (unint64_t)CFMutableDictionary;
    unint64_t v33 = (char *)*((void *)v6 + 13);
    if (v33 != v6 + 112)
    {
      do
      {
        uint64_t v34 = *((unsigned int *)v33 + 8);
        uint64_t BytePtr = (Security::CodeSigning::CodeDirectory *)CFDataGetBytePtr(*((CFDataRef *)v33 + 5));
        xpc_object_t value = (void *)0xAAAAAAAAAAAAAAAALL;
        xpc_object_t value = Security::CodeSigning::CodeDirectory::cdhash(BytePtr, 0);
        if (value)
        {
          size_t v36 = (__CFDictionary *)v158;
          *(void *)unsigned int valuePtr = v34;
          size_t __sz = (size_t)CFNumberCreate(0LL, kCFNumberLongLongType, valuePtr);
          CFDictionaryAddValue(v36, (const void *)__sz, value);
          Security::CFRef<__CFNumber const*>::~CFRef((const void **)&__sz);
        }

        Security::CFRef<__CFData const*>::~CFRef((const void **)&value);
        int v37 = (char *)*((void *)v33 + 1);
        if (v37)
        {
          do
          {
            char v38 = v37;
            int v37 = *(char **)v37;
          }

          while (v37);
        }

        else
        {
          do
          {
            char v38 = (char *)*((void *)v33 + 2);
            BOOL v39 = *(void *)v38 == (void)v33;
            unint64_t v33 = v38;
          }

          while (!v39);
        }

        unint64_t v33 = v38;
      }

      while (v38 != v6 + 112);
      CFMutableDictionaryRef CFMutableDictionary = (CFMutableDictionaryRef)v158;
    }

    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)v6 + 67, CFMutableDictionary);
    Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v158);
    uint64_t v30 = (const void *)*((void *)v6 + 67);
    information = v32;
  }

  CFDictionaryAddValue(v29, @"cdhashes-full", v30);
  std::string::size_type v40 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0);
  uint64_t v41 = theDict;
  LODWORD(v15_Block_object_dispose(va, 8) = v40[37];
  *(void *)unsigned int valuePtr = CFNumberCreate(0LL, kCFNumberIntType, &v158);
  CFDictionaryAddValue(v41, @"digest-algorithm", *(const void **)valuePtr);
  unsigned int v42 = Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
  xpc_object_t value = (void *)0xAAAAAAAAAAAAAAAALL;
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)v42, (void *)v6 + 43);
  char v43 = *(void **)valuePtr;
  if (*(_BYTE **)valuePtr == &valuePtr[8])
  {
    int v50 = (const void **)operator new[](0LL);
    unint64_t v44 = 0LL;
  }

  else
  {
    unint64_t v44 = 0LL;
    unsigned int v45 = *(_BYTE **)valuePtr;
    do
    {
      unint64_t v46 = v44;
      uint64_t v47 = (void *)*((void *)v45 + 1);
      if (v47)
      {
        do
        {
          unsigned int v48 = v47;
          uint64_t v47 = (void *)*v47;
        }

        while (v47);
      }

      else
      {
        do
        {
          unsigned int v48 = (_BYTE *)*((void *)v45 + 2);
          BOOL v39 = *(void *)v48 == (void)v45;
          unsigned int v45 = v48;
        }

        while (!v39);
      }

      ++v44;
      unsigned int v45 = v48;
    }

    while (v48 != &valuePtr[8]);
    if (v46 > 0x1FFFFFFFFFFFFFFELL) {
      size_t v49 = -1LL;
    }
    else {
      size_t v49 = 8 * v44;
    }
    int v50 = (const void **)operator new[](v49);
    if (v44)
    {
      uint64_t v51 = 0LL;
      unsigned int v52 = 0;
      do
      {
        uint64_t v53 = (void *)v43[1];
        unsigned int v54 = v43;
        if (v53)
        {
          do
          {
            BOOL v55 = v53;
            uint64_t v53 = (void *)*v53;
          }

          while (v53);
        }

        else
        {
          do
          {
            BOOL v55 = (void *)v54[2];
            BOOL v39 = *v55 == (void)v54;
            unsigned int v54 = v55;
          }

          while (!v39);
        }

        v50[v51] = ___ZN8Security11CodeSigning13SecStaticCode18signingInformationEj_block_invoke( (uint64_t)&__block_literal_global_71,  *((_DWORD *)v43 + 7));
        uint64_t v51 = ++v52;
        char v43 = v55;
      }

      while (v44 > v52);
    }
  }

  CFArrayRef v56 = CFArrayCreate(0LL, v50, v44, MEMORY[0x189605228]);
  operator delete[](v50);
  xpc_object_t value = v56;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(void **)&valuePtr[8]);
  CFDictionaryAddValue(theDict, @"digest-algorithms", value);
  if (v40[38])
  {
    uint64_t v57 = theDict;
    LODWORD(v15_Block_object_dispose(va, 8) = v40[38];
    *(void *)unsigned int valuePtr = CFNumberCreate(0LL, kCFNumberIntType, &v158);
    CFDictionaryAddValue(v57, @"platform-identifier", *(const void **)valuePtr);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
  }

  if (bswap32(*((_DWORD *)v40 + 2)) >> 8 >= 0x205)
  {
    unsigned int v58 = *((_DWORD *)v40 + 22);
    if (v58)
    {
      uint64_t v59 = theDict;
      *(void *)unsigned int valuePtr = bswap32(v58);
      unint64_t v158 = (unint64_t)CFNumberCreate(0LL, kCFNumberLongLongType, valuePtr);
      CFDictionaryAddValue(v59, @"runtime-version", (const void *)v158);
      Security::CFRef<__CFNumber const*>::~CFRef((const void **)&v158);
    }
  }

  CFURLRef v60 = (const void *)(*(uint64_t (**)(char *))(*(void *)v6 + 88LL))(v6);
  if (v60) {
    CFDictionaryAddValue(theDict, @"info-plist", v60);
  }
  if ((v144 & 2) != 0)
  {
    __int128 v61 = (const void *)Security::CodeSigning::SecStaticCode::signature((Security::CodeSigning::SecStaticCode *)v6);
    CFDictionaryAddValue(theDict, @"cms", v61);
    uint64_t v62 = (const char *)Security::CodeSigning::SecStaticCode::teamID((Security::CodeSigning::SecStaticCode *)v6);
    if (v62)
    {
      unsigned int v63 = theDict;
      Security::CFTempString::CFTempString<char const*>((CFStringRef *)valuePtr, v62);
      CFDictionaryAddValue(v63, @"teamid", *(const void **)valuePtr);
      Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
    }

    size_t v64 = (const void *)*((void *)v6 + 77);
    if (v64) {
      CFDictionaryAddValue(theDict, @"trust", v64);
    }
    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    std::string v65 = (const void *)*((void *)v6 + 78);
    if (v65) {
      CFDictionaryAddValue(theDict, @"certificates", v65);
    }
    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    double v66 = *((double *)v6 + 47);
    if (v66 != 0.0)
    {
      *(void *)unsigned int valuePtr = 0xAAAAAAAAAAAAAAAALL;
      CFDateRef v67 = CFDateCreate(0LL, v66);
      *(void *)unsigned int valuePtr = v67;
      if (v67) {
        CFDictionaryAddValue(theDict, @"signing-time", v67);
      }
      Security::CFRef<__CFDate const*>::~CFRef((const void **)valuePtr);
    }

    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    double v68 = *((double *)v6 + 48);
    if (v68 != 0.0)
    {
      *(void *)unsigned int valuePtr = 0xAAAAAAAAAAAAAAAALL;
      CFDateRef v69 = CFDateCreate(0LL, v68);
      *(void *)unsigned int valuePtr = v69;
      if (v69) {
        CFDictionaryAddValue(theDict, @"signing-timestamp", v69);
      }
      Security::CFRef<__CFDate const*>::~CFRef((const void **)valuePtr);
    }
  }

  if ((v144 & 4) != 0
    && Security::CodeSigning::SecStaticCode::defaultDesignatedLightWeightCodeRequirement((Security::CodeSigning::SecStaticCode *)v6))
  {
    std::string::size_type v70 = theDict;
    unsigned __int8 v71 = (const void *)Security::CodeSigning::SecStaticCode::defaultDesignatedLightWeightCodeRequirement((Security::CodeSigning::SecStaticCode *)v6);
    CFDictionaryAddValue(v70, @"default-designated-lwcr", v71);
  }

  if ((*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))(v6, 7LL, 4294900235LL))
  {
    uint64_t v72 = (const void *)Security::CodeSigning::SecStaticCode::entitlements((UInt8 *)v6);
    if (v72)
    {
      std::string::size_type v73 = (const void *)*((void *)v6 + 69);
      if (!v73)
      {
        unint64_t v74 = (os_log_s *)secLogObjForScope("staticCode");
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v139 = *((void *)v6 + 68);
          *(_DWORD *)unsigned int valuePtr = 134218240;
          *(void *)&valuePtr[4] = v6;
          *(_WORD *)&valuePtr[12] = 2048;
          *(void *)&valuePtr[14] = v139;
          _os_log_debug_impl( &dword_1804F4000,  v74,  OS_LOG_TYPE_DEBUG,  "%p reconstituting XML entitlements with context %p",  valuePtr,  0x16u);
        }

        unint64_t v158 = 0LL;
        uint64_t v75 = CESizeDeserialization();
        uint64_t v76 = (void *)MEMORY[0x1896135D8];
        if (v75 != *MEMORY[0x1896135D8])
        {
          std::string v140 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unsigned int valuePtr = 134217984;
            *(void *)&valuePtr[4] = v6;
            _os_log_impl( &dword_1804F4000,  v140,  OS_LOG_TYPE_DEFAULT,  "%p: couldn't size XML entitlements",  valuePtr,  0xCu);
          }

          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }

        uint64_t v77 = (os_log_s *)secLogObjForScope("staticCode");
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int valuePtr = 134218240;
          *(void *)&valuePtr[4] = v6;
          *(_WORD *)&valuePtr[12] = 2048;
          *(void *)&valuePtr[14] = v158;
          _os_log_debug_impl(&dword_1804F4000, v77, OS_LOG_TYPE_DEBUG, "%p desirialized size: %zu", valuePtr, 0x16u);
        }

        unint64_t v78 = v158;
        if (v158)
        {
          uint64_t v79 = information;
          if (v158 >> 59) {
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v80 = operator new(32 * v158);
          bzero(v80, 32 * v78);
          uint64_t v81 = v80;
        }

        else
        {
          uint64_t v79 = information;
          uint64_t v81 = 0LL;
        }

        if (CEDeserialize() != *v76)
        {
          __int128 v141 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unsigned int valuePtr = 134217984;
            *(void *)&valuePtr[4] = v6;
            _os_log_impl( &dword_1804F4000,  v141,  OS_LOG_TYPE_DEFAULT,  "%p: couldn't deserialize XML entitlements",  valuePtr,  0xCu);
          }

          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }

        size_t __sz = 0LL;
        if (CESizeXMLSerialization() != *v76)
        {
          v142 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unsigned int valuePtr = 134217984;
            *(void *)&valuePtr[4] = v6;
            _os_log_impl( &dword_1804F4000,  v142,  OS_LOG_TYPE_DEFAULT,  "%p: couldn't deserialize XML entitlements",  valuePtr,  0xCu);
          }

          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }

        uint64_t v82 = (os_log_s *)secLogObjForScope("staticCode");
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int valuePtr = 134218240;
          *(void *)&valuePtr[4] = v6;
          *(_WORD *)&valuePtr[12] = 2048;
          *(void *)&valuePtr[14] = __sz;
          _os_log_debug_impl(&dword_1804F4000, v82, OS_LOG_TYPE_DEBUG, "%p xml size: %zu", valuePtr, 0x16u);
        }

        size_t v83 = __sz;
        if (__sz)
        {
          if ((__sz & 0x8000000000000000LL) != 0) {
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v84 = operator new(__sz);
          bzero(v84, v83);
          std::string::size_type v85 = (UInt8 *)v84;
        }

        else
        {
          std::string::size_type v85 = 0LL;
        }

        if (CESerializeXML() != *v76)
        {
          v143 = (os_log_s *)secLogObjForScope("SecError");
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unsigned int valuePtr = 134217984;
            *(void *)&valuePtr[4] = v6;
            _os_log_impl(&dword_1804F4000, v143, OS_LOG_TYPE_DEFAULT, "%p: couldn't make up XML", valuePtr, 0xCu);
          }

          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }

        uint64_t v86 = (os_log_s *)secLogObjForScope("staticCode");
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)unsigned int valuePtr = 134218242;
          *(void *)&valuePtr[4] = v6;
          *(_WORD *)&valuePtr[12] = 2080;
          *(void *)&valuePtr[14] = v85;
          _os_log_debug_impl(&dword_1804F4000, v86, OS_LOG_TYPE_DEBUG, "%p done serializing %s", valuePtr, 0x16u);
        }

        uint64_t v87 = CFDataCreateWithBytesNoCopy(0LL, v85, __sz, (CFAllocatorRef)*MEMORY[0x189604DC8]);
        *(void *)unsigned int valuePtr = v87;
        CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
        CFIndex Length = CFDataGetLength(v87);
        CFDataSetLength(Mutable, Length + 8);
        if (!Mutable) {
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFF94LL);
        }
        Mutableuint64_t BytePtr = CFDataGetMutableBytePtr(Mutable);
        int v91 = CFDataGetLength(v87);
        *(_DWORD *)Mutableuint64_t BytePtr = 1903288058;
        *((_DWORD *)MutableBytePtr + 1) = bswap32(v91 + 8);
        uint64_t v92 = CFDataGetBytePtr(v87);
        CFIndex v93 = CFDataGetLength(v87);
        memcpy(MutableBytePtr + 8, v92, v93);
        uint64_t v94 = (const void *)*((void *)v6 + 69);
        if (v94) {
          CFRelease(v94);
        }
        *((void *)v6 + 69) = Mutable;
        Security::CFRef<__CFData const*>::~CFRef((const void **)valuePtr);
        if (v85) {
          operator delete(v85);
        }
        information = v79;
        if (v81) {
          operator delete(v81);
        }
        std::string::size_type v73 = (const void *)*((void *)v6 + 69);
      }

      CFDictionaryAddValue(theDict, @"entitlements", v73);
      CFDictionaryAddValue(theDict, @"entitlements-dict", v72);
    }
  }

  if ((v144 & 1) != 0)
  {
    uint64_t v95 = (const void *)*((void *)v6 + 42);
    if (v95) {
      CFDictionaryAddValue(theDict, @"CodeDirectory", v95);
    }
    uint64_t v96 = theDict;
    unint64_t v158 = (*(uint64_t (**)(void))(**((void **)v6 + 4) + 88LL))(*((void *)v6 + 4));
    *(void *)unsigned int valuePtr = CFNumberCreate(0LL, kCFNumberLongLongType, &v158);
    CFDictionaryAddValue(v96, @"CodeOffset", *(const void **)valuePtr);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
    if ((v144 & 0x20) == 0)
    {
      *(void *)unsigned int valuePtr = 0xAAAAAAAAAAAAAAAALL;
      Dictionary = Security::CodeSigning::SecStaticCode::getDictionary((UInt8 *)v6, 3LL, 0);
      *(void *)unsigned int valuePtr = Dictionary;
      if (Dictionary) {
        CFDictionaryAddValue(theDict, @"ResourceDirectory", Dictionary);
      }
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)valuePtr);
    }

    *(void *)unsigned int valuePtr = 0xAAAAAAAAAAAAAAAALL;
    std::string v98 = (const void *)(*(uint64_t (**)(void))(**((void **)v6 + 4) + 160LL))(*((void *)v6 + 4));
    *(void *)unsigned int valuePtr = v98;
    if (v98) {
      CFDictionaryAddValue(theDict, @"DiskRepInfo", v98);
    }
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)valuePtr);
    if (v6[596])
    {
      CFAbsoluteTime v99 = *((double *)v6 + 75);
      size_t __sz = 0xAAAAAAAAAAAAAAAALL;
      CFDateRef v100 = CFDateCreate(0LL, v99);
      size_t __sz = (size_t)v100;
      if (v100)
      {
        CFDictionaryAddValue(theDict, @"NotarizationDate", v100);
      }

      else
      {
        int v101 = (os_log_s *)secLogObjForScope("SecError");
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v102 = *((void *)v6 + 75);
          *(_DWORD *)unsigned int valuePtr = 134217984;
          *(void *)&valuePtr[4] = v102;
          _os_log_impl( &dword_1804F4000,  v101,  OS_LOG_TYPE_DEFAULT,  "Error creating date from timestamp: %f",  valuePtr,  0xCu);
        }
      }

      Security::CFRef<__CFDate const*>::~CFRef((const void **)&__sz);
    }

    if (Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1))
    {
      uint64_t v103 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1);
      unint64_t v104 = theDict;
      *(void *)unsigned int valuePtr = bswap32(*((_DWORD *)v103 + 2));
      size_t __sz = (size_t)CFNumberCreate(0LL, kCFNumberLongLongType, valuePtr);
      CFDictionaryAddValue(v104, @"SignatureVersion", (const void *)__sz);
      Security::CFRef<__CFNumber const*>::~CFRef((const void **)&__sz);
    }

    uint64_t v105 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))( v6,  7LL,  4294900235LL);
    if (v105) {
      CFDictionaryAddValue(theDict, @"entitlements-DER", v105);
    }
    std::string v106 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))( v6,  8LL,  4294900235LL);
    if (v106) {
      CFDictionaryAddValue(theDict, @"LaunchConstraints-self", v106);
    }
    uint64_t v107 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))( v6,  9LL,  4294900235LL);
    if (v107) {
      CFDictionaryAddValue(theDict, @"LaunchConstraints-parent", v107);
    }
    std::string v108 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))( v6,  10LL,  4294900235LL);
    if (v108) {
      CFDictionaryAddValue(theDict, @"LaunchConstraints-responsible", v108);
    }
    unint64_t v109 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 80LL))( v6,  11LL,  4294900235LL);
    if (v109) {
      CFDictionaryAddValue(theDict, @"LibraryConstraints", v109);
    }
  }

  if ((v144 & 0x40) != 0)
  {
    std::string v110 = theDict;
    int v155 = 2;
    *(void *)unsigned int valuePtr = CFNumberCreate(0LL, kCFNumberIntType, &v155);
    CFDictionaryAddValue(v110, @"CMSDigestHashType", *(const void **)valuePtr);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
    uint64_t v111 = *Security::CodeSigning::SecStaticCode::codeDirectories((Security::CodeSigning::SecStaticCode *)v6, 1);
    if ((void *)v111 == Security::CodeSigning::SecStaticCode::codeDirectories( (Security::CodeSigning::SecStaticCode *)v6,  1)
                         + 1)
    {
      size_t __sz = 0LL;
    }

    else
    {
      std::string v112 = CFDataGetBytePtr(*(CFDataRef *)(v111 + 40));
      unint64_t v162 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v113 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v113 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v160 = v113;
      __int128 v161 = v113;
      *(_OWORD *)unsigned int valuePtr = v113;
      *(_OWORD *)&valuePtr[16] = v113;
      std::string v114 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)2);
      Security::Mutex::Mutex((pthread_mutex_t *)&valuePtr[8]);
      std::string::size_type v115 = (unsigned int *)((char *)v114 + 8);
      do
        unsigned int v116 = __ldxr(v115);
      while (__stxr(v116 + 1, v115));
      *(void *)unsigned int valuePtr = v114;
      CFIndex v117 = (*(uint64_t (**)(Security::CCHashInstance *))(*(void *)v114 + 16LL))(v114);
      std::string v118 = CFDataCreateMutable(0LL, v117);
      CFIndex v119 = (*(uint64_t (**)(void))(**(void **)valuePtr + 16LL))(*(void *)valuePtr);
      CFDataSetLength(v118, v119);
      (*(void (**)(void, const UInt8 *, void))(**(void **)valuePtr + 24LL))( *(void *)valuePtr,  v112,  bswap32(*((_DWORD *)v112 + 1)));
      uint64_t v120 = *(void *)valuePtr;
      uint64_t v121 = CFDataGetMutableBytePtr(v118);
      (*(void (**)(uint64_t, UInt8 *))(*(void *)v120 + 32LL))(v120, v121);
      Security::RefPointer<Security::DynamicHash>::~RefPointer(valuePtr);
      size_t __sz = (size_t)v118;
      if (v118) {
        CFDictionaryAddValue(theDict, @"CMSDigest", v118);
      }
    }

    Security::CFRef<__CFData const*>::~CFRef((const void **)&__sz);
  }

  if ((v144 & 0x10) != 0)
  {
    if ((v144 & 0x20) == 0)
    {
      __int128 v122 = (const void *)(*(uint64_t (**)(void))(**((void **)v6 + 4) + 136LL))(*((void *)v6 + 4));
      size_t __sz = (size_t)v122;
      if (v122) {
        CFDictionaryAddValue(theDict, @"changed-files", v122);
      }
      Security::CFRef<__CFArray const*>::~CFRef((const void **)&__sz);
    }

    std::string::size_type v123 = (const void *)(*(uint64_t (**)(void))(**((void **)v6 + 4) + 176LL))(*((void *)v6 + 4));
    size_t __sz = (size_t)v123;
    if (v123) {
      CFDictionaryAddValue(theDict, @"stapled-ticket", v123);
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&__sz);
  }

  unint64_t v15 = theDict;
  CFMutableDictionaryRef theDict = 0LL;
  Security::CFRef<__CFArray const*>::~CFRef((const void **)&value);
LABEL_163:
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&theDict);
  CFTypeRef cf = v15;
  if ((v144 & 8) == 0) {
    goto LABEL_178;
  }
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!code) {
    goto LABEL_182;
  }
  {
    if (v124)
    {
      std::string v132 = v124;
      __int128 v133 = (unsigned __int8 *)(v124 - 1);
      do
        unsigned __int8 v134 = __ldaxr(v133);
      while (__stlxr(1u, v133));
      if ((v134 & 1) != 0)
      {
        CFComparisonResult v135 = (const void *)(*(uint64_t (**)(void *))(*v124 + 16LL))(v124);
        CFRetain(v135);
      }

      __p[0] = v132;
      uint64_t v136 = v132[2];
      if (v136) {
        (*(void (**)(uint64_t, void *))(*(void *)v136 + 104LL))(v136, v132);
      }
      CFDataRef v137 = Security::cfmake<__CFDictionary const*>( (uint64_t)"{+%O,%O=%u}",  v125,  v126,  v127,  v128,  v129,  v130,  v131,  (uint64_t)cf);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = v137;
      goto LABEL_177;
    }

LABEL_182:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
  }

  __p[0] = 0LL;
LABEL_177:
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)__p);
  unint64_t v15 = (__CFDictionary *)cf;
LABEL_178:
  CFTypeRef cf = 0LL;
  if (!information) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *information = v15;
  Security::CFRef<__CFDictionary const*>::~CFRef(&cf);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v146);
  return 0;
}

void sub_180620BE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, void *a39, uint64_t a40, int a41, __int16 a42, char a43, char a44, char a45, uint64_t a46, char a47, int a48, __int16 a49, char a50,char a51)
{
  if (a2)
  {
    if (v52) {
      operator delete(v52);
    }
    if (v51) {
      operator delete(v51);
    }
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1806202C4LL);
  }

  _Unwind_Resume(a1);
}

CFTypeID SecStaticCodeGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 200);
}

void sub_18062130C(void *a1)
{
}

OSStatus SecStaticCodeCreateWithPath(CFURLRef path, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  if (flags >= 2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  unsigned __int8 v8 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x288,  *(void *)(v6 + 200),  v7);
  Security::cfString((Security *)__p, path);
  if (v14 >= 0) {
    unsigned __int8 v9 = (char *)__p;
  }
  else {
    unsigned __int8 v9 = (char *)__p[0];
  }
  int v10 = Security::CodeSigning::DiskRep::bestGuess(v9, 0LL);
  Security::CodeSigning::SecStaticCode::SecStaticCode(v8, (Security::CodeSigning::DiskRep *)v10, flags);
  CFErrorRef v11 = (const __SecCode *)Security::SecCFObject::handle(v8, 1);
  if (!staticCode) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *staticint64_t Code = v11;
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_180621400( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  switch(a2)
  {
    case 6:
      unsigned int v18 = __cxa_begin_catch(a1);
      if (v18[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v18 + 24LL))(v18);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      unsigned int v18 = __cxa_begin_catch(a1);
      unsigned int v20 = v18[36];
      if (v20 > 0x1A) {
        goto LABEL_6;
      }
      int v21 = 1 << v20;
      if ((v21 & 0x800108) == 0 && (v21 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      int v19 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v19 + 24LL))(v19);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v22);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x1806213C0LL);
}

void sub_180621558(_Unwind_Exception *a1)
{
}

OSStatus SecStaticCodeCreateWithPathAndAttributes( CFURLRef path, SecCSFlags flags, CFDictionaryRef attributes, SecStaticCodeRef *staticCode)
{
  if (flags >= 2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  __int128 v33 = 0xAAAAAAAAAAAAAA00LL;
  unint64_t v35 = 0xAAAAAAAAAAAAAA00LL;
  unint64_t v30 = 0xFFFFFFFF00000000LL;
  unsigned int v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v34 = 0LL;
  v28[0] = 0LL;
  v28[1] = 0LL;
  uint64_t v29 = 0LL;
  if (attributes)
  {
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v27 = 0LL;
    int v24 = -1431655766;
    int v25 = -1431655766;
    int v23 = -1431655766;
    if (Security::cfscan( (const __CFString *)attributes,  "{%O=%d}",  (const char *)attributes,  @"UniversalFileOffset",  &v23))
    {
      uint64_t v32 = v23;
LABEL_18:
      if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v8, @"bundleversion", v28))
      {
        unint64_t v15 = v28;
        if (v29 < 0) {
          unint64_t v15 = (void **)v28[0];
        }
        unsigned int v31 = v15;
      }

      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_24;
    }

    if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v8, @"architecture", __p))
    {
      if (v27 >= 0) {
        int v10 = __p;
      }
      else {
        int v10 = (void **)__p[0];
      }
      CFErrorRef v11 = NXGetArchInfoFromName((const char *)v10);
      if (v11) {
        unint64_t v12 = *(void *)&v11->cputype;
      }
      else {
        unint64_t v12 = 0LL;
      }
      unint64_t v30 = v12;
      goto LABEL_18;
    }

    if (Security::cfscan( (const __CFString *)attributes,  "{%O=%d,%O=%d}",  v9,  @"architecture",  &v25,  @"subarchitecture",  &v24))
    {
      int v14 = v24;
      int v13 = v25;
    }

    else
    {
      int v13 = v25;
      int v14 = -1;
    }

    unint64_t v30 = __PAIR64__(v14, v13);
    goto LABEL_18;
  }

void sub_180621800( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  switch(a2)
  {
    case 6:
      uint64_t v29 = __cxa_begin_catch(a1);
      if (v29[36] == 8) {
        break;
      }
LABEL_10:
      (*(void (**)(_DWORD *))(*(void *)v29 + 24LL))(v29);
      break;
    case 5:
      goto LABEL_9;
    case 4:
      uint64_t v29 = __cxa_begin_catch(a1);
      unsigned int v31 = v29[36];
      if (v31 > 0x1A) {
        goto LABEL_10;
      }
      int v32 = 1 << v31;
      if ((v32 & 0x800108) == 0 && (v32 & 0x4014000) == 0) {
        goto LABEL_10;
      }
      break;
    case 3:
LABEL_9:
      unint64_t v30 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v30 + 24LL))(v30);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v33);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x1806217C0LL);
}

void sub_180621994(_Unwind_Exception *a1)
{
}

OSStatus SecStaticCodeCheckValidity( SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecStaticCodeCheckValidityWithErrors(staticCode, flags, requirement, 0LL);
}

OSStatus SecStaticCodeCheckValidityWithErrors( SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  if ((flags & 0xDFE0020) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  if (errors) {
    SecCSFlags v6 = flags | 0x20;
  }
  else {
    SecCSFlags v6 = flags;
  }
  int v19 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v7 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic( staticCode,  *(const __SecCode **)&flags);
  unsigned __int8 v9 = v7;
  if (v7)
  {
    int v10 = (unsigned __int8 *)v7 - 8;
    do
      unsigned __int8 v11 = __ldaxr(v10);
    while (__stlxr(1u, v10));
    if ((v11 & 1) != 0)
    {
      unint64_t v12 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)v7 + 16LL))(v7);
      CFRetain(v12);
    }
  }

  int v13 = v6 | 0x2000000;
  int v19 = v9;
  *((_DWORD *)v9 + 52) = v13;
  int v14 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v8);
  std::string __p = v19;
  Security::CodeSigning::SecStaticCode::staticValidate(v19, v13, (Security::CodeSigning::Requirement **)v14);
  if (*((_BYTE *)v19 + 632)) {
    OSStatus v15 = 0;
  }
  else {
    OSStatus v15 = -66996;
  }
  if (*((_BYTE *)v19 + 632)) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = errors == 0LL;
  }
  if (!v16)
  {
    *errors = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -66996LL, 0LL);
    OSStatus v15 = -66996;
  }

  SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC((SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *)&__p);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v19);
  return v15;
}

void sub_180621B5C( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      unsigned int v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      int v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8) {
        int v20 = -67049;
      }
      else {
        int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v19 + 24LL))(v19);
      }
      if (v15)
      {
LABEL_32:
        CFErrorRef v23 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v20, 0LL);
        goto LABEL_33;
      }

void sub_180621DD0(_Unwind_Exception *a1)
{
}

void SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC( SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *this)
{
}

uint64_t SecStaticCodeValidateResourceWithErrors( Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  if ((a3 & 0x1FFC9DAE) != 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  SecCSFlags v6 = v5;
  if (v5)
  {
    unsigned int v7 = (unsigned __int8 *)v5 - 8;
    do
      unsigned __int8 v8 = __ldaxr(v7);
    while (__stlxr(1u, v7));
    if ((v8 & 1) != 0)
    {
      unsigned __int8 v9 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)v5 + 16LL))(v5);
      CFRetain(v9);
    }
  }

  unint64_t v12 = (unint64_t)v6;
  *((_DWORD *)v6 + 52)  = a3;
  Security::cfString((Security *)&__p, a2);
  Security::CodeSigning::SecStaticCode::staticValidateResource(v6, &__p, a3, 0LL);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v12);
  return 0LL;
}

void sub_180621F34( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      unsigned int v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      int v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8) {
        int v20 = -67049;
      }
      else {
        int v20 = (*(uint64_t (**)(_DWORD *))(*(void *)v19 + 24LL))(v19);
      }
      if (v15)
      {
LABEL_32:
        CFErrorRef v23 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v20, 0LL);
        goto LABEL_33;
      }

void sub_18062218C(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCopyPath(SecStaticCodeRef staticCode, SecCSFlags flags, CFURLRef *path)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = (char *)Security::CodeSigning::SecStaticCode::requiredStatic(staticCode, *(const __SecCode **)&flags);
  uint64_t v5 = v4;
  if (v4)
  {
    SecCSFlags v6 = (unsigned __int8 *)(v4 - 8);
    do
      unsigned __int8 v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0)
    {
      unsigned __int8 v8 = (const void *)(*(uint64_t (**)(char *))(*(void *)v4 + 16LL))(v4);
      CFRetain(v8);
    }
  }

  unint64_t v11 = (unint64_t)v5;
  unsigned __int8 v9 = (const __CFURL *)(*(uint64_t (**)(void *))(**((void **)v5 + 4) + 48LL))(*((void **)v5 + 4));
  if (!path) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *path  = v9;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v11);
  return 0;
}

void sub_180622298(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      unint64_t v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24LL))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      unint64_t v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      unint64_t v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24LL))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180622268LL);
}

void sub_1806223D0(_Unwind_Exception *a1)
{
}

OSStatus SecCodeCopyDesignatedRequirement( SecStaticCodeRef code, SecCSFlags flags, SecRequirementRef *requirement)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t v4 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic( code,  *(const __SecCode **)&flags);
  uint64_t v5 = (unsigned int *)Security::CodeSigning::SecStaticCode::designatedRequirement(v4);
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  unsigned __int8 v8 = (Security::SecCFObject *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x18,  *(void *)(v6 + 304),  v7);
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v5, 0);
  unsigned __int8 v9 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  int v10 = v9;
  OSStatus result = 0;
  *requirement  = v10;
  return result;
}

void sub_1806224A4(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      uint64_t v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24LL))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      uint64_t v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24LL))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180622474LL);
}

void sub_1806225DC(_Unwind_Exception *a1)
{
}

uint64_t SecCodeCopyInternalRequirement( Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3, void *a4)
{
  if (a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  int v5 = (int)a2;
  uint64_t v6 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  unsigned int v7 = Security::CodeSigning::SecStaticCode::internalRequirements(v6);
  if (v7
    && (int v8 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>( (uint64_t)v7,  v5)) != 0LL)
  {
    uint64_t v9 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    unint64_t v11 = (Security::SecCFObject *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x18,  *(void *)(v9 + 304),  v10);
    Security::CodeSigning::SecRequirement::SecRequirement(v11, v8, 0);
    unint64_t v12 = Security::SecCFObject::handle(v11, 1);
  }

  else
  {
    unint64_t v12 = 0LL;
  }

  if (!a4) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  uint64_t result = 0LL;
  *a4  = v12;
  return result;
}

void sub_1806226CC(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      int v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24LL))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      int v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24LL))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x18062269CLL);
}

void sub_180622804(_Unwind_Exception *a1)
{
}

uint64_t SecCodeSetDetachedSignature(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  if (a3) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  int v10 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  int v5 = v4;
  if (v4)
  {
    uint64_t v6 = (unsigned __int8 *)v4 - 8;
    do
      unsigned __int8 v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0)
    {
      int v8 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)v4 + 16LL))(v4);
      CFRetain(v8);
    }
  }

  int v10 = v5;
  Security::CodeSigning::SecStaticCode::detachedSignature(v5, a2);
  Security::CodeSigning::SecStaticCode::resetValidity(v5);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0LL;
}

void sub_1806228E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  switch(a2)
  {
    case 6:
      unint64_t v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v11 + 24LL))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      unint64_t v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A) {
        goto LABEL_6;
      }
      int v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      unint64_t v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24LL))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x1806228C4LL);
}

void sub_180622A1C(_Unwind_Exception *a1)
{
}

OSStatus SecCodeMapMemory(SecStaticCodeRef code, SecCSFlags flags)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  audit_token_t v2 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic( code,  *(const __SecCode **)&flags);
  audit_token_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = (unsigned __int8 *)v2 - 8;
    do
      unsigned __int8 v5 = __ldaxr(v4);
    while (__stlxr(1u, v4));
    if ((v5 & 1) != 0)
    {
      uint64_t v6 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)v2 + 16LL))(v2);
      CFRetain(v6);
    }
  }

  unint64_t v25 = (unint64_t)v3;
  unsigned __int8 v7 = Security::CodeSigning::SecStaticCode::codeDirectory(v3, 0);
  if (!v7) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }
  if ((*(uint64_t (**)(void))(**(void **)(v25 + 32) + 16LL))(*(void *)(v25 + 32)) != *(void *)(v25 + 32))
  {
    *(void *)&v27[32]  = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v27 = v8;
    *(_OWORD *)&v27[16]  = v8;
    __int128 v26 = v8;
    *(void *)&__int128 v26 = (*(uint64_t (**)(void))(**(void **)(v25 + 32) + 88LL))(*(void *)(v25 + 32));
    *((void *)&v26 + 1)  = v7;
    *(void *)uint64_t v27 = bswap32(*((_DWORD *)v7 + 1));
    memset(&v27[8], 0, 32);
    uint64_t v9 = (int *)(*(uint64_t (**)(void))(**(void **)(v25 + 32) + 144LL))(*(void *)(v25 + 32));
    if (fcntl(*v9, 59, &v26) == -1)
    {
      int v10 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v10);
    }

    goto LABEL_24;
  }

  unint64_t v11 = (off_t *)(*(uint64_t (**)(void))(**(void **)(v25 + 32) + 80LL))(*(void *)(v25 + 32));
  if (!v11) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2BLL);
  }
  unint64_t v12 = (Security::MachOBase *)Security::Universal::architecture(v11);
  CodeCFDataRef Signature = Security::MachOBase::findCodeSignature(v12);
  if (CodeSignature)
  {
    c__int128 md = CodeSignature[1].cmd;
    unsigned int v15 = bswap32(cmd);
    if (*((_BYTE *)v12 + 33)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = cmd;
    }
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  uint64_t v17 = Security::MachOBase::findCodeSignature(v12);
  if (v17)
  {
    cmdstd::string::size_type size = v17[1].cmdsize;
    unsigned int v19 = bswap32(cmdsize);
    if (*((_BYTE *)v12 + 33)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = cmdsize;
    }
    if (v16) {
      goto LABEL_22;
    }
LABEL_26:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }

  uint64_t v20 = 0LL;
  if (!v16) {
    goto LABEL_26;
  }
LABEL_22:
  *(void *)&v27[32]  = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v27 = v21;
  *(_OWORD *)&v27[16]  = v21;
  __int128 v26 = v21;
  *(void *)&__int128 v26 = (*(uint64_t (**)(void))(**(void **)(v25 + 32) + 88LL))(*(void *)(v25 + 32));
  *((void *)&v26 + 1)  = v16;
  *(void *)uint64_t v27 = v20;
  memset(&v27[8], 0, 32);
  int v22 = (int *)(*(uint64_t (**)(void))(**(void **)(v25 + 32) + 144LL))(*(void *)(v25 + 32));
  if (fcntl(*v22, 61, &v26) == -1)
  {
    int v24 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v24);
  }

  (*(void (**)(Security::MachOBase *))(*(void *)v12 + 8LL))(v12);
LABEL_24:
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
  return 0;
}

void sub_180622D00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a10);
  if (a2 == 6)
  {
    unsigned int v13 = __cxa_begin_catch(exception_object);
    if (v13[36] == 8) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  if (a2 != 5)
  {
    if (a2 == 4)
    {
      unsigned int v13 = __cxa_begin_catch(exception_object);
      unsigned int v15 = v13[36];
      if (v15 <= 0x1A)
      {
        int v16 = 1 << v15;
        if ((v16 & 0x800108) != 0 || (v16 & 0x4014000) != 0) {
          goto LABEL_17;
        }
      }

uint64_t SecStaticCodeSetCallback( Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, void *a3, uint64_t a4)
{
  if ((_DWORD)a2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t v6 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  unsigned __int8 v7 = v6;
  if (a3) {
    *a3  = v6[72];
  }
  uint64_t result = 0LL;
  v7[72]  = a4;
  return result;
}

void sub_180622F58(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      audit_token_t v3 = __cxa_begin_catch(a1);
      if (v3[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v3 + 24LL))(v3);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      audit_token_t v3 = __cxa_begin_catch(a1);
      unsigned int v5 = v3[36];
      if (v5 > 0x1A) {
        goto LABEL_6;
      }
      int v6 = 1 << v5;
      if ((v6 & 0x800108) == 0 && (v6 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v4 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v4 + 24LL))(v4);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v7);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180622F3CLL);
}

void sub_180623074(_Unwind_Exception *a1)
{
}

uint64_t SecStaticCodeSetValidationConditions(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  audit_token_t v3 = (CFTypeRef *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  if (a2)
  {
    uint64_t v4 = v3;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
    Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(&v9, a2);
    LODWORD(v1syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = -67024;
    unsigned int v5 = Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "omissions");
    Security::CFRef<__CFArray const*>::operator=(v4 + 21, v5);
    int v6 = (const __CFArray *)Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "errors");
    unsigned __int8 v7 = v6;
    if (v6)
    {
      v11.size_t length = CFArrayGetCount(v6);
      v11.CFIndex location = 0LL;
      CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)Security::CodeSigning::addError, v4 + 18);
    }

    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
  }

  return 0LL;
}

void sub_180623174( void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  switch(a2)
  {
    case 6:
      CFRange v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8) {
        break;
      }
      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      CFRange v11 = __cxa_begin_catch(a1);
      unsigned int v13 = v11[36];
      if (v13 > 0x1A || (int v14 = 1 << v13, (v14 & 0x800108) == 0) && (v14 & 0x4014000) == 0) {
LABEL_6:
      }
        (*(void (**)(_DWORD *))(*(void *)v11 + 24LL))(v11);
      break;
    case 3:
LABEL_5:
      unint64_t v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v12 + 24LL))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180623160LL);
}

void sub_1806232A0(_Unwind_Exception *a1)
{
}

uint64_t SecStaticCodeCancelValidation(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  audit_token_t v2 = (dispatch_queue_t *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  audit_token_t v3 = v2;
  if ((*((_BYTE *)v2 + 211) & 0x10) == 0) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  dispatch_assert_queue_V2(v2[39]);
  uint64_t result = 0LL;
  *((_BYTE *)v3 + 22syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 1;
  return result;
}

unint64_t SecCodeCopyComponent( Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, const __CFData *a3)
{
  unsigned int v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  int v6 = Security::CodeSigning::SecStaticCode::codeDirectory(v5, 1);
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int8 v7 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, const __SecCode *, uint64_t))(*(void *)v5 + 80LL))( v5,  a2,  4294900235LL);
  Security::CFCopyRef<__CFData const*>::CFCopyRef(&v15, v7);
  unint64_t v8 = v15;
  if (v15)
  {
    if (a3)
    {
      unsigned int v9 = *((_DWORD *)v6 + 4);
      uint64_t v10 = v6[36];
      if (CFDataGetLength(a3) != v10
        || (uint64_t BytePtr = CFDataGetBytePtr(a3), memcmp(&v6[bswap32(v9) + (int)v10 * (uint64_t)(int)a2], BytePtr, v6[36])))
      {
        CFIndex Length = CFDataGetLength(a3);
        Security::Syslog::notice((Security::Syslog *)"copyComponent hash mismatch slot %d length %d", v13, a2, Length);
        unint64_t v8 = 0LL;
        goto LABEL_8;
      }

      unint64_t v8 = v15;
    }

    unint64_t v15 = 0LL;
  }

void sub_1806235A0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t SecCodeSpecialSlotIsPresent(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2 = (int)a2;
  audit_token_t v3 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  uint64_t v4 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(v3, 1);
  IsPresent  = Security::CodeSigning::CodeDirectory::slotIsPresent(v4, -v2);
  uint64_t v6 = MEMORY[0x189604DE8];
  if (!IsPresent) {
    uint64_t v6 = MEMORY[0x189604DE0];
  }
  return *(void *)v6;
}

void sub_180623618(void *a1)
{
}

uint64_t SecStaticCodeEnableOnlineNotarizationCheck( Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2 = (int)a2;
  audit_token_t v3 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  uint64_t result = 0LL;
  v3[148]  = v3[148] & 0xFFFFFFFE | (v2 != 0);
  return result;
}

OSStatus SecCodeValidateFileResource( SecStaticCodeRef code, CFStringRef relativePath, CFDataRef fileData, SecCSFlags flags)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!fileData) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  uint64_t v6 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic( code,  (const __SecCode *)relativePath);
  Security::cfString(&__p, relativePath);
  __int128 v26 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
  if (!Security::CodeSigning::SecStaticCode::loadResources(v6, &v27, &v26, &v25))
  {
    uint64_t v9 = 4294900240LL;
    goto LABEL_19;
  }

  unsigned __int8 v7 = v26;
  else {
    std::string v24 = __p;
  }
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)key, (char *)&v24);
  unint64_t Value = CFDictionaryGetValue(v7, key[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)key);
  uint64_t v9 = 4294900242LL;
  if (!Value) {
LABEL_19:
  }
    Security::MacOSError::throwMe((Security::MacOSError *)v9);
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v23[0]  = v10;
  v23[1]  = v10;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)v23, Value);
  CFRange v11 = Security::CodeSigning::SecStaticCode::codeDirectory(v6, 1);
  unint64_t v12 = Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)v23, v11[37]);
  if (!v12) {
    goto LABEL_16;
  }
  unsigned int v13 = Security::CodeSigning::SecStaticCode::codeDirectory(v6, 1);
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  __int128 v30 = v14;
  __int128 v31 = v14;
  *(_OWORD *)SecKeyRef key = v14;
  __int128 v29 = v14;
  unint64_t v15 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)v13[37]);
  Security::Mutex::Mutex((pthread_mutex_t *)&key[1]);
  int v16 = (unsigned int *)((char *)v15 + 8);
  do
    unsigned int v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  key[0]  = v15;
  uint64_t BytePtr = CFDataGetBytePtr(fileData);
  CFIndex Length = CFDataGetLength(fileData);
  (*(void (**)(Security::CCHashInstance *, const UInt8 *, CFIndex))(*(void *)v15 + 24LL))( v15,  BytePtr,  Length);
  BOOL v20 = Security::DynamicHash::verify((Security::DynamicHash *)key[0], v12);
  Security::RefPointer<Security::DynamicHash>::~RefPointer(key);
  if (!v20)
  {
LABEL_16:
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v23);
    goto LABEL_19;
  }

  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v23);
  return 0;
}

void sub_1806239FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, const void *a29)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  Security::CFRef<__CFString const*>::~CFRef(&a29);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a2 == 6)
  {
    __int128 v31 = __cxa_begin_catch(exception_object);
    if (v31[36] == 8) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (a2 != 5)
  {
    if (a2 == 4)
    {
      __int128 v31 = __cxa_begin_catch(exception_object);
      unsigned int v33 = v31[36];
      if (v33 <= 0x1A)
      {
        int v34 = 1 << v33;
        if ((v34 & 0x800108) != 0 || (v34 & 0x4014000) != 0) {
          goto LABEL_21;
        }
      }

CFTypeID SecRequirementGetTypeID(void)
{
  return *(void *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 304);
}

void sub_180623C18(void *a1)
{
}

OSStatus SecRequirementCreateWithData(CFDataRef data, SecCSFlags flags, SecRequirementRef *requirement)
{
  if (flags)
  {
    uint64_t v13 = 4294900226LL;
    goto LABEL_12;
  }

  uint64_t v5 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  unsigned __int8 v7 = (Security::SecCFObject *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x18,  *(void *)(v5 + 304),  v6);
  uint64_t BytePtr = (unsigned int *)CFDataGetBytePtr(data);
  unint64_t Length = CFDataGetLength(data);
  *((void *)v7 + 1)  = 1LL;
  *(void *)unsigned __int8 v7 = off_1896785E0;
  *((void *)v7 + 2)  = 0LL;
  if (Length < 0xC) {
LABEL_10:
  }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14LL);
  if (*BytePtr != 843514 || (unsigned int v10 = bswap32(BytePtr[1]), v10 <= 0xB))
  {
    *__error()  = 22;
    goto LABEL_10;
  }

  if (Length != v10) {
    goto LABEL_10;
  }
  *((void *)v7 + 2)  = Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone((Security::BlobCore *)BytePtr);
  CFRange v11 = (__SecRequirement *)Security::SecCFObject::handle(v7, 1);
  if (!requirement)
  {
    uint64_t v13 = 4294900227LL;
LABEL_12:
    Security::MacOSError::throwMe((Security::MacOSError *)v13);
  }

  *requirement  = v11;
  return 0;
}

void sub_180623D30(void *a1, int a2)
{
  switch(a2)
  {
    case 6:
      uint64_t v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v5 + 24LL))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      uint64_t v5 = __cxa_begin_catch(a1);
      unsigned int v7 = v5[36];
      if (v7 > 0x1A) {
        goto LABEL_6;
      }
      int v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      uint64_t v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v6 + 24LL))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180623CE8LL);
}

void sub_180623E4C(_Unwind_Exception *a1)
{
}

OSStatus SecRequirementCreateWithString(CFStringRef text, SecCSFlags flags, SecRequirementRef *requirement)
{
  return SecRequirementCreateWithStringAndErrors(text, flags, 0LL, requirement);
}

OSStatus SecRequirementCreateWithStringAndErrors( CFStringRef text, SecCSFlags flags, CFErrorRef *errors, SecRequirementRef *requirement)
{
  if (flags) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  int v8 = (Security::SecCFObject *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x18,  *(void *)(v6 + 304),  v7);
  Security::cfString(&__p, text);
  else {
    std::string v16 = __p;
  }
  memset(&v20, 0, sizeof(v20));
  uint64_t v9 = *(uint64_t (**)(std::string *, std::string *))(*(void *)(Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
                                                                          + 72)
                                                              + 24LL);
  int size = (char)v16.__r_.__value_.__s.__size_;
  else {
    std::string v19 = v16;
  }
  CFRange v11 = (unsigned int *)v9(&v19, &v20);
  if (!v11)
  {
    else {
      std::string v17 = v20;
    }
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v18, (char *)&v17);
    Security::CodeSigning::CSError::throwMe( (Security::CodeSigning::CSError *)0xFFFEFA14LL,  (uint64_t)@"SecRequirementSyntax",  v18,  v14);
  }

  if ((char)v20.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if ((size & 0x80000000) == 0) {
      goto LABEL_13;
    }
  }

  else if ((size & 0x80000000) == 0)
  {
    goto LABEL_13;
  }

  operator delete(v16.__r_.__value_.__l.__data_);
LABEL_13:
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v11, 1);
  unint64_t v12 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03LL);
  }
  *requirement  = v12;
  return 0;
}

void sub_180624060( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, char a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  Security::SecCFObject::operator delete(v36);
  switch(a2)
  {
    case 7:
      std::string::size_type v40 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v40, v35);
      goto LABEL_38;
    case 6:
      uint64_t v41 = __cxa_begin_catch(a1);
      if (v41[36] == 8) {
        int v42 = -67049;
      }
      else {
        int v42 = (*(uint64_t (**)(_DWORD *))(*(void *)v41 + 24LL))(v41);
      }
      if (v35)
      {
LABEL_36:
        CFErrorRef v45 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v42, 0LL);
        goto LABEL_37;
      }

void sub_18062433C(_Unwind_Exception *a1)
{
}

OSStatus SecRequirementCopyData(SecRequirementRef requirement, SecCSFlags flags, CFDataRef *data)
{
  uint64_t v5 = (const UInt8 **)Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    uint64_t v7 = 4294900226LL;
    goto LABEL_6;
  }

  if (!data)
  {
    uint64_t v7 = 4294900227LL;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }

  const UInt8 *data = CFDataCreate(0LL, v5[2], bswap32(*((_DWORD *)v5[2] + 1)));
  return 0;
}

void *Security::CodeSigning::SecRequirement::required( Security::CodeSigning::SecRequirement *this, __SecRequirement *a2)
{
  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01LL);
  }

  return result;
}

OSStatus SecRequirementCopyString(SecRequirementRef requirement, SecCSFlags flags, CFStringRef *text)
{
  uint64_t v5 = Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    uint64_t v11 = 4294900226LL;
    goto LABEL_15;
  }

  if (!text)
  {
    uint64_t v11 = 4294900227LL;
LABEL_15:
    Security::MacOSError::throwMe((Security::MacOSError *)v11);
  }

  Security::CodeSigning::Dumper::dump(&cStr, v5[2]);
  if ((char)cStr.__r_.__value_.__s.__size_ < 0)
  {
    p_cStr  = (std::string *)cStr.__r_.__value_.__r.__words[0];
    if (!cStr.__r_.__value_.__r.__words[0])
    {
      uint64_t v9 = 0LL;
      *text  = 0LL;
      goto LABEL_11;
    }
  }

  else
  {
    p_cStr  = &cStr;
  }

  uint64_t v7 = CFStringCreateWithCString(0LL, (const char *)p_cStr, 0x8000100u);
  if (!v7)
  {
    uint64_t v7 = CFStringCreateWithCString(0LL, (const char *)p_cStr, 0x600u);
    if (!v7) {
      Security::CFError::throwMe(0LL);
    }
  }

  int size = (char)cStr.__r_.__value_.__s.__size_;
  *text  = v7;
  if (size < 0)
  {
    uint64_t v9 = (void *)cStr.__r_.__value_.__r.__words[0];
LABEL_11:
    operator delete(v9);
  }

  return 0;
}

void sub_18062465C( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  switch(a2)
  {
    case 6:
      std::string v16 = __cxa_begin_catch(a1);
      if (v16[36] == 8) {
        break;
      }
LABEL_6:
      (*(void (**)(_DWORD *))(*(void *)v16 + 24LL))(v16);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      std::string v16 = __cxa_begin_catch(a1);
      unsigned int v18 = v16[36];
      if (v18 > 0x1A) {
        goto LABEL_6;
      }
      int v19 = 1 << v18;
      if ((v19 & 0x800108) == 0 && (v19 & 0x4014000) == 0) {
        goto LABEL_6;
      }
      break;
    case 3:
LABEL_5:
      std::string v17 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(void *)v17 + 24LL))(v17);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2) {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v20);
      }
      break;
  }

  __cxa_end_catch();
  JUMPOUT(0x180624628LL);
}

void sub_180624780(_Unwind_Exception *a1)
{
}

_DWORD *Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make( void *a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1[2];
  int v2 = (void *)*a1;
  audit_token_t v3 = a1 + 1;
  if ((void *)*a1 == a1 + 1)
  {
    int v4 = 0;
  }

  else
  {
    int v4 = 0;
    uint64_t v5 = (void *)*a1;
    do
    {
      uint64_t v6 = (void *)v5[1];
      uint64_t v7 = v5;
      if (v6)
      {
        do
        {
          int v8 = v6;
          uint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          int v8 = (void *)v7[2];
          BOOL v9 = *v8 == (void)v7;
          uint64_t v7 = v8;
        }

        while (!v9);
      }

      v4 += bswap32(*(_DWORD *)(v5[5] + 4LL));
      uint64_t v5 = v8;
    }

    while (v8 != v3);
  }

  unsigned int v10 = v4 + 8 * v1 + 12;
  uint64_t v11 = malloc(v10);
  if (!v11) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  unint64_t v12 = v11;
  _DWORD *v11 = 17620730;
  v11[1]  = bswap32(v10);
  void v11[2] = bswap32(v1);
  if (v2 != v3)
  {
    int v13 = 0;
    unsigned int v14 = 8 * v1 + 12;
    do
    {
      unint64_t v15 = &v12[2 * v13];
      unint64_t v15[3] = bswap32(*((_DWORD *)v2 + 8));
      void v15[4] = bswap32(v14);
      memcpy((char *)v12 + v14, (const void *)v2[5], bswap32(*(_DWORD *)(v2[5] + 4LL)));
      std::string v16 = (void *)v2[1];
      std::string v17 = v2;
      if (v16)
      {
        do
        {
          unsigned int v18 = v16;
          std::string v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          unsigned int v18 = (void *)v17[2];
          BOOL v9 = *v18 == (void)v17;
          std::string v17 = v18;
        }

        while (!v9);
      }

      v14 += bswap32(*(_DWORD *)(v2[5] + 4LL));
      ++v13;
      int v2 = v18;
    }

    while (v18 != v3);
  }

  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v33[7]  = v19;
  uint8_t v33[8] = v19;
  v33[5]  = v19;
  v33[6]  = v19;
  void v33[3] = v19;
  v33[4]  = v19;
  v33[1]  = v19;
  void v33[2] = v19;
  v33[0]  = v19;
  __int128 v31 = v19;
  __int128 v32 = v19;
  v29[3]  = v19;
  *(_OWORD *)std::string __p = v19;
  v29[1]  = v19;
  v29[2]  = v19;
  v29[0]  = v19;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v29);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)"Maker ", 6LL);
  std::string v20 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" assembles ", 11LL);
  __int128 v21 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" blob(s) into ", 14LL);
  int v22 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" (size=", 7LL);
  CFErrorRef v23 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1LL);
  std::string v24 = (os_log_s *)secLogObjForScope("superblob");
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v29 + 8);
    __int128 v26 = v28 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)stat buf = 136315138;
    size_t v36 = v26;
    _os_log_debug_impl(&dword_1804F4000, v24, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v28 < 0) {
      operator delete(__dst[0]);
    }
  }

  *(void *)&v29[0]  = *MEMORY[0x189614738];
  *(void *)((char *)v29 + *(void *)(*(void *)&v29[0] - 24LL))  = *(void *)(MEMORY[0x189614738] + 24LL);
  *((void *)&v29[0] + 1)  = MEMORY[0x189614750] + 16LL;
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](v33);
  return v12;
}

void sub_180624B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

_DWORD *Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone(Security::BlobCore *a1)
{
  uint64_t result = Security::BlobCore::clone(a1);
  unsigned int v2 = bswap32(result[1]);
  if (*result != 843514 || v2 <= 0xB)
  {
    int v4 = __error();
    uint64_t result = 0LL;
    *int v4 = 22;
  }

  return result;
}

void Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add( uint64_t **a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v6 = std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>( a1,  a2,  a2,  a3);
  if (!v7)
  {
    int v8 = v6;
    BOOL v9 = (os_log_s *)secLogObjForScope("superblob");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 134218240;
      uint64_t v11 = a1;
      __int16 v12 = 1024;
      unsigned int v13 = a2;
      _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "Maker %p replaces type=%d", (uint8_t *)&v10, 0x12u);
    }

    free(v8[5]);
    void v8[5] = a3;
  }

uint64_t **std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>( uint64_t **a1, unsigned int a2, int a3, uint64_t *a4)
{
  int v8 = a1 + 1;
  char v7 = a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v7;
        unsigned int v10 = *((_DWORD *)v7 + 8);
        if (v10 <= a2) {
          break;
        }
        char v7 = *v9;
        int v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }

      if (v10 >= a2) {
        break;
      }
      char v7 = v9[1];
      if (!v7)
      {
        int v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    BOOL v9 = a1 + 1;
LABEL_9:
    uint64_t v11 = (uint64_t *)v9;
    BOOL v9 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v9 + _Block_object_dispose(va, 8) = a3;
    void v9[5] = a4;
    os_log_s *v9 = 0LL;
    v9[1]  = 0LL;
    int v9[2] = v11;
    void *v8 = (uint64_t *)v9;
    __int16 v12 = (uint64_t *)**a1;
    unsigned int v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1  = v12;
      unsigned int v13 = *v8;
    }

    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2]  = (uint64_t *)((char *)a1[2] + 1);
  }

  return v9;
}

void *Security::BlobCore::clone(Security::BlobCore *this)
{
  size_t v2 = bswap32(*((_DWORD *)this + 1));
  audit_token_t v3 = malloc(v2);
  if (!v3) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  return memcpy(v3, this, v2);
}

const void **Security::CFRef<__SecRequirement *>::~CFRef(const void **a1)
{
  size_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t SecRequirementCreateWithLightweightCodeRequirementData(const __CFData *a1, int a2, void *a3)
{
  if (a2) {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02LL);
  }
  uint64_t result = 4294900227LL;
  if (a1 && a3)
  {
    uint64_t v6 = (unsigned int *)malloc(0x400uLL);
    unint64_t v15 = v6;
    *(void *)uint64_t v6 = 843514LL;
    _DWORD v6[2] = 0x2000000;
    uint64_t v16 = 0xC00000400LL;
    uint64_t BytePtr = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    makeLightweightCodeRequirement(a1);
    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v9) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFC73LL);
    }

    Security::CodeSigning::Requirement::Maker::putData( (Security::CodeSigning::Requirement::Maker *)&v15,  BytePtr,  Length);
    uint64_t v10 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    __int16 v12 = (Security::SecCFObject *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x18,  *(void *)(v10 + 304),  v11);
    unsigned int v13 = v15;
    v15[1]  = bswap32(HIDWORD(v16));
    Security::CodeSigning::SecRequirement::SecRequirement(v12, v13, 1);
    uint64_t v14 = Security::SecCFObject::handle(v12, 1);
    uint64_t result = 0LL;
    *a3  = v14;
  }

  return result;
}

void sub_180624EC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  switch(a2)
  {
    case 7:
      uint64_t v14 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v14, v9);
      __cxa_end_catch();
      goto LABEL_33;
    case 6:
      unint64_t v15 = __cxa_begin_catch(a1);
      if (v15[36] == 8) {
        int v16 = v11 - 16;
      }
      else {
        int v16 = (*(uint64_t (**)(_DWORD *))(*(void *)v15 + 24LL))(v15);
      }
      if (!v9) {
        goto LABEL_32;
      }
      goto LABEL_30;
    case 5:
      std::string v17 = __cxa_begin_catch(a1);
      int v18 = (*(uint64_t (**)(void *))(*(void *)v17 + 24LL))(v17);
      if (v9)
      {
        CFErrorRef v19 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v18, 0LL);
LABEL_31:
        void *v9 = v19;
        goto LABEL_32;
      }

      goto LABEL_32;
  }

  if (a2 != 4)
  {
    if (a2 == 3)
    {
      CFErrorRef v23 = __cxa_begin_catch(a1);
      int v24 = (*(uint64_t (**)(void *))(*(void *)v23 + 24LL))(v23);
      if (v9) {
        void *v9 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v24, 0LL);
      }
    }

    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v9) {
          void *v9 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -108LL, 0LL);
        }
      }

      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v25);
        if (v9) {
          void *v9 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], -67048LL, 0LL);
        }
      }
    }

    goto LABEL_32;
  }

  std::string v20 = __cxa_begin_catch(a1);
  unsigned int v21 = v20[36];
  if (v21 > 0x1A) {
    goto LABEL_28;
  }
  int v22 = 1 << v21;
  int v16 = -67033;
  if ((v22 & 0x800108) != 0) {
    goto LABEL_29;
  }
  if ((v22 & 0x4014000) != 0) {
    int v16 = v11 + 1;
  }
  else {
LABEL_28:
  }
    int v16 = (*(uint64_t (**)(_DWORD *))(*(void *)v20 + 24LL))(v20);
LABEL_29:
  if (v9)
  {
LABEL_30:
    CFErrorRef v19 = CFErrorCreate(0LL, (CFErrorDomain)*MEMORY[0x189604F50], v16, 0LL);
    goto LABEL_31;
  }

void sub_180625120(_Unwind_Exception *a1)
{
}

uint64_t mapFile(const char *a1, const void **a2, off_t *a3, char **a4)
{
  v7.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v7.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v13.st_blkint size = v7;
  *(timespec *)v13.st_qspare  = v7;
  v13.st_birthtimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_int size = v7;
  v13.st_mtimespeCC_SHA512_CTX c = v7;
  v13.st_ctimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_uid  = v7;
  v13.st_atimespeCC_SHA512_CTX c = v7;
  *(timespec *)&v13.st_dev  = v7;
  int v8 = open(a1, 0, 0LL);
  if (v8 == -1)
  {
    __error();
    log_error(a4, "cannot open file %s, errno=%d\n");
  }

  else
  {
    int v9 = v8;
    if (fstat(v8, &v13))
    {
      __error();
      log_error(a4, "fstat(%s) failed, errno=%d\n");
    }

    else
    {
      uint64_t v10 = mmap(0LL, v13.st_size, 1, 8194, v9, 0LL);
      if (v10 != (void *)-1LL)
      {
        int v11 = v10;
        close(v9);
        *a2  = v11;
        *a3  = v13.st_size;
        return 1LL;
      }

      log_error(a4, "cannot mmap file %s\n");
    }
  }

  return 0LL;
}

uint64_t log_error(char **a1, const char *a2, ...)
{
  return vasprintf(a1, a2, va);
}

BOOL vm_alloc(vm_address_t *a1, vm_size_t size, char **a3)
{
  kern_return_t v5;
  vm_address_t address;
  address  = 0LL;
  uint64_t v5 = vm_allocate(*MEMORY[0x1895FBBE0], &address, size, 1);
  if (v5) {
    log_error(a3, "failed to allocate memory\n");
  }
  else {
    *a1  = address;
  }
  return v5 == 0;
}

uint64_t assure_signature_space(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int *a4, char **a5)
{
  int v5 = *a1;
  BOOL v6 = *a1 == -822415874 || v5 == -805638658;
  int v7 = v6;
  unsigned int v8 = a1[3];
  unsigned int v9 = bswap32(v8);
  if (v6) {
    unsigned int v8 = v9;
  }
  if (v8 > 0xB || ((1 << v8) & 0x9C4) == 0)
  {
    log_error(a5, "mach-o filetype (%d) does not support code signing\n");
    return 0LL;
  }

  BOOL v11 = v5 == -805638658 || v5 == -17958193;
  uint64_t v12 = 7LL;
  if (v11) {
    uint64_t v12 = 8LL;
  }
  unsigned int v13 = a1[5];
  unsigned int v14 = bswap32(a1[4]);
  if (v7) {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v15 = a1[4];
  }
  LODWORD(v16)  = bswap32(v13);
  if (v7) {
    uint64_t v16 = v16;
  }
  else {
    uint64_t v16 = v13;
  }
  if (!v15) {
    goto LABEL_68;
  }
  uint64_t v84 = a5;
  int v17 = 0;
  int v18 = 0LL;
  CFErrorRef v19 = 0LL;
  std::string v20 = 0LL;
  unsigned int v21 = (char *)&a1[v12];
  uint64_t v79 = v16;
  int v22 = (_DWORD *)((char *)&a1[v12] + v16);
  CFErrorRef v23 = (char *)&a1[v12];
  do
  {
    unsigned int v24 = *(_DWORD *)v23;
    unsigned int v25 = bswap32(*(_DWORD *)v23);
    if (v7) {
      unsigned int v24 = v25;
    }
    unsigned int v26 = bswap32(*((_DWORD *)v23 + 1));
    if (v7) {
      unsigned int v27 = v26;
    }
    else {
      unsigned int v27 = *((_DWORD *)v23 + 1);
    }
    switch(v24)
    {
      case 1u:
        if (!strcmp(v23 + 8, "__LINKEDIT")) {
          CFErrorRef v19 = v23;
        }
        break;
      case 0x19u:
        if (!strcmp(v23 + 8, "__LINKEDIT")) {
          int v18 = v23;
        }
        break;
      case 0x1Du:
        std::string v20 = v23;
        break;
    }

    v23 += v27;
    if (v23 > (char *)v22)
    {
      log_error(v84, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0LL;
    }

    ++v17;
  }

  while (v15 != v17);
  if (!v19)
  {
    unint64_t v34 = a4;
    a5  = v84;
    unsigned int v35 = a2;
    size_t v36 = a1;
    unsigned int v37 = a3;
    uint64_t v38 = v79;
    if (v18)
    {
      unint64_t v39 = *((void *)v18 + 5);
      unint64_t v40 = *((void *)v18 + 6);
      unint64_t v41 = bswap64(v39);
      if (v7) {
        unint64_t v39 = v41;
      }
      unint64_t v42 = bswap64(v40);
      if (v7) {
        unint64_t v40 = v42;
      }
      BOOL v32 = __CFADD__(v39, v40);
      unint64_t v43 = v39 + v40;
      if (!v32 && v43 <= a3) {
        goto LABEL_60;
      }
LABEL_69:
      log_error(a5, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
      return 0LL;
    }

uint64_t writeFile(const char *a1, char *a2, unsigned int a3, char **a4)
{
  int v7 = open(a1, 1537, 511LL);
  if (v7 == -1)
  {
    __error();
    log_error(a4, "can't open output file for writing: %s, errno=%d\n");
  }

  else
  {
    int v8 = v7;
    uint64_t v9 = 0LL;
    if (a3)
    {
      unint64_t v10 = a3;
      while (1)
      {
        size_t v11 = v10 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v10;
        ssize_t v12 = write(v8, a2, v11);
        if (v12 == -1) {
          break;
        }
        if (v12)
        {
          a2 += v12;
          v9 += v12;
          v10 -= v12;
          if (v10) {
            continue;
          }
        }

        goto LABEL_10;
      }
    }

    else
    {
LABEL_10:
      if (v9 == a3)
      {
        close(v8);
        return 1LL;
      }
    }

    __error();
    log_error(a4, "can't write to output file (len: %d): %s, errno=%d\n");
  }

  return 0LL;
}

BOOL vm_dealloc(void **a1, uint64_t a2, char **a3)
{
  int v5 = MEMORY[0x186E005DC](*MEMORY[0x1895FBBE0], *a1, a2);
  if (v5) {
    log_error(a3, "failed to deallocate memory\n");
  }
  else {
    *a1  = 0LL;
  }
  return v5 == 0;
}

uint64_t remove_signature_space(_DWORD *a1, unsigned int a2, unsigned int *a3, char **a4)
{
  int v4 = *a1;
  BOOL v5 = *a1 == -822415874 || v4 == -805638658;
  int v6 = v5;
  unsigned int v7 = a1[3];
  unsigned int v8 = bswap32(v7);
  if (v5) {
    unsigned int v7 = v8;
  }
  if (v7 > 0xB || ((1 << v7) & 0x9C4) == 0)
  {
    log_error(a4, "mach-o filetype (%d) does not support code signing");
    return 0LL;
  }

  BOOL v10 = v4 == -805638658 || v4 == -17958193;
  uint64_t v11 = 7LL;
  if (v10) {
    uint64_t v11 = 8LL;
  }
  unsigned int v12 = a1[5];
  unsigned int v13 = bswap32(a1[4]);
  if (v6) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = a1[4];
  }
  LODWORD(v15)  = bswap32(v12);
  if (v6) {
    uint64_t v15 = v15;
  }
  else {
    uint64_t v15 = v12;
  }
  if (!v14) {
    goto LABEL_70;
  }
  unsigned int v64 = a4;
  int v16 = 0;
  int v17 = 0LL;
  int v18 = 0LL;
  CFErrorRef v19 = 0LL;
  std::string v20 = (char *)&a1[v11];
  int v60 = v15;
  unsigned int v21 = (char *)&a1[v11] + v15;
  do
  {
    unsigned int v22 = *(_DWORD *)v20;
    unsigned int v23 = bswap32(*(_DWORD *)v20);
    if (v6) {
      unsigned int v22 = v23;
    }
    unsigned int v24 = bswap32(*((_DWORD *)v20 + 1));
    if (v6) {
      unsigned int v25 = v24;
    }
    else {
      unsigned int v25 = *((_DWORD *)v20 + 1);
    }
    switch(v22)
    {
      case 1u:
        if (!strcmp(v20 + 8, "__LINKEDIT")) {
          int v18 = v20;
        }
        break;
      case 0x19u:
        if (!strcmp(v20 + 8, "__LINKEDIT")) {
          int v17 = v20;
        }
        break;
      case 0x1Du:
        CFErrorRef v19 = v20;
        break;
    }

    v20 += v25;
    if (v20 > v21)
    {
      log_error(v64, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0LL;
    }

    ++v16;
  }

  while (v14 != v16);
  if (!v18)
  {
    BOOL v32 = a3;
    a4  = v64;
    unsigned int v33 = a1;
    unsigned int v34 = a2;
    int v35 = v60;
    if (v17)
    {
      unint64_t v36 = *((void *)v17 + 5);
      unint64_t v37 = *((void *)v17 + 6);
      unint64_t v38 = bswap64(v36);
      if (v6) {
        unint64_t v36 = v38;
      }
      unint64_t v39 = bswap64(v37);
      if (v6) {
        unint64_t v37 = v39;
      }
      BOOL v30 = __CFADD__(v36, v37);
      unint64_t v40 = v36 + v37;
      if (v30 || v40 > a2) {
        goto LABEL_71;
      }
      goto LABEL_60;
    }

void *Security::CodeSigning::DiskRep::resourcesRootPath@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18065A197);
}

uint64_t Security::CodeSigning::DiskRep::mainExecutableImage(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

uint64_t Security::CodeSigning::DiskRep::signingBase(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

uint64_t Security::CodeSigning::DiskRep::execSegBase()
{
  return 0LL;
}

CFArrayRef Security::CodeSigning::DiskRep::modifiedFiles(Security::CodeSigning::DiskRep *this)
{
  (*(void (**)(void **__return_ptr))(*(void *)this + 40LL))(__p);
  if (v9 >= 0) {
    size_t v2 = __p;
  }
  else {
    size_t v2 = (void **)__p[0];
  }
  CFURLRef CFURL = Security::makeCFURL((Security *)v2, 0LL, 0LL, v1);
  CFURLRef v5 = CFURL;
  CFURLRef v10 = CFURL;
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  CFArray  = Security::makeCFArray(CFURL, v4, v5);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v10);
  return CFArray;
}

void sub_180625CFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t Security::CodeSigning::DiskRep::copyDiskRepInformation(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

uint64_t Security::CodeSigning::DiskRep::copyStapledTicket(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

void *Security::CodeSigning::DiskRep::explicitIdentifier@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18065A197);
}

uint64_t Security::CodeSigning::DiskRep::defaultResourceRules()
{
  return 0LL;
}

uint64_t Security::CodeSigning::DiskRep::defaultRequirements()
{
  return 0LL;
}

uint64_t Security::CodeSigning::DiskRep::pageSize()
{
  return 0LL;
}

void Security::CodeSigning::DiskRep::strictValidate(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  if ((a4 & 0x100) != 0)
  {
    uint64_t v6 = *(void *)(a3 + 8);
    uint64_t v4 = a3 + 8;
    uint64_t v5 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = v4;
    do
    {
      int v8 = *(_DWORD *)(v5 + 28);
      BOOL v9 = v8 < -67002;
      if (v8 >= -67002) {
        CFURLRef v10 = (uint64_t *)v5;
      }
      else {
        CFURLRef v10 = (uint64_t *)(v5 + 8);
      }
      if (!v9) {
        uint64_t v7 = v5;
      }
      uint64_t v5 = *v10;
    }

    while (*v10);
    if (v7 == v4 || *(int *)(v7 + 28) > -67002) {
LABEL_13:
    }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA46LL);
  }

uint64_t Security::CodeSigning::DiskRep::allowedResourceOmissions(Security::CodeSigning::DiskRep *this)
{
  return 0LL;
}

void Security::CodeSigning::DiskRep::writer(Security::CodeSigning::DiskRep *this)
{
}

uint64_t Security::CodeSigning::DiskRep::Writer::attributes(Security::CodeSigning::DiskRep::Writer *this)
{
  return *((unsigned int *)this + 5);
}

void Security::CodeSigning::DiskRep::Writer::remove(Security::CodeSigning::DiskRep::Writer *this)
{
}

void Security::CodeSigning::DiskRep::~DiskRep(Security::CodeSigning::DiskRep *this)
{
  *(void ++*(void *)this = off_189677970;
}

char *Security::CodeSigning::DiskRep::bestGuess(char *a1, unsigned int *a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a2 && *((_BYTE *)a2 + 24))
  {
LABEL_14:
    unsigned int v48 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v48, a1, 0, 438);
    CFURLRef v10 = (Security::UnixPlusPlus::FileDesc *)v48;
    memset(&v52, 170, 28);
    if (Security::UnixPlusPlus::FileDesc::read( (Security::UnixPlusPlus::FileDesc *)v48,  &v52,  0x1CuLL,  0LL) == 28)
    {
      int v11 = -4;
      do
      {
        BOOL v12 = __CFADD__(v11++, 1);
        if (v12) {
          break;
        }
        st_ino_high  = 0;
        if (v52.st_dev <= -889275715)
        {
          if (v52.st_dev != -1095041334) {
            goto LABEL_24;
          }
        }

        else
        {
          if (v52.st_dev > -822415875)
          {
            if ((v52.st_dev + 17958194) < 2)
            {
              st_ino_high  = HIDWORD(v52.st_ino);
            }

            else if (v52.st_dev == -822415874 || v52.st_dev == -805638658)
            {
              st_ino_high  = bswap32(HIDWORD(v52.st_ino));
            }

            goto LABEL_24;
          }

          if (v52.st_dev != -889275714) {
            goto LABEL_24;
          }
        }
      }

      while (Security::UnixPlusPlus::FileDesc::read(v10, &v52, 0x1CuLL, bswap32(v52.st_uid)) == 28);
    }

    st_ino_high  = 0;
LABEL_24:
    if (st_ino_high > 0xB || ((0x9E4u >> st_ino_high) & 1) == 0)
    {
      v52.st_mtimespec.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
      v16.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
      v16.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v52.st_uid  = v16;
      v52.st_atimespeCC_SHA512_CTX c = v16;
      *(timespec *)&v52.st_dev  = v16;
      if (Security::UnixPlusPlus::FileDesc::read(v10, &v52, 0x38uLL, 0LL) == 56
        && DYLDCache::matchArchitecture((char *)&v52))
      {
        uint64_t v6 = (char *)operator new(0x80uLL);
        std::string::basic_string[abi:ne180100]<0>(&v52, a1);
        Security::CodeSigning::SingleDiskRep::SingleDiskRep((uint64_t)v6, (__int128 *)&v52.st_dev);
        if (SHIBYTE(v52.st_gid) < 0) {
          operator delete(*(void **)&v52.st_dev);
        }
        *(void *)uint64_t v6 = off_1896773F0;
        std::string::basic_string[abi:ne180100]<0>(__p, a1);
        *((_DWORD *)v6 + 14)  = -1;
        int v17 = (int *)(v6 + 56);
        v6[60]  = 0;
        *((void *)v6 + 6)  = off_189676C28;
        if (v51 >= 0) {
          int v18 = __p;
        }
        else {
          int v18 = (void **)__p[0];
        }
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)(v6 + 56), (const char *)v18, 0, 438);
        v19.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        v19.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v52.st_blkint size = v19;
        *(timespec *)v52.st_qspare  = v19;
        *(timespec *)&v52.st_int size = v19;
        v52.st_ctimespeCC_SHA512_CTX c = v19;
        v52.st_birthtimespeCC_SHA512_CTX c = v19;
        v52.st_atimespeCC_SHA512_CTX c = v19;
        v52.st_mtimespeCC_SHA512_CTX c = v19;
        *(timespec *)&v52.st_dev  = v19;
        *(timespec *)&v52.st_uid  = v19;
        Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*v17, &v52);
        st_int size = v52.st_size;
        *((void *)v6 + 9)  = v52.st_size;
        if (!st_size)
        {
          v21.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
          v21.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v52.st_blkint size = v21;
          *(timespec *)v52.st_qspare  = v21;
          *(timespec *)&v52.st_int size = v21;
          v52.st_ctimespeCC_SHA512_CTX c = v21;
          v52.st_birthtimespeCC_SHA512_CTX c = v21;
          v52.st_atimespeCC_SHA512_CTX c = v21;
          v52.st_mtimespeCC_SHA512_CTX c = v21;
          *(timespec *)&v52.st_dev  = v21;
          *(timespec *)&v52.st_uid  = v21;
          Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*v17, &v52);
          st_int size = v52.st_size;
        }

        unsigned int v22 = (char *)mmap(0LL, st_size, 1, 2, *v17, 0LL);
        unsigned int v23 = v22;
        if (v22 == (char *)-1LL)
        {
          uint64_t v47 = *__error();
        }

        else
        {
          *((void *)v6 + _Block_object_dispose(va, 8) = v22;
          unint64_t v24 = *((void *)v6 + 9);
          if (v24 > 0x37)
          {
            *((void *)v6 + 1syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = v22;
            matched  = DYLDCache::matchArchitecture(v22);
            *((void *)v6 + 11)  = matched;
            if (matched)
            {
              int v26 = *((unsigned __int8 *)matched + 34);
              BOOL v27 = v26 == 18;
              v6[96]  = v26 != 18;
              unint64_t v28 = *((void *)v23 + 5);
              unint64_t v29 = bswap64(v28);
              if (!v27) {
                unint64_t v28 = v29;
              }
              *((void *)v6 + 1Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v28;
              unint64_t v30 = *((void *)v23 + 6);
              unint64_t v31 = bswap64(v30);
              if (!v27) {
                unint64_t v30 = v31;
              }
              *((void *)v6 + 14)  = v30;
              BOOL v12 = __CFADD__(v30, v28);
              unint64_t v32 = v30 + v28;
              if (v12 || v32 > v24) {
                Security::UnixError::throwMe((Security::UnixError *)8);
              }
              if (v51 < 0)
              {
                operator delete(__p[0]);
                unint64_t v24 = *((void *)v6 + 9);
                unint64_t v28 = *((void *)v6 + 13);
              }

              *((void *)v6 + 15)  = 0LL;
              if (v24 >= v28 + 8)
              {
                uint64_t v33 = v28 + *((void *)v6 + 8);
                if (v24 >= v28 + bswap32(*(_DWORD *)(v33 + 4))) {
                  *((void *)v6 + 15)  = v33;
                }
              }

              (*(void (**)(stat *__return_ptr, char *))(*(void *)v6 + 40LL))(&v52, v6);
              if (SHIBYTE(v52.st_gid) < 0) {
                operator delete(*(void **)&v52.st_dev);
              }
              goto LABEL_65;
            }
          }

          uint64_t v47 = 8LL;
        }

        Security::UnixError::throwMe((Security::UnixError *)v47);
      }

      uint64_t v6 = (char *)operator new(0x30uLL);
      Security::CodeSigning::FileDiskRep::FileDiskRep((Security::CodeSigning::FileDiskRep *)v6, a1);
LABEL_65:
      Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v48);
      return v6;
    }

    uint64_t v6 = (char *)operator new(0x48uLL);
    std::string::basic_string[abi:ne180100]<0>(&v52, a1);
    Security::CodeSigning::SingleDiskRep::SingleDiskRep((uint64_t)v6, (__int128 *)&v52.st_dev);
    if (SHIBYTE(v52.st_gid) < 0) {
      operator delete(*(void **)&v52.st_dev);
    }
    *(void *)uint64_t v6 = off_189678B88;
    *((void *)v6 + 6)  = &unk_189678CA8;
    *((void *)v6 + _Block_object_dispose(va, 8) = 0LL;
    if (a2)
    {
      if (*((void *)a2 + 2))
      {
        unsigned int v14 = operator new(0x50uLL);
        uint64_t v15 = Security::CodeSigning::SingleDiskRep::fd((Security::CodeSigning::SingleDiskRep *)v6);
        v52.st_dev  = *(_DWORD *)v15;
        LOBYTE(v52.st_mode)  = *((_BYTE *)v15 + 4);
        Security::Universal::Universal((uint64_t)v14, (unsigned int *)&v52, *((void *)a2 + 2), *((void *)a2 + 5));
LABEL_64:
        *((void *)v6 + 7)  = v14;
        goto LABEL_65;
      }

      if (*a2)
      {
        unint64_t v36 = (Security::Universal **)operator new(0x50uLL);
        unint64_t v37 = Security::CodeSigning::SingleDiskRep::fd((Security::CodeSigning::SingleDiskRep *)v6);
        LODWORD(__p[0])  = *(_DWORD *)v37;
        BYTE4(__p[0])  = *((_BYTE *)v37 + 4);
        Security::Universal::Universal((uint64_t)v36, (unsigned int *)__p, 0LL, 0LL);
        unint64_t v38 = operator new(0x50uLL);
        uint64_t v39 = (*(uint64_t (**)(char *))(*(void *)v6 + 144LL))(v6);
        LODWORD(v49)  = *(_DWORD *)v39;
        BYTE4(v49)  = *(_BYTE *)(v39 + 4);
        off_t v40 = Security::Universal::archOffset((Security::Universal *)v36, (const Security::Architecture *)*a2, a2[1]);
        unsigned int v41 = v36[1];
        if (v41)
        {
          unsigned int v42 = v36[4];
          off_t v43 = (off_t)v42
              + *((unsigned int *)Security::Universal::findArch( v41,  (const Security::Architecture *)*((unsigned int *)v36 + 4),  *a2,  a2[1])
                + 3);
        }

        else
        {
          if (*((_DWORD *)v36 + 5) != *a2 || (unsigned int v44 = a2[1], v44 != -1) && ((*((_DWORD *)v36 + 6) ^ v44) & 0xFFFFFF) != 0) {
            Security::UnixError::throwMe((Security::UnixError *)8);
          }
          v45.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
          v45.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v52.st_blkint size = v45;
          *(timespec *)v52.st_qspare  = v45;
          *(timespec *)&v52.st_int size = v45;
          v52.st_ctimespeCC_SHA512_CTX c = v45;
          v52.st_birthtimespeCC_SHA512_CTX c = v45;
          v52.st_atimespeCC_SHA512_CTX c = v45;
          v52.st_mtimespeCC_SHA512_CTX c = v45;
          *(timespec *)&v52.st_dev  = v45;
          *(timespec *)&v52.st_uid  = v45;
          Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v36, &v52);
          off_t v43 = v52.st_size;
        }

        Security::Universal::Universal((uint64_t)v38, (unsigned int *)&v49, v40, v43);
        *((void *)v6 + 7)  = v38;
        free(v36[1]);
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v36[7]);
        operator delete(v36);
        goto LABEL_65;
      }
    }

    unsigned int v14 = operator new(0x50uLL);
    unsigned int v34 = Security::CodeSigning::SingleDiskRep::fd((Security::CodeSigning::SingleDiskRep *)v6);
    v52.st_dev  = *(_DWORD *)v34;
    LOBYTE(v52.st_mode)  = *((_BYTE *)v34 + 4);
    Security::Universal::Universal((uint64_t)v14, (unsigned int *)&v52, 0LL, 0LL);
    goto LABEL_64;
  }

  v4.tv_seCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nseCC_SHA512_CTX c = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v52.st_blkint size = v4;
  *(timespec *)v52.st_qspare  = v4;
  *(timespec *)&v52.st_int size = v4;
  v52.st_ctimespeCC_SHA512_CTX c = v4;
  v52.st_birthtimespeCC_SHA512_CTX c = v4;
  v52.st_atimespeCC_SHA512_CTX c = v4;
  v52.st_mtimespeCC_SHA512_CTX c = v4;
  *(timespec *)&v52.st_dev  = v4;
  *(timespec *)&v52.st_uid  = v4;
  if (stat(a1, &v52))
  {
    unsigned int v46 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v46);
  }

  if ((v52.st_mode & 0xF000) == 0x4000)
  {
    uint64_t v6 = (char *)operator new(0xF0uLL);
    *((_DWORD *)v6 + 2)  = 0;
    *(void *)uint64_t v6 = off_1896775A0;
    *((void *)v6 + 2)  = &unk_1896776C0;
    __p[0]  = Security::makeCFURL((Security *)a1, 0LL, 0LL, v7);
    *((void *)v6 + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = _CFBundleCreateUnique();
    Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
    *((void *)v6 + _Block_object_dispose(va, 8) = 0LL;
    *((void *)v6 + 4)  = 0LL;
    *((void *)v6 + 5)  = 0LL;
    *((void *)v6 + 6)  = 0LL;
    *((_OWORD *)v6 + 5)  = 0u;
    *((_OWORD *)v6 + 6)  = 0u;
    Security::Mutex::Mutex((pthread_mutex_t *)(v6 + 112));
    *((void *)v6 + 27)  = 0LL;
    *((void *)v6 + 24)  = 0LL;
    *((void *)v6 + 2Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v6 + 192;
    *((void *)v6 + 2_Block_object_dispose(va, 8) = 0LL;
    *((void *)v6 + 25)  = 0LL;
    *((void *)v6 + 26)  = v6 + 216;
    v6[232]  = 0;
    if (!*((void *)v6 + 3)) {
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    }
    Security::CodeSigning::BundleDiskRep::setup((uint64_t)v6, (uint64_t)a2);
    v6[232]  = (*(uint64_t (**)(void))(**((void **)v6 + 13) + 248LL))(*((void *)v6 + 13));
    return v6;
  }

  __p[0]  = Security::makeCFURL((Security *)a1, 0LL, 0LL, v5);
  if (!__p[0])
  {
LABEL_13:
    Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
    goto LABEL_14;
  }

  int v8 = (const void *)_CFBundleCreateWithExecutableURLIfMightBeBundle();
  unsigned int v49 = v8;
  if (!v8)
  {
    Security::CFRef<__CFBundle *>::~CFRef(&v49);
    goto LABEL_13;
  }

  uint64_t v6 = (char *)operator new(0xF0uLL);
  *((_DWORD *)v6 + 2)  = 0;
  *(void *)uint64_t v6 = off_1896775A0;
  *((void *)v6 + 2)  = &unk_1896776C0;
  *(_OWORD *)(v6 + 24)  = 0u;
  *((void *)v6 + _Block_object_dispose(va, 8) = 0LL;
  *((_OWORD *)v6 + 5)  = 0u;
  *(_OWORD *)(v6 + 4syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 0u;
  *((_OWORD *)v6 + 6)  = 0u;
  Security::Mutex::Mutex((pthread_mutex_t *)(v6 + 112));
  *((void *)v6 + 27)  = 0LL;
  *((void *)v6 + 24)  = 0LL;
  *((void *)v6 + 2Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v6 + 192;
  *((void *)v6 + 2_Block_object_dispose(va, 8) = 0LL;
  *((void *)v6 + 25)  = 0LL;
  *((void *)v6 + 26)  = v6 + 216;
  CFRetain(v8);
  BOOL v9 = (const void *)*((void *)v6 + 3);
  if (v9) {
    CFRelease(v9);
  }
  *((void *)v6 + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = v8;
  Security::CodeSigning::BundleDiskRep::setup((uint64_t)v6, (uint64_t)a2);
  v6[232]  = (*(uint64_t (**)(void))(**((void **)v6 + 13) + 248LL))(*((void *)v6 + 13));
  Security::CFRef<__CFBundle *>::~CFRef(&v49);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
  return v6;
}

void sub_18062672C( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  *(void *)uint64_t v26 = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(v26 + 40));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v26);
  operator delete((void *)v26);
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&a10);
  if (a2 == 1)
  {
    unint64_t v30 = __cxa_begin_catch(a1);
    __cxa_rethrow();
  }

  JUMPOUT(0x180626A24LL);
}

void sub_180626A10()
{
}

void sub_180626A1C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t Security::CodeSigning::DiskRep::bestFileGuess(char *a1)
{
  return Security::CodeSigning::DiskRep::bestGuess(a1);
}

void Security::CodeSigning::DiskRep::canonicalIdentifier(std::string *a1, std::string *a2)
{
  else {
    std::string __str = *a2;
  }
  std::string::size_type size = __str.__r_.__value_.__s.__size_;
  unsigned __int8 v4 = __str.__r_.__value_.__s.__size_;
  std::string::size_type v6 = __str.__r_.__value_.__l.__size_;
  uint64_t v5 = (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_str  = &__str;
  }
  else {
    p_str  = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v8 = __str.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v8 = __str.__r_.__value_.__l.__size_;
  }
  if (v8)
  {
    while (v8)
    {
      int v9 = p_str->__r_.__value_.__s.__data_[--v8];
      if (v9 == 47)
      {
        if (v8 != -1LL)
        {
          std::string::basic_string(&v20, &__str, v8 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v22);
          std::string __str = v20;
          std::string::size_type size = v20.__r_.__value_.__s.__size_;
          std::string::size_type v6 = v20.__r_.__value_.__l.__size_;
          uint64_t v5 = (std::string *)v20.__r_.__value_.__r.__words[0];
          unsigned __int8 v4 = v20.__r_.__value_.__s.__size_;
        }

        break;
      }
    }
  }

  if ((v4 & 0x80u) != 0) {
    std::string::size_type size = v6;
  }
  else {
    uint64_t v5 = &__str;
  }
  if (size)
  {
    while (size)
    {
      int v10 = v5->__r_.__value_.__s.__data_[--size];
      if (v10 == 46)
      {
        int v11 = (char *)v5 + size;
        std::string::size_type v12 = v11 - (char *)v5;
        std::string::basic_string(&v20, &__str, 0LL, v12, (std::allocator<char> *)&v22);
        std::string __str = v20;
        unsigned __int8 v4 = v20.__r_.__value_.__s.__size_;
        if ((v20.__r_.__value_.__s.__size_ & 0x80) == 0) {
          goto LABEL_26;
        }
        goto LABEL_31;
      }
    }
  }

  if ((v4 & 0x80) != 0)
  {
LABEL_31:
    unsigned int v14 = (std::string *)__str.__r_.__value_.__r.__words[0];
    if (!memchr("0123456789.", *__str.__r_.__value_.__l.__data_, 0xCuLL))
    {
      std::string::size_type v13 = __str.__r_.__value_.__l.__size_;
      goto LABEL_34;
    }

void sub_180626D40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::~FileDiskRep(void **this)
{
  *this  = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

{
  void *v2;
  *this  = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
  operator delete(v2);
}

CFDataRef Security::CodeSigning::FileDiskRep::component( Security::CodeSigning::FileDiskRep *this, Security::CodeSigning::CodeDirectory *a2)
{
  audit_token_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (!v3) {
    return 0LL;
  }
  memset(&__p, 170, sizeof(__p));
  Security::CodeSigning::FileDiskRep::attrName(&__p, v3);
  unsigned __int8 v4 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(void *)this + 144LL))(this);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  ssize_t v6 = fgetxattr(*v4, (const char *)p_p, 0LL, 0LL, 0, 0);
  size_t v7 = v6;
  if (v6 == -1)
  {
    if (*__error() != 93)
    {
      std::string::size_type v12 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v12);
    }
  }

  else if ((v6 & 0x8000000000000000LL) == 0)
  {
    value[0]  = (void *)0xAAAAAAAAAAAAAAAALL;
    value[1]  = (void *)0xAAAAAAAAAAAAAAAALL;
    Security::CFMallocData::CFMallocData((Security::CFMallocData *)value, v6);
    std::string::size_type v8 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(void *)this + 144LL))(this);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v9 = &__p;
    }
    else {
      int v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (fgetxattr(*v8, (const char *)v9, value[0], v7, 0, 0) == -1 && *__error() != 93)
    {
      std::string::size_type v13 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v13);
    }

    CFDataRef v10 = Security::CFMallocData::operator __CFData const*((uint64_t)value);
    if (value[0]) {
      free(value[0]);
    }
    goto LABEL_17;
  }

  CFDataRef v10 = 0LL;
LABEL_17:
  return v10;
}

void sub_180626F58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2 == 1)
  {
    int v18 = *((_DWORD *)__cxa_begin_catch(exception_object) + 36);
    if (v18 != 45 && v18 != 1) {
      __cxa_rethrow();
    }
    __cxa_end_catch();
    JUMPOUT(0x180626F10LL);
  }

  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_180626FAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void *Security::CodeSigning::FileDiskRep::format@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "generic");
}

_DWORD *Security::CodeSigning::FileDiskRep::defaultRequirements( uint64_t a1, uint64_t a2, void (***a3)(void **__return_ptr, void, void **))
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v37[14]  = v4;
  v37[15]  = v4;
  v37[12]  = v4;
  v37[13]  = v4;
  v37[10]  = v4;
  v37[11]  = v4;
  v37[8]  = v4;
  v37[9]  = v4;
  v37[6]  = v4;
  v37[7]  = v4;
  v37[4]  = v4;
  v37[5]  = v4;
  v37[2]  = v4;
  v37[3]  = v4;
  v37[0]  = v4;
  v37[1]  = v4;
  uint64_t v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
  unint64_t v6 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*v5, v37, 0x100uLL, 0LL);
  size_t v7 = 0LL;
  if (v6 < 4 || LOBYTE(v37[0]) != 35 || BYTE1(v37[0]) != 33 || BYTE2(v37[0]) != 47) {
    return v7;
  }
  size_t v7 = (_DWORD *)((char *)v37 + 2);
  uint64_t v8 = 255LL;
  if (v6 != 256) {
    uint64_t v8 = v6;
  }
  *((_BYTE *)v37 + v_Block_object_dispose(va, 8) = 0;
  *((_BYTE *)v37 + strcspn((const char *)v37 + 2, " \t\n\r\f") + 2)  = 0;
  int v9 = (os_log_s *)secLogObjForScope("filediskrep");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p[0])  = 136315138;
    *(void **)((char *)__p + 4)  = (char *)v37 + 2;
    _os_log_debug_impl(&dword_1804F4000, v9, OS_LOG_TYPE_DEBUG, "looks like a script for %s", (uint8_t *)__p, 0xCu);
  }

  if (!BYTE3(v37[0])) {
    return 0LL;
  }
  memset(v26, 170, sizeof(v26));
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)v37 + 2);
  (**a3)(v26, a3, __p);
  if (SBYTE7(v33) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  __int128 v35 = v10;
  __int128 v33 = v10;
  __int128 v34 = v10;
  __int128 v31 = v10;
  *(_OWORD *)std::string __p = v10;
  if (SHIBYTE(v26[2]) >= 0) {
    int v11 = (char *)v26;
  }
  else {
    int v11 = (char *)v26[0];
  }
  __int128 v30 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = (uint64_t *)0xFFFFFFFF00000000LL;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  *(void *)&__int128 v31 = 0LL;
  BYTE8(v31)  = 0;
  LOBYTE(v3syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0) = 1;
  std::string::size_type v12 = Security::CodeSigning::DiskRep::bestGuess(v11, (unsigned int *)&v27);
  Security::Mutex::Mutex((pthread_mutex_t *)&__p[1]);
  if (v12)
  {
    std::string::size_type v13 = (unsigned int *)(v12 + 8);
    do
      unsigned int v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    __p[0]  = v12;
    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v15 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    std::string::size_type v17 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate( (Security::SecCFObject *)0x288,  *(void *)(v15 + 200),  v16);
    Security::CodeSigning::SecStaticCode::SecStaticCode(v17, (Security::CodeSigning::DiskRep *)__p[0], 0);
    int v18 = (unsigned __int8 *)v17 - 8;
    do
      unsigned __int8 v19 = __ldaxr(v18);
    while (__stlxr(1u, v18));
    if ((v19 & 1) != 0)
    {
      std::string v20 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(void *)v17 + 16LL))(v17);
      CFRetain(v20);
    }

    unint64_t v25 = (unint64_t)v17;
    timespec v21 = (Security::BlobCore *)Security::CodeSigning::SecStaticCode::designatedRequirement(v17);
    if (v21)
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = 0LL;
      uint64_t v27 = &v28;
      char v22 = (uint64_t *)Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone(v21);
      Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add( &v27,  1u,  v22);
      size_t v7 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(&v27);
      Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v27);
      Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
      char v23 = 0;
      goto LABEL_27;
    }

    Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
  }

  else
  {
    __p[0]  = 0LL;
  }

  char v23 = 1;
LABEL_27:
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(__p);
  if (SHIBYTE(v26[2]) < 0) {
    operator delete(v26[0]);
  }
  if ((v23 & 1) != 0) {
    return 0LL;
  }
  return v7;
}

void sub_18062730C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t buf, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a2)
  {
    Security::SecCFObject::operator delete(v29);
    Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(&buf);
    if (a16 < 0) {
      operator delete(__p);
    }
    __cxa_begin_catch(exception_object);
    __int128 v31 = (os_log_s *)secLogObjForScope("filediskrep");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf)  = 0;
      _os_log_debug_impl( &dword_1804F4000,  v31,  OS_LOG_TYPE_DEBUG,  "exception getting host requirement (ignored)",  (uint8_t *)&buf,  2u);
    }

    __cxa_end_catch();
    JUMPOUT(0x180627298LL);
  }

  _Unwind_Resume(exception_object);
}

char *Security::CodeSigning::FileDiskRep::writer(Security::CodeSigning::FileDiskRep *this)
{
  size_t v2 = (char *)operator new(0xC8uLL);
  Security::CodeSigning::SingleDiskRep::Writer::Writer((Security::CodeSigning::SingleDiskRep::Writer *)v2, this, 1);
  *(void *)size_t v2 = off_189677BB0;
  *((void *)v2 + 1Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 0LL;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 112));
  *((void *)v2 + 24)  = 0LL;
  *((void *)v2 + 2Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = 0LL;
  *((void *)v2 + 22)  = v2 + 184;
  return v2;
}

void sub_18062745C(_Unwind_Exception *a1)
{
}

void Security::CodeSigning::SingleDiskRep::Writer::~Writer( Security::CodeSigning::SingleDiskRep::Writer *this)
{
  *(void ++*(void *)this = off_189678DC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::SingleDiskRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((void *)this + 3);
}

void Security::CodeSigning::FileDiskRep::Writer::~Writer(char **this)
{
  *this  = (char *)off_189677BB0;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this  = (char *)off_189678DC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);
}

{
  *this  = (char *)off_189677BB0;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this  = (char *)off_189678DC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);
  operator delete(this);
}

void Security::CodeSigning::FileDiskRep::Writer::component( Security::CodeSigning::FileDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  uint64_t v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  Security::CodeSigning::FileDiskRep::attrName(&__p, v5);
  unint64_t v6 = (int *)Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  uint64_t BytePtr = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (fsetxattr(*v6, (const char *)p_p, BytePtr, Length, 0, 0) == -1)
  {
    uint64_t v15 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v15);
  }

  __int128 v10 = (uint64_t **)((char *)this + 176);
  uint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  int v11 = (uint64_t **)std::__tree<std::string>::__find_equal<std::string>((uint64_t)v10, &v17, &__p);
  if (!*v11)
  {
    std::string::size_type v12 = v11;
    std::string::size_type v13 = (uint64_t *)operator new(0x38uLL);
    unsigned int v14 = (std::string *)(v13 + 4);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external(v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }

    else
    {
      *(_OWORD *)&v14->__r_.__value_.__l.__data_  = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      void v13[6] = __p.__r_.__value_.__l.__cap_;
    }

    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at( v10,  v17,  v12,  v13);
  }

void sub_1806276A4( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_180627714()
{
}

void Security::CodeSigning::FileDiskRep::Writer::remove(Security::CodeSigning::FileDiskRep::Writer *this)
{
  size_t v2 = 0LL;
  do
  {
    audit_token_t v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v2);
    if (v3)
    {
      __int128 v4 = v3;
      uint64_t v5 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
      Security::CodeSigning::FileDiskRep::attrName(&__p, v4);
      unint64_t v6 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
      Security::UnixPlusPlus::FileDesc::removeAttr( (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v5,  (const char *)v6);
    }

    size_t v2 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v2 + 1);
  }

  while ((_DWORD)v2 != 12);
  size_t v7 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::CodeSigning::FileDiskRep::attrName(&__p, "CodeSignature");
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p  = &__p;
  }
  else {
    p_p  = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  Security::UnixPlusPlus::FileDesc::removeAttr( (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v7,  (const char *)p_p);
}

void sub_180627808( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::Writer::flush(Security::CodeSigning::FileDiskRep::Writer *this)
{
  size_t v2 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  ssize_t v3 = Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v2, 0LL, 0LL);
  int64_t v4 = v3;
  if (v3)
  {
    if (v3 < 0) {
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = (char *)operator new(v3);
    bzero(v5, v4);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  unint64_t v6 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v6, v5, v4);
  if (v4 >= 1)
  {
    size_t v7 = v5;
    do
    {
      memset(&v11, 170, sizeof(v11));
      std::string::basic_string[abi:ne180100]<0>(&v11, v7);
      size_t v8 = strlen(v7);
      if (!std::string::compare(&v11, 0LL, 0xDuLL, "com.apple.cs.")
        && (void *)((char *)this + 184) == std::__tree<std::string>::find<std::string>((uint64_t)this + 176, &v11))
      {
        int v9 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
        if ((v11.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v10 = &v11;
        }
        else {
          __int128 v10 = (std::string *)v11.__r_.__value_.__r.__words[0];
        }
        Security::UnixPlusPlus::FileDesc::removeAttr( (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v9,  (const char *)v10);
      }

      v7 += v8 + 1;
    }

    while (v7 < &v5[v4]);
  }

  if (v5) {
    operator delete(v5);
  }
}

void sub_180627984( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (v15) {
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::attrName(std::string *this, const char *a2)
{
  std::string::size_type v4 = strlen(a2);
  uint64_t v5 = std::string::append(&v6, a2, v4);
  *this  = *v5;
  v5->__r_.__value_.__l.__size_  = 0LL;
  v5->__r_.__value_.__l.__cap_  = 0LL;
  v5->__r_.__value_.__r.__words[0]  = 0LL;
}

void sub_180627A30( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(void *a1)
{
  size_t v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0]  = a1 + 1;
  v8[1]  = 0xAAAAAAAAAAAAAA01LL;
  ssize_t v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3) {
    Security::UnixError::throwMe(v3);
  }
  if (*a1)
  {
    std::string::size_type v4 = (unsigned int *)(*a1 + 8LL);
    do
    {
      unsigned int v5 = __ldxr(v4);
      unsigned int v6 = v5 - 1;
    }

    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1) {
        (*(void (**)(void))(*(void *)*a1 + 8LL))(*a1);
      }
      *a1  = 0LL;
    }
  }

  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

Security::CodeSigning::FileDiskRep *Security::CodeSigning::FileDiskRep::FileDiskRep( Security::CodeSigning::FileDiskRep *this, char *a2)
{
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  *(void ++*(void *)this = off_189677A98;
  return this;
}

void sub_180627B4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)uint64_t v15 = off_189678F30;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(v15 + 40));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v15);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__SecCertificate *>::~CFRef(const void **a1)
{
  size_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Security::CodeSigning::BlobEditor::~BlobEditor(Security::CodeSigning::BlobEditor *this)
{
  *(void ++*(void *)this = off_189677CD8;
  size_t v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);
}

{
  char *v2;
  void *v3;
  *(void ++*(void *)this = off_189677CD8;
  size_t v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);
  operator delete(v3);
}

void Security::CodeSigning::BlobEditor::component( uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
}

void Security::CodeSigning::BlobEditor::write(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void Security::CodeSigning::BlobEditor::commit( Security::CodeSigning::BlobEditor *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  int v9 = (uint64_t **)((char *)this + 56);
  __int128 v10 = (uint64_t *)Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make( (uint64_t)this + 80,  a2,  a3,  a4,  a5,  a6,  a7,  a8);
  Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add( v9,  0,  v10);
  uint64_t v11 = *((void *)this + 9);
  std::string::size_type v12 = (char *)*((void *)this + 7);
  std::string::size_type v13 = (char *)this + 64;
  if (v12 == (char *)this + 64)
  {
    int v14 = 0;
  }

  else
  {
    int v14 = 0;
    uint64_t v15 = (char *)*((void *)this + 7);
    do
    {
      BOOL v16 = (char *)*((void *)v15 + 1);
      uint64_t v17 = v15;
      if (v16)
      {
        do
        {
          int v18 = v16;
          BOOL v16 = *(char **)v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          int v18 = (char *)*((void *)v17 + 2);
          BOOL v19 = *(void *)v18 == (void)v17;
          uint64_t v17 = v18;
        }

        while (!v19);
      }

      v14 += bswap32(*(_DWORD *)(*((void *)v15 + 5) + 4LL));
      uint64_t v15 = v18;
    }

    while (v18 != v13);
  }

  unsigned int v20 = v14 + 8 * v11 + 12;
  timespec v21 = (Security::BlobCore *)malloc(v20);
  if (!v21) {
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  char v22 = v21;
  *(_DWORD *)timespec v21 = -1056121094;
  *((_DWORD *)v21 + 1)  = bswap32(v20);
  *((_DWORD *)v21 + 2)  = bswap32(v11);
  if (v12 != v13)
  {
    unsigned int v23 = 0;
    unsigned int v24 = 8 * v11 + 12;
    do
    {
      unint64_t v25 = (char *)v22 + 8 * v23;
      *((_DWORD *)v25 + Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(v1 + 3) = bswap32(*((_DWORD *)v12 + 8));
      *((_DWORD *)v25 + 4)  = bswap32(v24);
      memcpy((char *)v22 + v24, *((const void **)v12 + 5), bswap32(*(_DWORD *)(*((void *)v12 + 5) + 4LL)));
      uint64_t v26 = (char *)*((void *)v12 + 1);
      uint64_t v27 = v12;
      if (v26)
      {
        do
        {
          uint64_t v28 = v26;
          uint64_t v26 = *(char **)v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          uint64_t v28 = (char *)*((void *)v27 + 2);
          BOOL v19 = *(void *)v28 == (void)v27;
          uint64_t v27 = v28;
        }

        while (!v19);
      }

      v24 += bswap32(*(_DWORD *)(*((void *)v12 + 5) + 4LL));
      ++v23;
      std::string::size_type v12 = v28;
    }

    while (v28 != v13);
  }

  unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v43[7]  = v29;
  DERSize v43[8] = v29;
  v43[5]  = v29;
  v43[6]  = v29;
  v43[3]  = v29;
  v43[4]  = v29;
  v43[1]  = v29;
  v43[2]  = v29;
  v43[0]  = v29;
  __int128 v41 = v29;
  __int128 v42 = v29;
  v39[3]  = v29;
  *(_OWORD *)std::string __p = v29;
  v39[1]  = v29;
  _OWORD v39[2] = v29;
  v39[0]  = v29;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v39);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)"Maker ", 6LL);
  __int128 v30 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)" assembles ", 11LL);
  __int128 v31 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)" blob(s) into ", 14LL);
  unint64_t v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)" (size=", 7LL);
  __int128 v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)")", 1LL);
  __int128 v34 = (os_log_s *)secLogObjForScope("superblob");
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v39 + 8);
    unint64_t v36 = v38 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)stat buf = 136315138;
    unsigned int v46 = v36;
    _os_log_debug_impl(&dword_1804F4000, v34, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v38 < 0) {
      operator delete(__dst[0]);
    }
  }

  *(void *)&v39[0]  = *MEMORY[0x189614738];
  *(void *)((char *)v39 + *(void *)(*(void *)&v39[0] - 24LL))  = *(void *)(MEMORY[0x189614738] + 24LL);
  *((void *)&v39[0] + 1)  = MEMORY[0x189614750] + 16LL;
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](v43);
  Security::CodeSigning::SecCodeSigner::returnDetachedSignature(*(CFTypeRef **)(*((void *)this + 6) + 8LL), v22, v35);
  free(v22);
}

void sub_180627FE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30)
{
  a13  = *MEMORY[0x189614738];
  *(uint64_t *)((char *)&a13 + *(void *)(a13 - 24))  = *(void *)(MEMORY[0x189614738] + 24LL);
  a14  = MEMORY[0x189614750] + 16LL;
  if (a27 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DFEA1C](&a30);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::ArchEditor::~ArchEditor(Security::CodeSigning::ArchEditor *this)
{
  *(void ++*(void *)this = off_189677C28;
  size_t v2 = (char *)*((void *)this + 3);
  ssize_t v3 = (char *)this + 32;
  if (v2 != (char *)this + 32)
  {
    do
    {
      uint64_t v4 = *((void *)v2 + 5);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      }
      char v5 = (char *)*((void *)v2 + 1);
      if (v5)
      {
        do
        {
          unsigned int v6 = v5;
          char v5 = *(char **)v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          unsigned int v6 = (char *)*((void *)v2 + 2);
          BOOL v7 = *(void *)v6 == (void)v2;
          size_t v2 = v6;
        }

        while (!v7);
      }

      size_t v2 = v6;
    }

    while (v6 != v3);
  }

  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((void **)this + 4));
}